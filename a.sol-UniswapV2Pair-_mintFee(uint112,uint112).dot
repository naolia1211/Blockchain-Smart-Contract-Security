digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: NEW VARIABLE 1

EXPRESSION:
feeTo = IUniswapV2Factory(factory).feeTo()

IRs:
TMP_146 = CONVERT factory to IUniswapV2Factory
TMP_147(address) = HIGH_LEVEL_CALL, dest:TMP_146(IUniswapV2Factory), function:feeTo, arguments:[]  
feeTo(address) := TMP_147(address)"];
1->2;
2[label="Node Type: EXPRESSION 2

EXPRESSION:
feeOn = feeTo != address(0)

IRs:
TMP_148 = CONVERT 0 to address
TMP_149(bool) = feeTo != TMP_148
feeOn(bool) := TMP_149(bool)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
_kLast = kLast

IRs:
_kLast(uint256) := kLast(uint256)"];
3->4;
4[label="Node Type: IF 4

EXPRESSION:
feeOn

IRs:
CONDITION feeOn"];
4->5[label="True"];
4->17[label="False"];
5[label="Node Type: IF 5

EXPRESSION:
_kLast != 0

IRs:
TMP_150(bool) = _kLast != 0
CONDITION TMP_150"];
5->6[label="True"];
5->16[label="False"];
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1))

IRs:
TMP_151 = CONVERT _reserve0 to uint256
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['TMP_151', '_reserve1'] 
TMP_153(uint256) = LIBRARY_CALL, dest:Math, function:Math.sqrt(uint256), arguments:['TMP_152'] 
rootK(uint256) := TMP_153(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
rootKLast = Math.sqrt(_kLast)

IRs:
TMP_154(uint256) = LIBRARY_CALL, dest:Math, function:Math.sqrt(uint256), arguments:['_kLast'] 
rootKLast(uint256) := TMP_154(uint256)"];
7->8;
8[label="Node Type: IF 8

EXPRESSION:
rootK > rootKLast

IRs:
TMP_155(bool) = rootK > rootKLast
CONDITION TMP_155"];
8->9[label="True"];
8->15[label="False"];
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
numerator = totalSupply.mul(rootK.sub(rootKLast))

IRs:
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.sub(uint256,uint256), arguments:['rootK', 'rootKLast'] 
TMP_157(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['totalSupply', 'TMP_156'] 
numerator(uint256) := TMP_157(uint256)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
denominator = rootK.mul(5).add(rootKLast)

IRs:
TMP_158(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['rootK', '5'] 
TMP_159(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.add(uint256,uint256), arguments:['TMP_158', 'rootKLast'] 
denominator(uint256) := TMP_159(uint256)"];
10->11;
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
liquidity = numerator / denominator

IRs:
TMP_160(uint256) = numerator / denominator
liquidity(uint256) := TMP_160(uint256)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
liquidity > 0

IRs:
TMP_161(bool) = liquidity > 0
CONDITION TMP_161"];
12->13[label="True"];
12->14[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
_mint(feeTo,liquidity)

IRs:
INTERNAL_CALL, UniswapV2ERC20._mint(address,uint256)(feeTo,liquidity)"];
13->14;
14[label="Node Type: END_IF 14
"];
14->15;
15[label="Node Type: END_IF 15
"];
15->16;
16[label="Node Type: END_IF 16
"];
16->20;
17[label="Node Type: IF 17

EXPRESSION:
_kLast != 0

IRs:
TMP_163(bool) = _kLast != 0
CONDITION TMP_163"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
kLast = 0

IRs:
kLast(uint256) := 0(uint256)"];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: END_IF 20
"];
}
