digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->30;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(amount0Out > 0 || amount1Out > 0,UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT)

IRs:
TMP_237(bool) = amount0Out > 0
TMP_238(bool) = amount1Out > 0
TMP_239(bool) = TMP_237 || TMP_238
TMP_240(None) = SOLIDITY_CALL require(bool,string)(TMP_239,UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT)"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: NEW VARIABLE 3
"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
(_reserve0,_reserve1) = getReserves()

IRs:
TUPLE_3(uint112,uint112,uint32) = INTERNAL_CALL, UniswapV2Pair.getReserves()()
_reserve0(uint112)= UNPACK TUPLE_3 index: 0 
_reserve1(uint112)= UNPACK TUPLE_3 index: 1 "];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(amount0Out < _reserve0 && amount1Out < _reserve1,UniswapV2: INSUFFICIENT_LIQUIDITY)

IRs:
TMP_241(bool) = amount0Out < _reserve0
TMP_242(bool) = amount1Out < _reserve1
TMP_243(bool) = TMP_241 && TMP_242
TMP_244(None) = SOLIDITY_CALL require(bool,string)(TMP_243,UniswapV2: INSUFFICIENT_LIQUIDITY)"];
5->6;
6[label="Node Type: NEW VARIABLE 6
"];
6->7;
7[label="Node Type: NEW VARIABLE 7
"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
_token0 = token0

IRs:
_token0(address) := token0(address)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
_token1 = token1

IRs:
_token1(address) := token1(address)"];
9->10;
10[label="Node Type: EXPRESSION 10

EXPRESSION:
require(bool,string)(to != _token0 && to != _token1,UniswapV2: INVALID_TO)

IRs:
TMP_245(bool) = to != _token0
TMP_246(bool) = to != _token1
TMP_247(bool) = TMP_245 && TMP_246
TMP_248(None) = SOLIDITY_CALL require(bool,string)(TMP_247,UniswapV2: INVALID_TO)"];
10->11;
11[label="Node Type: IF 11

EXPRESSION:
amount0Out > 0

IRs:
TMP_249(bool) = amount0Out > 0
CONDITION TMP_249"];
11->12[label="True"];
11->13[label="False"];
12[label="Node Type: EXPRESSION 12

EXPRESSION:
_safeTransfer(_token0,to,amount0Out)

IRs:
INTERNAL_CALL, UniswapV2Pair._safeTransfer(address,address,uint256)(_token0,to,amount0Out)"];
12->13;
13[label="Node Type: END_IF 13
"];
13->14;
14[label="Node Type: IF 14

EXPRESSION:
amount1Out > 0

IRs:
TMP_251(bool) = amount1Out > 0
CONDITION TMP_251"];
14->15[label="True"];
14->16[label="False"];
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_safeTransfer(_token1,to,amount1Out)

IRs:
INTERNAL_CALL, UniswapV2Pair._safeTransfer(address,address,uint256)(_token1,to,amount1Out)"];
15->16;
16[label="Node Type: END_IF 16
"];
16->17;
17[label="Node Type: IF 17

EXPRESSION:
data.length > 0

IRs:
REF_91 -> LENGTH data
TMP_253(bool) = REF_91 > 0
CONDITION TMP_253"];
17->18[label="True"];
17->19[label="False"];
18[label="Node Type: EXPRESSION 18

EXPRESSION:
IUniswapV2Callee(to).uniswapV2Call(msg.sender,amount0Out,amount1Out,data)

IRs:
TMP_254 = CONVERT to to IUniswapV2Callee
HIGH_LEVEL_CALL, dest:TMP_254(IUniswapV2Callee), function:uniswapV2Call, arguments:['msg.sender', 'amount0Out', 'amount1Out', 'data']  "];
18->19;
19[label="Node Type: END_IF 19
"];
19->20;
20[label="Node Type: EXPRESSION 20

EXPRESSION:
balance0 = IERC20Uniswap(_token0).balanceOf(address(this))

IRs:
TMP_256 = CONVERT _token0 to IERC20Uniswap
TMP_257 = CONVERT this to address
TMP_258(uint256) = HIGH_LEVEL_CALL, dest:TMP_256(IERC20Uniswap), function:balanceOf, arguments:['TMP_257']  
balance0(uint256) := TMP_258(uint256)"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
balance1 = IERC20Uniswap(_token1).balanceOf(address(this))

IRs:
TMP_259 = CONVERT _token1 to IERC20Uniswap
TMP_260 = CONVERT this to address
TMP_261(uint256) = HIGH_LEVEL_CALL, dest:TMP_259(IERC20Uniswap), function:balanceOf, arguments:['TMP_260']  
balance1(uint256) := TMP_261(uint256)"];
21->31;
24[label="Node Type: EXPRESSION 24

EXPRESSION:
require(bool,string)(amount0In > 0 || amount1In > 0,UniswapV2: INSUFFICIENT_INPUT_AMOUNT)

IRs:
TMP_262(bool) = amount0In > 0
TMP_263(bool) = amount1In > 0
TMP_264(bool) = TMP_262 || TMP_263
TMP_265(None) = SOLIDITY_CALL require(bool,string)(TMP_264,UniswapV2: INSUFFICIENT_INPUT_AMOUNT)"];
24->25;
25[label="Node Type: NEW VARIABLE 25

EXPRESSION:
balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3))

IRs:
TMP_266(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['balance0', '1000'] 
TMP_267(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['amount0In', '3'] 
TMP_268(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.sub(uint256,uint256), arguments:['TMP_266', 'TMP_267'] 
balance0Adjusted(uint256) := TMP_268(uint256)"];
25->26;
26[label="Node Type: NEW VARIABLE 26

EXPRESSION:
balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3))

IRs:
TMP_269(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['balance1', '1000'] 
TMP_270(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['amount1In', '3'] 
TMP_271(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.sub(uint256,uint256), arguments:['TMP_269', 'TMP_270'] 
balance1Adjusted(uint256) := TMP_271(uint256)"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
require(bool,string)(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),UniswapV2: K)

IRs:
TMP_272(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['balance0Adjusted', 'balance1Adjusted'] 
TMP_273 = CONVERT _reserve0 to uint256
TMP_274(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['TMP_273', '_reserve1'] 
TMP_275(uint256) = 1000 ** 2
TMP_276(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['TMP_274', 'TMP_275'] 
TMP_277(bool) = TMP_272 >= TMP_276
TMP_278(None) = SOLIDITY_CALL require(bool,string)(TMP_277,UniswapV2: K)"];
27->28;
28[label="Node Type: EXPRESSION 28

EXPRESSION:
_update(balance0,balance1,_reserve0,_reserve1)

IRs:
INTERNAL_CALL, UniswapV2Pair._update(uint256,uint256,uint112,uint112)(balance0,balance1,_reserve0,_reserve1)"];
28->29;
29[label="Node Type: EXPRESSION 29

EXPRESSION:
Swap(msg.sender,amount0In,amount1In,amount0Out,amount1Out,to)

IRs:
Emit Swap(msg.sender,amount0In,amount1In,amount0Out,amount1Out,to)"];
30[label="Node Type: EXPRESSION 30

EXPRESSION:
lock()

IRs:
MODIFIER_CALL, UniswapV2Pair.lock()()"];
30->1;
31[label="Node Type: IF 31

EXPRESSION:
balance0 > _reserve0 - amount0Out

IRs:
TMP_282(uint112) = _reserve0 - amount0Out
TMP_283(bool) = balance0 > TMP_282
CONDITION TMP_283"];
31->32[label="True"];
31->33[label="False"];
32[label="Node Type: EXPRESSION 32

EXPRESSION:
amount0In = balance0 - (_reserve0 - amount0Out)

IRs:
TMP_284(uint112) = _reserve0 - amount0Out
TMP_285(uint256) = balance0 - TMP_284
amount0In(uint256) := TMP_285(uint256)"];
32->34;
33[label="Node Type: EXPRESSION 33

EXPRESSION:
amount0In = 0

IRs:
amount0In(uint256) := 0(uint256)"];
33->34;
34[label="Node Type: END_IF 34
"];
34->35;
35[label="Node Type: IF 35

EXPRESSION:
balance1 > _reserve1 - amount1Out

IRs:
TMP_286(uint112) = _reserve1 - amount1Out
TMP_287(bool) = balance1 > TMP_286
CONDITION TMP_287"];
35->36[label="True"];
35->37[label="False"];
36[label="Node Type: EXPRESSION 36

EXPRESSION:
amount1In = balance1 - (_reserve1 - amount1Out)

IRs:
TMP_288(uint112) = _reserve1 - amount1Out
TMP_289(uint256) = balance1 - TMP_288
amount1In(uint256) := TMP_289(uint256)"];
36->38;
37[label="Node Type: EXPRESSION 37

EXPRESSION:
amount1In = 0

IRs:
amount1In(uint256) := 0(uint256)"];
37->38;
38[label="Node Type: END_IF 38
"];
38->24;
}
