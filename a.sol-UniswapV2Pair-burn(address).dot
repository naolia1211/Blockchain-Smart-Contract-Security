digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->24;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
(_reserve0,_reserve1) = getReserves()

IRs:
TUPLE_2(uint112,uint112,uint32) = INTERNAL_CALL, UniswapV2Pair.getReserves()()
_reserve0(uint112)= UNPACK TUPLE_2 index: 0 
_reserve1(uint112)= UNPACK TUPLE_2 index: 1 "];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
_token0 = token0

IRs:
_token0(address) := token0(address)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
_token1 = token1

IRs:
_token1(address) := token1(address)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
balance0 = IERC20Uniswap(_token0).balanceOf(address(this))

IRs:
TMP_206 = CONVERT _token0 to IERC20Uniswap
TMP_207 = CONVERT this to address
TMP_208(uint256) = HIGH_LEVEL_CALL, dest:TMP_206(IERC20Uniswap), function:balanceOf, arguments:['TMP_207']  
balance0(uint256) := TMP_208(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
balance1 = IERC20Uniswap(_token1).balanceOf(address(this))

IRs:
TMP_209 = CONVERT _token1 to IERC20Uniswap
TMP_210 = CONVERT this to address
TMP_211(uint256) = HIGH_LEVEL_CALL, dest:TMP_209(IERC20Uniswap), function:balanceOf, arguments:['TMP_210']  
balance1(uint256) := TMP_211(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
liquidity = balanceOf[address(this)]

IRs:
TMP_212 = CONVERT this to address
REF_85(uint256) -> balanceOf[TMP_212]
liquidity(uint256) := REF_85(uint256)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
feeOn = _mintFee(_reserve0,_reserve1)

IRs:
TMP_213(bool) = INTERNAL_CALL, UniswapV2Pair._mintFee(uint112,uint112)(_reserve0,_reserve1)
feeOn(bool) := TMP_213(bool)"];
9->10;
10[label="Node Type: NEW VARIABLE 10

EXPRESSION:
_totalSupply = totalSupply

IRs:
_totalSupply(uint256) := totalSupply(uint256)"];
10->11;
11[label="Node Type: EXPRESSION 11

EXPRESSION:
amount0 = liquidity.mul(balance0) / _totalSupply

IRs:
TMP_214(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['liquidity', 'balance0'] 
TMP_215(uint256) = TMP_214 / _totalSupply
amount0(uint256) := TMP_215(uint256)"];
11->12;
12[label="Node Type: EXPRESSION 12

EXPRESSION:
amount1 = liquidity.mul(balance1) / _totalSupply

IRs:
TMP_216(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['liquidity', 'balance1'] 
TMP_217(uint256) = TMP_216 / _totalSupply
amount1(uint256) := TMP_217(uint256)"];
12->13;
13[label="Node Type: EXPRESSION 13

EXPRESSION:
require(bool,string)(amount0 > 0 && amount1 > 0,UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED)

IRs:
TMP_218(bool) = amount0 > 0
TMP_219(bool) = amount1 > 0
TMP_220(bool) = TMP_218 && TMP_219
TMP_221(None) = SOLIDITY_CALL require(bool,string)(TMP_220,UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
_burn(address(this),liquidity)

IRs:
TMP_222 = CONVERT this to address
INTERNAL_CALL, UniswapV2ERC20._burn(address,uint256)(TMP_222,liquidity)"];
14->15;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
_safeTransfer(_token0,to,amount0)

IRs:
INTERNAL_CALL, UniswapV2Pair._safeTransfer(address,address,uint256)(_token0,to,amount0)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
_safeTransfer(_token1,to,amount1)

IRs:
INTERNAL_CALL, UniswapV2Pair._safeTransfer(address,address,uint256)(_token1,to,amount1)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
balance0 = IERC20Uniswap(_token0).balanceOf(address(this))

IRs:
TMP_226 = CONVERT _token0 to IERC20Uniswap
TMP_227 = CONVERT this to address
TMP_228(uint256) = HIGH_LEVEL_CALL, dest:TMP_226(IERC20Uniswap), function:balanceOf, arguments:['TMP_227']  
balance0(uint256) := TMP_228(uint256)"];
17->18;
18[label="Node Type: EXPRESSION 18

EXPRESSION:
balance1 = IERC20Uniswap(_token1).balanceOf(address(this))

IRs:
TMP_229 = CONVERT _token1 to IERC20Uniswap
TMP_230 = CONVERT this to address
TMP_231(uint256) = HIGH_LEVEL_CALL, dest:TMP_229(IERC20Uniswap), function:balanceOf, arguments:['TMP_230']  
balance1(uint256) := TMP_231(uint256)"];
18->19;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
_update(balance0,balance1,_reserve0,_reserve1)

IRs:
INTERNAL_CALL, UniswapV2Pair._update(uint256,uint256,uint112,uint112)(balance0,balance1,_reserve0,_reserve1)"];
19->20;
20[label="Node Type: IF 20

EXPRESSION:
feeOn

IRs:
CONDITION feeOn"];
20->21[label="True"];
20->22[label="False"];
21[label="Node Type: EXPRESSION 21

EXPRESSION:
kLast = uint256(reserve0).mul(reserve1)

IRs:
TMP_233 = CONVERT reserve0 to uint256
TMP_234(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['TMP_233', 'reserve1'] 
kLast(uint256) := TMP_234(uint256)"];
21->22;
22[label="Node Type: END_IF 22
"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
Burn(msg.sender,amount0,amount1,to)

IRs:
Emit Burn(msg.sender,amount0,amount1,to)"];
24[label="Node Type: EXPRESSION 24

EXPRESSION:
lock()

IRs:
MODIFIER_CALL, UniswapV2Pair.lock()()"];
24->1;
}
