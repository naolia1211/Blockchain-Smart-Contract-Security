[{
  "_id": {
    "$oid": "663b8b87f879b20b736a9a68"
  },
  "filename": "10726.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Main0003_setupSBSigners {\n StabilityBoardProxy constant\n stabilityBoardProxy = StabilityBoardProxy(0x4686f017D456331ed2C1de66e134D8d05B24413D);\n function execute(Main0003_setupSBSigners ) external {\n address[] memory signersToAdd = new address[](3);\n signersToAdd[0] = 0x9de3F6E7caCbb7e1c2489dFCe21abbB0ecEE6213;\n signersToAdd[1] = 0xAE162e28575Ba898dc08D283f2Be10AE8b4114A2;\n signersToAdd[2] = 0x53DBF6E8fe46307C7536eAbb0D90CADA3e732716;\n stabilityBoardProxy.addSigners(signersToAdd);\n address[] memory signersToRemove = new address[](1);\n signersToRemove[0] = 0x7b534c2D0F9Ee973e0b6FE8D4000cA711A20f22e;\n stabilityBoardProxy.removeSigners(signersToRemove);\n }\n}\ncontract MultiSig {\n using SafeMath for uint256;\n uint public constant CHUNK_SIZE = 100;\n mapping(address => bool) public isSigner;\n address[] public allSigners;\n uint public activeSignersCount;\n enum ScriptState {New, Approved, Done, Cancelled, Failed}\n struct Script {\n ScriptState state;\n uint signCount;\n mapping(address => bool) signedBy;\n address[] allSigners;\n }\n mapping(address => Script) public scripts;\n address[] public scriptAddresses;\n event SignerAdded(address signer);\n event SignerRemoved(address signer);\n event ScriptSigned(address scriptAddress, address signer);\n event ScriptApproved(address scriptAddress);\n event ScriptCancelled(address scriptAddress);\n event ScriptExecuted(address scriptAddress, bool result);\n constructor() public {\n isSigner[msg.sender] = true;\n allSigners.push(msg.sender);\n activeSignersCount = 1;\n emit SignerAdded(msg.sender);\n }\n function sign(address scriptAddress) public {\n require(isSigner[msg.sender], \"sender must be signer\");\n Script storage script = scripts[scriptAddress];\n require(script.state == ScriptState.Approved || script.state == ScriptState.New,\n \"script state must be New or Approved\");\n require(!script.signedBy[msg.sender], \"script must not be signed by signer yet\");\n if(script.allSigners.length == 0) {\n scriptAddresses.push(scriptAddress);\n }\n script.allSigners.push(msg.sender);\n script.signedBy[msg.sender] = true;\n script.signCount = script.signCount.add(1);\n emit ScriptSigned(scriptAddress, msg.sender);\n if(checkQuorum(script.signCount)){\n script.state = ScriptState.Approved;\n emit ScriptApproved(scriptAddress);\n }\n }\n function execute(address scriptAddress) public returns (bool result) {\n require(isSigner[msg.sender], \"sender must be signer\");\n Script storage script = scripts[scriptAddress];\n require(script.state == ScriptState.Approved, \"script state must be Approved\");\n script.state = ScriptState.Failed;\n if(scriptAddress.delegatecall(bytes4(keccak256(\"execute(address)\")), scriptAddress)) {\n script.state = ScriptState.Done;\n result = true;\n } else {\n result = false;\n }\n emit ScriptExecuted(scriptAddress, result);\n }\n function cancelScript(address scriptAddress) public {\n require(msg.sender == address(this), \"only callable via MultiSig\");\n Script storage script = scripts[scriptAddress];\n require(script.state == ScriptState.Approved || script.state == ScriptState.New,\n \"script state must be New or Approved\");\n script.state= ScriptState.Cancelled;\n emit ScriptCancelled(scriptAddress);\n }\n function addSigners(address[] signers) public {\n require(msg.sender == address(this), \"only callable via MultiSig\");\n for (uint i= 0; i < signers.length; i++) {\n if (!isSigner[signers[i]]) {\n require(signers[i] != address(0), \"new signer must not be 0x0\");\n activeSignersCount++;\n allSigners.push(signers[i]);\n isSigner[signers[i]] = true;\n emit SignerAdded(signers[i]);\n }\n }\n }\n function removeSigners(address[] signers) public {\n require(msg.sender == address(this), \"only callable via MultiSig\");\n for (uint i= 0; i < signers.length; i++) {\n if (isSigner[signers[i]]) {\n require(activeSignersCount > 1, \"must not remove last signer\");\n activeSignersCount--;\n isSigner[signers[i]] = false;\n emit SignerRemoved(signers[i]);\n }\n }\n }\n function checkQuorum(uint signersCount) internal view returns(bool isQuorum);\n function getAllSignersCount() view external returns (uint allSignersCount) {\n return allSigners.length;\n }\n function getAllSigners(uint offset) external view returns(uint[3][CHUNK_SIZE] signersResult) {\n for (uint8 i = 0; i < CHUNK_SIZE && i + offset < allSigners.length; i++) {\n address signerAddress = allSigners[i + offset];\n signersResult[i] = [ i + offset, uint(signerAddress), isSigner[signerAddress] ? 1 : 0 ];\n }\n }\n function getScriptsCount() view external returns (uint scriptsCount) {\n return scriptAddresses.length;\n }\n function getAllScripts(uint offset) external view returns(uint[4][CHUNK_SIZE] scriptsResult) {\n for (uint8 i = 0; i < CHUNK_SIZE && i + offset < scriptAddresses.length; i++) {\n address scriptAddress = scriptAddresses[i + offset];\n scriptsResult[i] = [ i + offset, uint(scriptAddress), uint(scripts[scriptAddress].state),\n scripts[scriptAddress].signCount ];\n }\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n require(a == 0 || c / a == b, \"mul overflow\");\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b > 0, \"div by 0\");\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a, \"sub underflow\");\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"add overflow\");\n return c;\n }\n function roundedDiv(uint a, uint b) internal pure returns (uint256) {\n require(b > 0, \"div by 0\");\n uint256 z = a / b;\n if (a % b >= b / 2) {\n z++;\n }\n return z;\n }\n}\ncontract StabilityBoardProxy is MultiSig {\n function checkQuorum(uint signersCount) internal view returns(bool isQuorum) {\n isQuorum = signersCount > activeSignersCount / 2 ;\n }\n}",
  "extract_feature": [
    "function execute(address scriptAddress) public returns (bool result) {\nrequire(isSigner[msg.sender], \"sender must be signer\");\nScript storage script = scripts[scriptAddress];\nrequire(script.state == ScriptState.Approved, \"script state must be Approved\");\nscript.state = ScriptState.Failed;\nif(scriptAddress.delegatecall(bytes4(keccak256(\"execute(address)\")), scriptAddress)) {\nscript.state = ScriptState.Done;\nresult = true;\n} else {\nresult = false;\n}\nemit ScriptExecuted(scriptAddress, result);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b87f879b20b736a9a69"
  },
  "filename": "1138.sol",
  "content": "pragma solidity ^0.4.23;\ncontract Destroy{\n function delegatecall_selfdestruct(address _target) external returns (bool _ans) {\n _ans = _target.delegatecall(bytes4(sha3(\"address)\")), this);\n }\n}",
  "extract_feature": [
    "function delegatecall_selfdestruct(address _target) external returns (bool _ans) {\n_ans = _target.delegatecall(bytes4(sha3(\"address)\")), this);\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b87f879b20b736a9a6a"
  },
  "filename": "13000.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Ownable {\n address public owner;\n address public newOwnerCandidate;\n event OwnershipRequested(address indexed by, address indexed to);\n event OwnershipTransferred(address indexed from, address indexed to);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyOwnerCandidate() {\n require(msg.sender == newOwnerCandidate);\n _;\n }\n function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n require(_newOwnerCandidate != address(0));\n newOwnerCandidate = _newOwnerCandidate;\n OwnershipRequested(msg.sender, newOwnerCandidate);\n }\n function acceptOwnership() external onlyOwnerCandidate {\n address previousOwner = owner;\n owner = newOwnerCandidate;\n newOwnerCandidate = address(0);\n OwnershipTransferred(previousOwner, owner);\n }\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n require(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a < b ? a : b;\n }\n function toPower2(uint256 a) internal pure returns (uint256) {\n return mul(a, a);\n }\n function sqrt(uint256 a) internal pure returns (uint256) {\n uint256 c = (a + 1) / 2;\n uint256 b = a;\n while (c < b) {\n b = c;\n c = (a / c + c) / 2;\n }\n return b;\n }\n}\ncontract ERC20 {\n uint public totalSupply;\n function balanceOf(address _owner) constant public returns (uint balance);\n function transfer(address _to, uint _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n function approve(address _spender, uint _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint remaining);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract BasicToken is ERC20 {\n using SafeMath for uint256;\n uint256 public totalSupply;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => uint256) balances;\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n function approve(address _spender, uint256 _value) public returns (bool) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\n revert();\n }\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n uint256 _allowance = allowed[_from][msg.sender];\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok);\n}\ncontract ERC677 is ERC20 {\n function transferAndCall(address to, uint value, bytes data) public returns (bool ok);\n event TransferAndCall(address indexed from, address indexed to, uint value, bytes data);\n}\ncontract Standard677Token is ERC677, BasicToken {\n function transferAndCall(address _to, uint _value, bytes _data) public returns (bool) {\n require(super.transfer(_to, _value));\n TransferAndCall(msg.sender, _to, _value, _data);\n if (isContract(_to)) return contractFallback(_to, _value, _data);\n return true;\n }\n function contractFallback(address _to, uint _value, bytes _data) private returns (bool) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n require(receiver.tokenFallback(msg.sender, _value, _data));\n return true;\n }\n function isContract(address _addr) private constant returns (bool is_contract) {\n uint length;\n assembly { length := extcodesize(_addr) }\n return length > 0;\n }\n}\ncontract TokenHolder is Ownable {\n function transferAnyERC20Token(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {\n return ERC20(_tokenAddress).transfer(owner, _amount);\n }\n}\ncontract ColuLocalCurrency is Ownable, Standard677Token, TokenHolder {\n using SafeMath for uint256;\n string public name;\n string public symbol;\n uint8 public decimals;\n string public tokenURI;\n event TokenURIChanged(string newTokenURI);\n function ColuLocalCurrency(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, string _tokenURI) public {\n require(_totalSupply != 0);\n require(bytes(_name).length != 0);\n require(bytes(_symbol).length != 0);\n totalSupply = _totalSupply;\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n tokenURI = _tokenURI;\n balances[msg.sender] = totalSupply;\n }\n function setTokenURI(string _tokenURI) public onlyOwner {\n tokenURI = _tokenURI;\n TokenURIChanged(_tokenURI);\n }\n}\ncontract Standard223Receiver is ERC223Receiver {\n Tkn tkn;\n struct Tkn {\n address addr;\n address sender;\n uint256 value;\n }\n bool __isTokenFallback;\n modifier tokenPayable {\n require(__isTokenFallback);\n _;\n }\n function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\n if (!supportsToken(msg.sender)) {\n return false;\n }\n tkn = Tkn(msg.sender, _sender, _value);\n __isTokenFallback = true;\n if (!address(this).delegatecall(_data)) {\n __isTokenFallback = false;\n return false;\n }\n __isTokenFallback = false;\n return true;\n }\n function supportsToken(address token) public constant returns (bool);\n}\ncontract TokenOwnable is Standard223Receiver, Ownable {\n modifier onlyTokenOwner() {\n require(tkn.sender == owner);\n _;\n }\n}\ncontract EllipseMarketMaker is TokenOwnable {\n uint256 public constant PRECISION = 10 ** 18;\n ERC20 public token1;\n ERC20 public token2;\n uint256 public R1;\n uint256 public R2;\n uint256 public S1;\n uint256 public S2;\n bool public operational;\n bool public openForPublic;\n address public mmLib;\n function EllipseMarketMaker(address _mmLib, address _token1, address _token2) public {\n require(_mmLib != address(0));\n bytes4 sig = 0x6dd23b5b;\n uint256 argsSize = 3 * 32;\n uint256 dataSize = 4 + argsSize;\n bytes memory m_data = new bytes(dataSize);\n assembly {\n mstore(add(m_data, 0x20), sig)\n mstore(add(m_data, 0x24), _mmLib)\n mstore(add(m_data, 0x44), _token1)\n mstore(add(m_data, 0x64), _token2)\n }\n require(_mmLib.delegatecall(m_data));\n }\n function supportsToken(address token) public constant returns (bool) {\n return (token1 == token || token2 == token);\n }\n function() public {\n address _mmLib = mmLib;\n if (msg.data.length > 0) {\n assembly {\n calldatacopy(0xff, 0, calldatasize)\n let retVal := delegatecall(gas, _mmLib, 0xff, calldatasize, 0, 0x20)\n switch retVal case 0 { revert(0,0) } default { return(0, 0x20) }\n }\n }\n }\n}\ncontract MarketMaker is ERC223Receiver {\n function getCurrentPrice() public constant returns (uint _price);\n function change(address _fromToken, uint _amount, address _toToken) public returns (uint _returnAmount);\n function change(address _fromToken, uint _amount, address _toToken, uint _minReturn) public returns (uint _returnAmount);\n function change(address _toToken) public returns (uint _returnAmount);\n function change(address _toToken, uint _minReturn) public returns (uint _returnAmount);\n function quote(address _fromToken, uint _amount, address _toToken) public constant returns (uint _returnAmount);\n function openForPublicTrade() public returns (bool success);\n function isOpenForPublic() public returns (bool success);\n event Change(address indexed fromToken, uint inAmount, address indexed toToken, uint returnAmount, address indexed account);\n}\ncontract IEllipseMarketMaker is MarketMaker {\n uint256 public constant PRECISION = 10 ** 18;\n ERC20 public token1;\n ERC20 public token2;\n uint256 public R1;\n uint256 public R2;\n uint256 public S1;\n uint256 public S2;\n bool public operational;\n bool public openForPublic;\n address public mmLib;\n function supportsToken(address token) public constant returns (bool);\n function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256);\n function validateReserves() public view returns (bool);\n function withdrawExcessReserves() public returns (uint256);\n function initializeAfterTransfer() public returns (bool);\n function initializeOnTransfer() public returns (bool);\n function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256);\n}\ncontract CurrencyFactory is Standard223Receiver, TokenHolder {\n struct CurrencyStruct {\n string name;\n uint8 decimals;\n uint256 totalSupply;\n address owner;\n address mmAddress;\n }\n mapping (address => CurrencyStruct) public currencyMap;\n address public clnAddress;\n address public mmLibAddress;\n address[] public tokens;\n event MarketOpen(address indexed marketMaker);\n event TokenCreated(address indexed token, address indexed owner);\n modifier tokenIssuerOnly(address token, address owner) {\n require(currencyMap[token].owner == owner);\n _;\n }\n modifier CLNOnly() {\n require(msg.sender == clnAddress);\n _;\n }\n modifier marketClosed(address _token) {\n require(!MarketMaker(currencyMap[_token].mmAddress).isOpenForPublic());\n _;\n }\n modifier marketOpen(address _token) {\n require(MarketMaker(currencyMap[_token].mmAddress).isOpenForPublic());\n _;\n }\n function CurrencyFactory(address _mmLib, address _clnAddress) public {\n require(_mmLib != address(0));\n require(_clnAddress != address(0));\n mmLibAddress = _mmLib;\n clnAddress = _clnAddress;\n }\n function createCurrency(string _name,\n string _symbol,\n uint8 _decimals,\n uint256 _totalSupply,\n string _tokenURI) public\n returns (address) {\n ColuLocalCurrency subToken = new ColuLocalCurrency(_name, _symbol, _decimals, _totalSupply, _tokenURI);\n EllipseMarketMaker newMarketMaker = new EllipseMarketMaker(mmLibAddress, clnAddress, subToken);\n require(subToken.transfer(newMarketMaker, _totalSupply));\n require(IEllipseMarketMaker(newMarketMaker).initializeAfterTransfer());\n currencyMap[subToken] = CurrencyStruct({ name: _name, decimals: _decimals, totalSupply: _totalSupply, mmAddress: newMarketMaker, owner: msg.sender});\n tokens.push(subToken);\n TokenCreated(subToken, msg.sender);\n return subToken;\n }\n function createCurrency(string _name,\n string _symbol,\n uint8 _decimals,\n uint256 _totalSupply) public\n returns (address) {\n return createCurrency(_name, _symbol, _decimals, _totalSupply, '');\n }\n function insertCLNtoMarketMaker(address _token,\n uint256 _clnAmount) public\n tokenIssuerOnly(_token, msg.sender)\n returns (uint256 _subTokenAmount) {\n require(_clnAmount > 0);\n address marketMakerAddress = getMarketMakerAddressFromToken(_token);\n require(ERC20(clnAddress).transferFrom(msg.sender, this, _clnAmount));\n require(ERC20(clnAddress).approve(marketMakerAddress, _clnAmount));\n _subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, _clnAmount, _token);\n require(ERC20(_token).transfer(msg.sender, _subTokenAmount));\n }\n function insertCLNtoMarketMaker(address _token) public\n tokenPayable\n CLNOnly\n tokenIssuerOnly(_token, tkn.sender)\n returns (uint256 _subTokenAmount) {\n address marketMakerAddress = getMarketMakerAddressFromToken(_token);\n require(ERC20(clnAddress).approve(marketMakerAddress, tkn.value));\n _subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, tkn.value, _token);\n require(ERC20(_token).transfer(tkn.sender, _subTokenAmount));\n }\n function extractCLNfromMarketMaker(address _token,\n uint256 _ccAmount) public\n tokenIssuerOnly(_token, msg.sender)\n returns (uint256 _clnTokenAmount) {\n address marketMakerAddress = getMarketMakerAddressFromToken(_token);\n require(ERC20(_token).transferFrom(msg.sender, this, _ccAmount));\n require(ERC20(_token).approve(marketMakerAddress, _ccAmount));\n _clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(_token, _ccAmount, clnAddress);\n require(ERC20(clnAddress).transfer(msg.sender, _clnTokenAmount));\n }\n function extractCLNfromMarketMaker() public\n tokenPayable\n tokenIssuerOnly(msg.sender, tkn.sender)\n returns (uint256 _clnTokenAmount) {\n address marketMakerAddress = getMarketMakerAddressFromToken(msg.sender);\n require(ERC20(msg.sender).approve(marketMakerAddress, tkn.value));\n _clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(msg.sender, tkn.value, clnAddress);\n require(ERC20(clnAddress).transfer(tkn.sender, _clnTokenAmount));\n }\n function openMarket(address _token) public\n tokenIssuerOnly(_token, msg.sender)\n returns (bool) {\n address marketMakerAddress = getMarketMakerAddressFromToken(_token);\n require(MarketMaker(marketMakerAddress).openForPublicTrade());\n Ownable(marketMakerAddress).requestOwnershipTransfer(msg.sender);\n Ownable(_token).requestOwnershipTransfer(msg.sender);\n MarketOpen(marketMakerAddress);\n return true;\n }\n function supportsToken(address _token) public constant returns (bool) {\n return (clnAddress == _token || currencyMap[_token].totalSupply > 0);\n }\n function setTokenURI(address _token, string _tokenURI) public\n tokenIssuerOnly(_token, msg.sender)\n marketClosed(_token)\n returns (bool) {\n ColuLocalCurrency(_token).setTokenURI(_tokenURI);\n return true;\n }\n function getMarketMakerAddressFromToken(address _token) public constant returns (address _marketMakerAddress) {\n _marketMakerAddress = currencyMap[_token].mmAddress;\n require(_marketMakerAddress != address(0));\n }\n}",
  "extract_feature": [
    "function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\nif (!supportsToken(msg.sender)) {\nreturn false;\n}\ntkn = Tkn(msg.sender, _sender, _value);\n__isTokenFallback = true;\nif (!address(this).delegatecall(_data)) {\n__isTokenFallback = false;\nreturn false;\n}\n__isTokenFallback = false;\nreturn true;\n}",
    "function EllipseMarketMaker(address _mmLib, address _token1, address _token2) public {\nrequire(_mmLib != address(0));\nbytes4 sig = 0x6dd23b5b;\nuint256 argsSize = 3 * 32;\nuint256 dataSize = 4 + argsSize;\nbytes memory m_data = new bytes(dataSize);\nassembly {\nmstore(add(m_data, 0x20), sig)\nmstore(add(m_data, 0x24), _mmLib)\nmstore(add(m_data, 0x44), _token1)\nmstore(add(m_data, 0x64), _token2)\n}\nrequire(_mmLib.delegatecall(m_data));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b87f879b20b736a9a6b"
  },
  "filename": "14108.sol",
  "content": "contract Delegatable {\n address empty1;\n address empty2;\n address empty3;\n address public owner;\n address public delegation;\n event DelegationTransferred(address indexed previousDelegate, address indexed newDelegation);\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferDelegation(address newDelegation) public onlyOwner {\n require(newDelegation != address(0));\n emit DelegationTransferred(delegation, newDelegation);\n delegation = newDelegation;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract DelegateProxy {\n function delegatedFwd(address _dst, bytes _calldata) internal {\n assembly {\n let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n let size := returndatasize\n let ptr := mload(0x40)\n returndatacopy(ptr, 0, size)\n switch result case 0 { revert(ptr, size) }\n default { return(ptr, size) }\n }\n }\n}\ncontract Proxy is Delegatable, DelegateProxy {\n function () public {\n delegatedFwd(delegation, msg.data);\n }\n function initialize(address _controller, uint256 _cap) public {\n require(owner == 0);\n owner = msg.sender;\n delegation = _controller;\n delegatedFwd(_controller, msg.data);\n }\n}",
  "extract_feature": [
    "function delegatedFwd(address _dst, bytes _calldata) internal {\nassembly {\nlet result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\nlet size := returndatasize\nlet ptr := mload(0x40)\nreturndatacopy(ptr, 0, size)\nswitch result case 0 { revert(ptr, size) }\ndefault { return(ptr, size) }\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b87f879b20b736a9a6c"
  },
  "filename": "22320.sol",
  "content": "pragma solidity ^0.4.18;\ncontract DSAuthority {\n function canCall(\n address src, address dst, bytes4 sig\n ) public view returns (bool);\n}\ncontract DSAuthEvents {\n event LogSetAuthority (address indexed authority);\n event LogSetOwner (address indexed owner);\n}\ncontract DSAuth is DSAuthEvents {\n DSAuthority public authority;\n address public owner;\n function DSAuth() public {\n owner = msg.sender;\n LogSetOwner(msg.sender);\n }\n function setOwner(address owner_)\n public\n auth\n {\n owner = owner_;\n LogSetOwner(owner);\n }\n function setAuthority(DSAuthority authority_)\n public\n auth\n {\n authority = authority_;\n LogSetAuthority(authority);\n }\n modifier auth {\n require(isAuthorized(msg.sender, msg.sig));\n _;\n }\n function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n if (src == address(this)) {\n return true;\n } else if (src == owner) {\n return true;\n } else if (authority == DSAuthority(0)) {\n return false;\n } else {\n return authority.canCall(src, this, sig);\n }\n }\n}\ncontract DSMath {\n function add(uint x, uint y) internal pure returns (uint z) {\n require((z = x + y) >= x);\n }\n function sub(uint x, uint y) internal pure returns (uint z) {\n require((z = x - y) <= x);\n }\n function mul(uint x, uint y) internal pure returns (uint z) {\n require(y == 0 || (z = x * y) / y == x);\n }\n function min(uint x, uint y) internal pure returns (uint z) {\n return x <= y ? x : y;\n }\n function max(uint x, uint y) internal pure returns (uint z) {\n return x >= y ? x : y;\n }\n function imin(int x, int y) internal pure returns (int z) {\n return x <= y ? x : y;\n }\n function imax(int x, int y) internal pure returns (int z) {\n return x >= y ? x : y;\n }\n uint constant WAD = 10 ** 18;\n uint constant RAY = 10 ** 27;\n function wmul(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, y), WAD / 2) / WAD;\n }\n function rmul(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, y), RAY / 2) / RAY;\n }\n function wdiv(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, WAD), y / 2) / y;\n }\n function rdiv(uint x, uint y) internal pure returns (uint z) {\n z = add(mul(x, RAY), y / 2) / y;\n }\n function rpow(uint x, uint n) internal pure returns (uint z) {\n z = n % 2 != 0 ? x : RAY;\n for (n /= 2; n != 0; n /= 2) {\n x = rmul(x, x);\n if (n % 2 != 0) {\n z = rmul(z, x);\n }\n }\n }\n}\ncontract DSNote {\n event LogNote(\n bytes4 indexed sig,\n address indexed guy,\n bytes32 indexed foo,\n bytes32 indexed bar,\n uint wad,\n bytes fax\n ) anonymous;\n modifier note {\n bytes32 foo;\n bytes32 bar;\n assembly {\n foo := calldataload(4)\n bar := calldataload(36)\n }\n LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n _;\n }\n}\ncontract ERC20Events {\n event Approval(address indexed src, address indexed guy, uint wad);\n event Transfer(address indexed src, address indexed dst, uint wad);\n}\ncontract ERC20 is ERC20Events {\n function totalSupply() public view returns (uint);\n function balanceOf(address guy) public view returns (uint);\n function allowance(address src, address guy) public view returns (uint);\n function approve(address guy, uint wad) public returns (bool);\n function transfer(address dst, uint wad) public returns (bool);\n function transferFrom(\n address src, address dst, uint wad\n ) public returns (bool);\n}\ncontract TxManager is DSAuth, DSMath, DSNote {\n function execute(address[] tokens, bytes script) public note auth {\n for (uint i = 0; i < tokens.length; i++) {\n uint256 amount = min(ERC20(tokens[i]).balanceOf(msg.sender), ERC20(tokens[i]).allowance(msg.sender, this));\n require(ERC20(tokens[i]).transferFrom(msg.sender, this, amount));\n }\n invokeContracts(script);\n for (uint j = 0; j < tokens.length; j++) {\n require(ERC20(tokens[j]).transfer(msg.sender, ERC20(tokens[j]).balanceOf(this)));\n }\n }\n function invokeContracts(bytes script) internal {\n uint256 location = 0;\n while (location < script.length) {\n address contractAddress = addressAt(script, location);\n uint256 calldataLength = uint256At(script, location + 0x14);\n uint256 calldataStart = locationOf(script, location + 0x14 + 0x20);\n assembly {\n switch delegatecall(sub(gas, 5000), contractAddress, calldataStart, calldataLength, 0, 0)\n case 0 {\n revert(0, 0)\n }\n }\n location += (0x14 + 0x20 + calldataLength);\n }\n }\n function uint256At(bytes data, uint256 location) pure internal returns (uint256 result) {\n assembly {\n result := mload(add(data, add(0x20, location)))\n }\n }\n function addressAt(bytes data, uint256 location) pure internal returns (address result) {\n uint256 word = uint256At(data, location);\n assembly {\n result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n 0x1000000000000000000000000)\n }\n }\n function locationOf(bytes data, uint256 location) pure internal returns (uint256 result) {\n assembly {\n result := add(data, add(0x20, location))\n }\n }\n}",
  "extract_feature": [
    "function invokeContracts(bytes script) internal {\nuint256 location = 0;\nwhile (location < script.length) {\naddress contractAddress = addressAt(script, location);\nuint256 calldataLength = uint256At(script, location + 0x14);\nuint256 calldataStart = locationOf(script, location + 0x14 + 0x20);\nassembly {\nswitch delegatecall(sub(gas, 5000), contractAddress, calldataStart, calldataLength, 0, 0)\ncase 0 {\nrevert(0, 0)\n}\n}\nlocation += (0x14 + 0x20 + calldataLength);\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b87f879b20b736a9a6d"
  },
  "filename": "22943.sol",
  "content": "pragma solidity ^ ^0.4.2;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal constant returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract owned {\n address public owner;\n function owned() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newAdmin) onlyOwner public {\n owner = newAdmin;\n }\n}\ncontract tokenRecipient {\n function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n}\ncontract token {\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 public totalSupply;\n mapping(address => uint256) public balanceOf;\n mapping(address => mapping(address => uint256)) public allowance;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Burn(address indexed from, uint256 value);\n function token(uint256 initialSupply, string tokenName, uint8 decimalCount, string tokenSymbol) public {\n decimals = decimalCount;\n totalSupply = initialSupply * 10 ** uint256(decimals);\n balanceOf[msg.sender] = totalSupply;\n name = tokenName;\n symbol = tokenSymbol;\n }\n function transfer(address _to, uint256 _value) {\n if (balanceOf[msg.sender] < _value) throw;\n if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n balanceOf[msg.sender] -= _value;\n balanceOf[_to] += _value;\n Transfer(msg.sender, _to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n if (balanceOf[_from] < _value) throw;\n if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n if (_value > allowance[_from][msg.sender]) throw;\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n allowance[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public\n returns(bool success) {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool success) {\n tokenRecipient spender = tokenRecipient(_spender);\n if (approve(_spender, _value)) {\n spender.receiveApproval(msg.sender, _value, this, _extraData);\n return true;\n }\n }\n function burn(uint256 _value) public returns(bool success) {\n require(balanceOf[msg.sender] >= _value);\n balanceOf[msg.sender] -= _value;\n totalSupply -= _value;\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint256 _value) public returns(bool success) {\n require(balanceOf[_from] >= _value);\n require(_value <= allowance[_from][msg.sender]);\n balanceOf[_from] -= _value;\n allowance[_from][msg.sender] -= _value;\n totalSupply -= _value;\n Burn(_from, _value);\n return true;\n }\n}\ncontract OldToken {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n uint public decimals;\n string public name;\n}\ncontract Ohni is owned, token {\n OldToken ohniOld = OldToken(0x7f2176ceb16dcb648dc924eff617c3dc2befd30d);\n using SafeMath for uint256;\n uint256 public sellPrice;\n uint256 public buyPrice;\n bool public deprecated;\n address public currentVersion;\n mapping(address => bool) public frozenAccount;\n event FrozenFunds(address target, bool frozen);\n event ChangedTokens(address changedTarget, uint256 amountToChanged);\n function Ohni(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) token(initialSupply, tokenName, decimalUnits, tokenSymbol) {}\n function update(address newAddress, bool depr) onlyOwner {\n if (msg.sender != owner) throw;\n currentVersion = newAddress;\n deprecated = depr;\n }\n function checkForUpdates() internal {\n if (deprecated) {\n if (!currentVersion.delegatecall(msg.data)) throw;\n }\n }\n function withdrawETH(uint256 amount) onlyOwner {\n msg.sender.send(amount);\n }\n function airdrop(address[] recipients, uint256 value) onlyOwner {\n for (uint256 i = 0; i < recipients.length; i++) {\n transfer(recipients[i], value);\n }\n }\n function merge() public {\n checkForUpdates();\n uint256 amountChanged = ohniOld.allowance(msg.sender, this);\n require(amountChanged > 0);\n require(amountChanged < 100000000);\n require(ohniOld.balanceOf(msg.sender) < 100000000);\n require(msg.sender != address(0xa36e7c76da888237a3fb8a035d971ae179b45fad));\n if (!ohniOld.transferFrom(msg.sender, owner, amountChanged)) throw;\n amountChanged = (amountChanged * 10 ** uint256(decimals)) / 10;\n balanceOf[owner] = balanceOf[address(owner)].sub(amountChanged);\n balanceOf[msg.sender] = balanceOf[msg.sender].add(amountChanged);\n Transfer(address(owner), msg.sender, amountChanged);\n ChangedTokens(msg.sender,amountChanged);\n }\n function multiMerge(address[] recipients) onlyOwner {\n checkForUpdates();\n for (uint256 i = 0; i < recipients.length; i++) {\n uint256 amountChanged = ohniOld.allowance(msg.sender, owner);\n require(amountChanged > 0);\n require(amountChanged < 100000000);\n require(ohniOld.balanceOf(msg.sender) < 100000000);\n require(msg.sender != address(0xa36e7c76da888237a3fb8a035d971ae179b45fad));\n balanceOf[owner] = balanceOf[address(owner)].sub(amountChanged);\n balanceOf[msg.sender] = balanceOf[msg.sender].add(amountChanged);\n Transfer(address(owner), msg.sender, amountChanged);\n }\n }\n function mintToken(address target, uint256 mintedAmount) onlyOwner {\n checkForUpdates();\n balanceOf[target] += mintedAmount;\n totalSupply += mintedAmount;\n Transfer(0, this, mintedAmount);\n Transfer(this, target, mintedAmount);\n }\n function freezeAccount(address target, bool freeze) onlyOwner {\n checkForUpdates();\n frozenAccount[target] = freeze;\n FrozenFunds(target, freeze);\n }\n}",
  "extract_feature": [
    "function checkForUpdates() internal {\nif (deprecated) {\nif (!currentVersion.delegatecall(msg.data)) throw;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b87f879b20b736a9a6e"
  },
  "filename": "23604.sol",
  "content": "pragma solidity ^ 0.4 .2;\ncontract owned {\n address public owner;\n function owned() public {\n owner = msg.sender;\n }\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n function transferOwnership(address newAdmin) onlyOwner public {\n owner = newAdmin;\n }\n}\ncontract tokenRecipient {\n function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;\n}\ncontract token {\n string public name;\n string public symbol;\n uint8 public decimals = 18;\n uint256 public totalSupply;\n mapping(address => uint256) public balanceOf;\n mapping(address => mapping(address => uint256)) public allowance;\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Burn(address indexed from, uint256 value);\n function token(\n uint256 initialSupply,\n string tokenName,\n string tokenSymbol\n ) public {\n totalSupply = initialSupply * 10 ** uint256(decimals);\n balanceOf[msg.sender] = totalSupply;\n name = tokenName;\n symbol = tokenSymbol;\n }\n function transfer(address _to, uint256 _value) {\n if (balanceOf[msg.sender] < _value) throw;\n if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n balanceOf[msg.sender] -= _value;\n balanceOf[_to] += _value;\n Transfer(msg.sender, _to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n if (balanceOf[_from] < _value) throw;\n if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n if (_value > allowance[_from][msg.sender]) throw;\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n allowance[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public\n returns(bool success) {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool success) {\n tokenRecipient spender = tokenRecipient(_spender);\n if (approve(_spender, _value)) {\n spender.receiveApproval(msg.sender, _value, this, _extraData);\n return true;\n }\n }\n function burn(uint256 _value) public returns(bool success) {\n require(balanceOf[msg.sender] >= _value);\n balanceOf[msg.sender] -= _value;\n totalSupply -= _value;\n Burn(msg.sender, _value);\n return true;\n }\n function burnFrom(address _from, uint256 _value) public returns(bool success) {\n require(balanceOf[_from] >= _value);\n require(_value <= allowance[_from][msg.sender]);\n balanceOf[_from] -= _value;\n allowance[_from][msg.sender] -= _value;\n totalSupply -= _value;\n Burn(_from, _value);\n return true;\n }\n}\ncontract Ohni is owned, token {\n uint256 public sellPrice;\n uint256 public buyPrice;\n bool public deprecated;\n address public currentVersion;\n mapping(address => bool) public frozenAccount;\n event FrozenFunds(address target, bool frozen);\n function Ohni(\n uint256 initialSupply,\n string tokenName,\n uint8 decimalUnits,\n string tokenSymbol\n ) token(initialSupply, tokenName, tokenSymbol) {}\n function update(address newAddress, bool depr) onlyOwner {\n if (msg.sender != owner) throw;\n currentVersion = newAddress;\n deprecated = depr;\n }\n function checkForUpdates() private {\n if (deprecated) {\n if (!currentVersion.delegatecall(msg.data)) throw;\n }\n }\n function withdrawETH(uint256 amount) onlyOwner {\n msg.sender.send(amount);\n }\n function airdrop(address[] recipients, uint256 value) public onlyOwner {\n for (uint256 i = 0; i < recipients.length; i++) {\n transfer(recipients[i], value);\n }\n }\n function transfer(address _to, uint256 _value) {\n checkForUpdates();\n if (balanceOf[msg.sender] < _value) throw;\n if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n if (frozenAccount[msg.sender]) throw;\n balanceOf[msg.sender] -= _value;\n balanceOf[_to] += _value;\n Transfer(msg.sender, _to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n checkForUpdates();\n if (frozenAccount[_from]) throw;\n if (balanceOf[_from] < _value) throw;\n if (balanceOf[_to] + _value < balanceOf[_to]) throw;\n if (_value > allowance[_from][msg.sender]) throw;\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n allowance[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n }\n function merge(address target) onlyOwner {\n balanceOf[target] = token(address(0x7F2176cEB16dcb648dc924eff617c3dC2BEfd30d)).balanceOf(target) / 10;\n }\n function multiMerge(address[] recipients, uint256[] value) onlyOwner {\n for (uint256 i = 0; i < recipients.length; i++) {\n merge(recipients[i]);\n }\n }\n function mintToken(address target, uint256 mintedAmount) onlyOwner {\n checkForUpdates();\n balanceOf[target] += mintedAmount;\n totalSupply += mintedAmount;\n Transfer(0, this, mintedAmount);\n Transfer(this, target, mintedAmount);\n }\n function freezeAccount(address target, bool freeze) onlyOwner {\n checkForUpdates();\n frozenAccount[target] = freeze;\n FrozenFunds(target, freeze);\n }\n function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {\n checkForUpdates();\n sellPrice = newSellPrice;\n buyPrice = newBuyPrice;\n }\n function buy() payable {\n checkForUpdates();\n if (buyPrice == 0) throw;\n uint amount = msg.value / buyPrice;\n if (balanceOf[this] < amount) throw;\n balanceOf[msg.sender] += amount;\n balanceOf[this] -= amount;\n Transfer(this, msg.sender, amount);\n }\n function sell(uint256 amount) {\n checkForUpdates();\n if (sellPrice == 0) throw;\n if (balanceOf[msg.sender] < amount) throw;\n balanceOf[this] += amount;\n balanceOf[msg.sender] -= amount;\n if (!msg.sender.send(amount * sellPrice)) {\n throw;\n } else {\n Transfer(msg.sender, this, amount);\n }\n }\n}",
  "extract_feature": [
    "function checkForUpdates() private {\nif (deprecated) {\nif (!currentVersion.delegatecall(msg.data)) throw;\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b87f879b20b736a9a6f"
  },
  "filename": "25217.sol",
  "content": "pragma solidity ^0.4.18;\ncontract ERC20 {\n uint public totalSupply;\n function balanceOf(address _owner) constant public returns (uint balance);\n function transfer(address _to, uint _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n function approve(address _spender, uint _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint remaining);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract BasicToken is ERC20 {\n using SafeMath for uint256;\n uint256 public totalSupply;\n mapping (address => mapping (address => uint256)) allowed;\n mapping (address => uint256) balances;\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n function approve(address _spender, uint256 _value) public returns (bool) {\n if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) {\n revert();\n }\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n var _allowance = allowed[_from][msg.sender];\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = _allowance.sub(_value);\n Transfer(_from, _to, _value);\n return true;\n }\n}\ncontract ERC677 is ERC20 {\n function transferAndCall(address to, uint value, bytes data) public returns (bool ok);\n event TransferAndCall(address indexed from, address indexed to, uint value, bytes data);\n}\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n require(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a < b ? a : b;\n }\n function toPower2(uint256 a) internal pure returns (uint256) {\n return mul(a, a);\n }\n function sqrt(uint256 a) internal pure returns (uint256) {\n uint256 c = (a + 1) / 2;\n uint256 b = a;\n while (c < b) {\n b = c;\n c = (a / c + c) / 2;\n }\n return b;\n }\n}\ncontract Standard677Token is ERC677, BasicToken {\n function transferAndCall(address _to, uint _value, bytes _data) public returns (bool) {\n require(super.transfer(_to, _value));\n TransferAndCall(msg.sender, _to, _value, _data);\n if (isContract(_to)) return contractFallback(_to, _value, _data);\n return true;\n }\n function contractFallback(address _to, uint _value, bytes _data) private returns (bool) {\n ERC223Receiver receiver = ERC223Receiver(_to);\n require(receiver.tokenFallback(msg.sender, _value, _data));\n return true;\n }\n function isContract(address _addr) private constant returns (bool is_contract) {\n uint length;\n assembly { length := extcodesize(_addr) }\n return length > 0;\n }\n}\ncontract Ownable {\n address public owner;\n address public newOwnerCandidate;\n event OwnershipRequested(address indexed _by, address indexed _to);\n event OwnershipTransferred(address indexed _from, address indexed _to);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyOwnerCandidate() {\n require(msg.sender == newOwnerCandidate);\n _;\n }\n function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n require(_newOwnerCandidate != address(0));\n newOwnerCandidate = _newOwnerCandidate;\n OwnershipRequested(msg.sender, newOwnerCandidate);\n }\n function acceptOwnership() external onlyOwnerCandidate {\n address previousOwner = owner;\n owner = newOwnerCandidate;\n newOwnerCandidate = address(0);\n OwnershipTransferred(previousOwner, owner);\n }\n}\ncontract TokenHolder is Ownable {\n function transferAnyERC20Token(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) {\n return ERC20(_tokenAddress).transfer(owner, _amount);\n }\n}\ncontract ColuLocalCurrency is Ownable, Standard677Token, TokenHolder {\n using SafeMath for uint256;\n string public name;\n string public symbol;\n uint8 public decimals;\n function ColuLocalCurrency(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {\n require(_totalSupply != 0);\n require(bytes(_name).length != 0);\n require(bytes(_symbol).length != 0);\n totalSupply = _totalSupply;\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n balances[msg.sender] = totalSupply;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok);\n}\ncontract Standard223Receiver is ERC223Receiver {\n Tkn tkn;\n struct Tkn {\n address addr;\n address sender;\n uint256 value;\n }\n bool __isTokenFallback;\n modifier tokenPayable {\n require(__isTokenFallback);\n _;\n }\n function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\n if (!supportsToken(msg.sender)) {\n return false;\n }\n tkn = Tkn(msg.sender, _sender, _value);\n __isTokenFallback = true;\n if (!address(this).delegatecall(_data)) {\n __isTokenFallback = false;\n return false;\n }\n __isTokenFallback = false;\n return true;\n }\n function supportsToken(address token) public constant returns (bool);\n}\ncontract TokenOwnable is Standard223Receiver, Ownable {\n modifier onlyTokenOwner() {\n require(tkn.sender == owner);\n _;\n }\n}\ncontract MarketMaker is ERC223Receiver {\n function getCurrentPrice() public constant returns (uint _price);\n function change(address _fromToken, uint _amount, address _toToken) public returns (uint _returnAmount);\n function change(address _fromToken, uint _amount, address _toToken, uint _minReturn) public returns (uint _returnAmount);\n function change(address _toToken) public returns (uint _returnAmount);\n function change(address _toToken, uint _minReturn) public returns (uint _returnAmount);\n function quote(address _fromToken, uint _amount, address _toToken) public constant returns (uint _returnAmount);\n function openForPublicTrade() public returns (bool success);\n function isOpenForPublic() public returns (bool success);\n event Change(address indexed fromToken, uint inAmount, address indexed toToken, uint returnAmount, address indexed account);\n}\ncontract EllipseMarketMaker is TokenOwnable {\n uint256 public constant PRECISION = 10 ** 18;\n ERC20 public token1;\n ERC20 public token2;\n uint256 public R1;\n uint256 public R2;\n uint256 public S1;\n uint256 public S2;\n bool public operational;\n bool public openForPublic;\n address public mmLib;\n function EllipseMarketMaker(address _mmLib, address _token1, address _token2) public {\n require(_mmLib != address(0));\n bytes4 sig = 0x6dd23b5b;\n uint256 argsSize = 3 * 32;\n uint256 dataSize = 4 + argsSize;\n bytes memory m_data = new bytes(dataSize);\n assembly {\n mstore(add(m_data, 0x20), sig)\n mstore(add(m_data, 0x24), _mmLib)\n mstore(add(m_data, 0x44), _token1)\n mstore(add(m_data, 0x64), _token2)\n }\n require(_mmLib.delegatecall(m_data));\n }\n function supportsToken(address token) public constant returns (bool) {\n return (token1 == token || token2 == token);\n }\n function() public {\n address _mmLib = mmLib;\n if (msg.data.length > 0) {\n assembly {\n calldatacopy(0xff, 0, calldatasize)\n let retVal := delegatecall(gas, _mmLib, 0xff, calldatasize, 0, 0x20)\n switch retVal case 0 { revert(0,0) } default { return(0, 0x20) }\n }\n }\n }\n}\ncontract IEllipseMarketMaker is MarketMaker {\n uint256 public constant PRECISION = 10 ** 18;\n ERC20 public token1;\n ERC20 public token2;\n uint256 public R1;\n uint256 public R2;\n uint256 public S1;\n uint256 public S2;\n bool public operational;\n bool public openForPublic;\n address public mmLib;\n function supportsToken(address token) public constant returns (bool);\n function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256);\n function validateReserves() public view returns (bool);\n function withdrawExcessReserves() public returns (uint256);\n function initializeAfterTransfer() public returns (bool);\n function initializeOnTransfer() public returns (bool);\n function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256);\n}\ncontract CurrencyFactory is Standard223Receiver, TokenHolder {\n struct CurrencyStruct {\n string name;\n uint8 decimals;\n uint256 totalSupply;\n address owner;\n address mmAddress;\n }\n mapping (address => CurrencyStruct) public currencyMap;\n address public clnAddress;\n address public mmLibAddress;\n address[] public tokens;\n event MarketOpen(address indexed marketMaker);\n event TokenCreated(address indexed token, address indexed owner);\n modifier tokenIssuerOnly(address token, address owner) {\n require(currencyMap[token].owner == owner);\n _;\n }\n modifier CLNOnly() {\n require(msg.sender == clnAddress);\n _;\n }\n function CurrencyFactory(address _mmLib, address _clnAddress) public {\n require(_mmLib != address(0));\n require(_clnAddress != address(0));\n mmLibAddress = _mmLib;\n clnAddress = _clnAddress;\n }\n function createCurrency(string _name,\n string _symbol,\n uint8 _decimals,\n uint256 _totalSupply) public\n returns (address) {\n ColuLocalCurrency subToken = new ColuLocalCurrency(_name, _symbol, _decimals, _totalSupply);\n EllipseMarketMaker newMarketMaker = new EllipseMarketMaker(mmLibAddress, clnAddress, subToken);\n require(subToken.transfer(newMarketMaker, _totalSupply));\n require(IEllipseMarketMaker(newMarketMaker).initializeAfterTransfer());\n currencyMap[subToken] = CurrencyStruct({ name: _name, decimals: _decimals, totalSupply: _totalSupply, mmAddress: newMarketMaker, owner: msg.sender});\n tokens.push(subToken);\n TokenCreated(subToken, msg.sender);\n return subToken;\n }\n function insertCLNtoMarketMaker(address _token,\n uint256 _clnAmount) public\n tokenIssuerOnly(_token, msg.sender)\n returns (uint256 _subTokenAmount) {\n require(_clnAmount > 0);\n address marketMakerAddress = getMarketMakerAddressFromToken(_token);\n require(ERC20(clnAddress).transferFrom(msg.sender, this, _clnAmount));\n require(ERC20(clnAddress).approve(marketMakerAddress, _clnAmount));\n _subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, _clnAmount, _token);\n require(ERC20(_token).transfer(msg.sender, _subTokenAmount));\n }\n function insertCLNtoMarketMaker(address _token) public\n tokenPayable\n CLNOnly\n tokenIssuerOnly(_token, tkn.sender)\n returns (uint256 _subTokenAmount) {\n address marketMakerAddress = getMarketMakerAddressFromToken(_token);\n require(ERC20(clnAddress).approve(marketMakerAddress, tkn.value));\n _subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, tkn.value, _token);\n require(ERC20(_token).transfer(tkn.sender, _subTokenAmount));\n }\n function extractCLNfromMarketMaker(address _token,\n uint256 _ccAmount) public\n tokenIssuerOnly(_token, msg.sender)\n returns (uint256 _clnTokenAmount) {\n address marketMakerAddress = getMarketMakerAddressFromToken(_token);\n require(ERC20(_token).transferFrom(msg.sender, this, _ccAmount));\n require(ERC20(_token).approve(marketMakerAddress, _ccAmount));\n _clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(_token, _ccAmount, clnAddress);\n require(ERC20(clnAddress).transfer(msg.sender, _clnTokenAmount));\n }\n function extractCLNfromMarketMaker() public\n tokenPayable\n tokenIssuerOnly(msg.sender, tkn.sender)\n returns (uint256 _clnTokenAmount) {\n address marketMakerAddress = getMarketMakerAddressFromToken(msg.sender);\n require(ERC20(msg.sender).approve(marketMakerAddress, tkn.value));\n _clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(msg.sender, tkn.value, clnAddress);\n require(ERC20(clnAddress).transfer(tkn.sender, _clnTokenAmount));\n }\n function openMarket(address _token) public\n tokenIssuerOnly(_token, msg.sender)\n returns (bool) {\n address marketMakerAddress = getMarketMakerAddressFromToken(_token);\n require(MarketMaker(marketMakerAddress).openForPublicTrade());\n Ownable(marketMakerAddress).requestOwnershipTransfer(msg.sender);\n MarketOpen(marketMakerAddress);\n return true;\n }\n function supportsToken(address _token) public constant returns (bool) {\n return (clnAddress == _token || currencyMap[_token].totalSupply > 0);\n }\n function getMarketMakerAddressFromToken(address _token) public constant returns (address _marketMakerAddress) {\n _marketMakerAddress = currencyMap[_token].mmAddress;\n require(_marketMakerAddress != address(0));\n }\n}",
  "extract_feature": [
    "function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\nif (!supportsToken(msg.sender)) {\nreturn false;\n}\ntkn = Tkn(msg.sender, _sender, _value);\n__isTokenFallback = true;\nif (!address(this).delegatecall(_data)) {\n__isTokenFallback = false;\nreturn false;\n}\n__isTokenFallback = false;\nreturn true;\n}",
    "function EllipseMarketMaker(address _mmLib, address _token1, address _token2) public {\nrequire(_mmLib != address(0));\nbytes4 sig = 0x6dd23b5b;\nuint256 argsSize = 3 * 32;\nuint256 dataSize = 4 + argsSize;\nbytes memory m_data = new bytes(dataSize);\nassembly {\nmstore(add(m_data, 0x20), sig)\nmstore(add(m_data, 0x24), _mmLib)\nmstore(add(m_data, 0x44), _token1)\nmstore(add(m_data, 0x64), _token2)\n}\nrequire(_mmLib.delegatecall(m_data));\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b87f879b20b736a9a70"
  },
  "filename": "25219.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n require(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n require(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a);\n return c;\n }\n function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a >= b ? a : b;\n }\n function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n return a < b ? a : b;\n }\n function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a >= b ? a : b;\n }\n function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n return a < b ? a : b;\n }\n function toPower2(uint256 a) internal pure returns (uint256) {\n return mul(a, a);\n }\n function sqrt(uint256 a) internal pure returns (uint256) {\n uint256 c = (a + 1) / 2;\n uint256 b = a;\n while (c < b) {\n b = c;\n c = (a / c + c) / 2;\n }\n return b;\n }\n}\ncontract ERC223Receiver {\n function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok);\n}\ncontract MarketMaker is ERC223Receiver {\n function getCurrentPrice() public constant returns (uint _price);\n function change(address _fromToken, uint _amount, address _toToken) public returns (uint _returnAmount);\n function change(address _fromToken, uint _amount, address _toToken, uint _minReturn) public returns (uint _returnAmount);\n function change(address _toToken) public returns (uint _returnAmount);\n function change(address _toToken, uint _minReturn) public returns (uint _returnAmount);\n function quote(address _fromToken, uint _amount, address _toToken) public constant returns (uint _returnAmount);\n function openForPublicTrade() public returns (bool success);\n function isOpenForPublic() public returns (bool success);\n event Change(address indexed fromToken, uint inAmount, address indexed toToken, uint returnAmount, address indexed account);\n}\ncontract IEllipseMarketMaker is MarketMaker {\n uint256 public constant PRECISION = 10 ** 18;\n ERC20 public token1;\n ERC20 public token2;\n uint256 public R1;\n uint256 public R2;\n uint256 public S1;\n uint256 public S2;\n bool public operational;\n bool public openForPublic;\n address public mmLib;\n function supportsToken(address token) public constant returns (bool);\n function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256);\n function validateReserves() public view returns (bool);\n function withdrawExcessReserves() public returns (uint256);\n function initializeAfterTransfer() public returns (bool);\n function initializeOnTransfer() public returns (bool);\n function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256);\n}\ncontract ERC20 {\n uint public totalSupply;\n function balanceOf(address _owner) constant public returns (uint balance);\n function transfer(address _to, uint _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n function approve(address _spender, uint _value) public returns (bool success);\n function allowance(address _owner, address _spender) public constant returns (uint remaining);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract Ownable {\n address public owner;\n address public newOwnerCandidate;\n event OwnershipRequested(address indexed _by, address indexed _to);\n event OwnershipTransferred(address indexed _from, address indexed _to);\n function Ownable() public {\n owner = msg.sender;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n modifier onlyOwnerCandidate() {\n require(msg.sender == newOwnerCandidate);\n _;\n }\n function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner {\n require(_newOwnerCandidate != address(0));\n newOwnerCandidate = _newOwnerCandidate;\n OwnershipRequested(msg.sender, newOwnerCandidate);\n }\n function acceptOwnership() external onlyOwnerCandidate {\n address previousOwner = owner;\n owner = newOwnerCandidate;\n newOwnerCandidate = address(0);\n OwnershipTransferred(previousOwner, owner);\n }\n}\ncontract Standard223Receiver is ERC223Receiver {\n Tkn tkn;\n struct Tkn {\n address addr;\n address sender;\n uint256 value;\n }\n bool __isTokenFallback;\n modifier tokenPayable {\n require(__isTokenFallback);\n _;\n }\n function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\n if (!supportsToken(msg.sender)) {\n return false;\n }\n tkn = Tkn(msg.sender, _sender, _value);\n __isTokenFallback = true;\n if (!address(this).delegatecall(_data)) {\n __isTokenFallback = false;\n return false;\n }\n __isTokenFallback = false;\n return true;\n }\n function supportsToken(address token) public constant returns (bool);\n}\ncontract TokenOwnable is Standard223Receiver, Ownable {\n modifier onlyTokenOwner() {\n require(tkn.sender == owner);\n _;\n }\n}\ncontract EllipseMarketMakerLib is TokenOwnable, IEllipseMarketMaker {\n using SafeMath for uint256;\n uint256 private l_R1;\n uint256 private l_R2;\n modifier notConstructed() {\n require(mmLib == address(0));\n _;\n }\n modifier isOperational() {\n require(operational);\n _;\n }\n modifier notOperational() {\n require(!operational);\n _;\n }\n modifier canTrade() {\n require(openForPublic || msg.sender == owner);\n _;\n }\n modifier canTrade223() {\n require (openForPublic || tkn.sender == owner);\n _;\n }\n function constructor(address _mmLib, address _token1, address _token2) public onlyOwner notConstructed returns (bool) {\n require(_mmLib != address(0));\n require(_token1 != address(0));\n require(_token2 != address(0));\n require(_token1 != _token2);\n mmLib = _mmLib;\n token1 = ERC20(_token1);\n token2 = ERC20(_token2);\n R1 = 0;\n R2 = 0;\n S1 = token1.totalSupply();\n S2 = token2.totalSupply();\n operational = false;\n openForPublic = false;\n return true;\n }\n function openForPublicTrade() public onlyOwner isOperational returns (bool) {\n openForPublic = true;\n return true;\n }\n function isOpenForPublic() public onlyOwner returns (bool) {\n return (openForPublic && operational);\n }\n function supportsToken(address _token) public constant returns (bool) {\n return (token1 == _token || token2 == _token);\n }\n function initializeAfterTransfer() public notOperational onlyOwner returns (bool) {\n require(initialize());\n return true;\n }\n function initializeOnTransfer() public notOperational onlyTokenOwner tokenPayable returns (bool) {\n require(initialize());\n return true;\n }\n function initialize() private returns (bool success) {\n R1 = token1.balanceOf(this);\n R2 = token2.balanceOf(this);\n success = ((R1 == 0 && R2 == S2) || (R2 == 0 && R1 == S1));\n if (success) {\n operational = true;\n }\n }\n function getCurrentPrice() public constant isOperational returns (uint256) {\n return getPrice(R1, R2, S1, S2);\n }\n function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256 price) {\n price = PRECISION;\n price = price.mul(_S1.sub(_R1));\n price = price.div(_S2.sub(_R2));\n price = price.mul(_S2);\n price = price.div(_S1);\n price = price.mul(_S2);\n price = price.div(_S1);\n }\n function quoteAndReserves(address _fromToken, uint256 _inAmount, address _toToken) private isOperational returns (uint256 returnAmount) {\n if (token1 == _fromToken && token2 == _toToken) {\n l_R1 = R1.add(_inAmount);\n l_R2 = calcReserve(l_R1, S1, S2);\n if (l_R2 > R2) {\n return 0;\n }\n returnAmount = R2.sub(l_R2);\n }\n else if (token2 == _fromToken && token1 == _toToken) {\n l_R2 = R2.add(_inAmount);\n l_R1 = calcReserve(l_R2, S2, S1);\n if (l_R1 > R1) {\n return 0;\n }\n returnAmount = R1.sub(l_R1);\n } else {\n return 0;\n }\n }\n function quote(address _fromToken, uint256 _inAmount, address _toToken) public constant isOperational returns (uint256 returnAmount) {\n uint256 _R1;\n uint256 _R2;\n if (token1 == _fromToken && token2 == _toToken) {\n _R1 = R1.add(_inAmount);\n _R2 = calcReserve(_R1, S1, S2);\n if (_R2 > R2) {\n return 0;\n }\n returnAmount = R2.sub(_R2);\n }\n else if (token2 == _fromToken && token1 == _toToken) {\n _R2 = R2.add(_inAmount);\n _R1 = calcReserve(_R2, S2, S1);\n if (_R1 > R1) {\n return 0;\n }\n returnAmount = R1.sub(_R1);\n } else {\n return 0;\n }\n }\n function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256 _R2) {\n _R2 = _S2\n .mul(\n _S1\n .sub(\n _R1\n .mul(_S1)\n .mul(2)\n .sub(\n _R1\n .toPower2()\n )\n .sqrt()\n )\n )\n .div(_S1);\n }\n function change(address _fromToken, uint256 _inAmount, address _toToken) public canTrade returns (uint256 returnAmount) {\n return change(_fromToken, _inAmount, _toToken, 0);\n }\n function change(address _fromToken, uint256 _inAmount, address _toToken, uint256 _minReturn) public canTrade returns (uint256 returnAmount) {\n require(ERC20(_fromToken).transferFrom(msg.sender, this, _inAmount));\n returnAmount = exchange(_fromToken, _inAmount, _toToken, _minReturn);\n if (returnAmount == 0) {\n revert();\n }\n ERC20(_toToken).transfer(msg.sender, returnAmount);\n require(validateReserves());\n Change(_fromToken, _inAmount, _toToken, returnAmount, msg.sender);\n }\n function change(address _toToken) public canTrade223 tokenPayable returns (uint256 returnAmount) {\n return change(_toToken, 0);\n }\n function change(address _toToken, uint256 _minReturn) public canTrade223 tokenPayable returns (uint256 returnAmount) {\n address fromToken = tkn.addr;\n uint256 inAmount = tkn.value;\n returnAmount = exchange(fromToken, inAmount, _toToken, _minReturn);\n if (returnAmount == 0) {\n revert();\n }\n ERC20(_toToken).transfer(tkn.sender, returnAmount);\n require(validateReserves());\n Change(fromToken, inAmount, _toToken, returnAmount, tkn.sender);\n }\n function exchange(address _fromToken, uint256 _inAmount, address _toToken, uint256 _minReturn) private returns (uint256 returnAmount) {\n returnAmount = quoteAndReserves(_fromToken, _inAmount, _toToken);\n if (returnAmount == 0 || returnAmount < _minReturn) {\n return 0;\n }\n updateReserve();\n }\n function updateReserve() private {\n R1 = l_R1;\n R2 = l_R2;\n }\n function validateReserves() public view returns (bool) {\n return (token1.balanceOf(this) >= R1 && token2.balanceOf(this) >= R2);\n }\n function withdrawExcessReserves() public onlyOwner returns (uint256 returnAmount) {\n if (token1.balanceOf(this) > R1) {\n returnAmount = returnAmount.add(token1.balanceOf(this).sub(R1));\n token1.transfer(msg.sender, token1.balanceOf(this).sub(R1));\n }\n if (token2.balanceOf(this) > R2) {\n returnAmount = returnAmount.add(token2.balanceOf(this).sub(R2));\n token2.transfer(msg.sender, token2.balanceOf(this).sub(R2));\n }\n }\n}",
  "extract_feature": [
    "function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) {\nif (!supportsToken(msg.sender)) {\nreturn false;\n}\ntkn = Tkn(msg.sender, _sender, _value);\n__isTokenFallback = true;\nif (!address(this).delegatecall(_data)) {\n__isTokenFallback = false;\nreturn false;\n}\n__isTokenFallback = false;\nreturn true;\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a71"
  },
  "filename": "26284.sol",
  "content": "pragma solidity ^0.4.18;\ncontract DelegateProxy {\n function delegatedFwd(address _dst, bytes _calldata) internal {\n assembly {\n let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n let size := returndatasize\n let ptr := mload(0x40)\n returndatacopy(ptr, 0, size)\n switch result case 0 { revert(ptr, size) }\n default { return(ptr, size) }\n }\n }\n}\ncontract Delegatable {\n address empty1;\n address empty2;\n address empty3;\n address public owner;\n address public delegation;\n event DelegationTransferred(address indexed previousDelegate, address indexed newDelegation);\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function transferDelegation(address newDelegation) public onlyOwner {\n require(newDelegation != address(0));\n DelegationTransferred(delegation, newDelegation);\n delegation = newDelegation;\n }\n function transferOwnership(address newOwner) public onlyOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\ncontract Parsec is Delegatable, DelegateProxy {\n function () public {\n delegatedFwd(delegation, msg.data);\n }\n function initialize(address _controller, uint256 _cap) public {\n require(owner == 0);\n owner = msg.sender;\n delegation = _controller;\n delegatedFwd(_controller, msg.data);\n }\n}",
  "extract_feature": [
    "function delegatedFwd(address _dst, bytes _calldata) internal {\nassembly {\nlet result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\nlet size := returndatasize\nlet ptr := mload(0x40)\nreturndatacopy(ptr, 0, size)\nswitch result case 0 { revert(ptr, size) }\ndefault { return(ptr, size) }\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a72"
  },
  "filename": "27767.sol",
  "content": "pragma solidity ^0.4.10;\ncontract IERC20Token {\n function totalSupply() public constant returns ( uint256 supply ) { supply; }\n function balanceOf( address _owner ) public constant returns ( uint256 balance ) { _owner; balance; }\n function allowance( address _owner, address _spender ) public constant returns ( uint256 remaining ) { _owner; _spender; remaining; }\n function transfer( address _to, uint256 _value ) public returns ( bool success );\n function transferFrom( address _from, address _to, uint256 _value ) public returns ( bool success );\n function approve( address _spender, uint256 _value ) public returns ( bool success );\n}\ncontract RegaUtils {\n modifier validAddress( address _address ) {\n require( _address != 0x0 );\n _;\n }\n function safeAdd( uint256 x, uint256 y ) internal returns( uint256 ) {\n uint256 z = x + y;\n assert( z >= x );\n return z;\n }\n function safeSub( uint256 x, uint256 y ) internal returns( uint256 ) {\n assert( x >= y);\n return x - y;\n }\n}\ncontract ERC20Token is IERC20Token, RegaUtils {\n uint256 public totalSupply = 0;\n mapping( address => uint256 ) public balanceOf;\n mapping( address => mapping( address => uint256 ) ) public allowance;\n event Transfer( address indexed _from, address indexed _to, uint256 _value );\n event Approval( address indexed _owner, address indexed _spender, uint256 _value );\n function transfer( address _to, uint256 _value ) validAddress( _to )\n returns( bool success )\n {\n balanceOf[ msg.sender ] = safeSub( balanceOf[ msg.sender ], _value );\n balanceOf[ _to ] = safeAdd( balanceOf[ _to ], _value );\n Transfer( msg.sender, _to, _value );\n return true;\n }\n function transferFrom( address _from, address _to, uint256 _value ) validAddress( _from ) validAddress( _to )\n returns( bool success )\n {\n allowance[ _from ][ msg.sender ] = safeSub( allowance[ _from ][ msg.sender ], _value );\n balanceOf[ _from] = safeSub( balanceOf[_from], _value );\n balanceOf[ _to] = safeAdd( balanceOf[_to], _value );\n Transfer( _from, _to, _value );\n return true;\n }\n function approve( address _spender, uint256 _value ) validAddress( _spender )\n returns( bool success)\n {\n require( _value == 0 || allowance[ msg.sender ][ _spender ] == 0 );\n allowance[ msg.sender ][ _spender ] = _value;\n Approval( msg.sender, _spender, _value );\n return true;\n }\n}\ncontract RSTBase is ERC20Token {\n address public board;\n address public owner;\n address public votingData;\n address public tokenData;\n address public feesData;\n uint256 public reserve;\n uint32 public crr;\n uint256 public weiForToken;\n uint8 public totalAccounts;\n modifier boardOnly() {\n require(msg.sender == board);\n _;\n }\n}\ncontract TokenControllerBase is RSTBase {\n function init() public;\n function isSellOpen() public constant returns(bool);\n function isBuyOpen() public constant returns(bool);\n function sell(uint value) public;\n function buy() public payable;\n function addToReserve() public payable;\n}\ncontract VotingControllerBase is RSTBase {\n function voteFor() public;\n function voteAgainst() public;\n function startVoting() public;\n function stopVoting() public;\n function getCurrentVotingDescription() public constant returns (bytes32 vd) ;\n}\ncontract FeesControllerBase is RSTBase {\n function init() public;\n function withdrawFee() public;\n function calculateFee() public;\n function addPayee( address payee ) public;\n function removePayee( address payee ) public;\n function setRepayment( ) payable public;\n}\ncontract RiskSharingToken is RSTBase {\n string public constant version = \"0.1\";\n string public constant name = \"REGA Risk Sharing Token\";\n string public constant symbol = \"RST\";\n uint8 public constant decimals = 10;\n TokenControllerBase public tokenController;\n VotingControllerBase public votingController;\n FeesControllerBase public feesController;\n modifier ownerOnly() {\n require( msg.sender == owner );\n _;\n }\n modifier boardOnly() {\n require( msg.sender == board );\n _;\n }\n modifier authorized() {\n require( msg.sender == owner || msg.sender == board);\n _;\n }\n function RiskSharingToken( address _board ) {\n board = _board;\n owner = msg.sender;\n tokenController = TokenControllerBase(0);\n votingController = VotingControllerBase(0);\n weiForToken = uint(10)**(18-1-decimals);\n reserve = 0;\n crr = 20;\n totalAccounts = 0;\n }\n function() payable {\n }\n function setTokenController( TokenControllerBase tc, address _tokenData ) public boardOnly {\n tokenController = tc;\n if( _tokenData != address(0) )\n tokenData = _tokenData;\n if( tokenController != TokenControllerBase(0) )\n if( !tokenController.delegatecall(bytes4(sha3(\"init()\"))) )\n revert();\n }\n function setVotingController( VotingControllerBase vc ) public boardOnly {\n votingController = vc;\n }\n function startVoting( bytes32 ) public boardOnly validAddress(votingController) {\n if( !votingController.delegatecall(msg.data) )\n revert();\n }\n function stopVoting() public boardOnly validAddress(votingController) {\n if( !votingController.delegatecall(msg.data) )\n revert();\n }\n function voteFor() public validAddress(votingController) {\n if( !votingController.delegatecall(msg.data) )\n revert();\n }\n function voteAgainst() public validAddress(votingController) {\n if( !votingController.delegatecall(msg.data) )\n revert();\n }\n function buy() public payable validAddress(tokenController) {\n if( !tokenController.delegatecall(msg.data) )\n revert();\n }\n function sell( uint ) public validAddress(tokenController) {\n if( !tokenController.delegatecall(msg.data) )\n revert();\n }\n function addToReserve( ) public payable validAddress(tokenController) {\n if( !tokenController.delegatecall(msg.data) )\n revert();\n }\n function withdraw( uint256 amount ) public boardOnly {\n require(safeSub(this.balance, amount) >= reserve);\n board.transfer( amount );\n }\n function issueToken( address , uint256 ) public authorized {\n if( !tokenController.delegatecall(msg.data) )\n revert();\n }\n function issueTokens( uint256[] ) public ownerOnly {\n if( !tokenController.delegatecall(msg.data) )\n revert();\n }\n function setFeesController( FeesControllerBase fc ) public boardOnly {\n feesController = fc;\n if( !feesController.delegatecall(bytes4(sha3(\"init()\"))) )\n revert();\n }\n function withdrawFee() public validAddress(feesController) {\n if( !feesController.delegatecall(msg.data) )\n revert();\n }\n function calculateFee() public validAddress(feesController) {\n if( !feesController.delegatecall(msg.data) )\n revert();\n }\n function addPayee( address ) public validAddress(feesController) {\n if( !feesController.delegatecall(msg.data) )\n revert();\n }\n function removePayee( address ) public validAddress(feesController) {\n if( !feesController.delegatecall(msg.data) )\n revert();\n }\n function setRepayment( ) payable public validAddress(feesController) {\n if( !feesController.delegatecall(msg.data) )\n revert();\n }\n}",
  "extract_feature": [
    "function setTokenController( TokenControllerBase tc, address _tokenData ) public boardOnly {\ntokenController = tc;\nif( _tokenData != address(0) )\ntokenData = _tokenData;\nif( tokenController != TokenControllerBase(0) )\nif( !tokenController.delegatecall(bytes4(sha3(\"init()\"))) )\nrevert();\n}",
    "function startVoting( bytes32 ) public boardOnly validAddress(votingController) {\nif( !votingController.delegatecall(msg.data) )\nrevert();\n}",
    "function stopVoting() public boardOnly validAddress(votingController) {\nif( !votingController.delegatecall(msg.data) )\nrevert();\n}",
    "function voteFor() public validAddress(votingController) {\nif( !votingController.delegatecall(msg.data) )\nrevert();\n}",
    "function voteAgainst() public validAddress(votingController) {\nif( !votingController.delegatecall(msg.data) )\nrevert();\n}",
    "function buy() public payable validAddress(tokenController) {\nif( !tokenController.delegatecall(msg.data) )\nrevert();\n}",
    "function sell( uint ) public validAddress(tokenController) {\nif( !tokenController.delegatecall(msg.data) )\nrevert();\n}",
    "function addToReserve( ) public payable validAddress(tokenController) {\nif( !tokenController.delegatecall(msg.data) )\nrevert();\n}",
    "function issueToken( address , uint256 ) public authorized {\nif( !tokenController.delegatecall(msg.data) )\nrevert();\n}",
    "function issueTokens( uint256[] ) public ownerOnly {\nif( !tokenController.delegatecall(msg.data) )\nrevert();\n}",
    "function setFeesController( FeesControllerBase fc ) public boardOnly {\nfeesController = fc;\nif( !feesController.delegatecall(bytes4(sha3(\"init()\"))) )\nrevert();\n}",
    "function withdrawFee() public validAddress(feesController) {\nif( !feesController.delegatecall(msg.data) )\nrevert();\n}",
    "function calculateFee() public validAddress(feesController) {\nif( !feesController.delegatecall(msg.data) )\nrevert();\n}",
    "function addPayee( address ) public validAddress(feesController) {\nif( !feesController.delegatecall(msg.data) )\nrevert();\n}",
    "function removePayee( address ) public validAddress(feesController) {\nif( !feesController.delegatecall(msg.data) )\nrevert();\n}",
    "function setRepayment( ) payable public validAddress(feesController) {\nif( !feesController.delegatecall(msg.data) )\nrevert();\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a73"
  },
  "filename": "29842.sol",
  "content": "pragma solidity ^0.4.18;\ncontract LANDStorage {\n mapping (address => uint) latestPing;\n uint256 constant clearLow = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;\n uint256 constant clearHigh = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\n uint256 constant factor = 0x100000000000000000000000000000000;\n}\ncontract AssetRegistryStorage {\n string internal _name;\n string internal _symbol;\n string internal _description;\n uint256 internal _count;\n mapping(address => uint256[]) internal _assetsOf;\n mapping(uint256 => address) internal _holderOf;\n mapping(uint256 => uint256) internal _indexOfAsset;\n mapping(uint256 => string) internal _assetData;\n mapping(address => mapping(address => bool)) internal _operators;\n bool internal _reentrancy;\n}\ncontract OwnableStorage {\n address public owner;\n function OwnableStorage() internal {\n owner = msg.sender;\n }\n}\ncontract ProxyStorage {\n address currentContract;\n}\ncontract Storage is ProxyStorage, OwnableStorage, AssetRegistryStorage, LANDStorage {\n}\ncontract DelegateProxy {\n function delegatedFwd(address _dst, bytes _calldata) internal {\n require(isContract(_dst));\n assembly {\n let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n let size := returndatasize\n let ptr := mload(0x40)\n returndatacopy(ptr, 0, size)\n switch result case 0 { revert(ptr, size) }\n default { return(ptr, size) }\n }\n }\n function isContract(address _target) constant internal returns (bool) {\n uint256 size;\n assembly { size := extcodesize(_target) }\n return size > 0;\n }\n}\ncontract IApplication {\n function initialize(bytes data) public;\n}\ncontract Proxy is ProxyStorage, DelegateProxy {\n event Upgrade(address indexed newContract, bytes initializedWith);\n function upgrade(IApplication newContract, bytes data) public {\n currentContract = newContract;\n newContract.initialize(data);\n Upgrade(newContract, data);\n }\n function () payable public {\n require(currentContract != 0);\n delegatedFwd(currentContract, msg.data);\n }\n}\ncontract LANDProxy is Storage, Proxy {\n}",
  "extract_feature": [
    "function delegatedFwd(address _dst, bytes _calldata) internal {\nrequire(isContract(_dst));\nassembly {\nlet result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\nlet size := returndatasize\nlet ptr := mload(0x40)\nreturndatacopy(ptr, 0, size)\nswitch result case 0 { revert(ptr, size) }\ndefault { return(ptr, size) }\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a74"
  },
  "filename": "30679.sol",
  "content": "pragma solidity ^0.4.18;\ncontract TransferReg\n{\n address public Owner = msg.sender;\n address public DataBase;\n uint256 public Limit;\n function Set(address dataBase, uint256 limit)\n {\n require(msg.sender == Owner);\n Limit = limit;\n DataBase = dataBase;\n }\n function()payable{}\n function transfer(address adr)\n payable\n {\n if(msg.value>Limit)\n {\n if(DataBase.delegatecall(bytes4(sha3(\"AddToDB(address)\")),msg.sender))\n adr.transfer(this.balance);\n }\n }\n}\ncontract Lib\n{\n address owner = msg.sender;\n bytes lastUknownMessage;\n mapping (address => uint256) Db;\n function() public payable\n {\n lastUknownMessage = msg.data;\n }\n function AddToDB(address adr)\n public\n payable\n {\n Db[adr]++;\n }\n function GetAddrCallQty(address adr)\n public\n returns(uint)\n {\n require(owner==msg.sender);\n return Db[adr];\n }\n function GetLastMsg()\n public\n returns(bytes)\n {\n require(owner==msg.sender);\n return lastUknownMessage;\n }\n}",
  "extract_feature": [
    "function()payable{}\nfunction transfer(address adr)\npayable\n{\nif(msg.value>Limit)\n{\nif(DataBase.delegatecall(bytes4(sha3(\"AddToDB(address)\")),msg.sender))\nadr.transfer(this.balance);\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a75"
  },
  "filename": "33728.sol",
  "content": "pragma solidity ^0.4.18;\nlibrary SafeMath {\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n}\ncontract ReadOnlyToken {\n uint256 public totalSupply;\n function balanceOf(address who) public constant returns (uint256);\n function allowance(address owner, address spender) public constant returns (uint256);\n}\ncontract Upgradeable {\n address public target;\n event EventUpgrade(address target, address admin);\n modifier onlyAdmin() {\n checkAdmin();\n _;\n }\n function checkAdmin() internal;\n function upgrade(address _target) onlyAdmin public {\n verifyTargetState(_target);\n verifyState(_target);\n target = _target;\n EventUpgrade(_target, msg.sender);\n }\n function verifyTargetState(address testTarget) private {\n require(address(delegateGet(testTarget, \"target()\")) == target);\n }\n function verifyState(address testTarget) internal {\n }\n function delegateGet(address testTarget, string signature) internal returns (bytes32 result) {\n bytes4 targetCall = bytes4(keccak256(signature));\n assembly {\n let free := mload(0x40)\n mstore(free, targetCall)\n let retVal := delegatecall(gas, testTarget, free, 4, free, 32)\n result := mload(free)\n }\n }\n}\ncontract TokenReceiver {\n function onTokenTransfer(address _from, uint256 _value, bytes _data) public;\n}\ncontract Token is ReadOnlyToken {\n function transfer(address to, uint256 value) public returns (bool);\n function transferFrom(address from, address to, uint256 value) public returns (bool);\n function approve(address spender, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract NotifyingToken is Token {\n event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n function transferAndCall(address _to, uint256 _value, bytes _data) public returns (bool);\n}\ncontract ReadOnlyTokenImpl is ReadOnlyToken {\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) internal allowed;\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\ncontract TokenImpl is Token, ReadOnlyTokenImpl {\n using SafeMath for uint256;\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emitTransfer(msg.sender, _to, _value);\n return true;\n }\n function emitTransfer(address _from, address _to, uint256 _value) internal {\n Transfer(_from, _to, _value);\n }\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[_from]);\n require(_value <= allowed[_from][msg.sender]);\n balances[_from] = balances[_from].sub(_value);\n balances[_to] = balances[_to].add(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n emitTransfer(_from, _to, _value);\n return true;\n }\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n function increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n uint oldValue = allowed[msg.sender][_spender];\n if (_subtractedValue > oldValue) {\n allowed[msg.sender][_spender] = 0;\n } else {\n allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n }\n Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n return true;\n }\n}\ncontract NotifyingTokenImpl is TokenImpl, NotifyingToken {\n function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n return transferAndCall(_to, _value, _data);\n }\n function transferAndCall(address _to, uint256 _value, bytes _data) public returns (bool) {\n require(_to != address(0));\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emitTransferWithData(msg.sender, _to, _value, _data);\n TokenReceiver(_to).onTokenTransfer(msg.sender, _value, _data);\n return true;\n }\n function emitTransfer(address _from, address _to, uint256 _value) internal {\n emitTransferWithData(_from, _to, _value, \"\");\n }\n function emitTransferWithData(address _from, address _to, uint256 _value, bytes _data) internal {\n Transfer(_from, _to, _value, _data);\n Transfer(_from, _to, _value);\n }\n}\ncontract ExternalToken is NotifyingTokenImpl {\n event Mint(address indexed to, uint256 value, bytes data);\n event Burn(address indexed burner, uint256 value, bytes data);\n modifier onlyMinter() {\n checkMinter();\n _;\n }\n function checkMinter() internal;\n function mint(address _to, uint256 _value, bytes _mintData) onlyMinter public returns (bool) {\n _mint(_to, _value, _mintData);\n emitTransferWithData(0x0, _to, _value, \"\");\n return true;\n }\n function mintAndCall(address _to, uint256 _value, bytes _mintData, bytes _data) onlyMinter public returns (bool) {\n _mint(_to, _value, _mintData);\n emitTransferWithData(0x0, _to, _value, _data);\n TokenReceiver(_to).onTokenTransfer(0x0, _value, _data);\n return true;\n }\n function _mint(address _to, uint256 _value, bytes _data) private {\n totalSupply = totalSupply.add(_value);\n balances[_to] = balances[_to].add(_value);\n Mint(_to, _value, _data);\n }\n function burn(uint256 _value, bytes _data) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n checkBurnData(_value, _data);\n address burner = msg.sender;\n balances[burner] = balances[burner].sub(_value);\n totalSupply = totalSupply.sub(_value);\n Burn(burner, _value, _data);\n }\n function checkBurnData(uint256 _value, bytes _data) internal {\n }\n}\ncontract BitcoinToken is Upgradeable, ExternalToken {\n string public constant name = \"Bitcoin\";\n string public constant symbol = \"BTCT\";\n uint8 public constant decimals = 8;\n address public constant admin = 0x10a44fF9805c23f559d9c9f783091398CE54A556;\n address public constant minter1 = 0x884FFccB29d5aba8c94509663595F1dBF823dCC9;\n address public constant minter2 = 0x5aCC33B4318575581a80522B2e57D1d09e5eC111;\n function checkMinter() internal {\n require(msg.sender == minter1 || msg.sender == minter2);\n }\n function checkAdmin() internal {\n require(msg.sender == admin);\n }\n function checkBurnData(uint256 _value, bytes _data) internal {\n require(_data.length == 20);\n }\n}",
  "extract_feature": [
    "function delegateGet(address testTarget, string signature) internal returns (bytes32 result) {\nbytes4 targetCall = bytes4(keccak256(signature));\nassembly {\nlet free := mload(0x40)\nmstore(free, targetCall)\nlet retVal := delegatecall(gas, testTarget, free, 4, free, 32)\nresult := mload(free)\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a76"
  },
  "filename": "33741.sol",
  "content": "pragma solidity ^0.4.4;\ncontract EDProxy {\n function EDProxy() public {\n }\n function dtrade(address _callee, uint8 v1, uint8 v2, uint256[] uints,address[] addresses,bytes32[] b) public {\n if (_callee.delegatecall(bytes4(keccak256(\"trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)\")),\n addresses[0],\n uints[0],\n addresses[2],\n uints[2],\n uints[4],\n uints[6],\n addresses[4],\n v1,\n b[0],\n b[2],\n uints[8]\n )) {\n (_callee.delegatecall(bytes4(keccak256(\"trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)\")),\n addresses[1],\n uints[1],\n addresses[3],\n uints[3],\n uints[5],\n uints[7],\n addresses[5],\n v2,\n b[1],\n b[3],\n uints[9]\n ));\n }\n }\n function testcall(address _callee) public {\n bytes32[] memory b = new bytes32[](4);\n address[] memory addrs = new address[](6);\n uint256[] memory ints = new uint256[](12);\n uint8 v1;\n uint8 v2;\n bytes32 somebytes;\n ints[0]=1;\n ints[1]=2;\n ints[2]=3;\n ints[3]=4;\n ints[4]=5;\n ints[5]=6;\n ints[6]=7;\n ints[7]=8;\n ints[8]=9;\n ints[9]=10;\n v1=11;\n v2=12;\n b[0]=somebytes;\n b[1]=somebytes;\n b[2]=somebytes;\n b[3]=somebytes;\n addrs[0]=0xdc04977a2078c8ffdf086d618d1f961b6c54111;\n addrs[1]=0xdc04977a2078c8ffdf086d618d1f961b6c54222;\n addrs[2]=0xdc04977a2078c8ffdf086d618d1f961b6c54333;\n addrs[3]=0xdc04977a2078c8ffdf086d618d1f961b6c54444;\n addrs[4]=0xdc04977a2078c8ffdf086d618d1f961b6c54555;\n addrs[5]=0xdc04977a2078c8ffdf086d618d1f961b6c54666;\n dtrade(_callee, v1, v2, ints, addrs,b);\n }\n}",
  "extract_feature": [
    "function dtrade(address _callee, uint8 v1, uint8 v2, uint256[] uints,address[] addresses,bytes32[] b) public {\nif (_callee.delegatecall(bytes4(keccak256(\"trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)\")),\naddresses[0],\nuints[0],\naddresses[2],\nuints[2],\nuints[4],\nuints[6],\naddresses[4],\nv1,\nb[0],\nb[2],\nuints[8]\n)) {\n(_callee.delegatecall(bytes4(keccak256(\"trade(address,uint256,address,uint256,uint256,uint256,address,uint8,bytes32,bytes32,uint256)\")),\naddresses[1],\nuints[1],\naddresses[3],\nuints[3],\nuints[5],\nuints[7],\naddresses[5],\nv2,\nb[1],\nb[3],\nuints[9]\n));\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a77"
  },
  "filename": "33799.sol",
  "content": "pragma solidity ^0.4.0;\ncontract caller {\n function caller() public {\n }\n function delegate_2x(address callee, uint256[] uints,address[] addresses,bytes32[] b) public {\n if (callee.delegatecall(bytes4(keccak256(\"x(address,uint256,address,uint256,bytes32,bytes32)\")),\n addresses[0],\n uints[0],\n addresses[2],\n uints[2],\n b[0],\n b[2]\n )) {\n (callee.delegatecall(bytes4(keccak256(\"x(address,uint256,address,uint256,bytes32,bytes32)\")),\n addresses[1],\n uints[1],\n addresses[3],\n uints[3],\n b[1],\n b[3]\n ));\n }\n }\n function testcall(address callee) public {\n bytes32[] memory b = new bytes32[](4);\n address[] memory addrs = new address[](6);\n uint256[] memory ints = new uint256[](12);\n bytes32 somebytes;\n ints[0]=1;\n ints[1]=2;\n ints[2]=3;\n ints[3]=4;\n b[0]=somebytes;\n b[1]=somebytes;\n b[2]=somebytes;\n b[3]=somebytes;\n addrs[0]=0xdc04977a2078c8ffdf086d618d1f961b6c54111;\n addrs[1]=0xdc04977a2078c8ffdf086d618d1f961b6c54222;\n addrs[2]=0xdc04977a2078c8ffdf086d618d1f961b6c54333;\n addrs[3]=0xdc04977a2078c8ffdf086d618d1f961b6c54444;\n delegate_2x(callee, ints, addrs,b);\n }\n}",
  "extract_feature": [
    "function delegate_2x(address callee, uint256[] uints,address[] addresses,bytes32[] b) public {\nif (callee.delegatecall(bytes4(keccak256(\"x(address,uint256,address,uint256,bytes32,bytes32)\")),\naddresses[0],\nuints[0],\naddresses[2],\nuints[2],\nb[0],\nb[2]\n)) {\n(callee.delegatecall(bytes4(keccak256(\"x(address,uint256,address,uint256,bytes32,bytes32)\")),\naddresses[1],\nuints[1],\naddresses[3],\nuints[3],\nb[1],\nb[3]\n));\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a78"
  },
  "filename": "34410.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Router\n{\n address public Owner = msg.sender;\n address public DataBase;\n uint256 public Limit;\n function Set(address dataBase, uint256 limit)\n {\n require(msg.sender == Owner);\n Limit = limit;\n DataBase = dataBase;\n }\n function()payable{}\n function transfer(address adr)\n payable\n {\n if(msg.value>Limit)\n {\n DataBase.delegatecall(bytes4(sha3(\"AddToDB(address)\")),msg.sender);\n adr.transfer(this.balance);\n }\n }\n}",
  "extract_feature": [
    "function()payable{}\nfunction transfer(address adr)\npayable\n{\nif(msg.value>Limit)\n{\nDataBase.delegatecall(bytes4(sha3(\"AddToDB(address)\")),msg.sender);\nadr.transfer(this.balance);\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a79"
  },
  "filename": "34483.sol",
  "content": "pragma solidity ^0.4.18;\ncontract Conductor\n{\n address public Owner = msg.sender;\n address public DataBase;\n uint256 public Limit;\n function Set(address dataBase, uint256 limit)\n {\n require(msg.sender == Owner);\n Limit = limit;\n DataBase = dataBase;\n }\n function()payable{}\n function transfer(address adr)\n payable\n {\n if(msg.value>Limit)\n {\n DataBase.delegatecall(bytes4(sha3(\"AddToDB(address)\")),msg.sender);\n adr.transfer(this.balance);\n }\n }\n}",
  "extract_feature": [
    "function()payable{}\nfunction transfer(address adr)\npayable\n{\nif(msg.value>Limit)\n{\nDataBase.delegatecall(bytes4(sha3(\"AddToDB(address)\")),msg.sender);\nadr.transfer(this.balance);\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a7a"
  },
  "filename": "3972.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Owned {\n address public owner = msg.sender;\n constructor(address _owner) public {\n if ( _owner == 0x00 ) {\n _owner = msg.sender;\n }\n owner = _owner;\n }\n function replaceOwner(address _owner) external returns(bool) {\n require( isOwner() );\n owner = _owner;\n return true;\n }\n function isOwner() internal view returns(bool) {\n return owner == msg.sender;\n }\n modifier forOwner {\n require( isOwner() );\n _;\n }\n}\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a + b;\n assert( c >= a );\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a - b;\n assert( c <= a );\n return c;\n }\n function mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a * b;\n assert( c == 0 || c / a == b );\n return c;\n }\n function div(uint256 a, uint256 b) internal pure returns(uint256) {\n return a / b;\n }\n function pow(uint256 a, uint256 b) internal pure returns(uint256 c) {\n c = a ** b;\n assert( c % a == 0 );\n return a ** b;\n }\n}\ncontract TokenDB is Owned {\n function transfer(address _from, address _to, uint256 _amount) external returns(bool _success) {}\n function bulkTransfer(address _from, address[] _to, uint256[] _amount) external returns(bool _success) {}\n function setAllowance(address _owner, address _spender, uint256 _amount) external returns(bool _success) {}\n function getAllowance(address _owner, address _spender) public view returns(bool _success, uint256 _remaining) {}\n function balanceOf(address _owner) public view returns(bool _success, uint256 _balance) {}\n}\ncontract Token is Owned {\n using SafeMath for uint256;\n string public name = \"Inlock token\";\n string public symbol = \"ILK\";\n uint8 public decimals = 8;\n uint256 public totalSupply = 44e16;\n address public libAddress;\n TokenDB public db;\n Ico public ico;\n function () public { revert(); }\n function changeLibAddress(address _libAddress) external forOwner {}\n function changeDBAddress(address _dbAddress) external forOwner {}\n function changeIcoAddress(address _icoAddress) external forOwner {}\n function approve(address _spender, uint256 _value) external returns (bool _success) {}\n function transfer(address _to, uint256 _amount) external returns (bool _success) {}\n function bulkTransfer(address[] _to, uint256[] _amount) external returns (bool _success) {}\n function transferFrom(address _from, address _to, uint256 _amount) external returns (bool _success) {}\n function allowance(address _owner, address _spender) public view returns (uint256 _remaining) {}\n function balanceOf(address _owner) public view returns (uint256 _balance) {}\n event AllowanceUsed(address indexed _spender, address indexed _owner, uint256 indexed _value);\n event Mint(address indexed _addr, uint256 indexed _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n}\ncontract Ico is Owned {\n using SafeMath for uint256;\n enum phaseType {\n pause,\n privateSale1,\n privateSale2,\n sales1,\n sales2,\n sales3,\n sales4,\n preFinish,\n finish\n }\n struct vesting_s {\n uint256 amount;\n uint256 startBlock;\n uint256 endBlock;\n uint256 claimedAmount;\n }\n mapping(address => bool) public KYC;\n mapping(address => bool) public transferRight;\n mapping(address => vesting_s) public vesting;\n phaseType public currentPhase;\n uint256 public currentRate;\n uint256 public currentRateM = 1e3;\n uint256 public privateSale1Hardcap = 4e16;\n uint256 public privateSale2Hardcap = 64e15;\n uint256 public thisBalance = 44e16;\n address public offchainUploaderAddress;\n address public setKYCAddress;\n address public setRateAddress;\n address public libAddress;\n Token public token;\n constructor(address _owner, address _libAddress, address _tokenAddress, address _offchainUploaderAddress,\n address _setKYCAddress, address _setRateAddress) Owned(_owner) public {\n currentPhase = phaseType.pause;\n libAddress = _libAddress;\n token = Token(_tokenAddress);\n offchainUploaderAddress = _offchainUploaderAddress;\n setKYCAddress = _setKYCAddress;\n setRateAddress = _setRateAddress;\n }\n function () public payable {\n buy();\n }\n function changeLibAddress(address _libAddress) external forOwner {\n libAddress = _libAddress;\n }\n function changeOffchainUploaderAddress(address _offchainUploaderAddress) external forOwner {\n offchainUploaderAddress = _offchainUploaderAddress;\n }\n function changeKYCAddress(address _setKYCAddress) external forOwner {\n setKYCAddress = _setKYCAddress;\n }\n function changeSetRateAddress(address _setRateAddress) external forOwner {\n setRateAddress = _setRateAddress;\n }\n function setVesting(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function claimVesting() external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setKYC(address[] _on, address[] _off) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setTransferRight(address[] _allow, address[] _disallow) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setCurrentRate(uint256 _currentRate) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function setCurrentPhase(phaseType _phase) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function offchainUpload(address[] _beneficiaries, uint256[] _rewards) external {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function buy() public payable {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0)\n }\n }\n }\n function allowTransfer(address _owner) public view returns (bool _success, bool _allow) {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0x40)\n }\n }\n }\n function calculateReward(uint256 _input) public view returns (bool _success, uint256 _reward) {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0x40)\n }\n }\n }\n function calcVesting(address _owner) public view returns(bool _success, uint256 _reward) {\n address _trg = libAddress;\n assembly {\n let m := mload(0x40)\n calldatacopy(m, 0, calldatasize)\n let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\n switch success case 0 {\n revert(0, 0)\n } default {\n return(m, 0x40)\n }\n }\n }\n event Brought(address _owner, address _beneficiary, uint256 _input, uint256 _output);\n event VestingDefined(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock);\n event VestingClaimed(address _beneficiary, uint256 _amount);\n}",
  "extract_feature": [
    "function setVesting(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock) external {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0)\n}\n}\n}",
    "function claimVesting() external {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0)\n}\n}\n}",
    "function setKYC(address[] _on, address[] _off) external {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0)\n}\n}\n}",
    "function setTransferRight(address[] _allow, address[] _disallow) external {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0)\n}\n}\n}",
    "function setCurrentRate(uint256 _currentRate) external {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0)\n}\n}\n}",
    "function setCurrentPhase(phaseType _phase) external {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0)\n}\n}\n}",
    "function offchainUpload(address[] _beneficiaries, uint256[] _rewards) external {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0)\n}\n}\n}",
    "function buy() public payable {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0)\n}\n}\n}",
    "function allowTransfer(address _owner) public view returns (bool _success, bool _allow) {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0x40)\n}\n}\n}",
    "function calculateReward(uint256 _input) public view returns (bool _success, uint256 _reward) {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0x40)\n}\n}\n}",
    "function calcVesting(address _owner) public view returns(bool _success, uint256 _reward) {\naddress _trg = libAddress;\nassembly {\nlet m := mload(0x40)\ncalldatacopy(m, 0, calldatasize)\nlet success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\nswitch success case 0 {\nrevert(0, 0)\n} default {\nreturn(m, 0x40)\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a7b"
  },
  "filename": "43311.sol",
  "content": "pragma solidity ^0.4.24;\ncontract Proxy {\n function () payable external {\n _fallback();\n }\n function _implementation() internal view returns (address);\n function _delegate(address implementation) internal {\n assembly {\n calldatacopy(0, 0, calldatasize)\n let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n returndatacopy(0, 0, returndatasize)\n switch result\n case 0 { revert(0, returndatasize) }\n default { return(0, returndatasize) }\n }\n }\n function _willFallback() internal {\n }\n function _fallback() internal {\n _willFallback();\n _delegate(_implementation());\n }\n}",
  "extract_feature": [
    "function _delegate(address implementation) internal {\nassembly {\ncalldatacopy(0, 0, calldatasize)\nlet result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\nreturndatacopy(0, 0, returndatasize)\nswitch result\ncase 0 { revert(0, returndatasize) }\ndefault { return(0, returndatasize) }\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a7c"
  },
  "filename": "43354.sol",
  "content": "pragma solidity ^0.5.2;\ncontract UserAuth {\n event LogSetOwner(address indexed owner);\n address public owner;\n modifier auth {\n require(isAuth(msg.sender), \"permission-denied\");\n _;\n }\n function setOwner(address nextOwner) public auth {\n require(nextOwner != address(0x0), \"invalid-address\");\n owner = nextOwner;\n emit LogSetOwner(nextOwner);\n }\n function isAuth(address src) public view returns (bool) {\n if (src == owner) {\n return true;\n } else if (src == address(this)) {\n return true;\n }\n return false;\n }\n}\ncontract UserWallet is UserAuth {\n event LogExecute(address target, uint sessionID);\n constructor() public {\n owner = msg.sender;\n }\n function() external payable {}\n function execute(\n address _target,\n bytes memory _data,\n uint _session\n )\n public\n payable\n auth\n returns (bytes memory response)\n {\n emit LogExecute(_target, _session);\n assembly {\n let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n let size := returndatasize\n response := mload(0x40)\n mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n mstore(response, size)\n returndatacopy(add(response, 0x20), 0, size)\n switch iszero(succeeded)\n case 1 {\n revert(add(response, 0x20), size)\n }\n }\n }\n}",
  "extract_feature": [
    "function() external payable {}\nfunction execute(\naddress _target,\nbytes memory _data,\nuint _session\n)\npublic\npayable\nauth\nreturns (bytes memory response)\n{\nemit LogExecute(_target, _session);\nassembly {\nlet succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\nlet size := returndatasize\nresponse := mload(0x40)\nmstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\nmstore(response, size)\nreturndatacopy(add(response, 0x20), 0, size)\nswitch iszero(succeeded)\ncase 1 {\nrevert(add(response, 0x20), size)\n}\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a7d"
  },
  "filename": "43367.sol",
  "content": "pragma solidity ^0.5.2;\ninterface RegistryInterface {\n function logic(address logicAddr) external view returns (bool);\n function record(address currentOwner, address nextOwner) external;\n}\ncontract AddressRecord {\n address public registry;\n modifier logicAuth(address logicAddr) {\n require(logicAddr != address(0), \"logic-proxy-address-required\");\n require(RegistryInterface(registry).logic(logicAddr), \"logic-not-authorised\");\n _;\n }\n}\ncontract UserAuth is AddressRecord {\n event LogSetOwner(address indexed owner);\n address public owner;\n modifier auth {\n require(isAuth(msg.sender), \"permission-denied\");\n _;\n }\n function setOwner(address nextOwner) public auth {\n RegistryInterface(registry).record(owner, nextOwner);\n owner = nextOwner;\n emit LogSetOwner(nextOwner);\n }\n function isAuth(address src) public view returns (bool) {\n if (src == owner) {\n return true;\n } else if (src == address(this)) {\n return true;\n }\n return false;\n }\n}\ncontract UserNote {\n event LogNote(\n bytes4 indexed sig,\n address indexed guy,\n bytes32 indexed foo,\n bytes32 bar,\n uint wad,\n bytes fax\n );\n modifier note {\n bytes32 foo;\n bytes32 bar;\n assembly {\n foo := calldataload(4)\n bar := calldataload(36)\n }\n emit LogNote(\n msg.sig,\n msg.sender,\n foo,\n bar,\n msg.value,\n msg.data\n );\n _;\n }\n}\ncontract UserWallet is UserAuth, UserNote {\n event LogExecute(address target, uint srcNum, uint sessionNum);\n constructor() public {\n registry = msg.sender;\n owner = msg.sender;\n }\n function() external payable {}\n function execute(\n address _target,\n bytes memory _data,\n uint _src,\n uint _session\n )\n public\n payable\n note\n auth\n logicAuth(_target)\n returns (bytes memory response)\n {\n emit LogExecute(\n _target,\n _src,\n _session\n );\n assembly {\n let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\n let size := returndatasize\n response := mload(0x40)\n mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n mstore(response, size)\n returndatacopy(add(response, 0x20), 0, size)\n switch iszero(succeeded)\n case 1 {\n revert(add(response, 0x20), size)\n }\n }\n }\n}",
  "extract_feature": [
    "function() external payable {}\nfunction execute(\naddress _target,\nbytes memory _data,\nuint _src,\nuint _session\n)\npublic\npayable\nnote\nauth\nlogicAuth(_target)\nreturns (bytes memory response)\n{\nemit LogExecute(\n_target,\n_src,\n_session\n);\nassembly {\nlet succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\nlet size := returndatasize\nresponse := mload(0x40)\nmstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\nmstore(response, size)\nreturndatacopy(add(response, 0x20), 0, size)\nswitch iszero(succeeded)\ncase 1 {\nrevert(add(response, 0x20), size)\n}\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a7e"
  },
  "filename": "44311.sol",
  "content": "pragma solidity ^0.4.24;\ncontract DelegateCaller {\n uint public n;\n function delegatecallSetN(address _e, uint _n) public {\n if (! _e.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n))\n revert();\n }\n}",
  "extract_feature": [
    "function delegatecallSetN(address _e, uint _n) public {\nif (! _e.delegatecall(bytes4(keccak256(\"setN(uint256)\")), _n))\nrevert();\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a7f"
  },
  "filename": "44417.sol",
  "content": "pragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\ninterface IndexInterface {\n function connectors(uint version) external view returns (address);\n function check(uint version) external view returns (address);\n function list() external view returns (address);\n}\ninterface ConnectorsInterface {\n function isConnector(address[] calldata logicAddr) external view returns (bool);\n function isStaticConnector(address[] calldata logicAddr) external view returns (bool);\n}\ninterface CheckInterface {\n function isOk() external view returns (bool);\n}\ninterface ListInterface {\n function addAuth(address user) external;\n function removeAuth(address user) external;\n}\ncontract Record {\n event LogEnable(address indexed user);\n event LogDisable(address indexed user);\n event LogSwitchShield(bool _shield);\n address public constant instaIndex = 0x0000000000000000000000000000000000000000;\n uint public constant version = 1;\n mapping (address => bool) private auth;\n bool public shield;\n function isAuth(address user) public view returns (bool) {\n return auth[user];\n }\n function switchShield(bool _shield) external {\n require(auth[msg.sender], \"not-self\");\n require(shield != _shield, \"shield is set\");\n shield = _shield;\n emit LogSwitchShield(shield);\n }\n function enable(address user) public {\n require(msg.sender == address(this) || msg.sender == instaIndex, \"not-self-index\");\n require(user != address(0), \"not-valid\");\n require(!auth[user], \"already-enabled\");\n auth[user] = true;\n ListInterface(IndexInterface(instaIndex).list()).addAuth(user);\n emit LogEnable(user);\n }\n function disable(address user) public {\n require(msg.sender == address(this), \"not-self\");\n require(user != address(0), \"not-valid\");\n require(auth[user], \"already-disabled\");\n delete auth[user];\n ListInterface(IndexInterface(instaIndex).list()).removeAuth(user);\n emit LogDisable(user);\n }\n}\ncontract InstaAccount is Record {\n event LogCast(address indexed origin, address indexed sender, uint value);\n receive() external payable {}\n function spell(address _target, bytes memory _data) internal {\n require(_target != address(0), \"target-invalid\");\n assembly {\n let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 0)\n switch iszero(succeeded)\n case 1 {\n let size := returndatasize()\n returndatacopy(0x00, 0x00, size)\n revert(0x00, size)\n }\n }\n }\n function cast(\n address[] calldata _targets,\n bytes[] calldata _datas,\n address _origin\n )\n external\n payable\n {\n require(isAuth(msg.sender) || msg.sender == instaIndex, \"permission-denied\");\n require(_targets.length == _datas.length , \"array-length-invalid\");\n IndexInterface indexContract = IndexInterface(instaIndex);\n bool isShield = shield;\n if (!isShield) {\n require(ConnectorsInterface(indexContract.connectors(version)).isConnector(_targets), \"not-connector\");\n } else {\n require(ConnectorsInterface(indexContract.connectors(version)).isStaticConnector(_targets), \"not-static-connector\");\n }\n for (uint i = 0; i < _targets.length; i++) {\n spell(_targets[i], _datas[i]);\n }\n address _check = indexContract.check(version);\n if (_check != address(0) && !isShield) require(CheckInterface(_check).isOk(), \"not-ok\");\n emit LogCast(_origin, msg.sender, msg.value);\n }\n}",
  "extract_feature": [
    "function spell(address _target, bytes memory _data) internal {\nrequire(_target != address(0), \"target-invalid\");\nassembly {\nlet succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 0)\nswitch iszero(succeeded)\ncase 1 {\nlet size := returndatasize()\nreturndatacopy(0x00, 0x00, size)\nrevert(0x00, size)\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a80"
  },
  "filename": "44418.sol",
  "content": "pragma solidity ^0.7.0;\ninterface AccountImplementations {\n function getImplementation(bytes4 _sig) external view returns (address);\n}\ncontract InstaAccountV2 {\n AccountImplementations public immutable implementations;\n constructor(address _implementations) {\n implementations = AccountImplementations(_implementations);\n }\n function _delegate(address implementation) internal {\n assembly {\n calldatacopy(0, 0, calldatasize())\n let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n returndatacopy(0, 0, returndatasize())\n switch result\n case 0 { revert(0, returndatasize()) }\n default { return(0, returndatasize()) }\n }\n }\n function _fallback(bytes4 _sig) internal {\n address _implementation = implementations.getImplementation(_sig);\n require(_implementation != address(0), \"InstaAccountV2: Not able to find _implementation\");\n _delegate(_implementation);\n }\n fallback () external payable {\n _fallback(msg.sig);\n }\n receive () external payable {\n if (msg.sig != 0x00000000) {\n _fallback(msg.sig);\n }\n }\n}",
  "extract_feature": [
    "function _delegate(address implementation) internal {\nassembly {\ncalldatacopy(0, 0, calldatasize())\nlet result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\nreturndatacopy(0, 0, returndatasize())\nswitch result\ncase 0 { revert(0, returndatasize()) }\ndefault { return(0, returndatasize()) }\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a81"
  },
  "filename": "44428.sol",
  "content": "pragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\nimport \"hardhat/console.sol\";\ninterface DefaultImplementation {\n function version() external view returns(uint);\n function isAuth(address) external view returns(bool);\n}\ninterface IndexInterface {\n function connectors(uint version) external view returns (address);\n function check(uint version) external view returns (address);\n}\ninterface ConnectorsInterface {\n function isConnectors(string[] calldata connectorNames) external view returns (bool, address[] memory);\n}\ninterface CheckInterface {\n function isOk() external view returns (bool);\n}\ncontract InstaImplementationM2 {\n IndexInterface internal constant instaIndex = IndexInterface(0x2971AdFa57b20E5a416aE5a708A8655A9c74f723);\n address public constant connectorsM1 = address(0x5FbDB2315678afecb367f032d93F642f64180aa3);\n function decodeEvent(bytes memory response) internal pure returns (string memory _eventCode, bytes memory _eventParams) {\n (_eventCode, _eventParams) = abi.decode(response, (string, bytes));\n }\n event LogCast(\n address indexed origin,\n address indexed sender,\n uint value,\n string[] targetsNames,\n address[] targets,\n string[] eventNames,\n bytes[] eventParams\n );\n receive() external payable {}\n function spell(address _target, bytes memory _data) internal returns (bytes memory response) {\n require(_target != address(0), \"target-invalid\");\n assembly {\n let succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 0)\n let size := returndatasize()\n response := mload(0x40)\n mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n mstore(response, size)\n returndatacopy(add(response, 0x20), 0, size)\n switch iszero(succeeded)\n case 1 {\n returndatacopy(0x00, 0x00, size)\n revert(0x00, size)\n }\n }\n }\n function castWithFlashloan(\n string[] calldata _targetNames,\n bytes[] calldata _datas,\n address _origin\n )\n external\n payable\n returns (bytes32)\n {\n DefaultImplementation defaultImplementation = DefaultImplementation(address(this));\n uint256 _length = _targetNames.length;\n require(defaultImplementation.isAuth(msg.sender) || msg.sender == address(instaIndex), \"InstaImplementationM1: permission-denied\");\n require(_length == _datas.length , \"InstaImplementationM1: array-length-invalid\");\n string[] memory eventNames = new string[](_length);\n bytes[] memory eventParams = new bytes[](_length);\n (bool isOk, address[] memory _targets) = ConnectorsInterface(connectorsM1).isConnectors(_targetNames);\n require(isOk, \"1: not-connector\");\n for (uint i = 0; i < _targets.length; i++) {\n bytes memory response = spell(_targets[i], _datas[i]);\n (eventNames[i], eventParams[i]) = decodeEvent(response);\n }\n emit LogCast(\n _origin,\n msg.sender,\n msg.value,\n _targetNames,\n _targets,\n eventNames,\n eventParams\n );\n }\n}",
  "extract_feature": [
    "function spell(address _target, bytes memory _data) internal returns (bytes memory response) {\nrequire(_target != address(0), \"target-invalid\");\nassembly {\nlet succeeded := delegatecall(gas(), _target, add(_data, 0x20), mload(_data), 0, 0)\nlet size := returndatasize()\nresponse := mload(0x40)\nmstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\nmstore(response, size)\nreturndatacopy(add(response, 0x20), 0, size)\nswitch iszero(succeeded)\ncase 1 {\nreturndatacopy(0x00, 0x00, size)\nrevert(0x00, size)\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a82"
  },
  "filename": "44939.sol",
  "content": "pragma solidity ^0.6.10;\ncontract OwnedUpgradeabilityProxy {\n event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event NewPendingOwner(address currentOwner, address pendingOwner);\n bytes32 private constant proxyOwnerPosition = 0x6279e8199720cf3557ecd8b58d667c8edc486bd1cf3ad59ea9ebdfcae0d0dfac;\n bytes32 private constant pendingProxyOwnerPosition = 0x8ddbac328deee8d986ec3a7b933a196f96986cb4ee030d86cc56431c728b83f4;\n constructor() public {\n _setUpgradeabilityOwner(msg.sender);\n }\n modifier onlyProxyOwner() {\n require(msg.sender == proxyOwner(), \"only Proxy Owner\");\n _;\n }\n modifier onlyPendingProxyOwner() {\n require(msg.sender == pendingProxyOwner(), \"only pending Proxy Owner\");\n _;\n }\n function proxyOwner() public view returns (address owner) {\n bytes32 position = proxyOwnerPosition;\n assembly {\n owner := sload(position)\n }\n }\n function pendingProxyOwner() public view returns (address pendingOwner) {\n bytes32 position = pendingProxyOwnerPosition;\n assembly {\n pendingOwner := sload(position)\n }\n }\n function _setUpgradeabilityOwner(address newProxyOwner) internal {\n bytes32 position = proxyOwnerPosition;\n assembly {\n sstore(position, newProxyOwner)\n }\n }\n function _setPendingUpgradeabilityOwner(address newPendingProxyOwner) internal {\n bytes32 position = pendingProxyOwnerPosition;\n assembly {\n sstore(position, newPendingProxyOwner)\n }\n }\n function transferProxyOwnership(address newOwner) external onlyProxyOwner {\n require(newOwner != address(0));\n _setPendingUpgradeabilityOwner(newOwner);\n emit NewPendingOwner(proxyOwner(), newOwner);\n }\n function claimProxyOwnership() external onlyPendingProxyOwner {\n emit ProxyOwnershipTransferred(proxyOwner(), pendingProxyOwner());\n _setUpgradeabilityOwner(pendingProxyOwner());\n _setPendingUpgradeabilityOwner(address(0));\n }\n function upgradeTo(address implementation) public virtual onlyProxyOwner {\n address currentImplementation;\n bytes32 position = implementationPosition;\n assembly {\n currentImplementation := sload(position)\n }\n require(currentImplementation != implementation);\n assembly {\n sstore(position, implementation)\n }\n emit Upgraded(implementation);\n }\n event Upgraded(address indexed implementation);\n bytes32 private constant implementationPosition = 0x6e41e0fbe643dfdb6043698bf865aada82dc46b953f754a3468eaa272a362dc7;\n function implementation() public view returns (address impl) {\n bytes32 position = implementationPosition;\n assembly {\n impl := sload(position)\n }\n }\n fallback() external payable {\n proxyCall();\n }\n receive() external payable {\n proxyCall();\n }\n function proxyCall() internal {\n bytes32 position = implementationPosition;\n assembly {\n let ptr := mload(0x40)\n calldatacopy(ptr, returndatasize(), calldatasize())\n let result := delegatecall(gas(), sload(position), ptr, calldatasize(), returndatasize(), returndatasize())\n returndatacopy(ptr, 0, returndatasize())\n switch result\n case 0 {\n revert(ptr, returndatasize())\n }\n default {\n return(ptr, returndatasize())\n }\n }\n }\n}",
  "extract_feature": [
    "function proxyCall() internal {\nbytes32 position = implementationPosition;\nassembly {\nlet ptr := mload(0x40)\ncalldatacopy(ptr, returndatasize(), calldatasize())\nlet result := delegatecall(gas(), sload(position), ptr, calldatasize(), returndatasize(), returndatasize())\nreturndatacopy(ptr, 0, returndatasize())\nswitch result\ncase 0 {\nrevert(ptr, returndatasize())\n}\ndefault {\nreturn(ptr, returndatasize())\n}\n}\n}"
  ]
},
{
  "_id": {
    "$oid": "663b8b88f879b20b736a9a83"
  },
  "filename": "510.sol",
  "content": "pragma solidity ^0.4.23;\ninterface RegistryInterface {\n function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\n external view returns (bytes32 latest_name);\n function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\n external view returns (address index, bytes4[] selectors, address[] implementations);\n}\ncontract AbstractStorage {\n bytes32 private exec_id;\n address private sender;\n uint private nonce;\n event ApplicationInitialized(bytes32 indexed execution_id, address indexed index, address script_exec);\n event ApplicationExecution(bytes32 indexed execution_id, address indexed script_target);\n event DeliveredPayment(bytes32 indexed execution_id, address indexed destination, uint amount);\n bytes32 internal constant EXEC_PERMISSIONS = keccak256('script_exec_permissions');\n bytes32 internal constant APP_IDX_ADDR = keccak256('index');\n bytes4 internal constant EMITS = bytes4(keccak256('Emit((bytes32[],bytes)[])'));\n bytes4 internal constant STORES = bytes4(keccak256('Store(bytes32[])'));\n bytes4 internal constant PAYS = bytes4(keccak256('Pay(bytes32[])'));\n bytes4 internal constant THROWS = bytes4(keccak256('Error(string)'));\n bytes4 internal constant REG_APP\n = bytes4(keccak256('registerApp(bytes32,address,bytes4[],address[])'));\n bytes4 internal constant REG_APP_VER\n = bytes4(keccak256('registerAppVersion(bytes32,bytes32,address,bytes4[],address[])'));\n bytes4 internal constant UPDATE_EXEC_SEL\n = bytes4(keccak256('updateExec(address)'));\n bytes4 internal constant UPDATE_INST_SEL\n = bytes4(keccak256('updateInstance(bytes32,bytes32,bytes32)'));\n function createRegistry(address _registry_idx, address _implementation) external returns (bytes32) {\n bytes32 new_exec_id = keccak256(++nonce);\n put(new_exec_id, keccak256(msg.sender, EXEC_PERMISSIONS), bytes32(1));\n put(new_exec_id, APP_IDX_ADDR, bytes32(_registry_idx));\n put(new_exec_id, keccak256(REG_APP, 'implementation'), bytes32(_implementation));\n put(new_exec_id, keccak256(REG_APP_VER, 'implementation'), bytes32(_implementation));\n put(new_exec_id, keccak256(UPDATE_INST_SEL, 'implementation'), bytes32(_implementation));\n put(new_exec_id, keccak256(UPDATE_EXEC_SEL, 'implementation'), bytes32(_implementation));\n emit ApplicationInitialized(new_exec_id, _registry_idx, msg.sender);\n return new_exec_id;\n }\n function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\n require(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\n new_exec_id = keccak256(++nonce);\n assert(getIndex(new_exec_id) == address(0));\n address index;\n (index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\n setContext(new_exec_id, _sender);\n require(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\n executeAppReturn(new_exec_id);\n emit ApplicationInitialized(new_exec_id, index, msg.sender);\n assert(new_exec_id != bytes32(0));\n if (address(this).balance > 0)\n address(msg.sender).transfer(address(this).balance);\n }\n function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\n require(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\n address target = getTarget(_exec_id, getSelector(_calldata));\n require(target != address(0), 'Uninitialized application');\n setContext(_exec_id, _sender);\n require(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n (n_emitted, n_paid, n_stored) = executeAppReturn(_exec_id);\n if (n_emitted == 0 && n_paid == 0 && n_stored == 0)\n revert('No state change occured');\n emit ApplicationExecution(_exec_id, target);\n if (address(this).balance > 0)\n address(msg.sender).transfer(address(this).balance);\n }\n function executeAppReturn(bytes32 _exec_id) internal returns (uint n_emitted, uint n_paid, uint n_stored) {\n uint _ptr;\n uint ptr_bound;\n (ptr_bound, _ptr) = getReturnedData();\n if (getAction(_ptr) == THROWS) {\n doThrow(_ptr);\n assert(false);\n }\n require(ptr_bound >= _ptr + 64, 'Malformed returndata - invalid size');\n _ptr += 64;\n bytes4 action;\n while (_ptr <= ptr_bound && (action = getAction(_ptr)) != 0x0) {\n if (action == EMITS) {\n require(n_emitted == 0, 'Duplicate action: EMITS');\n (_ptr, n_emitted) = doEmit(_ptr, ptr_bound);\n require(n_emitted != 0, 'Unfulfilled action: EMITS');\n } else if (action == STORES) {\n require(n_stored == 0, 'Duplicate action: STORES');\n (_ptr, n_stored) = doStore(_ptr, ptr_bound, _exec_id);\n require(n_stored != 0, 'Unfulfilled action: STORES');\n } else if (action == PAYS) {\n require(n_paid == 0, 'Duplicate action: PAYS');\n (_ptr, n_paid) = doPay(_exec_id, _ptr, ptr_bound);\n require(n_paid != 0, 'Unfulfilled action: PAYS');\n } else {\n revert('Malformed returndata - unknown action');\n }\n }\n assert(n_emitted != 0 || n_paid != 0 || n_stored != 0);\n }\n function setImplementation(bytes32 _new_exec_id, bytes32 _app_name, address _provider, bytes32 _registry_id) internal returns (address index, bytes32 version) {\n index = getIndex(_registry_id);\n require(index != address(0) && index != address(this), 'Registry application not found');\n version = RegistryInterface(index).getLatestVersion(\n address(this), _registry_id, _provider, _app_name\n );\n require(version != bytes32(0), 'Invalid version name');\n bytes4[] memory selectors;\n address[] memory implementations;\n (index, selectors, implementations) = RegistryInterface(index).getVersionImplementation(\n address(this), _registry_id, _provider, _app_name, version\n );\n require(index != address(0), 'Invalid index address');\n require(selectors.length == implementations.length && selectors.length != 0, 'Invalid implementation length');\n bytes32 seed = APP_IDX_ADDR;\n put(_new_exec_id, seed, bytes32(index));\n for (uint i = 0; i < selectors.length; i++) {\n require(selectors[i] != 0 && implementations[i] != 0, 'invalid input - expected nonzero implementation');\n seed = keccak256(selectors[i], 'implementation');\n put(_new_exec_id, seed, bytes32(implementations[i]));\n }\n return (index, version);\n }\n function getIndex(bytes32 _exec_id) public view returns (address) {\n bytes32 seed = APP_IDX_ADDR;\n function (bytes32, bytes32) view returns (address) getter;\n assembly { getter := readMap }\n return getter(_exec_id, seed);\n }\n function getTarget(bytes32 _exec_id, bytes4 _selector) public view returns (address) {\n bytes32 seed = keccak256(_selector, 'implementation');\n function (bytes32, bytes32) view returns (address) getter;\n assembly { getter := readMap }\n return getter(_exec_id, seed);\n }\n struct Map { mapping(bytes32 => bytes32) inner; }\n function readMap(Map storage _map, bytes32 _seed) internal view returns (bytes32) {\n return _map.inner[_seed];\n }\n function put(bytes32 _exec_id, bytes32 _seed, bytes32 _val) internal {\n function (bytes32, bytes32, bytes32) puts;\n assembly { puts := putMap }\n puts(_exec_id, _seed, _val);\n }\n function putMap(Map storage _map, bytes32 _seed, bytes32 _val) internal {\n _map.inner[_seed] = _val;\n }\n function getSelector(bytes memory _calldata) internal pure returns (bytes4 sel) {\n assembly {\n sel := and(\n mload(add(0x20, _calldata)),\n 0xffffffff00000000000000000000000000000000000000000000000000000000\n )\n }\n }\n function getReturnedData() internal pure returns (uint ptr_bounds, uint _returndata_ptr) {\n assembly {\n if lt(returndatasize, 0x60) {\n mstore(0, 0x20)\n mstore(0x20, 24)\n mstore(0x40, 'Insufficient return size')\n revert(0, 0x60)\n }\n _returndata_ptr := msize\n returndatacopy(_returndata_ptr, 0, returndatasize)\n ptr_bounds := add(_returndata_ptr, returndatasize)\n mstore(0x40, add(0x20, ptr_bounds))\n }\n }\n function getLength(uint _ptr) internal pure returns (uint length) {\n assembly { length := mload(_ptr) }\n }\n function doThrow(uint _ptr) internal pure {\n assert(getAction(_ptr) == THROWS);\n assembly { revert(_ptr, returndatasize) }\n }\n function doPay(bytes32 _exec_id, uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_paid) {\n require(msg.value > 0);\n assert(getAction(_ptr) == PAYS);\n _ptr += 4;\n uint num_destinations = getLength(_ptr);\n _ptr += 32;\n address pay_to;\n uint amt;\n while (_ptr <= _ptr_bound && n_paid < num_destinations) {\n assembly {\n amt := mload(_ptr)\n pay_to := mload(add(0x20, _ptr))\n }\n if (pay_to == address(0) || pay_to == address(this))\n revert('PAYS: invalid destination');\n address(pay_to).transfer(amt);\n n_paid++;\n _ptr += 64;\n emit DeliveredPayment(_exec_id, pay_to, amt);\n }\n ptr = _ptr;\n assert(n_paid == num_destinations);\n }\n function doStore(uint _ptr, uint _ptr_bound, bytes32 _exec_id) internal returns (uint ptr, uint n_stored) {\n assert(getAction(_ptr) == STORES && _exec_id != bytes32(0));\n _ptr += 4;\n uint num_locations = getLength(_ptr);\n _ptr += 32;\n bytes32 location;\n bytes32 value;\n while (_ptr <= _ptr_bound && n_stored < num_locations) {\n assembly {\n location := mload(_ptr)\n value := mload(add(0x20, _ptr))\n }\n store(_exec_id, location, value);\n n_stored++;\n _ptr += 64;\n }\n ptr = _ptr;\n require(n_stored == num_locations);\n }\n function doEmit(uint _ptr, uint _ptr_bound) internal returns (uint ptr, uint n_emitted) {\n assert(getAction(_ptr) == EMITS);\n _ptr += 4;\n uint num_events = getLength(_ptr);\n _ptr += 32;\n bytes32[] memory topics;\n bytes memory data;\n while (_ptr <= _ptr_bound && n_emitted < num_events) {\n assembly {\n topics := _ptr\n data := add(add(_ptr, 0x20), mul(0x20, mload(topics)))\n }\n uint log_size = 32 + (32 * (1 + topics.length)) + data.length;\n assembly {\n switch mload(topics)\n case 0 {\n log0(\n add(0x20, data),\n mload(data)\n )\n }\n case 1 {\n log1(\n add(0x20, data),\n mload(data),\n mload(add(0x20, topics))\n )\n }\n case 2 {\n log2(\n add(0x20, data),\n mload(data),\n mload(add(0x20, topics)),\n mload(add(0x40, topics))\n )\n }\n case 3 {\n log3(\n add(0x20, data),\n mload(data),\n mload(add(0x20, topics)),\n mload(add(0x40, topics)),\n mload(add(0x60, topics))\n )\n }\n case 4 {\n log4(\n add(0x20, data),\n mload(data),\n mload(add(0x20, topics)),\n mload(add(0x40, topics)),\n mload(add(0x60, topics)),\n mload(add(0x80, topics))\n )\n }\n default {\n mstore(0, 'EMITS: invalid topic count')\n revert(0, 0x20)\n }\n }\n n_emitted++;\n _ptr += log_size;\n }\n ptr = _ptr;\n require(n_emitted == num_events);\n }\n function getAction(uint _ptr) internal pure returns (bytes4 action) {\n assembly {\n action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n }\n }\n function setContext(bytes32 _exec_id, address _sender) internal {\n assert(_exec_id != bytes32(0) && _sender != address(0));\n exec_id = _exec_id;\n sender = _sender;\n }\n function store(bytes32 _exec_id, bytes32 _location, bytes32 _data) internal {\n _location = keccak256(_location, _exec_id);\n assembly { sstore(_location, _data) }\n }\n function read(bytes32 _exec_id, bytes32 _location) public view returns (bytes32 data_read) {\n _location = keccak256(_location, _exec_id);\n assembly { data_read := sload(_location) }\n }\n function readMulti(bytes32 _exec_id, bytes32[] _locations) public view returns (bytes32[] data_read) {\n data_read = new bytes32[](_locations.length);\n for (uint i = 0; i < _locations.length; i++) {\n data_read[i] = read(_exec_id, _locations[i]);\n }\n }\n}",
  "extract_feature": [
    "function createInstance(address _sender, bytes32 _app_name, address _provider, bytes32 _registry_id, bytes _calldata) external payable returns (bytes32 new_exec_id, bytes32 version) {\nrequire(_sender != 0 && _app_name != 0 && _provider != 0 && _registry_id != 0 && _calldata.length >= 4, 'invalid input');\nnew_exec_id = keccak256(++nonce);\nassert(getIndex(new_exec_id) == address(0));\naddress index;\n(index, version) = setImplementation(new_exec_id, _app_name, _provider, _registry_id);\nsetContext(new_exec_id, _sender);\nrequire(address(index).delegatecall(_calldata) == false, 'Unsafe execution');\nexecuteAppReturn(new_exec_id);\nemit ApplicationInitialized(new_exec_id, index, msg.sender);\nassert(new_exec_id != bytes32(0));\nif (address(this).balance > 0)\naddress(msg.sender).transfer(address(this).balance);\n}",
    "function exec(address _sender, bytes32 _exec_id, bytes _calldata) external payable returns (uint n_emitted, uint n_paid, uint n_stored) {\nrequire(_calldata.length >= 4 && _sender != address(0) && _exec_id != bytes32(0));\naddress target = getTarget(_exec_id, getSelector(_calldata));\nrequire(target != address(0), 'Uninitialized application');\nsetContext(_exec_id, _sender);\nrequire(address(target).delegatecall(_calldata) == false, 'Unsafe execution');\n(n_emitted, n_paid, n_stored) = executeAppReturn(_exec_id);\nif (n_emitted == 0 && n_paid == 0 && n_stored == 0)\nrevert('No state change occured');\nemit ApplicationExecution(_exec_id, target);\nif (address(this).balance > 0)\naddress(msg.sender).transfer(address(this).balance);\n}"
  ]
}]