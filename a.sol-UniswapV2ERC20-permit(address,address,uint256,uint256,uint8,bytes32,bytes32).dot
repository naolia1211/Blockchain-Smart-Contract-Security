digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->1;
1[label="Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(deadline >= block.timestamp,UniswapV2: EXPIRED)

IRs:
TMP_40(bool) = deadline >= block.timestamp
TMP_41(None) = SOLIDITY_CALL require(bool,string)(TMP_40,UniswapV2: EXPIRED)"];
1->2;
2[label="Node Type: NEW VARIABLE 2

EXPRESSION:
digest = keccak256(bytes)(abi.encodePacked(,DOMAIN_SEPARATOR,keccak256(bytes)(abi.encode(PERMIT_TYPEHASH,owner,spender,value,nonces[owner] ++,deadline))))

IRs:
REF_26(uint256) -> nonces[owner]
TMP_42(uint256) := REF_26(uint256)
REF_26(-> nonces) = REF_26 + 1
TMP_43(bytes) = SOLIDITY_CALL abi.encode()(PERMIT_TYPEHASH,owner,spender,value,TMP_42,deadline)
TMP_44(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_43)
TMP_45(bytes) = SOLIDITY_CALL abi.encodePacked()(,DOMAIN_SEPARATOR,TMP_44)
TMP_46(bytes32) = SOLIDITY_CALL keccak256(bytes)(TMP_45)
digest(bytes32) := TMP_46(bytes32)"];
2->3;
3[label="Node Type: NEW VARIABLE 3

EXPRESSION:
recoveredAddress = ecrecover(bytes32,uint8,bytes32,bytes32)(digest,v,r,s)

IRs:
TMP_47(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(digest,v,r,s)
recoveredAddress(address) := TMP_47(address)"];
3->4;
4[label="Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(recoveredAddress != address(0) && recoveredAddress == owner,UniswapV2: INVALID_SIGNATURE)

IRs:
TMP_48 = CONVERT 0 to address
TMP_49(bool) = recoveredAddress != TMP_48
TMP_50(bool) = recoveredAddress == owner
TMP_51(bool) = TMP_49 && TMP_50
TMP_52(None) = SOLIDITY_CALL require(bool,string)(TMP_51,UniswapV2: INVALID_SIGNATURE)"];
4->5;
5[label="Node Type: EXPRESSION 5

EXPRESSION:
_approve(owner,spender,value)

IRs:
INTERNAL_CALL, UniswapV2ERC20._approve(address,address,uint256)(owner,spender,value)"];
}
