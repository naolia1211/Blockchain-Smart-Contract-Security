digraph{
0[label="Node Type: ENTRY_POINT 0
"];
0->28;
1[label="Node Type: NEW VARIABLE 1
"];
1->2;
2[label="Node Type: NEW VARIABLE 2
"];
2->3;
3[label="Node Type: EXPRESSION 3

EXPRESSION:
(_reserve0,_reserve1) = getReserves()

IRs:
TUPLE_1(uint112,uint112,uint32) = INTERNAL_CALL, UniswapV2Pair.getReserves()()
_reserve0(uint112)= UNPACK TUPLE_1 index: 0 
_reserve1(uint112)= UNPACK TUPLE_1 index: 1 "];
3->4;
4[label="Node Type: NEW VARIABLE 4

EXPRESSION:
balance0 = IERC20Uniswap(token0).balanceOf(address(this))

IRs:
TMP_164 = CONVERT token0 to IERC20Uniswap
TMP_165 = CONVERT this to address
TMP_166(uint256) = HIGH_LEVEL_CALL, dest:TMP_164(IERC20Uniswap), function:balanceOf, arguments:['TMP_165']  
balance0(uint256) := TMP_166(uint256)"];
4->5;
5[label="Node Type: NEW VARIABLE 5

EXPRESSION:
balance1 = IERC20Uniswap(token1).balanceOf(address(this))

IRs:
TMP_167 = CONVERT token1 to IERC20Uniswap
TMP_168 = CONVERT this to address
TMP_169(uint256) = HIGH_LEVEL_CALL, dest:TMP_167(IERC20Uniswap), function:balanceOf, arguments:['TMP_168']  
balance1(uint256) := TMP_169(uint256)"];
5->6;
6[label="Node Type: NEW VARIABLE 6

EXPRESSION:
amount0 = balance0.sub(_reserve0)

IRs:
TMP_170(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.sub(uint256,uint256), arguments:['balance0', '_reserve0'] 
amount0(uint256) := TMP_170(uint256)"];
6->7;
7[label="Node Type: NEW VARIABLE 7

EXPRESSION:
amount1 = balance1.sub(_reserve1)

IRs:
TMP_171(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.sub(uint256,uint256), arguments:['balance1', '_reserve1'] 
amount1(uint256) := TMP_171(uint256)"];
7->8;
8[label="Node Type: NEW VARIABLE 8

EXPRESSION:
feeOn = _mintFee(_reserve0,_reserve1)

IRs:
TMP_172(bool) = INTERNAL_CALL, UniswapV2Pair._mintFee(uint112,uint112)(_reserve0,_reserve1)
feeOn(bool) := TMP_172(bool)"];
8->9;
9[label="Node Type: NEW VARIABLE 9

EXPRESSION:
_totalSupply = totalSupply

IRs:
_totalSupply(uint256) := totalSupply(uint256)"];
9->10;
10[label="Node Type: IF 10

EXPRESSION:
_totalSupply == 0

IRs:
TMP_173(bool) = _totalSupply == 0
CONDITION TMP_173"];
10->11[label="True"];
10->19[label="False"];
11[label="Node Type: NEW VARIABLE 11

EXPRESSION:
migrator = IUniswapV2Factory(factory).migrator()

IRs:
TMP_174 = CONVERT factory to IUniswapV2Factory
TMP_175(address) = HIGH_LEVEL_CALL, dest:TMP_174(IUniswapV2Factory), function:migrator, arguments:[]  
migrator(address) := TMP_175(address)"];
11->12;
12[label="Node Type: IF 12

EXPRESSION:
msg.sender == migrator

IRs:
TMP_176(bool) = msg.sender == migrator
CONDITION TMP_176"];
12->13[label="True"];
12->15[label="False"];
13[label="Node Type: EXPRESSION 13

EXPRESSION:
liquidity = IMigrator(migrator).desiredLiquidity()

IRs:
TMP_177 = CONVERT migrator to IMigrator
TMP_178(uint256) = HIGH_LEVEL_CALL, dest:TMP_177(IMigrator), function:desiredLiquidity, arguments:[]  
liquidity(uint256) := TMP_178(uint256)"];
13->14;
14[label="Node Type: EXPRESSION 14

EXPRESSION:
require(bool,string)(liquidity > 0 && liquidity != uint256(- 1),Bad desired liquidity)

IRs:
TMP_179(bool) = liquidity > 0
TMP_180(uint256) = 0 - 1
TMP_181 = CONVERT TMP_180 to uint256
TMP_182(bool) = liquidity != TMP_181
TMP_183(bool) = TMP_179 && TMP_182
TMP_184(None) = SOLIDITY_CALL require(bool,string)(TMP_183,Bad desired liquidity)"];
14->18;
15[label="Node Type: EXPRESSION 15

EXPRESSION:
require(bool,string)(migrator == address(0),Must not have migrator)

IRs:
TMP_185 = CONVERT 0 to address
TMP_186(bool) = migrator == TMP_185
TMP_187(None) = SOLIDITY_CALL require(bool,string)(TMP_186,Must not have migrator)"];
15->16;
16[label="Node Type: EXPRESSION 16

EXPRESSION:
liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY)

IRs:
TMP_188(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['amount0', 'amount1'] 
TMP_189(uint256) = LIBRARY_CALL, dest:Math, function:Math.sqrt(uint256), arguments:['TMP_188'] 
TMP_190(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.sub(uint256,uint256), arguments:['TMP_189', 'MINIMUM_LIQUIDITY'] 
liquidity(uint256) := TMP_190(uint256)"];
16->17;
17[label="Node Type: EXPRESSION 17

EXPRESSION:
_mint(address(0),MINIMUM_LIQUIDITY)

IRs:
TMP_191 = CONVERT 0 to address
INTERNAL_CALL, UniswapV2ERC20._mint(address,uint256)(TMP_191,MINIMUM_LIQUIDITY)"];
17->18;
18[label="Node Type: END_IF 18
"];
18->20;
19[label="Node Type: EXPRESSION 19

EXPRESSION:
liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0,amount1.mul(_totalSupply) / _reserve1)

IRs:
TMP_193(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['amount0', '_totalSupply'] 
TMP_194(uint256) = TMP_193 / _reserve0
TMP_195(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['amount1', '_totalSupply'] 
TMP_196(uint256) = TMP_195 / _reserve1
TMP_197(uint256) = LIBRARY_CALL, dest:Math, function:Math.min(uint256,uint256), arguments:['TMP_194', 'TMP_196'] 
liquidity(uint256) := TMP_197(uint256)"];
19->20;
20[label="Node Type: END_IF 20
"];
20->21;
21[label="Node Type: EXPRESSION 21

EXPRESSION:
require(bool,string)(liquidity > 0,UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED)

IRs:
TMP_198(bool) = liquidity > 0
TMP_199(None) = SOLIDITY_CALL require(bool,string)(TMP_198,UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED)"];
21->22;
22[label="Node Type: EXPRESSION 22

EXPRESSION:
_mint(to,liquidity)

IRs:
INTERNAL_CALL, UniswapV2ERC20._mint(address,uint256)(to,liquidity)"];
22->23;
23[label="Node Type: EXPRESSION 23

EXPRESSION:
_update(balance0,balance1,_reserve0,_reserve1)

IRs:
INTERNAL_CALL, UniswapV2Pair._update(uint256,uint256,uint112,uint112)(balance0,balance1,_reserve0,_reserve1)"];
23->24;
24[label="Node Type: IF 24

EXPRESSION:
feeOn

IRs:
CONDITION feeOn"];
24->25[label="True"];
24->26[label="False"];
25[label="Node Type: EXPRESSION 25

EXPRESSION:
kLast = uint256(reserve0).mul(reserve1)

IRs:
TMP_202 = CONVERT reserve0 to uint256
TMP_203(uint256) = LIBRARY_CALL, dest:SafeMathUniswap, function:SafeMathUniswap.mul(uint256,uint256), arguments:['TMP_202', 'reserve1'] 
kLast(uint256) := TMP_203(uint256)"];
25->26;
26[label="Node Type: END_IF 26
"];
26->27;
27[label="Node Type: EXPRESSION 27

EXPRESSION:
Mint(msg.sender,amount0,amount1)

IRs:
Emit Mint(msg.sender,amount0,amount1)"];
28[label="Node Type: EXPRESSION 28

EXPRESSION:
lock()

IRs:
MODIFIER_CALL, UniswapV2Pair.lock()()"];
28->1;
}
